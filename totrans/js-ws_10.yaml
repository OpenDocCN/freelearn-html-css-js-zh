- en: 10\. Accessing External Resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to describe AJAX, REST, JSON, and
    HTTP to APIs; perform service calls using a library such as jQuery and native
    XMLHttpRequest and be familiar with the pros and cons of each approach; use an
    external API to retrieve data using JavaScript; use some jQuery functionality
    for the UI and events; and identify cross-domain-capable APIs and use cross-domain
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will cover various approaches to using AJAX to obtain data,
    primarily from RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned about Node.js, which runs on the server-side.
    This chapter will cover the other side of services â€“ you will learn how to call
    them from the client-side. There's a good chance that services being accessed
    are, in fact, implemented in Node.js, but it is common for them to run on other
    platforms as well, such as Java, C#, and Python.
  prefs: []
  type: TYPE_NORMAL
- en: Web pages are static and of limited use without fresh data. Web services are
    a set of technologies that provide standards for your web page to communicate
    with other servers and sites to exchange data.
  prefs: []
  type: TYPE_NORMAL
- en: To enable services implemented in different languages to communicate with each
    other, they need to have common rules regarding how the requests and responses
    being exchanged should look and be structured. For this reason, there are a number
    of different standards and approaches to web services out there that define the
    format of data being exchanged. The most popular combination used for websites
    today is **REST** with **JSON**, which stands for **Representational State Transfer**
    with **JavaScript Object Notation**. This chapter will describe in detail all
    you need to know in order to call REST services to provide data for your web pages.
  prefs: []
  type: TYPE_NORMAL
- en: Before web services came about, web servers needed to gather all required data
    on the server-side before rendering the final HTML they would serve. To get a
    fresh update, the entire page had to be redrawn. The user experience of the pages
    was constantly affected, especially if the data involved complex calculations
    or queries, as the user would need to wait until redrawing was complete and didn't
    have the ability to use any other functionality on the page in the meantime.
  prefs: []
  type: TYPE_NORMAL
- en: For example, think of a page that displays stock quotes or email messages. In
    the old days, you would have to reload or refresh the whole page in the browser
    to see whether there were any updates to the stock quotes or whether you had any
    new mail. Web services and dynamic HTML changed this, as it is now common for
    pages to only update portions at a time without needing to reload and redraw the
    entire page.
  prefs: []
  type: TYPE_NORMAL
- en: Note that many web services use a different technology, known as **SOAP**, which
    stands for **Simple Object Access Protocol** with an **XML** (**eXtensible Markup
    Language**) format. There are some emerging standards as well that are gaining
    traction, such as Google's protocol buffers. While each of these technologies
    has its advantages and disadvantages and use cases where they are appropriate,
    we will only focus on REST and JSON in this book as they are the most widespread
    methods in use today.
  prefs: []
  type: TYPE_NORMAL
- en: JSON
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you have been using JavaScript up until now in this book, you should feel
    right at home with the syntax of JSON, as it is derived from JavaScript and closely
    resembles object structures you have already learned in previous chapters. JSON,
    usually pronounced like the name Jason, is lightweight, easy for humans to read
    and write, and easy for machines to parse and work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two main data structures used in JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: A collection of key-value pairs enclosed in curly-braces `{ }`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A list of values enclosed in square brackets `[ ]`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s a sample JSON object that shows different structures and value types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Each key-value pair has the key wrapped in double quotation marks, as in `"key"`,
    and a colon is placed between the key and the value. For example, the following
    would be incorrect, as the key does not have double quotation marks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Keys must be unique within each object, can be any valid string, and allow space
    characters (though it is not always the best idea to use spaces in keys, as programming
    is sometimes easier if other characters, such as underscores, are used instead).
    Each key-value pair is separated by a comma.
  prefs: []
  type: TYPE_NORMAL
- en: 'The values can be one of the following types:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"twitter_username": "@LeoDiCaprio"` in the preceding example. String values
    are enclosed in double-quotes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"year": 1997` in the preceding example. Sign (+ or -) and decimal fractions
    are also permitted. Numbers are not enclosed in double-quotes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"active": true` in the preceding example (Boolean values are not enclosed
    in double-quotes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Nested array**: This is a value that is itself an array of strings. Each
    of the strings is enclosed in double-quotes and separated by a comma. (An array
    is used here to allow any number of costars to be specified). Have a look at the
    example block:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`famous_movies` list. Each element in the array is a nested object that contains
    fields related to a movie, including `title, director, costars`, and `year`. The
    nested objects in the array are separated by a comma.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"eye_color": null` in the preceding code snippet. `Null` can be used to indicate
    an unknown or inapplicable value. `Null` is indicated with no quotes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There is some debate on how to best represent such scenarios, with many opinions
    being that if a value is unknown, the field should not appear at all rather than
    assigning a value of `null`. We can leave this debate aside for the purposes of
    this book.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Whitespace (spaces, tabs, and carriage returns) is generally ignored in JSON
    (except in strings) and can be used liberally to increase readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some important limitations with JSON syntax as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Values must be one of the types previously specified, and cannot have more complex
    expressions, calculations, or function calls.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Comments are not permitted.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **Application Programming Interface** (**API**) defines the formats and rules
    of how programs talk to each other. REST is a software architectural style that
    has become the de facto standard for most web services used by websites today.
    In this book, rather than getting bogged down with the academic theory behind
    REST, we'll focus on the practical aspects of how to invoke and use RESTful services
    from the client-side.
  prefs: []
  type: TYPE_NORMAL
- en: What Is HTTP?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to understand REST, it is important to touch a bit on the underlying
    technology of the World Wide Web and how resources are identified and communicated.
    Very briefly, **HyperText Transfer Protocol** (**HTTP**) defines what actions
    web browsers and servers should take in response to various commands.
  prefs: []
  type: TYPE_NORMAL
- en: 'Resources such as HTML pages, images, documents, or video files are identified
    by using a **Uniform Resource Locator** (**URL**). URLs have the following parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1: Parts of a URL'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.1: Parts of a URL'
  prefs: []
  type: TYPE_NORMAL
- en: '`http` (insecure) or `https` (for secure communication).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Host Name**: Specifies the location of the IP address or domain name.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`80` is assumed by default for `http` (`443` for `https`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Path**: To a file or location on the webserver.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`?`). The parameter name is separated from the value by an equals sign (`=`).
    Multiple parameters can also be present, usually separated by an ampersand (`&`).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most REST APIs favor URLs that combine identifiers with other elements of the
    URL rather than using parameters in the query string, for example, a URL such
    as `http://myserver.com/user/1234`.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding URL code is often preferred over `http://myserver.com/user?user_id=1234`.
  prefs: []
  type: TYPE_NORMAL
- en: But this latter style is still perfectly valid and definitely considered RESTful!
  prefs: []
  type: TYPE_NORMAL
- en: 'On a basic level, REST utilizes HTTP verbs to perform actions with data or
    resources: `GET` is used to retrieve a resource, `PUT` is used to update a resource,
    `POST` is used to create a new resource, and `DELETE` is used to remove data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'HTTP requests frequently require different values to be passed through headers
    as well. The HTTP header format contains name-value pairs separated by a colon.
    For example, to indicate that you desire the data in your HTTP response to be
    in JSON format, it is often necessary to provide the following header:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: TheSportsDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many websites and services that provide data of various types through
    APIs. TheSportsDB ([https://www.thesportsdb.com](https://www.thesportsdb.com))
    is one such site that provides sports-related data through its simple JSON REST
    API.
  prefs: []
  type: TYPE_NORMAL
- en: 'TheSportsDB is a community database of sports data and artwork that covers
    hundreds of professional and non-professional sports, such as soccer, basketball,
    baseball, tennis, cricket, and motorsport. It provides live scores, logos, rosters,
    stats, schedules, and much more:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2: Home page and logo of TheSportsDB'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.2: Home page and logo of TheSportsDB'
  prefs: []
  type: TYPE_NORMAL
- en: Many APIs require users to obtain an API key in order to use their services.
    The good news is access to TheSportsDB API is free with a test API key, `1`, for
    educational purposes or smaller applications. (Commercial applications and larger
    users are encouraged to sign up if the API will be used frequently. Donations
    are also accepted, though are not required, through Patreon.)
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3: Sample page showing how the data from various API calls is'
  prefs: []
  type: TYPE_NORMAL
- en: combined to present team info
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.3: Sample page showing how the data from various API calls are combined
    to present team info'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The full API is documented at https://packt.live/2NuwMtd.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.01: Using a REST API to Make Calls'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get a good feel for this REST API and how it works before learning how to
    invoke it programmatically, we are going to make some calls right in our web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Calls to TheSportsDB API have `https://www.thesportsdb.com/api/v1/json/{APIKEY}/resource_path`
    as the base form. Since we are using the free test API key, substitute `{APIKEY}`
    with the value of `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a summary of the API calls we will be using in the exercises.
    A string of `XXXX`''s indicate where an appropriate identifier or value should
    be substituted:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/all_leagues.php`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookup_all_teams.php?id=XXXX`, where
    `XXXX` is a value of `idLeague` from the list of leagues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/eventslast.php?id=XXXX`, where `XXXX`
    is a value of `idTeam` from the list of teams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookupteam.php?id=XXXX`, where,
    again, `XXXX` is a value of `idTeam` from the list of teams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are other useful methods the API provides (but will not be specifically
    covered here):'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/searchteams.php?t=XXXX`, where `XXXX`
    is a search string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookup_all_players.php?id=XXXX`,
    where `XXXX` is a value of `idTeam` from the list of teams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookupplayer.php?id=XXXX`, where
    `XXXX` is a value of `idPlayer` from the list of players'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookuphonors.php?id= XXXX`, where
    `XXXX` is a value of `idPlayer` from the list of players'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/eventsnext.php?id= XXXX`, where
    `XXXX` is a value of `idTeam` from the list of teams'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookupevent.php?id=XXXX`, where
    `XXXX` is an `idEvent` from the list of events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/eventsnextleague.php?id=XXXX`, where
    `XXXX` is a value of `idLeague` from the list of leagues'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/eventsday.php?d=2019-10-10`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In order to obtain useful data regarding our favorite sports team, it is necessary
    to first look up the ID for that team. The easiest way to do this is by obtaining
    a list of all available leagues, finding the ID we are interested in, then doing
    another call with this ID.
  prefs: []
  type: TYPE_NORMAL
- en: '`TheSportsDB` provides the following service call to obtain our list of all
    available leagues. The following instructions are for Google Chrome, but any major
    browser supports similar functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Launch a new instance of the browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the *F12* key to launch the debugger (or select `More Tools` | `Developer
    Tools` from the menu).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select the `Network` tab and make sure the circle icon is red (to indicate
    that network traffic is being logged). Your screen should now look similar to
    this:![Figure 10.4: Network tab in the debugger of Chrome Developer Tools'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_10_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.4: Network tab in the debugger of Chrome Developer Tools'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type `https://www.thesportsdb.com/api/v1/json/1/all_leagues.php` as the URL
    into the address bar and press *Enter*. Your screen should now look similar to
    this:![Figure 10.5: Raw JSON response with league data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_10_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.5: Raw JSON response with league data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice the JSON response in the main window lists all the league data, but it
    is unformatted and not very user-friendly. Luckily, the debugger provides a nicer
    way of viewing the data in a collapsible tree. In the `Network` tab, select the
    line with `all_leagues.php` and select the `Preview` tab.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should see the first line of JSON data in your `Preview` window. Place your
    mouse over this line and right-click the mouse button to open the context menu.
    From the context menu, select `Expand recursively`. You will now see a lot more
    data, like the screenshot that follows. Note that you may need to select `Expand
    recursively` two or three times to get the data to fully expand.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s find the data for the league we are interested in. Press *Ctrl* + *F*
    and type `NBA` to find the entry for the National Basketball Association. Your
    screen should now look similar to this:![Figure 10.6: Expanded and formatted JSON'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_10_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 10.6: Expanded and formatted JSON'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Focusing on the entry for our league, the full JSON for the entry looks like
    this (formatted for clarity):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This entry only has a few key-value pairs, but with the `idLeague` key, we now
    know that the league ID of `4387` represents the NBA in this API. This ID can
    now be used for another service call to obtain further details regarding the NBA.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Following a similar process to the one previously described, enter the following
    as the URL:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`https://www.thesportsdb.com/api/v1/json/1/lookup_all_teams.php?id=4387`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice the `id` parameter placed at the end of the URL, for which we plugged
    in the ID of `4387` that we found in the previous steps.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Once you have expanded the result set, search for the word `Knicks`. This time,
    you will need to search through several of the matches until you find the correct
    one, as the word `Knicks` appears in several irrelevant entries as part of long
    descriptions. Also, there will be many more key-value pairs available in the resulting
    entry compared to last time, but we will only focus on some of them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The relevant JSON looks something like this, with many of the fields removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, we see the team ID and name in the `idTeam` and `strTeam` keys, followed
    by other fields related to team history, stadium info, and website and social
    media URLs.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Finally, there are links to various available images for the team badge, jersey,
    logo, and banner, which we can use to display on our site if we wish. We will
    be making use of these values in the upcoming exercises.
  prefs: []
  type: TYPE_NORMAL
- en: HTTP Headers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While we have the network monitor open, it would be a good time to take note
    of some other useful information. Click on the `Headers` tab, and you will see
    all the HTTP request headers, response headers, and some other details that were
    involved in the interaction, similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7: HTTP Headers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.7: HTTP Headers'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are of particular note:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Request Method: GET`: URLs entered into the address line of a browser are
    `GET` by default.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Status Code: 200`: This indicates the interaction was successful. There are
    several status codes, and the following are some of the most common ones. The
    later status codes, with a number of `400` or greater, indicate various error
    conditions that occurred:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.8: Status code and their meanings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.8: Status code and their meanings'
  prefs: []
  type: TYPE_NORMAL
- en: '`content-type: application/json; charset=utf-8`: This indicates to the caller
    that the response is in JSON format in UTF-8 encoding.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Remote Address: 104.18.46.13:443`: This indicates the IP address and port
    of the remote server that processed the request.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`access-control-allow-origin: *`: This is a header that enables cross-site
    requests. More on this in a later section.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`accept: text/html,application/xhtml+xml,application/xml;â€¦`: This header advises
    the server what formats the caller would accept for the response. This requires
    a bit of explanation in our case. TheSportsDB is designed to be a JSON-only API,
    so even though JSON is not indicated in the list of accepted formats the browser
    sent, the response is still in JSON. (This is not the case for other APIs that
    may support multiple formats such as HTML, XML, or JSON. So, this header would
    be used for the caller to indicate which format they desire.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'There are other available HTTP headers that were not part of this request but
    deserve to be mentioned. To briefly summarize some of the most common headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Authorization`: Many resources are protected and require credentials to access
    them, such as with a user/password combination or a token. This header is used
    to send the credentials in various formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cache-Control`: Static resources or data that is not expected to change in
    the near future can be cached by the browser or client, so the resource is not
    fetched unnecessarily if requested again. This response header indicates whether
    caching is allowed. Some of the most common values are `no-cache` and `max-age=<seconds>`,
    which indicate whether the object can be cached and for how long, respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Last-Modified`: This response header indicates when the object was last modified.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Keep-Alive`: Controls how long a persistent connection should stay open. A
    persistent connection is a special type that is used when multiple requests are
    made with the same connection, making it unnecessary to close and re-establish
    connections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Cookie`/`Set-Cookie`: A cookie is a small piece of data sent by a website
    to save state or track user authentication, devices, and activity. The next time
    the browser or client makes a request to the server, the previously sent cookie
    value is included.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we introduced the basics of HTTP, JSON, and REST web services.
    We learned about the parts of a URL, HTTP status codes, HTTP headers, and how
    to use the browser debugger to invoke REST services and glean the data we need.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will introduce AJAX and how to invoke services with JavaScript
    code using the jQuery library.
  prefs: []
  type: TYPE_NORMAL
- en: AJAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: AJAX stands for Asynchronous JavaScript and XML and is an umbrella term for
    a set of technologies to communicate with servers and other sites in various formats,
    including JSON and XML.
  prefs: []
  type: TYPE_NORMAL
- en: Most JavaScript is synchronous, which means there is only a single thread of
    execution, and only one operation can be executed at a time. If browsers were
    truly synchronous, websites would be a drag to use, as only one resource would
    be able to load at a time. Imagine if the images on websites only drew one at
    a time after loading! Sometimes, requests can take a long time, such as to do
    a calculation or a complex database query. You wouldn't want your site to become
    non-responsive while a request is processing!
  prefs: []
  type: TYPE_NORMAL
- en: Luckily, service calls were designed to allow multiple calls to occur asynchronously.
    Also, in between requests being made and a response is received, the main thread
    of execution can continue to execute and potentially issue more service calls.
    This is the *"A"* in *AJAX*.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has developed several techniques and approaches to accomplish synchronicity,
    and the most straightforward and widespread is by using callbacks. This chapter
    will use callbacks, but other techniques, such as promises, will be explored in
    *Chapter 15, Asynchronous Tasks*
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript has a means of natively performing service calls via an object called
    `XMLHttpRequest`. Normally, there is a preference to use native functionality
    that is built-in to JavaScript, but in my opinion, `XMLHttpRequest` is too low-level
    and difficult to use most of the time. This is a use case where utilizing a library
    makes more sense and really simplifies your code. (However, we will also cover
    `XMLHttpRequest` later in this chapter.)
  prefs: []
  type: TYPE_NORMAL
- en: There are several libraries available that make REST calls, and we'll start
    with exploring jQuery's `ajax()` and `getJSON()` calls.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'jQuery is one of the most popular JavaScript libraries out there. It is lightweight
    and greatly simplifies programming JavaScript for many functions related to websites.
    These include:'
  prefs: []
  type: TYPE_NORMAL
- en: HTML/DOM manipulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS styling helpers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: HTML event handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AJAX service call helpers and much more
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 10.9: Home page of the jQuery project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.9: Home page of the jQuery project'
  prefs: []
  type: TYPE_NORMAL
- en: For HTML/DOM and CSS manipulation, jQuery syntax typically follows a pattern
    of *selecting* HTML elements and calling methods to perform *actions* on the elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic syntax is `$(selector).action()`, where:'
  prefs: []
  type: TYPE_NORMAL
- en: The `$` sign defines/accesses jQuery.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`(selector)` locates HTML elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`action()` denotes the jQuery action to be performed on the elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Selectors start with the dollar sign and parentheses: `$()`. They follow a
    very similar syntax to selecting elements in CSS code. The most basic case for
    using a selector is an element by HTML ID, for which you prefix the ID with a
    pound sign (`#`). For example, if you start with the following HTML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `$("#test_div"").hide()` code would cause the `<div>` with an ID of `test_div`
    to be hidden from view. Multiple actions can also be performed in a chained fashion
    on the same elements. For example, `$("#test_div"").html(""Hello World"").show()`
    would assign the text `Hello World` as the body of the `<div>` and cause it to
    reappear.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are common methods provided by jQuery for UI purposes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10: Common jQuery Methods for UI purpose'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.10: Common jQuery Methods for UI purpose'
  prefs: []
  type: TYPE_NORMAL
- en: 'jQuery can also be used to define functions to handle events on HTML elements;
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code would cause an alert with the message `Button Clicked` to
    appear if the button was clicked. Also note that a class selector was used in
    this case, not one to select by ID as was used previously. Class selectors start
    with a period (`.`) and result in selecting all elements in the document that
    have that class in its list of classes (in this case, only one element).
  prefs: []
  type: TYPE_NORMAL
- en: It is also possible to select multiple elements by type, attributes, values,
    and much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are common methods provided by jQuery for event handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.11: Common jQuery methods for event handlers'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.11: Common jQuery methods for event handlers'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, jQuery offers a complete suite of helpers to perform AJAX service calls.
    These will be introduced in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: The previous paragraphs were only a brief introduction to jQuery, but there
    are many good tutorials and resources available to learn about it in more depth.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.02: Using AJAX and the jQuery ajax() Method to Invoke a Service'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we understand the mechanics of HTTP and REST, we are ready to write
    some code.
  prefs: []
  type: TYPE_NORMAL
- en: jQuery has very nice methods available that greatly simplify AJAX interactions.
    In this exercise, we will first use the `$.ajax()` method to make a TheSportsDB
    service call to find out how our favorite team scored in its last game. We will
    use the team ID obtained in the previous section as a parameter.
  prefs: []
  type: TYPE_NORMAL
- en: First, we enter the HTML code. Open a text editor or IDE and create a new file
    (`exercise2.html`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `<html>` tag and the `<head>` element, which simply includes the JavaScript
    files for the jQuery library and our JavaScript source file, which will be shown
    shortly using the file `exercise2.html:`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the `<body>` tag. The `<table>` contains the HTML tags to display
    the last game data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use a table to aid the layout. The table is initially specified with a style
    of `display: none` since the data is incomplete when the page is loaded, and we
    don''t want it to be shown yet. We will make it visible only once the service
    call returns and provides us with the data.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Fill in the table rows and columns until the end of the HTML:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Most of the table columns are given IDs such as `away_team` and `away_score`
    so they can be referenced later to fill in the data once available. This also
    allows us to treat each value separately and define different styling for each
    if we desire.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finally, we get to the actual JavaScript code. Save the first file as `exercise2.html`
    and create a new file in the text editor or IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enter the first line of the file `exercise2.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All jQuery functions begin with the dollar sign, `$`, as a shortcut, followed
    by a dot and the function name. The `$(document).ready()` function is called once
    the page is fully loaded. It's important to use this function here, since this
    JavaScript file was included in the document via a `<script>` tag in the `<head>`
    section of the HTML before the `<body>` tag. This code could potentially be loaded
    and executed before the full body of the HTML is parsed and processed. If we did
    not enclose our logic in a `$(document).ready()` function, there is potential
    for errors if an HTML element is referenced that hasn't been loaded yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Start the `$.ajax()` call as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `$.ajax()` call includes a listing of various settings. The `method` setting
    indicates that the type of call we desire is `GET`. (In truth, it is not really
    necessary to specify the `method` setting as `GET` is the default value if it
    is not present. But sometimes it is more beneficial to be more explicit.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We next enter the `dataType` setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This specifies that we expect the call response to be in JSON format, and to
    return the JSON parsed to a JavaScript object. This also causes a request header
    similar to `Accept: application/json` to be sent.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type the `url` setting next, which indicates the URL for our call:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next is the `data` setting:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `data` setting indicates the parameters that should be sent in the request.
    Since this is a `GET`, under the hood, jQuery will add the parameter key-value
    pairs to the URL query string, resulting in `?id=134862` in this case. We could
    have added this value to the URL ourselves if we wanted but specifying parameters
    in the `data` setting allows the parameters to be separate from the URL itself.
    Another reason is so that the library will handle any URL encoding needed for
    more complex values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, begin the `success` function, which is a callback function called by
    jQuery once the service call returns with a response. By this point, jQuery will
    have processed the response and parsed the JSON into a JavaScript object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This `eventslast.php` service call returns the last five events for the team,
    ordered by latest date first, in the `data.results[]` array. However, for our
    purposes, we only require the latest game. There is a quirk in the API we need
    to account for: if the game is currently in progress, the event will be present
    in the array, but the score may not have a value yet. For our page, we''d prefer
    to only show games that actually have a score. Enter the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We use the `data.results.find()` function to iterate through the array and
    locate the first element with a score. Specifically, we look for the first event
    for which the `intAwayScore` and `intHomeScore` values are non-null. We will next
    set various table cell data with the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These lines set the table cell corresponding to the ID to the specified value.
    HTML elements can be selected by ID in jQuery by placing a pound (`#`) character
    before the ID. So, for example, `$("#game_date")` would result in `<td>` with
    the `game_date` ID being selected, and method calls that come afterward will apply
    to that element. Finally, the `html()` call would result in the value being assigned
    to that table cell.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once all the data is assigned in the table, we are finally ready to show the
    table to the user. Enter the following final code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'jQuery has a `show()` function, which results in the `display: none` style
    being made visible. So, `$("#game_table").show()` would select the table represented
    by the `game_table` ID and cause it to show.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the file as `exercise2.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Load the `exercise2.html` file into a browser. The output should look something
    like the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12: Result of exercise 10.02'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.12: Result of exercise 10.02'
  prefs: []
  type: TYPE_NORMAL
- en: Note there is no styling yet (but that will be added in the next exercise).
    We can see the results of the favourite team scored using the `$.ajax()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced AJAX and the jQuery `ajax()` method to invoke
    a service. We also introduced the basic jQuery functions to add dynamic content
    to HTML elements and show/hide them as needed.
  prefs: []
  type: TYPE_NORMAL
- en: In the next topic, we will go further and use the results of one service as
    an input to another service call. We will also invoke multiple services asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 10.03: More AJAX and Some CSS Styling'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous exercise was a good starting point, but now we''d like to build
    on it to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use the results obtained from the first service call to show additional items
    related to the game and teams, such as team logos.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Make the site more visually appealing by adding CSS styling.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We''ll enhance the code in these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open a text editor or IDE and create a new file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'First, add the `<html>` tag and the `<head>` element. It is almost the same
    code as in *Exercise 10.02: Using AJAX and the jQuery ajax() Method to Invoke
    a Service*, but with the addition of a stylesheet using the file `exercise3.html`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add `<body>`. In `<table>`, the first `<tr>` row is the same as *Exercise
    10.02: Using AJAX and the jQuery ajax() Method to Invoke a Service*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the next table row. This is new code and has two `<img>` elements that
    contain the team''s banner images. Also, notice that these images have also been
    marked with `class="team_banner"`, as we will define CSS styles for them later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last row and the remainder of the HTML is the same as the last exercise
    as well, as are the slots where the home and away scores will be displayed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the file and create a new one for the JavaScript code. Copy the initial
    code from the previous exercise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'A cool feature would be to apply special styling to the winning score, or to
    both scores in the event of a tie. We do this by assigning a dynamic style to
    the appropriate score element with the following code. Firstly, add the Boolean
    expressions to determine whether the home team had the winning score or there
    was a tie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If the home score is greater than the away score, then `homewinner` will equal
    `true`. Notice you need to call `parseInt()` to convert the data values to integers
    before performing the comparison, as the service returns the scores as string
    types.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Notice the expression with the conditional ternary operator. This shortcut
    has the same effect as the following code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This can actually be improved a bit further if we wish. jQuery has a function
    called `toggleClass()` for this specific use case where a class should be added
    conditionally. This code can be rewritten as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`$("#home_score").html(homeScore)`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`.toggleClass("winning_score", homeWinner || tie);`'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The `toggleClass()` method takes two parameters. The first parameter is the
    name of the class that will be conditionally added (or removed). The second parameter
    is the Boolean value or expression itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we add the code to get the team''s banner images:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `lastGame.idHomeTeam` and `lastGame.idAwayTeam` fields contain the IDs of
    the home and away teams of the most recent game. Using these IDs, we are going
    to call the `getTeamImage()` function, which will load the banner image for each
    of the teams, passing in the HTML IDs of the images as well. (This function will
    be defined soon.)
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Type in the remainder of the function, which is the same as in the last exercise,
    to actually show the table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we come to the `getTeamImage()` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once the exercise is complete, the final result should look something like
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.13: Final result of exercise'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.13: Final result of exercise'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a number of items to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We used `$.getJSON()` instead of `$.ajax()` this time. The `$.getJSON()` function
    is a shortcut that can be used for requests that are `JSON GET`. Using this shortcut,
    `dataType="json"` is assumed by default. There is no need to specify the URL,
    data parameters, and `success` function as separate settings, as the signature
    of the function is the following, with the brackets indicating that the last two
    parameters are optional: `$.getJSON( url [, data ] [, success ] )`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`imageId` is passed in to represent the ID of the HTML image element that will
    be set. We will use jQuery to select this image element and call `attr("src",
    value)`, which is jQuery''s utility method to set the `src` field of the `<img>`
    HTML element (similar to `<img src="img/â€¦."/>`). We will set this `src` with the
    value returned by the service call in the `teamData.strTeamBanner` element. Setting
    the `src` field will trigger the browser to load the corresponding image dynamically.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$.getJSON()` is an asynchronous call, which means that after the request is
    made, the browser will not wait for the response and execution will continue even
    while the service call is in progress (and execute the `success` callback when
    the response is received). The implication of this is that the calls to `getTeamImage()`
    will effectively issue two simultaneous service calls and not lock the browser
    while the requests are in flight.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will now briefly cover the CSS and styling that was added to the page in
    the preceding exercise to make it visually appealing. As this is not really a
    book on CSS, we will only give a brief overview. (There are many excellent books
    and resources available that cover CSS in depth.)
  prefs: []
  type: TYPE_NORMAL
- en: 'The stylesheet is included in the head element with the following tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The contents of the CSS file follow here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `#game_table` selector indicates that all styles in this block will apply
    to the HTML element with an ID of `game_table`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Places a border around the table to make it appear more contained.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We move the `display:none` style (to prevent display until the data is loaded)
    into the stylesheet itself, to keep the HTML code less cluttered of styling code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `#game_table td` selector indicates that the styles in the block will apply
    to all `<td>` elements that appear within the table with an ID of `game_table`.
    Here, we are saying that all text in table rows should be aligned to the right.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A comma in the selector allows you to select multiple elements. Here, we are
    indicating that scores should have a larger, 24-pixel font.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selectors that begin with a dot (such as `.team_banner` here) are a different
    type of selector. This is a `class` selector, which would apply to all HTML elements
    that have `class="team_banner"` specified.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The banner images from the server are quite large, but we only want a scaled-down
    image of 275 x 50 pixels.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A distinctive style that indicates the winning score in green and bold.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the last section, we explored different types of responses from services
    (JSON and images) and how to use jQuery to display them using the helpers for
    dynamic DOM manipulation. We also saw how to use CSS to add colors, fonts, and
    other styles to make our screen more visually appealing.
  prefs: []
  type: TYPE_NORMAL
- en: Other Libraries and XMLHttpRequest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section explores other approaches to AJAX with JavaScript. The approach
    to making REST calls using jQuery and callbacks is just one of many different
    options available and was presented first as it's the most straightforward and
    easy-to-understand option for novice users. This is not to say the approach is
    not powerful though. And it is really all that is needed in many cases. Remember
    that jQuery offers other functionality you may want to use in your application
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Axios and the Fetch API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point in the book, we'd like to mention two other popular choices that
    may be appropriate to be used in your projects, Axios and the Fetch API. These
    use advanced concepts such as promises, so they will not be covered here but will
    be covered in *Chapter 15, Asynchronous Tasks* of the advanced module. (Note that
    even jQuery itself offers variations on the AJAX methods that return promises
    instead of using callbacks, but this usage is not in the scope of this chapter
    either.)
  prefs: []
  type: TYPE_NORMAL
- en: But for now, we'll compare jQuery with the native `XMLHttpRequest` JavaScript
    object in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'For Comparison: XMLHttpRequest and jQuery'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`XMLHttpRequest` is a low-level class built into JavaScript to handle service
    calls. Despite having XML in its name, `XMLHttpRequest` can actually be used for
    other protocols as well, including JSON and HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is equivalent code to *Exercise 10.02: Using AJAX and the jQuery
    ajax() Method to Invoke a Service* so you can compare how code using `XMLHttpRequest`
    looks in comparison to that of jQuery (`xml_http_request_example.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: HTML part is the same as above in *exercise 10.02* in file `exercise2.html`,
    but omit the jQuery lib in `<head>` and change the `js` script `src` file to `xml_http_request_example.js`
    rather than `exercise2.js`
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s examine the preceding example in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'When using `XMLHttpRequest`, we need to append query parameters ourselves to
    the end of the URL. Here, it is straightforward to do so, since the value is just
    a simple number, but more complex values will require HTTP encoding by calling
    `encodeURI()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We instantiate the `XMLHttpRequest` object and call the open method, specifying
    the method (`GET`, `POST`, and so on) and the URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This low-level API doesn''t take care of setting headers like jQuery did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the callback function that will be called when there is a ready state
    change. There are a number of states the request can have, so we need to check
    the current state, as in the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Unlike the jQuery implementation, there is no `success()` function that gets
    called. We have to check the `readyState` and `status` code explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `readyState` of `4` indicates the request finished and the response is ready.
    Possible states are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`0`: Request not initialized'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`1`: Server connection established'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`2`: Request received'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`3`: Processing request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`4`: Request finished, and response is ready'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A `status` of `200` indicates `OK`. See the *HTTP Headers* section for a list
    of the most common HTTP status codes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike with jQuery, we need to parse the JSON text ourselves by calling `JSON.parse()`
    from the response field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The `document.getElementById()` function is the native way to select DOM elements
    in JavaScript by ID (equivalent to jQuery''s `$("#game_date")` function). You
    would set the text for the element by setting the `innerHTML` field directly (rather
    than calling an `html()` function as in jQuery):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Setting `style.display` is the native way to make a hidden element visible
    again, equivalent to jQuery''s `show()` method (though obviously not as simple):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The request does not actually get sent until the `send()` method is actually
    invoked, so it is important we do not forget to call it. (Unlike jQuery, where
    the request is automatically sent.)
  prefs: []
  type: TYPE_NORMAL
- en: Using jQuery and XMLHttpRequest for POST Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using `$.ajax()` for `POST` requests with regular parameters is much the same
    as for `GET`, apart from specifying `method="POST"`. However, a `POST` request
    has an additional capability â€“ sending the request data in `JSON` format rather
    than the default `''application/x-www-form-urlencoded''` content type. If you
    wish to do so, the `contentType` setting should be set to `''application/json''`
    and the data object should be wrapped in `JSON.stringify()`. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Like `$.getJSON()`, jQuery also provides a shortcut for `POST` requests, called
    `$.post()`. It has one additional parameter, though, to indicate the data type
    of the response. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'For `XMLHttpRequest`:'
  prefs: []
  type: TYPE_NORMAL
- en: If you are just sending standard parameters, use `setRequestHeader("Content-Type",
    "application/x-www-form-urlencoded")` and send the encoded parameters when calling
    `send()`. (You may need to also call `encodeURI()` if your data is complex.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you are sending your input as JSON, use `setRequestHeader("Content-type",
    "application/json")` and send the data wrapped in `JSON.stringify()` when calling
    `send()`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For either method, one caveat is that the return code from the service will
    frequently be `201 (Created)` rather than `200 (OK)`, so you want to make sure
    your code looks out for the correct return code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Cross-Domain Requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When selecting or implementing a REST API, there is an important rule to be
    aware of that can impact whether the API can be used for your site. Browsers have
    a security feature known as the **Same Origin Policy**. This policy only allows
    scripts running on a site to access data from URLs on the same site with no specific
    restrictions but prevents scripts from accessing data that is hosted on a different
    domain. The reason for this policy is to prevent different types of attacks unscrupulous
    people can make by exploiting browser security weaknesses to steal your data or
    invoke malicious service calls.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if your page is hosted at [https://www.mygreatsite.com/foo.html](https://www.mygreatsite.com/foo.html),
    you would be able to access data or call the service with a URL such as [https://www.mygreatsite.com/my_data.json](https://www.mygreatsite.com/my_data.json).
    However, if the domain differs, even just in a different subdomain such as [https://www.foobar.mygreatsite.com/my_data.json](https://www.foobar.mygreatsite.com/my_data.json),
    the browser would respond with an error such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Luckily, there are a few ways around this restriction that APIs can implement.
    The details of the implementation of these workarounds are on the server side
    and are not in the scope of this chapter. But it is sufficient to know that APIs
    can be designed in a way that makes them data available across sites. So, when
    selecting APIs to use for your project, you'll need to investigate whether it
    is cross-domain capable. (The API we used in the earlier exercise, TheSportsDB,
    is such a site.)
  prefs: []
  type: TYPE_NORMAL
- en: CORS Header
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you are really curious, the main technique that allows cross-site requests
    is by the service sending something called a **CORS** header, which stands for
    **Cross-Origin Resource Sharing**. If the API wants to make its service available
    from any domain, the server can send the following response header when serving
    the response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: The `*` value indicates "any origin," but the server could also be more restrictive
    in what sites have access to as per its desire. This is only a very brief description
    of a larger subject. There are some other techniques to achieve cross-domain requests,
    such as using JSONP, `postMessage()` between frames, or local server-side proxies,
    but we will not detail them here.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 10.01: Implement REST Service Calls Using Various Techniques'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we have only coded for HTTP `GET` requests. Let''s get some practice
    using `POST`. The API we have been using in the previous exercises, TheSportsDB,
    only contains GET requests, making it unsuitable for testing other HTTP methods.
    Luckily, there are several dummy REST APIs out there made specifically for testing
    and prototyping that can be used for our purposes. We will use one such free API
    called **REQ | RES** (at [https://reqres.in/](https://packt.live/37aWtH4)):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.14: Home page of REQ|RES'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.14: Home page of REQ|RES'
  prefs: []
  type: TYPE_NORMAL
- en: The API supplies a POST method at [https://reqres.in/api/users](https://reqres.in/api/users)
    for which you supply a JSON object with any fields you wish. You include the object
    as the data of your service call, and the service responds with the same object
    but with additional `id` and `createdAt` fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, if you have the following data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.15: Request and Response example'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_15.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.15: Request and Response example'
  prefs: []
  type: TYPE_NORMAL
- en: Your task is to implement the code for this service call using the `$.ajax()`
    method followed by the `$.post()` method, and finally execute it using the `XMLHttpRequest`
    method. Then, print out the `id` and `createdAt` fields returned to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that the **REQ | RES** API is really just a dummy service for testing
    and does not actually persist any data, so don't expect to be able to retrieve
    the data you sent later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for the activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use `$.ajax()` with `method: ''post''` and `dataType: ''json''`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enclose your data fields in an object, `{}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `success` function to output the expected values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, use `$.post()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enclose your data fields in an object, `{}`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `success` function to output the expected values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As the last parameter to `$.post()`, use the `'json'` value to indicate the
    expected JSON return type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, create a new `XMLHttpRequest` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `open('POST')`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the `Content-type` and `Accept` request headers to the appropriate values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a function for `onreadystatechange` that checks for a status code of
    `201 (Created)` and parses the JSON data with `JSON.parse()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call `JSON.stringify()` on the input data to convert it to JSON format.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the JSON data when calling `send()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code should result in something like the following in the JavaScript console
    in Google Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.16: JavaScript Console output'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_10_16.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 10.16: JavaScript Console output'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 742.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last section, we explored the native `XMLHttpRequest` object and how
    it differs from other libraries for making service calls. In summary, as you can
    see, compared to jQuery, the native approach is a lot more verbose, difficult
    to work with, and low-level for most use cases. Unless you have a specific need
    where more control is required, I do not recommend its use.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will describe regular expressions, which are commonly
    used to match patterns in a concise, flexible, and efficient manner. We will also
    explore best practices for writing clean and understandable code, which is critical
    if you want your code to be easily maintainable and live for a long time.
  prefs: []
  type: TYPE_NORMAL
