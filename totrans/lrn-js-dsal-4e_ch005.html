<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html>
<html xml:lang="en"
lang="en"
xmlns="http://www.w3.org/1999/xhtml"
xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<title>Learning JavaScript Data Structures and Algorithms - Fourth Edition</title>


</head>
<body>
<div><div><h1 data-number="5">4 Stacks</h1>
<p><strong>Before you begin: Join our book community on Discord</strong></p>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "learning-javascript-dsa-4e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p>
<img style="width:10rem;" src="img/file0.png" width="200" height="200"/>
</p>
<a href="https://packt.link/EarlyAccess/">https://packt.link/EarlyAccess/</a>
<p>We learned in the previous chapter how to create and use arrays, which are the most common type of data structure in computer science. As we learned, we can add and remove elements from an array at any index desired. However, sometimes we need some form of data structure where we have more control over adding and removing items. There are two data structures that have some similarities to arrays, but which give us more control over the addition and removal of elements. These data structures are <strong>stacks</strong> and <strong>queues</strong>.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The stack data structure</li>
<li>Adding elements to a stack</li>
<li>Popping elements from a stack</li>
<li>How to use the Stack class</li>
<li>Different problems we can resolve using the stack data structure</li>
</ul>

<h2 data-number="5.1">The stack data structure</h2>
<p>Imagine you have a stack of trays in a cafeteria or food court, or a pile of books, as in the following image:</p>
<figure>
<img src="img/file16.png" alt="Figure 4.1: A stack of books about programming languages and frameworks" width="651" height="651"/><figcaption aria-hidden="true">Figure 4.1: A stack of books about programming languages and frameworks</figcaption>
</figure>
<p>Now suppose you need to add a new book to the pile. The standard practice is to simply add the new book on the top of the pile of books. And in case you need to put the books back into the bookshelf, you would pick the book that is on the top of the pile, put it away, and then get the next book that is on the top until all the books have been stored away. This behavior of adding or removing books from the pile of books follows the same principle of a stack data structure.</p>
<p>A stack is an ordered collection of items that follows the <em>last in, first out</em> (<strong>LIFO</strong>) principle. The addition of new items or the removal of existing items takes place at the same end. The end of the stack is known as the <strong>top</strong>, and the beginning is known as the <strong>base</strong>. The newest elements are near the top, and the oldest elements are near the base.</p>
<p>A stack is used by compilers in programming languages, to store variables and method calls in the computer memory, and by the browser history (the browser's back button).</p>
<p>Another real-world example of a stack data structure is the <em>undo feature</em> in text editors such as Microsoft Word or Google Documents as showed in the following image:</p>
<figure>
<img src="img/file17.png" alt="Figure 4.2: Image of the undo style feature in Microsoft Word software" width="810" height="460"/><figcaption aria-hidden="true">Figure 4.2: Image of the undo style feature in Microsoft Word software</figcaption>
</figure>
<p>In this example, we have one stack being used internally by Microsoft Word: the <em>undo style</em> feature, where all the actions performed in the document are stacked and we can undo any action by clicking on the undo style button as many times as needed, until the stack of actions is empty.</p>
<p>Let's put these concepts into practice by creating our own Stack class using JavaScript and TypeScript.</p>


<h2 data-number="5.2">Creating an array-based Stack class</h2>
<p>We are going to create our own class to represent a stack. The source code for this chapter is available inside the <code>src/04-stack</code> folder on GitHub.</p>
<p>We will start by creating the <code>stack.js</code> file which will contain our class that represents a stack using an array-based approach.</p>
<p>First, we will declare our <code>Stack</code> class:</p>
<div><pre><code>class Stack {
  #items = []; // {1}
  // other methods
} </code></pre>
</div>
<p>We need a data structure that will store the elements of the stack. We can use an array to do this as we are already familiar with the array data structure (<code>{1}</code>). Also, note the prefix of the variable <code>items</code>: we are using a hash <code>#</code> prefix. This means the <code>#items</code> property can only be referenced inside the <code>Stack</code> class. This will allow us to protect this private array as the array data structure allows us to add or remove elements from any position in the data structure. Since the stack follows the LIFO principle, we will limit the functionalities that will be available for the insertion and removal of elements.</p>
<p>The following methods will be available in the <code>Stack</code> class:</p>
<ul>
<li><code>push(item)</code>: This method adds a new item to the top of the stack.</li>
<li><code>pop()</code>: This method removes the top element from the stack. It also returns the removed element.</li>
<li><code>peek()</code>: This method returns the top element from the stack. The stack is not modified (it does not remove the element; it only returns the element for information purposes).</li>
<li><code>isEmpty()</code>: This method returns <code>true</code> if the stack does not contain any elements, and <code>false</code> if the size of the stack is bigger than 0.</li>
<li><code>clear()</code>: This method removes all the elements of the stack.</li>
<li><code>size()</code>: This method returns the number of elements that the stack contains. It is similar to the <code>length</code> property of an array.</li>
</ul>
<p>We will code each method in the following sections.</p>

<h3 data-number="5.2.1">Pushing elements to the top of the stack</h3>
<p>The first method that we will implement is the <code>push</code> method. This method is responsible for adding new elements to the stack, with one very important detail: we can only add new items to the top of the stack, meaning at the end of the array (internally). The <code>push</code> method is represented as follows:</p>
<div><pre><code>push(item) {
  this.#items.push(item);
}</code></pre>
</div>
<p>As we are using an array to store the elements of the stack, we can use the <code>push</code> method from the JavaScript <code>Array</code> class that we covered in the previous chapter.</p>


<h3 data-number="5.2.2">Popping elements from the stack</h3>
<p>Next, we are going to implement the <code>pop</code> method. This method is responsible for removing the items from the stack. As the stack uses the LIFO principle, the last item we added is removed. For this reason, we can use the <code>pop</code> method from the JavaScript <code>Array</code> class that we also covered in the previous chapter. The <code>Stack.pop</code> method is represented as follows:</p>
<div><pre><code>pop() {
  return this.#items.pop();
}</code></pre>
</div>
<p>In case the stack is empty, this method will return the value <code>undefined</code>.</p>
<p>With the <code>push</code> and <code>pop</code> methods being the only methods available for adding and removing items from the stack, the LIFO principle will apply to our own <code>Stack</code> class.</p>


<h3 data-number="5.2.3">Peeking the element from the top of the stack</h3>
<p>Next, we will implement additional helper methods in our class. If we would like to know what the last element added to our stack was, we can use the <code>peek</code> method. This method will return the item from the top of the stack:</p>
<div><pre><code>peek() {
  return this.#items[this.#items.length - 1];
}</code></pre>
</div>
<p>As we are using an array to store the items internally, we can obtain the last item from an array using <code>length - 1</code> as follows:</p>
<figure>
<img src="img/file18.png" alt="Figure 4.3: A stack of four typing actions simulating the undo feature of a text editor." width="1018" height="561"/><figcaption aria-hidden="true">Figure 4.3: A stack of four typing actions simulating the undo feature of a text editor.</figcaption>
</figure>
<p>Suppose we are simulating the undo feature of a text editor. And we type "top of the stack". The feature we are developing will stack each word separately. So, we will end up with a stack with four items; therefore, the length of the internal array is 4. The last position used in the internal array is 3. As a result, the <code>length - 1</code> (4 - 1) is 3.</p>
<p>So, if we peek the top of the stack, we will get the following result: <code>{ action: 'typing', text: 'stack' }</code>.</p>


<h3 data-number="5.2.4">Verifying whether the stack is empty and its size</h3>
<p>The next method we will create is the <code>isEmpty</code> method, which returns <code>true</code> if the stack is empty (no element has been added), and <code>false</code> otherwise:</p>
<div><pre><code>isEmpty() {
  return this.#items.length === 0;
}</code></pre>
</div>
<p>Using the <code>isEmpty</code> method, we can simply verify whether the length of the internal array is 0.</p>
<p>Like the <code>length</code> property from the array class, we can also add a getter for the length of our Stack class. For collections, we usually use the term <em>size</em> instead of length. And again, as we are using an array to store the elements internally, we can simply return its length:</p>
<div><pre><code>get size() {
  return this.#items.length;
}</code></pre>
</div>
<p>In JavaScript, we can leverage a getter to efficiently track the size of our stack data structure. Getters provide a cleaner syntax, allowing us to retrieve the size as if it were a property (<code>myStack.size</code>) rather than calling a method like <code>myStack.size()</code>. This enhances code readability and maintainability.</p>


<h3 data-number="5.2.5">Clearing the elements of the stack</h3>
<p>Finally, we are going to implement the <code>clear</code> method. The clear method simply empties the stack, removing all its elements. The simplest way of implementing this method is by directly resetting the internal array to an empty array as follows:</p>
<div><pre><code>clear() {
  this.#items = [];
}</code></pre>
</div>
<p>An alternative implementation would be calling the <code>pop</code> method until the stack is empty:</p>
<div><pre><code>clear2() {
  while (!this.isEmpty()) {
   this.pop();
  }
}</code></pre>
</div>
<p>However, the first implementation is considered better in most cases in JavaScript as it is more efficient. By directly resetting the internal array to an empty array, the operation is typically constant time (<em>O(1)</em>), regardless of the stack's size. The second approach (<code>clear2()</code>) iterates through the stack and pops each element individually, and the time complexity is linear (<em>O(n)</em>), where <code>n</code> is the number of elements in the stack – this means this operation gets slower as the stack grows. From a memory usage standpoint, for the first approach, while it might seem like creating a new empty array uses more memory, JavaScript engines often optimize this operation, reusing memory where possible.</p>
<p>In rare cases, if the stack is extremely large, and there are concerns about memory usage with <code>clear()</code>, then <code>clear2()</code> could be slightly better due to its incremental approach. However, this is an edge case, and the efficiency difference would likely be negligible in most real-world scenarios. Also, for the <code>clear()</code> method, some developers might argue it is technically <em>O(n)</em> in the worst case due to garbage collection.</p>


<h3 data-number="5.2.6">Exporting the Stack data structure as a library class</h3>
<p>We have created a file <code>src/04-stack/stack.js</code> with our <code>Stack</code> class. And we would like to use the <code>Stack</code> class in a different file for easy maintainability of our code (<code>src/04-stack/01-using-stack-class.js</code>). How can we achieve this?</p>
<p>There are different approaches, depending on the environment you are working with.</p>
<p>The first approach we will learn is the <strong>CommonJS Module</strong> (<code>module.exports</code>). This is the traditional way of exporting modules in <strong>Node.js</strong>:</p>
<div><pre><code>// stack.js
class Stack {
  // our Stack class implementation
}
module.exports = Stack;</code></pre>
</div>
<p>The last line will expose our class so we can use it in a different file as follows:</p>
<div><pre><code>// 01-using-stack-class.js
const Stack = require('./stack');
const myStack = new Stack();</code></pre>
</div>
<p>This CommonJS Module approach is the one we will use throughout this book as we are using the following command to see the output of our code:</p>
<div><pre><code>node src/04-stack/01-using-stack-class.js</code></pre>
</div>
<p>However, if you would like to the code in the front-end, we can use <strong>ECMAScript Modules</strong> (<code>export default</code>) as follows:</p>
<div><pre><code>// stack.js
export default class Stack {
  // our Stack class implementation
}</code></pre>
</div>
<p>And to use it in a different file:</p>
<div><pre><code>import Stack from './stack.js';
const myStack = new Stack();</code></pre>
</div>
<p>A third approach that we can also use in the front-end is the <strong>Named Exports</strong>, which allows us to export multiple items from a module:</p>
<div><pre><code>export class Stack {
  // our Stack class implementation
}</code></pre>
</div>
<p>And to use it in a different file:</p>
<div><pre><code>import { Stack } from './stack'; 
const myStack = new Stack();</code></pre>
</div>
<p>Although we will use the Node.js approach, it is useful to know the other approaches so we can adapt our code to different environments.</p>


<h3 data-number="5.2.7">Using the Stack class</h3>
<p>The time to test the Stack class has come! As discussed in the previous subsection, let's go ahead and create a separate file so we can write as many tests as we like: <code>src/04-stack/01-using-stack-class.js</code>.</p>
<p>The first thing we need to do is to import the code from the stack.js file and instantiate the Stack class we just created:</p>
<div><pre><code>const Stack = require('./stack');
const stack = new Stack();</code></pre>
</div>
<p>Next, we can verify whether it is empty (the output <code>is true</code>, because we have not added any elements to our stack yet):</p>
<div><pre><code>    console.log(stack.isEmpty()); // true</code></pre>
</div>
<p>Next, let's simulate the undo feature of a text editor. Suppose our text editor will store the action (such as typing), along with the text that is being typed. Each key stroke will be stored as one action.</p>
<p>For example, let's type <em>Stack</em>. After each key stroke, we will push the <code>action</code> and the <code>text</code> as an object to the stack. We will start with "St":</p>
<div><pre><code>stack.push({action: 'typing', text: 'S'});
stack.push({action: 'typing', text: 't'});</code></pre>
</div>
<p>If we call the <code>peek</code> method, it is going to return the object with text <code>t</code>, because it was the last element that was added to the stack:</p>
<div><pre><code>    console.log(stack.peek()); // { action: 'typing', text: 't' }</code></pre>
</div>
<p>Let's also check the stack size:</p>
<div><pre><code>    console.log(stack.size); // 2</code></pre>
</div>
<p>Now let's type a few more characters: "<em>ack</em>". This will push another three characters to the stack:</p>
<div><pre><code>stack.push({action: 'typing', text: 'a'});
stack.push({action: 'typing', text: 'c'});
stack.push({action: 'typing', text: 'k'});</code></pre>
</div>
<p>And if we check the size and if the stack is empty:</p>
<div><pre><code>console.log(stack.size); // 5
console.log(stack.isEmpty()); // false</code></pre>
</div>
<p>The following diagram shows all the push operations we have executed so far, and the status of our stack:</p>
<figure>
<img src="img/file19.png" alt="Figure 4.4: The push operations in the stack by typing Stack" width="1209" height="416"/><figcaption aria-hidden="true">Figure 4.4: The push operations in the stack by typing Stack</figcaption>
</figure>
<p>Next, let's undo the last two actions by removing two elements from the stack:</p>
<div><pre><code>    stack.pop();
    stack.pop();</code></pre>
</div>
<p>Before we evoked the <code>pop</code> method twice, our stack had five elements in it. After the execution of the pop method twice, the stack now has only three elements. We can check by outputting the size and peeking the top of the stack:</p>
<div><pre><code>console.log(stack.size); // 3
console.log(stack.peek()); // { action: 'typing', text: 'a' }</code></pre>
</div>
<p>The following diagram exemplifies the execution of the pop method:</p>
<figure>
<img src="img/file20.png" alt="Figure 4.5: The pop operations in the stack by popping two elements" width="1209" height="342"/><figcaption aria-hidden="true">Figure 4.5: The pop operations in the stack by popping two elements</figcaption>
</figure>

<h4 data-number="5.2.7.1">Enhancing the Stack by creating the toString method</h4>
<p>If we try to execute the following code:</p>
<div><pre><code>console.log(stack);</code></pre>
</div>
<p>We will get the following output:</p>
<div><pre><code>[object Object],[object Object],[object Object]</code></pre>
</div>
<p>This is not friendly at all, and we can enhance the output by creating a <code>toString</code> method in our <code>Stack</code> class:</p>
<div><pre><code>toString() {
  if (this.isEmpty()) {
    return "Empty Stack";
  } else {
    return this.#items.map(item =&gt; { // {1}
      if (typeof item === 'object' &amp;&amp; item !== null) { // {2}
        return JSON.stringify(item); // Handle objects
      } else {
        return item.toString(); // Handle other types {3}
      }
    }).join(', '); // {4}
  }
}</code></pre>
</div>
<p>If the stack is empty, we can return a message or simply <code>[] </code>(whichever is your preference). Since we are using an array-based Stack, we can leverage the <code>map</code> method to iterate and transform each element (<code>{1}</code>) of our Stack. For each item or element, we can check if the item is an object (<code>{2}</code>) and output the JSON version of the object for a user friendly output. Otherwise, we can use the item's own <code>toString</code> method (<code>{3}</code>). And to separate each element of the stack, we can use a comma and space (<code>{4}</code>).</p>



<h3 data-number="5.2.8">Reviewing the efficiency of our Stack class</h3>
<p>As the Stack class is the first data structure we are creating from scratch, let's review the efficiency of each method by review the Big O notation in terms of time of execution:</p>
<table>
<tbody>
<tr class="odd">
<td><strong>Method</strong></td>
<td><strong>Complexity</strong></td>
<td><strong>Explanation</strong></td>
</tr>
<tr class="even">
<td><code>push(item)</code></td>
<td><em>O(1)</em></td>
<td>Adding an item to the end of an array is usually constant time.</td>
</tr>
<tr class="odd">
<td><code>pop()</code></td>
<td><em>O(1)</em></td>
<td>Removing the last item from an array is usually constant time.</td>
</tr>
<tr class="even">
<td><code>isEmpty()</code></td>
<td><em>O(1)</em></td>
<td>Checking the length of an array is a constant-time operation.</td>
</tr>
<tr class="odd">
<td><code>get size()</code></td>
<td><em>O(1)</em></td>
<td>Accessing the <code>length</code> property of an array is constant time.</td>
</tr>
<tr class="even">
<td><code>clear()</code></td>
<td><em>O(1)</em></td>
<td>Assigning a new empty array is typically considered constant time, although some developers might consider O(n) due to garbage collector in the worst-case scenario.</td>
</tr>
<tr class="odd">
<td><code>toString</code></td>
<td><em>O(n)</em></td>
<td>Iterating through each element of the stack takes linear time.</td>
</tr>
</tbody>
</table>
Table 4.1:
<p>In the array-based implementation, operations like <code>push()</code> might occasionally take longer due to the array needing to be resized. However, on average, the time complexity still tends to be <em>O(1)</em> over many operations. JavaScript arrays are not fixed size like arrays in some other languages. They are dynamic, meaning they can grow or shrink as needed. Internally, they are typically implemented as dynamic arrays or hash tables.</p>
<p>JavaScript follows the ECMAScript standard, and each browser or engine might have its own implementation, meaning the array <code>push</code> method might have a different internal source code in Node.js, Chrome, Firefox, or Edge. Regardless of the implementation, the contract or the functionality will be the same, meaning the <code>push</code> method will add a new element to the end of the array, even if different engines have a different approach on how to do it.</p>
<p>For the dynamic array approach, when you push an element onto an array, and it has no more space, it might need to allocate a larger block of memory, copy the existing elements over, and then add the new element. This resizing can be an expensive operation, taking <em>O(n)</em> time (where <em>n</em> is the number of elements). In some JavaScript engines, arrays might use hash tables internally for faster access: <code>push</code> and <code>pop</code> would still typically be <code>O(1)</code>, but the details can vary depending on the implementation. We will learn more about hash tables in <em>Chapter 8, Dictionaries and Hashes</em>.</p>



<h2 data-number="5.3">Creating a JavaScript object-based Stack class</h2>
<p>The easiest way of creating a Stack class is using an array to store its elements. When working with a large set of data (which is quite common in real-world projects), we also need to analyze what is the most efficient way of manipulating the data.</p>
<p>When reviewing the efficiency of our array-based <code>Stack</code> class, we learned that some JavaScript engines might use hash tables to implement an array. We have not learned hash tables yet, but we can implement a Stack class using a JavaScript object to store the stack elements, and by doing so, we can access any element directly, with time complexity <em>O(1)</em>. And of course, comply with the LIFO principle. Let's see how we can achieve this behavior.</p>
<p>We will start by declaring the Stack class (<code>src/04-stack/stack-object.js</code> file) as follows:</p>
<div><pre><code>class Stack {
  #items = {}; // {1}
  #count = 0; // {2}
  // other methods
}</code></pre>
</div>
<p>For this version of the <code>Stack</code> class, we will use a JavaScript empty object instead of an empty array (<code>{1}</code>) to store the data and a <code>count</code> property to help us keep track of the size of the stack (and, consequently, also help us in adding and removing elements).</p>

<h3 data-number="5.3.1">Pushing elements to the stack</h3>
<p>We will declare our first method, used to add elements to the top of the stack:</p>
<div><pre><code>push(item) {
  this.#items[this.#count] = item;
  this.#count++;
}</code></pre>
</div>
<p>In JavaScript, an object is a set of <strong>key</strong> and <strong>value</strong> pairs. To add an <code>item</code> to the stack, we will use the <code>count</code> variable as the key to the <code>items</code> object and the <code>item</code> will be its value. After pushing the element to the stack, we increment the <code>count</code>. </p>
<p>In JavaScript, we have two main ways to assign a value to a particular key within an object:</p>
<ul>
<li><em>Dot notation</em>: <code>this.#items.1 = item</code>. This is the most common and concise way to assign values when we know the key name in advance.</li>
<li><em>Bracket Notation</em>: <code>this.#items[this.#count] = item</code>. Bracket notation offers more flexibility as can use variables or expressions to determine the key name. This notation is essential when dealing with dynamic keys, as it is our case in this scenario.</li>
</ul>
<p>We can use the same example as before to use the <code>Stack</code> class and type "St":</p>
<div><pre><code>// src/04-stack/02-using-stack-object-class.js
const Stack = require('./stack-object');
const stack = new Stack();
stack.push({action: 'typing', text: 'S'});
stack.push({action: 'typing', text: 't'});</code></pre>
</div>
<p>Internally, we will have the following values inside the <code>items</code> and <code>count</code> private properties:</p>
<div><pre><code>#items = {
  0: { action: 'typing', text: 'S' },
  1: { action: 'typing', text: 't' }}
};
#count = 2; </code></pre>
</div>


<h3 data-number="5.3.2">Verifying whether the stack is empty and its size</h3>
<p>The <code>#count</code> property also works as the size of the stack. So, for the <code>size</code> getter, we can simply return the <code>#count</code> property:</p>
<div><pre><code>get size() {
  return this.#count;
}</code></pre>
</div>
<p>And to verify whether the stack is empty, we can compare if the <code>#count</code> value is 0 as follows:</p>
<div><pre><code>isEmpty() {
  return this.#count === 0;
}</code></pre>
</div>


<h3 data-number="5.3.3">Popping elements from the stack</h3>
<p>As we are not using an array to store the elements, we will need to implement the logic to remove an element manually. The <code>pop</code> method also returns the element that was removed from the stack. The <code>pop</code> method for the object-based implementation is presented as follows:</p>
<div><pre><code>pop() {
  if (this.isEmpty()) { // {1}
    return undefined;
  }
  this.#count--; // {2}
  const result = this.#items[this.#count]; // {3}
  delete this.#items[this.#count]; // {4}
  return result; // {5}
}</code></pre>
</div>
<p>First, we need to verify whether the stack is empty (<code>{1}</code>) and, if so, we return the value <code>undefined</code> (the array <code>pop</code> method returns undefined in case the array is empty, so we are following the same behavior). If the stack is not empty, we will decrement the <code>#count</code> property (<code>{2}</code>) and we will store the value from the top of the stack (<code>{3}</code>) temporarily so we can return it (<code>{5}</code>) after the element has been removed (<code>{4}</code>).</p>
<p>As we are working with a JavaScript object, to remove a specific value from the object, we can use the JavaScript <code>delete</code> operator as in line <code>{4}</code>.</p>
<p>Let's use the following internal values to emulate the <code>pop</code> action:</p>
<div><pre><code>#items = {
  0: { action: 'typing', text: 'S' },
  1: { action: 'typing', text: 't' }}
};
#count = 2; </code></pre>
</div>
<p>To access the element from the top of the stack (latest <code>text</code> added: <code>t</code>), we need to access the key with value <code>1</code>. To do so, we decrement the <code>#count</code> variable from <code>2</code> to <code>1</code>. We can access <code>#items[1]</code>, delete it, and return its value.</p>


<h3 data-number="5.3.4">Peeking the top of the stack and clearing it</h3>
<p>To peek the element that is on the top of the stack we will use the following code:</p>
<div><pre><code>peek() {
  return this.#items[this.#count - 1];
}</code></pre>
</div>
<p>The behavior is like the peek method of the array-based implementation. In case the stack is empty, it will return <code>undefined</code>.</p>
<p>And to clear the stack, we can simply reset it to the same values we initialized the class with:</p>
<div><pre><code>clear() {
  this.#items = {};
  this.#count = 0;
}</code></pre>
</div>


<h3 data-number="5.3.5">Creating the toString method</h3>
<p>To create the <code>toString</code> method for the object-based Stack class, we will use the following code:</p>
<div><pre><code>toString() {
  if (this.isEmpty()) {
    return 'Empty Stack';
  }
  let objString = this.#itemToString(this.#items[0]); // {1}
  for (let i = 1; i &lt; this.#count; i++) { // {2}
    objString += `, ${this.#itemToString(this.#items[i])}`; // {3}
  }
  return objString;
}
#itemToString(item) { // {4}
  if (typeof item === 'object' &amp;&amp; item !== null) {
    return JSON.stringify(item); // Handle objects
  } else {
    return item.toString(); // Handle other types
  }
}</code></pre>
</div>
<p>If the stack is empty, we can return a message or <code>{} </code>(whichever is your preference). Next, we will transform the first element into a string (<code>{1}</code>) – this is in case the stack only has one element or so we do not need to append a comma at the end of the string. Next, we will iterate through all the elements (<code>{2}</code>) by using the <code>#count</code> property (that also works as a key within our <code>#items</code> object). For each additional element, we will append a comma, followed by the string version of the element (<code>{3}</code>). Since we need to stringify the first element and all the subsequent elements of the stack, instead of duplicating the code, we can create another method (<code>{4}</code>) that will transform an element into a string (this is the same logic we used in the array-based version). By prefixing the method with hash (<code>#</code>), JavaScript will not expose this method and it will not be available to be used outside this class (it is a private method).</p>


<h3 data-number="5.3.6">Comparing object-based approach with array-based stack</h3>
<p>The time complexity of all methods for the object-based <code>Stack</code> class is constant time (<em>O(1)</em>) as we can access any element directly. The only method that is linear time (<em>O(n)</em>) is the <code>toString</code> method as we need to iterate through all the elements of the stack, where <em>n</em> is the stack size.</p>
<p>If we compare our array-based versus our object-based implementation, which one do you think is the best one?</p>
<p>Let's review both approaches:</p>
<ul>
<li><em>Performance</em>: Both implementations have similar Big O complexities for most operations. However, array-based stacks might have a slight edge in overall performance due to potential resizing issues with object-based stacks.</li>
<li><em>Element access</em>: Array-based stacks offer efficient random access by index, which can be useful in some scenarios. In some real-world examples, such as the undo feature, if the user wants to undo multiple steps at once, you can quickly access the relevant change based on its position in the stack using an index (in this case, the stack is not so strict to the LIFO behavior). If the stack operations primarily consist of pushing, popping, and peeking at the top element, then random access might not be a significant factor.</li>
<li><em>Order</em>: If maintaining strict order of elements is important, array-based stacks are the preferred choice.</li>
<li><em>Memory</em>: Array-based stacks are generally more memory-efficient.</li>
</ul>
<p>For most use cases involving stacks, the array-based implementation is generally recommended due to its order preservation, efficient access, and better memory usage. The object-based implementation might be considered in situations where order is not crucial, and you need a simple, straightforward implementation for basic stack operations.</p>



<h2 data-number="5.4">Creating the Stack class using TypeScript</h2>
<p>As discussed previously in this book, using TypeScript to create a data structure API like our Stack class offers several significant advantages over plain JavaScript, such as:</p>
<ul>
<li>Enhanced type safety: early error detection with static typing catches type-related errors during development, preventing them from causing runtime failures. This is crucial when building APIs (such as our Stack class) that others will consume, as it helps ensure correct usage.</li>
<li>Explicit contracts: TypeScript's interfaces and type aliases let us define the exact structure and types of the data our stack will hold, making it easier for others to understand how to interact with it.</li>
<li>Generics: We can make the Stack class more versatile by using generics to specify the type of data it will store. This allows for type-safe operations on various kinds of data (numbers, strings, objects, etc.).</li>
<li>Self-documenting code: TypeScript's type annotations serve as built-in documentation, explaining the purpose of functions, parameters, and return values. This reduces the need for separate documentation and makes our code easier to understand.</li>
</ul>
<p>Let's check how we can rewrite our Stack class using array-based implementation using TypeScript:</p>
<div><pre><code>// src/04-stack/stack.ts
class Stack&lt;T&gt; { // {1}
  private items: T[] = []; // {2}
  push(item: T): void { }
  pop(): T | undefined { }
  peek(): T | undefined { }
  isEmpty(): boolean { }
  get size(): number { }
  clear(): void { }
  toString(): string { }
}
export default Stack; // {3}</code></pre>
</div>
<p>We will use the generics (<code>{1}</code>) to make our class flexible. It can hold elements of any type (<code>T</code>), whether it's numbers, strings, objects, or custom types. This is a major advantage over a JavaScript implementation as JavaScript allows mixed types of data in the data structure and by typing our Stack class, we are enforcing all elements will be of the same type (<code>{2}</code>). TypeScript also has a <code>private</code> keyword to declare private properties and methods. This feature became available years before JavaScript added the hash # prefix to allow private properties and methods.</p>
<p>The code inside the methods is the same as the JavaScript implementation. The advantage here is we can type any method arguments and their return type, facilitating reading the code with more ease.</p>
<p>The export (<code>{3}</code>) syntax follows the ECMAScript approach we reviewed earlier in this chapter.</p>
<p>If we want to use this data structure in a separate file so we can test it, we can create another file (equivalent to the JavaScript file we created):</p>
<div><pre><code>// src/04-stack/01-using-stack-class.ts
import Stack from './stack';
enum Action { // {4}
  TYPE = 'typing'
}
interface EditorAction { // {5}
  action: Action;
  text: string;
}
const stack = new Stack&lt;EditorAction&gt;(); // {6}
stack.push({action: Action.TYPE, text: 'S'});
stack.push({action: Action.TYPE, text: 't'});</code></pre>
</div>
<p>We can create an enumerator to define all the types allowed in the text editor (<code>{4}</code>). This step is optional, but a good practice to avoid typo mistakes. Next, we can create an interface to define the type of the data our stack will store (<code>{5}</code>). Finally, when we instantiate the <code>Stack</code> data structure, we can type it to ensure all elements will be of the same type (<code>{6}</code>). The remaining sample code will be the same as in JavaScript.</p>
<p>To see the output of the example file, we can use the following command:</p>
<div><pre><code>npx ts-node src/04-stack/01-using-stack-class.ts</code></pre>
</div>
<p>The <code>ts-node</code> package allows us to execute the TypeScript code without manually compiling it first. The output will be the same as the one in JavaScript.</p>


<h2 data-number="5.5">Solving problems using stacks</h2>
<p>Now that we know how to use the <code>Stack</code> class, let's use it to solve some computer science problems. In this section, we will cover the decimal to binary problem, and we will also transform the algorithm into a base converter algorithm.</p>

<h3 data-number="5.5.1">Converting decimal numbers to binary</h3>
<p>We are already familiar with the decimal base. However, binary representation is particularly important in computer science, as everything in a computer is represented by binary digits (0 and 1).</p>
<p>This is extremely helpful when working with data storage for example. Computers store all information as binary digits. When we save a file, the decimal representation of each character or pixel is converted to binary before being stored on the hard drive or other storage media. Some file formats, like image files (.bmp, .png) and audio files (.wav), store data partially or entirely in binary format. Understanding binary conversion is crucial for working with these files at a low level. Another application are barcodes, which are essentially binary patterns of black and white lines that represent decimal numbers. Scanners decode these patterns back into decimals to identify products and other information.</p>
<p>To convert a decimal number into a binary representation, we can divide the number by 2 (binary is a base 2 number system) until the division result is 0. As an example, we will convert the number 10 into binary digits:</p>
<figure>
<img src="img/file21.png" alt="Figure 4.6: A mathematical representation of converting the number 10 into binary digits" width="704" height="302"/><figcaption aria-hidden="true">Figure 4.6: A mathematical representation of converting the number 10 into binary digits</figcaption>
</figure>
<p>This conversion is one of the first things you learn in computer science classes. The decimal to binary algorithm is presented as follows:</p>
<div><pre><code>// src/04-stack/decimal-to-binary.js
const Stack = require('./stack');
function decimalToBinary(decimalNumber) {
  const remainderStack = new Stack();
  let binaryString = '';
  if (decimalNumber === 0) { '0'; }
  while (decimalNumber &gt; 0) { // {1}
    const remainder = Math.floor(decimalNumber % 2); // {2}
    remainderStack.push(remainder); // {3}
    decimalNumber = Math.floor(decimalNumber / 2); // {4}
  }
  while (!remainderStack.isEmpty()) { // {5}
    binaryString += remainderStack.pop().toString();
  }
  return binaryString;
}</code></pre>
</div>
<p>In the provided code, as long as the quotient of the division is non-zero (line <code>{1}</code>), we calculate the remainder using the modulo operator (line <code>{2}</code>) and push it onto the stack (line {3}). We then update the dividend for the next iteration by dividing it by 2 and discarding any fractional part using <code>Math.floor</code> (line <code>{4}</code>). This is necessary because JavaScript does not distinguish between integers and floating-point numbers. Finally, we pop elements from the stack until it's empty (line <code>{5}</code>), concatenating them into a string to form the binary representation.</p>
<p>If we call <code>decimalToBinary(13)</code>, here's how the process would unfold:</p>
<ol>
<li>13 % 2 = 1 (remainder pushed onto stack); 13 / 2 = 6 (integer division)</li>
<li>6 % 2 = 0 (remainder pushed onto stack); 6 / 2 = 3</li>
<li>3 % 2 = 1 (remainder pushed onto stack); 3 / 2 = 1</li>
<li>1 % 2 = 1 (remainder pushed onto stack); 1 / 2 = 0 (loop terminates)</li>
<li>Stack: [1, 1, 0, 1] (top to bottom)</li>
<li>Popping from the stack and building the result string: "1101"</li>
</ol>


<h3 data-number="5.5.2">The base converter algorithm</h3>
<p>We can modify the previous algorithm to make it work as a converter from decimal to the bases between <code>2</code> and <code>36</code>. Instead of dividing the decimal number by 2, we can pass the desired base as an argument to the method and use it in the division operations, as shown in the following algorithm:</p>
<div><pre><code>// src/04-stack/decimal-to-base.js
const Stack = require('./stack');
function decimalToBase(decimalNumber, base) {
  if (base &lt; 2 || base &gt; 36) {
    throw new Error('Base must be between 2 and 36');
  }
  const digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'; // {6}
  const remainderStack = new Stack();
  let baseString = '';
  while (decimalNumber &gt; 0) {
    const remainder = Math.floor(decimalNumber % base);
    remainderStack.push(remainder);
    decimalNumber = Math.floor(decimalNumber / base);
  }
  while (!remainderStack.isEmpty()) {
    baseString += digits[remainderStack.pop()]; // {7}
  }
  return baseString;
}</code></pre>
</div>
<p>There is one more thing we need to change. In the conversion from decimal to binary, the remainders will be 0 or 1; in the conversion from decimal to octagonal, the remainders will be from 0 to 8; and in the conversion from decimal to hexadecimal, the remainders can be 0 to 9 plus the letters A to F (values 10 to 15). For this reason, we need to convert these values as well (lines <code>{6}</code> and <code>{7}</code>). So, starting at base 11, each letter of the alphabet will represent its base. The letter <code>A</code> represents base 11, <code>B</code> represents base 12, and so on.</p>
<p>We can use the previous algorithm and output its result as follows:</p>
<div><pre><code>console.log(decimalToBase(100345, 2)); // 11000011111111001
console.log(decimalToBase(100345, 8)); // 303771
console.log(decimalToBase(100345, 16)); // 187F9
console.log(decimalToBase(100345, 35)); // 2BW0</code></pre>
</div>
<p>And when could we use this algorithm in the real-world? This algorithm has many applications such as:</p>
<ul>
<li>Hexadecimal (base 16): Web developers and graphic designers frequently use hexadecimal notation to represent colors in HTML, CSS, and other digital design tools. For example, the color white is represented as <code>#FFFFFF</code>, which is equivalent to the decimal value <code>16777215</code>. The <code>decimalToBase</code> algorithm could be used to convert color values between decimal and hexadecimal representations.</li>
<li>Base64 encoding: Base64 is a common encoding scheme used to represent binary data (images, audio, and so on) as text. It uses a 64-character alphabet (A-Z, a-z, 0-9, +, /) and converts binary data into base-64 representation for easier transmission over text-based protocols like email. We could enhance our algorithm to convert to a base-64 (use this as a challenge to try on your own, you will find the resolution in the source code of this book).</li>
<li>Shortened URLs or unique identifiers: Services like <a href="https://bit.ly">bit.ly</a> generate shortened URLs that use a mix of alphanumeric characters. These shortened URLs often represent unique numeric identifiers that have been converted to a higher base (for example: base 62) to make them more compact.</li>
</ul>
<blockquote>
<p>You will also find the <em>Hanoi Tower</em> example when you download the source code of this book.</p>
</blockquote>



<h2 data-number="5.6">Exercises</h2>
<p>We will resolve a few array exercises from <strong>LeetCode</strong> using the concepts we learned in this chapter.</p>

<h3 data-number="5.6.1">Valid Parentheses</h3>
<p>The first exercise we will resolve is the <em>20. Valid Parentheses</em> problem available at <a href="https://leetcode.com/problems/valid-parentheses/">https://leetcode.com/problems/valid-parentheses/</a>.</p>
<p>When resolving the problem using JavaScript or TypeScript, we will need to add our logic inside the function <code>function isValid(s: string): boolean {}</code>, which receives a string it is expecting a boolean to be returned.</p>
<p>The following are the sample input and expected output provided by the problem:</p>
<ul>
<li>Input "()", output true.</li>
<li>Input "()", output true.</li>
<li>Input "(]", output false.</li>
</ul>
<p>An input string is valid if:</p>
<ul>
<li>Open brackets must be closed by the same type of brackets.</li>
<li>Open brackets must be closed in the correct order.</li>
<li>Every close bracket has a corresponding open bracket of the same type.</li>
</ul>
<p>The problem also provides three hints, which contain the logic we need to implement to resolve this problem:</p>
<ul>
<li>Use a stack of characters.</li>
<li>When you encounter an opening bracket, push it to the top of the stack.</li>
<li>When you encounter a closing bracket, check if the top of the stack was the opening for it. If yes, pop it from the stack. Otherwise, return false.</li>
</ul>
<p>Let's write the <code>isValid</code> function:</p>
<div><pre><code>const isValid = function(s) {
  const stack = []; // {1}
  const open = ['(', '[', '{']; // {2}
  const close = [')', ']', '}']; // {3}
  for (let i = 0; i &lt; s.length; i++) { // {4}
    if (open.includes(s[i])) { // {5}
      stack.push(s[i]);
    } else if (close.includes(s[i])) { // {6}
      const last = stack.pop(); // {7}
      if (open.indexOf(last) !== close.indexOf(s[i])) { // {8}
        return false;
      }
    }
  }
  return stack.length === 0; // {9}
}</code></pre>
</div>
<p>The preceding code uses a stack data structure to keep track of the parentheses as provided in the hints (<code>{1}</code>). Although we are not using our own Stack class to resolve this problem, we learned we can use the array and apply the LIFO behavior by using the push and pop method from the JavaScript Array class. We also declared two arrays: <code>open</code> (<code>{2}</code>) and <code>close</code> (<code>{3}</code>), which contain the three types of opening and closing brackets, respectively. Then, we iterate over the string (<code>{4}</code>). If it encounters an opening bracket present in the <code>open</code> array (<code>{5}</code>), then it pushes it onto the stack. If it encounters a closing bracket present in the close array ((<code>{6}</code>)), it pops the last element from the stack (<code>{7}</code>) and checks if the popped opening bracket matches its respective closing bracket (<code>{8}</code>). After the loop, if the stack is empty (<code>{9}</code>), it means all opening brackets have been correctly matched with closing brackets, so the function returns <code>true</code>, otherwise if there are still elements left in the stack, it means there are unmatched opening brackets.</p>
<p>This is solution that passes all the tests and resolves the problem. However, if this exercise is being used in technical interviews, the interviewer might ask you to try a different solution that does not include arrays to track the open and close brackets, after all, the <em>includes</em> method alone is of time complexity O(n) as it might iterate over the entire array, even though our array only contains three elements.</p>
<p>We learned in this chapter we can use JavaScript objects for key-value pairs as well. So, we can rewrite the <code>isValid</code> function using a JavaScript object to map the open and close brackets:</p>
<div><pre><code>const isValid2 = function(s) {
  const stack = [];
  const map = { // {10}
    '(': ')',
    '[': ']',
    '{': '}'
  };
  for (let i = 0; i &lt; s.length; i++) {
    if (map[s[i]]) { // {11}
      stack.push(s[i]);
    } else if (s[i] !== map[stack.pop()]) { // {12}
      return false;
    }
  }
  return stack.length === 0;
}</code></pre>
</div>
<p>The logic is still the same, however, we can map the open brackets as keys and the close brackets as values (<code>{10}</code>). This allows us to directly access the elements within the object in lines <code>{11}</code> and <code>{12}</code>, avoiding iterating through the array.</p>
<p>The time complexity of this function is <em>O(n)</em>, where <em>n</em> is the length of the string <code>s</code>. This is because the function iterates over the string <code>s</code> once, performing a constant amount of work for each character in the string (either pushing to the stack, popping from the stack, or comparing characters).</p>
<p>The space complexity is also <em>O(n)</em>, as in the worst-case scenario (when all characters are opening brackets), the function would push all characters into the stack.</p>
<p>Can you think of any optimizations we can apply to this algorithm?</p>
<p>Although our code is working, it can be further optimized by adding some validations for edge cases in the beginning of the algorithm:</p>
<div><pre><code>const isValid3 = function(s) {
  // opt 1: if the length of the string is odd, return false
  if (s.length % 2 === 1) return false;
  // opt 2: if the first character is a closing bracket, return false
  if (s[0] === ')' || s[0] === ']' || s[0] === '}') return false;
  // opt 3: if the last character is an opening bracket, return false
  if (s[s.length - 1] === '(' ||
s[s.length - 1] === '[' || s[s.length - 1] === '{') return false;
  // remaining algorithm is same
}</code></pre>
</div>
<p>The optimizations at the beginning of the function do not change the overall time complexity, as they are constant time operations. They may, however, improve the function's performance in certain scenarios by allowing it to exit early.</p>
<p>In algorithm challenges, competitions, and technical interviews, these optimizations are especially important. Optimizations like these demonstrate that you pay attention to detail and care about writing clean, efficient code. This can be a positive signal to potential employers. The ability to identify and implement these optimizations shows you can think critically about code efficiency and have a good understanding of the problem's constraints. Interviewers often value this ability as it demonstrates a deeper understanding of algorithms and data structures.</p>


<h3 data-number="5.6.2">Min Stack</h3>
<p>The next exercise we will resolve is the <em>155. Min Stack</em>, available at <a href="https://leetcode.com/problems/min-stack">https://leetcode.com/problems/min-stack</a>.</p>
<p>This is a design problem that asks you to design a stack that supports push, pop, top, and retrieving the minimum element in constant time. The problem also states that you must implement a solution with <em>O(1)</em> time complexity for each function.</p>
<p>We have already designed the Stack class in this chapter (the <code>top</code> method is our <code>peek</code> method). What we need to do is keep track of the minimum element in the stack.</p>
<p>The sample input that is given is:</p>
<ul>
<li>["MinStack","push","push","push","getMin","pop","top","getMin"]</li>
<li>[[],[-2],[0],[-3],[],[],[],[]]</li>
</ul>
<p>And the explanation given is:</p>
<div><pre><code>MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin(); // return -3
minStack.pop();
minStack.top();    // return 0
minStack.getMin(); // return -2</code></pre>
</div>
<p>Let's review the MinStack design as follows:</p>
<div><pre><code>class MinStack {
  stack = [];
  minStack = []; // {1}
  push(x) {
    this.stack.push(x);
    if (this.minStack.length === 0 ||
x &lt;= this.minStack[this.minStack.length - 1]) {
      this.minStack.push(x);
    }
  }
  pop() {
    const x = this.stack.pop();
    if (x === this.minStack[this.minStack.length - 1]) {
      this.minStack.pop();
    }
  }
  top() {
    return this.stack[this.stack.length - 1];
  }
  getMin() {
    return this.minStack[this.minStack.length - 1];
  }
}</code></pre>
</div>
<p>To be able to return the minimum element of the stack in constant time, we also need to track the minimum value. There are different ways of achieving this, and the first approach chosen is to also keep a <code>minStack</code> to track the minimum values (<code>{1}</code>).</p>
<p>The <code>push</code> method takes a number <code>x</code> as an argument and pushes it onto the stack. Then checks if <code>minStack</code> is empty or if <code>x</code> is less than or equal to the current minimum element (which is the last element in <code>minStack</code>). If either condition is <code>true</code>, <code>x</code> is also pushed onto <code>minStack</code>.</p>
<p>The <code>pop</code> method removes the top element from stack and assigns it to <code>x</code>. If <code>x</code> is equal to the current minimum element (again, the last element in <code>minStack</code>), it also removes the top element from <code>minStack</code>.</p>
<p>The <code>top</code> method has the same implementation as our <code>peek</code> method. The <code>getMin</code> method is the same as doing a peek into the <code>minStack</code>, which always holds the minimum element of the current state of the stack on its top.</p>
<p>A different approach would be to track the minimum element in a variable instead of a stack. We would initialize its value <code>min= +Infinity</code> with the biggest numeric value in JavaScript, inside the <code>push</code> method, we would update its value every time a new element is added to the stack (<code>this.min = Math.min(val, this.min)</code>) and inside the pop method, we would also update the minimum value if the same is being removed from the stack (<code>if (this.min === val) this.min = Math.min(...this.stack)</code>). And for the <code>getMin</code> method, we would simply return <code>this.min</code>. However, in this approach, the pop method would have <em>O(n)</em> because it uses <code>Math.min(...this.stack)</code> to find the new minimum every time an element is popped as this operation requires iterating over the entire stack, so it is not necessarily a better solution.</p>
<blockquote>
<p>You will also find the <em>77. Simplify Path</em> problem resolution when you download the source code of this book.</p>
</blockquote>



<h2 data-number="5.7">Summary</h2>
<p>In this chapter, we delved into the fundamental stack data structure. We implemented our own stack algorithms using both arrays and JavaScript objects, mastering how to efficiently add and remove elements with the <code>push</code> and <code>pop</code> methods.</p>
<p>We explored and compared diverse implementations of the Stack class, weighing factors like memory usage, performance, and order preservation to arrive at a well-informed recommendation for practical use cases. We have also reviewed the implementation of the Stack class using TypeScript and its benefits.</p>
<p>Beyond implementation, we tackled renowned computer science problems using stacks and dissected exercises commonly encountered in technical interviews, analyzing their time and space complexities.</p>
<p>In the next chapter, we'll shift our focus to queues, a closely related data structure that operates on a different principle than the LIFO (Last In, First Out) model that governs stacks.</p>


</div>
</div>
</body>
</html>