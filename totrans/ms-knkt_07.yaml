- en: Chapter 7. Best Practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, all the coding recommendations have been interspersed with Knockout
    techniques as they were introduced. In order to go into more detail about these
    patterns and why they are useful as well as to provide a consolidated reference,
    we are going to review them in this chapter. As JavaScript is a very flexible
    language, enjoys one of the largest online developer communities, and is in use
    at all levels of development on the hobbyist-enterprise spectrum, it is difficult
    to talk about good or useful patterns without becoming opinionated. These practices
    should be taken as advice and shouldn't be considered dogma. Many of these recommendations
    are applicable to programming in general and not just Knockout development.
  prefs: []
  type: TYPE_NORMAL
- en: Sticking to MVVM
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knockout was designed with the **Model-View-ViewModel** (**MVVM**) pattern in
    mind. While it is possible to develop applications using Knockout and other design
    patterns, sticking to MVVM will produce a natural alignment between Knockout and
    your own code.
  prefs: []
  type: TYPE_NORMAL
- en: The view and the viewmodel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The separation of concerns is the key here. Don't introduce view concepts such
    as DOM elements or CSS classes into your viewmodel; these belong in the HTML.
    Limit or avoid business logic and inline binding functions in your view; these
    belong as properties or functions in your viewmodel. Keeping these two separated
    makes it possible for the work to be divided and parallelized, allows the viewmodel
    to be reusable, and makes it possible to unit test the viewmodel.
  prefs: []
  type: TYPE_NORMAL
- en: Cluttering the viewmodel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Animation handlers are a good example of view logic that often ends up in the
    viewmodel. The `foreach` binding handler has several postprocessing hooks (such
    as `afteradd`, `afterrender`, and `beforeremove`) that are intended to allow animations
    to be used. It might seem natural to use viewmodel functions, as they are specified
    in a binding, which normally takes viewmodel properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this tightly couples the viewmodel to the view and makes both
    the viewmodel and the animation less reusable. A better solution would be to store
    the animations somewhere globally accessible, such as `ko.animations`, and reference
    them in the binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, the same animations can be reused in other lists, and the viewmodel doesn't
    contain logic that controls the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Cluttering the view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While keeping the viewmodel agnostic of the view tends to be very clear cut
    (don't reference HTML types), keeping inline code out of the view tends to merit
    more consideration. This is partially because logic related to the presentation
    might belong in the view, or at least a binding handler, and partially because
    there is a balancing act when many small, one-off properties are required.
  prefs: []
  type: TYPE_NORMAL
- en: 'An example of inline logic that does not belong in the view is a button-disabling
    expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Consider the case where this value needs to change: do you really want to hunt
    through the HTML for the rule that controls this? What about when this value is
    variable and is determined by other factors? This should absolutely be `canSubmit`
    (or similarly named) that is computed in the viewmodel, because the maximum number
    of items is business logic, which is not the view''s domain.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A less clear-cut example is a warning display based on similar logic. Let''s
    say disabling the button isn''t enough of a visual cue, and you also want the
    button to turn red:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This isn't a perfect example, and you might want to add an `overMaxItemLimit`
    computed to your viewmodel anyway; and it does not directly express the business
    logic either. *If the form has too many items, highlight the form* is presentation
    logic, and if you have enough of these one-off computed properties, which just
    contain a simple expression against a single observable, your viewmodel will get
    cluttered quickly. In cases like these, forcing the viewmodel to represent this
    logic might not offer any value, and you should use discretion when deciding where
    to put it.
  prefs: []
  type: TYPE_NORMAL
- en: Using service modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Viewmodels should not contain all of your application code even in small applications.
    When possible, code should be broken out into non-viewmodel modules that encapsulate
    the work and can be reused. These modules are often called services.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a viewmodel that gets data from the server doesn't need to know
    how that operation is handled, whether it uses jQuery's AJAX method, a websocket,
    or some other retrieval method. Putting this logic into a data service module
    not only makes it reusable by other viewmodels, it makes unit testing easier by
    limiting the scope of each object to its own work. The driving philosophy here
    is the single responsibility principle.
  prefs: []
  type: TYPE_NORMAL
- en: Creating small modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating smaller modules makes unit testing simpler and reduces the effort required
    to understand the code for others who have to read it. When deciding whether or
    not to add functionalities to a module or split it off into a new one, keep the
    single responsibility principle in mind.
  prefs: []
  type: TYPE_NORMAL
- en: This is a bit of a balancing act. If you have a RESTful API for your JavaScript
    application, then creating modules to abstract away the individual URLs by providing
    methods for them is a good idea. Having a single dataService module that contains
    all of the URLs for the whole application, though, will result in a very large
    module in even medium-sized applications. On the other hand, having a service
    module for each individual route will produce an even larger number of files.
    This will make unit testing and maintenance harder, it won't make it easier. The
    best course is to group the routes into modules by functionality. In the case
    of REST URLs, grouping them by resource produces a very natural organization.
  prefs: []
  type: TYPE_NORMAL
- en: Writing unit tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you follow all the previous recommendations, then your code will be in a
    good position to be unit tested. The primary consideration while writing unit
    testable code is mockability: code whose external dependencies are loosely coupled.
    Loosely coupled dependencies can be replaced in a unit test with a fake, stub,
    mock, spy, or other form of replacement whose behavior can be controlled by the
    test. This challenge is solved by keeping DOM and binding the code out of your
    viewmodel, keeping the modules small and avoiding tight coupling to other viewmodels
    through practices such as dependency injection.'
  prefs: []
  type: TYPE_NORMAL
- en: There are several frameworks that are available for unit testing in JavaScript,
    and they all offer similar benefits and workflows. The important thing is not
    what tools you use to unit test, only that you write unit tests. The value of
    unit testing really can't be overstated. It is even more important in dynamic
    languages such as JavaScript that do not offer compile-time checking.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton versus instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you have a viewmodel that is actually used multiple times, such as the
    one backing a `foreach` loop, using an instance is the only option. When there
    is only one instance of the viewmodel, such as the one backing an entry form or
    a page in an SPA, the choice might not be as simple.
  prefs: []
  type: TYPE_NORMAL
- en: A good rule of thumb is to think about the lifetime of the object. If the object's
    lifetime doesn't end, such as the viewmodel for an ever-present navigation bar,
    using a singleton is appropriate. If the object's lifetime is short, such as a
    page viewmodel in an SPA, then using a singleton means that the object cannot
    be garbage collected even after it is no longer being actively used. In this situation,
    a disposable instance is recommended.
  prefs: []
  type: TYPE_NORMAL
- en: Another rule of thumb is to consider whether or not it has an internal state.
    Without an internal state that needs to be managed, there is little danger that
    multiple uses of the object or its methods will result in errors. If an object
    has no internal state, such as a service that abstracts AJAX requests or cookie
    access, a singleton is appropriate even if the object has a limited lifetime.
    This is not true for a viewmodel whose state is important, such as one backing
    an entry form; this is because with each use, it should have a fresh state. The
    need for a fresh state is there even if the object has a long lifetime, such as
    the login viewmodel in a navigation bar. Reconstructing the viewmodel after a
    logout will ensure that no information from a previous use remains.
  prefs: []
  type: TYPE_NORMAL
- en: Calling ko.applyBindings once (per root)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I can't tell you how many times I've come across questions on Stack Overflow
    regarding problems that come from developers calling `ko.applyBindings` multiple
    times, thinking that it is responsible for syncing the DOM and the observable
    data. This is more of a *warning* than a *best practice*, but I would feel remiss
    if I left it out entirely. For any given root element in your HTML, you should
    have one call to `ko.applyBindings` at most.
  prefs: []
  type: TYPE_NORMAL
- en: Performance concerns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knockout's performance has improved several times since its initial release,
    but it is still possible to encounter issues in apps with a large number of operations
    or objects. While some decrease in performance should be expected as the work
    being done increases, there are ways to ease the burden on the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: Observable loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Changing observable arrays inside loops causes them to publish change notifications
    multiple times. The cost of these changes is proportional to the size of the array.
    You might need to add several items to an array and use a loop to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem here is that `push` gets called multiple times, which causes the
    array to send out multiple change notifications. It''s much easier for the subscribers
    of the array if all of the changes are sent at once. This can be done by collecting
    all of the changes in the loop and then applying them to the observable array
    at the end with `push.apply`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding method ensures that only a single call to `valueHasMutated` happens
    for the observable array. A popular solution to this common problem is to add
    this into a function on the `observableArray.fn` object, making it available to
    all observable arrays:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The following method can be used to add an array of items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Limit active bindings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A large number of bindings, especially those that register event handlers such
    as value and click can quickly lead to poor browser performance. Managing this
    takes careful consideration about how to best reduce the number of changes that
    need to happen simultaneously.
  prefs: []
  type: TYPE_NORMAL
- en: One method is to use control flow bindings to remove bound sections that are
    not required. Limiting the amount of content on the screen helps performance and
    also has the incidental benefit of reducing the clutter that users need to parse.
    Techniques such as pagination can be used for more than just long lists, such
    as breaking up a long form or activity into several screens. Of course, this method
    is limited to activities that can be broken up.
  prefs: []
  type: TYPE_NORMAL
- en: A more broadly applicable method is to use delegated events, which are otherwise
    known as **unobtrusive event handlers**.
  prefs: []
  type: TYPE_NORMAL
- en: Delegated events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unobtrusive event handlers, such as jQuery''s `on`, can use a single event
    handler to respond to events on any number of DOM elements that are inside the
    registered element. This is especially useful in large or recursive lists where
    registering a single event handler per element would be too expensive. Knockout
    provides two utility methods to connect these handlers with the appropriate data
    from the binding context in a manner that''s similar to the how Knockout''s click
    binding provides the context as the first parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ko.dataFor` (element): This returns the data that is available to the element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ko.contextFor` (element): This returns the binding context for the element
    (includes binding context properties such as `$parent` and `$root`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This can be combined with a binding handler that provides the event delegation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example can be seen in the `cp7-unobtrusive` branch.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding technique is not required everywhere, but when dealing with large
    numbers of handlers, it can lead to a noticeable impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Again, these are guidelines and not rules, and some of them are opinions that
    will lead to disagreement among coworkers. Sometimes, breaking the pattern produces
    cleaner and clearer code and is the only way to get something working while sometimes,
    breaking the pattern is the only way to compromise with colleagues. If it's getting
    in your way without giving you any benefits, don't do it. There is no one right
    way to develop software.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover some popular Knockout plugins maintained by the
    community.
  prefs: []
  type: TYPE_NORMAL
