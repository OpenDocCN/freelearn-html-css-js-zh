- en: Chapter 7. Best Practices
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 7 章. 最佳实践
- en: Up until now, all the coding recommendations have been interspersed with Knockout
    techniques as they were introduced. In order to go into more detail about these
    patterns and why they are useful as well as to provide a consolidated reference,
    we are going to review them in this chapter. As JavaScript is a very flexible
    language, enjoys one of the largest online developer communities, and is in use
    at all levels of development on the hobbyist-enterprise spectrum, it is difficult
    to talk about good or useful patterns without becoming opinionated. These practices
    should be taken as advice and shouldn't be considered dogma. Many of these recommendations
    are applicable to programming in general and not just Knockout development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，所有的编码建议都穿插着 Knockout 技术介绍。为了更详细地介绍这些模式以及它们为什么有用，并提供一个综合参考，我们将在这章中回顾它们。由于
    JavaScript 是一个非常灵活的语言，拥有最大的在线开发者社区之一，并且在业余爱好者到企业级开发的各个层面都有使用，因此不带有偏见地谈论好的或有用的模式是困难的。这些实践应被视为建议，而不应被视为教条。许多这些建议适用于一般的编程，而不仅仅是
    Knockout 开发。
- en: Sticking to MVVM
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 坚持 MVVM
- en: Knockout was designed with the **Model-View-ViewModel** (**MVVM**) pattern in
    mind. While it is possible to develop applications using Knockout and other design
    patterns, sticking to MVVM will produce a natural alignment between Knockout and
    your own code.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 是按照 **模型-视图-视图模型**（**MVVM**）模式设计的。虽然使用 Knockout 和其他设计模式开发应用程序是可能的，但坚持
    MVVM 将会在 Knockout 和您的代码之间产生自然的对齐。
- en: The view and the viewmodel
  id: totrans-4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图和视图模型
- en: The separation of concerns is the key here. Don't introduce view concepts such
    as DOM elements or CSS classes into your viewmodel; these belong in the HTML.
    Limit or avoid business logic and inline binding functions in your view; these
    belong as properties or functions in your viewmodel. Keeping these two separated
    makes it possible for the work to be divided and parallelized, allows the viewmodel
    to be reusable, and makes it possible to unit test the viewmodel.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 关注点的分离是关键。不要在您的视图模型中引入视图概念，如 DOM 元素或 CSS 类；这些属于 HTML。限制或避免在您的视图中使用业务逻辑和内联绑定函数；这些应作为属性或函数存在于视图模型中。保持这两者分离可以使工作得以分割和并行化，使视图模型可重用，并使单元测试视图模型成为可能。
- en: Cluttering the viewmodel
  id: totrans-6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图模型杂乱
- en: 'Animation handlers are a good example of view logic that often ends up in the
    viewmodel. The `foreach` binding handler has several postprocessing hooks (such
    as `afteradd`, `afterrender`, and `beforeremove`) that are intended to allow animations
    to be used. It might seem natural to use viewmodel functions, as they are specified
    in a binding, which normally takes viewmodel properties:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 动画处理程序是视图逻辑的一个很好的例子，这些逻辑通常最终会出现在视图模型中。`foreach` 绑定处理程序有几个后处理钩子（如 `afteradd`、`afterrender`
    和 `beforeremove`），目的是允许使用动画。使用视图模型函数似乎很自然，因为它们在绑定中指定，通常绑定视图模型属性：
- en: '[PRE0]'
  id: totrans-8
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Unfortunately, this tightly couples the viewmodel to the view and makes both
    the viewmodel and the animation less reusable. A better solution would be to store
    the animations somewhere globally accessible, such as `ko.animations`, and reference
    them in the binding:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这紧密地将视图模型与视图耦合在一起，使得视图模型和动画都变得不可重用。更好的解决方案是将动画存储在全局可访问的位置，例如 `ko.animations`，并在绑定中引用它们：
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the same animations can be reused in other lists, and the viewmodel doesn't
    contain logic that controls the DOM.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，相同的动画可以在其他列表中重用，并且视图模型不包含控制 DOM 的逻辑。
- en: Cluttering the view
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 视图杂乱
- en: While keeping the viewmodel agnostic of the view tends to be very clear cut
    (don't reference HTML types), keeping inline code out of the view tends to merit
    more consideration. This is partially because logic related to the presentation
    might belong in the view, or at least a binding handler, and partially because
    there is a balancing act when many small, one-off properties are required.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然保持视图模型对视图的无知通常是明确的（不要引用 HTML 类型），但将内联代码排除在视图之外通常需要更多的考虑。这部分是因为与呈现相关的逻辑可能属于视图，或者至少是一个绑定处理程序，部分是因为当需要许多小而独特属性时，存在一种平衡行为。
- en: 'An example of inline logic that does not belong in the view is a button-disabling
    expression:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 不属于视图的内联逻辑的例子是一个按钮禁用表达式：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Consider the case where this value needs to change: do you really want to hunt
    through the HTML for the rule that controls this? What about when this value is
    variable and is determined by other factors? This should absolutely be `canSubmit`
    (or similarly named) that is computed in the viewmodel, because the maximum number
    of items is business logic, which is not the view''s domain.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑这种情况，这个值需要改变：你真的想在整个HTML中寻找控制这个规则的规则吗？当这个值是变量并由其他因素确定时呢？这绝对应该是视图模型中计算出的`canSubmit`（或类似名称），因为项目数量的最大值是业务逻辑，这不是视图的领域。
- en: 'A less clear-cut example is a warning display based on similar logic. Let''s
    say disabling the button isn''t enough of a visual cue, and you also want the
    button to turn red:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个不那么明确的例子是基于类似逻辑的警告显示。假设禁用按钮不足以提供视觉提示，你还希望按钮变成红色：
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This isn't a perfect example, and you might want to add an `overMaxItemLimit`
    computed to your viewmodel anyway; and it does not directly express the business
    logic either. *If the form has too many items, highlight the form* is presentation
    logic, and if you have enough of these one-off computed properties, which just
    contain a simple expression against a single observable, your viewmodel will get
    cluttered quickly. In cases like these, forcing the viewmodel to represent this
    logic might not offer any value, and you should use discretion when deciding where
    to put it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个完美的例子，你可能会想在你的视图模型中添加一个`overMaxItemLimit`计算属性；而且它也没有直接表达业务逻辑。*如果表单中的项目太多，突出显示表单*是表示逻辑，如果你有足够的这些一次性计算属性，它们只是对单个可观察对象进行简单表达式，你的视图模型会很快变得杂乱。在这些情况下，强迫视图模型表示这种逻辑可能没有任何价值，你在决定将其放在哪里时应该谨慎行事。
- en: Using service modules
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用服务模块
- en: Viewmodels should not contain all of your application code even in small applications.
    When possible, code should be broken out into non-viewmodel modules that encapsulate
    the work and can be reused. These modules are often called services.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 即使在小型应用程序中，视图模型也不应包含所有应用程序代码。当可能时，代码应拆分为非视图模型模块，这些模块封装了工作并可以重用。这些模块通常被称为服务。
- en: For example, a viewmodel that gets data from the server doesn't need to know
    how that operation is handled, whether it uses jQuery's AJAX method, a websocket,
    or some other retrieval method. Putting this logic into a data service module
    not only makes it reusable by other viewmodels, it makes unit testing easier by
    limiting the scope of each object to its own work. The driving philosophy here
    is the single responsibility principle.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，从服务器获取数据的视图模型不需要知道该操作是如何处理的，无论是使用jQuery的AJAX方法、WebSocket还是其他检索方法。将此逻辑放入数据服务模块不仅使其对其他视图模型可重用，而且通过限制每个对象的作用域到其自身的工作，使单元测试更容易。这里的驱动哲学是单一职责原则。
- en: Creating small modules
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建小型模块
- en: Creating smaller modules makes unit testing simpler and reduces the effort required
    to understand the code for others who have to read it. When deciding whether or
    not to add functionalities to a module or split it off into a new one, keep the
    single responsibility principle in mind.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 创建更小的模块可以使单元测试更简单，并减少其他人阅读代码时理解代码所需的努力。在决定是否向模块添加功能或将其拆分为新的模块时，请牢记单一职责原则。
- en: This is a bit of a balancing act. If you have a RESTful API for your JavaScript
    application, then creating modules to abstract away the individual URLs by providing
    methods for them is a good idea. Having a single dataService module that contains
    all of the URLs for the whole application, though, will result in a very large
    module in even medium-sized applications. On the other hand, having a service
    module for each individual route will produce an even larger number of files.
    This will make unit testing and maintenance harder, it won't make it easier. The
    best course is to group the routes into modules by functionality. In the case
    of REST URLs, grouping them by resource produces a very natural organization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种平衡行为。如果你的JavaScript应用程序有一个RESTful API，那么创建模块通过提供方法来抽象单个URL是个好主意。然而，包含整个应用程序所有URL的单个数据服务模块，即使在中等规模的应用程序中，也会导致模块非常大。另一方面，为每个单独的路由创建服务模块会产生更多的文件。这将使单元测试和维护更困难，而不是更容易。最好的做法是按功能将路由分组到模块中。在REST
    URL的情况下，按资源分组会产生非常自然的组织。
- en: Writing unit tests
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写单元测试
- en: 'If you follow all the previous recommendations, then your code will be in a
    good position to be unit tested. The primary consideration while writing unit
    testable code is mockability: code whose external dependencies are loosely coupled.
    Loosely coupled dependencies can be replaced in a unit test with a fake, stub,
    mock, spy, or other form of replacement whose behavior can be controlled by the
    test. This challenge is solved by keeping DOM and binding the code out of your
    viewmodel, keeping the modules small and avoiding tight coupling to other viewmodels
    through practices such as dependency injection.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你遵循所有之前的建议，那么你的代码将处于良好的单元测试状态。在编写可测试的单元测试代码时，主要考虑的是可模拟性：外部依赖松散耦合的代码。松散耦合的依赖可以在单元测试中用模拟、存根、mock、spy或其他形式的替代品替换，其行为可以通过测试来控制。这个挑战通过将DOM和绑定代码从viewmodel中分离出来，保持模块小，并通过依赖注入等实践避免与其他viewmodel的紧密耦合来解决。
- en: There are several frameworks that are available for unit testing in JavaScript,
    and they all offer similar benefits and workflows. The important thing is not
    what tools you use to unit test, only that you write unit tests. The value of
    unit testing really can't be overstated. It is even more important in dynamic
    languages such as JavaScript that do not offer compile-time checking.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 有几个JavaScript单元测试框架可供使用，它们都提供了类似的好处和工作流程。重要的是你使用什么工具进行单元测试，而不是你是否编写了单元测试。单元测试的价值真的无法过高估计。在像JavaScript这样的不提供编译时检查的动态语言中，它甚至更重要。
- en: Singleton versus instance
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例与实例
- en: When you have a viewmodel that is actually used multiple times, such as the
    one backing a `foreach` loop, using an instance is the only option. When there
    is only one instance of the viewmodel, such as the one backing an entry form or
    a page in an SPA, the choice might not be as simple.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当你有一个实际被多次使用的viewmodel时，例如支持`foreach`循环的viewmodel，使用实例是唯一的选择。当viewmodel只有一个实例时，例如支持表单输入或SPA中的页面的viewmodel，选择可能并不简单。
- en: A good rule of thumb is to think about the lifetime of the object. If the object's
    lifetime doesn't end, such as the viewmodel for an ever-present navigation bar,
    using a singleton is appropriate. If the object's lifetime is short, such as a
    page viewmodel in an SPA, then using a singleton means that the object cannot
    be garbage collected even after it is no longer being actively used. In this situation,
    a disposable instance is recommended.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的经验法则是考虑对象的生命周期。如果对象的生命周期不会结束，例如始终存在的导航栏的viewmodel，使用单例是合适的。如果对象的生命周期较短，例如SPA中的页面viewmodel，那么使用单例意味着对象即使在不再被积极使用后也无法被垃圾回收。在这种情况下，建议使用可丢弃的实例。
- en: Another rule of thumb is to consider whether or not it has an internal state.
    Without an internal state that needs to be managed, there is little danger that
    multiple uses of the object or its methods will result in errors. If an object
    has no internal state, such as a service that abstracts AJAX requests or cookie
    access, a singleton is appropriate even if the object has a limited lifetime.
    This is not true for a viewmodel whose state is important, such as one backing
    an entry form; this is because with each use, it should have a fresh state. The
    need for a fresh state is there even if the object has a long lifetime, such as
    the login viewmodel in a navigation bar. Reconstructing the viewmodel after a
    logout will ensure that no information from a previous use remains.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个经验法则是考虑它是否有内部状态。如果没有需要管理的内部状态，那么多次使用对象或其方法导致错误的风险很小。如果一个对象没有内部状态，例如抽象AJAX请求或cookie访问的服务，即使对象有有限的生命周期，单例也是合适的。这不适用于状态重要的viewmodel，例如支持表单输入的viewmodel；这是因为每次使用时，它都应该有一个新的状态。即使对象有较长的生命周期，例如导航栏中的登录viewmodel，也需要新的状态。在注销后重建viewmodel将确保之前使用的信息不会保留。
- en: Calling ko.applyBindings once (per root)
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一次调用ko.applyBindings（每个根）
- en: I can't tell you how many times I've come across questions on Stack Overflow
    regarding problems that come from developers calling `ko.applyBindings` multiple
    times, thinking that it is responsible for syncing the DOM and the observable
    data. This is more of a *warning* than a *best practice*, but I would feel remiss
    if I left it out entirely. For any given root element in your HTML, you should
    have one call to `ko.applyBindings` at most.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我不知道有多少次在Stack Overflow上看到关于开发者多次调用`ko.applyBindings`导致的问题，他们认为这是同步DOM和可观察数据的原因。这与其说是一个**最佳实践**，不如说是一个**警告**，但如果完全忽略它，我会感到疏忽。对于HTML中的任何给定根元素，最多只能有一个`ko.applyBindings`调用。
- en: Performance concerns
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能问题
- en: Knockout's performance has improved several times since its initial release,
    but it is still possible to encounter issues in apps with a large number of operations
    or objects. While some decrease in performance should be expected as the work
    being done increases, there are ways to ease the burden on the CPU.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Knockout首次发布以来，其性能已经提高了好几次，但在包含大量操作或对象的应用中仍然可能遇到问题。虽然随着工作量的增加，性能的某些下降是可以预料的，但有一些方法可以减轻CPU的负担。
- en: Observable loops
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察循环
- en: 'Changing observable arrays inside loops causes them to publish change notifications
    multiple times. The cost of these changes is proportional to the size of the array.
    You might need to add several items to an array and use a loop to do this:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中更改可观察数组会导致它们多次发布更改通知。这些更改的成本与数组的大小成比例。你可能需要向数组添加多个项目，并使用循环来完成这项工作：
- en: '[PRE4]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The problem here is that `push` gets called multiple times, which causes the
    array to send out multiple change notifications. It''s much easier for the subscribers
    of the array if all of the changes are sent at once. This can be done by collecting
    all of the changes in the loop and then applying them to the observable array
    at the end with `push.apply`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是`push`被多次调用，导致数组发送出多次更改通知。如果所有更改一次性发送，对数组的订阅者来说会更容易。这可以通过在循环中收集所有更改，然后在最后使用`push.apply`将它们应用到可观察数组中来实现：
- en: '[PRE5]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The preceding method ensures that only a single call to `valueHasMutated` happens
    for the observable array. A popular solution to this common problem is to add
    this into a function on the `observableArray.fn` object, making it available to
    all observable arrays:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法确保对于可观察数组只发生一次`valueHasMutated`调用。对于这个常见问题的一个流行解决方案是将此添加到`observableArray.fn`对象上的函数中，使其对所有可观察数组都可用：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The following method can be used to add an array of items:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 以下方法可以用来添加一个项目数组：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Limit active bindings
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 限制活动绑定
- en: A large number of bindings, especially those that register event handlers such
    as value and click can quickly lead to poor browser performance. Managing this
    takes careful consideration about how to best reduce the number of changes that
    need to happen simultaneously.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 大量的绑定，尤其是那些注册事件处理程序（如值和点击）的绑定，可能会迅速导致浏览器性能下降。管理这一点需要仔细考虑如何最好地减少同时需要发生的变化的数量。
- en: One method is to use control flow bindings to remove bound sections that are
    not required. Limiting the amount of content on the screen helps performance and
    also has the incidental benefit of reducing the clutter that users need to parse.
    Techniques such as pagination can be used for more than just long lists, such
    as breaking up a long form or activity into several screens. Of course, this method
    is limited to activities that can be broken up.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是使用控制流绑定来移除不必要的绑定部分。限制屏幕上的内容量有助于性能，并且还有减少用户需要解析的杂乱信息的附带好处。例如，分页技术不仅适用于长列表，还可以用来将长表单或活动拆分成几个屏幕。当然，这种方法仅限于可以拆分的活动。
- en: A more broadly applicable method is to use delegated events, which are otherwise
    known as **unobtrusive event handlers**.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更广泛适用的方法是使用委派事件，也称为**非侵入式事件处理器**。
- en: Delegated events
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 委派事件
- en: 'Unobtrusive event handlers, such as jQuery''s `on`, can use a single event
    handler to respond to events on any number of DOM elements that are inside the
    registered element. This is especially useful in large or recursive lists where
    registering a single event handler per element would be too expensive. Knockout
    provides two utility methods to connect these handlers with the appropriate data
    from the binding context in a manner that''s similar to the how Knockout''s click
    binding provides the context as the first parameter:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 无侵入式事件处理器，如 jQuery 的 `on`，可以使用单个事件处理器来响应注册元素内部任意数量的 DOM 元素上的事件。这在处理大型或递归列表时特别有用，因为为每个元素注册单个事件处理器可能会过于昂贵。Knockout
    提供了两种实用方法来将这些处理器与绑定上下文中的适当数据连接起来，其方式类似于 Knockout 的点击绑定如何将上下文作为第一个参数提供：
- en: '`ko.dataFor` (element): This returns the data that is available to the element'
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.dataFor` (元素): 这返回可用于元素的 数据'
- en: '`ko.contextFor` (element): This returns the binding context for the element
    (includes binding context properties such as `$parent` and `$root`)'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.contextFor` (元素): 这返回元素的绑定上下文（包括绑定上下文属性，如 `$parent` 和 `$root`）'
- en: 'This can be combined with a binding handler that provides the event delegation:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以与提供事件委托的绑定处理器结合使用：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The preceding example can be seen in the `cp7-unobtrusive` branch.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的示例可以在 `cp7-unobtrusive` 分支中看到。
- en: The preceding technique is not required everywhere, but when dealing with large
    numbers of handlers, it can lead to a noticeable impact on performance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 前述技术并非在所有地方都必需，但在处理大量处理器时，它可能会导致性能上的明显影响。
- en: Summary
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Again, these are guidelines and not rules, and some of them are opinions that
    will lead to disagreement among coworkers. Sometimes, breaking the pattern produces
    cleaner and clearer code and is the only way to get something working while sometimes,
    breaking the pattern is the only way to compromise with colleagues. If it's getting
    in your way without giving you any benefits, don't do it. There is no one right
    way to develop software.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这些是指导原则而不是规则，其中一些是可能导致同事之间意见分歧的观点。有时，打破模式会产生更清晰、更简洁的代码，并且是使某些事情能够工作的唯一方法；有时，打破模式是唯一能与同事妥协的方法。如果它阻碍了你的工作而没有给你带来任何好处，就不要这样做。软件开发没有唯一正确的方法。
- en: The next chapter will cover some popular Knockout plugins maintained by the
    community.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍一些由社区维护的流行 Knockout 插件。
