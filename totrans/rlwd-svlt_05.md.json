["```js\nfunction action(node) {\n  return {\n    destroy() {}\n  };\n}\n```", "```js\n<div use:action />\n```", "```js\nconst action_obj = action(div);\n```", "```js\nif (action_obj && action_obj.destroy) action_obj.destroy();\n```", "```js\nfunction action(node, parameter) {\n  return {\n   update(parameter) {},\n   destroy() {},\n  };\n}\n```", "```js\naction_obj.update(new_value);\n```", "```js\n<div use:action={value} />\n```", "```js\n<script>\n  let timer;\n  function handleMousedown() {\n    timer = setTimeout(() => {\n      console.log('long press!');\n    }, 2000);\n  }\n  function handleMouseup() {\n    clearTimeout(timer);\n  }\n</script>\n<button\n  on:mousedown={handleMousedown}\n  on:mouseup={handleMouseup}\n/>\n```", "```js\n<!-- LongPressButton.svelte -->\n<button\n  // besides the longpress behavior\n  on:mousedown={handleMousedown}\n  on:mouseup={handleMouseup}\n  // you need to pass down props as attributes\n  {...$$props}\n  // and also forward events up\n  on:click\n  on:dblclick\n>\n  <slot />\n</button>\n```", "```js\nfunction longPress(node) {\n  let timer;\n  function handleMousedown() {\n    timer = setTimeout(() => {\n      console.log('long press!');\n    }, 2000);\n  }\n  function handleMouseup() {\n    clearTimeout(timer);\n  }\n  node.addEventListener('mousedown', handleMousedown);\n  node.addEventListener('mouseup', handleMouseup);\n  return {\n    destroy() {\n     node.removeEventListener('mousedown', handleMousedown);\n     node.removeEventListener('mouseup', handleMouseup);\n    }\n  }\n}\n```", "```js\n<button use:longPress>Button one</button>\n<button use:longPress>Button two</button>\n```", "```js\n<span use:longPress>Hold on to me</span>\n```", "```js\n<button use:longPress class=\"...\" on:click={...} />\n```", "```js\n<button use:longPress={doSomething1} />\n<button use:longPress={doSomething2} />\n```", "```js\nfunction longPress(node, fn) {\n  // ...\n}\n```", "```js\nfn();\n```", "```js\n<button\n  use:longPress={{\n    onLongPress: doSomething1,\n    duration: 5000\n  }} />\n```", "```js\nfunction longPress(node, { onLongPress, duration = 1000 }) {\n  // if not specified, the default duration is 1s\n}\n```", "```js\nfunction gesture(node, { onSwipe, onDrag, onPinch }) { }\n```", "```js\nif (typeof onSwipe === 'function') onSwipe();\n```", "```js\n<button on:longpress={doSomething1} />\n```", "```js\nnode.dispatchEvent(new CustomEvent('longpress'));\n```", "```js\n<script>\n  function longPress(node, { duration = 1000 } = {}) {\n    let timer;\n    function handleMousedown() {\n      timer = setTimeout(() => {\n        node.dispatchEvent(new CustomEvent('longpress'));\n      }, duration);\n    }\n    function handleMouseup() {\n      clearTimeout(timer);\n    }\n    node.addEventListener('mousedown', handleMousedown);\n    node.addEventListener('mouseup', handleMouseup);\n    return {\n      destroy() {\n        node.removeEventListener('mousedown', handleMousedown);\n        node.removeEventListener('mouseup', handleMouseup);\n     }\n    }\n  }\n</script>\n<button longPress action to the button element, which adds logic to determine whether the button is being long-pressed. When the button is long-pressed, the longPress action dispatches a custom event called 'longpress' on the element. To react to and trigger specific behaviors when the custom 'longpress' event is dispatched on the element, we can listen to the event by using on:longpress with an event handler.\nIt may feel like a roundabout way to call a function from an action by dispatching an event, but doing it this way has a few pros:\n\n*   Whether we listen to the `'longpress'` event on the button or not, the action could still dispatch the `'longpress'` custom event. So, with this approach, we don’t need to check whether the handler is defined or not.\n*   Listening to the `'longpress'` event using `on:` instead of passing the function directly into the action would mean that you could use other Svelte features that come with Svelte’s `on:` directive. For example, to only listen to the `'longpress'` event once, you can use the `|once` event modifier, for example, `on:longpress|once`.\n\nAnother way of describing what we have done with the `longPress` action is that the `longPress` action enhances the button element and provides a new event, `'longpress'`, that can be listened to on the element.\nNow that we’ve learned how we can define Svelte actions, and how we can use actions to create new events that we can listen to on an element, let’s look at a few more examples that use this technique.\nExample – validating form inputs with custom events\nThe example that we are going to explore is using actions to validate form inputs.\nWhen you add an input element to your form, you can add attributes such as `required`, `minlength`, and `min` to indicate that the input value has to pass the constraint validation or else would be considered invalid.\nHowever, by default, such a validation check is only done during form submission. There’s no real-time feedback on whether your input is valid as you type.\nTo make the input element validate as you type, we need to add an `'input'` event listener (which will be called on every keystroke as we type in the input element) and call `input.checkValidity()` to validate the input. Now, let’s do just that:\n\n```", "```js\n\n As you call the `checkValidity()` method, if the input is indeed invalid, then it will trigger the `'``invalid'` event:\n\n```", "```js\n\n Unfortunately, there’s no `'valid'` event. So, there’s no way to tell whether the input has passed the validation.\nIt would be great if there were an event called `'validate'` in which within the event details, we can tell whether the input is valid or not. If it isn’t, we could get an error message about why the input is invalid.\nHere’s an example of how we could use the `'``validate'` event:\n\n```", "```js\n\n There isn’t an event called `'validate'`, but we can create this custom event ourselves. So, why not create an action to create this custom event for us?\nThis logic is well suited to be written as an action for the following reasons:\n\n*   It can be reused in other input elements.\n*   This logic itself is not involved in creating or updating elements. If it were, it would probably be better suited to be a component.\n\nLet us write this action:\n\n1.  Firstly, this action involves listening to the `'input'` event listener. So, in the code, as shown, we are going to add an event listener at the start of the action and remove the `'input'` event listener in the `destroy` method. This means that whenever an element that uses this action is added to the DOM, it will listen to the `'input'` event, and when it is removed from the DOM, the event listener will be automatically removed:\n\n    ```", "```js\n\n     2.  Next, within the input handler, we are going to call `checkValidity()` to check whether the input is valid. If the input is invalid, then we will read `input.validity` and determine the error message:\n\n    ```", "```js\n\n     3.  Finally, we will dispatch the custom `'validate'` event with `isValid` and `errorMessage` as event details:\n\n    ```", "```js\n\n     4.  Now, with this action completed, we can enhance the `<input>` element by adding a new `'validate'` event, which will be called `as-you-type`, letting you know whether the input is currently valid or invalid. It will also show the corresponding error message:\n\n    ```", "```js\n\n    To make the validation results more useful to the user, you can use the result from the `'validate'` event to modify element styles, such as setting the input border color to red when the validation result is invalid, as shown in the following snippet:\n\n    ```", "```js\n\nAre you getting the hang of writing actions that create custom events?\nLet’s try the next one as an exercise. This time, we’ll tackle one of the most common user interactions, drag and drop.\nExercise – creating a drag-and-drop event\nA drag-and-drop behavior means clicking on an element, moving the mouse while holding down the click to drag the element across the screen to the desired location, and then releasing the mouse click to drop the element in the new location.\nA drag-and-drop behavior thus involves coordination between multiple events, namely, `'mousedown'`, `'mousemove'`, and `'mouseup'`.\nAs we perform the drag-and-drop motion, what we are interested in knowing is when the dragging starts, how far the element is dragged, and when the dragging ends.\nThese three events can be translated into three custom events: `'dragStart'`, `'dragMove'`, and `'dragEnd'`.\nLet us try to implement the drag-and-drop behavior as an action that will create these three custom events:\n\n```", "```js\n\n You can check the answer to this exercise here: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05/03-drag-and-drop](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05/03-drag-and-drop).\nSummary\nIn this chapter, we saw how to define an action. We talked about one of the common patterns of actions, which is to create custom events. This allows us to encapsulate DOM event logic into custom events and reuse them across elements.\nIn the next chapter, we will look at the next common pattern of actions, which is integrating third-party libraries.\n\n```"]