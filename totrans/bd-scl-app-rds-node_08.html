<html><head></head><body>
<article epub:type="bodymatter">
<header>
<h1 class="chap2"><a id="page301" class="calibre6"/><a href="toc.xhtml#c09" class="calibre6">C<small class="calibre8">HAPTER</small> 9</a></h1>
<h1 class="subchap"><a href="toc.xhtml#c09" class="calibre6">Testing API</a></h1>
</header>
<h1 class="sec" id="s229"><a href="toc.xhtml#s229a" class="calibre6">Introduction</a></h1>
<p class="nonindent">Node.js is a versatile runtime environment that allows developers to run JavaScript on the server-side. When it comes to testing REST APIs, Node.js offers numerous libraries and tools to streamline the process. With Node.js, you can write automated tests that interact with your RESTful APIs, send HTTP requests, and verify responses. It provides a flexible and scalable platform for running API tests, making it an excellent choice for both unit and integration testing.</p>
<p class="nonindent">Node.js also allows you to leverage various testing frameworks and libraries, such as Mocha, Chai, Jest, and Supertest. These tools simplify the creation of test suites, assertion checks, and test runners for your API endpoints. In addition, Node.js’s asynchronous nature is well-suited for making HTTP requests and handling asynchronous responses, which is crucial in testing APIs. This asynchronous capability ensures that your tests can efficiently handle multiple requests and responses simultaneously.</p>
<p class="nonindent">In this chapter, we will explore the process of creating test cases and performing API validation.</p>
<h1 class="sec" id="s230"><a href="toc.xhtml#s230a" class="calibre6">Structure</a></h1>
<p class="nonindent">In this chapter, we will discuss the following topics:</p>
<ul class="bull">
<li class="calibre9">Overview of Unit Testing</li>
<li class="calibre9">Mocha Framework</li>
<li class="calibre9">Define Test Cases</li>
<li class="calibre9">Verify Developed API</li>
</ul>
<h1 class="sec" id="s231"><a href="toc.xhtml#s231a" class="calibre6">Overview of Unit Testing</a></h1>
<p class="nonindent">Unit testing is a fundamental practice in software development that ensures that individual units of code are working as intended. In the context of a REST API, this means testing each endpoint and the associated business logic separately to verify that they respond correctly to different inputs and situations.</p>
<p class="nonindent">Unit testing is just one part of testing a REST API. It complements other types of testing, <a id="page302"/>such as integration testing (testing how different parts of the API work together) and end-to-end testing (testing the entire application from the user’s perspective).</p>
<p class="nonindent">Unit testing is a critical practice in software development, but it is highly specific to the codebase that you are working with. When writing unit test cases, it is important to cover a wide range of scenarios to ensure your code functions correctly. Here are some key points to consider when writing unit tests:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Test Case Structure:</strong>
<p class="nonindent">Describe what the test case is testing using `<code class="calibre7"><strong class="calibre3">describe</strong></code>` blocks. Create individual test cases using `<code class="calibre7"><strong class="calibre3">it</strong></code>` blocks. Structure your tests logically, covering various aspects of your code.</p></li>
<li class="calibre9"><strong class="calibre3">Test Data:</strong>
<p class="nonindent">Include test data or mock data that covers different input scenarios. Include edge cases, boundary values, and typical inputs to validate your code’s behavior in different situations.</p></li>
<li class="calibre9"><strong class="calibre3">Assertions:</strong>
<p class="nonindent">Use assertions provided by your testing framework (for example, Chai, Jest, Jasmine) to check that the code produces the expected results. Verify that the actual results match the expected results.</p></li>
<li class="calibre9"><strong class="calibre3">Error Handling:</strong>
<p class="nonindent">Ensure your code handles errors or exceptions correctly. Test scenarios where exceptions or errors are expected to be thrown.</p></li>
<li class="calibre9"><strong class="calibre3">Code Coverage:</strong>
<p class="nonindent">Aim for good code coverage, ensuring that as much of your code as possible is executed by your tests. Use code coverage tools to identify untested code paths.</p></li>
<li class="calibre9"><strong class="calibre3">Mocks and Stubs:</strong>
<p class="nonindent">Use mocks and stubs to simulate external dependencies like databases, APIs, or services. Ensure that your code interacts correctly with these dependencies.</p></li>
<li class="calibre9"><strong class="calibre3">Positive and Negative Testing:</strong>
<p class="nonindent">Test with positive scenarios where everything works as expected. Test with negative scenarios, where things may go wrong, and the code handles errors correctly.</p></li>
<li class="calibre9"><strong class="calibre3">Regression Testing:</strong>
<p class="nonindent">Periodically run your unit tests to catch regressions when new code changes are introduced.</p></li>
<li class="calibre9"><strong class="calibre3"><a id="page303"/>Automation</strong>
<p class="nonindent">Unit tests are automated, meaning they can be run automatically by a testing framework without manual intervention.</p></li>
<li class="calibre9"><strong class="calibre3">Fast Execution</strong>
<p class="nonindent">Unit tests are designed to be fast, so they can be run frequently during development. This quick feedback loop helps catch issues early in the development process.</p></li>
</ul>
<p class="nonindent">Remember that unit tests should focus on a single unit of code (a function, method, or a small component) and should be fast to execute. Writing comprehensive unit tests helps identify and resolve issues early in the development process, leading to more robust and maintainable code.</p>
<p class="nonindent">End-to-End Testing, on the other hand, assesses the entire application from start to finish. It simulates real user scenarios. It essentially tests how a user would interact with the application and includes real database connections, network connections, and more. If there is any other application needed to be connected, it connects that as well.</p>
<p class="nonindent">In this chapter, for testing features, we will connect to a real database to fetch data. When we use real database connection in tests which ideally would be unit tests, we move towards a more integrated testing approach. Sometimes, it may be referred to as integration tests.</p>
<h1 class="sec" id="s232"><a href="toc.xhtml#s232a" class="calibre6">Mocha Framework</a></h1>
<p class="nonindent">Mocha is a popular JavaScript test framework for Node.js and web browsers. It provides a versatile and feature-rich environment for writing and running test cases for your JavaScript applications. Mocha is often used in conjunction with assertion libraries like Chai for making assertions in test cases.</p>
<p class="nonindent">Mocha is well-regarded for its flexibility and wide adoption among developers for various reasons:</p>
<ul class="bull">
<li class="calibre9"><strong class="calibre3">Ease of Use:</strong>
<p class="nonindent">Mocha’s syntax is easy to learn and write, making it accessible for both beginners and experienced developers.</p></li>
<li class="calibre9"><strong class="calibre3">Support for Various Test Styles:</strong>
<p class="nonindent">Mocha supports different test styles such as BDD (Behavior-Driven Development), TDD (Test-Driven Development), and QUnit.</p></li>
<li class="calibre9"><strong class="calibre3">Asynchronous Testing:</strong>
<p class="nonindent">Mocha has built-in support for testing asynchronous code, allowing you to use <code class="calibre7"><strong class="calibre3">callbacks</strong></code>, <code class="calibre7"><strong class="calibre3">promises</strong></code>, or <code class="calibre7"><strong class="calibre3">async</strong></code>/<code class="calibre7"><strong class="calibre3">await</strong></code>.</p></li>
<li class="calibre9"><strong class="calibre3"><a id="page304"/>Hooks:</strong> 
<p class="nonindent">Mocha provides hooks like <code class="calibre7"><strong class="calibre3">before</strong></code>, <code class="calibre7"><strong class="calibre3">after</strong></code>, <code class="calibre7"><strong class="calibre3">beforeEach</strong></code>, and <code class="calibre7"><strong class="calibre3">afterEach</strong></code> to set up and tear down test fixtures.</p></li>
<li class="calibre9"><strong class="calibre3">Reporter System:</strong>
<p class="nonindent">Mocha offers a range of built-in reporters for generating test reports and results in different formats, as well as custom reporter support.</p></li>
<li class="calibre9"><strong class="calibre3">Parallel Test Execution:</strong> 
<p class="nonindent">Mocha can run tests in parallel, which can significantly reduce test execution time for large test suites.</p></li>
<li class="calibre9"><strong class="calibre3">Test Suites and Nested Descriptions:</strong> 
<p class="nonindent">You can organize your tests into hierarchical suites and describe blocks for better structure and readability.</p></li>
<li class="calibre9"><strong class="calibre3">Timeouts:</strong>
<p class="nonindent">Mocha allows you to set timeout limits for individual tests or test suites, helping identify slow or blocking tests.</p></li>
<li class="calibre9"><strong class="calibre3">Test Skips and Exclusivity:</strong> 
<p class="nonindent">You can skip or focus on specific tests or suites using <code class="calibre7"><strong class="calibre3">.skip</strong></code> and <code class="calibre7"><strong class="calibre3">.only</strong></code>.</p></li>
<li class="calibre9"><strong class="calibre3">Browser and Node.js Support:</strong> 
<p class="nonindent">Mocha can be used both in Node.js and in web browsers.</p></li>
</ul>
<p class="nonindent">Mocha’s flexibility, extensive ecosystem, and active community make it a popular choice for testing JavaScript applications, ranging from small libraries to large complex projects.</p>
<p class="nonindent">To use Mocha, you typically install it as an npm package and write your test cases in JavaScript or a testing framework like Chai. Mocha provides a command-line interface for running tests, and it can be integrated into Continuous Integration (CI) pipelines to automate testing.</p>
<h1 class="sec1" id="s233"><a href="toc.xhtml#s233a" class="calibre6">Installing Mocha and Chai</a></h1>
<p class="nonindent">Mocha is a testing framework, and Chai is an assertion library often used together for testing. Install them as development dependencies in our project through <code class="calibre7"><strong class="calibre3">cmd</strong></code> enter the following command with root of project directory</p>
<p class="code"><code class="calibre7"><strong class="calibre3">$ npm install mocha chai @types/mocha @types/chai --save-dev</strong></code></p>
<p class="nonindent">After you have successfully installed Chai, let us explore how to utilize it. Chai serves as a versatile assertion library, effectively functioning as a plugin for your testing needs. <a id="page305"/><code class="calibre7"><strong class="calibre3">Chai</strong></code> offers three primary styles: <code class="calibre7"><strong class="calibre3">"expect</strong></code>,<code class="calibre7"><strong class="calibre3">"</strong></code> <code class="calibre7"><strong class="calibre3">"should</strong></code>,<code class="calibre7"><strong class="calibre3">"</strong></code> and <code class="calibre7"><strong class="calibre3">"assert</strong></code>.<code class="calibre7"><strong class="calibre3">"</strong></code> You can use any of these, but <code class="calibre7"><strong class="calibre3">"expect"</strong></code> is the most popular choice.</p>
<p class="code"><code class="calibre7">const chai = require('chai');</code></p>
<p class="code1"><code class="calibre7">const expect = chai.expect;</code></p>
<p class="code"><code class="calibre7">// Expect a value to be equal to another value</code></p>
<p class="code1"><code class="calibre7">expect(5).to.equal(5);</code></p>
<p class="code"><code class="calibre7">// Expect an array to include a specific element</code></p>
<p class="code1"><code class="calibre7">expect([1, 2, 3]).to.include(2);</code></p>
<p class="code"><code class="calibre7">// Expect a value to be a certain data type</code></p>
<p class="code1"><code class="calibre7">expect('Hello').to.be.a('string');</code></p>
<p class="code"><code class="calibre7">// Expect an object to have a property</code></p>
<p class="code1"><code class="calibre7">expect({ name: 'John' }).to.have.property('name');</code></p>
<p class="nonindent">You can chain various methods to create complex assertions. <code class="calibre7"><strong class="calibre3">Chai</strong></code> provides a wide range of assertion methods to check equality, check for the existence of properties, and more. Chai is often used in conjunction with testing frameworks like Mocha.</p>
<p class="nonindent">Let us create one directory with the name as <code class="calibre7"><strong class="calibre3">tests</strong></code> in <code class="calibre7"><strong class="calibre3">src</strong></code> directory of the project with <code class="calibre7"><strong class="calibre3">test.spec.ts</strong></code> file. The test file extension must be <code class="calibre7"><strong class="calibre3">.spec.ts</strong></code> so that tooling can identify it as a file with tests (also known as a spec file). As per the following directory structure you can make test files.</p>
<p class="code"><code class="calibre7"><strong class="calibre3">tests/</strong></code></p>
<p class="code1"><code class="calibre7">├── user/</code></p>
<p class="code1"><code class="calibre7">│   ├── user.spec.ts</code></p>
<p class="code1"><code class="calibre7">├── project/</code></p>
<p class="code1"><code class="calibre7">│   ├── project.spec.ts</code></p>
<p class="code1"><code class="calibre7">├── task/</code></p>
<p class="code1"><code class="calibre7">│   ├── task.spec.ts</code></p>
<p class="code1"><code class="calibre7">├── common/</code></p>
<p class="code1"><code class="calibre7">│   ├── utility.spec.ts</code></p>
<p class="code1"><code class="calibre7">└── mocha.opts</code></p>
<p class="nonindent">You can create a Mocha configuration file (<code class="calibre7"><strong class="calibre3">mocha.opts</strong></code>) if you want to specify Mocha options. This file is optional, but it can be handy for configuring Mocha behavior. Here is a simple example:</p>
<p class="code"><code class="calibre7">--require ts-node/register</code></p>
<p class="code1"><code class="calibre7">--require chai/register-assert</code></p>
<p class="code1"><code class="calibre7">--require chai/register-expect</code></p>
<p class="code1"><code class="calibre7">--require chai/register-should</code></p>
<p class="code1"><code class="calibre7">--require chai-http/register</code></p>
<p class="nonindent"><a id="page306"/>In the <code class="calibre7"><strong class="calibre3">tsconfig.json</strong></code> file add <code class="calibre7"><strong class="calibre3">"types": ["express", "./src/custom.d.ts"]</strong></code> in <code class="calibre7"><strong class="calibre3">compilerOptions</strong></code>.</p>
<p class="nonindent">In the <code class="calibre7"><strong class="calibre3">package.json</strong></code> file add test script as follows:</p>
<p class="code"><code class="calibre7">"scripts": {</code></p>
<p class="code3"><code class="calibre7">"test": "mocha --require ts-node/register src/**/*.spec.ts</code></p>
<p class="code2"><code class="calibre7">src/**/**/*.spec.ts</code></p>
<p class="code1"><code class="calibre7">",</code></p>
<p class="code3"><code class="calibre7"> …</code></p>
<p class="code1"><code class="calibre7"> }</code></p>
<p class="nonindent">Currently, no test cases are defined, so it will display 0 passing tests.</p>
<figure class="img">
<img alt="" src="images/9.1.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig9_1"><strong class="calibre3">Figure 9.1:</strong> Run Test Script</p>
<h1 class="sec" id="s234"><a href="toc.xhtml#s234a" class="calibre6">Defining a Test Case</a></h1>
<p class="nonindent">After the configuration is added, let us define first basic test case in <code class="calibre7"><strong class="calibre3">utility.spec.ts</strong></code> file with the following code:</p>
<p class="code"><code class="calibre7">import chai from 'chai';</code></p>
<p class="code1"><code class="calibre7">import chaiHttp from 'chai-http';</code></p>
<p class="code1"><code class="calibre7">chai.use(chaiHttp);import { describe, it } from 'mocha';</code></p>
<p class="code1"><code class="calibre7">// Use Chai with Chai HTTP</code></p>
<p class="code1"><code class="calibre7">const expect = chai.expect;</code></p>
<p class="code1"><code class="calibre7">describe('Array', function () {</code></p>
<p class="code2"><code class="calibre7">describe('#indexOf()', function () {</code></p>
<p class="code3"><code class="calibre7">it('should return -1 when the value is not present', function () {</code></p>
<p class="code4"><code class="calibre7">expect([1, 2, 3].indexOf(4)).to.equal(-1);</code></p>
<p class="code3"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent"><a id="page307"/>This test case checks if the <code class="calibre7"><strong class="calibre3">indexOf</strong></code> function correctly returns <code class="calibre7"><strong class="calibre3">-1</strong></code> when the value is not present in the array. Chai expect function is used for clear and readable assertions in your test cases. If the expectation is met, the test will pass; otherwise, it will fail and provide feedback on what went wrong.</p>
<p class="nonindent">Run the test in <code class="calibre7"><strong class="calibre3">cmd</strong></code> with entering <code class="calibre7"><strong class="calibre3">$ npm run test</strong></code> which gives following output :</p>
<p class="code"><code class="calibre7"><strong class="calibre3">Array</strong></code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">1) #indexOf()</strong></code></p>
<p class="code3"><code class="calibre7"><strong class="calibre3">✔should return -1 when the value is not present</strong></code></p>
<figure class="img">
<img alt="" src="images/9.2.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig9_2"><strong class="calibre3">Figure 9.2:</strong> Utility Success Test Case</p>
<p class="nonindent">If you change expect line with <code class="calibre7"><strong class="calibre3">expect([1, 2, 3].indexOf(3)).to.equal(-1)</strong></code>; that fails the test case and gives following output with red mark:</p>
<p class="code"><code class="calibre7"><strong class="calibre3">Array</strong></code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">1) #indexOf()</strong></code></p>
<p class="code4"><code class="calibre7"><strong class="calibre3">should return -1 when the value is not present</strong></code></p>
<a id="page308"/>
<figure class="img">
<img alt="" src="images/9.3.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig9_3"><strong class="calibre3">Figure 9.3:</strong> Utility Fail Test Case</p>
<p class="nonindent">This is a very basic test case to get started. Now, let us dive into more test cases by connecting our application and configuring it for execution.</p>
<h1 class="sec" id="s235"><a href="toc.xhtml#s235a" class="calibre6">Configuring the Application</a></h1>
<p class="nonindent">We need to make some changes in <code class="calibre7"><strong class="calibre3">express_server.ts</strong></code> file. Since we want to connect <code class="calibre7"><strong class="calibre3">express</strong></code> app in test cases, we need to export it. Here is the updated code:</p>
<p class="code"><code class="calibre7">import express from 'express';</code></p>
<p class="code1"><code class="calibre7">import * as bodyParser from 'body-parser';</code></p>
<p class="code1"><code class="calibre7">import { IServerConfig } from './utils/config';</code></p>
<p class="code1"><code class="calibre7">import * as config from '../server_config.json';</code></p>
<p class="code1"><code class="calibre7">import { Routes } from './routes';</code></p>
<p class="code"><code class="calibre7">export class ExpressServer {</code></p>
<p class="code2a"><code class="calibre7">private static server = null;</code></p>
<p class="code2"><code class="calibre7"><a id="page309"/>public server_config: IServerConfig = config;</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">public app;</strong></code></p>
<p class="code2"><code class="calibre7">constructor() {</code></p>
<p class="code3"><code class="calibre7">const port = this.server_config.port ?? 3000;</code></p>
<p class="code3"><code class="calibre7">// initialize express app</code></p>
<p class="code3"><code class="calibre7"><strong class="calibre3">this.app = express();</strong></code></p>
<p class="code3"><code class="calibre7">this.app.use(bodyParser.urlencoded({ extended: false }));</code></p>
<p class="code3"><code class="calibre7">this.app.use(bodyParser.json());</code></p>
<p class="code3a"><code class="calibre7">this.app.get('/ping', (req, res) =&gt; {</code></p>
<p class="code4"><code class="calibre7">res.send('pong');</code></p>
<p class="code3"><code class="calibre7">});</code></p>
<p class="code3a"><code class="calibre7">const routes = new Routes(this.app);</code></p>
<p class="code3"><code class="calibre7">if (routes) {</code></p>
<p class="code4"><code class="calibre7">console.log('Server Routes started for server');</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code3a"><code class="calibre7">ExpressServer.server = this.app.listen(port, () =&gt; {</code></p>
<p class="code4"><code class="calibre7">console.log(`Server is running on port ${port} with pid = ${process.pid}`);</code></p>
<p class="code3"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2a"><code class="calibre7">//close the express server for safe on uncaughtException</code></p>
<p class="code2"><code class="calibre7">public closeServer(): void {</code></p>
<p class="code3"><code class="calibre7">ExpressServer.server.close(() =&gt; {</code></p>
<p class="code4"><code class="calibre7">console.log('Server closed');</code></p>
<p class="code4"><code class="calibre7">process.exit(0);</code></p>
<p class="code3"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent">Similarly, when dealing with test cases, it is necessary to connect to the database. Replace the code in the <code class="calibre7"><strong class="calibre3">db.ts</strong></code> file with the following:</p>
<p class="code"><code class="calibre7">import { DataSource, Repository } from 'typeorm';</code></p>
<p class="code1"><code class="calibre7">import { IServerConfig } from './config';</code></p>
<p class="code1"><code class="calibre7"><a id="page310"/>import * as config from '../../server_config.json';</code></p>
<p class="code1"><code class="calibre7">import { Roles } from '../components/roles/roles_entity';</code></p>
<p class="code1"><code class="calibre7">import { Users } from '../components/users/users_entity';</code></p>
<p class="code1"><code class="calibre7">import { Projects } from '../components/projects/projects_entity';</code></p>
<p class="code1"><code class="calibre7">import { Tasks } from '../components/tasks/tasks_entity';</code></p>
<p class="code1"><code class="calibre7">import { Comments } from '../components/comments/comments_entity';</code></p>
<p class="code"><code class="calibre7">export class DatabaseUtil {</code></p>
<p class="code2"><code class="calibre7">private server_config: IServerConfig = config;</code></p>
<p class="code2"><code class="calibre7">private static connection: DataSource | null = null;</code></p>
<p class="code2"><code class="calibre7">private repositories: Record&lt;string, Repository&lt;any&gt;&gt; = {};</code></p>
<p class="code2a"><code class="calibre7">constructor() {</code></p>
<p class="code3"><code class="calibre7">this.connectDatabase();</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2a"><code class="calibre7">/**</code></p>
<p class="code3"><code class="calibre7">* Establishes a database connection or returns the existing connection if available.</code></p>
<p class="code3"><code class="calibre7">* @returns The database connection instance.</code></p>
<p class="code3"><code class="calibre7">*/</code></p>
<p class="code2"><code class="calibre7">public async connectDatabase(): <strong class="calibre3">Promise&lt;DataSource&gt;</strong> {</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7"><strong class="calibre3">if (DatabaseUtil.connection) {</strong></code></p>
<p class="code5"><code class="calibre7"><strong class="calibre3">return Promise.resolve(DatabaseUtil.connection);</strong></code></p>
<p class="code4"><code class="calibre7"><strong class="calibre3">}</strong> else {</code></p>
<p class="code5"><code class="calibre7">const db_config = this.server_config.db_config;</code></p>
<p class="code5"><code class="calibre7">const AppSource = new DataSource({</code></p>
<p class="code6"><code class="calibre7">type: 'postgres',</code></p>
<p class="code6"><code class="calibre7">host: db_config.host,</code></p>
<p class="code6"><code class="calibre7">port: db_config.port,</code></p>
<p class="code6"><code class="calibre7">username: db_config.username,</code></p>
<p class="code6"><code class="calibre7">password: db_config.password,</code></p>
<p class="code6"><code class="calibre7">database: db_config.dbname,</code></p>
<p class="code6"><code class="calibre7">entities: [Roles, Users, Projects, Tasks, Comments,Files],</code></p>
<p class="code6"><code class="calibre7"><a id="page311"/>synchronize: true,</code></p>
<p class="code6"><code class="calibre7">logging: true,</code></p>
<p class="code6"><code class="calibre7">poolSize: 10</code></p>
<p class="code5"><code class="calibre7">});</code></p>
<p class="code5"><code class="calibre7">await AppSource.initialize();</code></p>
<p class="code5"><code class="calibre7">DatabaseUtil.connection = AppSource;</code></p>
<p class="code5"><code class="calibre7">console.log('Connected to the database');</code></p>
<p class="code5"><code class="calibre7">return DatabaseUtil.connection;</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code3a"><code class="calibre7">} catch (error) {</code></p>
<p class="code4"><code class="calibre7">console.error('Error connecting to the database:', error);</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2a"><code class="calibre7">/**</code></p>
<p class="code3"><code class="calibre7">* Get the repository for a given entity.</code></p>
<p class="code3"><code class="calibre7">* @param entity - The entity for which the repository is needed.</code></p>
<p class="code3"><code class="calibre7">* @returns The repository instance for the entity.</code></p>
<p class="code3"><code class="calibre7">*/</code></p>
<p class="code2"><code class="calibre7">public getRepository(entity) {</code></p>
<p class="code3"><code class="calibre7">try {</code></p>
<p class="code4"><code class="calibre7">// Check if a valid database connection is available</code></p>
<p class="code4"><code class="calibre7">if (DatabaseUtil.connection) {</code></p>
<p class="code5"><code class="calibre7">const entityName = entity.name;</code></p>
<p class="code5a"><code class="calibre7">// Check if the repository instance already exists, if not, create it</code></p>
<p class="code5"><code class="calibre7">if (!this.repositories[entityName]) {</code></p>
<p class="code6"><code class="calibre7">this.repositories[entityName] = DatabaseUtil.connection.getRepository(entity);</code></p>
<p class="code5"><code class="calibre7">}</code></p>
<p class="code5"><code class="calibre7">return this.repositories[entityName];</code></p>
<p class="code4"><code class="calibre7">}</code></p>
<p class="code4"><code class="calibre7">return null;</code></p>
<p class="code3"><code class="calibre7">} catch (error) {</code></p>
<p class="code4"><code class="calibre7">console.error(`Error while getRepository =&gt; ${error.message}`);</code></p>
<p class="code3"><code class="calibre7">}</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="nonindent"><a id="page312"/>As shown in the code, we have introduced a <code class="calibre7"><strong class="calibre3">promise</strong></code> to ensure that the test cases run only after the database connection is established. This helps prevent potential errors that could occur otherwise.</p>
<p class="nonindent">In case we want to mock the database connection, there are libraries available to do so. One such library is <code class="calibre7"><strong class="calibre3">sinon</strong></code>, <code class="calibre7"><strong class="calibre3">https://sinonjs.org/</strong></code>.</p>
<p class="nonindent"><code class="calibre7"><strong class="calibre3">Sinon</strong></code> is a testing library used for creating spies, stubs, and mocks in JavaScript tests, rather than specifically for mocking databases. It can be used to intercept and simulate behavior in functions, methods, or any kind of operation in your codebase, including database operations, API requests, or any other external service interactions. This makes it incredibly useful for writing unit and integration tests where you need to isolate the part of the code being tested.</p>
<p class="nonindent">For this chapter, we are interested in checking our API against a real database. Hence, we do not need to use a mock database connection. However, for the sake of completion, an example is added at the end of this chapter.</p>
<p class="nonindent">Now, replace following code in <code class="calibre7"><strong class="calibre3">utility.spec.ts</strong></code> file to export app in test cases:</p>
<p class="code"><code class="calibre7">import { DatabaseUtil } from '../../utils/db';</code></p>
<p class="code1"><code class="calibre7">import { ExpressServer } from '../../express_server';</code></p>
<p class="code1"><code class="calibre7">import chai from 'chai';</code></p>
<p class="code1"><code class="calibre7">import chaiHttp from 'chai-http';</code></p>
<p class="code1"><code class="calibre7">chai.use(chaiHttp);</code></p>
<p class="code"><code class="calibre7">import { describe, it } from 'mocha';</code></p>
<p class="code1"><code class="calibre7">// Use Chai with Chai HTTP</code></p>
<p class="code1"><code class="calibre7">const expect = chai.expect;</code></p>
<p class="code1"><code class="calibre7">let app, expressServer;</code></p>
<p class="code"><code class="calibre7"><strong class="calibre3">before(async () =&gt; {</strong></code></p>
<p class="code2"><code class="calibre7">const databaseUtil = new DatabaseUtil();</code></p>
<p class="code2"><code class="calibre7">await databaseUtil.connectDatabase();</code></p>
<p class="code2"><code class="calibre7">expressServer = new ExpressServer();</code></p>
<p class="code2"><code class="calibre7">app = expressServer.app;</code></p>
<p class="code1"><code class="calibre7"><strong class="calibre3">});</strong></code></p>
<p class="code1"><a id="page313"/><code class="calibre7">// Close the server after all tests are done</code></p>
<p class="code1"><code class="calibre7"><strong class="calibre3">after(function (done) {</strong></code></p>
<p class="code2"><code class="calibre7">expressServer.closeServer(done);</code></p>
<p class="code1"><code class="calibre7"><strong class="calibre3">});</strong></code></p>
<p class="code"><code class="calibre7">export { app };</code></p>
<p class="nonindent">It imports necessary modules like <code class="calibre7"><strong class="calibre3">DatabaseUtil</strong></code>, <code class="calibre7"><strong class="calibre3">ExpressServer</strong></code>, and the testing libraries <code class="calibre7"><strong class="calibre3">(chai and chai-http). chai.use(chaiHttp)</strong></code> configures chai to work with HTTP requests, enabling you to make HTTP requests and perform assertions on their responses.</p>
<h1 class="sec1" id="s236"><a href="toc.xhtml#s236a" class="calibre6">Hooks</a></h1>
<p class="nonindent">In the context of testing frameworks like Mocha, <code class="calibre7"><strong class="calibre3">"before"</strong></code> and <code class="calibre7"><strong class="calibre3">"after"</strong></code> are known as test hooks. They are used to set up and tear down the testing environment. Here is what they do:</p>
<p class="nonindent"><strong class="calibre3">Before Hook</strong> (<code class="calibre7"><strong class="calibre3">before</strong></code>): This hook is executed before any test cases within a test suite (defined using describe) are run. It is typically used for setting up the environment or any common context needed for the tests. For example, you might use it to establish a database connection, initialize variables, or start a server.</p>
<p class="code"><code class="calibre7"><strong class="calibre3">before(() =&gt; {</strong></code></p>
<p class="code3"><code class="calibre7">// Set up the testing environment</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent"><strong class="calibre3">After Hook</strong> (<code class="calibre7"><strong class="calibre3">after</strong></code>): This hook is executed after all test cases within a test suite have run. It is commonly used for cleaning up the environment, releasing resources, or performing any necessary actions after the tests are completed. For example, you might use it to close a database connection, shut down a server, or perform <code class="calibre7"><strong class="calibre3">cleanup</strong></code> tasks.</p>
<p class="code"><code class="calibre7"><strong class="calibre3">after(() =&gt; {</strong></code></p>
<p class="code2"><code class="calibre7">// Clean up the testing environment</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">Here is how the <code class="calibre7"><strong class="calibre3">"before"</strong></code> and <code class="calibre7"><strong class="calibre3">"after"</strong></code> hooks fit into the test lifecycle:</p>
<p class="nonindent"><strong class="calibre3">Before All Tests</strong>: The <code class="calibre7"><strong class="calibre3">"before"</strong></code> hook is executed before any of the test cases within the suite are run. It is a one-time setup for the entire suite.</p>
<p class="nonindent"><strong class="calibre3">Run Test Cases</strong>: All the test cases (it blocks) within the suite are executed.</p>
<p class="nonindent"><strong class="calibre3"><a id="page314"/>After All Tests</strong>: The <code class="calibre7"><strong class="calibre3">"after"</strong></code> hook is executed once all the test cases in the suite have been completed. It is a one-time <code class="calibre7"><strong class="calibre3">cleanup</strong></code> step for the suite.</p>
<p class="nonindent">These hooks are useful for ensuring a consistent and clean test environment for each test suite. They help avoid code repetition and make it easier to manage resources like database connections, servers, or other setup and teardown tasks.</p>
<p class="nonindent">There are also <code class="calibre7"><strong class="calibre3">beforeEach()</strong></code>, and <code class="calibre7"><strong class="calibre3">afterEach()</strong></code> hooks that will execute before each test case and after each test case respectively.</p>
<p class="nonindent">We can explore hook with another example such as payment create one <code class="calibre7"><strong class="calibre3">payment.spec.ts</strong></code> file with following code :</p>
<p class="code"><code class="calibre7">import { expect } from 'chai';</code></p>
<p class="code1"><code class="calibre7">import { describe, it } from 'mocha';</code></p>
<p class="code"><code class="calibre7">class Payment {</code></p>
<p class="code2"><code class="calibre7">private amount: number;</code></p>
<p class="code2"><code class="calibre7">private method: string;</code></p>
<p class="code2a"><code class="calibre7">constructor(amount: number, method: string) {</code></p>
<p class="code3"><code class="calibre7">this.amount = amount;</code></p>
<p class="code3"><code class="calibre7">this.method = method;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code2a"><code class="calibre7">processPayment(): string {</code></p>
<p class="code3"><code class="calibre7">// Simulate payment processing</code></p>
<p class="code3"><code class="calibre7">return `Payment of ${this.amount} processed via ${this.method}`;</code></p>
<p class="code2"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code"><code class="calibre7">describe('Payment', () =&gt; {</code></p>
<p class="code2"><code class="calibre7">let payment: Payment;</code></p>
<p class="code2a"><code class="calibre7">// Before hook: This will run before the test suite before(() =&gt; {</code></p>
<p class="code3"><code class="calibre7">console.log('Setting up payment processing…');</code></p>
<p class="code3"><code class="calibre7">// Perform setup tasks, e.g., initialize payment gateway</code></p>
<p class="code3"><code class="calibre7">payment = new Payment(100, 'Credit Card');</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code2a"><a id="page315"/><code class="calibre7">// After hook: This will run after the test suite after(() =&gt; {</code></p>
<p class="code3"><code class="calibre7">console.log('Tearing down payment processing…');</code></p>
<p class="code3"><code class="calibre7">// Perform teardown tasks, e.g., close payment gateway connection</code></p>
<p class="code3"><code class="calibre7">payment = null!;</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code2a"><code class="calibre7">// Test case</code></p>
<p class="code2"><code class="calibre7">it('should process payment successfully', () =&gt; {</code></p>
<p class="code3"><code class="calibre7">// Act</code></p>
<p class="code3"><code class="calibre7">const result = payment.processPayment();</code></p>
<p class="code3a"><code class="calibre7">// Assert</code></p>
<p class="code3"><code class="calibre7">expect(result).to.equal('Payment of 100 processed via Credit Card');</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent">In this example:</p>
<ul class="bull">
<li class="calibre9">We have a Payment class with a <code class="calibre7"><strong class="calibre3">processPayment</strong></code> method that simulates processing a payment transaction.</li>
<li class="calibre9">We use Mocha’s before hook to perform setup tasks before the test suite. This includes initializing payment processing, such as setting up a payment gateway.</li>
<li class="calibre9">We use Mocha’s after hook to perform teardown tasks after the test suite. This includes closing the payment gateway connection.</li>
<li class="calibre9">We define a single test case to verify that the payment is processed successfully.</li>
<li class="calibre9">Before the test suite runs, the <code class="calibre7"><strong class="calibre3">"Setting up payment processing…"</strong></code> message will be logged, indicating that payment processing is being set up.</li>
<li class="calibre9">After the test suite runs, the <code class="calibre7"><strong class="calibre3">"Tearing down payment processing…"</strong></code> message will be logged, indicating that payment processing is being torn down.</li>
</ul>
<p class="nonindent">Now run the test script in the terminal and it will display following output:</p>
<a id="page316"/>
<figure class="img">
<img alt="" src="images/9.4.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig9_4"><strong class="calibre3">Figure 9.4:</strong> Hook Example with Payment</p>
<h1 class="sec" id="s237"><a href="toc.xhtml#s237a" class="calibre6">Verifying APIs through Test cases</a></h1>
<p class="nonindent">In the world of software development, ensuring that your application’s APIs work as intended is of paramount importance. To achieve this, we rely on test cases, which are a structured approach to validating the functionality, correctness, and performance of APIs. Verifying APIs through test cases involves systematically testing various aspects of your API to guarantee that it behaves as expected.</p>
<h1 class="sec1" id="s238"><a href="toc.xhtml#s238a" class="calibre6">Login Test</a></h1>
<p class="nonindent">Create a <code class="calibre7"><strong class="calibre3">"user.spec.ts"</strong></code> file within the <code class="calibre7"><strong class="calibre3">"tests"</strong></code> directory, specifically within the <code class="calibre7"><strong class="calibre3">"user"</strong></code> subdirectory, and include the following code:</p>
<p class="code"><code class="calibre7">import chai from 'chai';</code></p>
<p class="code1"><code class="calibre7">import chaiHttp from 'chai-http';</code></p>
<p class="code1"><code class="calibre7">chai.use(chaiHttp);</code></p>
<p class="code"><code class="calibre7">import { describe, it } from 'mocha';</code></p>
<p class="code1"><code class="calibre7">// Use Chai with Chai HTTP</code></p>
<p class="code1"><code class="calibre7">const expect = chai.expect;</code></p>
<p class="code1"><code class="calibre7">import { app } from '../common/utility.spec';</code></p>
<p class="code1"><code class="calibre7">let authToken; // Declare a variable to store the authentication token</code></p>
<p class="code"><code class="calibre7">describe('Login API', () =&gt; {</code></p>
<p class="code2"><code class="calibre7">it('should return a success message when login is successful', (done) =&gt; {</code></p>
<p class="code3"><code class="calibre7"><strong class="calibre3">chai.request(app)</strong> // Replace 'app' with your Express app instance</code></p>
<p class="code4"><code class="calibre7"><strong class="calibre3"><a id="page317"/>.post(</strong>'<strong class="calibre3">/api/login</strong>'<strong class="calibre3">)</strong></code></p>
<p class="code4"><code class="calibre7"><strong class="calibre3">.send({ email:</strong> '<strong class="calibre3">yamipanchal1993@gmail.com</strong>'<strong class="calibre3">, password:</strong> '<strong class="calibre3">Abc@123456</strong>' <strong class="calibre3">})</strong></code></p>
<p class="code4"><code class="calibre7">.end((err, res) =&gt; {</code></p>
<p class="code5"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(200);</strong></code></p>
<p class="code5"><code class="calibre7">expect(res.body).to.have.property('status').equal('success');</code></p>
<p class="code5"><code class="calibre7">authToken = res.body.data.accessToken; // Save the authentication token</code></p>
<p class="code5"><code class="calibre7">done();</code></p>
<p class="code4"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code2a"><code class="calibre7">it('should return an error message when login fails', (done) =&gt; {</code></p>
<p class="code3"><code class="calibre7">chai.request(app)</code></p>
<p class="code4"><code class="calibre7">.post('/api/login')</code></p>
<p class="code4"><code class="calibre7"><strong class="calibre3">.send({ email:</strong> '<strong class="calibre3">yamipanchal1993@gmail.com</strong>'<strong class="calibre3">, password:</strong> '<strong class="calibre3">wrongpassword</strong>' <strong class="calibre3">})</strong></code></p>
<p class="code4"><code class="calibre7">.end((err, res) =&gt; {</code></p>
<p class="code5"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(400);</strong></code></p>
<p class="code5"><code class="calibre7"><strong class="calibre3">expect(res.body).to.have.property('message').equal('Password is not valid');</strong></code></p>
<p class="code5"><code class="calibre7">done();</code></p>
<p class="code4"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7">export { authToken };</code></p>
<p class="nonindent">Run the test case in <code class="calibre7"><strong class="calibre3">cmd</strong></code> through the <code class="calibre7"><strong class="calibre3">npm run</strong></code> test which provides the following output.</p>
<p class="code"><code class="calibre7">&gt; pms-be@1.0.0 test</code></p>
<p class="code1"><code class="calibre7">&gt; mocha --require ts-node/register 'src/**/*.spec.ts'</code></p>
<p class="code"><code class="calibre7">Login API</code></p>
<p class="code2"><code class="calibre7">1) "<strong class="calibre3">before all</strong>" hook in "<strong class="calibre3">{root}</strong>"</code></p>
<p class="code3"><code class="calibre7">Connected to the database</code></p>
<p class="code2"><a id="page318"/><code class="calibre7"><strong class="calibre3">✔&gt; should return a success message when login is successful (75ms)</strong></code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔ should return an error message when login fails (46ms)</strong></code></p>
<figure class="img">
<img alt="" src="images/9.5.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig9_5"><strong class="calibre3">Figure 9.5:</strong> Login Test Case</p>
<p class="nonindent">Here, we define two test cases for Login api in that the first has valid data and the second has the wrong password.</p>
<ul class="bull">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">describe('Login API', () =&gt; { … });</strong></code>: This line defines a test suite using the describe function. In this case, it is a suite named <code class="calibre7"><strong class="calibre3">"Login API"</strong></code> that groups related test cases together.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">it('should return a success message when login is successful', (done) =&gt; { … });</strong></code>: Within the test suite, there is an individual test case defined using the it function. This test case has a description that explains what it is testing, which is that it should return a success message when the login is successful. The <code class="calibre7"><strong class="calibre3">(done)</strong></code> function is passed as an argument, indicating that this is an asynchronous test, and the done function is used to signal the completion of the test.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">chai.request(app)</strong></code>: This line uses the chai-http library to make an HTTP request to an Express.js app. app should be replaced with the actual instance of your Express app. <code class="calibre7"><strong class="calibre3">.post('/api/login')</strong></code>: This line specifies that it is a POST request to the <code class="calibre7"><strong class="calibre3">'/api/login'</strong></code> endpoint. It is likely that this endpoint is responsible for handling user login.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3"><a id="page319"/>.send({ email: 'yamipanchal1993@gmail.com', password: 'Abc@123' })</strong></code>: Here, the code sends a JSON object in the request body with the email and password values for the login attempt.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.end((err, res) =&gt; { … });</strong></code>: This is the <code class="calibre7"><strong class="calibre3">callback</strong></code> function that gets executed when the HTTP request is completed. It receives two parameters: err for any errors that might occur during the request, and res for the response from the server.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(200);</strong></code>: This line uses Chai’s expect assertion to check if the HTTP response has a status code of 200, which typically indicates a successful request.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">expect(res.body).to.have.property('status').equal('success');</strong></code>: This line checks that the response body contains a property named ‘status’ with the value <code class="calibre7"><strong class="calibre3">'success'</strong></code>. It is a common way to check if an API response indicates a successful operation.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">authToken = res.body.data.accessToken;</strong></code>: If the login is successful, this line extracts the authentication token from the response and stores it in the authToken variable. This token is often used for subsequent authenticated requests.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">done();</strong></code>: Finally, the <code class="calibre7"><strong class="calibre3">done</strong></code> function is called to indicate that the test has completed.</li>
</ul>
<p class="nonindent">This code is a test case for login API returns a successful response with the expected status code and message. It also captures the authentication token for further testing, typically for authenticated routes.</p>
<h1 class="sec1" id="s239"><a href="toc.xhtml#s239a" class="calibre6">List of User Test</a></h1>
<p class="nonindent">In the same file, add the following test case code to verify the List of user API.</p>
<p class="code"><code class="calibre7">describe('GET List of Users', () =&gt; {</code></p>
<p class="code2"><code class="calibre7">it('should return array with status code 200', (done) =&gt; {</code></p>
<p class="code3"><code class="calibre7">chai.request(app)</code></p>
<p class="code4"><code class="calibre7">.get('/api/users')</code></p>
<p class="code4"><code class="calibre7">.set('Authorization',</code></p>
<p class="code5"><code class="calibre7">`Bearer ${authToken}`) // Pass the token in the headers</code></p>
<p class="code4"><code class="calibre7">.end((err, res) =&gt; {</code></p>
<p class="code5"><code class="calibre7">// console.log(res);</code></p>
<p class="code5"><code class="calibre7">expect(res).to.have.status(200);</code></p>
<p class="code5"><code class="calibre7">expect(res.body).to.have.property('data').to.be.an('array');</code></p>
<p class="code5"><code class="calibre7">done();</code></p>
<p class="code4"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">Output</code></p>
<p class="code1"><code class="calibre7">&gt; pms-be@1.0.0 test</code></p>
<p class="code1"><code class="calibre7">&gt; mocha --require ts-node/register 'src/**/*.spec.ts'</code></p>
<p class="code"><code class="calibre7"> <a id="page320"/>Login API</code></p>
<p class="code2"><code class="calibre7">1) "<strong class="calibre3">before all</strong>" hook in "<strong class="calibre3">{root}</strong>"</code></p>
<p class="code3"><code class="calibre7">Connected to the database</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔</strong> should return a success message when login is successful (75ms)</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔</strong> should return an error message when login fails (46ms)</code></p>
<p class="code"><code class="calibre7"> <strong class="calibre3">GET List of Users</strong></code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔ should return array with status code 200</strong></code></p>
<p class="code1"><code class="calibre7">Server closed</code></p>
<figure class="img">
<img alt="" src="images/9.6.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig9_6"><strong class="calibre3">Figure 9.6:</strong> User List Get API Testcase</p>
<p class="nonindent">Here are the details of the key parts of the proceeding code:</p>
<ul class="bull">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">describe('GET List of Users', () =&gt; { … });</strong></code>: This line defines a <a id="page321"/>new test suite with the description <code class="calibre7"><strong class="calibre3">"GET List of Users"</strong></code>. This suite groups together related test cases that are concerned with retrieving a list of users.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">it('should return array with status code 200', (done) =&gt; { … });</strong></code>: Within the test suite, there is an individual test case defined using the it function. The test case description specifies that it should return an array with a status code of 200. The (<code class="calibre7"><strong class="calibre3">done</strong></code>) function is used to indicate that this is an asynchronous test, and the done function will be called when the test is complete.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.get('/api/users')</strong></code>: This line specifies that it is a GET request to the <code class="calibre7"><strong class="calibre3">'/api/users'</strong></code> endpoint. This endpoint is likely responsible for fetching a list of users.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.set('Authorization', Bearer ${authToken}):</strong></code> Here, the code is setting an <code class="calibre7"><strong class="calibre3">"Authorization"</strong></code> header in the HTTP request. It includes an authentication token in the header, typically in the format <code class="calibre7"><strong class="calibre3">"Bearer &lt;token&gt;"</strong></code>. This is a common way to authenticate API requests. <code class="calibre7"><strong class="calibre3">authToken</strong></code> is expected to contain the token obtained during a successful login (as shown in your previous code snippet).</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.end((err, res) =&gt; { … });</strong></code>: This is the <code class="calibre7"><strong class="calibre3">callback</strong></code> function that gets executed when the HTTP request is completed. It receives two parameters: <code class="calibre7"><strong class="calibre3">err</strong></code> for any errors that might occur during the request, and <code class="calibre7"><strong class="calibre3">res</strong></code> for the response from the server.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(200);</strong></code>: This line uses Chai’s expect assertion to check if the HTTP response has a status code of 200, which typically indicates a successful request. This is the common way to ensure that the server responded with a 200 <code class="calibre7"><strong class="calibre3">OK</strong></code> status for a successful <code class="calibre7"><strong class="calibre3">GET</strong></code> request.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">expect(res.body).to.have.property('data').to.be.an('array');</strong></code>: This line checks that the response body contains a property named <code class="calibre7"><strong class="calibre3">'data</strong></code>,<code class="calibre7"><strong class="calibre3">'</strong></code> and that this property’s value is an array. This is a way to verify that the response contains a list of users in the form of an array.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">done();</strong></code>: Finally, the <code class="calibre7"><strong class="calibre3">done</strong></code> function is called to signal that the test has completed.</li>
</ul>
<p class="nonindent">This code is a test case for an Express.js API endpoint that tests whether a GET request to fetch a list of users returns the expected status code (<code class="calibre7"><strong class="calibre3">200</strong></code>) and verifies that the response contains an array of user data. It also includes the authorization token in the request header for authentication, assuming that the <code class="calibre7"><strong class="calibre3">authToken</strong></code> variable holds a valid token obtained from a login request.</p>
<h1 class="sec1" id="s240"><a href="toc.xhtml#s240a" class="calibre6">Add User Test</a></h1>
<p class="nonindent">In the same file, add the following test case that verifies add user API.</p>
<p class="code"><code class="calibre7">describe('ADD User', () =&gt; {</code></p>
<p class="code2"><code class="calibre7">it('should return with status code 201', (done) =&gt; {</code></p>
<p class="code3"><code class="calibre7">chai.request(app)</code></p>
<p class="code4"><code class="calibre7"><a id="page322"/>.post('/api/users')</code></p>
<p class="code4"><code class="calibre7">.set('Authorization',</code></p>
<p class="code5"><code class="calibre7">`Bearer ${authToken}`) // Pass the token in the headers</code></p>
<p class="code4"><code class="calibre7">.send({</code></p>
<p class="code5"><code class="calibre7">'fullname': 'Super Admin',</code></p>
<p class="code5"><code class="calibre7">'username': 'pms-admin1',</code></p>
<p class="code5"><code class="calibre7">'email': 'admin@pms1.com',</code></p>
<p class="code5"><code class="calibre7">'password': 'Admin@pms1',</code></p>
<p class="code5"><code class="calibre7">'role_id': 'dbda47e4-f843-4263-a4d6-69ef80156f81'</code></p>
<p class="code4"><code class="calibre7">})</code></p>
<p class="code4"><code class="calibre7">.end((err, res) =&gt; {</code></p>
<p class="code5"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(201);</strong></code></p>
<p class="code5"><code class="calibre7">done();</code></p>
<p class="code4"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code2a"><code class="calibre7">it('should return with status code 409', (done) =&gt; {</code></p>
<p class="code3"><code class="calibre7">chai.request(app)</code></p>
<p class="code4"><code class="calibre7">.post('/api/users')</code></p>
<p class="code4"><code class="calibre7">.set('Authorization',</code></p>
<p class="code5"><code class="calibre7">`Bearer ${authToken}`) // Pass the token in the headers</code></p>
<p class="code4"><code class="calibre7">.send({</code></p>
<p class="code5"><code class="calibre7">'fullname': 'Super Admin',</code></p>
<p class="code5"><code class="calibre7">'username': 'pms-admin1',</code></p>
<p class="code5"><code class="calibre7">'email': 'admin@pms1.com',</code></p>
<p class="code5"><code class="calibre7">'password': 'Admin@pms1',</code></p>
<p class="code5"><code class="calibre7">'role_id': 'dbda47e4-f843-4263-a4d6-69ef80156f81'</code></p>
<p class="code4"><code class="calibre7">})</code></p>
<p class="code4"><code class="calibre7">.end((err, res) =&gt; {</code></p>
<p class="code5"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(409);</strong></code></p>
<p class="code5"><code class="calibre7"><strong class="calibre3">expect(res.body).to.have.property('message').equal('Key (username)=(pms-admin1) already exists.');</strong></code></p>
<p class="code5"><code class="calibre7">done();</code></p>
<p class="code4"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7"><a id="page323"/>Output</code></p>
<p class="code1"><code class="calibre7">&gt; pms-be@1.0.0 test</code></p>
<p class="code1"><code class="calibre7">&gt; mocha --require ts-node/register 'src/**/*.spec.ts'</code></p>
<p class="code1"><code class="calibre7">Login API</code></p>
<p class="code2"><code class="calibre7">1) "before all" hook in "{root}"</code></p>
<p class="code3"><code class="calibre7">Connected to the database</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔</strong> should return a success message when login is successful (75ms)</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔</strong> should return an error message when login fails (46ms)</code></p>
<p class="code"><code class="calibre7"> GET List of Users</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔</strong> should return array with status code 200</code></p>
<p class="code"><code class="calibre7"><strong class="calibre3">ADD User</strong></code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔ should return array with status code 201</strong></code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔ should return with status code 409 (54ms)</strong></code></p>
<p class="code1"><code class="calibre7">Server closed</code></p>
<figure class="img">
<img alt="" src="images/9.7.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig9_7"><strong class="calibre3">Figure 9.7:</strong> Add User API Test Case</p>
<p class="nonindent"><a id="page324"/>Here are the details of the key parts of the proceeding code:</p>
<ul class="bull">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">describe('ADD User', () =&gt; { … });</strong></code>: This line defines a test suite with the description <code class="calibre7"><strong class="calibre3">"ADD User"</strong></code>. This suite groups together related test cases that are concerned with adding new users.</li>
<li class="calibre9">The first test case:
<ul class="bull1">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">it('should return with status code 201', (done) =&gt; { … });</strong></code>: This test case description indicates that it is testing whether adding a user should return a status code of <code class="calibre7"><strong class="calibre3">201</strong></code> (Created). The (<code class="calibre7"><strong class="calibre3">done</strong></code>) function is used to indicate that this is an asynchronous test, and the <code class="calibre7"><strong class="calibre3">done</strong></code> function will be called when the test is complete.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.post('/api/users')</strong></code>: It’s a <code class="calibre7"><strong class="calibre3">POST</strong></code> request to the <code class="calibre7"><strong class="calibre3">'/api/users'</strong></code> endpoint, presumably used to add a new user.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.set('Authorization', Bearer ${authToken})</strong></code>: This line sets an <code class="calibre7"><strong class="calibre3">"Authorization"</strong></code> header in the HTTP request, including the authentication token for authorization.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.send({ … })</strong></code>: The code sends a JSON object in the request body with user information, including the user’s fullname, username, email, password, and role IDs. This represents the data you are trying to add.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.end((err, res) =&gt; { … });</strong></code>: The <code class="calibre7"><strong class="calibre3">callback</strong></code> function that gets executed when the HTTP request is completed.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(201);</strong></code>: This line uses Chai’s expect assertion to check if the HTTP response has a status code of 201, indicating that the user creation was successful.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">done();</strong></code>: Finally, the <code class="calibre7"><strong class="calibre3">done</strong></code> function is called to signal that the test has completed.</li></ul></li>
<li class="calibre9">The second test case:
<ul class="bull1">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">it('should return with status code 409', (done) =&gt; { … });</strong></code>: This test case description indicates that it’s testing whether adding a user with the same username should return a status code of <code class="calibre7"><strong class="calibre3">409</strong></code> (Conflict).</li>
<li class="calibre9">The structure of this test case is similar to the first one, with the main differences being the expected status code and the additional checks:</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(409);</strong></code>: This line checks if the HTTP response has a status code of <code class="calibre7"><strong class="calibre3">409</strong></code>, indicating a conflict.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">expect(res.body).to.have.property('message').equal('Key (username)=(pms-admin1) already exists.');</strong></code>: This line verifies that the response body contains a specific message indicating that the provided username already exists.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">done();</strong></code>: As before, the done function is called to signal the completion of the test.</li></ul></li>
</ul>
<p class="nonindent"><a id="page325"/>This code contains two test cases. The first test case checks if a new user is successfully added with a 201 status code, while the second test case checks if a conflict (409 status code) is returned when attempting to add a user with an existing username. The second test case also verifies the presence of an error message in the response.</p>
<h1 class="sec1" id="s241"><a href="toc.xhtml#s241a" class="calibre6">Delete User Test</a></h1>
<p class="nonindent">Within the existing file, include the following test case code to validate the functionality of the user deletion API.</p>
<p class="code"><code class="calibre7">describe('Delete User', () =&gt; {</code></p>
<p class="code2"><code class="calibre7">it('should return with status code 200', (done) =&gt; {</code></p>
<p class="code3"><code class="calibre7">chai.request(app)</code></p>
<p class="code4"><code class="calibre7">.delete('/api/users/0ddc59fe-a9ea-4060-9b39-5118fe13937d')</code></p>
<p class="code4"><code class="calibre7">.set('Authorization',</code></p>
<p class="code5"><code class="calibre7">`Bearer ${authToken}`) // Pass the token in the headers</code></p>
<p class="code4"><code class="calibre7">.end((err, res) =&gt; {</code></p>
<p class="code5"><code class="calibre7">expect(res).to.have.status(201);</code></p>
<p class="code5"><code class="calibre7">done();</code></p>
<p class="code4"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code2a"><code class="calibre7">it('should return with status code 404', (done) =&gt; {</code></p>
<p class="code3"><code class="calibre7">chai.request(app)</code></p>
<p class="code4"><code class="calibre7">.delete('/api/users/0ddc59fe-a9ea-4060-9b39-5118fe13937d')</code></p>
<p class="code4"><code class="calibre7">.set('Authorization', `Bearer ${authToken}`) // Pass the token in the headers</code></p>
<p class="code4"><code class="calibre7">.end((err, res) =&gt; {</code></p>
<p class="code5"><code class="calibre7">expect(res).to.have.status(404);</code></p>
<p class="code5"><code class="calibre7">done();</code></p>
<p class="code4"><code class="calibre7">});</code></p>
<p class="code2"><code class="calibre7">});</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="code"><code class="calibre7"><a id="page326"/>Output</code></p>
<p class="code1"><code class="calibre7">&gt; pms-be@1.0.0 test</code></p>
<p class="code1"><code class="calibre7">&gt; mocha --require ts-node/register 'src/**/*.spec.ts'</code></p>
<p class="code1"><code class="calibre7">Login API</code></p>
<p class="code2"><code class="calibre7">1) "before all" hook in "{root}"</code></p>
<p class="code3"><code class="calibre7">Connected to the database</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔</strong> should return a success message when login is successful (75ms)</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔</strong> should return an error message when login fails (46ms)</code></p>
<p class="code"><code class="calibre7"> GET List of Users</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔</strong> should return array with status code 200</code></p>
<p class="code"><code class="calibre7">ADD User</code></p>
<p class="code2"><code class="calibre7">X should return array with status code 201</code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔</strong> should return with status code 409 (54ms)</code></p>
<p class="code"><code class="calibre7"><strong class="calibre3">Delete User</strong></code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔ should return with status code 200</strong></code></p>
<p class="code2"><code class="calibre7"><strong class="calibre3">✔ should return with status code 404</strong></code></p>
<p class="code1"><code class="calibre7">Server closed</code></p>
<figure class="img">
<img alt="" src="images/9.8.jpg" class="calibre1"/>
</figure>
<p class="figcap" id="fig9_8"><strong class="calibre3">Figure 9.8:</strong> Delete User API Testcase</p>
<p class="nonindent"><a id="page327"/>In this code, Add User test case displays fail because same user is already in database. Similarly, the Delete User test case might fail if the user you're trying to delete doesn't exist in the database when the test runs.</p>
<ul class="bull">
<li class="calibre9">The first test case:
<ul class="bull1">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">it('should return with status code 200', (done) =&gt; { … });</strong></code>: The description of this test case indicates that it is testing whether a successful user deletion should return a status code of <code class="calibre7"><strong class="calibre3">200</strong></code> (<code class="calibre7"><strong class="calibre3">OK</strong></code>). The (done) function is used to indicate that this is an asynchronous test, and the done function will be called when the test is complete.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.delete('/api/users/0ddc59fe-a9ea-4060-9b39-5118fe13937d')</strong></code>: It is a DELETE request to a specific endpoint <code class="calibre7"><strong class="calibre3">'</strong></code>/<code class="calibre7"><strong class="calibre3">api/users/'</strong></code> with a user identifier (for example, <code class="calibre7"><strong class="calibre3">'0ddc59fe-a9ea-4060-9b39-5118fe13937d'</strong></code>) in the URL. This typically represents the action of deleting a specific user by their unique identifier.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.set('Authorization', Bearer ${authToken})</strong></code>: This line sets an <code class="calibre7"><strong class="calibre3">"Authorization"</strong></code> header in the HTTP request, including the authentication token for authorization.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">.end((err, res) =&gt; { … });</strong></code>: The <code class="calibre7"><strong class="calibre3">callback</strong></code> function that gets executed when the HTTP request is completed.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(201);</strong></code>: There is a potential issue in this line. It checks if the HTTP response has a status code of <code class="calibre7"><strong class="calibre3">201</strong></code>, but the test case description implies that it should be expecting a <code class="calibre7"><strong class="calibre3">200</strong></code> status code. This line should be corrected to <code class="calibre7"><strong class="calibre3">expect(res).to.have.status(200)</strong></code>;.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">done();</strong></code>: Finally, the <code class="calibre7"><strong class="calibre3">done</strong></code> function is called to signal that the test has completed.</li></ul></li>
<li class="calibre9">The second test case:
<ul class="bull1">
<li class="calibre9"><code class="calibre7"><strong class="calibre3">it('should return with status code 404', (done) =&gt; { … });</strong></code>: The description of this test case indicates that it is testing whether attempting to delete a user that does not exist should return a status code of <code class="calibre7"><strong class="calibre3">404 (Not Found)</strong></code>. The structure of this test case is similar to the first one, with the main difference being the expected status code:</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">expect(res).to.have.status(404);</strong></code>: This line checks if the HTTP response has a status code of 404, indicating that the requested user was not found.</li>
<li class="calibre9"><code class="calibre7"><strong class="calibre3">done();</strong></code>: As before, the done function is called to signal the completion of the test.</li></ul></li>
</ul>
<p class="nonindent">This code contains two test cases for testing the user deletion functionality through an Express.js API. The first test case checks if a user is successfully deleted with a <code class="calibre7"><strong class="calibre3">200</strong></code> <a id="page328"/>status code, and the second test case checks if attempting to delete a non-existent user results in a <code class="calibre7"><strong class="calibre3">404</strong></code> status code.</p>
<p class="nonindent">In this manner, you have the flexibility to create distinct test scenarios for various sections within your application, including user management, project handling, task management, and comment features. For each of these APIs, you can define specific test cases. Additionally, you can extend your testing suite by incorporating cases that verify authentication failures, such as testing for a <code class="calibre7"><strong class="calibre3">401</strong></code> status code when authentication is missing and a 403 status code when authorization is not granted for certain API endpoints.</p>
<h1 class="sec" id="s242"><a href="toc.xhtml#s242a" class="calibre6">Mocking Database Connection</a></h1>
<p class="nonindent">To mock the database connection, we can use the popular library — <code class="calibre7"><strong class="calibre3">sinon</strong></code>. Let us install the library with npm.</p>
<p class="code"><code class="calibre7">npm install sinon –save-dev</code></p>
<p class="nonindent">Consider if we have a function to get the user for a given id as:</p>
<p class="code"><code class="calibre7">// db.ts</code></p>
<p class="code1"><code class="calibre7">async function getUserByUserId(user_id:string) {</code></p>
<p class="code2"><code class="calibre7">// actual logic to fetch the user from database</code></p>
<p class="code1"><code class="calibre7">}</code></p>
<p class="code1"><code class="calibre7">module.exports = { getUserByUserId };</code></p>
<p class="nonindent">We can use sinon to mock this behavior -</p>
<p class="code"><code class="calibre7">const sinon = require('sinon');</code></p>
<p class="code1"><code class="calibre7">const { expect } = require('chai');</code></p>
<p class="code1"><code class="calibre7">const db = require('../db');</code></p>
<p class="code1"><code class="calibre7">describe('getUserByUserId', function() {</code></p>
<p class="code2"><code class="calibre7">it('should return mocked user data', async function() {</code></p>
<p class="code3"><code class="calibre7">// Create a stub for getUserByUserId</code></p>
<p class="code3"><code class="calibre7">const mockUser = { id: 1, name: 'Alice M' };</code></p>
<p class="code3"><code class="calibre7">const stub = sinon.stub(db, 'getUserByUserId').resolves(mockUser);</code></p>
<p class="code3a"><code class="calibre7">// Call the function (which is now stubbed)</code></p>
<p class="code3"><code class="calibre7">const user = await getUserByUserId(1);</code></p>
<p class="code3a"><code class="calibre7">// Verify the function returned the mocked data</code></p>
<p class="code3"><code class="calibre7">expect(user).to.deep.equal(mockUser);</code></p>
<p class="code3a"><code class="calibre7">// Restore the original function</code></p>
<p class="code3"><code class="calibre7">stub.restore();</code></p>
<p class="code2"><code class="calibre7"> });</code></p>
<p class="code1"><code class="calibre7">});</code></p>
<p class="nonindent"><a id="page329"/>In the preceding example, <code class="calibre7"><strong class="calibre3">sinon.stub()</strong></code> is used to replace the actual function <code class="calibre7"><strong class="calibre3">getUserByUserId()</strong></code> with a version that returns a promise which resolves to the <code class="calibre7"><strong class="calibre3">mockUser</strong></code>. This test does not connect to an actual database. This way it ensures that the test is isolated and repeatable. <code class="calibre7"><strong class="calibre3">stub.restore()</strong></code> at the end restores the original function.</p>
<h1 class="sec" id="s243"><a href="toc.xhtml#s243a" class="calibre6">Conclusion</a></h1>
<p class="nonindent">In this chapter, the test cases presented in the code examples provide a comprehensive approach to testing various aspects of an Express.js API application. These test cases cover different scenarios which include Login and user management APIs. These tests are an essential part of ensuring the reliability, security, and correctness of the API, and they can help identify and address issues early in the development process.</p>
<p class="nonindent">By systematically testing the application, you can increase its robustness and enhance the overall quality of your software.</p>
<p class="nonindent">In the next chapter, we will learn how to build and deploy our application.</p>
</article>
</body></html>