- en: '12'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Measuring and Optimizing Performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In software engineering circles, it’s common to hear the expression “premature
    optimization is the root of all evil.” This is usually bestowed very knowingly
    from a more Senior developer to a more Junior one. Stroking of the chin – whether
    a beard is present or not – is almost always required to attain the Solemn Air
    of Pronouncement accompanying such declarations. Strange delivery or not, it is
    good advice to follow.
  prefs: []
  type: TYPE_NORMAL
- en: There aren’t many worse ways to approach software design than by starting to
    make performance-related changes while that software is still largely being built.
    That, in turn, is because the optimization of a code base is inversely related
    to the code’s readability, its maintainability, and ultimately the facility to
    which new features and changes can be introduced. To put it another way, the more
    optimized a code base tends to be, the harder it is for someone to understand
    the code and subsequently make changes to that code.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point in our journey, we have established a full end-to-end application
    experience. Though there may still be some rough edges, all the major features
    have been implemented in the application, making this an ideal time to examine
    our application’s performance. At the same time, though, we don’t have much insight
    into how *Space-Truckers* performs at really any other level than the bare basics.
    Our first task is clear: we must capture a baseline performance profile, or rather
    one profile each for both the Route Planning and Driving phases.'
  prefs: []
  type: TYPE_NORMAL
- en: The Babylon.js **Real-time performance viewer** can record real-time performance
    statistics across a wide range of metrics relevant to a Babylon.js Scene. With
    these tools in hand, we’ll be able to identify “hotspots” in the Space-Truckers
    code base that we can then target for selective performance enhancements, but
    that doesn’t tell us anything about how we can improve the performance or what
    to look for in our tooling. Not yet at least!
  prefs: []
  type: TYPE_NORMAL
- en: Something we haven’t discussed so far has been how the very breadth and reach
    of a web application also means a greater number of different potential hardware
    and software configurations that must then be supported by you, the developer.
    How do we avoid having to go down the rabbit hole of testing, verifying, and fixing
    functionality for every combination of device, software, and display? By knowing
    what areas or scenarios in a Scene put the most stress on which part of the system,
    we can defer the optimization from design time to runtime and handle it in real
    time. The Babylon.js **Scene Optimizer** is the ideal solution to dynamically
    balance performance and render quality with its ability to turn on and off different
    performance optimizations based on the difference between a target and the current
    frame rates, or **frames per second** (**FPS**).
  prefs: []
  type: TYPE_NORMAL
- en: Aside from the runtime **Scene Optimizer**, there are other things we can do
    to improve an application’s performance in Babylon.js. We’ll continue to use and
    re-measure the impact of any changes we make, first individually, then all together,
    because how can you know if any improvement has been made if you don’t have something
    for comparison? The rhetorical answer is that you can’t – not unless you are consistent
    in your measurement procedure and capturing measurements, but as the fastidious
    and methodical creator of Software That Does Magic™, you’ve already got that part
    down!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Levity aside, something that will help enforce and facilitate this kind of development
    work greatly is to leverage the mighty power of Git. Any time you save a change
    to a source code file, consider at least staging that change, if not committing
    it. Revert commits that don’t work instead of plowing ahead. In other words, by
    working with, not against, Source Control, you might be amazed at how fast you
    can get things done!
  prefs: []
  type: TYPE_NORMAL
- en: Our last port of call for this, the penultimate stage of our Babylon.js long-haul,
    will be looking at the network performance of our app. Specifically, we’ll see
    how our asset and data resources affect both loading time and bandwidth usage.
    Today’s web browsers almost all support both robust caching functionality, as
    well as local storage mechanisms such as **IndexedDb**, which is a mini SQL server
    made available by the browser to scripts running inside it. Why is this relevant?
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In case you missed it, rhetorical questions are back in style!
  prefs: []
  type: TYPE_NORMAL
- en: The relevance of **IndexedDB** is that we can use it to stuff all our assets
    – textures, sounds, JSON, and more. Instead of having to download everything from
    the server, we store resources locally on the browser. It’s a great place to cache
    assets. This positions us well for the next chapter’s look at making Space-Truckers
    into an installable publishable **Progressive Web Application** (**PWA**). But
    first things first, let’s go over the topics covered in this chapter and some
    technical requirements and recommendations.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Knowing What To Measure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Measuring Performance and Identifying Bottlenecks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving Runtime Performance with the Scene Optimizer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Most of the requirements in this chapter are the same as they have been for
    the previous chapters, but some new tools can be incredibly useful for performance
    measurement and improvement. Here are the tools that are new and/or specific to
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: This is not a requirement, but it is very helpful to have multiple displays
    available while working on performance captures. Accurate and consistent measurements
    can be tough enough – don’t add more variables into the mix if you can help it!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The Scene Optimizer: [https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer](https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optimizing with Octrees: [https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees](https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: BVH article/information link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing What To Measure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Quantum Mechanics has a concept called the **Uncertainty Principle**. Named
    after physicist Werner Heisenberg, the principle can be summarized for our purposes
    as the act of measuring some quantity itself affecting the observed value of that
    quantity. Although merely an analogy for us currently bound to non-quantum systems,
    it serves as a useful warning as we take our measures and metrics: don’t let the
    instrumentation impact the measurements that are being taken for our app’s performance.'
  prefs: []
  type: TYPE_NORMAL
- en: Starting with some general guidelines, we’ll look at some key factors that need
    to be attended to and accounted for to gather meaningful test data. Using those
    guidelines to establish a basic context, we’ll start learning some key terminology
    that will allow us to get into more specifics in future sections of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: General Guidelines
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we review and examine the various means and procedures for taking our performance
    profile, we’ll go over the tooling-specific steps as they come up. But first,
    let’s look at a few guidelines that generally apply.
  prefs: []
  type: TYPE_NORMAL
- en: Keep External Factors To a Minimum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Computers are quite good at sharing slices of computing time between processes,
    but we’re better off closing all our other browser windows and shutting down any
    other non-essential programs that may compete with ours for resources. No, it’s
    not as “real world” as might be expected, but the goal here is to gather clean,
    consistent data, and that doesn’t have to stick to the “real world” rules. Rebel.
  prefs: []
  type: TYPE_NORMAL
- en: Choose a Target Resolution and Stick To It
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is a bit trickier than it might seem. Simply going with the highest resolution
    possible and putting on the highest pixel-dense display is certainly a good way
    to stress-test a graphical application, but it won’t yield a very useful performance
    profile. Too low of a resolution and the GPU won’t break a sweat, also not yielding
    a very useful profile. Going for a Veruca Salt-meets-goldilocks approach, select
    a value somewhere in the upper-middle range that avoids “redlining” either CPU
    or GPU but still makes those components work for their electrons!
  prefs: []
  type: TYPE_NORMAL
- en: Compare Apples to Apples
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always make sure your comparisons are equivalent, all other things considered.
    Follow the same testing procedure – resist the urge to “improve” or take shortcuts
    – and collect data in the same fashion between test runs. If methodologies differ,
    then there’s a good possibility that your results won’t tell you what you think
    they say.
  prefs: []
  type: TYPE_NORMAL
- en: Change Only One Thing Between Measurements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One of the less helpful things you might do to yourself is put off re-measuring
    after making one set of changes. For example, say you refactor one method, then
    make another set of changes somewhere else in the application. Repeat this a few
    times, and you’ve now lost the ability to definitively say whether your change
    has improved anything – regardless of whether the app performs better or worse!
    This is also a poor situation to be in because you’re also restrained in the changes
    you can safely make in the future without risking regression in the code you’re
    trying to change. Avoid getting into this in the first place by committing each
    cohesive set of changes together, and by re-measuring after each major change
    to validate your assumptions about how the code behaves.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding guidelines aren’t rules set in stone – they’re pieces of advice
    aimed at helping you proactively avoid arriving at false conclusions and the resulting
    consequences. This is surely helpful, but not directly so. To help connect this
    advice to a useful context, we’ll first look at what sorts of metrics are important.
    Then, we’ll look at the tools that collect this data. Finally, we’ll apply what
    we’ve learned to find and fix performance bottlenecks and resource pressures that
    lurk in the Space-Truckers code base.
  prefs: []
  type: TYPE_NORMAL
- en: Performance-Related Terminology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: “*I Wanna Go Fast!*”
  prefs: []
  type: TYPE_NORMAL
- en: Yes, Ricky Bobby, so do we all. When referring to cars or racing, the meaning
    of the phrase is clear, but what does “[going] Fast!” mean for a 3D application?
    Sure, it cannot be a good thing for a laptop to suddenly take off in a cloud of
    burning plastic at 200 kph! At least, not a laptop without wheels. Brakes too
    – those are also important.
  prefs: []
  type: TYPE_NORMAL
- en: The equivalent measure for 3D applications and games is, of course, the Frame
    Rate, or **Frames Per Second** (**FPS**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Positioned unfortunately close in proximity to a **First-Person Shooter** (**FPS**),
    noting that the two are not directly related is yet another reminder that context
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similar to how a speed limit posted on a highway serves to limit (in theory,
    at least) the top speed of drivers on the road, the number of frames that can
    be rendered every second is limited at the end by an intrinsic maximum that matches
    the refresh rate of the display device or monitor doing the rendering. In the
    Old Days, this was limited by the speed at which the electron gun of a **Cathode
    Ray Tube** (**CRT**) display could traverse the width and height of the screen.
    Barbarian times, they were. In today’s era of more Enlightened Display Technologies,
    **Light Emitting Diode** (**LED**) displays can switch on or off with incredible
    speed. Here are some typical FPS values and examples that you may recognize from
    the real world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_12.01_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: FPS is a convenient metric because it is almost completely unambiguous – higher
    values are almost always better. The only real exception to this is in scenarios
    where power consumption is a higher priority than maintaining a high frame rate.
    Because that deals with actions taken at runtime, we’re going to look at how to
    approach a scenario like that later in this chapter in the *Improving Runtime
    Performance with the Scene Optimizer* section. The ugly downside of a higher FPS
    is that there’s less time to get all the needed inter-frame processing that goes
    on, whether inside the GPU or in the CPU.
  prefs: []
  type: TYPE_NORMAL
- en: This **Frame Budget**, depicted in the second-to-left-most column in the previous
    table, dictates what can happen during the inter-frame time. Go over the budget
    and the frame rate drops. Go too much under budget and time is being wasted that
    could be rendering additional frames or running other processing tasks. Performance
    management can be approached by either reducing the CPU Frame Time or by reducing
    the GPU Frame Time. Sometimes, there’s crossover between the two – a good example
    of this is the Thin Instances used for the Route Planning phases’ asteroid belt
    (see the *A Detour into Particle Systems* section of [*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142),
    *Processing Route Data*, for more).
  prefs: []
  type: TYPE_NORMAL
- en: Every frame, the asteroid’s rotation and position matrices are updated by code
    running on the CPU, which is then copied over into the GPU. These matrixes are
    then passed into the vertex and fragment shaders, which apply them during a single
    Draw call to every instance in the Scene. While this is an extremely fast process,
    there is one potential bottleneck on the CPU, and that’s the loop over each Thin
    Instance that recalculates the two matrices. Any improvements there would theoretically
    improve either the performance or the maximum number of asteroids that can be
    rendered without severe performance degradation.
  prefs: []
  type: TYPE_NORMAL
- en: Shifting over to the GPU, bottlenecks can occur when the device is tasked with
    too many (or fewer, slower) shader programs competing for the same limited frame
    budget. The raw number of shader executions is expressed as the number of **Draw**
    calls made in each second and serves as a complement to the GPU intra-frame time
    spent executing shaders. As each Draw call is associated with a single material
    (some materials will make multiple calls to Draw), the number of different materials
    in a Scene is directly related to the number of times the GPU is being asked to
    switch contexts to run that material’s shader programs every second.
  prefs: []
  type: TYPE_NORMAL
- en: Switching the GPU between contexts (shaders) has been brutally optimized in
    hardware, but it isn’t completely free. Each shift carries a small amount of overhead,
    and though trivial individually, this can add up to substantial losses with large
    numbers. Thus, reducing the number of draw calls can improve performance directly
    from the reduced context switches and indirectly through the shader code that
    is no longer being invoked.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The fastest code is code that doesn’t exist. Think about that.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few other metrics that are worth defining but are most obvious from
    their name or context. One exception, though, is Absolute FPS. Absolute FPS is
    the number of frames that can be processed each second, not counting any actual
    render timings. This is a measure of how well the CPU side of things is performing
    through its update loop.
  prefs: []
  type: TYPE_NORMAL
- en: As with most of the content in this book, the preceding terms aren’t a comprehensive
    survey of the 3D performance programming landscape, but as a primer for what comes
    next, it is as comprehensive as needed. A comfortably high frame rate – one at
    or above 60 FPS – carries a frame budget of around 16 milliseconds, during which
    all processing needed to process a simulation and prepare it for the next frame
    must be completed. GPUs are screamingly fast at doing this type of thing, but
    just as an overburdened CPU can spin and churn trying to service too many competing
    processes, so can a GPU become overburdened by shader programs.
  prefs: []
  type: TYPE_NORMAL
- en: To help us understand what all of that talk about CPUs, GPUs, burdens, and everything
    else that plays out in an actual scenario, we need to learn about how and what
    to measure. Simply measuring things is rarely enough. Like chemistry students
    planning their lab procedures out in their notebooks, we’ll need to learn how
    to plan our testing strategies, as well as how to interpret the results. In the
    next section, we’re going to take on the tasks of planning out, executing, and
    interpreting a performance test, but not before we learn more about the tools
    that will help accomplish those tasks for us.
  prefs: []
  type: TYPE_NORMAL
- en: Measuring Performance and Identifying Bottlenecks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Effective problem-solving starts by clearly defining the problem that needs
    to be solved. Sometimes, this is less than obvious, or sometimes, there’s more
    than one problem that appears to be front and center. Oftentimes, the thing that
    makes defining a problem difficult is that it is presented as a qualitative statement,
    like this one: “The Route Planning Screen doesn’t perform well.”'
  prefs: []
  type: TYPE_NORMAL
- en: A statement such as that one is unambiguIus in one sense – there’s no doubt
    as to its meaning – but it is completely opaque in another, for we have no understanding
    to what degree the performance is poor. That’s the basic difference between having
    qualitative data and having specific, qualitative measures. Without the former,
    there’s no understanding of the overall picture, and without the latter, there’s
    no way to know whether any actions have been resolved, mitigated, or even made
    worse. So, gathering quantitative data on how the Route Planning screen performs
    is the first step we need to take so that we can better define our conditions
    for victory, as it were.
  prefs: []
  type: TYPE_NORMAL
- en: Inspecting the Performance of Route Planning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Babylon.js Inspector is a Swiss-army knife of useful goodness. If you’re
    as-yet-unfamiliar with the Inspector, now wouldn’t be a bad time to check out
    the docs at [https://doc.babylonjs.com/toolsAndResources/tools/inspector](https://doc.babylonjs.com/toolsAndResources/tools/inspector),
    as well as take another refresher through [*Chapter 2*](B17266_02_Final_AM.xhtml#_idTextAnchor030),
    *Ramping up On Babylon.js*, to set you straight. The Inspector has long had a
    **Performance** tab that displays all manner of statistics regarding the currently
    running Scene, but until the Babylon.js v5.0 release, there wasn’t an easy way
    to capture and analyze those metrics as they progress over time. The **Performance
    Profiler** is an extensible tool that has two similar concepts but different practice
    modes: headless and real time.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In case you don’t recall, the keyboard shortcut for bringing up the Inspector
    when running Space-Truckers is *Shift* + *Alt* + *I*.
  prefs: []
  type: TYPE_NORMAL
- en: Real-Time Performance Viewer Metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When running in Real Time mode, a live graph is rendered showing the selected
    metrics from a list of the available metrics. Headless mode, in contrast, displays
    nothing but captures data that can later be exported to CSV format for further
    analysis. All three of these options (Start/Stop, Real Time, Headless, and Import/Export
    to CSV) are covered in more detail in the BJS docs at [https://doc.babylonjs.com/toolsAndResources/tools/performanceProfiler](https://doc.babylonjs.com/toolsAndResources/tools/performanceProfiler).
    The following table lists the out-of-the-box metrics collected by the Performance
    Profiler, along with a basic explanation of these metrics:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Table_12.02_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The specific values for each of the preceding metrics will depend on the hardware
    and software environment, so specific target values aren’t very useful. The different
    property groupings of metrics tend to reflect the dimension or unit that values
    assume. The top section focuses on counted metrics – things such as the number
    of meshes, vertices, textures, and more. After that, there are timing metrics,
    which show the amount of time that specific parts of the scene are consuming during
    and in-between frames. It’s this base set of metrics that the Performance Profiler
    captures and displays in a visual graph. Let’s move on and look at what a procedure
    looks like for our profiling.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the Testing Procedure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Following the guidelines laid out previously in this chapter, we need to define
    a repeatable procedure for profiling the application. There’s no need to over-complicate
    this, so let’s do the Simplest Thing That Could Possibly Work. We want to refresh
    the web page for the application to reset and clear memory and such, and then
    we want to let the application settle for a bit and find its groove before we
    launch some cargo and take some more measurements. The last part is to save our
    performance profile to a CSV file for posterity before loading it into the Performance
    Viewer for basic analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Unless there’s a specific reason to not do it, always evaluate performance and
    capture metrics against code built in Production environment mode!
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s what our testing procedure looks like. Remember, we want to repeat this
    same series of steps every time we make a significant change to the code so that
    we can understand the impact of that change:'
  prefs: []
  type: TYPE_NORMAL
- en: Refresh the browser, launch the game, and navigate to route planning
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow game to stabilize for 10s
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin capture
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Allow 10 seconds to stabilize and establish a baseline
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Launch cargo unit into an empty space
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Collect data for 10 seconds
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Stop capture and export to CSV
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A more thorough testing procedure would also want to include camera panning
    and zooming, but this procedure will serve our purposes adequately. At this point
    in this book, *Step 1* shouldn’t need further elaboration. *Step 2* is also straightforward
    and to the point. It is *Step 3* where we need to pause to get into the details
    of what the step entails.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we start capturing our profile, we need to launch the BJS Inspector
    by pressing the *Shift* + *Alt* + *I* key combination. The **Statistics** tab
    in the right-hand pane contains our target information, but first, detach the
    **Inspector** panes from the browser window (you can close the Scene Explorer
    instead if desired) so that they do not take up or cover up any part of the app
    window. If you’re using multiple monitors, it can be convenient to dedicate one
    monitor to the browser window, but it’s not required. Just remember the Guideline
    About Using the Same Screen Size and Resolution! When you’re ready, press the
    **Begin Recording** button circled in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1 – The Statistics tab of the Inspector contains controls for starting,
    stopping, exporting, and viewing Performance Profile data'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.01_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.1 – The Statistics tab of the Inspector contains controls for starting,
    stopping, exporting, and viewing Performance Profile data
  prefs: []
  type: TYPE_NORMAL
- en: By clicking the **Begin Recording** button, we can initiate a performance profile
    in Headless mode. This gives us better accuracy because, in a nod to Dr. Heisenberg,
    our measurements won’t be affecting the application’s execution to as much of
    a degree.
  prefs: []
  type: TYPE_NORMAL
- en: '*Step 4* involves the difficult task of waiting – without touching anything
    – for 10 seconds to allow stabilization to occur in the application. These first
    10 seconds also help establish a runtime baseline profile that we can use to compare
    different actions taken during a test. When the allotted time has passed, *Step
    5* is to point the launcher toward an empty patch of space and fire away – we
    want to capture the behavior of the game during flight. After letting the Cargo
    Unit cruise for another 10 seconds, *Step 6* has been completed, and thus *Step
    7* comes, where we click the **Stop Recording** button, followed by the **Export
    Perf to CSV** button, to download it. Now that we’ve finished capturing our profile,
    it’s time to examine it.'
  prefs: []
  type: TYPE_NORMAL
- en: Viewing and Analyzing a Captured Profile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The fastest way to view a performance profile is to choose **Load Perf Viewer**
    using the **CSV** button, then select the freshly downloaded CSV file previously
    captured to launch the Perf Viewer.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Depending on whether you’re doing this locally or against a deployed environment,
    your browser’s pop-up blocker may engage and prevent the **Realtime Performance
    Viewer** window from showing. Make sure you disable or add exceptions to your
    blocker rules to allow the window to appear!
  prefs: []
  type: TYPE_NORMAL
- en: Your first impression of the performance graph might be that someone spilled
    a box of colored spaghetti or perhaps Pick-up-Stix and now it’s going to need
    to be cleaned up. That’s because all metrics are selected for display at the time
    of load. Click the master toggles on the group headers to disable all the Count
    items, leaving FPS. Selectively remove items that have very small values – if
    something is taking less than a millisecond to complete, there are better things
    to worry about! The graph is a lot easier to comprehend now! Zoom in and out with
    the mouse wheel, while panning across the timeline by dragging.
  prefs: []
  type: TYPE_NORMAL
- en: This will transition us from looking at a larger overall picture to a progressively
    more granular view of things, where there are a few things of interest to note.
  prefs: []
  type: TYPE_NORMAL
- en: Initial Assessments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice how the Inter-frame time seems to correlate inversely with FPS? That
    is, if you look carefully at the two data series, you’ll see how the FPS drops
    dramatically any time there is a similar shift in the opposite direction by the
    Inter-frame time. Something else obvious to see in this format is the statement
    that whenever it takes more time between frames, there are fewer frames as a result.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add the GPU frame time to this graph, a more nuanced picture starts to
    emerge. Although there are exceptions and outliers, in most of the areas where
    Inter-frame time increases (followed immediately by a drop in FPS), there is a
    corresponding *decrease* in GPU frame time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2 – A snapshot of a portion of a performance profile'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_12.02_B17266.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 12.2 – A snapshot of a portion of a performance profile
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, the darker line at the top initially is the FPS, while
    the bottom-most line is the Inter-frame time. In the middle is the GPU frame time.
  prefs: []
  type: TYPE_NORMAL
- en: If the GPU frame time is improving, why is the FPS dropping? Without knowledge
    of the Space-Truckers application and how it’s put together, it might take an
    expert a bit of time to puzzle out the source of this strange connection, but
    seasoned coders of the Space-Highways followers of this book will likely already
    know exactly what this means and what’s causing it.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating External Knowledge
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Even though the CPU and the GPU operate pretty much independently from each
    other, events or conditions affecting one can still indirectly affect the other.
    In the case of our **Route Planning Screen**, we can infer that the GPU frame
    time drops because it is waiting to be told what to do by the CPU. Therefore,
    it is the increase in the Inter-frame time that is the proximate cause of both
    the FPS drop and the GPU frame time decrease.
  prefs: []
  type: TYPE_NORMAL
- en: Reach back into your memories of [*Chapter 6*](B17266_06_Final_AM.xhtml#_idTextAnchor120),
    *Implementing Game Mechanics*, and recall how we went about implementing the asteroid
    belt in the *Building the Asteroid Belt* section. The belt is comprised of many
    hundreds of individual rock meshes that have been procedurally generated as a
    set of **Thin Instances**. Note that as we discussed in [*Chapter 7*](B17266_07_Final_AM.xhtml#_idTextAnchor142),
    *Processing Route Data*, Thin Instances are blazing fast because they run on the
    GPU.
  prefs: []
  type: TYPE_NORMAL
- en: 'Checking the Particle frame steps timing tends to support that assertion as
    the amount of time the CPU spends managing particles is small enough that it is
    unlikely to account for the two distinctly different systems in use in the Scene
    (the Sun Particle System is also a GPU-based **ParticleSystem**, with the asteroid
    **Thin Instances** being the other). Why, then, focus on the asteroid belt as
    the source of our high Inter-frame bottleneck? This is because our Thin Instances
    are not statically held in place – they individually rotate. To accomplish this
    rotation, we implemented a scheme wherein we stored a set of rotation, position,
    and scaling data locally on the CPU. Every frame, we looped through the set of
    asteroids and adjusted the rotation values for each asteroid, updating their matrices
    before signaling to the GPU that it should refresh the **Thin Instance Buffer**
    to update the objects on screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '`gameData` for the Route Planning screen contains an `asteroidBeltOptions`
    configuration object, which, in turn, contains the number property that controls
    the number of asteroids (**Thin Instances**) to create and manage. Next, it’s
    time to test our hypothesis by running an experiment.'
  prefs: []
  type: TYPE_NORMAL
- en: Validating Assumptions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Change the number of asteroids to about 75% percent of its current value, then
    re-run the performance profile. It should be immediately apparent that the Inter-frame
    time improves, along with the overall FPS. As we are hoping to see, the GPU frame
    time either stays constant or trends upwards, supporting our conjecture about
    the GPU waiting for work from an over-taxed CPU.
  prefs: []
  type: TYPE_NORMAL
- en: If you wish to be extra thorough (and you should if you’re still learning!),
    change the asteroid count again, but this time in the opposite direction, re-doing
    the test afterward. The results, once again, should support our proposed explanation
    that the number of asteroids is inversely correlated to the FPS, and the degree
    to which it correlates should be consistent between runs as well, showing both
    quantitative and qualitative sides of the story.
  prefs: []
  type: TYPE_NORMAL
- en: Be sure to revert the change to the asteroid count since this is a situation
    where one size doesn’t fit all – different CPUs will be able to support a varying
    number of asteroids without tanking performance. We need to be able to dynamically
    change the asteroid count at runtime based on how well the app is performing.
    Once again Babylon.js has the perfect tool for the job – the Scene Optimizer.
    The **Babylon.js Inspector** is the launching pad for engaging in performance
    analysis and improvement. The **Statistics** tab contains a whole set of aggregated
    Counts – textures, meshes, and more – and timings, such as GPU time and FPS. Supplementing
    that, the metric display is the new Real-time Performance Viewer, which uses the
    same metrics to draw a time-evolving graph of performance. It can run in Real-Time
    and Headless mode, but Headless will have the least impact on performance.
  prefs: []
  type: TYPE_NORMAL
- en: Capturing and exporting performance data to CSV can be done with a click of
    the button but having a testing procedure in place is just as crucial as the data
    collected (if not more!). After defining our procedure, we saw how to execute
    it to capture a performance profile. Upon analysis of the profile, a trend appeared
    to emerge that indicated there might be a bottleneck in the CPU due to the number
    of asteroid Thin Instances involved in the Scene. Because it’s so easy to capture
    profiles – changing the number of asteroids and re-running the test doesn’t take
    long, and the results appear to confirm our assertion of connecting the number
    of asteroids to the overall frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: Improving this situation isn’t as simple as just lowering the number of asteroids,
    though. Because this is so heavily bound to the CPU’s ability to chug through
    the various matrix calculations, different CPUs are going to have different responses
    to the same variables. A dynamically set number of asteroids, matching the number
    the CPU can handle, would be the perfect solution. In the next section, we’ll
    learn all about how to use the Scene Optimizer in both its vanilla, out-of-the-box
    configuration and with a custom stratagem.
  prefs: []
  type: TYPE_NORMAL
- en: Improving Runtime Performance with the Scene Optimizer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing games for a given platform comes with its own set of unique challenges
    and benefits. Console games have the benefit of having standard hardware specifications
    and drivers to target, but at the expense of those same hardware specifications
    creating severe limitations in other areas, such as RAM or **video RAM** (**vRAM**).
    Browser-based games have their own bag of double-edged swords too – the ubiquitous
    nature of JavaScript and the web brings similar problems to console developers
    with restricted hardware specs, and some of the same problems that PC developers
    must face with a wide variety of hardware combinations.
  prefs: []
  type: TYPE_NORMAL
- en: Using the tools and lessons from this chapter and the preceding chapters of
    this book, it’s easy to imagine writing some code – a coroutine perhaps – that
    monitors the real-time performance of the application and makes tweaks to various
    settings in response to bring frame rates up to target. However, it is easy to
    imagine and probably easy to prototype or create a proof-of-concept that works
    in a few limited situations. The devil is always in the details though, and considerable
    time and effort would have to be expended that could otherwise be put to other
    uses.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, and hopefully getting somewhat repetitive to hear at this point,
    is that Babylon.js has got you covered with **SceneOptimizer** ([https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer](https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer)).
    Every time the specified sampling interval passes (by default, every 2,000 ms),
    **SceneOptimizer** checks the current frame rate, and if it isn’t close to or
    at the target, the next optimization in the queue is applied. If the optimization
    is capable of further action, it remains in the queue until it reports it can’t
    help any longer.
  prefs: []
  type: TYPE_NORMAL
- en: Through the `SceneOptimizerOptions` object, **SceneOptimizer** works from a
    queue of strategies that each offer a different type of performance optimization,
    allowing for graceful degradation of scene quality while maintaining a stable
    frame rate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some examples of operations that the built-in optimization strategies can perform
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Merging multiple similar meshes into a single mesh
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling shadows and/or post-processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing texture resolution or hardware scaling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Particle count reductions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each specific **Optimization** has a priority value assigned to it, with lower
    valued optimizations being applied first. To make it more convenient, **SceneOptimizerOptions**
    has a set of static factory methods that allow you to specify a set of optimizations
    according to the amount of visual degradation you’re willing to allow in the scene
    – low, moderate, or high. See the docs at the link mentioned previously for more
    details on the specifics of which optimizations are used for what degradation
    level. Interestingly, **SceneOptimizer** can be configured to run in the opposite
    direction – instead of degrading scene quality, it will enable or apply effects
    until the point where the FPS drops to or below the target. This is useful in
    power-limited scenarios where energy usage is an important consideration but isn’t
    an area that we’re going to cover here (see *Extended Topics* for more though!).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the built-in optimization strategies, it’s possible to define
    custom optimization strategies. This is quite useful for our salient purpose and
    doesn’t require more than a line or two of JavaScript. We’re going to use this
    to create a custom strategy later in the *Creating a Custom Optimization Strategy
    for the Asteroid Belt* section, but first, let’s learn to crawl before we walk
    by learning a bit about **SceneOptimizer** on its own. Don’t be fooled by the
    tall Section Headers – it’s quite simple when we look at the mechanics of it!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the Scene Optimizer and its Operating Modes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Babylon.js Scene Optimizer executes in one of two modes: Improvement and…
    `!isInImprovementMode`. That’s a bit of an insider joke because that’s the property
    set by the last parameter to the `true` is set, optimizations are applied until
    the target frame rate has been reached or we run out of strategies to apply. When
    `false`, it does the opposite or enhances the visuals while the frame rate is
    *above* the target. Each Optimization (even Custom ones) adapts its behavior to
    whichever mode is set, so a strategy that tries to increase frame rate might turn
    off shadows when in optimization mode and turn them on when in enhancement mode.'
  prefs: []
  type: TYPE_NORMAL
- en: The list of optimization/enhancement strategies used by `SceneOptimizerOptions`
    module. Although it’s possible to start with a blank set of options and manually
    create and add strategies, a set of static factory methods for `SceneOptimizerOptions`
    are available that will create a pre-defined set of strategies based on how aggressive
    or extensive the actions are. The three methods range from `LowDegradationAllowed`
    to `HighDegradationAllowed` (see [https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer#options](https://doc.babylonjs.com/divingDeeper/scene/sceneOptimizer#options)
    for more on the specific strategies included in each).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Changing the value of `isInImprovementMode` will not affect the behavior of
    **SceneOptimizer**– the only place that it can be set is in the constructor!
  prefs: []
  type: TYPE_NORMAL
- en: Once you’ve set up `sceneOptimizer.start()` and halted with `sceneOptimizer.stop()`.
    To help with debugging and troubleshooting (among other potential uses), **SceneOptimizer**
    has a set of three Observables that are triggered whenever an optimization is
    applied, succeeds, or fails, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Any Optimizer (that is, a Strategy for those who like Code Patterns) that is
    to be used with `apply` and `getDescription`. The `apply(scene, optimizer)` method
    is called against each Optimization with a `priority` matching the current `priority`
    of `getDescription` is responsible for returning a human-readable textual description
    of what the Optimization does to the given Scene. That’s all there is to it at
    a basic level – simple as promised! Building from this simple foundation, and
    now that we’re ready for it, let’s focus on that custom Optimization hinted at
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Custom Optimization Strategy for the Asteroid Belt
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, we used the `thinInstanceCount` property, this seems
    like a good candidate for a custom Optimization Strategy.
  prefs: []
  type: TYPE_NORMAL
- en: Though several different ways exist to define an `sceneOptimizerOptions.addCustomOptimization`
    method. This function takes three parameters – callbacks for `apply` and `getDescription`
    and a value for `priority` that, by not-much-of-a-coincidence, happens to be the
    interface contract for an **Optimizer** that we so recently discussed!
  prefs: []
  type: TYPE_NORMAL
- en: 'The Playground at [https://playground.babylonjs.com/#17ZX41#10](https://playground.babylonjs.com/%2317ZX41%2310)
    is a modified and stripped-down version of some earlier PGs that we looked at
    during [*Chapter 6*](B17266_06_Final_AM.xhtml#_idTextAnchor120), *Implementing
    Game Mechanics*. This PG just contains the central star and the TI asteroid belt.
    Play with `asteroidBeltOptions.number` until you get a value that gives you a
    low-ish frame rate, then click the `fastOptimizer` to see `createScene` method
    body. Most of this should be easy to understand, but one potential head-scratcher
    is this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'What’s happening here? Well, we want our TI Optimizer to run first before any
    other Optimizers do. Yes, it’s like we’re an only or a first-born child – incredibly
    selfish and self-centered – but this is our application, and we know what we’re
    doing. For the most part. But we also can’t allow other Optimizations to run at
    the same priority because we don’t want to change anything except for the TI count
    before trying anything else to improve things. So, we loop over every existing
    priority in the `optimizerOptions` object and bump its priority to be one greater
    than whatever it previously was at (the default value is zero). That way, in the
    very next line, when we call `addCustomOptimization` with a priority of `0`, we
    know our stuff comes first. Take that, younger Sibs! The custom optimization definition
    can account for either mode of operation, and in its full version, it is capable
    of automatically computing min and max values for the instance count based on
    degradation requirements. The following code has been abridged for brevity and
    clarity but otherwise, it is the same as its big brother at [https://github.com/jelster/space-truckers/blob/ch12/src/thinInstanceCountOptimization.js](https://github.com/jelster/space-truckers/blob/ch12/src/thinInstanceCountOptimization.js):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The interesting thing in the preceding code is that instead of changing the
    TI count by a fixed, set amount, we are changing it in increments of roughly 9%.
    This allows designers and developers to make changes more freely to the base asteroid
    count without needing to make other changes to accommodate different scales of
    values. Hopefully, it’s easy to see how easy it can be to make runtime adaptations
    to an application’s visual quality to meet a target frame rate, because that’s
    the extent of what we’re going to be covering in this topic, at least for this
    edition of this book.
  prefs: []
  type: TYPE_NORMAL
- en: There’s nothing magical about **SceneOptimizer**, even though the effect it
    has of saving developers’ time certainly can be that way. With the incredible
    number of individual performance characteristics accessible to web applications,
    the amount of hand-optimization that is possible or practical becomes more difficult
    and expensive. Balancing performance optimizations done at design time with ones
    dynamically applied at runtime can be the key to getting beautiful and smooth
    visuals for the widest possible range of audiences.
  prefs: []
  type: TYPE_NORMAL
- en: '`SceneOptimizerOptions` object that defines the set of Optimizations that will
    be executed and whether they should be run to improve the frame rate to improve
    the visuals. Many built-in optimizations are provided and can be quickly created
    with `SceneOptimizerOptions.LowDegradationAllowed` and its companion methods,
    but custom Optimizations are almost as quick and easy to use too. Our custom optimizer
    changes the number of TIs until the target frame rate has been achieved. By adding
    it to the Optimization collection by passing an `apply` function, a `getDescription`
    function, and a priority number to `optimizerOptions.addCustomOptimization`, the
    custom optimizer is intended to run solo. Therefore, before we even do that, we
    must nudge the existing Optimization priorities up to keep ours both first and
    on its own in the queue.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When condensed down to an outline form, it may not seem like we covered a whole
    lot of ground in this chapter, but nothing could be further from the truth! Sure,
    there has been little to no mention of many important areas of performance optimization
    and measurement. We’ve covered nothing about the use of **Octtrees** to speed
    up collisions and mesh selection ([https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees](https://doc.babylonjs.com/divingDeeper/scene/optimizeOctrees)),
    toggling various convenience caches to reduce memory footprints ([https://doc.babylonjs.com/divingDeeper/scene/reducingMemoryUsage](https://doc.babylonjs.com/divingDeeper/scene/reducingMemoryUsage)),
    or any other of the almost two-dozen specific optimization heuristics ([https://doc.babylonjs.com/divingDeeper/scene/optimize_your_scene](https://doc.babylonjs.com/divingDeeper/scene/optimize_your_scene))
    that constitute “low-hanging fruit” areas for improvement. That’s OK, though.
    This book’s title starts with *Going the Distance*, not *Plumbing the Depths*,
    and we can always detour into those details in the Second Edition (should there
    ever be one!).
  prefs: []
  type: TYPE_NORMAL
- en: What we have covered are the basics of how to approach thinking and learning
    about performance testing and profiling, starting with general guidelines and
    advice before progressing to the **Real-Time Performance Viewer** tool new to
    Babylon.js v5\. Using those skills, we took a capture of our application and used
    it to identify factors that show that performance is sensitive to changes, such
    as the number of asteroids rendered in the Route Planning Asteroid Belt. Finally,
    we saw how easy basic scene optimization at runtime can be with **SceneOptimizer**.
    We solved the previously identified performance bottleneck with a custom optimization
    strategy that will gradually lower the number of thin instances until the frame
    rate reaches acceptable levels.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll learn how to enhance our game and level it up from
    a regular web application to a Progressive Web Application. This will be the final
    step of making our game fully playable and accessible to everyone at any time;
    by the end of the next chapter, we’ll have an application ready to run offline
    and be published to the major app stores!
  prefs: []
  type: TYPE_NORMAL
- en: Extended Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As always, there’s more to learn and explore in the topics we’ve looked at
    in this chapter. The following are ways you can engage further and practice the
    knowledge you’ve gained in the chapter. Don’t forget to post your questions and
    share your accomplishments on the Babylon.js forums or in the Space-Truckers discussion
    boards at [https://forum.babylonjs.com](https://forum.babylonjs.com) and [https://github.com/jelster/space-truckers/discussions](https://github.com/jelster/space-truckers/discussions):'
  prefs: []
  type: TYPE_NORMAL
- en: Perform a more comprehensive quantitative analysis of the asteroid belt data
    to extract the precise relationship between the FPS and asteroid count. What is
    the specific FPS to asteroid ratio? Having the CSV file is handy here because
    spreadsheet tools such as Excel, Sheets, and Google Sheets are the best way to
    compare and calculate these figures.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Are there ways to rewrite the `AsteroidBelt.update` method to reduce the CPU
    inter-frame time? Maybe it isn’t necessary to loop through every asteroid individually
    if they could be addressed in bundles or batches…
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Along the lines of the previous bullet point, is it possible to refactor the
    Asteroid Belt so that it behaves identically to how it does currently, but happen
    entirely on the GPU? Given what we learned about Shaders and Node Materials in
    the previous chapter, the answer should be an enthusiastic “YES!”. Now go prove
    it by making it happen!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Invert the custom asteroid scene optimization strategy to add thin instances
    instead of removing them. Integrate this with the application so that the scene
    tries to maintain a comfortable FPS range between 24 and 60.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add the ability for users to configure an overall graphics quality preference
    setting. Their choice could influence the specific `SceneOptimizerOptions` that
    are included to either improve visuals or performance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
