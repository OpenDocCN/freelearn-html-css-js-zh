- en: Chapter 5. Modeling Data Structures for Your UI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Representing your system's data accurately is extremely important for every
    application. Being able to access and manipulate datasets in a logical and organized
    way is essential to creating a maintainable code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ext JS has a comprehensive data package which makes this task very easy. It
    has a huge number of features, including:'
  prefs: []
  type: TYPE_NORMAL
- en: Numerous data field types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automatic value conversion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation rules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Associations, including one-to-many, one-to-one, and many-to-many
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Abstracted reading and writing mechanisms, including AJAX, LocalStorage, and
    REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will demonstrate how to create the data structures required
    for our business dashboard application, how to join these data models with associations,
    and how to read and write data from a backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram demonstrates the data entities and their relationships
    that we will be representing in our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modeling Data Structures for Your UI](img/3717_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The main relationships are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A **Location** can contain one or more Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Product** can be found in one or more Locations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Product** can have multiple Sales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **Sale** can involve one or more Products
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **User** can have multiple Sales
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **User** can have multiple Messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data models are defined as regular Ext JS classes and should extend the `Ext.data.Model`
    class. Model classes are generally located in the app's model folder and can have
    any number of subnamespaces to allow for grouping of related models.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by defining our Product model in a file named `Product.js` in
    the `model` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To save on some key strokes, you can generate models in the command line using
    Sencha Cmd. Refer to [Chapter 4](ch04.html "Chapter 4. Architecting an Ext JS
    Application"), *Architecting an Ext JS Application*, for details on how to do
    this.
  prefs: []
  type: TYPE_NORMAL
- en: Fields
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `fields` property in the product model defines the name and type of each
    piece of data attached to the model. Each object in the fields array is a configuration
    object for the `Ext.data.Field` class, which provides various options for how
    the field is interpreted and stored.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main configurations are:'
  prefs: []
  type: TYPE_NORMAL
- en: '`name`: This is the name of the field. It is used as the mapping key when reading
    data from a data source and retrieving it later.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type`: This is data type the assigned value should be parsed into. Possible
    values include `string`, `int`, `float`, `date`, `boolean`, and `auto`. If set
    to `auto`, no automatic conversion will take place.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mapping`: This allows the field''s value to be pulled from a property that
    doesn''t match the field''s name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Field validation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Validation logic for data structures can be baked right into the definition,
    thus ensuring that the same logic isn't scattered all through your application.
    This can be added with the `validators` option which lets you define what validation
    rules should be applied to each field.
  prefs: []
  type: TYPE_NORMAL
- en: We can add validation rules to our Product model to ensure each field's data
    is correct. We do this by defining an object with each key referring to a field's
    name. The value of this property can be a simple string referring to the name
    of a validation type, an object configuring the validation, or an array of objects
    so multiple rules can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows the configuration used to validate the fields in
    the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Name` field is valid by being present (that is, not empty) and by being
    at least three characters long
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Quantity` field must be present
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Price` field is greater than 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `type` config defines the rule we want to apply: out of the box the possibilities
    are `presence`, `length`, `format`, `inclusion`, `exclusion`, `range`, and `email`.
    Details of each can be found in the `Ext.data.validator.*` namespace.'
  prefs: []
  type: TYPE_NORMAL
- en: Any other properties added are then used as options to customize that specific
    validator; for example, min defines the minimum length the `Name` must have.
  prefs: []
  type: TYPE_NORMAL
- en: We can apply the validation rules on a model instance (sometimes referred to
    as a *record*) using the `getValidation` method. This method will return an instance
    of the `Ext.data.Validation` class, which we can then query to determine which
    fields are invalid and retrieve error messages from.
  prefs: []
  type: TYPE_NORMAL
- en: Custom field types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although Ext JS has five field types that cover the majority of scenarios required,
    the latest version introduces the ability to create your own custom field type
    that can have conversions, validations, and serializations built in. This feature
    can help reduce duplicated code across models that share the same field type.
  prefs: []
  type: TYPE_NORMAL
- en: In our Product model, we defined a validation rule for the `Price` field to
    ensure it has a positive value. We will have to apply this same rule to every
    model which has a field holding a monetary value. This would be a prime candidate
    for a custom field type that would allow this configuration to be shared.
  prefs: []
  type: TYPE_NORMAL
- en: Custom field types are declared in the same way as other classes and should
    extend the `Ext.data.field.Field` class (or one of its subclasses if you want
    to build upon their existing functionality). We will extend the `Ext.data.field.Number`
    type, which provides us with the logic to ensure the value is numeric.
  prefs: []
  type: TYPE_NORMAL
- en: 'The validation we added to the Product model can then be added to this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This custom field type can now be used by assigning any field a type of `money`.
    The Product model''s `Price` field will be rewritten as follows, and will automatically
    have the validation rules we specified applied to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Custom data converters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A field''s value can be automatically processed before being stored, in order
    to modify it in some way based on other field values, or to parse its value into
    a different type; for example, splitting a currency value received as "USD10.00"
    to its two component parts: currency and value.'
  prefs: []
  type: TYPE_NORMAL
- en: The first way to do this is to add a `convert` property to the field's configuration
    and assign it a function. This function will be passed the field's value and the
    record instance it is being stored in and should return the processed value which
    will then be stored.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the record instance may be incomplete depending on the
    order in which the fields are populated, so it can't be guaranteed that other
    field values will be available.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how we might implement a `StockValue` field, which
    uses the current `Quantity` and `Price` values to calculate the total value of
    the stock:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We have also included the `depends` config, which creates a dependency between
    our `StockValue` field and the fields we use in its `convert` function. This means
    that when the `Price` or `Quantity` fields are updated, the `StockValue` field
    is recalculated ensuring everything is kept in sync.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of doing this, is to use the `calculate` option, which behaves
    in a very similar way, but is designed to be used for purely calculated fields
    rather than manipulating actual values. We could rewrite the `StockValue` field
    using `calculate`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `calculate` function accepts one parameter containing the record's data
    object, which can be used to access the other fields. As with the `convert` function,
    it should return the value to be stored.
  prefs: []
  type: TYPE_NORMAL
- en: By using `calculate`, the dependencies are automatically determined based on
    the function's contents. So, there is no need for an explicit `depends` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Working with stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Stores are a collection of model instances that allow these models to be manipulated
    (for example, sorted, filtered, searched, and so on). They also provide a platform
    for backend interaction. Many of Ext JS' components can be bound to data stores
    and take care of a lot of the plumbing required to react to changes in the data
    held within it.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will discuss how to construct a simple store and how to
    perform simple manipulation of the data within it; how to create different views
    of a dataset using Chained stores; and finally, how hierarchical data can be stored
    using TreeStores.
  prefs: []
  type: TYPE_NORMAL
- en: Simple stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To define a store, you must extend the `Ext.data.Store` class and configure
    it with a `model` class that it will hold a collection of. The following store
    definition shows a store containing a collection of user records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now add our store to the `stores` config option in our `Application.js`
    file. This will result in the file being loaded and automatically instantiated,
    making it accessible using the `Ext.getStore` method. We can then populate it
    with some sample data using the `add` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have a store filled with data, we can start exploring the various
    methods to interrogate and manipulate the data.
  prefs: []
  type: TYPE_NORMAL
- en: Store stats
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We often need to know how many records there are within a store, and this can
    be done easily with the `getCount` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Retrieving a record
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest way to retrieve a record instance is to access it based on its
    (zero-based) index. To do this, we use the `getAt` method, which returns the `Ext.data.Model`
    subclass at that position (or null if none was found):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Finding specific records
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In order to find a specific record based on a field''s value, we use the `findRecord`
    method which, in its simplest form, accepts a field name and value to match. This
    will return the first record that matches, or null if none was found:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, this will search all records and will look for the search value
    at the beginning of the record''s value. It will be case insensitive and will
    allow partial matches. These options can be changed by passing the following parameters
    to the `findRecord` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Field Name (String)**: The field to match against'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Search Value (String/Number/Date)**: The value to find'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Start Index (Number)**: The index at which to start searching'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Any Match (Boolean)**: True to match the search value anywhere (not just
    at the beginning)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Case Sensitive (Boolean)**: True to match the case'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exact Match (Boolean)**: True to match the whole value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you would prefer to retrieve the index of the record, rather than the actual
    record instance, you can use the `find` method, which will return the record's
    position, or -1 if not found.
  prefs: []
  type: TYPE_NORMAL
- en: Complex searches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your search criteria are more complex than a simple field match, you can
    use your own custom matching functions to introduce multiple criteria. For example,
    you may want to find a user by name and telephone number.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can do this using the `findBy` method, passing it a function that will
    have one parameter, a `record` instance, and it should return true if it is deemed
    a match or false if it isn''t. This function will be executed once for each record
    in the store or until it finds a match:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Filtering a store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Stores can be filtered at any time with similar basic or complex queries. Doing
    so, will result in the store exposing a subset of its original dataset. The filters
    can be removed at any time to restore the full dataset once again.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can filter a store by using the `addFilter` method, which accepts a single
    `Ext.util.Filter` instance or an array of `Ext.util.Filter` instances or configuration
    objects. These should specify the name of the field being filtered on and the
    value to compare against. The following example filters the store to only users
    named "Brian":'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In a way similar to the `findBy` method, we can also filter with a function
    that allows more complex queries to be constructed. The following example shows
    the store being filtered by name and e-mail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'While a store is filtered, all query operations (`find`, `getAt`, and so on)
    are performed on the filtered dataset and won''t search any filtered items. To
    return the store to its unfiltered state, simply call the `clearFilter` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Configuration-based filtering
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All the preceding examples show the store being filtered programmatically.
    It is also possible to define a default filter when the store is configured, and
    which will be applied to all new records being added to the store. This can be
    a full `Ext.util.Filter` configuration object with a simple property/value combination
    or a more complex `filterFn`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Sorting a store
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also change the sort order of a store's records by using the `sort` or
    `sortBy` methods. As with filtering and finding, these allow for simple sorting
    in one or more fields, or more complex sorting using a function. Note that if
    no sorting options are provided, the records will remain in the order they are
    added.
  prefs: []
  type: TYPE_NORMAL
- en: 'A simple sort on `Name` can be seen as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'To perform more complex sorting, you can provide an object that will configure
    an instance of the `Ext.util.Sorter` class. This example sorts by the reverse
    of each user''s name (for example, nhoJ, haraS):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Configuration-based sorting
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Once again, we can define a default sorter on a store that will be reapplied
    after each new record is added. This should be an `Ext.util.Sorter` configuration
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Grouping
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'A store''s records can also be grouped by specific fields or combination of
    fields, which can be very useful to display data in grouped grids. We use the
    `group` method as follows, passing in the `Role` field, as the field to group
    on and `ASC` to determine the sort direction of the groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: By calling this method, the store remains unchanged. This means all its records
    can be accessed as before, but it now gives us access to an `Ext.util.GroupCollection`
    instance, which is a collection of `Ext.util.Group` instances that holds a set
    of grouped records in each instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can interrogate the grouped data using the `getGroups` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to accepting these parameters, we can also pass in an `Ext.util.Grouper`
    config object to define a more complex grouping setup. In the following example,
    we group by each user''s email address domain (notice that we use the `clearGrouping`
    method to reset any existing groupings already in place):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Configuration-based grouping
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Grouping can also be done in the store''s definition by using the `groupField`
    and `groupDirection` options together, or the `grouper` option on its own. The
    following snippets show the store grouped in `Role` using each combination:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'And, here is the another one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Chained stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chained stores are a new addition to Ext JS 5 and allow us to create different
    views of the same underlying data store without it affecting the base data or
    other chained stores.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine that we want to display the data within our `usersStore` in separate
    grids for each role. We would want one grid attached to the `usersStore` with
    a filter of *Role=Administrator*, the next grid with *Role=Supplier*, and so on.
    Unfortunately, before Ext JS 5, this was not possible to do with just one store
    and so, we would have to create multiple stores with multiple copies of the same
    data and manage them all separately. Chained stores take this problem away and
    allow us to attach to an underlying base data store and apply any filters and
    sorters to the view of the data, without them affecting the base store or any
    other linked chained stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram explains this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chained stores](img/3717_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Key things to remember about chained stores are:'
  prefs: []
  type: TYPE_NORMAL
- en: The record instances are shared between all chained stores and the base store
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Any updates made to any of the records will be propagated through to all linked
    stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Going back to our roles example, we can now solve the problem by defining three
    chained stores that can be bound to separate grids or data views.
  prefs: []
  type: TYPE_NORMAL
- en: We link them to the base data store using the `source` configuration option,
    which can accept a store instance or a store ID. We can then add any sorters or
    filters to the chained store, as we would to a regular store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We create these in the folder `store/users/` to keep things organized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We then add the new stores to the `stores` config within `Application.js` and
    create an instance of each and see the record counts in each:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: TreeStores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Ext.data.TreeStore` class is a specialist store, extending from the regular
    `Ext.data.Store` class, which manages hierarchical data. This type of store must
    be used to bind to Tree Panels and other components, where data is required to
    have a hierarchical structure.
  prefs: []
  type: TYPE_NORMAL
- en: TreeStores are created in the same way as regular stores except for one main
    difference. The collection of the model that a TreeStore manages must extend from
    the `Ext.data.TreeModel` class, rather than the usual `Ext.data.Model`.
  prefs: []
  type: TYPE_NORMAL
- en: Ext.data.TreeModels
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason that a TreeStore's model must extend the `Ext.data.TreeModel` class
    is that each model instance must be decorated with additional properties and methods
    to allow the models' hierarchy to be managed correctly, and to allow the tree
    components to display them correctly. These extra properties and methods come
    from the `Ext.data.NodeInterface` class, whose members are all applied to each
    model instance in the TreeStore.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create a simple tree example by first defining the model that will
    be stored. Our data will represent our application''s navigation structure and
    will form the basis of our menu:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If you require this class within your `Application.js` file, create an instance
    of this model and inspect its contents. You will see that the model now has over
    20 additional data fields. These fields are all used to describe each node for
    various purposes, for example, tracking its location, its state, and its appearance.
  prefs: []
  type: TYPE_NORMAL
- en: By default, these fields have their `persist` configs set to `false`, so they
    won't be included in any save operations initiated.
  prefs: []
  type: TYPE_NORMAL
- en: '![Ext.data.TreeModels](img/3717_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you look further, you will also see numerous extra methods added to the
    model. These methods can be used to manage the node and its children, traverse
    the tree structure, and interrogate its position in the hierarchy. Some of the
    more useful methods are detailed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`appendChild`: This adds the specified node(s) as the last child of the current
    node'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`insertChild`: This inserts the new node at the specified position'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeChild`: This removes the specified node from the child collection'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`eachChild`: This executes a function on each of the child nodes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`findChild`: This finds the first child that matches the given property/value
    given'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isLeaf`: This determines if the current node is a leaf without any further
    children'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a TreeStore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will create a simple TreeStore called `BizDash.store.Navigation`, which
    will contain a collection of `BizDash.model.NavigationItem` model instances. This
    store extends the base `Ext.data.TreeStore` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We include this store in the `Application.js` file's `stores` array, where it
    will be automatically loaded and instantiated, and will be accessible via a call
    to `Ext.getStore('Navigation')`.
  prefs: []
  type: TYPE_NORMAL
- en: Populating a TreeStore
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TreeStores must always have a *root node*, which is the root parent of all child
    nodes within the store. It is common for this node to always be hidden and never
    actually seen in tree views. To populate our TreeStore programmatically (that
    is, not from an external data source—we'll talk about that in the next section),
    we can either add the full hierarchy using the `setRoot` method, or add child
    nodes individually using the `appendChild` or `insertChild` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start by using the `setRoot` method, which builds a hierarchy of `NavigationItem`
    instances expanding outward from the root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce a structure, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Populating a TreeStore](img/3717_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that our own fields (`Label` and `Route`) are combined with some of the
    `Ext.data.NodeInterface` fields (children and leaf); we do this to indicate the
    parent-child relationship between the nodes, and to indicate which nodes do not
    have any children, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a root node exists, we can also start adding nodes using the `appendChild`
    method, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Getting data into your application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have only dealt with hard-coded data and not with real-world examples
    of loading and saving data from/to external sources, whether they are REST endpoints,
    local databases, or third party APIs. Ext JS supports a number of different ways
    of assisting with data loading and persistence, including AJAX and LocalStorage.
  prefs: []
  type: TYPE_NORMAL
- en: Ext.Ajax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although only indirectly related to stores, we are first going to discuss AJAX
    requests in a more general sense and how we can perform them to make calls to
    a server backend.
  prefs: []
  type: TYPE_NORMAL
- en: '`Ext.Ajax` is a singleton instance of the `Ext.data.Connection` class, which
    provides us with a very simple interface for making AJAX calls to a server and
    handling the response. We will primarily focus on the `request` method, which
    initiates this call and allows us to specify how it should be made.'
  prefs: []
  type: TYPE_NORMAL
- en: Simple AJAX calls
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start by demonstrating how to make a simple AJAX request to a static
    JSON file. We simply pass in a configuration object to the request method, telling
    the framework where to make the AJAX request to, in this case specifying the `url`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: If we run this in the console of the Ext JS app, we should see the request being
    made in the **Network** tab. At the moment, we are ignoring the response given
    to us, so now we will include a callback function to process the received data.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we''re sure you know, AJAX calls are asynchronous, meaning the rest of the
    code will carry on while the request is made and will not wait for it to complete.
    This means we must handle the response in a callback function that will get executed
    when the response has been received. We do this by specifying the `success` property,
    whose function will be given two parameters: a response object and an options
    object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In our success handler, we will decode the JSON string received and log the
    output to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Handling errors
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Obviously we can''t just rely on the fairytale case where all our AJAX requests
    complete successfully, so we must include some alternative should our request
    fail (that is, return a non-200 response code). We can do this by specifying a
    `failure` config and defining a function that will be executed should the request
    fail. The following example console logs the response status code when an error
    occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: You can try this out by modifying the `url` property to a non-existent one to
    force a 404 error.
  prefs: []
  type: TYPE_NORMAL
- en: Other useful configurations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can pass a lot of configuration options to the `request` method. We run
    down a few of these as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`params`: This is an object whose key/value pairs will be sent along with the
    request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`method`: This is the method by which the request is sent (defaults to `GET`
    when no `params` are present, or `POST` if they are)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`callback`: The function defined here will be called following the request,
    regardless of the success or failure'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`timeout`: This defines the timeout length, in seconds, for the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers`: This defines the headers that are sent with the request'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we have discussed performing simple AJAX requests, which could quite
    happily be used to populate stores, we will move on to explain proxies, which
    provide us with a simple mechanism for our stores to communicate with data sources.
  prefs: []
  type: TYPE_NORMAL
- en: A store or model can be configured with a proxy, which provides an abstracted
    layer above the specifics of each possible data source (be it an external server
    or LocalStorage). This abstraction allows us to provide a simple configuration
    and have the store take care of performing the intricacies of communicating with
    the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proxies are linked to two other class types: `Reader` and `Writer`. The `Reader`
    class is responsible for interpreting the received data and parsing it correctly,
    so it can be turned into Model instances. The `Writer` class on the other hand,
    looks after collecting the data to be saved.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows how these classes are linked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Proxies](img/3717_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: AJAX proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common type of proxy is an AJAX proxy (`Ext.data.proxy.Ajax`), which
    allows us to load and save data to server endpoints via an AJAX call. We will
    add an AJAX proxy to our users store to load the data from a simple JSON file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's break down this code. We start by adding a `proxy` config option with
    a `config` object. We specify the type of `proxy` we want (we'll talk about other
    types shortly)—in this case an AJAX proxy which equates to the `Ext.data.proxy.Ajax`
    class. We next specify the `url` to load the data from. Finally, we tell the proxy
    how to interpret the results by giving it a `reader` configuration. The type tells
    it we're going to be receiving JSON data and so we want to use the `Ext.data.reader.Json`
    class. The `rootProperty` tells the reader which property of the received JSON
    object to look in for the data records.
  prefs: []
  type: TYPE_NORMAL
- en: 'This setup will load data from the `users.json` file, which contains the following
    data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now call the load method of the users store and it will make an AJAX
    request to the `users.json` file and populate itself with four records. The following
    code will load the store and log the loaded records once it has completed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: LocalStorage proxies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Another type of proxy is the `localstorage` proxy, which allows us to load
    and save data to the LocalStorage within the browser. It is extremely simple to
    configure a store to communicate with the LocalStorage, and it follows the same
    pattern as the AJAX proxy, as seen here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Again, we specify the proxy type, which in this case, will use the `Ext.data.proxy.LocalStorage`
    class. We also specify an `id` which will be used to identify items that belong
    to this store within the LocalStorage. This `id` must be unique across all proxies.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will first demonstrate saving records, so we have some data to load in LocalStorage.
    We can save the store''s records by calling the `sync` method after adding some
    records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: If you open up the **Resources** tab of Developer Tools and inspect the LocalStorage
    area, you will see the records with keys based on the `id` we provided.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three types of items stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<id>-counter`, which holds the number of records stored'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<id>`, which contains a comma-separated list of the stored records'' IDs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each record's JSON encoded data stored with a key in the format of `<id>-<Record
    ID>`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![LocalStorage proxies](img/3717_05_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have records saved in LocalStorage, we can call the store's `load`
    method, in the same way as we did with the AJAX proxy, to retrieve these saved
    records and repopulate the store.
  prefs: []
  type: TYPE_NORMAL
- en: REST proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many APIs are RESTful and so Ext JS has a proxy to make integration with them
    extremely easy. By defining a REST proxy, our CRUD requests will be executed to
    the endpoint with the correct method type. We can update our users store to use
    a REST proxy (the `Ext.data.writer.Rest` class), by changing the type to `rest`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our store, by using a REST proxy, we can update one of the
    records and sync the store and see a `GET` request made to retrieve the records
    and a `PUT` request being made to update the data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the screenshot of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![REST proxies](img/3717_05_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Data associations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our application's data models will always have associations between them, which
    must be represented in our client-side applications, so that they can be manipulated
    easily and consistently. Ext JS offers the ability to model one-to-one, one-to-many,
    and many-to-many relationships between Model types.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One-to-many relationships exist when a single entity owns multiple entities
    of a different type. For example, an author *has many* books or a recipe *has
    many* ingredients. In our example project, we will model the association between
    users and sales—a user can have many sales and each sale only has one user.
  prefs: []
  type: TYPE_NORMAL
- en: '![One-to-many](img/3717_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Configuring a proxy and data source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We will start by defining a proxy and simple static data source to connect
    our models to so that they can be populated. We do this with the following code
    pointing to two simple JSON files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Defining the association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have our infrastructure in place to allow data to be loaded into
    each model, we can define the relationship between these two entities. There are
    two ways this can be done: `hasMany` and `reference`.'
  prefs: []
  type: TYPE_NORMAL
- en: hasMany config
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `hasMany` configuration option is the way these associations have always
    been created and allow us to define the models that would be related, and the
    names and data sources of each. This approach allows for more explicit control
    over the details of the association, making it more appropriate for more custom
    situations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The `hasMany` config accepts an array of association definitions and should
    include a model option, defining the name of the model that the association data
    represents, and a name option which will be used to access the associated data.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access the associated data via the defined proxy, we use the user model''s
    static `load` method to load the user with an ID of `1` and specify a callback
    function to execute when it is successfully loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now load in the sale records that are associated with this user. We
    do this by calling the `sales` method (so called based on the `name` config we
    gave it in our `hasMany` configuration), which will return an `Ext.data.Store`
    instance that will contain our sale record instances. We then call that store''s
    `load` method, which will hit the `sale.json` file and return the related sale
    records. Within a callback function, we can then see the data items loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The reference config
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The new way in Ext JS 5 to define associations is to use the `reference` config
    on a model's field, which will link the foreign key in a model to a related model
    type. This greatly simplifies the construction of associations and means both
    directions of the association can be accessed easily.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows the `reference` config added to the `BizDash.model.Sale`
    model, linking it to the `BizDash.model.User` model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use the same code to load the user and then its associated sale
    records:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'This technique also makes it easy to gain access to a sale record associated
    to a user. We make use of the generated `getUser` method, which is added to the
    sale record because of the reference we created. Calling this method will load
    the relevant user model based on the foreign key (`userId`) defined in the sale:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Exploring requests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each time we did a `load` or `getUser` call in our associations, an AJAX request
    was made to our server resources. In our case, we just had simple static JSON
    files, but in real life, we would have a proper server implementation which would
    return the correct data, based on the sale or user being requested. If we look
    at the **Network** tab of Developer Tools, we can see that the request to the
    `user.json` and `sale.json` files passed up parameters that we can then use to
    retrieve the correct data from our server database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the user with ID of 1 loading. It passes the
    ID value as a query string parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring requests](img/3717_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When loading the sales relating to this user, the server is given a slightly
    more complex JSON string with details of the filter that should be applied to
    retrieve the correct data. In our server-side code, we would parse this and use
    it in our database queries.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring requests](img/3717_05_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Many-to-many
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another relationship type that can be modeled is many-to-many. In our application,
    we want to define a many-to-many relationship between Products and Locations,
    meaning that one Product can be stored in multiple Locations and one Location
    can have multiple Products. For example, Product 1 could be located in Warehouse
    1 and Warehouse 2, and Warehouse 1 could store Product 1 and Product 2.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring a proxy and data source
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As we did earlier, we will start by defining a proxy and simple static data
    source to connect our models to so that they can be populated. We do this with
    the following code pointing to two simple JSON files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Defining the association
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The simplest way to define this relationship is to add the `manyToMany` config
    option to the models on both sides of the association (Product and Location) and
    by providing the name of the model that should be on the other side:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Loading the associated data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Like the one-to-many association, by defining this link, Ext JS will generate
    new methods called `locations` and `products` in the Product and Location models
    respectively. These methods will return an `Ext.data.Store` instance and will
    contain our associated data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: From a Location record, the related Products can be loaded in an identical way.
  prefs: []
  type: TYPE_NORMAL
- en: Saving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are able to load data successfully into our application, we can
    move on to persisting changes that we've made to this data within our client-side
    application. In most applications, when a change is made to a data store or record,
    we want to persist that change back to the data source, be it a server-side database
    or LocalStorage store. As mentioned previously, Ext JS provides us with the `Ext.data.writer.Writer`
    class (and its sub-classes) to manage the fields required to be written.
  prefs: []
  type: TYPE_NORMAL
- en: In its most simple and standard form, a store will save any changes made when
    the `sync` method is called, without any further additions to our `proxy` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we continue with our users store example, we can update one of the `record`
    fields and then call the `sync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'If we inspect the **Network** tab of our Developer Tools, we will see a `POST`
    request being made to our `users.json` file passing along the changed field and
    the record''s ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving data](img/3717_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Similarly, we can add or remove records and call the `sync` method and an equivalent
    `POST` request will be made:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the screenshot of the request that is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving data](img/3717_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding request, after a record has been added, shows all fields being
    sent as `POST` parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '![Saving data](img/3717_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a record is removed, the `id` field is POSTed to the server.
  prefs: []
  type: TYPE_NORMAL
- en: CRUD endpoints
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Obviously the preceding example is a little flawed, in that we are POSTing
    changes to a static JSON file. By default, Ext JS will send all changes to the
    URL specified in the proxy, regardless of whether they are adds, updates, or deletes.
    This is often undesirable when separate endpoints exist for each of these actions.
    We can easily configure our proxy to contact a different endpoint for each action
    using the `api` configuration property. Our `proxy` configuration could be rewritten
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If we rerun the add, update, and delete actions, we will see calls being made
    to each of the PHP files specified in our `api` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Data writers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data writers allow us to control how a store's data is constructed for sending
    out to be saved and give us a variety of options to customize this process. By
    default, a proxy will use a JSON writer (`Ext.data.writer.Json`), which will result
    in the to-be-saved data being encoded as a JSON string. Alternatively, the XML
    writer (`Ext.data.writer.Writer`) could be used, which would transfer data as
    XML.
  prefs: []
  type: TYPE_NORMAL
- en: To define a writer, we use the `writer` config of the proxy and give it its
    own configuration object. The `type` property determines which writer class is
    used—either JSON or XML.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure our users store to use a JSON writer, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: We'll now take a look at a couple of the configuration options the writer class
    offers to allow us to customize how and what data is sent to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous update example, we saw the edited field (in this case the `Email`
    field) being sent, along with the record''s ID, to the server. Sometimes, we will
    want to send all the fields to the server regardless of whether they have been
    edited or not. We can do this easily with the `writeAllFields` config as demonstrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is the screenshot of this update request:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data writers](img/3717_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'On occasion, you might want to do some additional processing on a dataset before
    it is sent up to the server. We can define this extra processing step by using
    the `transform` config, giving it a function to execute during the writing process.
    This function will accept the `data` object that will be sent and should return
    the processed `data` object. The following example shows how we can ensure that
    the given e-mail address is always in lowercase:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout this chapter, we have explored the details of how to model our application''s
    data structure with Ext JS. We have covered:'
  prefs: []
  type: TYPE_NORMAL
- en: Defining models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading and saving data to server and LocalStorage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining relationships between models through associations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to work with data within data stores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will make use of all of these lessons throughout the rest of the book as
    our example application comes to life and we start to integrate data sources and
    data visualizations to it.
  prefs: []
  type: TYPE_NORMAL
