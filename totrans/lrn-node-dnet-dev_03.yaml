- en: Chapter 3. A JavaScript Primer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's important to have a solid understanding of JavaScript to write Node.js
    applications. JavaScript is not a large or complex language, but it may seem unusual,
    and has a few quirks and gotchas to watch out for.
  prefs: []
  type: TYPE_NORMAL
- en: The recent release of ECMAScript 2015 (previously named ES6) introduces a number
    of new language features to make JavaScript programming easier and safer. Not
    all ES2015 features are available in all implementations yet. However, all the
    ES2015 features we'll mention in this chapter are available in Node.js and in
    most other JavaScript environments.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll familiarize ourselves with JavaScript so we can write
    Node.js applications with confidence. We will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The JavaScript type system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript as a functional programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Object-oriented programming in JavaScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JavaScript's prototype-based inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing JavaScript types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'JavaScript is a dynamically-typed language. These means that types are checked
    at runtime when you try to do something with a variable, rather than by a compiler.
    For example, the following is valid JavaScript code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Although variables do have a type, this may change throughout the lifetime of
    the variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'JavaScript also tries to implicitly convert types where possible, for example,
    using the equality operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Although this might make sense for frontend JavaScript (for example comparing
    against the value of a form input), in general, it is more likely to be a source
    of errors or confusion. For this reason, it is recommended to always use the strict
    equality and inequality operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript primitive types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript has a small number of primitive types, similar to C# and Java. These
    are string, number, and Boolean, as well as the special single-valued types, null
    and undefined. ES2015 also adds the symbol type, but we won't cover it here as
    its use cases are more advanced.
  prefs: []
  type: TYPE_NORMAL
- en: '**Strings** are immutable, like in C# and Java. Concatenating strings creates
    a new string instance. String literals can be defined with double quotes (as in
    C# or Java) or single quotes. These can be used interchangeably (usually whatever
    is easier to avoid escaping).'
  prefs: []
  type: TYPE_NORMAL
- en: ES2015 also introduces support for template strings, which are defined using
    backticks and can include interpolated expressions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are several ways to define the same string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '**Number** is JavaScript''s only built-in numeric type. It is a double-precision
    64-bit floating-point number, like `double` in C# or Java. It has special values
    `NaN` (not a number) and `Infinity` for values that cannot be represented otherwise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that although there is only a single `NaN` value, it is not treated as
    equal to itself. JavaScript provides the special `isNaN` function for testing
    whether a variable contains the `NaN` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **null** type has a single instance, represented by the literal `null`,
    just as in C# or Java. JavaScript also has the **undefined** type. Variables or
    parameters that have never been assigned will have the value `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that our `undeclared` identifier cannot be accessed as a variable in normal
    code because it has not been declared. However, we can pass it to the `typeof`
    operator, which evaluates to the undefined type.
  prefs: []
  type: TYPE_NORMAL
- en: Functional object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JavaScript is a functional object-oriented programming language. However, it
    is quite different to other object-oriented programming languages such as C# or
    Java. Despite having a similar syntax, there are some important differences.
  prefs: []
  type: TYPE_NORMAL
- en: Functional programming in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In JavaScript, functions are first-class objects. This means that functions
    can be treated like any other object: they can be created dynamically, assigned
    to variables, or passed into methods as arguments.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it very easy to specify event callbacks, or to program in a more
    functional style using **higher-order functions**. Higher-order functions are
    functions that take other functions as arguments, and/or return another function.
    Here''s a trivial example of filtering an array of numbers first in an imperative
    style and then in a functional style. Note that this example also shows JavaScript''s
    **array literal notation** for creating arrays, using square brackets. It also
    demonstrates JavaScript''s conditional construct and one of its loop constructs,
    which should be familiar from other languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The second approach in the example makes use of a function expression to define
    a new, anonymous function inline. In general, this is referred to as a lambda
    expression (after lambda calculus in mathematics). This function is passed-in
    to the built in `filter` expression available on JavaScript arrays.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, assignment and passing of behavior was originally only possible using
    delegates. Since C# 3.0, support for lambda expressions makes it much easier to
    use functions in this way. This allows a more functional style of programming,
    for example, using C#'s **Language-Integrated Query** (**LINQ**) features.
  prefs: []
  type: TYPE_NORMAL
- en: In Java, for a long time there was no native way for a function to exist independently.
    You would have to define a method on a (possibly anonymous) class and pass this
    around, adding a lot of boilerplate. Java 8 introduces support for lambda expressions
    in a similar way to C#.
  prefs: []
  type: TYPE_NORMAL
- en: While C# and Java may have taken a while to catch up, you might be thinking
    that JavaScript is now falling behind. The syntax for defining a new function
    in JavaScript is quite clumsy compared to the lambda syntax in C# and Java.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is especially unfortunate since JavaScript uses a C-like syntax for familiarity
    with other languages like Java! This is resolved in ES2015 with **arrow functions**,
    allowing us to rewrite the previous example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This is a simple arrow function with a single argument and a single expression.
    In this case, the expression is implicitly returned.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It can be useful to read the `=>` notation in arrow functions as *goes to*.
  prefs: []
  type: TYPE_NORMAL
- en: Arrow functions may have multiple (or zero) arguments, in which case they must
    be surrounded by parentheses. If the function body is enclosed in braces, it may
    contain multiple statements, in which case there is no implicit return. These
    are exactly the same syntax rules as for lambda expressions in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a more complex arrow function expression that returns the maximum of
    its two arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Understanding scopes in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Traditionally, in JavaScript, there are only two possible variable scopes:
    global and functional. That is, an identifier (a variable name) is defined globally,
    or for an entire function. This can lead to some surprising behavior, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In most other languages, you would expect `i` to exist for the duration of
    the `for` loop, and `j` to exist for each loop iteration. You would therefore
    expect this function to log `undefined undefined`. In fact, it logs `10 18`. This
    is because the variables are not scoped to the block of the `for` loop, but to
    the entire function. So the preceding code is equivalent to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: JavaScript treats all variable declarations as if they were made at the top
    of the function. This is known as **variable hoisting**. Although consistent,
    this can be confusing and lead to subtle bugs.
  prefs: []
  type: TYPE_NORMAL
- en: 'ES2015 introduces the `let` keyword for declaring variables. This works exactly
    the same as `var` except that variables are block-scoped. There is also the `const`
    keyword, which works the same as `let` except that it does not allow reassignment.
    It is recommended that you always use `let` rather than `var`, and use `const`
    wherever possible. Check the following code for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Note the `"use strict"` string in the preceding example. We'll discuss this
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `"use strict"` string is a hint to the JavaScript interpreter to enable
    **Strict Mode**. This makes the language safer by treating certain usages of the
    language as errors. For example, mistyping a variable name without strict mode
    will define a new variable at the global level, rather than causing an error.
  prefs: []
  type: TYPE_NORMAL
- en: Strict mode is also now used by some browsers to enable features in the newest
    version of JavaScript, such as the `let` and `const` keywords previously shown.
    If you are running these examples in a browser, you may find that the preceding
    listing doesn't work without strict mode.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, you should always enable strict mode in all of your production
    code. The `"use strict"` string affects all code in the current scope (that is,
    JavaScript's traditional functional or global scope), so should usually be placed
    at the top of a function (or the top of a module's script file in Node.js).
  prefs: []
  type: TYPE_NORMAL
- en: Object-oriented programming in JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Anything that is not one of JavaScript's built-in primitives (strings, number,
    null, and so on) is an **object**. This includes functions, as we've seen in the
    previous section. Functions are just a special type of object that can be invoked
    with arguments. Arrays are a special type of object with list-like behavior. All
    objects (including these two special types) can have properties, which are just
    names with a value. You can think of JavaScript objects as a dictionary with string
    keys and object values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Objects can be created with properties using the object literal notation, as
    in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You might find this notation familiar even if you've never written any JavaScript,
    as it is the basis for JSON. Note that a method is just an object property that
    happens to have a function as its value. Also note that within methods, we can
    refer to the containing object using the `this` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, note that we did not need to define a class for our object. JavaScript
    is unusual amongst object-oriented languages in that it doesn't really have classes.
  prefs: []
  type: TYPE_NORMAL
- en: Programming without classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In most object-oriented languages, we can declare methods in a class for use
    by all of its object instances. We can also share behavior between classes through
    inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a graph with a very large number of points. These may be
    represented by objects that are created dynamically and have some common behavior.
    We could implement points like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: One problem with this approach is that the `isAboveDiagonal` method is redefined
    for each point on our graph, thus taking up more space in memory.
  prefs: []
  type: TYPE_NORMAL
- en: We can address this using **prototypal inheritance**. Although JavaScript doesn't
    have classes, objects can inherit from other objects. Each object has a **prototype**.
    If we try to access a property on an object and that property doesn't exist, the
    interpreter will look for a property with the same name on the object's prototype
    instead. If it doesn't exist there, it will check the prototype's prototype, and
    so on. The prototype chain will end with the built-in `Object.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement this for our point objects as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `isAboveDiagonal` method now only exists once in memory, on the `pointPrototype`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: When we try to call `isAboveDiagonal` on an individual point object, it is not
    present, but it is found on the prototype instead.
  prefs: []
  type: TYPE_NORMAL
- en: Note that this tells us something important about the `this` keyword. It actually
    refers to the object that the current function was called on, rather than the
    object it was defined on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating objects with the new keyword
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'We can rewrite the preceding code example in a slightly different form, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This makes use of the special `arguments` object, which contains an array of
    the arguments to the current function. It also uses the `apply` method (which
    is available on all functions) to call the `Point` function on the `newPoint`
    object with the same arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, our `pointPrototype` object isn''t particularly closely associated
    with the `Point` function. Let''s resolve this by using the `Point` function''s
    `prototype` property instead. This is a built-in property available on all functions
    by default. It just contains an empty object to which we can add additional properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This might seem like a needlessly complicated way of doing things. However,
    JavaScript has a special operator that allows us to greatly simplify the previous
    code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The behavior of the `new` operator is identical to our `createPoint` function
    in the previous example. There is one small exception: if the `Point` function
    actually returned a value, then this would be used instead of `newPoint`. It is
    conventional in JavaScript to start functions with a capital letter if they are
    intended to be used with the `new` operator.'
  prefs: []
  type: TYPE_NORMAL
- en: Programming with classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although JavaScript doesn't really have classes, ES2015 introduces a new `class`
    keyword. This makes it possible to implement shared behavior and inheritance in
    a way that may be more familiar compared to other object-oriented languages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The equivalent of our preceding code would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Note that this really is equivalent to our preceding code. The `class` keyword
    is just syntactic sugar for setting up the prototype-based inheritance already
    discussed.
  prefs: []
  type: TYPE_NORMAL
- en: Class-based inheritance
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'As mentioned before, an object''s prototype may in turn have another prototype,
    allowing a chain of inheritance. Setting up such a chain becomes quite complicated
    using the prototype-based approach from the previous section. It is much more
    intuitive using the class keyword, as in the following example (which might be
    used for plotting a graph with error bars):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have introduced JavaScript's type system, understood functions
    as first-class objects in JavaScript, seen how JavaScript differs from other object-oriented
    languages, implemented inheritance using prototypes and classes, and learned the
    new features of ECMAScript 2015 (ES6) that make the language safer and more intuitive
    to use.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a firm grounding in JavaScript, you can start writing Node.js
    applications with confidence. In the next chapter, we will expand on our Express
    project and see how the module system in Node.js allows us to structure our codebase.
  prefs: []
  type: TYPE_NORMAL
