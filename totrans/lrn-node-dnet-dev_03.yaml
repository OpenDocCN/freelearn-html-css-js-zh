- en: Chapter 3. A JavaScript Primer
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章。JavaScript 入门
- en: It's important to have a solid understanding of JavaScript to write Node.js
    applications. JavaScript is not a large or complex language, but it may seem unusual,
    and has a few quirks and gotchas to watch out for.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 JavaScript 对于编写 Node.js 应用程序非常重要。JavaScript 不是一个庞大或复杂的语言，但它可能看起来有些不寻常，并且有一些需要注意的怪癖和陷阱。
- en: The recent release of ECMAScript 2015 (previously named ES6) introduces a number
    of new language features to make JavaScript programming easier and safer. Not
    all ES2015 features are available in all implementations yet. However, all the
    ES2015 features we'll mention in this chapter are available in Node.js and in
    most other JavaScript environments.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: ECMAScript 2015（之前称为 ES6）的最新发布引入了许多新的语言特性，使 JavaScript 编程更加容易和安全。然而，并非所有 ES2015
    特性都已在所有实现中可用。但是，我们将在本章中提到的所有 ES2015 特性都在 Node.js 以及大多数其他 JavaScript 环境中可用。
- en: 'In this chapter, we''ll familiarize ourselves with JavaScript so we can write
    Node.js applications with confidence. We will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将熟悉 JavaScript，以便我们可以自信地编写 Node.js 应用程序。我们将涵盖以下主题：
- en: The JavaScript type system
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的类型系统
- en: JavaScript as a functional programming language
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 作为一种函数式编程语言
- en: Object-oriented programming in JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 中的面向对象编程
- en: JavaScript's prototype-based inheritance
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 的基于原型的继承
- en: Introducing JavaScript types
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍 JavaScript 类型
- en: 'JavaScript is a dynamically-typed language. These means that types are checked
    at runtime when you try to do something with a variable, rather than by a compiler.
    For example, the following is valid JavaScript code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种动态类型语言。这意味着类型是在运行时检查的，当你尝试对变量进行操作时，而不是由编译器检查。例如，以下代码是有效的 JavaScript
    代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Although variables do have a type, this may change throughout the lifetime of
    the variable.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然变量确实有类型，但这种类型可能会在变量的整个生命周期中发生变化。
- en: 'JavaScript also tries to implicitly convert types where possible, for example,
    using the equality operator:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 还试图在可能的情况下隐式转换类型，例如，使用相等运算符：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Although this might make sense for frontend JavaScript (for example comparing
    against the value of a form input), in general, it is more likely to be a source
    of errors or confusion. For this reason, it is recommended to always use the strict
    equality and inequality operators:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这可能在前端 JavaScript 中有意义（例如，与表单输入的值进行比较），但通常来说，它更可能是错误或混淆的来源。因此，建议始终使用严格的相等和不相等运算符：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: JavaScript primitive types
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 原始类型
- en: JavaScript has a small number of primitive types, similar to C# and Java. These
    are string, number, and Boolean, as well as the special single-valued types, null
    and undefined. ES2015 also adds the symbol type, but we won't cover it here as
    its use cases are more advanced.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有少量原始类型，类似于 C# 和 Java。这些是字符串、数字和布尔值，以及特殊的单值类型 null 和 undefined。ES2015
    还添加了 symbol 类型，但在这里我们不会介绍它，因为它的用例更为高级。
- en: '**Strings** are immutable, like in C# and Java. Concatenating strings creates
    a new string instance. String literals can be defined with double quotes (as in
    C# or Java) or single quotes. These can be used interchangeably (usually whatever
    is easier to avoid escaping).'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '**字符串**是不可变的，就像在 C# 和 Java 中一样。连接字符串会创建一个新的字符串实例。字符串字面量可以用双引号（如在 C# 或 Java
    中）或单引号定义。这些可以互换使用（通常使用起来更简单，可以避免转义）。'
- en: ES2015 also introduces support for template strings, which are defined using
    backticks and can include interpolated expressions.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 还引入了对模板字符串的支持，这些字符串使用反引号定义，并可以包含插值表达式。
- en: 'Here are several ways to define the same string:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些定义相同字符串的方法：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '**Number** is JavaScript''s only built-in numeric type. It is a double-precision
    64-bit floating-point number, like `double` in C# or Java. It has special values
    `NaN` (not a number) and `Infinity` for values that cannot be represented otherwise:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '**数字**是 JavaScript 唯一的内置数值类型。它是一个双精度 64 位浮点数，类似于 C# 或 Java 中的 `double`。它有特殊的值
    `NaN`（不是一个数字）和 `Infinity`，用于表示无法用其他方式表示的值：'
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that although there is only a single `NaN` value, it is not treated as
    equal to itself. JavaScript provides the special `isNaN` function for testing
    whether a variable contains the `NaN` value.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管只有一个 `NaN` 值，但它不会被视为等于自身。JavaScript 提供了特殊的 `isNaN` 函数来测试变量是否包含 `NaN` 值。
- en: 'The **null** type has a single instance, represented by the literal `null`,
    just as in C# or Java. JavaScript also has the **undefined** type. Variables or
    parameters that have never been assigned will have the value `undefined`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: '**null**类型有一个实例，由字面量`null`表示，就像在C#或Java中一样。JavaScript也有**undefined**类型。从未被分配的变量或参数将具有`undefined`值：'
- en: '[PRE5]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that our `undeclared` identifier cannot be accessed as a variable in normal
    code because it has not been declared. However, we can pass it to the `typeof`
    operator, which evaluates to the undefined type.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的`undeclared`标识符在正常代码中不能作为变量访问，因为它没有被声明。然而，我们可以将它传递给`typeof`运算符，它评估为`undefined`类型。
- en: Functional object-oriented programming
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 函数式面向对象编程
- en: JavaScript is a functional object-oriented programming language. However, it
    is quite different to other object-oriented programming languages such as C# or
    Java. Despite having a similar syntax, there are some important differences.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript是一种函数式面向对象编程语言。然而，它与C#或Java等其他面向对象编程语言相当不同。尽管语法相似，但有一些重要的区别。
- en: Functional programming in JavaScript
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript中的函数式编程
- en: 'In JavaScript, functions are first-class objects. This means that functions
    can be treated like any other object: they can be created dynamically, assigned
    to variables, or passed into methods as arguments.'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，函数是一等对象。这意味着函数可以像任何其他对象一样被对待：它们可以动态创建，分配给变量，或作为参数传递给方法。
- en: 'This makes it very easy to specify event callbacks, or to program in a more
    functional style using **higher-order functions**. Higher-order functions are
    functions that take other functions as arguments, and/or return another function.
    Here''s a trivial example of filtering an array of numbers first in an imperative
    style and then in a functional style. Note that this example also shows JavaScript''s
    **array literal notation** for creating arrays, using square brackets. It also
    demonstrates JavaScript''s conditional construct and one of its loop constructs,
    which should be familiar from other languages:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得指定事件回调或使用**高阶函数**进行更函数式编程变得非常容易。高阶函数是接受其他函数作为参数，或返回另一个函数的函数。以下是一个简单的例子，首先以命令式风格然后以函数式风格过滤数字数组。注意，此示例还展示了JavaScript的**数组字面量表示法**，用于创建数组，使用方括号。它还演示了JavaScript的条件构造和其中一个循环构造，这些在其他语言中应该是熟悉的：
- en: '[PRE6]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The second approach in the example makes use of a function expression to define
    a new, anonymous function inline. In general, this is referred to as a lambda
    expression (after lambda calculus in mathematics). This function is passed-in
    to the built in `filter` expression available on JavaScript arrays.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的第二种方法使用函数表达式在行内定义一个新的匿名函数。通常，这被称为lambda表达式（数学中的lambda演算之后）。这个函数被传递给JavaScript数组上可用的内置`filter`表达式。
- en: In C#, assignment and passing of behavior was originally only possible using
    delegates. Since C# 3.0, support for lambda expressions makes it much easier to
    use functions in this way. This allows a more functional style of programming,
    for example, using C#'s **Language-Integrated Query** (**LINQ**) features.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，最初只能使用委托来执行赋值和传递行为。自C# 3.0以来，对lambda表达式的支持使得使用函数的方式更加简单。这允许更函数式的编程风格，例如，使用C#的**语言集成查询**（**LINQ**）功能。
- en: In Java, for a long time there was no native way for a function to exist independently.
    You would have to define a method on a (possibly anonymous) class and pass this
    around, adding a lot of boilerplate. Java 8 introduces support for lambda expressions
    in a similar way to C#.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在Java中，长期以来没有一种让函数独立存在的方法。你必须在一个（可能是匿名）类上定义一个方法，并将这个方法传递出去，这增加了大量的样板代码。Java
    8以类似于C#的方式引入了对lambda表达式的支持。
- en: While C# and Java may have taken a while to catch up, you might be thinking
    that JavaScript is now falling behind. The syntax for defining a new function
    in JavaScript is quite clumsy compared to the lambda syntax in C# and Java.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 C# 和 Java 可能需要一段时间才能赶上，但你可能会想，JavaScript 现在可能落后了。与 C# 和 Java 中的 lambda 语法相比，JavaScript
    定义新函数的语法相当笨拙。
- en: 'This is especially unfortunate since JavaScript uses a C-like syntax for familiarity
    with other languages like Java! This is resolved in ES2015 with **arrow functions**,
    allowing us to rewrite the previous example as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这尤其不幸，因为JavaScript使用类似于C语言的语法，以便与其他语言如Java兼容！在ES2015中，**箭头函数**解决了这个问题，允许我们将前面的示例重写如下：
- en: '[PRE7]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a simple arrow function with a single argument and a single expression.
    In this case, the expression is implicitly returned.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个带有单个参数和单个表达式的简单箭头函数。在这种情况下，表达式是隐式返回的。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It can be useful to read the `=>` notation in arrow functions as *goes to*.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在箭头函数中，可以将 `=>` 符号读作 *goes to*。
- en: Arrow functions may have multiple (or zero) arguments, in which case they must
    be surrounded by parentheses. If the function body is enclosed in braces, it may
    contain multiple statements, in which case there is no implicit return. These
    are exactly the same syntax rules as for lambda expressions in C#.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 箭头函数可以有多个（或零个）参数，在这种情况下，它们必须被括号包围。如果函数体被大括号包围，它可能包含多个语句，在这种情况下没有隐式返回。这些语法规则与
    C# 中的 lambda 表达式语法完全相同。
- en: 'Here is a more complex arrow function expression that returns the maximum of
    its two arguments:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个更复杂的箭头函数表达式，它返回两个参数中的最大值：
- en: '[PRE8]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Understanding scopes in JavaScript
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 JavaScript 中的作用域
- en: 'Traditionally, in JavaScript, there are only two possible variable scopes:
    global and functional. That is, an identifier (a variable name) is defined globally,
    or for an entire function. This can lead to some surprising behavior, for example:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 传统上，在 JavaScript 中，只有两种可能的变量作用域：全局和函数。也就是说，一个标识符（变量名）是在全局定义的，或者是对整个函数定义的。这可能会导致一些令人惊讶的行为，例如：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In most other languages, you would expect `i` to exist for the duration of
    the `for` loop, and `j` to exist for each loop iteration. You would therefore
    expect this function to log `undefined undefined`. In fact, it logs `10 18`. This
    is because the variables are not scoped to the block of the `for` loop, but to
    the entire function. So the preceding code is equivalent to the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数其他语言中，您会期望 `i` 在 `for` 循环的整个过程中存在，而 `j` 在每次循环迭代中存在。因此，您会期望这个函数记录 `undefined
    undefined`。实际上，它记录的是 `10 18`。这是因为变量不是作用域到 `for` 循环的块中，而是作用域到整个函数。因此，前面的代码等同于以下代码：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: JavaScript treats all variable declarations as if they were made at the top
    of the function. This is known as **variable hoisting**. Although consistent,
    this can be confusing and lead to subtle bugs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 将所有变量声明视为在函数顶部创建的。这被称为 **变量提升**。虽然一致，但这可能会令人困惑并导致微妙的错误。
- en: 'ES2015 introduces the `let` keyword for declaring variables. This works exactly
    the same as `var` except that variables are block-scoped. There is also the `const`
    keyword, which works the same as `let` except that it does not allow reassignment.
    It is recommended that you always use `let` rather than `var`, and use `const`
    wherever possible. Check the following code for example:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ES2015 引入了 `let` 关键字用于声明变量。这与 `var` 的行为完全相同，只是变量是块作用域的。还有一个 `const` 关键字，它与 `let`
    的行为相同，只是不允许重新赋值。建议您始终使用 `let` 而不是 `var`，并在可能的情况下使用 `const`。以下代码为例：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note the `"use strict"` string in the preceding example. We'll discuss this
    in the next section.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 注意前面示例中的 `"use strict"` 字符串。我们将在下一节中讨论这个问题。
- en: Strict mode
  id: totrans-56
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 严格模式
- en: The `"use strict"` string is a hint to the JavaScript interpreter to enable
    **Strict Mode**. This makes the language safer by treating certain usages of the
    language as errors. For example, mistyping a variable name without strict mode
    will define a new variable at the global level, rather than causing an error.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`"use strict"` 字符串是给 JavaScript 解释器的提示，以启用 **严格模式**。这使得语言更安全，因为它将某些语言用法视为错误。例如，在严格模式下，如果误输变量名，则会在全局级别定义一个新变量，而不是引发错误。'
- en: Strict mode is also now used by some browsers to enable features in the newest
    version of JavaScript, such as the `let` and `const` keywords previously shown.
    If you are running these examples in a browser, you may find that the preceding
    listing doesn't work without strict mode.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 严格模式现在也被一些浏览器用于启用 JavaScript 最新版本中的功能，例如之前显示的 `let` 和 `const` 关键字。如果您在浏览器中运行这些示例，您可能会发现前面的列表在没有严格模式的情况下无法工作。
- en: In any case, you should always enable strict mode in all of your production
    code. The `"use strict"` string affects all code in the current scope (that is,
    JavaScript's traditional functional or global scope), so should usually be placed
    at the top of a function (or the top of a module's script file in Node.js).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，您都应该在所有生产代码中始终启用严格模式。`"use strict"` 字符串影响当前作用域中的所有代码（即 JavaScript 的传统函数或全局作用域），因此通常应放置在函数的顶部（或
    Node.js 中模块脚本文件的顶部）。
- en: Object-oriented programming in JavaScript
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 中的面向对象编程
- en: Anything that is not one of JavaScript's built-in primitives (strings, number,
    null, and so on) is an **object**. This includes functions, as we've seen in the
    previous section. Functions are just a special type of object that can be invoked
    with arguments. Arrays are a special type of object with list-like behavior. All
    objects (including these two special types) can have properties, which are just
    names with a value. You can think of JavaScript objects as a dictionary with string
    keys and object values.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 任何不是 JavaScript 内置原始类型（字符串、数字、null 等）的东西都是一个 **对象**。这包括函数，正如我们在上一节中看到的。函数只是可以带参数调用的特殊类型的对象。数组是具有类似列表行为的特殊类型的对象。所有对象（包括这两种特殊类型）都可以有属性，属性只是带有值的名称。你可以把
    JavaScript 对象想象成一个具有字符串键和对象值的字典。
- en: 'Objects can be created with properties using the object literal notation, as
    in the following example:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用对象字面量表示法创建具有属性的对象，如下例所示：
- en: '[PRE12]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: You might find this notation familiar even if you've never written any JavaScript,
    as it is the basis for JSON. Note that a method is just an object property that
    happens to have a function as its value. Also note that within methods, we can
    refer to the containing object using the `this` keyword.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你没有写过任何 JavaScript，你也可能对这个表示法很熟悉，因为它是 JSON 的基础。请注意，方法只是一个恰好具有函数值的对象属性。还要注意，在方法内部，我们可以使用
    `this` 关键字来引用包含的对象。
- en: Finally, note that we did not need to define a class for our object. JavaScript
    is unusual amongst object-oriented languages in that it doesn't really have classes.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，请注意，我们不需要为我们的对象定义一个类。JavaScript 在面向对象的语言中很独特，因为它实际上没有类。
- en: Programming without classes
  id: totrans-66
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 无类编程
- en: In most object-oriented languages, we can declare methods in a class for use
    by all of its object instances. We can also share behavior between classes through
    inheritance.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数面向对象的语言中，我们可以在类中声明方法，供所有对象实例使用。我们还可以通过继承在类之间共享行为。
- en: 'Let''s say we have a graph with a very large number of points. These may be
    represented by objects that are created dynamically and have some common behavior.
    We could implement points like this:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个包含大量点的图。这些点可能是由动态创建的具有一些共同行为的对象表示。我们可以这样实现点：
- en: '[PRE13]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: One problem with this approach is that the `isAboveDiagonal` method is redefined
    for each point on our graph, thus taking up more space in memory.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的一个问题是，`isAboveDiagonal` 方法在我们的图上的每个点上都被重新定义，因此占用更多的内存空间。
- en: We can address this using **prototypal inheritance**. Although JavaScript doesn't
    have classes, objects can inherit from other objects. Each object has a **prototype**.
    If we try to access a property on an object and that property doesn't exist, the
    interpreter will look for a property with the same name on the object's prototype
    instead. If it doesn't exist there, it will check the prototype's prototype, and
    so on. The prototype chain will end with the built-in `Object.prototype`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 **原型继承** 来解决这个问题。虽然 JavaScript 没有类，但对象可以继承自其他对象。每个对象都有一个 **原型**。如果我们尝试访问一个对象的属性，而这个属性不存在，解释器将在对象的原型上查找具有相同名称的属性。如果那里也不存在，它将检查原型的原型，依此类推。原型链将以内置的
    `Object.prototype` 结束。
- en: 'We can implement this for our point objects as follows:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以这样为我们点的对象实现：
- en: '[PRE14]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `isAboveDiagonal` method now only exists once in memory, on the `pointPrototype`
    object.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`isAboveDiagonal` 方法现在只在内存中的 `pointPrototype` 对象上存在一次。'
- en: When we try to call `isAboveDiagonal` on an individual point object, it is not
    present, but it is found on the prototype instead.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试在一个单独的点对象上调用 `isAboveDiagonal` 方法时，它不存在，而是在原型上找到。
- en: Note that this tells us something important about the `this` keyword. It actually
    refers to the object that the current function was called on, rather than the
    object it was defined on.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这告诉我们关于 `this` 关键字的重要信息。它实际上指的是当前函数被调用的对象，而不是定义它的对象。
- en: Creating objects with the new keyword
  id: totrans-77
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用 new 关键字创建对象
- en: 'We can rewrite the preceding code example in a slightly different form, as
    follows:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以以略微不同的形式重写前面的代码示例，如下所示：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This makes use of the special `arguments` object, which contains an array of
    the arguments to the current function. It also uses the `apply` method (which
    is available on all functions) to call the `Point` function on the `newPoint`
    object with the same arguments.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这使用了特殊的 `arguments` 对象，它包含当前函数的参数数组。它还使用了 `apply` 方法（所有函数都可用）来以相同的参数在 `newPoint`
    对象上调用 `Point` 函数。
- en: 'At the moment, our `pointPrototype` object isn''t particularly closely associated
    with the `Point` function. Let''s resolve this by using the `Point` function''s
    `prototype` property instead. This is a built-in property available on all functions
    by default. It just contains an empty object to which we can add additional properties:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的 `pointPrototype` 对象与 `Point` 函数并没有特别紧密的联系。让我们通过使用 `Point` 函数的 `prototype`
    属性来解决这个问题。这是一个默认情况下所有函数都有的内置属性。它只包含一个空对象，我们可以向其中添加额外的属性：
- en: '[PRE16]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This might seem like a needlessly complicated way of doing things. However,
    JavaScript has a special operator that allows us to greatly simplify the previous
    code, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能看起来是一种不必要的复杂做事方式。然而，JavaScript 有一个特殊的操作符，允许我们极大地简化之前的代码，如下所示：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The behavior of the `new` operator is identical to our `createPoint` function
    in the previous example. There is one small exception: if the `Point` function
    actually returned a value, then this would be used instead of `newPoint`. It is
    conventional in JavaScript to start functions with a capital letter if they are
    intended to be used with the `new` operator.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`new` 操作符的行为与上一个示例中的 `createPoint` 函数相同。有一个小的例外：如果 `Point` 函数实际上返回了一个值，那么就会使用这个值而不是
    `newPoint`。在 JavaScript 中，如果函数打算与 `new` 操作符一起使用，通常以大写字母开头。'
- en: Programming with classes
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用类进行编程
- en: Although JavaScript doesn't really have classes, ES2015 introduces a new `class`
    keyword. This makes it possible to implement shared behavior and inheritance in
    a way that may be more familiar compared to other object-oriented languages.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然JavaScript实际上并没有类，但ES2015引入了一个新的 `class` 关键字。这使得以可能比其他面向对象语言更熟悉的方式实现共享行为和继承成为可能。
- en: 'The equivalent of our preceding code would look like the following:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前代码的等价物看起来如下所示：
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that this really is equivalent to our preceding code. The `class` keyword
    is just syntactic sugar for setting up the prototype-based inheritance already
    discussed.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这实际上与我们的上一段代码是等价的。`class` 关键字只是设置已讨论的基于原型的继承的语法糖。
- en: Class-based inheritance
  id: totrans-91
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 基于类的继承
- en: 'As mentioned before, an object''s prototype may in turn have another prototype,
    allowing a chain of inheritance. Setting up such a chain becomes quite complicated
    using the prototype-based approach from the previous section. It is much more
    intuitive using the class keyword, as in the following example (which might be
    used for plotting a graph with error bars):'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，一个对象的原型可能还有另一个原型，从而允许继承链。使用上一节中提到的基于原型的方法设置这样的链变得相当复杂。使用类关键字会更直观，如下面的示例（可能用于绘制带有误差棒的图表）所示：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Summary
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we have introduced JavaScript's type system, understood functions
    as first-class objects in JavaScript, seen how JavaScript differs from other object-oriented
    languages, implemented inheritance using prototypes and classes, and learned the
    new features of ECMAScript 2015 (ES6) that make the language safer and more intuitive
    to use.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 JavaScript 的类型系统，理解了函数在 JavaScript 中的第一类对象，看到了 JavaScript 与其他面向对象语言的不同之处，使用了原型和类来实现继承，并学习了
    ECMAScript 2015（ES6）的新特性，这些特性使语言更安全、更易于使用。
- en: Now that you have a firm grounding in JavaScript, you can start writing Node.js
    applications with confidence. In the next chapter, we will expand on our Express
    project and see how the module system in Node.js allows us to structure our codebase.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经对 JavaScript 有了一个坚实的基础，你可以自信地开始编写 Node.js 应用程序。在下一章中，我们将扩展我们的 Express 项目，并了解
    Node.js 中的模块系统如何允许我们构建我们的代码库。
