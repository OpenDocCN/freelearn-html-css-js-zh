<html><head></head><body>
		<div><h1 id="_idParaDest-102" class="chapter-number"><a id="_idTextAnchor101"/>6</h1>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Exploring Advanced Geometries</h1>
			<p>In <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, <em class="italic">Learning to Work with Geometries</em>, we showed you all the basic geometries provided by Three.js. Besides these basic geometries, Three.js also offers a set of more advanced and specialized objects.</p>
			<p>In this chapter, we’ll show you these advanced geometries:</p>
			<ul>
				<li>How to use advanced geometries such as <code>THREE.ConvexGeometry</code>, <code>THREE.LatheGeometry</code>, <code>THREE.BoxLineGeometry</code>, <code>THREE.RoundeBoxGeometry</code>, <code>THREE.TeapotGeometry</code>, and <code>THREE.TubeGeometry</code>.</li>
				<li>How to create 3D shapes from 2D shapes using <code>THREE.ExtrudeGeometry</code>. We’ll create a 3D shape from a 2D SVG image, and we will extrude from 2D Three.js shapes to create novel 3D shapes.</li>
				<li>If you want to create custom shapes yourself, you can continue playing with the ones we’ve discussed in the previous chapters. Three.js, however, also offers a <code>THREE.ParametricGeometry</code> object. With parametric geometry, you can create geometry with parameters you can change to effect the shape of the geometry.</li>
				<li>We’ll also show how you can create 3D text effects using <code>THREE.TextGeometry</code>, and show you how to use the Troika library for when you want to add 2D text labels to your scene.</li>
				<li>Additionally, we’ll show you how you can use two helper geometries, <code>THREE.WireframeGeometry</code> and <code>THREE.EdgesGeometry</code>. These helpers allow you to see more details about other geometries.</li>
			</ul>
			<p>We’ll start with the first one from this list, <code>THREE.ConvexGeometry</code>.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Learning advanced geometries</h1>
			<p>In this section, we’ll look at a number of advanced Three.js geometries. We will start with <code>THREE.ConvexGeometry</code>, which you can use to create convex hulls.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>THREE.ConvexGeometry</h2>
			<p>With <code>THREE.ConvexGeometry</code>, we <a id="_idIndexMarker512"/>can create a convex hull from a<a id="_idIndexMarker513"/> set of points. A convex hull is the minimal shape that encompasses all these points. The easiest way to understand this is by looking at an example. If you open up the <code>convex-geometry.html</code> example, you’ll see the convex hull for a random set of points. The following screenshot shows this geometry:</p>
			<div><div><img src="img/Figure_6.1_B18726.jpg" alt="Figure 6.1 – The convex hull encompassing all the points"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The convex hull encompassing all the points</p>
			<p>In this example, we generate a random set of points, and based on these points, we create <code>THREE.ConvexGeometry</code>. In the example, you can use the <code>1</code> to see the points that are used to create this geometry. These points are created as small <code>THREE.SphereGeometry</code> objects for this example.</p>
			<p>To create <code>THREE.ConvexGeometry</code>, we need a set of points. The following code fragment<a id="_idIndexMarker514"/> shows <a id="_idIndexMarker515"/>how we do this:</p>
			<pre class="source-code">
const generatePoints = () =&gt; {
  const spGroup = new THREE.Object3D()
  spGroup.name = 'spGroup'
  const points = []
  for (let i = 0; i &lt; 20; i++) {
    const randomX = -5 + Math.round(Math.random() * 10)
    const randomY = -5 + Math.round(Math.random() * 10)
    const randomZ = -5 + Math.round(Math.random() * 10)
    points.push(new THREE.Vector3(randomX, randomY, randomZ))
  }
  const material = new THREE.MeshBasicMaterial({ color:
    0xff0000, transparent: false })
  points.forEach(function (point) {
    const spGeom = new THREE.SphereGeometry(0.04)
    const spMesh = new THREE.Mesh(spGeom, material)
    spMesh.position.copy(point)
    spGroup.add(spMesh)
  })
  return {
    spGroup,
    points
  }
}</pre>
			<p>As you can see in this snippet of code, we create 20 random points (<code>THREE.Vector3</code>), which we push into an array. Next, we iterate this array and create <code>THREE.SphereGeometry</code>, whose position we set to one of these points (<code>position.copy(point)</code>). All the points are added to a group, so we can easily replace them once we do a redraw. Once you have this set of points, creating a <code>THREE.ConvexGeometry</code> from them is very easy, as shown in the following code snippet:</p>
			<pre class="source-code">
const convexGeometry = new THREE.ConvexGeometry(points);</pre>
			<p>An array containing vertices (of the <code>THREE.Vector3</code> type) is the only argument <code>THREE.ConvexGeometry</code> takes. Note that if you want to render a smooth <code>THREE.ConvexGeometry</code>, you should<a id="_idIndexMarker516"/> call <code>computeVertexNormals</code>, as we explained <a id="_idIndexMarker517"/>in <a href="B18726_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">The Basic Components that Make up a </em><em class="italic">Three.js Application</em>.</p>
			<p>The next complex geometry is <code>THREE.LatheGeometry</code>, which, for example, can be used to create vase-like shapes.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>THREE.LatheGeometry</h2>
			<p><code>THREE.LatheGeometry</code> allows<a id="_idIndexMarker518"/> you to create shapes from a set of points that <a id="_idIndexMarker519"/>together form a curve. If you look at <em class="italic">Figure 6</em><em class="italic">.2</em>, you can see that we created a number of points (the red dots), which Three.js uses to create <code>THREE.LatheGeometry</code>. Once again, the easiest way to understand what <code>THREE.LatheGeometry</code> looks like is by looking at an example. This geometry is shown in <code>lathe-geometry.html</code>. The following screenshot taken from the example shows this geometry:</p>
			<div><div><img src="img/Figure_6.2_B18726.jpg" alt="Figure 6.2 – A lathe for vase-like meshes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – A lathe for vase-like meshes</p>
			<p>In the preceding <a id="_idIndexMarker520"/>screenshot, you can see the points used to create this geometry <a id="_idIndexMarker521"/>as a set of small red spheres. The positions of these points are passed into <code>THREE.LatheGeometry</code>, together with arguments that define the shape of the geometry. Before we look at all the arguments, let’s look at the code used to create the individual points and how <code>THREE.LatheGeometry</code> uses these points:</p>
			<pre class="source-code">
const generatePoints = () =&gt; {
  ...
  const points = []
  const height = 0.4
  const count = 25
  for (let i = 0; i &lt; count; i++) {
    points.push(new THREE.Vector3((Math.sin(i * 0.4) +
      Math.cos(i * 0.4)) * height + 3, i / 6, 0))
  }
  ...
}
// use the same points to create a LatheGeometry
const latheGeometry = new THREE.LatheGeometry (points,
  segments, phiStart, phiLength);
latheMesh = createMesh(latheGeometry);
scene.add(latheMesh);
}</pre>
			<p>In this piece of <a id="_idIndexMarker522"/>JavaScript, we <a id="_idIndexMarker523"/>can see that we generate 25 points whose <em class="italic">x</em> coordinate is based on a combination of sine and cosine functions, while the <em class="italic">y</em> coordinate is based on the <code>i</code> and <code>count</code> variables. This creates a spline visualized by the red dots in the preceding screenshot. Based on these points, we can create <code>THREE.LatheGeometry</code>. Besides the array of vertices, <code>THREE.LatheGeometry</code> takes a couple of other arguments. The following list explains these properties:</p>
			<ul>
				<li><code>points</code>: These are <a id="_idIndexMarker524"/>the points that make up the spline used to generate the bell/vase shape.</li>
				<li><code>segments</code>: These are the number of segments used when creating the shape. The higher this number, the more round and smooth the resulting shape will be. The default value for this is <code>12</code>.</li>
				<li><code>phiStart</code>: This determines where to start on a circle when generating the shape. This can range from <code>0</code> to <code>2*PI</code>. The default value is <code>0</code>.</li>
				<li><code>phiLength</code>: This defines how fully generated the shape is. For instance, a quarter shape will be <code>0.5*PI</code>. The default value is the full 360 degrees or <code>2*PI</code>. This shape will start at the position of the <code>phiStart</code> property.</li>
			</ul>
			<p>In <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, we’ve already seen <code>BoxGeometry</code>. Three.js also provides two other box-like geometries, which we’ll discuss next.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>BoxLineGeometry</h2>
			<p>If you just want<a id="_idIndexMarker525"/> to <a id="_idIndexMarker526"/>show the outline, you can use <code>THREE.BoxLineGeometry</code>. This geometry works exactly like <code>THREE.BoxGeometry</code>, but instead of rendering a solid object, it renders the box using lines like this (from <code>box-line-geometry.html</code>):</p>
			<div><div><img src="img/Figure_6.3_B18726.jpg" alt="Figure 6.3 – A box rendered using lines"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A box rendered using lines</p>
			<p>You use this geometry in the same way as <code>THREE.BoxGeometry</code>, but instead of creating <code>THREE.Mesh</code>, we need to create <code>THREE.LineSegments</code>, using one of the available line-specific materials:</p>
			<pre class="source-code">
import { BoxLineGeometry } from 'three/examples/jsm/
  geometries/BoxLineGeometry'
const material = new THREE.LineBasicMaterial({ color:
  0x000000 }),
const geometry = new BoxLineGeometry(width, height, depth,
  widthSegments, heightSegments, depthSegments)
const lines = new THREE.LineSegments(geometry, material)
scene.add(lines)</pre>
			<p>For an explanation of the properties you can pass into this geometry, refer to the <code>THREE.BoxGeometry</code> section of <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>.</p>
			<p>Three.js also <a id="_idIndexMarker527"/>provides<a id="_idIndexMarker528"/> a slightly more advanced <code>THREE.BoxGeometry</code>, where you can have nicely rounded corners. You can do this with <code>RoundedBoxGeometry</code>.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>THREE.RoundedBoxGeometry</h2>
			<p>This geometry <a id="_idIndexMarker529"/>uses <a id="_idIndexMarker530"/>the same properties as <code>THREE.BoxGeometry</code>, but it also allows you to specify how round the corners should be. In the <code>rounded-box-geometry</code> example, you can see how this looks:</p>
			<div><div><img src="img/Figure_6.4_B18726.jpg" alt="Figure 6.4 – A box with rounded corners"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – A box with rounded corners</p>
			<p>For this geometry, we can specify the dimensions of the box by specifying <code>width</code>, <code>height</code>, and <code>depth</code>. Besides these properties, this geometry provides two additional ones:</p>
			<ul>
				<li><code>radius</code>: This is the <a id="_idIndexMarker531"/>size of the rounded corners. The higher this value, the more rounded the corners will be.</li>
				<li><code>segments</code>: This property defines how detailed the corners will be. If this is set to a low value, Three.js will use fewer vertices for the definition of the rounded corners.</li>
			</ul>
			<p>Before we <a id="_idIndexMarker532"/>move<a id="_idIndexMarker533"/> on to showing how you can create 3D geometries from a 2D object, we’ll look at the final geometry provided by Three.js, <code>TeapotGeometry</code>.</p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>TeapotGeometry</h2>
			<p><code>TeapotGeometry</code> is a <a id="_idIndexMarker534"/>geometry<a id="_idIndexMarker535"/> that you can use to render, not very surprisingly, a teapot. This teapot is a standard reference model for 3D renders and has been used since 1975. More information on the history of this model can be found here: <a href="https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206">https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206</a>.</p>
			<p>Using this model works in exactly the same way as all the other models we’ve seen so far:</p>
			<pre class="source-code">
import { TeapotGeometry } from 'three/examples/jsm/
  geometries/TeapotGeometry'
...
const geom = new TeapotGeometry(size, segments, bottom,
  lid, body, fitLid, blinn)</pre>
			<p>You specify the specific properties and then create the geometry, which you assign to <code>THREE.Mesh</code>. The result, depending on the properties, looks like this (in the <code>teapot-geometry.html</code> example):</p>
			<div><div><img src="img/Figure_6.5_B18726.jpg" alt="Figure 6.5 – The Utah teapot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The Utah teapot</p>
			<p>To configure this <a id="_idIndexMarker536"/>geometry, you<a id="_idIndexMarker537"/> can use the<a id="_idIndexMarker538"/> following properties:</p>
			<ul>
				<li><code>size</code>: This is the size of the teapot.</li>
				<li><code>segments</code>: This defines how many segments are used to create the wireframe of this teapot. The more segments you use, the more smooth the teapot will look.</li>
				<li><code>bottom</code>: If set to <code>true</code>, the bottom of the teapot will be rendered. If <code>false</code>, the bottom won’t be rendered, which you could use when the teapot is located on a surface and there is no need to render the bottom of it.</li>
				<li><code>lid</code>: If set to <code>true</code>, the lid of the teapot will be rendered. If <code>false</code>, the lid won’t be rendered.</li>
				<li><code>body</code>: If set to <code>true</code>, the body of the teapot will be rendered. If <code>false</code>, the body won’t be rendered.</li>
				<li><code>fitLid</code>: If set to <code>true</code>, the lid will exactly fit the teapot. If <code>false</code>, there will be a small space between the lid and the body of the teapot.</li>
				<li><code>blinn</code>: This<a id="_idIndexMarker539"/> defines whether to use the same aspect ratio of the teapot as the original 1975 model<a id="_idIndexMarker540"/> this teapot <a id="_idIndexMarker541"/>is based on.</li>
			</ul>
			<p>In the next sections, we’ll look at an alternative way of creating geometries by extracting a 3D geometry from a 2D shape.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Creating a geometry by extruding a 2D shape</h1>
			<p>Three.js provides <a id="_idIndexMarker542"/>a way in which we can extrude a 2D shape into a 3D shape. By extruding, we mean stretching out a 2D shape along its <em class="italic">z</em> axis to convert it to 3D. For instance, if we extrude <code>THREE.CircleGeometry</code>, we get a shape that looks like a cylinder, and if we extrude <code>THREE.PlaneGeometry</code>, we get a cube-like shape. The most versatile way of extruding a shape is using <code>THREE.ExtrudeGeometry</code>.</p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>THREE.ExtrudeGeometry</h2>
			<p>With <code>THREE.ExtrudeGeometry</code>, you can <a id="_idIndexMarker543"/>create a 3D object from a 2D shape. Before we dive into the details of this geometry, let’s first look at an example, <code>extrude-geometry.html</code>. The following screenshot taken from the example shows this geometry:</p>
			<div><div><img src="img/Figure_6.6_B18726.jpg" alt="Figure 6.6 – Creating a 3D geometry from a 2D shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Creating a 3D geometry from a 2D shape</p>
			<p>In this example, we took the 2D shape <a id="_idIndexMarker544"/>we created in the <em class="italic">2D geometries</em> section in <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, and used <code>THREE.ExtrudeGeometry</code> to convert it to 3D. As you can see in the preceding screenshot, the shape is extruded along the <em class="italic">z</em> axis, which results in a 3D shape. The code to create <code>THREE.ExtrudeGeometry</code> is very easy:</p>
			<pre class="source-code">
const geometry = new THREE.ExtrudeGeometry(drawShape(), {
    curveSegments,
    steps,
    depth,
    bevelEnabled,
    bevelThickness,
    bevelSize,
    bevelOffset,
    bevelSegments,
    amount
  })</pre>
			<p>In this code, we created the shape with the <code>drawShape()</code> function, just as we did in <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>. This shape is passed on to the <code>THREE.ExtrudeGeometry</code> constructor together with a set of properties. With these properties, you can define exactly how the shape should be extruded. The following list explains the options you can pass into <code>THREE.ExtrudeGeometry</code>:</p>
			<ul>
				<li><code>shapes</code>: One or <a id="_idIndexMarker545"/>more shapes (<code>THREE.Shape</code> objects) are required to extrude the geometry. See <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, on how to create such a shape.</li>
				<li><code>depth</code>: This determines how far the shape should be extruded (the depth). The default value is 100.</li>
				<li><code>bevelThickness</code>: This determines the depth of the bevel. The bevel is the rounded corner between the front and back faces and the extrusion. This value defines how deep into the shape the bevel goes. The default value is <code>6</code>.</li>
				<li><code>bevelSize</code>: This determines<a id="_idIndexMarker546"/> the height of the bevel. This is added to the normal height of the shape. The default value is <code>bevelThickness - </code><code>2</code>.</li>
				<li><code>bevelSegments</code>: This defines the number of segments that will be used by the bevel. The more the number of segments used, the smoother the bevel will look. The default value is <code>3</code>. Note that if you add more segments, you’re also increasing the vertex count, which could have an adverse effect on performance.</li>
				<li><code>bevelEnabled</code>: If this is set to <code>true</code>, a bevel is added. The default value is <code>true</code>.</li>
				<li><code>bevelOffset</code>: The distance from the outline of the shape where the bevel starts. The default value is <code>0</code>.</li>
				<li><code>curveSegments</code>: This determines how many segments will be used when extruding the curves of shapes. The higher the number of segments used, the smoother the curves will look. The default value is <code>12</code>.</li>
				<li><code>steps</code>: This defines the number of segments the shape will be divided into along the extrusion depth. The default value is <code>1</code>, which means it will have a single segment along its depth, without unnecessary additional vertices.</li>
				<li><code>extrudePath</code>: This is the path (<code>THREE.CurvePath</code>) along which the shape should be extruded. If this isn’t specified, the shape is extruded along the <em class="italic">z</em> axis. Note that if you’ve got a curving path, you also need to make sure to set a higher value for the <code>steps</code> property so that it can follow the curve accurately.</li>
				<li><code>uvGenerator</code>: When you use a texture with your material, the UV mapping determines what part of a texture is used for a specific face. With the <code>uvGenerator</code> property, you can pass in your own object, which will create the UV settings for <a id="_idIndexMarker547"/>the faces that are created for the passed-in shapes. More information on UV settings can be found in <a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working with Textures</em>. If nothing is specified, <code>THREE.ExtrudeGeometry.WorldUVGenerator</code> is used.</li>
			</ul>
			<p>If you want to use a different material for the faces and the sides, you can pass in an array of materials to <code>THREE.Mesh</code>. The first material passed in will be applied to the face, and the second material will be used for the <a id="_idIndexMarker548"/>sides. You can experiment with these options using the menu from the <code>extrude-geometry.html</code> example. In this example, we extruded the shape along its <em class="italic">z</em> axis. As you can see in the options listed earlier in this section, you can also extrude a shape along a path with the <code>extrudePath</code> option. In the following geometry, <code>THREE.TubeGeometry</code>, we’ll do just that.</p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>THREE.TubeGeometry</h2>
			<p><code>THREE.TubeGeometry</code> creates a tube that extrudes<a id="_idIndexMarker549"/> along a 3D spline. You specify the path using a number of vertices, and <code>THREE.TubeGeometry</code> will create the tube. An example that you can experiment with can be found in the sources for this chapter (<code>tube-geometry.html</code>). The following screenshot shows this example:</p>
			<div><div><img src="img/Figure_6.7_B18726.jpg" alt="Figure 6.7 – TubeGeometry based on random 3D vertices"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – TubeGeometry based on random 3D vertices</p>
			<p>As you can see<a id="_idIndexMarker550"/> in this example, we generate a number of random points and use those points to draw the tube. With the controls in the menu, we can define how the tube looks. The code needed to create a tube is very simple, as follows:</p>
			<pre class="source-code">
const points = ... // array of THREE.Vector3 objects
const tubeGeometry = new TubeGeometry(
  new THREE.CatmullRomCurve3(points),
  tubularSegments,
  radius,
  radiusSegments,
  closed
)</pre>
			<p>What we need to do first is get a set of vertices (the <code>points</code> variable) of the <code>THREE.Vector3</code> type, just like we did for <code>THREE.ConvexGeometry</code> and <code>THREE.LatheGeometry</code>. Before we can use these points, however, to create the tube, we first need to convert these points to <code>THREE.Curve</code>. In other words, we need to define a smooth curve through the points we defined. We can do this simply by passing in the array of vertices to the constructor of <code>THREE.CatmullRomCurve3</code>, or any of the other <code>Curve</code> implementations provided by Three.js. With this curve and the other arguments (which we’ll explain in this section), we can create the tube and add it to the scene.</p>
			<p>In this example, we’ve used <code>THREE.CatmullRomCurve3</code>. Three.js provides a number of other curves you can use as well that take slightly different arguments, but they can be used to create different curve implementations. Out of the box, Three.js comes with <a id="_idIndexMarker551"/>the following curves: <code>ArcCurve</code>, <code>CatmullRomCurve3</code>,<code>CubicBezierCurve</code>,<code>Cub</code><code> </code><code>icBezierCurve3</code>,<code>EllipseCurve</code>,<code>LineCurve</code>,<code>LineCurve3</code>,<code>QuadraticBezierCurve</code>, <code>QuadraticBezierCurve3</code>, and <code>SplineCurve</code>.</p>
			<p><code>THREE.TubeGeometry</code> takes some other arguments besides the curve. The following lists all the arguments for <code>THREE.TubeGeometry</code>:</p>
			<ul>
				<li><code>path</code>: This is <code>THREE.SplineCurve3</code>, which<a id="_idIndexMarker552"/> describes the path this tube should follow.</li>
				<li><code>tubularSegments</code>: These are the segments used to build up the tube. The default value is <code>64</code>. The longer the path, the more segments you should specify.</li>
				<li><code>radius</code>: This is the radius of the tube. The default value is <code>1</code>.</li>
				<li><code>radiusSegments</code>: This is the number of segments to be used along the length of the tube. The default value is <code>8</code>. The more you use, the more round the tube will look.</li>
				<li><code>closed</code>: If this is set to <code>true</code>, the start and the end of the tube will be connected. The default value is <code>false</code>.</li>
			</ul>
			<p>The last extrude example we’ll show in this chapter isn’t really a different type of geometry, but we’ll use <code>THREE.ExtrudeGeometry</code> to create <a id="_idIndexMarker553"/>extrusions from an SVG image.</p>
			<p class="callout-heading">What is SVG?</p>
			<p class="callout">SVG is an XML-based <a id="_idIndexMarker554"/>standard that can be used to create vector-based 2D images for the web. This is an open standard that is supported by all modern browsers. Directly working with SVG and manipulating it from JavaScript, however, isn’t very straightforward. Luckily, there are a couple of open source JavaScript libraries that make working with SVG a lot easier. <code>Paper.js</code>, <code>Snap.js</code>, <code>D3.js</code>, and <code>Raphael.js</code> are some of the best. If you want a graphical editor, you can also use the open source Inkscape product.</p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Extruding 3D shapes from an SVG element</h2>
			<p>When we<a id="_idIndexMarker555"/> discussed <code>THREE.ShapeGeometry</code> in <a href="B18726_05.xhtml#_idTextAnchor081"><em class="italic">Chapter 5</em></a>, we <a id="_idIndexMarker556"/>mentioned that SVG follows pretty much the same approach to drawing shapes. In this section, we’ll look at how you can use SVG images together with <code>THREE.SVGLoader</code> to extrude SVG images. We’ll use the Batman logo as an example:</p>
			<div><div><img src="img/Figure_6.8_B18726.jpg" alt="Figure 6.8 – The Batman SVG base image"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The Batman SVG base image</p>
			<p>First, let’s look at what the original <a id="_idIndexMarker557"/>SVG <a id="_idIndexMarker558"/>code looks like (you can also see this for yourself when looking at the source code of the <code>assets/svg/batman.svg</code> file):</p>
			<pre class="source-code">
&lt;svg version="1.0" xmlns="http://www.w3.org/2000/svg"   xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1152px" height="1152px" xml:space="preserve"&gt;
  &lt;g&gt;
    &lt;path   id="batman-path" style="fill:rgb(0,0,0);" d="M 261.135 114.535 C 254.906 116.662 247.491 118.825 244.659 119.344 C
    229.433 122.131 177.907 142.565 151.973 156.101 C   111.417
    177.269 78.9808 203.399 49.2992 238.815 C 41.0479   248.66
    26.5057 277.248 21.0148 294.418 C 14.873 313.624    15.3588
    357.341 21.9304 376.806 C 29.244 398.469 39.6107    416.935
    52.0865 430.524 C 58.2431 437.23 63.3085 443.321    63.3431
    444.06 ... 261.135 114.535 "/&gt;
  &lt;/g&gt;
&lt;/svg&gt;</pre>
			<p>Unless you’re an SVG guru, this <a id="_idIndexMarker559"/>probably <a id="_idIndexMarker560"/>won’t mean too much to you. Basically though, what you see here is a set of drawing instructions. For instance, <code>C 277.987 119.348 279.673 116.786 279.673 115.867</code> tells the browser to draw a cubic Bezier curve, and <code>L 489.242 111.787</code> tells us that we should draw a line to that specific position. Luckily though, we won’t have to write the code to interpret this ourselves and can use <code>THREE.SVGLoader</code> instead, as you can see in the following code:</p>
			<pre class="source-code">
// returns a promise
const batmanShapesPromise = new SVGLoader().loadAsync('/assets/svg/batman.svg')
// when promise resolves the svg will contain the shapes
batmanShapes.then((svg) =&gt; {
  const shapes = SVGLoader.createShapes(svg.paths[0])
  // based on the shapes we can create an extrude geometry
    as we've seen earlier
  const geometry = new THREE.ExtrudeGeometry(shapes, {
    curveSegments,
    steps,
    depth,
    bevelEnabled,
    bevelThickness,
    bevelSize,
    bevelOffset,
    bevelSegments,
    amount
  })
  ...
}</pre>
			<p>In this code<a id="_idIndexMarker561"/> fragment, you can<a id="_idIndexMarker562"/> see that we use <code>SVGLoader</code> to load the SVG file. We use <code>loadAsync</code> here, which will return a JavaScript <code>Promise</code>. When that <code>Promise</code> resolves, we get access to the loaded <code>svg</code> data. This data can contain a list of <code>path</code> elements, each representing the <code>path</code> element of the original SVG. In our example, we’ve only got one, so we use <code>svg.paths[0]</code> and pass it into <code>SVGLoader.createShapes</code> to convert it into an array of <code>THREE.Shape</code> objects. Now that we’ve got the shapes, we can use the same approach we used earlier when we extruded our custom-created 2D geometry and use <code>THREE.ExtrudeGeometry</code> to create a 3D model from the 2D-loaded SVG shapes.</p>
			<p>The final result can be seen when you open the <code>extrude-svg.html</code> example in the browser:</p>
			<div><div><img src="img/Figure_6.9_B18726.jpg" alt="Figure 6.9 – A 3D-created Batman logo extruded from a 2D SVG image"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – A 3D-created Batman logo extruded from a 2D SVG image</p>
			<p>The last geometry we’ll discuss in<a id="_idIndexMarker563"/> this<a id="_idIndexMarker564"/> section is <code>THREE.ParametricGeometry</code>. With this geometry, you can specify a couple of functions that are used to programmatically create geometries.</p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>THREE.ParametricGeometry</h2>
			<p>With <code>THREE.ParametricGeometry</code>, you can<a id="_idIndexMarker565"/> create a geometry based on an equation. Before we dive into our own example, a good thing to start with is to look at the examples already provided by Three.js. When you download the Three.js distribution, you get the <code>examples/js/ParametricGeometries.js</code> file. In this file, you can find a couple of examples of equations you can use together with <code>THREE.ParametricGeometry</code>.</p>
			<p>The most basic example is the function to create a plane:</p>
			<pre class="source-code">
        plane: function ( width, height ) {
            return function ( u, v, target ) {
                const x = u * width;
                const y = 0;
                const z = v * height;
                target.set( x, y, z );
            };
        },</pre>
			<p>This<a id="_idIndexMarker566"/> function is called by <code>THREE.ParametricGeometry</code>. The <code>u</code> and <code>v</code> values will range from <code>0</code> to <code>1</code> and will be called a large number of times, for all the values from <code>0</code> to <code>1</code>. In this example, the <code>u</code> value is used to determine the <code>x</code> coordinate of the vector, and the <code>v</code> value is used to determine the <code>z</code> coordinate. When this is run, you’ll have a basic plane with a width of <code>width</code> and a depth of <code>depth</code>.</p>
			<p>In our example, we do something similar. However, instead of creating a flat plane, we create a wave-like pattern, as you can see in the <code>parametric-geometry.html</code> example. The following screenshot shows this example:</p>
			<div><div><img src="img/Figure_6.10_B18726.jpg" alt="Figure 6.10 – A wave-like plane using a parametric geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – A wave-like plane using a parametric geometry</p>
			<p>To create this shape, we passed the<a id="_idIndexMarker567"/> following function to <code>THREE.ParametricGeometry</code>:</p>
			<pre class="source-code">
const radialWave = (u, v, optionalTarget) =&gt; {
  var result = optionalTarget || new THREE.Vector3()
  var r = 20
  var x = Math.sin(u) * r
  var z = Math.sin(v / 2) * 2 * r + -10
  var y = Math.sin(u * 4 * Math.PI) + Math.cos(v * 2 *
    Math.PI)
  return result.set(x, y, z)
}
const geom = new THREE.ParametricGeometry(radialWave, 120,
  120);</pre>
			<p>As you can see in this example, with a few lines of code, we can create some really interesting geometries. In this example, you can also see the arguments we can pass to <code>THREE.ParametricGeometry</code>:</p>
			<ul>
				<li><code>function</code>: This is the function <a id="_idIndexMarker568"/>that defines the position of each vertex based on the <code>u</code> and <code>v</code> values provided</li>
				<li><code>slices</code>: This defines the number of parts the <code>u</code> value should be divided into</li>
				<li><code>stacks</code>: This defines the number of parts the <code>v</code> value should be divided into</li>
			</ul>
			<p>By changing the function, we can easily <a id="_idIndexMarker569"/>use the exact same approach to render a completely different object:</p>
			<div><div><img src="img/Figure_6.11_B18726.jpg" alt="Figure 6.11 – A Klein bottle rendered using a parametric geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – A Klein bottle rendered using a parametric geometry</p>
			<p>Here’s a final note on how to use the <code>slices</code> and <code>stacks</code> properties before moving on to the next part of this chapter. We mentioned that the <code>u</code> and <code>v</code> properties are passed into the function argument provided and that the values of these two properties range from <code>0</code> to <code>1</code>. With the <code>slices</code> and <code>stacks</code> properties, we can define how often the passed-in function is called. If, for instance, we set <code>slices</code> to <code>5</code> and <code>stacks</code> to <code>4</code>, the function will be called with the following values:</p>
			<pre class="source-code">
u:0/5, v:0/4
u:1/5, v:0/4
u:2/5, v:0/4
u:3/5, v:0/4
u:4/5, v:0/4
u:5/5, v:0/4
u:0/5, v:1/4
u:1/5, v:1/4
...
u:5/5, v:3/4
u:5/5, v:4/4</pre>
			<p>So, the <a id="_idIndexMarker570"/>higher these values are, the more vertices you get to specify and the smoother your created geometry will be. You can use the menu at the right of the <code>parametric-geometry.html</code> example to see this effect.</p>
			<p>For more examples, you can look at the <code>examples/js/ParametricGeometries.js</code> file in the Three.js distribution. This file contains functions to create the following geometries:</p>
			<ul>
				<li>Klein bottle</li>
				<li>Plane</li>
				<li>Flat Mobius strip</li>
				<li>3D Mobius strip</li>
				<li>Tube</li>
				<li>Torus knot</li>
				<li>Sphere</li>
				<li>Plane</li>
			</ul>
			<p>Sometimes, you need to see more details about your geometry, and you don’t care too much about materials and how the mesh will be rendered. If you want to look at the vertices and the faces, or even just the outline, Three.js provides a couple of geometries that can help you with this (besides <a id="_idIndexMarker571"/>enabling the <code>wireframe</code> property of the material you use for the mesh). We’ll explore these in the following section.</p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Geometries you can use for debugging</h1>
			<p>Three.js comes with two helper geometries out of the box that make it easier to see the details or just the outline of a geometry:</p>
			<ul>
				<li><code>THREE.EdgesGeometry</code>, which provides a geometry that only renders the edges of a geometry</li>
				<li><code>THREE.WireFrameGeometry</code>, which renders just the geometry without showing any faces</li>
			</ul>
			<p>First, let’s look at <code>THREE.EdgesGeometry</code>.</p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>THREE.EdgesGeometry</h2>
			<p>With <code>THREE.EdgesGeometry</code>, you<a id="_idIndexMarker572"/> wrap<a id="_idIndexMarker573"/> an existing geometry, which is then rendered by just showing the edges and not the individual vertices and faces. An example of this is shown in the <code>edges-geometry.html</code> example:</p>
			<div><div><img src="img/Figure_6.12_B18726.jpg" alt="Figure 6.12 – EdgesGeometry only showing the edges, not the individual faces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – EdgesGeometry only showing the edges, not the individual faces</p>
			<p>In the previous <a id="_idIndexMarker574"/>screenshot, you can see that <a id="_idIndexMarker575"/>the outline of <code>RoundedBoxGeometry</code> is shown, where we just see the edges. Since <code>RoundedBoxGeometry</code> has smooth corners, those are shown when using <code>THREE.EdgesGeometry</code>.</p>
			<p>To use this geometry, you just wrap an existing geometry like this:</p>
			<pre class="source-code">
const baseGeometry = new RoundedBoxGeometry(3, 3, 3, 10, 0.4)
const edgesGeometry = THREE.EdgesGeometry(baseGeometry, 1.5)
}</pre>
			<p>The only property <code>THREE.EdgesGeometry</code> takes is <code>thresholdAngle</code>. With this property, you can determine when this geometry draws an edge. In <code>edges-geometry.html</code>, you can control this property to see the effect.</p>
			<p>If you’ve got an existing geometry and want to see the wireframe, you can configure a material to show this wireframe:</p>
			<pre class="source-code">
const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true })</pre>
			<p>Three.js<a id="_idIndexMarker576"/> also <a id="_idIndexMarker577"/>provides a different way of using <code>THREE.WireFrameGeometry</code>.</p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>THREE.WireFrameGeometry</h2>
			<p>This geometry <a id="_idIndexMarker578"/>simulates the <a id="_idIndexMarker579"/>behavior you see when you set the <code>wireframe</code> property of a material to <code>true</code>:</p>
			<div><div><img src="img/Figure_6.13_B18726.jpg" alt="Figure 6.13 – Wireframe geometry showing all the individual faces of a geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Wireframe geometry showing all the individual faces of a geometry</p>
			<p>Using this material works in the same way as using <code>THREE.EdgesGeometry</code>:</p>
			<pre class="source-code">
const baseGeometry = new THREE.TorusKnotBufferGeometry(3, 1, 100, 20, 6, 9)
const wireframeGeometry = new THREE.WireframeGeometry(baseGeometry)</pre>
			<p>This geometry doesn’t take any additional properties.</p>
			<p>The last part of<a id="_idIndexMarker580"/> this chapter deals with creating 3D text objects. We’ll show you two different <a id="_idIndexMarker581"/>approaches, one with the <code>THREE.Text</code> object and one where we use an external library.</p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>Creating a 3D text mesh</h1>
			<p>In this section, we’ll have a<a id="_idIndexMarker582"/> quick look at how you can create 3D text. First, we’ll look at how to render text using the fonts provided by Three.js, and how you can use your own fonts for this. Then, we’ll show a quick example of using an external library called Troika (<a href="https://github.com/protectwise/troika">https://github.com/protectwise/troika</a>) that makes it really easy to create labels and 2D text elements and add them to your scene.</p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Rendering text</h2>
			<p>Rendering<a id="_idIndexMarker583"/> text in Three.js is very easy. All you have to do is define the font you want to use and use the same extrude properties we saw when we discussed <code>THREE.ExtrudeGeometry</code>. The following screenshot shows a <code>text-geometry.html</code> example of how to render text in Three.js:</p>
			<div><div><img src="img/Figure_6.14_B18726.jpg" alt="Figure 6.14 – Rendering text in Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Rendering text in Three.js</p>
			<p>The code <a id="_idIndexMarker584"/>required to create this 3D text is as follows:</p>
			<pre class="source-code">
import { FontLoader } from 'three/examples/jsm/
  loaders/FontLoader'
import { TextGeometry } from 'three/examples/jsm/
  geometries/TextGeometry'
...
new FontLoader()
  .loadAsync('/assets/fonts/helvetiker_regular.typeface.json')
  .then((font) =&gt; {
      const textGeom =  new TextGeometry('Some Text', {
          font,
          size,
          height,
          curveSegments,
          bevelEnabled,
          bevelThickness,
          bevelSize,
          bevelOffset,
          bevelSegments,
          amount
    })
    ...
  )</pre>
			<p>In this code fragment, you<a id="_idIndexMarker585"/> can see that we first have to load the font. For this, Three.js provides <code>FontLoader()</code>, where we provide the name of the font to load, just like we did with <code>SVGLoader</code>, where we get back a JavaScript <code>Promise</code>. Once that <code>Promise</code> resolves, we use the loaded font to create <code>TextGeometry</code>.</p>
			<p>The options we can pass into <code>THREE.TextGeometry</code> match those that we can pass into <code>THREE.ExtrudeGeometry</code>:</p>
			<ul>
				<li><code>font</code>: The loaded font to use for the text.</li>
				<li><code>size</code>: This is the size of the text. The default value is <code>100</code>.</li>
				<li><code>height</code>: This is the length (depth) of the extrusion. The default value is <code>50</code>.</li>
				<li><code>curveSegments</code>: This defines the number of segments used when extruding the curves of shapes. The more segments there are, the smoother the curves will look. The default value is <code>4</code>.</li>
				<li><code>bevelEnabled</code>: If this is set to <code>true</code>, a bevel is added. The default value is <code>false</code>.</li>
				<li><code>bevelThickness</code>: This is the depth of the bevel. The bevel is the rounded corner between the front and back faces and the extrusion. The default value is <code>10</code>.</li>
				<li><code>bevelSize</code>: This is the height of the bevel. The default value is <code>8</code>.</li>
				<li><code>bevelSegments</code>: This defines the number of segments that will be used by the bevel. The more segments there are, the smoother the bevel will look. The default value is <code>3</code>.</li>
				<li><code>bevelOffset</code>: This is the distance from the outline of the shape where the bevel starts. The default value is <code>0</code>.</li>
			</ul>
			<p>Since <code>THREE.TextGeometry</code> is also <code>THREE.ExtrudeGeometry</code>, the same approach applies if you want to use a different material for the front and the sides of the material. If you pass in an array of two materials when creating <code>THREE.Mesh</code>, Three.js will<a id="_idIndexMarker586"/> apply the first material to the front and the back of the text, and the second one to the sides.</p>
			<p>It’s also possible to use other fonts with this geometry, but you first need to convert them to JSON – how to do this is shown in the next section.</p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Adding custom fonts</h2>
			<p>There are a couple<a id="_idIndexMarker587"/> of fonts provided by Three.js that you can use in your scenes. These fonts are based on the fonts provided by the <code>TypeFace.js</code> library. <code>TypeFace.js</code> is a library that can convert TrueType and OpenType fonts to JavaScript. The resulting JavaScript file or JSON file can be included in your page, and the font can then be used in Three.js. In older versions, the JavaScript file was used, but in later Three.js versions, Three.js switched to using the JSON file.</p>
			<p>To convert an existing OpenType or TrueType font, you can use the web page at <a href="https://gero3.github.io/facetype.js/">https://gero3.github.io/facetype.js/</a>:</p>
			<div><div><img src="img/Figure_6.15_B18726.jpg" alt="Figure 6.15 – Converting a font to a typeface-supported format"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Converting a font to a typeface-supported format</p>
			<p>On this page, you <a id="_idIndexMarker588"/>can upload a font, and it will be converted to JSON for you. Note that this won’t work so well for all types of fonts. The simpler the font (more straight lines), the better the chance that it will be rendered correctly when used in Three.js. The resulting file looks like this, where each of the characters (or glyphs) is described:</p>
			<pre class="source-code">
{"glyphs":{"¦":{"x_min":359,"x_max":474,"ha":836,"o":"m 474 971 l 474 457 l
359 457 l 359 971 l 474 971 m 474 277 l 474 -237 l 359 -237 l 359 277 l 474
277 "},"Ž":{"x_min":106,"x_max":793,"ha":836,"o":"m 121 1013 l 778 1013 l
778 908 l 249 115 l 793 115 l 793 0 l 106 0 l 106 104 l 620 898 l 121 898 l
121 1013 m 353 1109 l 211 1289 l 305 1289 l 417 1168 l 530 1289 l 625 1289
l 482 1109 l 353 1109 "},"Á":{"x_min":25,"x_max":811,"ha":836,"o":"m 417
892 l 27 ....</pre>
			<p>Once you’ve got the JSON file, you can use <code>FontLoader</code> (as we showed previously in the <em class="italic">Rendering text</em> section) to load this font and assign it to the <code>font</code> property of the options you can <a id="_idIndexMarker589"/>pass into <code>TextGeometry</code>.</p>
			<p>For the final example of this chapter, we’re going to look at a different way to create text with Three.js.</p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Creating text using the Troika library</h2>
			<p>If you want<a id="_idIndexMarker590"/> to create labels or 2D text marks for<a id="_idIndexMarker591"/> certain parts of your scene, there is an alternative option to using the <code>THREE.Text</code> geometry. You can also use an external library called Troika: <a href="https://github.com/protectwise/troika">https://github.com/protectwise/troika</a>.</p>
			<p>This is a fairly big library that provides lots of functionalities to add interactivity to your scenes. For this example, we’ll only look at the text module of that library. An example of what we’re going to create is shown in the <code>troika-text.html</code> example:</p>
			<div><div><img src="img/Figure_6.16_B18726.jpg" alt="Figure 6.16 – Troika text for 2D labels"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Troika text for 2D labels</p>
			<p>To use this library, we first have to install it (if you followed the instructions from <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, you can already use this library): <code>$ yarn add troika-three-text</code>. Once installed, we can import it and use it just like <a id="_idIndexMarker592"/>we do with the rest of the modules <a id="_idIndexMarker593"/>provided by Three.js:</p>
			<pre class="source-code">
import { Text } from 'troika-three-text'
const troikaText = new Text()
troikaText.text = 'Text rendering with Troika!\nGreat for
  2D labels'
troikaText.fontSize = 2
troikaText.position.x = -3
troikaText.color = 0xff00ff
troikaText.sync()
scene.add(troikaText)</pre>
			<p>In the previous code fragment, we showed how you can use Troika to create a simple text element. You only need to call the <code>Text()</code> constructor and set the properties. One thing to keep in <a id="_idIndexMarker594"/>mind, however, is that whenever you <a id="_idIndexMarker595"/>change a property in the <code>Text()</code> object, you have to call <code>troikaText.sync()</code>. That will make sure that the changes are also applied to the model rendered on the screen.</p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Summary</h1>
			<p>We saw a lot in this chapter. We introduced a couple of advanced geometries and showed you how you can create and render text elements with Three.js. We showed you how you can create really beautiful shapes using advanced geometries such as <code>THREE.ConvexGeometry</code>, <code>THREE.TubeGeometry</code>, and <code>THREE.LatheGeometry</code> and how can you experiment with these geometries to get the results you’re looking for. A very nice feature is that we can also convert existing SVG paths to Three.js using <code>THREE.ExtrudeGeometry</code>.</p>
			<p>We’ve also quickly looked at a couple of geometries that are very useful for debugging purposes. <code>THREE.EdgesGeometry</code> shows just the edges of another geometry, and <code>THREE.WireframeGeometry</code> can be used to show the wireframe of some other geometry.</p>
			<p>Finally, if you want to create 3D text, Three.js provides <code>TextGeometry</code>, where you can pass in a font that you want to use. Three.js comes with a couple of fonts, but you can also create your own fonts. However, remember that complex fonts often won’t convert correctly. An alternative to using <code>TextGeometry</code> is using the Troika library, which makes it very easy to create 2D text labels and place them anywhere in the scene.</p>
			<p>Until now, we looked at solid (or wireframe) geometries, where vertices are connected to each other to form faces. In the upcoming chapter, we’ll look at an alternative way of visualizing geometries using something called particles or points. With particles, we don’t render complete geometries — we just render the individual vertices as points in space. This allows you to create great-looking 3D effects that perform well.</p>
		</div>
	</body></html>