<html><head></head><body>
		<div id="_idContainer139">
			<h1 id="_idParaDest-102" class="chapter-number"><a id="_idTextAnchor101"/>6</h1>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Exploring Advanced Geometries</h1>
			<p>In <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, <em class="italic">Learning to Work with Geometries</em>, we showed you all the basic geometries provided by Three.js. Besides these basic geometries, Three.js also offers a set of more advanced and <span class="No-Break">specialized objects.</span></p>
			<p>In this chapter, we’ll show you these <span class="No-Break">advanced geometries:</span></p>
			<ul>
				<li>How to use advanced geometries such as <strong class="source-inline">THREE.ConvexGeometry</strong>, <strong class="source-inline">THREE.LatheGeometry</strong>, <strong class="source-inline">THREE.BoxLineGeometry</strong>, <strong class="source-inline">THREE.RoundeBoxGeometry</strong>, <strong class="source-inline">THREE.TeapotGeometry</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">THREE.TubeGeometry</strong></span><span class="No-Break">.</span></li>
				<li>How to create 3D shapes from 2D shapes using <strong class="source-inline">THREE.ExtrudeGeometry</strong>. We’ll create a 3D shape from a 2D SVG image, and we will extrude from 2D Three.js shapes to create novel <span class="No-Break">3D shapes.</span></li>
				<li>If you want to create custom shapes yourself, you can continue playing with the ones we’ve discussed in the previous chapters. Three.js, however, also offers a <strong class="source-inline">THREE.ParametricGeometry</strong> object. With parametric geometry, you can create geometry with parameters you can change to effect the shape of <span class="No-Break">the geometry.</span></li>
				<li>We’ll also show how you can create 3D text effects using <strong class="source-inline">THREE.TextGeometry</strong>, and show you how to use the Troika library for when you want to add 2D text labels to <span class="No-Break">your scene.</span></li>
				<li>Additionally, we’ll show you how you can use two helper geometries, <strong class="source-inline">THREE.WireframeGeometry</strong> and <strong class="source-inline">THREE.EdgesGeometry</strong>. These helpers allow you to see more details about <span class="No-Break">other geometries.</span></li>
			</ul>
			<p>We’ll start with the first one from this <span class="No-Break">list, </span><span class="No-Break"><strong class="source-inline">THREE.ConvexGeometry</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Learning advanced geometries</h1>
			<p>In this section, we’ll look at a number of advanced Three.js geometries. We will start with <strong class="source-inline">THREE.ConvexGeometry</strong>, which you can use to create <span class="No-Break">convex hulls.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>THREE.ConvexGeometry</h2>
			<p>With <strong class="source-inline">THREE.ConvexGeometry</strong>, we <a id="_idIndexMarker512"/>can create a convex hull from a<a id="_idIndexMarker513"/> set of points. A convex hull is the minimal shape that encompasses all these points. The easiest way to understand this is by looking at an example. If you open up the <strong class="source-inline">convex-geometry.html</strong> example, you’ll see the convex hull for a random set of points. The following screenshot shows <span class="No-Break">this geometry:</span></p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/Figure_6.1_B18726.jpg" alt="Figure 6.1 – The convex hull encompassing all the points"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – The convex hull encompassing all the points</p>
			<p>In this example, we generate a random set of points, and based on these points, we create <strong class="source-inline">THREE.ConvexGeometry</strong>. In the example, you can use the <strong class="bold">redraw</strong> button in the menu on the right, which will generate 20 new points and draw the convex hull. If you try this for yourself, enable the material’s transparency and set the opacity to a level below <strong class="source-inline">1</strong> to see the points that are used to create this geometry. These points are created as small <strong class="source-inline">THREE.SphereGeometry</strong> objects for <span class="No-Break">this example.</span></p>
			<p>To create <strong class="source-inline">THREE.ConvexGeometry</strong>, we need a set of points. The following code fragment<a id="_idIndexMarker514"/> shows <a id="_idIndexMarker515"/>how we <span class="No-Break">do this:</span></p>
			<pre class="source-code">
const generatePoints = () =&gt; {
  const spGroup = new THREE.Object3D()
  spGroup.name = 'spGroup'
  const points = []
  for (let i = 0; i &lt; 20; i++) {
    const randomX = -5 + Math.round(Math.random() * 10)
    const randomY = -5 + Math.round(Math.random() * 10)
    const randomZ = -5 + Math.round(Math.random() * 10)
    points.push(new THREE.Vector3(randomX, randomY, randomZ))
  }
  const material = new THREE.MeshBasicMaterial({ color:
    0xff0000, transparent: false })
  points.forEach(function (point) {
    const spGeom = new THREE.SphereGeometry(0.04)
    const spMesh = new THREE.Mesh(spGeom, material)
    spMesh.position.copy(point)
    spGroup.add(spMesh)
  })
  return {
    spGroup,
    points
  }
}</pre>
			<p>As you can see in this snippet of code, we create 20 random points (<strong class="source-inline">THREE.Vector3</strong>), which we push into an array. Next, we iterate this array and create <strong class="source-inline">THREE.SphereGeometry</strong>, whose position we set to one of these points (<strong class="source-inline">position.copy(point)</strong>). All the points are added to a group, so we can easily replace them once we do a redraw. Once you have this set of points, creating a <strong class="source-inline">THREE.ConvexGeometry</strong> from them is very easy, as shown in the following <span class="No-Break">code snippet:</span></p>
			<pre class="source-code">
const convexGeometry = new THREE.ConvexGeometry(points);</pre>
			<p>An array containing vertices (of the <strong class="source-inline">THREE.Vector3</strong> type) is the only argument <strong class="source-inline">THREE.ConvexGeometry</strong> takes. Note that if you want to render a smooth <strong class="source-inline">THREE.ConvexGeometry</strong>, you should<a id="_idIndexMarker516"/> call <strong class="source-inline">computeVertexNormals</strong>, as we explained <a id="_idIndexMarker517"/>in <a href="B18726_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">The Basic Components that Make up a </em><span class="No-Break"><em class="italic">Three.js Application</em></span><span class="No-Break">.</span></p>
			<p>The next complex geometry is <strong class="source-inline">THREE.LatheGeometry</strong>, which, for example, can be used to create <span class="No-Break">vase-like shapes.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>THREE.LatheGeometry</h2>
			<p><strong class="source-inline">THREE.LatheGeometry</strong> allows<a id="_idIndexMarker518"/> you to create shapes from a set of points that <a id="_idIndexMarker519"/>together form a curve. If you look at <span class="No-Break"><em class="italic">Figure 6</em></span><em class="italic">.2</em>, you can see that we created a number of points (the red dots), which Three.js uses to create <strong class="source-inline">THREE.LatheGeometry</strong>. Once again, the easiest way to understand what <strong class="source-inline">THREE.LatheGeometry</strong> looks like is by looking at an example. This geometry is shown in <strong class="source-inline">lathe-geometry.html</strong>. The following screenshot taken from the example shows <span class="No-Break">this geometry:</span></p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Figure_6.2_B18726.jpg" alt="Figure 6.2 – A lathe for vase-like meshes"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – A lathe for vase-like meshes</p>
			<p>In the preceding <a id="_idIndexMarker520"/>screenshot, you can see the points used to create this geometry <a id="_idIndexMarker521"/>as a set of small red spheres. The positions of these points are passed into <strong class="source-inline">THREE.LatheGeometry</strong>, together with arguments that define the shape of the geometry. Before we look at all the arguments, let’s look at the code used to create the individual points and how <strong class="source-inline">THREE.LatheGeometry</strong> uses <span class="No-Break">these points:</span></p>
			<pre class="source-code">
const generatePoints = () =&gt; {
  ...
  const points = []
  const height = 0.4
  const count = 25
  for (let i = 0; i &lt; count; i++) {
    points.push(new THREE.Vector3((Math.sin(i * 0.4) +
      Math.cos(i * 0.4)) * height + 3, i / 6, 0))
  }
  ...
}
// use the same points to create a LatheGeometry
const latheGeometry = new THREE.LatheGeometry (points,
  segments, phiStart, phiLength);
latheMesh = createMesh(latheGeometry);
scene.add(latheMesh);
}</pre>
			<p>In this piece of <a id="_idIndexMarker522"/>JavaScript, we <a id="_idIndexMarker523"/>can see that we generate 25 points whose <em class="italic">x</em> coordinate is based on a combination of sine and cosine functions, while the <em class="italic">y</em> coordinate is based on the <strong class="source-inline">i</strong> and <strong class="source-inline">count</strong> variables. This creates a spline visualized by the red dots in the preceding screenshot. Based on these points, we can create <strong class="source-inline">THREE.LatheGeometry</strong>. Besides the array of vertices, <strong class="source-inline">THREE.LatheGeometry</strong> takes a couple of other arguments. The following list explains <span class="No-Break">these properties:</span></p>
			<ul>
				<li><strong class="source-inline">points</strong>: These are <a id="_idIndexMarker524"/>the points that make up the spline used to generate the <span class="No-Break">bell/vase shape.</span></li>
				<li><strong class="source-inline">segments</strong>: These are the number of segments used when creating the shape. The higher this number, the more round and smooth the resulting shape will be. The default value for this <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">12</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">phiStart</strong>: This determines where to start on a circle when generating the shape. This can range from <strong class="source-inline">0</strong> to <strong class="source-inline">2*PI</strong>. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">phiLength</strong>: This defines how fully generated the shape is. For instance, a quarter shape will be <strong class="source-inline">0.5*PI</strong>. The default value is the full 360 degrees or <strong class="source-inline">2*PI</strong>. This shape will start at the position of the <span class="No-Break"><strong class="source-inline">phiStart</strong></span><span class="No-Break"> property.</span></li>
			</ul>
			<p>In <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we’ve already seen <strong class="source-inline">BoxGeometry</strong>. Three.js also provides two other box-like geometries, which we’ll <span class="No-Break">discuss next.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>BoxLineGeometry</h2>
			<p>If you just want<a id="_idIndexMarker525"/> to <a id="_idIndexMarker526"/>show the outline, you can use <strong class="source-inline">THREE.BoxLineGeometry</strong>. This geometry works exactly like <strong class="source-inline">THREE.BoxGeometry</strong>, but instead of rendering a solid object, it renders the box using lines like this (<span class="No-Break">from </span><span class="No-Break"><strong class="source-inline">box-line-geometry.html</strong></span><span class="No-Break">):</span></p>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Figure_6.3_B18726.jpg" alt="Figure 6.3 – A box rendered using lines"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – A box rendered using lines</p>
			<p>You use this geometry in the same way as <strong class="source-inline">THREE.BoxGeometry</strong>, but instead of creating <strong class="source-inline">THREE.Mesh</strong>, we need to create <strong class="source-inline">THREE.LineSegments</strong>, using one of the available <span class="No-Break">line-specific materials:</span></p>
			<pre class="source-code">
import { BoxLineGeometry } from 'three/examples/jsm/
  geometries/BoxLineGeometry'
const material = new THREE.LineBasicMaterial({ color:
  0x000000 }),
const geometry = new BoxLineGeometry(width, height, depth,
  widthSegments, heightSegments, depthSegments)
const lines = new THREE.LineSegments(geometry, material)
scene.add(lines)</pre>
			<p>For an explanation of the properties you can pass into this geometry, refer to the <strong class="source-inline">THREE.BoxGeometry</strong> section of <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a><span class="No-Break">.</span></p>
			<p>Three.js also <a id="_idIndexMarker527"/>provides<a id="_idIndexMarker528"/> a slightly more advanced <strong class="source-inline">THREE.BoxGeometry</strong>, where you can have nicely rounded corners. You can do this <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">RoundedBoxGeometry</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor107"/>THREE.RoundedBoxGeometry</h2>
			<p>This geometry <a id="_idIndexMarker529"/>uses <a id="_idIndexMarker530"/>the same properties as <strong class="source-inline">THREE.BoxGeometry</strong>, but it also allows you to specify how round the corners should be. In the <strong class="source-inline">rounded-box-geometry</strong> example, you can see how <span class="No-Break">this looks:</span></p>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/Figure_6.4_B18726.jpg" alt="Figure 6.4 – A box with rounded corners"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.4 – A box with rounded corners</p>
			<p>For this geometry, we can specify the dimensions of the box by specifying <strong class="source-inline">width</strong>, <strong class="source-inline">height</strong>, and <strong class="source-inline">depth</strong>. Besides these properties, this geometry provides two <span class="No-Break">additional ones:</span></p>
			<ul>
				<li><strong class="source-inline">radius</strong>: This is the <a id="_idIndexMarker531"/>size of the rounded corners. The higher this value, the more rounded the corners <span class="No-Break">will be.</span></li>
				<li><strong class="source-inline">segments</strong>: This property defines how detailed the corners will be. If this is set to a low value, Three.js will use fewer vertices for the definition of the <span class="No-Break">rounded corners.</span></li>
			</ul>
			<p>Before we <a id="_idIndexMarker532"/>move<a id="_idIndexMarker533"/> on to showing how you can create 3D geometries from a 2D object, we’ll look at the final geometry provided by <span class="No-Break">Three.js, </span><span class="No-Break"><strong class="source-inline">TeapotGeometry</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-109"><a id="_idTextAnchor108"/>TeapotGeometry</h2>
			<p><strong class="source-inline">TeapotGeometry</strong> is a <a id="_idIndexMarker534"/>geometry<a id="_idIndexMarker535"/> that you can use to render, not very surprisingly, a teapot. This teapot is a standard reference model for 3D renders and has been used since 1975. More information on the history of this model can be found <span class="No-Break">here: </span><a href="https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206"><span class="No-Break">https://www.computerhistory.org/revolution/computer-graphics-music-and-art/15/206</span></a><span class="No-Break">.</span></p>
			<p>Using this model works in exactly the same way as all the other models we’ve seen <span class="No-Break">so far:</span></p>
			<pre class="source-code">
import { TeapotGeometry } from 'three/examples/jsm/
  geometries/TeapotGeometry'
...
const geom = new TeapotGeometry(size, segments, bottom,
  lid, body, fitLid, blinn)</pre>
			<p>You specify the specific properties and then create the geometry, which you assign to <strong class="source-inline">THREE.Mesh</strong>. The result, depending on the properties, looks like this (in the <span class="No-Break"><strong class="source-inline">teapot-geometry.html</strong></span><span class="No-Break"> example):</span></p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/Figure_6.5_B18726.jpg" alt="Figure 6.5 – The Utah teapot"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.5 – The Utah teapot</p>
			<p>To configure this <a id="_idIndexMarker536"/>geometry, you<a id="_idIndexMarker537"/> can use the<a id="_idIndexMarker538"/> <span class="No-Break">following properties:</span></p>
			<ul>
				<li><strong class="source-inline">size</strong>: This is the size of <span class="No-Break">the teapot.</span></li>
				<li><strong class="source-inline">segments</strong>: This defines how many segments are used to create the wireframe of this teapot. The more segments you use, the more smooth the teapot <span class="No-Break">will look.</span></li>
				<li><strong class="source-inline">bottom</strong>: If set to <strong class="source-inline">true</strong>, the bottom of the teapot will be rendered. If <strong class="source-inline">false</strong>, the bottom won’t be rendered, which you could use when the teapot is located on a surface and there is no need to render the bottom <span class="No-Break">of it.</span></li>
				<li><strong class="source-inline">lid</strong>: If set to <strong class="source-inline">true</strong>, the lid of the teapot will be rendered. If <strong class="source-inline">false</strong>, the lid won’t <span class="No-Break">be rendered.</span></li>
				<li><strong class="source-inline">body</strong>: If set to <strong class="source-inline">true</strong>, the body of the teapot will be rendered. If <strong class="source-inline">false</strong>, the body won’t <span class="No-Break">be rendered.</span></li>
				<li><strong class="source-inline">fitLid</strong>: If set to <strong class="source-inline">true</strong>, the lid will exactly fit the teapot. If <strong class="source-inline">false</strong>, there will be a small space between the lid and the body of <span class="No-Break">the teapot.</span></li>
				<li><strong class="source-inline">blinn</strong>: This<a id="_idIndexMarker539"/> defines whether to use the same aspect ratio of the teapot as the original 1975 model<a id="_idIndexMarker540"/> this teapot <a id="_idIndexMarker541"/>is <span class="No-Break">based on.</span></li>
			</ul>
			<p>In the next sections, we’ll look at an alternative way of creating geometries by extracting a 3D geometry from a <span class="No-Break">2D shape.</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Creating a geometry by extruding a 2D shape</h1>
			<p>Three.js provides <a id="_idIndexMarker542"/>a way in which we can extrude a 2D shape into a 3D shape. By extruding, we mean stretching out a 2D shape along its <em class="italic">z</em> axis to convert it to 3D. For instance, if we extrude <strong class="source-inline">THREE.CircleGeometry</strong>, we get a shape that looks like a cylinder, and if we extrude <strong class="source-inline">THREE.PlaneGeometry</strong>, we get a cube-like shape. The most versatile way of extruding a shape is <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">THREE.ExtrudeGeometry</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-111"><a id="_idTextAnchor110"/>THREE.ExtrudeGeometry</h2>
			<p>With <strong class="source-inline">THREE.ExtrudeGeometry</strong>, you can <a id="_idIndexMarker543"/>create a 3D object from a 2D shape. Before we dive into the details of this geometry, let’s first look at an example, <strong class="source-inline">extrude-geometry.html</strong>. The following screenshot taken from the example shows <span class="No-Break">this geometry:</span></p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/Figure_6.6_B18726.jpg" alt="Figure 6.6 – Creating a 3D geometry from a 2D shape"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.6 – Creating a 3D geometry from a 2D shape</p>
			<p>In this example, we took the 2D shape <a id="_idIndexMarker544"/>we created in the <em class="italic">2D geometries</em> section in <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, and used <strong class="source-inline">THREE.ExtrudeGeometry</strong> to convert it to 3D. As you can see in the preceding screenshot, the shape is extruded along the <em class="italic">z</em> axis, which results in a 3D shape. The code to create <strong class="source-inline">THREE.ExtrudeGeometry</strong> is <span class="No-Break">very easy:</span></p>
			<pre class="source-code">
const geometry = new THREE.ExtrudeGeometry(drawShape(), {
    curveSegments,
    steps,
    depth,
    bevelEnabled,
    bevelThickness,
    bevelSize,
    bevelOffset,
    bevelSegments,
    amount
  })</pre>
			<p>In this code, we created the shape with the <strong class="source-inline">drawShape()</strong> function, just as we did in <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>. This shape is passed on to the <strong class="source-inline">THREE.ExtrudeGeometry</strong> constructor together with a set of properties. With these properties, you can define exactly how the shape should be extruded. The following list explains the options you can pass <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">THREE.ExtrudeGeometry</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">shapes</strong>: One or <a id="_idIndexMarker545"/>more shapes (<strong class="source-inline">THREE.Shape</strong> objects) are required to extrude the geometry. See <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, on how to create such <span class="No-Break">a shape.</span></li>
				<li><strong class="source-inline">depth</strong>: This determines how far the shape should be extruded (the depth). The default value <span class="No-Break">is 100.</span></li>
				<li><strong class="source-inline">bevelThickness</strong>: This determines the depth of the bevel. The bevel is the rounded corner between the front and back faces and the extrusion. This value defines how deep into the shape the bevel goes. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">6</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">bevelSize</strong>: This determines<a id="_idIndexMarker546"/> the height of the bevel. This is added to the normal height of the shape. The default value is <strong class="source-inline">bevelThickness - </strong><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">bevelSegments</strong>: This defines the number of segments that will be used by the bevel. The more the number of segments used, the smoother the bevel will look. The default value is <strong class="source-inline">3</strong>. Note that if you add more segments, you’re also increasing the vertex count, which could have an adverse effect <span class="No-Break">on performance.</span></li>
				<li><strong class="source-inline">bevelEnabled</strong>: If this is set to <strong class="source-inline">true</strong>, a bevel is added. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">bevelOffset</strong>: The distance from the outline of the shape where the bevel starts. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">curveSegments</strong>: This determines how many segments will be used when extruding the curves of shapes. The higher the number of segments used, the smoother the curves will look. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">12</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">steps</strong>: This defines the number of segments the shape will be divided into along the extrusion depth. The default value is <strong class="source-inline">1</strong>, which means it will have a single segment along its depth, without unnecessary <span class="No-Break">additional vertices.</span></li>
				<li><strong class="source-inline">extrudePath</strong>: This is the path (<strong class="source-inline">THREE.CurvePath</strong>) along which the shape should be extruded. If this isn’t specified, the shape is extruded along the <em class="italic">z</em> axis. Note that if you’ve got a curving path, you also need to make sure to set a higher value for the <strong class="source-inline">steps</strong> property so that it can follow the <span class="No-Break">curve accurately.</span></li>
				<li><strong class="source-inline">uvGenerator</strong>: When you use a texture with your material, the UV mapping determines what part of a texture is used for a specific face. With the <strong class="source-inline">uvGenerator</strong> property, you can pass in your own object, which will create the UV settings for <a id="_idIndexMarker547"/>the faces that are created for the passed-in shapes. More information on UV settings can be found in <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Loading and Working with Textures</em>. If nothing is specified, <strong class="source-inline">THREE.ExtrudeGeometry.WorldUVGenerator</strong> <span class="No-Break">is used.</span></li>
			</ul>
			<p>If you want to use a different material for the faces and the sides, you can pass in an array of materials to <strong class="source-inline">THREE.Mesh</strong>. The first material passed in will be applied to the face, and the second material will be used for the <a id="_idIndexMarker548"/>sides. You can experiment with these options using the menu from the <strong class="source-inline">extrude-geometry.html</strong> example. In this example, we extruded the shape along its <em class="italic">z</em> axis. As you can see in the options listed earlier in this section, you can also extrude a shape along a path with the <strong class="source-inline">extrudePath</strong> option. In the following geometry, <strong class="source-inline">THREE.TubeGeometry</strong>, we’ll do <span class="No-Break">just that.</span></p>
			<h2 id="_idParaDest-112"><a id="_idTextAnchor111"/>THREE.TubeGeometry</h2>
			<p><strong class="source-inline">THREE.TubeGeometry</strong> creates a tube that extrudes<a id="_idIndexMarker549"/> along a 3D spline. You specify the path using a number of vertices, and <strong class="source-inline">THREE.TubeGeometry</strong> will create the tube. An example that you can experiment with can be found in the sources for this chapter (<strong class="source-inline">tube-geometry.html</strong>). The following screenshot shows <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/Figure_6.7_B18726.jpg" alt="Figure 6.7 – TubeGeometry based on random 3D vertices"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.7 – TubeGeometry based on random 3D vertices</p>
			<p>As you can see<a id="_idIndexMarker550"/> in this example, we generate a number of random points and use those points to draw the tube. With the controls in the menu, we can define how the tube looks. The code needed to create a tube is very simple, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
const points = ... // array of THREE.Vector3 objects
const tubeGeometry = new TubeGeometry(
  new THREE.CatmullRomCurve3(points),
  tubularSegments,
  radius,
  radiusSegments,
  closed
)</pre>
			<p>What we need to do first is get a set of vertices (the <strong class="source-inline">points</strong> variable) of the <strong class="source-inline">THREE.Vector3</strong> type, just like we did for <strong class="source-inline">THREE.ConvexGeometry</strong> and <strong class="source-inline">THREE.LatheGeometry</strong>. Before we can use these points, however, to create the tube, we first need to convert these points to <strong class="source-inline">THREE.Curve</strong>. In other words, we need to define a smooth curve through the points we defined. We can do this simply by passing in the array of vertices to the constructor of <strong class="source-inline">THREE.CatmullRomCurve3</strong>, or any of the other <strong class="source-inline">Curve</strong> implementations provided by Three.js. With this curve and the other arguments (which we’ll explain in this section), we can create the tube and add it to <span class="No-Break">the scene.</span></p>
			<p>In this example, we’ve used <strong class="source-inline">THREE.CatmullRomCurve3</strong>. Three.js provides a number of other curves you can use as well that take slightly different arguments, but they can be used to create different curve implementations. Out of the box, Three.js comes with <a id="_idIndexMarker551"/>the following curves: <span class="No-Break"><strong class="source-inline">ArcCurve</strong></span><span class="No-Break">, </span><span class="No-Break"><strong class="source-inline">CatmullRomCurve3</strong></span><span class="No-Break">,</span><span class="No-Break"><strong class="source-inline">CubicBezierCurve</strong></span><span class="No-Break">,</span><span class="No-Break"><strong class="source-inline">Cub</strong></span><strong class="source-inline"> </strong><span class="No-Break"><strong class="source-inline">icBezierCurve3</strong></span><span class="No-Break">,</span><span class="No-Break"><strong class="source-inline">EllipseCurve</strong></span><span class="No-Break">,</span><span class="No-Break"><strong class="source-inline">LineCurve</strong></span><span class="No-Break">,</span><span class="No-Break"><strong class="source-inline">LineCurve3</strong></span><span class="No-Break">,</span><span class="No-Break"><strong class="source-inline">QuadraticBezierCurve</strong></span><span class="No-Break">,</span> <strong class="source-inline">QuadraticBezierCurve3</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">SplineCurve</strong></span><span class="No-Break">.</span></p>
			<p><strong class="source-inline">THREE.TubeGeometry</strong> takes some other arguments besides the curve. The following lists all the arguments <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">THREE.TubeGeometry</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">path</strong>: This is <strong class="source-inline">THREE.SplineCurve3</strong>, which<a id="_idIndexMarker552"/> describes the path this tube <span class="No-Break">should follow.</span></li>
				<li><strong class="source-inline">tubularSegments</strong>: These are the segments used to build up the tube. The default value is <strong class="source-inline">64</strong>. The longer the path, the more segments you <span class="No-Break">should specify.</span></li>
				<li><strong class="source-inline">radius</strong>: This is the radius of the tube. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">radiusSegments</strong>: This is the number of segments to be used along the length of the tube. The default value is <strong class="source-inline">8</strong>. The more you use, the more round the tube <span class="No-Break">will look.</span></li>
				<li><strong class="source-inline">closed</strong>: If this is set to <strong class="source-inline">true</strong>, the start and the end of the tube will be connected. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>The last extrude example we’ll show in this chapter isn’t really a different type of geometry, but we’ll use <strong class="source-inline">THREE.ExtrudeGeometry</strong> to create <a id="_idIndexMarker553"/>extrusions from an <span class="No-Break">SVG image.</span></p>
			<p class="callout-heading">What is SVG?</p>
			<p class="callout">SVG is an XML-based <a id="_idIndexMarker554"/>standard that can be used to create vector-based 2D images for the web. This is an open standard that is supported by all modern browsers. Directly working with SVG and manipulating it from JavaScript, however, isn’t very straightforward. Luckily, there are a couple of open source JavaScript libraries that make working with SVG a lot easier. <strong class="source-inline">Paper.js</strong>, <strong class="source-inline">Snap.js</strong>, <strong class="source-inline">D3.js</strong>, and <strong class="source-inline">Raphael.js</strong> are some of the best. If you want a graphical editor, you can also use the open source <span class="No-Break">Inkscape product.</span></p>
			<h2 id="_idParaDest-113"><a id="_idTextAnchor112"/>Extruding 3D shapes from an SVG element</h2>
			<p>When we<a id="_idIndexMarker555"/> discussed <strong class="source-inline">THREE.ShapeGeometry</strong> in <a href="B18726_05.xhtml#_idTextAnchor081"><span class="No-Break"><em class="italic">Chapter 5</em></span></a>, we <a id="_idIndexMarker556"/>mentioned that SVG follows pretty much the same approach to drawing shapes. In this section, we’ll look at how you can use SVG images together with <strong class="source-inline">THREE.SVGLoader</strong> to extrude SVG images. We’ll use the Batman logo as <span class="No-Break">an example:</span></p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/Figure_6.8_B18726.jpg" alt="Figure 6.8 – The Batman SVG base image"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.8 – The Batman SVG base image</p>
			<p>First, let’s look at what the original <a id="_idIndexMarker557"/>SVG <a id="_idIndexMarker558"/>code looks like (you can also see this for yourself when looking at the source code of the <span class="No-Break"><strong class="source-inline">assets/svg/batman.svg</strong></span><span class="No-Break"> file):</span></p>
			<pre class="source-code">
&lt;svg version="1.0" xmlns="http://www.w3.org/2000/svg"   xmlns:xlink="http://www.w3.org/1999/xlink" x="0px" y="0px" width="1152px" height="1152px" xml:space="preserve"&gt;
  &lt;g&gt;
    &lt;path   id="batman-path" style="fill:rgb(0,0,0);" d="M 261.135 114.535 C 254.906 116.662 247.491 118.825 244.659 119.344 C
    229.433 122.131 177.907 142.565 151.973 156.101 C   111.417
    177.269 78.9808 203.399 49.2992 238.815 C 41.0479   248.66
    26.5057 277.248 21.0148 294.418 C 14.873 313.624    15.3588
    357.341 21.9304 376.806 C 29.244 398.469 39.6107    416.935
    52.0865 430.524 C 58.2431 437.23 63.3085 443.321    63.3431
    444.06 ... 261.135 114.535 "/&gt;
  &lt;/g&gt;
&lt;/svg&gt;</pre>
			<p>Unless you’re an SVG guru, this <a id="_idIndexMarker559"/>probably <a id="_idIndexMarker560"/>won’t mean too much to you. Basically though, what you see here is a set of drawing instructions. For instance, <strong class="source-inline">C 277.987 119.348 279.673 116.786 279.673 115.867</strong> tells the browser to draw a cubic Bezier curve, and <strong class="source-inline">L 489.242 111.787</strong> tells us that we should draw a line to that specific position. Luckily though, we won’t have to write the code to interpret this ourselves and can use <strong class="source-inline">THREE.SVGLoader</strong> instead, as you can see in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
// returns a promise
const batmanShapesPromise = new SVGLoader().loadAsync('/assets/svg/batman.svg')
// when promise resolves the svg will contain the shapes
batmanShapes.then((svg) =&gt; {
  const shapes = SVGLoader.createShapes(svg.paths[0])
  // based on the shapes we can create an extrude geometry
    as we've seen earlier
  const geometry = new THREE.ExtrudeGeometry(shapes, {
    curveSegments,
    steps,
    depth,
    bevelEnabled,
    bevelThickness,
    bevelSize,
    bevelOffset,
    bevelSegments,
    amount
  })
  ...
}</pre>
			<p>In this code<a id="_idIndexMarker561"/> fragment, you can<a id="_idIndexMarker562"/> see that we use <strong class="source-inline">SVGLoader</strong> to load the SVG file. We use <strong class="source-inline">loadAsync</strong> here, which will return a JavaScript <strong class="source-inline">Promise</strong>. When that <strong class="source-inline">Promise</strong> resolves, we get access to the loaded <strong class="source-inline">svg</strong> data. This data can contain a list of <strong class="source-inline">path</strong> elements, each representing the <strong class="source-inline">path</strong> element of the original SVG. In our example, we’ve only got one, so we use <strong class="source-inline">svg.paths[0]</strong> and pass it into <strong class="source-inline">SVGLoader.createShapes</strong> to convert it into an array of <strong class="source-inline">THREE.Shape</strong> objects. Now that we’ve got the shapes, we can use the same approach we used earlier when we extruded our custom-created 2D geometry and use <strong class="source-inline">THREE.ExtrudeGeometry</strong> to create a 3D model from the 2D-loaded <span class="No-Break">SVG shapes.</span></p>
			<p>The final result can be seen when you open the <strong class="source-inline">extrude-svg.html</strong> example in <span class="No-Break">the browser:</span></p>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/Figure_6.9_B18726.jpg" alt="Figure 6.9 – A 3D-created Batman logo extruded from a 2D SVG image"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.9 – A 3D-created Batman logo extruded from a 2D SVG image</p>
			<p>The last geometry we’ll discuss in<a id="_idIndexMarker563"/> this<a id="_idIndexMarker564"/> section is <strong class="source-inline">THREE.ParametricGeometry</strong>. With this geometry, you can specify a couple of functions that are used to programmatically <span class="No-Break">create geometries.</span></p>
			<h2 id="_idParaDest-114"><a id="_idTextAnchor113"/>THREE.ParametricGeometry</h2>
			<p>With <strong class="source-inline">THREE.ParametricGeometry</strong>, you can<a id="_idIndexMarker565"/> create a geometry based on an equation. Before we dive into our own example, a good thing to start with is to look at the examples already provided by Three.js. When you download the Three.js distribution, you get the <strong class="source-inline">examples/js/ParametricGeometries.js</strong> file. In this file, you can find a couple of examples of equations you can use together <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">THREE.ParametricGeometry</strong></span><span class="No-Break">.</span></p>
			<p>The most basic example is the function to create <span class="No-Break">a plane:</span></p>
			<pre class="source-code">
        plane: function ( width, height ) {
            return function ( u, v, target ) {
                const x = u * width;
                const y = 0;
                const z = v * height;
                target.set( x, y, z );
            };
        },</pre>
			<p>This<a id="_idIndexMarker566"/> function is called by <strong class="source-inline">THREE.ParametricGeometry</strong>. The <strong class="source-inline">u</strong> and <strong class="source-inline">v</strong> values will range from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> and will be called a large number of times, for all the values from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>. In this example, the <strong class="source-inline">u</strong> value is used to determine the <strong class="source-inline">x</strong> coordinate of the vector, and the <strong class="source-inline">v</strong> value is used to determine the <strong class="source-inline">z</strong> coordinate. When this is run, you’ll have a basic plane with a width of <strong class="source-inline">width</strong> and a depth <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">depth</strong></span><span class="No-Break">.</span></p>
			<p>In our example, we do something similar. However, instead of creating a flat plane, we create a wave-like pattern, as you can see in the <strong class="source-inline">parametric-geometry.html</strong> example. The following screenshot shows <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/Figure_6.10_B18726.jpg" alt="Figure 6.10 – A wave-like plane using a parametric geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.10 – A wave-like plane using a parametric geometry</p>
			<p>To create this shape, we passed the<a id="_idIndexMarker567"/> following function <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">THREE.ParametricGeometry</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const radialWave = (u, v, optionalTarget) =&gt; {
  var result = optionalTarget || new THREE.Vector3()
  var r = 20
  var x = Math.sin(u) * r
  var z = Math.sin(v / 2) * 2 * r + -10
  var y = Math.sin(u * 4 * Math.PI) + Math.cos(v * 2 *
    Math.PI)
  return result.set(x, y, z)
}
const geom = new THREE.ParametricGeometry(radialWave, 120,
  120);</pre>
			<p>As you can see in this example, with a few lines of code, we can create some really interesting geometries. In this example, you can also see the arguments we can pass <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">THREE.ParametricGeometry</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">function</strong>: This is the function <a id="_idIndexMarker568"/>that defines the position of each vertex based on the <strong class="source-inline">u</strong> and <strong class="source-inline">v</strong> <span class="No-Break">values provided</span></li>
				<li><strong class="source-inline">slices</strong>: This defines the number of parts the <strong class="source-inline">u</strong> value should be <span class="No-Break">divided into</span></li>
				<li><strong class="source-inline">stacks</strong>: This defines the number of parts the <strong class="source-inline">v</strong> value should be <span class="No-Break">divided into</span></li>
			</ul>
			<p>By changing the function, we can easily <a id="_idIndexMarker569"/>use the exact same approach to render a completely <span class="No-Break">different object:</span></p>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/Figure_6.11_B18726.jpg" alt="Figure 6.11 – A Klein bottle rendered using a parametric geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.11 – A Klein bottle rendered using a parametric geometry</p>
			<p>Here’s a final note on how to use the <strong class="source-inline">slices</strong> and <strong class="source-inline">stacks</strong> properties before moving on to the next part of this chapter. We mentioned that the <strong class="source-inline">u</strong> and <strong class="source-inline">v</strong> properties are passed into the function argument provided and that the values of these two properties range from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>. With the <strong class="source-inline">slices</strong> and <strong class="source-inline">stacks</strong> properties, we can define how often the passed-in function is called. If, for instance, we set <strong class="source-inline">slices</strong> to <strong class="source-inline">5</strong> and <strong class="source-inline">stacks</strong> to <strong class="source-inline">4</strong>, the function will be called with the <span class="No-Break">following values:</span></p>
			<pre class="source-code">
u:0/5, v:0/4
u:1/5, v:0/4
u:2/5, v:0/4
u:3/5, v:0/4
u:4/5, v:0/4
u:5/5, v:0/4
u:0/5, v:1/4
u:1/5, v:1/4
...
u:5/5, v:3/4
u:5/5, v:4/4</pre>
			<p>So, the <a id="_idIndexMarker570"/>higher these values are, the more vertices you get to specify and the smoother your created geometry will be. You can use the menu at the right of the <strong class="source-inline">parametric-geometry.html</strong> example to see <span class="No-Break">this effect.</span></p>
			<p>For more examples, you can look at the <strong class="source-inline">examples/js/ParametricGeometries.js</strong> file in the Three.js distribution. This file contains functions to create the <span class="No-Break">following geometries:</span></p>
			<ul>
				<li><span class="No-Break">Klein bottle</span></li>
				<li><span class="No-Break">Plane</span></li>
				<li>Flat <span class="No-Break">Mobius strip</span></li>
				<li>3D <span class="No-Break">Mobius strip</span></li>
				<li><span class="No-Break">Tube</span></li>
				<li><span class="No-Break">Torus knot</span></li>
				<li><span class="No-Break">Sphere</span></li>
				<li><span class="No-Break">Plane</span></li>
			</ul>
			<p>Sometimes, you need to see more details about your geometry, and you don’t care too much about materials and how the mesh will be rendered. If you want to look at the vertices and the faces, or even just the outline, Three.js provides a couple of geometries that can help you with this (besides <a id="_idIndexMarker571"/>enabling the <strong class="source-inline">wireframe</strong> property of the material you use for the mesh). We’ll explore these in the <span class="No-Break">following section.</span></p>
			<h1 id="_idParaDest-115"><a id="_idTextAnchor114"/>Geometries you can use for debugging</h1>
			<p>Three.js comes with two helper geometries out of the box that make it easier to see the details or just the outline of <span class="No-Break">a geometry:</span></p>
			<ul>
				<li><strong class="source-inline">THREE.EdgesGeometry</strong>, which provides a geometry that only renders the edges of <span class="No-Break">a geometry</span></li>
				<li><strong class="source-inline">THREE.WireFrameGeometry</strong>, which renders just the geometry without showing <span class="No-Break">any faces</span></li>
			</ul>
			<p>First, let’s look <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">THREE.EdgesGeometry</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-116"><a id="_idTextAnchor115"/>THREE.EdgesGeometry</h2>
			<p>With <strong class="source-inline">THREE.EdgesGeometry</strong>, you<a id="_idIndexMarker572"/> wrap<a id="_idIndexMarker573"/> an existing geometry, which is then rendered by just showing the edges and not the individual vertices and faces. An example of this is shown in the <span class="No-Break"><strong class="source-inline">edges-geometry.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/Figure_6.12_B18726.jpg" alt="Figure 6.12 – EdgesGeometry only showing the edges, not the individual faces"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.12 – EdgesGeometry only showing the edges, not the individual faces</p>
			<p>In the previous <a id="_idIndexMarker574"/>screenshot, you can see that <a id="_idIndexMarker575"/>the outline of <strong class="source-inline">RoundedBoxGeometry</strong> is shown, where we just see the edges. Since <strong class="source-inline">RoundedBoxGeometry</strong> has smooth corners, those are shown when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">THREE.EdgesGeometry</strong></span><span class="No-Break">.</span></p>
			<p>To use this geometry, you just wrap an existing geometry <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const baseGeometry = new RoundedBoxGeometry(3, 3, 3, 10, 0.4)
const edgesGeometry = THREE.EdgesGeometry(baseGeometry, 1.5)
}</pre>
			<p>The only property <strong class="source-inline">THREE.EdgesGeometry</strong> takes is <strong class="source-inline">thresholdAngle</strong>. With this property, you can determine when this geometry draws an edge. In <strong class="source-inline">edges-geometry.html</strong>, you can control this property to see <span class="No-Break">the effect.</span></p>
			<p>If you’ve got an existing geometry and want to see the wireframe, you can configure a material to show <span class="No-Break">this wireframe:</span></p>
			<pre class="source-code">
const material = new THREE.MeshBasicMaterial({ color: 0xffff00, wireframe: true })</pre>
			<p>Three.js<a id="_idIndexMarker576"/> also <a id="_idIndexMarker577"/>provides a different way of <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">THREE.WireFrameGeometry</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-117"><a id="_idTextAnchor116"/>THREE.WireFrameGeometry</h2>
			<p>This geometry <a id="_idIndexMarker578"/>simulates the <a id="_idIndexMarker579"/>behavior you see when you set the <strong class="source-inline">wireframe</strong> property of a material <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer135" class="IMG---Figure">
					<img src="image/Figure_6.13_B18726.jpg" alt="Figure 6.13 – Wireframe geometry showing all the individual faces of a geometry"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.13 – Wireframe geometry showing all the individual faces of a geometry</p>
			<p>Using this material works in the same way as <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">THREE.EdgesGeometry</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
const baseGeometry = new THREE.TorusKnotBufferGeometry(3, 1, 100, 20, 6, 9)
const wireframeGeometry = new THREE.WireframeGeometry(baseGeometry)</pre>
			<p>This geometry doesn’t take any <span class="No-Break">additional properties.</span></p>
			<p>The last part of<a id="_idIndexMarker580"/> this chapter deals with creating 3D text objects. We’ll show you two different <a id="_idIndexMarker581"/>approaches, one with the <strong class="source-inline">THREE.Text</strong> object and one where we use an <span class="No-Break">external library.</span></p>
			<h1 id="_idParaDest-118"><a id="_idTextAnchor117"/>Creating a 3D text mesh</h1>
			<p>In this section, we’ll have a<a id="_idIndexMarker582"/> quick look at how you can create 3D text. First, we’ll look at how to render text using the fonts provided by Three.js, and how you can use your own fonts for this. Then, we’ll show a quick example of using an external library called Troika (<a href="https://github.com/protectwise/troika">https://github.com/protectwise/troika</a>) that makes it really easy to create labels and 2D text elements and add them to <span class="No-Break">your scene.</span></p>
			<h2 id="_idParaDest-119"><a id="_idTextAnchor118"/>Rendering text</h2>
			<p>Rendering<a id="_idIndexMarker583"/> text in Three.js is very easy. All you have to do is define the font you want to use and use the same extrude properties we saw when we discussed <strong class="source-inline">THREE.ExtrudeGeometry</strong>. The following screenshot shows a <strong class="source-inline">text-geometry.html</strong> example of how to render text <span class="No-Break">in Three.js:</span></p>
			<div>
				<div id="_idContainer136" class="IMG---Figure">
					<img src="image/Figure_6.14_B18726.jpg" alt="Figure 6.14 – Rendering text in Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.14 – Rendering text in Three.js</p>
			<p>The code <a id="_idIndexMarker584"/>required to create this 3D text is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import { FontLoader } from 'three/examples/jsm/
  loaders/FontLoader'
import { TextGeometry } from 'three/examples/jsm/
  geometries/TextGeometry'
...
new FontLoader()
  .loadAsync('/assets/fonts/helvetiker_regular.typeface.json')
  .then((font) =&gt; {
      const textGeom =  new TextGeometry('Some Text', {
          font,
          size,
          height,
          curveSegments,
          bevelEnabled,
          bevelThickness,
          bevelSize,
          bevelOffset,
          bevelSegments,
          amount
    })
    ...
  )</pre>
			<p>In this code fragment, you<a id="_idIndexMarker585"/> can see that we first have to load the font. For this, Three.js provides <strong class="source-inline">FontLoader()</strong>, where we provide the name of the font to load, just like we did with <strong class="source-inline">SVGLoader</strong>, where we get back a JavaScript <strong class="source-inline">Promise</strong>. Once that <strong class="source-inline">Promise</strong> resolves, we use the loaded font to <span class="No-Break">create </span><span class="No-Break"><strong class="source-inline">TextGeometry</strong></span><span class="No-Break">.</span></p>
			<p>The options we can pass into <strong class="source-inline">THREE.TextGeometry</strong> match those that we can pass <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">THREE.ExtrudeGeometry</strong></span><span class="No-Break">:</span></p>
			<ul>
				<li><strong class="source-inline">font</strong>: The loaded font to use for <span class="No-Break">the text.</span></li>
				<li><strong class="source-inline">size</strong>: This is the size of the text. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">100</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">height</strong>: This is the length (depth) of the extrusion. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">50</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">curveSegments</strong>: This defines the number of segments used when extruding the curves of shapes. The more segments there are, the smoother the curves will look. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">4</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">bevelEnabled</strong>: If this is set to <strong class="source-inline">true</strong>, a bevel is added. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">bevelThickness</strong>: This is the depth of the bevel. The bevel is the rounded corner between the front and back faces and the extrusion. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">10</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">bevelSize</strong>: This is the height of the bevel. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">8</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">bevelSegments</strong>: This defines the number of segments that will be used by the bevel. The more segments there are, the smoother the bevel will look. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">3</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">bevelOffset</strong>: This is the distance from the outline of the shape where the bevel starts. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Since <strong class="source-inline">THREE.TextGeometry</strong> is also <strong class="source-inline">THREE.ExtrudeGeometry</strong>, the same approach applies if you want to use a different material for the front and the sides of the material. If you pass in an array of two materials when creating <strong class="source-inline">THREE.Mesh</strong>, Three.js will<a id="_idIndexMarker586"/> apply the first material to the front and the back of the text, and the second one to <span class="No-Break">the sides.</span></p>
			<p>It’s also possible to use other fonts with this geometry, but you first need to convert them to JSON – how to do this is shown in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-120"><a id="_idTextAnchor119"/>Adding custom fonts</h2>
			<p>There are a couple<a id="_idIndexMarker587"/> of fonts provided by Three.js that you can use in your scenes. These fonts are based on the fonts provided by the <strong class="source-inline">TypeFace.js</strong> library. <strong class="source-inline">TypeFace.js</strong> is a library that can convert TrueType and OpenType fonts to JavaScript. The resulting JavaScript file or JSON file can be included in your page, and the font can then be used in Three.js. In older versions, the JavaScript file was used, but in later Three.js versions, Three.js switched to using the <span class="No-Break">JSON file.</span></p>
			<p>To convert an existing OpenType or TrueType font, you can use the web page <span class="No-Break">at </span><a href="https://gero3.github.io/facetype.js/"><span class="No-Break">https://gero3.github.io/facetype.js/</span></a><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer137" class="IMG---Figure">
					<img src="image/Figure_6.15_B18726.jpg" alt="Figure 6.15 – Converting a font to a typeface-supported format"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.15 – Converting a font to a typeface-supported format</p>
			<p>On this page, you <a id="_idIndexMarker588"/>can upload a font, and it will be converted to JSON for you. Note that this won’t work so well for all types of fonts. The simpler the font (more straight lines), the better the chance that it will be rendered correctly when used in Three.js. The resulting file looks like this, where each of the characters (or glyphs) <span class="No-Break">is described:</span></p>
			<pre class="source-code">
{"glyphs":{"¦":{"x_min":359,"x_max":474,"ha":836,"o":"m 474 971 l 474 457 l
359 457 l 359 971 l 474 971 m 474 277 l 474 -237 l 359 -237 l 359 277 l 474
277 "},"Ž":{"x_min":106,"x_max":793,"ha":836,"o":"m 121 1013 l 778 1013 l
778 908 l 249 115 l 793 115 l 793 0 l 106 0 l 106 104 l 620 898 l 121 898 l
121 1013 m 353 1109 l 211 1289 l 305 1289 l 417 1168 l 530 1289 l 625 1289
l 482 1109 l 353 1109 "},"Á":{"x_min":25,"x_max":811,"ha":836,"o":"m 417
892 l 27 ....</pre>
			<p>Once you’ve got the JSON file, you can use <strong class="source-inline">FontLoader</strong> (as we showed previously in the <em class="italic">Rendering text</em> section) to load this font and assign it to the <strong class="source-inline">font</strong> property of the options you can <a id="_idIndexMarker589"/>pass <span class="No-Break">into </span><span class="No-Break"><strong class="source-inline">TextGeometry</strong></span><span class="No-Break">.</span></p>
			<p>For the final example of this chapter, we’re going to look at a different way to create text <span class="No-Break">with Three.js.</span></p>
			<h2 id="_idParaDest-121"><a id="_idTextAnchor120"/>Creating text using the Troika library</h2>
			<p>If you want<a id="_idIndexMarker590"/> to create labels or 2D text marks for<a id="_idIndexMarker591"/> certain parts of your scene, there is an alternative option to using the <strong class="source-inline">THREE.Text</strong> geometry. You can also use an external library called <span class="No-Break">Troika: </span><a href="https://github.com/protectwise/troika"><span class="No-Break">https://github.com/protectwise/troika</span></a><span class="No-Break">.</span></p>
			<p>This is a fairly big library that provides lots of functionalities to add interactivity to your scenes. For this example, we’ll only look at the text module of that library. An example of what we’re going to create is shown in the <span class="No-Break"><strong class="source-inline">troika-text.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer138" class="IMG---Figure">
					<img src="image/Figure_6.16_B18726.jpg" alt="Figure 6.16 – Troika text for 2D labels"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.16 – Troika text for 2D labels</p>
			<p>To use this library, we first have to install it (if you followed the instructions from <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene with Three.js</em>, you can already use this library): <strong class="source-inline">$ yarn add troika-three-text</strong>. Once installed, we can import it and use it just like <a id="_idIndexMarker592"/>we do with the rest of the modules <a id="_idIndexMarker593"/>provided <span class="No-Break">by Three.js:</span></p>
			<pre class="source-code">
import { Text } from 'troika-three-text'
const troikaText = new Text()
troikaText.text = 'Text rendering with Troika!\nGreat for
  2D labels'
troikaText.fontSize = 2
troikaText.position.x = -3
troikaText.color = 0xff00ff
troikaText.sync()
scene.add(troikaText)</pre>
			<p>In the previous code fragment, we showed how you can use Troika to create a simple text element. You only need to call the <strong class="source-inline">Text()</strong> constructor and set the properties. One thing to keep in <a id="_idIndexMarker594"/>mind, however, is that whenever you <a id="_idIndexMarker595"/>change a property in the <strong class="source-inline">Text()</strong> object, you have to call <strong class="source-inline">troikaText.sync()</strong>. That will make sure that the changes are also applied to the model rendered on <span class="No-Break">the screen.</span></p>
			<h1 id="_idParaDest-122"><a id="_idTextAnchor121"/>Summary</h1>
			<p>We saw a lot in this chapter. We introduced a couple of advanced geometries and showed you how you can create and render text elements with Three.js. We showed you how you can create really beautiful shapes using advanced geometries such as <strong class="source-inline">THREE.ConvexGeometry</strong>, <strong class="source-inline">THREE.TubeGeometry</strong>, and <strong class="source-inline">THREE.LatheGeometry</strong> and how can you experiment with these geometries to get the results you’re looking for. A very nice feature is that we can also convert existing SVG paths to Three.js <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">THREE.ExtrudeGeometry</strong></span><span class="No-Break">.</span></p>
			<p>We’ve also quickly looked at a couple of geometries that are very useful for debugging purposes. <strong class="source-inline">THREE.EdgesGeometry</strong> shows just the edges of another geometry, and <strong class="source-inline">THREE.WireframeGeometry</strong> can be used to show the wireframe of some <span class="No-Break">other geometry.</span></p>
			<p>Finally, if you want to create 3D text, Three.js provides <strong class="source-inline">TextGeometry</strong>, where you can pass in a font that you want to use. Three.js comes with a couple of fonts, but you can also create your own fonts. However, remember that complex fonts often won’t convert correctly. An alternative to using <strong class="source-inline">TextGeometry</strong> is using the Troika library, which makes it very easy to create 2D text labels and place them anywhere in <span class="No-Break">the scene.</span></p>
			<p>Until now, we looked at solid (or wireframe) geometries, where vertices are connected to each other to form faces. In the upcoming chapter, we’ll look at an alternative way of visualizing geometries using something called particles or points. With particles, we don’t render complete geometries — we just render the individual vertices as points in space. This allows you to create great-looking 3D effects that <span class="No-Break">perform well.</span></p>
		</div>
	</body></html>