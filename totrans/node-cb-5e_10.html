<html><head></head><body>
  <div id="_idContainer075">
   <h1 class="chapter-number" id="_idParaDest-311">
    <a id="_idTextAnchor318">
    </a>
    <span class="koboSpan" id="kobo.1.1">
     10
    </span>
   </h1>
   <h1 id="_idParaDest-312">
    <a id="_idTextAnchor319">
    </a>
    <span class="koboSpan" id="kobo.2.1">
     Optimizing Performance
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.3.1">
     Performance optimization is an endless activity.
    </span>
    <span class="koboSpan" id="kobo.3.2">
     Further optimizations can always be made.
    </span>
    <span class="koboSpan" id="kobo.3.3">
     The recipes in this chapter will demonstrate typical performance
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.4.1">
      optimization workflows.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.5.1">
     The performance optimization workflow starts with establishing a baseline.
    </span>
    <span class="koboSpan" id="kobo.5.2">
     Often, this involves benchmarking our application in some way.
    </span>
    <span class="koboSpan" id="kobo.5.3">
     In the case of a web server, this could be measuring how many requests our server can handle per second.
    </span>
    <span class="koboSpan" id="kobo.5.4">
     A baseline measure must be recorded for us to have evidence of any performance improvements that have
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.6.1">
      been made.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.7.1">
     Once the baseline has been determined, the next step is to identify the bottleneck.
    </span>
    <span class="koboSpan" id="kobo.7.2">
     The recipes in this chapter will cover using tools such as flame graphs and memory profilers to help us identify the specific bottlenecks in an application.
    </span>
    <span class="koboSpan" id="kobo.7.3">
     Using these performance tools will ensure that our optimization efforts are invested in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.8.1">
      correct place.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.9.1">
     Identifying a bottleneck is the first step to understanding where the optimization work should begin, and performance tools can help us determine the starting point.
    </span>
    <span class="koboSpan" id="kobo.9.2">
     For instance, a flame graph can identify a specific function responsible for causing the bottleneck.
    </span>
    <span class="koboSpan" id="kobo.9.3">
     After making the necessary optimizations, the changes must be verified by rerunning the initial baseline test.
    </span>
    <span class="koboSpan" id="kobo.9.4">
     This allows us to have numerical evidence supporting whether the optimization has improved the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.10.1">
      application’s performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.11.1">
     This chapter will cover the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.12.1">
      following recipes:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.13.1">
      Benchmarking
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.14.1">
       HTTP requests
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.15.1">
      Interpreting
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.16.1">
       flame graphs
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.17.1">
      Detecting
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.18.1">
       memory leaks
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.19.1">
      Optimizing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.20.1">
       synchronous functions
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.21.1">
      Optimizing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.22.1">
       asynchronous functions
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.23.1">
      Working with
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.24.1">
       worker threads
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-313">
    <a id="_idTextAnchor320">
    </a>
    <span class="koboSpan" id="kobo.25.1">
     Technical requirements
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.26.1">
     You should have the latest version of Node.js 22 installed, as well as access to a terminal.
    </span>
    <span class="koboSpan" id="kobo.26.2">
     You will also need access to an editor and browser of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.27.1">
      your choice.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.28.1">
     The
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.29.1">
      Optimizing synchronous functions
     </span>
    </em>
    <span class="koboSpan" id="kobo.30.1">
     recipe will require the use of MongoDB.
    </span>
    <span class="koboSpan" id="kobo.30.2">
     We’ll be using Docker to provision a containerized MongoDB instance.
    </span>
    <span class="koboSpan" id="kobo.30.3">
     Please refer to
    </span>
    <a href="B19212_07.xhtml#_idTextAnchor212">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.31.1">
        Chapter 7
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.32.1">
     , for detailed technical setup information regarding how to use MongoDB
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.33.1">
      via Docker.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.34.1">
     The code samples that will be used in this chapter can be found in this book’s GitHub repository at
    </span>
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     <span class="koboSpan" id="kobo.35.1">
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     </span>
    </a>
    <span class="koboSpan" id="kobo.36.1">
     , in the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.37.1">
       Chapter10
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.38.1">
      directory.
     </span>
    </span>
   </p>
   <h1 id="_idParaDest-314">
    <a id="_idTextAnchor321">
    </a>
    <span class="koboSpan" id="kobo.39.1">
     Benchmarking HTTP requests
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.40.1">
     As we’ve seen
    </span>
    <a id="_idIndexMarker781">
    </a>
    <span class="koboSpan" id="kobo.41.1">
     throughout this book, HTTP communications are the foundation of many Node.js applications and microservices.
    </span>
    <span class="koboSpan" id="kobo.41.2">
     For these applications, the HTTP requests should be handled as efficiently as possible.
    </span>
    <span class="koboSpan" id="kobo.41.3">
     To be able to optimize, we must first record a baseline measure of our application’s performance.
    </span>
    <span class="koboSpan" id="kobo.41.4">
     Once we’ve recorded the baseline, we’ll be able to determine the impact of our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.42.1">
      optimization efforts.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.43.1">
     To create a baseline, it’s necessary to simulate the load on the application and record how it responds.
    </span>
    <span class="koboSpan" id="kobo.43.2">
     For an HTTP-based application, we must simulate HTTP requests being sent to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.44.1">
      the server.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.45.1">
     In this recipe, we’ll capture a baseline performance measure for an HTTP web server using a tool named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.46.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.47.1">
     (
    </span>
    <a href="https://github.com/mcollina/autocannon">
     <span class="koboSpan" id="kobo.48.1">
      https://github.com/mcollina/autocannon
     </span>
    </a>
    <span class="koboSpan" id="kobo.49.1">
     ), which will simulate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.50.1">
      HTTP requests.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-315">
    <a id="_idTextAnchor322">
    </a>
    <span class="koboSpan" id="kobo.51.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.52.1">
     In this recipe, we’ll be using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.53.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.54.1">
     tool to benchmark an Express.js web server.
    </span>
    <span class="koboSpan" id="kobo.54.2">
     Instead of creating a web server from scratch, we’ll use the Express.js generator to create one.
    </span>
    <span class="koboSpan" id="kobo.54.3">
     The web server will return an HTML page
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.55.1">
      at
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.56.1">
       http://localhost:3000
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.57.1">
      :
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.58.1">
      Enter the following commands to use the Express.js generator to generate a sample
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.59.1">
       web server:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.60.1">$ npx express-generator --no-view benchmarking-http</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.61.1">$ cd benchmarking-http</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.62.1">$ npm install</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.63.1">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.64.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.65.1">
      tool is available on the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.66.1">
       npm
      </span>
     </strong>
     <span class="koboSpan" id="kobo.67.1">
      registry.
     </span>
     <span class="koboSpan" id="kobo.67.2">
      Globally install the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.68.1">
        autocannon
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.69.1">
       module:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.70.1">$ npm install --global autocannon</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.71.1">
     Now that we’ve created a web server to test, we’re ready to start
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.72.1">
      this recipe.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-316">
    <a id="_idTextAnchor323">
    </a>
    <span class="koboSpan" id="kobo.73.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.74.1">
     In this recipe, we’ll learn
    </span>
    <a id="_idIndexMarker782">
    </a>
    <span class="koboSpan" id="kobo.75.1">
     how to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.76.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.77.1">
     tool to benchmark
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.78.1">
      HTTP requests:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.79.1">
      Start the Express.js web server with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.80.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.81.1">$ npm start</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.82.1">
      Navigate to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.83.1">
       http://localhost:3000
      </span>
     </strong>
     <span class="koboSpan" id="kobo.84.1">
      in your browser.
     </span>
     <span class="koboSpan" id="kobo.84.2">
      You should see the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.85.1">
       following output:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer053">
     <span class="koboSpan" id="kobo.86.1">
      <img alt="Figure 10.1 – Browser window showing the “Welcome to Express” web page" src="image/Figure_10.1_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.87.1">
     Figure 10.1 – Browser window showing the “Welcome to Express” web page
    </span>
   </p>
   <ol>
    <li value="3">
     <span class="koboSpan" id="kobo.88.1">
      We’ve confirmed
     </span>
     <a id="_idIndexMarker783">
     </a>
     <span class="koboSpan" id="kobo.89.1">
      our server has started and is responding to requests at
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.90.1">
       http://localhost:3000
      </span>
     </strong>
     <span class="koboSpan" id="kobo.91.1">
      .
     </span>
     <span class="koboSpan" id="kobo.91.2">
      Now, we can use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.92.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.93.1">
      tool to benchmark our HTTP requests.
     </span>
     <span class="koboSpan" id="kobo.93.2">
      Open a new terminal window and enter the following command to run a load test
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.94.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.95.1">
        autocannon
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.96.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.97.1">$ autocannon --connections 100 http://localhost:3000/</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.98.1">
      While the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.99.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.100.1">
      load test is running, switch to the terminal window where you started the web server.
     </span>
     <span class="koboSpan" id="kobo.100.2">
      You should see a mass of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.101.1">
       incoming requests:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer054">
     <span class="koboSpan" id="kobo.102.1">
      <img alt="Figure 10.2 – The Express.js server receiving many HTTP GET requests" src="image/Figure_10.2_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.103.1">
     Figure 10.2 – The Express.js server receiving many HTTP GET requests
    </span>
   </p>
   <ol>
    <li value="5">
     <span class="koboSpan" id="kobo.104.1">
      Switch back to the
     </span>
     <a id="_idIndexMarker784">
     </a>
     <span class="koboSpan" id="kobo.105.1">
      terminal window where you’re running the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.106.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.107.1">
      load test.
     </span>
     <span class="koboSpan" id="kobo.107.2">
      Once the load test is complete, you should see an output similar to the following, detailing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.108.1">
       the results:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer055">
     <span class="koboSpan" id="kobo.109.1">
      <img alt="Figure 10.3 – autocannon results summary" src="image/Figure_10.3_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.110.1">
     Figure 10.3 – autocannon results summary
    </span>
   </p>
   <ol>
    <li value="6">
     <span class="koboSpan" id="kobo.111.1">
      Observe the table of results.
     </span>
     <span class="koboSpan" id="kobo.111.2">
      The first table details the request latency.
     </span>
     <span class="koboSpan" id="kobo.111.3">
      The average was recorded as
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.112.1">
       12.74
      </span>
     </strong>
     <span class="koboSpan" id="kobo.113.1">
      ms.
     </span>
     <span class="koboSpan" id="kobo.113.2">
      The second table details the request volume.
     </span>
     <span class="koboSpan" id="kobo.113.3">
      Here, it was recorded that our server handled an average of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.114.1">
       7,555.2
      </span>
     </strong>
     <span class="koboSpan" id="kobo.115.1">
      requests per second, with an average throughput of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.116.1">
       3.71
      </span>
     </strong>
     <span class="koboSpan" id="kobo.117.1">
      MB
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.118.1">
       per second.
      </span>
     </span>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.119.1">
     With that, we’ve learned
    </span>
    <a id="_idIndexMarker785">
    </a>
    <span class="koboSpan" id="kobo.120.1">
     how to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.121.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.122.1">
     tool to benchmark
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.123.1">
      HTTP requests.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-317">
    <a id="_idTextAnchor324">
    </a>
    <span class="koboSpan" id="kobo.124.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.125.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.126.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.127.1">
     tool is a cross-platform HTTP benchmarking tool written in Node.js and published to the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.128.1">
       npm
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.129.1">
      registry.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.130.1">
     In this recipe, we used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.131.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.132.1">
     to load test our Express.js web server at the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.133.1">
      http://localhost:3000
     </span>
    </strong>
    <span class="koboSpan" id="kobo.134.1">
     endpoint.
    </span>
    <span class="koboSpan" id="kobo.134.2">
     We passed
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.135.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.136.1">
     the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.137.1">
      --connections 100
     </span>
    </strong>
    <span class="koboSpan" id="kobo.138.1">
     flag.
    </span>
    <span class="koboSpan" id="kobo.138.2">
     This flag instructs
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.139.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.140.1">
     to allocate a pool of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.141.1">
      100
     </span>
    </strong>
    <span class="koboSpan" id="kobo.142.1">
     concurrent connections to our server.
    </span>
    <span class="koboSpan" id="kobo.142.2">
     Had we omitted this flag,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.143.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.144.1">
     would have defaulted to allocating
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.145.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.146.1">
     concurrent connections.
    </span>
    <span class="koboSpan" id="kobo.146.2">
     The number of concurrent connections should be altered to best represent the anticipated load on your server so that you can simulate
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.147.1">
      production workloads.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.148.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.149.1">
     This recipe used the full-form command-line flags for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.150.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.151.1">
     for readability.
    </span>
    <span class="koboSpan" id="kobo.151.2">
     However, as with many command-line flags, it’s possible to use an abbreviated form.
    </span>
    <span class="koboSpan" id="kobo.151.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.152.1">
      --connections
     </span>
    </strong>
    <span class="koboSpan" id="kobo.153.1">
     flag can be abbreviated to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.154.1">
      -c
     </span>
    </strong>
    <span class="koboSpan" id="kobo.155.1">
     and the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.156.1">
      --duration
     </span>
    </strong>
    <span class="koboSpan" id="kobo.157.1">
     flag can be abbreviated
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.158.1">
      to
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.159.1">
       -d
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.160.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.161.1">
     Note that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.162.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.163.1">
     defaults to running the load test for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.164.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.165.1">
     seconds, immediately sending a new request on each socket after the previous request has been completed.
    </span>
    <span class="koboSpan" id="kobo.165.2">
     It’s possible to extend the length of the load test using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.166.1">
      --duration
     </span>
    </strong>
    <span class="koboSpan" id="kobo.167.1">
     flag.
    </span>
    <span class="koboSpan" id="kobo.167.2">
     For example, you could use the following command to extend the load test shown in this recipe to
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.168.1">
       20
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.169.1">
      seconds:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.170.1">
$ autocannon --connections 100 --duration 20 http://localhost:3000/</span></pre>
   <p>
    <span class="koboSpan" id="kobo.171.1">
     By default,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.172.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.173.1">
     outputs the data from the load test in two tables.
    </span>
    <span class="koboSpan" id="kobo.173.2">
     The first table details the request latency, while the second table details the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.174.1">
      request volume.
     </span>
    </span>
   </p>
   <p>
    <strong class="bold">
     <span class="koboSpan" id="kobo.175.1">
      Request latency
     </span>
    </strong>
    <span class="koboSpan" id="kobo.176.1">
     is the
    </span>
    <a id="_idIndexMarker786">
    </a>
    <span class="koboSpan" id="kobo.177.1">
     amount of time that’s elapsed
    </span>
    <a id="_idIndexMarker787">
    </a>
    <span class="koboSpan" id="kobo.178.1">
     between when a request is made, and a response is received.
    </span>
    <span class="koboSpan" id="kobo.178.2">
     The request latency table is broken down into various percentiles.
    </span>
    <span class="koboSpan" id="kobo.178.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.179.1">
      2.5%
     </span>
    </strong>
    <span class="koboSpan" id="kobo.180.1">
     percentile records the fastest
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.181.1">
      2.5%
     </span>
    </strong>
    <span class="koboSpan" id="kobo.182.1">
     of requests, whereas the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.183.1">
      99%
     </span>
    </strong>
    <span class="koboSpan" id="kobo.184.1">
     percentile records the slowest
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.185.1">
      1%
     </span>
    </strong>
    <span class="koboSpan" id="kobo.186.1">
     of requests.
    </span>
    <span class="koboSpan" id="kobo.186.2">
     When benchmarking requests, it can be useful to record and consider both the best and worst-case scenarios.
    </span>
    <span class="koboSpan" id="kobo.186.3">
     The latency table also details the average, standard deviation, and maximum recorded latency.
    </span>
    <span class="koboSpan" id="kobo.186.4">
     Generally, the lower the latency,
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.187.1">
      the better.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.188.1">
     The request volume table details the number of requests per second (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.189.1">
      Req/Sec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.190.1">
     ) and the throughput, which is recorded as the number of bytes processed per second (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.191.1">
      Bytes/Sec
     </span>
    </strong>
    <span class="koboSpan" id="kobo.192.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.192.2">
     Again, the results are broken down into percentiles so that the best and worst cases can be interpreted.
    </span>
    <span class="koboSpan" id="kobo.192.3">
     For these two measures, the higher the number, the better, as it indicates more requests were processed by the server in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.193.1">
      given timeframe.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.194.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.195.1">
     For more information about the available
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.196.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.197.1">
     command-line flags, please refer to the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.198.1">
      Usage
     </span>
    </em>
    <span class="koboSpan" id="kobo.199.1">
     documentation on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.200.1">
      GitHub:
     </span>
    </span>
    <a href="https://github.com/mcollina/autocannon#usage">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.201.1">
       https://github.com/mcollina/autocannon#usage
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.202.1">
      .
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-318">
    <a id="_idTextAnchor325">
    </a>
    <span class="koboSpan" id="kobo.203.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.204.1">
     Next, we’ll cover how to use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.205.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.206.1">
     to benchmark HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.207.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.208.1">
     requests.
    </span>
    <span class="koboSpan" id="kobo.208.2">
     We’ll also consider how we
    </span>
    <a id="_idIndexMarker788">
    </a>
    <span class="koboSpan" id="kobo.209.1">
     can best replicate a production environment during our benchmarks and how this can change our latency
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.210.1">
      and throughput.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.211.1">
     Benchmarking HTTP POST requests
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.212.1">
     In this recipe, we
    </span>
    <a id="_idIndexMarker789">
    </a>
    <span class="koboSpan" id="kobo.213.1">
     benchmarked an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.214.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.215.1">
     request.
    </span>
    <span class="koboSpan" id="kobo.215.2">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.216.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.217.1">
     tool provides allows you to send requests using other HTTP methods, such as
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.218.1">
      HTTP
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.219.1">
       POST
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.220.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.221.1">
     Let’s see how we can use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.222.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.223.1">
     to send an HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.224.1">
      POST
     </span>
    </strong>
    <span class="koboSpan" id="kobo.225.1">
     request with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.226.1">
      JSON payload:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.227.1">
      In the same directory (
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.228.1">
       benchmarking-http
      </span>
     </strong>
     <span class="koboSpan" id="kobo.229.1">
      ), create a file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.230.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.231.1">
        post-server.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.232.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.233.1">$ touch post-server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.234.1">
      Now, we need to define an endpoint on an Express.js server that will handle an HTTP
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.235.1">
       POST
      </span>
     </strong>
     <span class="koboSpan" id="kobo.236.1">
      request with a JSON payload.
     </span>
     <span class="koboSpan" id="kobo.236.2">
      Add the following
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.237.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.238.1">
        post-server.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.239.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.240.1">
const express = require('express');
const app = express();
const bodyParser = require('body-parser');
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: false }));
app.post('/', (req, res) =&gt; {
  res.send(req.body);
});
app.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.241.1">
      Now, we need to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.242.1">
       start
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.243.1">
        post-server.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.244.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.245.1">$ node post-server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.246.1">
      In a separate terminal window, enter the following command to load test the HTTP
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.247.1">
       POST
      </span>
     </strong>
     <span class="koboSpan" id="kobo.248.1">
      request.
     </span>
     <span class="koboSpan" id="kobo.248.2">
      Note that we pass
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.249.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.250.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.251.1">
       --method
      </span>
     </strong>
     <span class="koboSpan" id="kobo.252.1">
      ,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.253.1">
       --headers
      </span>
     </strong>
     <span class="koboSpan" id="kobo.254.1">
      , and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.255.1">
       --
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.256.1">
        body
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.257.1">
       flags:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.258.1">$ autocannon --connections 100 --method POST --headers 'content-type=application/json' --body '{ "hello": "world"}' http://localhost:3000/</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.259.1">
       As in the main recipe,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.260.1">
        autocannon
       </span>
      </strong>
      <span class="koboSpan" id="kobo.261.1">
       will run the load test and output a
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.262.1">
        results summary.
       </span>
      </span>
     </p>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.263.1">
     This demonstrates
    </span>
    <a id="_idIndexMarker790">
    </a>
    <span class="koboSpan" id="kobo.264.1">
     how we can use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.265.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.266.1">
     to simulate other HTTP method requests, including requests with
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.267.1">
      a payload.
     </span>
    </span>
   </p>
   <h3>
    <span class="koboSpan" id="kobo.268.1">
     Replicating a production environment
    </span>
   </h3>
   <p>
    <span class="koboSpan" id="kobo.269.1">
     When measuring
    </span>
    <a id="_idIndexMarker791">
    </a>
    <span class="koboSpan" id="kobo.270.1">
     performance, it’s important to replicate the production environment as closely as possible; otherwise, we may produce misleading results.
    </span>
    <span class="koboSpan" id="kobo.270.2">
     The behavior of applications in development and production may differ, which can result in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.271.1">
      performance differences.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.272.1">
     We can use an Express.js-generated application to demonstrate how performance results may differ, depending on the environment we’re
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.273.1">
      running in.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.274.1">
     Use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.275.1">
      express-generator
     </span>
    </strong>
    <span class="koboSpan" id="kobo.276.1">
     to generate an Express.js application in a new directory named
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.277.1">
      benchmarking-views
     </span>
    </strong>
    <span class="koboSpan" id="kobo.278.1">
     .
    </span>
    <span class="koboSpan" id="kobo.278.2">
     For more information on the Express.js generator, please refer to the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.279.1">
      Creating an Express.js web application
     </span>
    </em>
    <span class="koboSpan" id="kobo.280.1">
     recipe in
    </span>
    <a href="B19212_06.xhtml#_idTextAnchor178">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.281.1">
        Chapter 6
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.282.1">
     .
    </span>
    <span class="koboSpan" id="kobo.282.2">
     In this example, we’ll be using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.283.1">
      pug
     </span>
    </strong>
    <span class="koboSpan" id="kobo.284.1">
     view engine to generate a simple
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.285.1">
      HTML page:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.286.1">
      Enter the following command in your terminal to generate
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.287.1">
       the application:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.288.1">$ npx express-generator --views=pug benchmarking-views</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.289.1">$ cd benchmarking-views</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.290.1">$ npm install</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.291.1">
      Start the server with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.292.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.293.1">$ npm start</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.294.1">
      In a new terminal
     </span>
     <a id="_idIndexMarker792">
     </a>
     <span class="koboSpan" id="kobo.295.1">
      window, use
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.296.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.297.1">
      to load
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.298.1">
       test
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.299.1">
        http://localhost:3000
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.300.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.301.1">$ autocannon --connections 100 http://localhost:3000/</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.302.1">
       Once the load test has been completed,
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.303.1">
        autocannon
       </span>
      </strong>
      <span class="koboSpan" id="kobo.304.1">
       will output the load test
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.305.1">
        results summary:
       </span>
      </span>
     </p>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer056">
     <span class="koboSpan" id="kobo.306.1">
      <img alt="Figure 10.4 – autocannon result summary from the development mode run" src="image/Figure_10.4_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.307.1">
     Figure 10.4 – autocannon result summary from the development mode run
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.308.1">
     In this load test, the average number of requests per second was around 1,584, and the average throughput was around 632 kB per second.
    </span>
    <span class="koboSpan" id="kobo.308.2">
     This is considerably slower than the HTTP
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.309.1">
      GET
     </span>
    </strong>
    <span class="koboSpan" id="kobo.310.1">
     request that we benchmarked in the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.311.1">
      main recipe.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.312.1">
     The reason why the requests are slower is that when in development mode, the pug templating engine will reload the template for every request.
    </span>
    <span class="koboSpan" id="kobo.312.2">
     This is useful in development mode because
    </span>
    <a id="_idIndexMarker793">
    </a>
    <span class="koboSpan" id="kobo.313.1">
     changes to the template can be reflected without having to restart the server.
    </span>
    <span class="koboSpan" id="kobo.313.2">
     When the mode is set to production, Express.js will no longer reload the template for every request.
    </span>
    <span class="koboSpan" id="kobo.313.3">
     This will result in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.314.1">
      performance differences.
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.315.1">
      Restart the Express.js server in production mode using the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.316.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.317.1">$ NODE_ENV=production npm start</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.318.1">
      Now, in your other terminal window, rerun the same benchmark test
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.319.1">
       using
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.320.1">
        autocannon
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.321.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.322.1">$ autocannon --connections 100 http://localhost:3000/</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.323.1">
      Compare the output between the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.324.1">
       two runs:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer057">
     <span class="koboSpan" id="kobo.325.1">
      <img alt="Figure 10.5 – autocannon result summary from the production mode run" src="image/Figure_10.5_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.326.1">
     Figure 10.5 – autocannon result summary from the production mode run
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.327.1">
     In the second load test, we can see that the average number of requests per second has increased to approximately
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.328.1">
      8744
     </span>
    </strong>
    <span class="koboSpan" id="kobo.329.1">
     (up from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.330.1">
      1584
     </span>
    </strong>
    <span class="koboSpan" id="kobo.331.1">
     ), and the throughput has increased to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.332.1">
      3.49
     </span>
    </strong>
    <span class="koboSpan" id="kobo.333.1">
     MB per second (up from
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.334.1">
      632
     </span>
    </strong>
    <span class="koboSpan" id="kobo.335.1">
     kB).
    </span>
    <span class="koboSpan" id="kobo.335.2">
     This performance increase is due to the template being cached when in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.336.1">
      production mode.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.337.1">
     This highlights the need
    </span>
    <a id="_idIndexMarker794">
    </a>
    <span class="koboSpan" id="kobo.338.1">
     to benchmark our application in an environment that best represents the expected
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.339.1">
      production environment.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-319">
    <a id="_idTextAnchor326">
    </a>
    <span class="koboSpan" id="kobo.340.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.341.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.342.1">
       Interpreting flame graphs
      </span>
     </em>
     <span class="koboSpan" id="kobo.343.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.344.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.345.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.346.1">
       Detecting memory leaks
      </span>
     </em>
     <span class="koboSpan" id="kobo.347.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.348.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.349.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.350.1">
       Optimizing synchronous functions
      </span>
     </em>
     <span class="koboSpan" id="kobo.351.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.352.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.353.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.354.1">
       Optimizing asynchronous functions
      </span>
     </em>
     <span class="koboSpan" id="kobo.355.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.356.1">
       this chapter
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-320">
    <a id="_idTextAnchor327">
    </a>
    <span class="koboSpan" id="kobo.357.1">
     Interpreting flame graphs
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.358.1">
     A flame graph is a
    </span>
    <a id="_idIndexMarker795">
    </a>
    <span class="koboSpan" id="kobo.359.1">
     visual tool that allows us to identify “hot code paths” within our application.
    </span>
    <span class="koboSpan" id="kobo.359.2">
     The term “hot code path” is used to describe execution paths in the program that consume a relatively large amount of time, which can indicate a bottleneck in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.360.1">
      an application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.361.1">
     Flame graphs provide a visualization of an application’s call stack during execution.
    </span>
    <span class="koboSpan" id="kobo.361.2">
     From this visualization, it’s possible to determine which functions are spending the most time on the CPU while the application
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.362.1">
      is running.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.363.1">
     In this recipe, we’re going to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.364.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.365.1">
     flame graph tool (
    </span>
    <a href="https://github.com/davidmarkclements/0x">
     <span class="koboSpan" id="kobo.366.1">
      https://github.com/davidmarkclements/0x
     </span>
    </a>
    <span class="koboSpan" id="kobo.367.1">
     ) to generate a flame graph for our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.368.1">
      Node.js application.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-321">
    <a id="_idTextAnchor328">
    </a>
    <span class="koboSpan" id="kobo.369.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.370.1">
     We need to create an application that we
    </span>
    <a id="_idIndexMarker796">
    </a>
    <span class="koboSpan" id="kobo.371.1">
     can profile.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.372.1">
      Profiling
     </span>
    </strong>
    <span class="koboSpan" id="kobo.373.1">
     is a type of program analysis that measures how frequently and for how long functions or methods in our program are being used.
    </span>
    <span class="koboSpan" id="kobo.373.2">
     We’ll use the Express.js generator to create a base application.
    </span>
    <span class="koboSpan" id="kobo.373.3">
     Our application will use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.374.1">
      pug
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.375.1">
      view engine:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.376.1">
$ npx express-generator --views=pug flamegraph-app
$ cd flamegraph-app
$ npm install</span></pre>
   <p>
    <span class="koboSpan" id="kobo.377.1">
     Now that we’ve generated an application, we’re ready to start generating a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.378.1">
      flame graph.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-322">
    <a id="_idTextAnchor329">
    </a>
    <span class="koboSpan" id="kobo.379.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.380.1">
     In this recipe, we’ll be using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.381.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.382.1">
     tool to profile our server and generate a flame graph.
    </span>
    <span class="koboSpan" id="kobo.382.2">
     We’ll also need to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.383.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.384.1">
     tool, which we covered in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.385.1">
      Benchmarking HTTP requests
     </span>
    </em>
    <span class="koboSpan" id="kobo.386.1">
     recipe of this chapter, to generate a load on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.387.1">
      our application:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.388.1">
      First, we need to ensure that we have both the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.389.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.390.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.391.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.392.1">
      tools
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.393.1">
       installed globally:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.394.1">$ npm install --global autocannon 0x</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.395.1">
      Now, instead of starting our server with the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.396.1">
       node
      </span>
     </strong>
     <span class="koboSpan" id="kobo.397.1">
      binary, we need to start it with the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.398.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.399.1">
      executable.
     </span>
     <span class="koboSpan" id="kobo.399.2">
      If we
     </span>
     <a id="_idIndexMarker797">
     </a>
     <span class="koboSpan" id="kobo.400.1">
      open the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.401.1">
       package.json
      </span>
     </strong>
     <span class="koboSpan" id="kobo.402.1">
      file, we’ll see that the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.403.1">
       npm start
      </span>
     </strong>
     <span class="koboSpan" id="kobo.404.1">
      script is
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.405.1">
       node ./bin/www
      </span>
     </strong>
     <span class="koboSpan" id="kobo.406.1">
      .
     </span>
     <span class="koboSpan" id="kobo.406.2">
      We need to substitute the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.407.1">
       node
      </span>
     </strong>
     <span class="koboSpan" id="kobo.408.1">
      binary in the terminal command
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.409.1">
       with
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.410.1">
        0x
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.411.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.412.1">$ 0x ./bin/www</span></strong><span class="koboSpan" id="kobo.413.1">
Profiling</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.414.1">
      Now, we need to generate some load on the server.
     </span>
     <span class="koboSpan" id="kobo.414.2">
      In a new terminal window, use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.415.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.416.1">
      benchmarking tool to generate a load by running the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.417.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.418.1">$ autocannon --connections 100 http://localhost:3000</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.419.1">
      Expect to see the following output when the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.420.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.421.1">
      load test has
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.422.1">
       been completed:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer058">
     <span class="koboSpan" id="kobo.423.1">
      <img alt="Figure 10.6 – autocannon result summary" src="image/Figure_10.6_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.424.1">
     Figure 10.6 – autocannon result summary
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.425.1">
     Note that in this load test, our server was handling
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.426.1">
      1512
     </span>
    </strong>
    <span class="koboSpan" id="kobo.427.1">
     requests per second
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.428.1">
      on average.
     </span>
    </span>
   </p>
   <ol>
    <li value="5">
     <span class="koboSpan" id="kobo.429.1">
      Return to the terminal window where the server was started and press
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.430.1">
       Ctrl
      </span>
     </em>
     <span class="koboSpan" id="kobo.431.1">
      +
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.432.1">
       C
      </span>
     </em>
     <span class="koboSpan" id="kobo.433.1">
      .
     </span>
     <span class="koboSpan" id="kobo.433.2">
      This will stop the
     </span>
     <a id="_idIndexMarker798">
     </a>
     <span class="koboSpan" id="kobo.434.1">
      server.
     </span>
     <span class="koboSpan" id="kobo.434.2">
      At this point,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.435.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.436.1">
      will convert the captured stacks into a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.437.1">
       flame graph.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.438.1">
      Expect to see the following output after pressing
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.439.1">
       Ctrl
      </span>
     </em>
     <span class="koboSpan" id="kobo.440.1">
      +
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.441.1">
       C
      </span>
     </em>
     <span class="koboSpan" id="kobo.442.1">
      .
     </span>
     <span class="koboSpan" id="kobo.442.2">
      This output details the location where
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.443.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.444.1">
      has generated the flame graph.
     </span>
     <span class="koboSpan" id="kobo.444.2">
      Observe that the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.445.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.446.1">
      tool has created a directory named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.447.1">
       96552.0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.448.1">
      , where
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.449.1">
       96552
      </span>
     </strong>
     <span class="koboSpan" id="kobo.450.1">
      is the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.451.1">
       process identifier
      </span>
     </strong>
     <span class="koboSpan" id="kobo.452.1">
      (
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.453.1">
       PID
      </span>
     </strong>
     <span class="koboSpan" id="kobo.454.1">
      ) of
     </span>
     <a id="_idIndexMarker799">
     </a>
     <span class="koboSpan" id="kobo.455.1">
      the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.456.1">
       server process:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer059">
     <span class="koboSpan" id="kobo.457.1">
      <img alt="Figure 10.7 – The 0x tool generating a flame graph" src="image/Figure_10.7_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.458.1">
     Figure 10.7 – The 0x tool generating a flame graph
    </span>
   </p>
   <ol>
    <li value="7">
     <span class="koboSpan" id="kobo.459.1">
      Open the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.460.1">
       flamegraph.html
      </span>
     </strong>
     <span class="koboSpan" id="kobo.461.1">
      file that’s been generated in the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.462.1">
       flamegraph-app
      </span>
     </strong>
     <span class="koboSpan" id="kobo.463.1">
      directory with Google Chrome.
     </span>
     <span class="koboSpan" id="kobo.463.2">
      You can do this by copying the path to the flame graph and pasting it into the Google Chrome address bar.
     </span>
     <span class="koboSpan" id="kobo.463.3">
      Expect to see the generated flame graph and
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.464.1">
       some controls.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.465.1">
      Observe that the
     </span>
     <a id="_idIndexMarker800">
     </a>
     <span class="koboSpan" id="kobo.466.1">
      bars in the flame graph are of different shades.
     </span>
     <span class="koboSpan" id="kobo.466.2">
      A darker (redder) shade indicates a hot
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.467.1">
       code path.
      </span>
     </span>
    </li>
   </ol>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.468.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.469.1">
     Each generated flame graph may be slightly different, even when running the same load test.
    </span>
    <span class="koboSpan" id="kobo.469.2">
     The flame graph that’s generated on your device is likely to look different from the output shown in this recipe.
    </span>
    <span class="koboSpan" id="kobo.469.3">
     This is due to the non-deterministic nature of the profiling process, which may have subtle impacts on the flame graph’s output.
    </span>
    <span class="koboSpan" id="kobo.469.4">
     However, generally, the flame graph’s overall results and bottlenecks are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.470.1">
      identified consistently.
     </span>
    </span>
   </p>
   <ol>
    <li value="9">
     <span class="koboSpan" id="kobo.471.1">
      Identify one of the darker frames.
     </span>
     <span class="koboSpan" id="kobo.471.2">
      In the example flame graph, we can see that the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.472.1">
       readFileSync()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.473.1">
      frame method has a darker shade – indicating that that function has spent a relatively large amount of time on
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.474.1">
       the CPU:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer060">
     <span class="koboSpan" id="kobo.475.1">
      <img alt="Figure 10.8 – ﻿An overview of the 0x flame graph highlighting readFileSync() as a hot frame" src="image/Figure_10.8_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.476.1">
     Figure 10.8 – An overview of the 0x flame graph highlighting readFileSync() as a hot frame
    </span>
   </p>
   <ol>
    <li value="10">
     <span class="koboSpan" id="kobo.477.1">
      Click on the
     </span>
     <a id="_idIndexMarker801">
     </a>
     <span class="koboSpan" id="kobo.478.1">
      darker frame.
     </span>
     <span class="koboSpan" id="kobo.478.2">
      If it’s difficult to identify the frame, you can enter
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.479.1">
       readFileSync
      </span>
     </strong>
     <span class="koboSpan" id="kobo.480.1">
      into the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.481.1">
       search
      </span>
     </strong>
     <span class="koboSpan" id="kobo.482.1">
      bar (top right), after which the frame will be highlighted.
     </span>
     <span class="koboSpan" id="kobo.482.2">
      Upon clicking on the frame,
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.483.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.484.1">
      will expand the parent and child stacks of the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.485.1">
       selected frame:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer061">
     <span class="koboSpan" id="kobo.486.1">
      <img alt="Figure 10.9 – ﻿An overview of the 0x flame graph showing a drilled-down view of readFileSync()" src="image/Figure_10.9_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.487.1">
     Figure 10.9 – An overview of the 0x flame graph showing a drilled-down view of readFileSync()
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.488.1">
     From the drilled-down view, we can see the hot code path.
    </span>
    <span class="koboSpan" id="kobo.488.2">
     From the flame graph, we can make an educated guess about which functions it would be worthwhile to invest
    </span>
    <a id="_idIndexMarker802">
    </a>
    <span class="koboSpan" id="kobo.489.1">
     time in optimizing.
    </span>
    <span class="koboSpan" id="kobo.489.2">
     In this case, we can see references to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.490.1">
      handleTemplateCache()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.491.1">
     .
    </span>
    <span class="koboSpan" id="kobo.491.2">
     In the previous recipe,
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.492.1">
      Benchmarking HTTP requests
     </span>
    </em>
    <span class="koboSpan" id="kobo.493.1">
     , we learned how
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.494.1">
      pug
     </span>
    </strong>
    <span class="koboSpan" id="kobo.495.1">
     reloads a template for each request when in development mode.
    </span>
    <span class="koboSpan" id="kobo.495.2">
     This is the cause of this bottleneck.
    </span>
    <span class="koboSpan" id="kobo.495.3">
     Let’s change the application so that it runs in production mode and see what the impact is on the load test results and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.496.1">
      flame graph.
     </span>
    </span>
   </p>
   <ol>
    <li value="11">
     <span class="koboSpan" id="kobo.497.1">
      Restart the Express.js server in production mode with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.498.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.499.1">$ NODE_ENV=production 0x ./bin/www</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.500.1">
      Rerun the load test using the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.501.1">
        autocannon
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.502.1">
       tool:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.503.1">$ autocannon --connections 100 http://localhost:3000</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.504.1">
      From the results of the load test, we can see that our server is handling more requests per second.
     </span>
     <span class="koboSpan" id="kobo.504.2">
      In this run, our load test reported that our server handled an average of around
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.505.1">
       7688
      </span>
     </strong>
     <span class="koboSpan" id="kobo.506.1">
      requests per second, up from around
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.507.1">
       1512
      </span>
     </strong>
     <span class="koboSpan" id="kobo.508.1">
      before we changed the Express.js server so that it runs in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.509.1">
       production mode:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer062">
     <span class="koboSpan" id="kobo.510.1">
      <img alt="Figure 10.10 – autocannon result summary from the production mode run" src="image/Figure_10.10_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.511.1">
     Figure 10.10 – autocannon result summary from the production mode run
    </span>
   </p>
   <ol>
    <li value="14">
     <span class="koboSpan" id="kobo.512.1">
      As before, once
     </span>
     <a id="_idIndexMarker803">
     </a>
     <span class="koboSpan" id="kobo.513.1">
      the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.514.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.515.1">
      load test is complete, stop your server using
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.516.1">
       Ctrl
      </span>
     </em>
     <span class="koboSpan" id="kobo.517.1">
      +
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.518.1">
       C
      </span>
     </em>
     <span class="koboSpan" id="kobo.519.1">
      .
     </span>
     <span class="koboSpan" id="kobo.519.2">
      A new flame graph will be generated.
     </span>
     <span class="koboSpan" id="kobo.519.3">
      Open the new flame graph in your browser and observe that the new flame graph is a different shape from the first.
     </span>
     <span class="koboSpan" id="kobo.519.4">
      Observe that the second flame graph highlights a different set of darker frames.
     </span>
     <span class="koboSpan" id="kobo.519.5">
      This is because we’ve resolved our first bottleneck.
     </span>
     <span class="koboSpan" id="kobo.519.6">
      Hot code paths are relative.
     </span>
     <span class="koboSpan" id="kobo.519.7">
      Despite having increased the performance of our application, the flame graph will identify the next set of hot
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.520.1">
       code paths:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer063">
     <span class="koboSpan" id="kobo.521.1">
      <img alt="Figure 10.11 – ﻿An overview of the 0x flame graph from production mode" src="image/Figure_10.11_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.522.1">
     Figure 10.11 – An overview of the 0x flame graph from production mode
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.523.1">
     With that, we’ve used
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.524.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.525.1">
     to generate a flame graph, which has enabled us to identify a bottleneck in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.526.1">
      our application.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-323">
    <a id="_idTextAnchor330">
    </a>
    <span class="koboSpan" id="kobo.527.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.528.1">
     In this recipe, we
    </span>
    <a id="_idIndexMarker804">
    </a>
    <span class="koboSpan" id="kobo.529.1">
     used the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.530.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.531.1">
     tool to profile and generate a flame graph for our application.
    </span>
    <span class="koboSpan" id="kobo.531.2">
     Our application was a small, generated Express.js web server.
    </span>
    <span class="koboSpan" id="kobo.531.3">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.532.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.533.1">
     tool was used to add load to our web server so that we could produce a flame graph that’s representative of a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.534.1">
      production workload.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.535.1">
     To use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.536.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.537.1">
     tool, we had to start our server with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.538.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.539.1">
     .
    </span>
    <span class="koboSpan" id="kobo.539.2">
     When we start an application with
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.540.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.541.1">
     , two processes
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.542.1">
      are started.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.543.1">
     The first process uses the Node.js binary,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.544.1">
      node
     </span>
    </strong>
    <span class="koboSpan" id="kobo.545.1">
     , to start our program.
    </span>
    <span class="koboSpan" id="kobo.545.2">
     When
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.546.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.547.1">
     starts the node process, it passes the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.548.1">
      --perf-basic-prof
     </span>
    </strong>
    <span class="koboSpan" id="kobo.549.1">
     command-line flag to the process.
    </span>
    <span class="koboSpan" id="kobo.549.2">
     This command-line flag allows C++ V8 function calls to be mapped to the corresponding JavaScript
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.550.1">
      function calls.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.551.1">
     The second process starts the local system’s stack tracing tool.
    </span>
    <span class="koboSpan" id="kobo.551.2">
     On Linux, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.552.1">
      perf
     </span>
    </strong>
    <span class="koboSpan" id="kobo.553.1">
     tool will be invoked, whereas on macOS and SmartOS, the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.554.1">
      dtrace
     </span>
    </strong>
    <span class="koboSpan" id="kobo.555.1">
     tool will be invoked.
    </span>
    <span class="koboSpan" id="kobo.555.2">
     These tools capture the underlying C-level
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.556.1">
      function calls.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.557.1">
     The underlying system stack tracing tool will take samples.
    </span>
    <span class="koboSpan" id="kobo.557.2">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.558.1">
      sample
     </span>
    </strong>
    <span class="koboSpan" id="kobo.559.1">
     is a snapshot of all the functions
    </span>
    <a id="_idIndexMarker805">
    </a>
    <span class="koboSpan" id="kobo.560.1">
     being executed by the CPU at the time the sample was taken, which will also record the parent
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.561.1">
      function calls.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.562.1">
     The sampled stacks are grouped based on the call hierarchy, grouping the parent and child function calls together.
    </span>
    <span class="koboSpan" id="kobo.562.2">
     These groups are what’s known as a
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.563.1">
      flame
     </span>
    </strong>
    <span class="koboSpan" id="kobo.564.1">
     , hence the name
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.565.1">
      flame graph
     </span>
    </strong>
    <span class="koboSpan" id="kobo.566.1">
     .
    </span>
    <span class="koboSpan" id="kobo.566.2">
     The
    </span>
    <a id="_idIndexMarker806">
    </a>
    <span class="koboSpan" id="kobo.567.1">
     same function
    </span>
    <a id="_idIndexMarker807">
    </a>
    <span class="koboSpan" id="kobo.568.1">
     may appear in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.569.1">
      multiple flames.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.570.1">
     Each line in a flame is known as a frame.
    </span>
    <span class="koboSpan" id="kobo.570.2">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.571.1">
      frame
     </span>
    </strong>
    <span class="koboSpan" id="kobo.572.1">
     represents a function call.
    </span>
    <span class="koboSpan" id="kobo.572.2">
     The width of the frame corresponds
    </span>
    <a id="_idIndexMarker808">
    </a>
    <span class="koboSpan" id="kobo.573.1">
     to the amount of time that that function was observed by the profiler on the CPU.
    </span>
    <span class="koboSpan" id="kobo.573.2">
     The time representation of each frame aggregates the time that all child functions take as well, hence the triangular or
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.574.1">
      flame
     </span>
    </em>
    <span class="koboSpan" id="kobo.575.1">
     shape of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.576.1">
      the graph.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.577.1">
     Darker (redder) frames indicate that a function has spent more time at the top of the stack relative to the other functions.
    </span>
    <span class="koboSpan" id="kobo.577.2">
     This means that this function is spending a lot of time on the CPU, which
    </span>
    <a id="_idIndexMarker809">
    </a>
    <span class="koboSpan" id="kobo.578.1">
     indicates a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.579.1">
      potential bottleneck.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.580.1">
     Important note
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.581.1">
     Chrome DevTools can also be used to profile the CPU, which can help identify bottlenecks.
    </span>
    <span class="koboSpan" id="kobo.581.2">
     Using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.582.1">
      --inspect
     </span>
    </strong>
    <span class="koboSpan" id="kobo.583.1">
     command-line flag, the Node.js process can be debugged and profiled using Chrome DevTools.
    </span>
    <span class="koboSpan" id="kobo.583.2">
     Please refer to the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.584.1">
      Debugging with Chrome DevTools
     </span>
    </em>
    <span class="koboSpan" id="kobo.585.1">
     recipe in
    </span>
    <a href="B19212_12.xhtml#_idTextAnchor388">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.586.1">
        Chapter 12
       </span>
      </em>
     </span>
    </a>
    <span class="koboSpan" id="kobo.587.1">
     for more information on using Chrome DevTools to debug a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.588.1">
      Node.js program.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-324">
    <a id="_idTextAnchor331">
    </a>
    <span class="koboSpan" id="kobo.589.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.590.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.591.1">
       Creating an Express.js web application
      </span>
     </em>
     <span class="koboSpan" id="kobo.592.1">
      recipe in
     </span>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.593.1">
         Chapter 6
        </span>
       </em>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.594.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.595.1">
       Benchmarking HTTP requests
      </span>
     </em>
     <span class="koboSpan" id="kobo.596.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.597.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.598.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.599.1">
       Detecting memory leaks
      </span>
     </em>
     <span class="koboSpan" id="kobo.600.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.601.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.602.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.603.1">
       Optimizing synchronous functions
      </span>
     </em>
     <span class="koboSpan" id="kobo.604.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.605.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.606.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.607.1">
       Optimizing asynchronous functions
      </span>
     </em>
     <span class="koboSpan" id="kobo.608.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.609.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.610.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.611.1">
       Debugging with Chrome DevTools
      </span>
     </em>
     <span class="koboSpan" id="kobo.612.1">
      recipe in
     </span>
     <a href="B19212_12.xhtml#_idTextAnchor388">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.613.1">
         Chapter 12
        </span>
       </em>
      </span>
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-325">
    <a id="_idTextAnchor332">
    </a>
    <span class="koboSpan" id="kobo.614.1">
     Detecting memory leaks
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.615.1">
     Memory leaks can
    </span>
    <a id="_idIndexMarker810">
    </a>
    <span class="koboSpan" id="kobo.616.1">
     drastically reduce your application’s performance and can lead to crashes.
    </span>
    <span class="koboSpan" id="kobo.616.2">
     V8 manages objects and dynamic data in its heap, a binary tree-based structure designed to manage parent-child node relationships.
    </span>
    <span class="koboSpan" id="kobo.616.3">
     The V8
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.617.1">
      Garbage Collector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.618.1">
     (
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.619.1">
      GC
     </span>
    </strong>
    <span class="koboSpan" id="kobo.620.1">
     ) is responsible
    </span>
    <a id="_idIndexMarker811">
    </a>
    <span class="koboSpan" id="kobo.621.1">
     for managing the heap.
    </span>
    <span class="koboSpan" id="kobo.621.2">
     It reclaims any memory that is no longer in use – freeing the memory so that it can
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.622.1">
      be reused.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.623.1">
     A memory leak occurs when a block of memory is never reclaimed by the GC and is therefore idle and inefficient.
    </span>
    <span class="koboSpan" id="kobo.623.2">
     This results in pieces of unused memory remaining on the heap.
    </span>
    <span class="koboSpan" id="kobo.623.3">
     The performance of your application can be impacted when many of these unused memory blocks accumulate in the heap.
    </span>
    <span class="koboSpan" id="kobo.623.4">
     In the worst cases, the unused memory could consume all the available heap space, which, in turn, can cause your application
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.624.1">
      to crash.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.625.1">
     In this recipe, we’ll learn how to use Chrome DevTools to profile memory, enabling us to detect and fix
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.626.1">
      memory leaks.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-326">
    <a id="_idTextAnchor333">
    </a>
    <span class="koboSpan" id="kobo.627.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.628.1">
     This recipe will require you to have Chrome DevTools installed, which is integrated into the Google Chrome browser.
    </span>
    <span class="koboSpan" id="kobo.628.2">
     Visit
    </span>
    <a href="https://www.google.com/chrome/">
     <span class="koboSpan" id="kobo.629.1">
      https://www.google.com/chrome/
     </span>
    </a>
    <span class="koboSpan" id="kobo.630.1">
     to download
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.631.1">
      Google Chrome:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.632.1">
      We’ll be using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.633.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.634.1">
      tool to direct load to our application.
     </span>
     <span class="koboSpan" id="kobo.634.2">
      Install
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.635.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.636.1">
      from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.637.1">
       npm
      </span>
     </strong>
     <span class="koboSpan" id="kobo.638.1">
      registry with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.639.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.640.1">$ npm install --global autocannon</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.641.1">
      We also need to create a directory to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.642.1">
       work in:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.643.1">$ mkdir profiling-memory</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.644.1">$ cd profiling-memory</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.645.1">$ npm init --yes</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.646.1">
      Create a file named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.647.1">
       leaky-server.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.648.1">
      .
     </span>
     <span class="koboSpan" id="kobo.648.2">
      This HTTP server will intentionally contain a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.649.1">
       memory leak:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.650.1">$ touch leaky-server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.651.1">
      Add the following
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.652.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.653.1">
        leaky-server.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.654.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.655.1">
const http = require('node:http');
const server = http.createServer((req, res) =&gt; {
  server.on('connection', () =&gt; { });
  res.end('Hello World!');
});
server.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.656.1">
     Now that we’ve installed the
    </span>
    <a id="_idIndexMarker812">
    </a>
    <span class="koboSpan" id="kobo.657.1">
     necessary tools and created a sample application containing a memory leak, we’re ready to move on to this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.658.1">
      recipe’s steps.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-327">
    <a id="_idTextAnchor334">
    </a>
    <span class="koboSpan" id="kobo.659.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.660.1">
     In this recipe, we’ll use Chrome DevTools to identify a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.661.1">
      memory leak:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.662.1">
      Memory leaks can get progressively worse the longer an application is running.
     </span>
     <span class="koboSpan" id="kobo.662.2">
      Sometimes, it can take several days or weeks of an application running before the memory leak causes the application to crash.
     </span>
     <span class="koboSpan" id="kobo.662.3">
      We can use the Node.js process
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.663.1">
       --max-old-space-size
      </span>
     </strong>
     <span class="koboSpan" id="kobo.664.1">
      command-line flag to increase or reduce the maximum V8 old memory size (in MB).
     </span>
     <span class="koboSpan" id="kobo.664.2">
      To demonstrate the presence of the memory leak, we’ll set this to a very small value.
     </span>
     <span class="koboSpan" id="kobo.664.3">
      Start
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.665.1">
       leaky-server.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.666.1">
      with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.667.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.668.1">$ node --max-old-space-size=10 leaky-server.js</span></strong><span class="koboSpan" id="kobo.669.1">
Server listening on port 3000</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.670.1">
      In a second terminal window, use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.671.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.672.1">
      tool to direct load to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.673.1">
       the server:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.674.1">$ autocannon http://localhost:3000</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.675.1">
      Back in the terminal window where you started the server, observe that the server crashed
     </span>
     <a id="_idIndexMarker813">
     </a>
     <span class="koboSpan" id="kobo.676.1">
      with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.677.1">
       JavaScript heap out
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.678.1">
        of memory
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.679.1">
       :
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer064">
     <span class="koboSpan" id="kobo.680.1">
      <img alt="Figure 10.12 – JavaScript heap out of memory error" src="image/Figure_10.12_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.681.1">
     Figure 10.12 – JavaScript heap out of memory error
    </span>
   </p>
   <ol>
    <li value="4">
     <span class="koboSpan" id="kobo.682.1">
      Now, we’ll start using Chrome DevTools to profile our application.
     </span>
     <span class="koboSpan" id="kobo.682.2">
      First, we must restart the server with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.683.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.684.1">$ node --inspect leaky-server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.685.1">
      Navigate to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.686.1">
       chrome://inspect
      </span>
     </strong>
     <span class="koboSpan" id="kobo.687.1">
      in Google Chrome and click
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.688.1">
       inspect
      </span>
     </strong>
     <span class="koboSpan" id="kobo.689.1">
      (underneath
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.690.1">
       leaky-server.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.691.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.691.2">
      This should open the Chrome
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.692.1">
       DevTools interface.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.693.1">
      Ensure you’re on
     </span>
     <a id="_idIndexMarker814">
     </a>
     <span class="koboSpan" id="kobo.694.1">
      the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.695.1">
       Memory
      </span>
     </strong>
     <span class="koboSpan" id="kobo.696.1">
      tab and that
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.697.1">
       Heap snapshot
      </span>
     </strong>
     <span class="koboSpan" id="kobo.698.1">
      is selected.
     </span>
     <span class="koboSpan" id="kobo.698.2">
      Click
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.699.1">
        Take snapshot
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.700.1">
       :
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer065">
     <span class="koboSpan" id="kobo.701.1">
      <img alt="Figure 10.13 – The Chrome DevTools Memory interface" src="image/Figure_10.13_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.702.1">
     Figure 10.13 – The Chrome DevTools Memory interface
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.703.1">
     You should see
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.704.1">
      Snapshot 1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.705.1">
     appear on the left of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.706.1">
      the interface:
     </span>
    </span>
   </p>
   <div>
    <div class="IMG---Figure" id="_idContainer066">
     <span class="koboSpan" id="kobo.707.1">
      <img alt="Figure 10.14 – Chrome DevTools memory snapshot interface" src="image/Figure_10.14_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.708.1">
     Figure 10.14 – Chrome DevTools memory snapshot interface
    </span>
   </p>
   <ol>
    <li value="7">
     <span class="koboSpan" id="kobo.709.1">
      Return to your
     </span>
     <a id="_idIndexMarker815">
     </a>
     <span class="koboSpan" id="kobo.710.1">
      second terminal window and rerun the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.711.1">
        autocannon
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.712.1">
       benchmark:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.713.1">$ autocannon http://localhost:3000</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.714.1">
      Once the load test has been completed, return to your Chrome DevTools window.
     </span>
     <span class="koboSpan" id="kobo.714.2">
      Return to the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.715.1">
       Profiles
      </span>
     </strong>
     <span class="koboSpan" id="kobo.716.1">
      interface of the
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.717.1">
       Memory
      </span>
     </strong>
     <span class="koboSpan" id="kobo.718.1">
      tab and take
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.719.1">
       another snapshot:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer067">
     <span class="koboSpan" id="kobo.720.1">
      <img alt="Figure 10.15 – Chrome DevTools memory snapshot interface" src="image/Figure_10.15_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.721.1">
     Figure 10.15 – Chrome DevTools memory snapshot interface
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.722.1">
     Note
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.723.1">
      MaxListenersExceededWarning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.724.1">
     in the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.725.1">
      Console
     </span>
    </strong>
    <span class="koboSpan" id="kobo.726.1">
     tab – this will be covered in
    </span>
    <a id="_idIndexMarker816">
    </a>
    <span class="koboSpan" id="kobo.727.1">
     more detail in the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.728.1">
      There’s
     </span>
    </em>
    <span class="No-Break">
     <em class="italic">
      <span class="koboSpan" id="kobo.729.1">
       more…
      </span>
     </em>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.730.1">
      section.
     </span>
    </span>
   </p>
   <ol>
    <li value="9">
     <span class="koboSpan" id="kobo.731.1">
      Now that we have two snapshots, we can use Chrome DevTools to compare them.
     </span>
     <span class="koboSpan" id="kobo.731.2">
      To do this, change the drop-down window from
     </span>
     <strong class="bold">
      <span class="koboSpan" id="kobo.732.1">
       Summary
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.733.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="bold">
       <span class="koboSpan" id="kobo.734.1">
        Comparison
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.735.1">
       :
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer068">
     <span class="koboSpan" id="kobo.736.1">
      <img alt="Figure 10.16 – Chrome DevTools memory snapshot comparison interface" src="image/Figure_10.16_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.737.1">
     Figure 10.16 – Chrome DevTools memory snapshot comparison interface
    </span>
   </p>
   <ol>
    <li value="10">
     <span class="koboSpan" id="kobo.738.1">
      Observe that the
     </span>
     <a id="_idIndexMarker817">
     </a>
     <span class="koboSpan" id="kobo.739.1">
      constructors are now sorted by delta – the difference between two snapshots.
     </span>
     <span class="koboSpan" id="kobo.739.2">
      Expand the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.740.1">
       (array)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.741.1">
      constructor and the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.742.1">
       (object elements) [ ]
      </span>
     </strong>
     <span class="koboSpan" id="kobo.743.1">
      object within it; you should see the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.744.1">
       following output:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer069">
     <span class="koboSpan" id="kobo.745.1">
      <img alt="Figure 10.17 – Chrome DevTools memory snapshot comparison interface expanded" src="image/Figure_10.17_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.746.1">
     Figure 10.17 – Chrome DevTools memory snapshot comparison interface expanded
    </span>
   </p>
   <ol>
    <li value="11">
     <span class="koboSpan" id="kobo.747.1">
      The expanded view
     </span>
     <a id="_idIndexMarker818">
     </a>
     <span class="koboSpan" id="kobo.748.1">
      indicates that there are masses of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.749.1">
       connectionListener()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.750.1">
      events stemming from
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.751.1">
       line 4
      </span>
     </em>
     <span class="koboSpan" id="kobo.752.1">
      of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.753.1">
       leaky-server.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.754.1">
      .
     </span>
     <span class="koboSpan" id="kobo.754.2">
      If we take a look at that line, we’ll see that it starts on the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.755.1">
       server.on('connection',...
      </span>
     </strong>
     <span class="koboSpan" id="kobo.756.1">
      block.
     </span>
     <span class="koboSpan" id="kobo.756.2">
      This is our memory leak.
     </span>
     <span class="koboSpan" id="kobo.756.3">
      We’re registering a listener for the connected event upon every request, causing our server to eventually run out of memory.
     </span>
     <span class="koboSpan" id="kobo.756.4">
      We need to move this event listener outside of our request handler function.
     </span>
     <span class="koboSpan" id="kobo.756.5">
      Create a new file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.757.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.758.1">
        server.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.759.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.760.1">$ touch server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.761.1">
      Add the following
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.762.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.763.1">
        server.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.764.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.765.1">
const http = require('node:http');
const server = http.createServer((req, res) =&gt; {
  res.end('Hello World!');
});
server.on('connection', () =&gt; {});
server.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.766.1">
      Close the Chrome
     </span>
     <a id="_idIndexMarker819">
     </a>
     <span class="koboSpan" id="kobo.767.1">
      DevTools window and then rerun the same experiment.
     </span>
     <span class="koboSpan" id="kobo.767.2">
      Start the server with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.768.1">
       $ node --inspect server.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.769.1">
      and take a snapshot.
     </span>
     <span class="koboSpan" id="kobo.769.2">
      In a second terminal window, direct load to the server with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.770.1">
       $ autocannon http://localhost:3000
      </span>
     </strong>
     <span class="koboSpan" id="kobo.771.1">
      and take another snapshot.
     </span>
     <span class="koboSpan" id="kobo.771.2">
      Now, when we compare the two, we’ll see that the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.772.1">
       # Delta
      </span>
     </strong>
     <span class="koboSpan" id="kobo.773.1">
      value of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.774.1">
       (array)
      </span>
     </strong>
     <span class="koboSpan" id="kobo.775.1">
      constructors has
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.776.1">
       significantly reduced:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer070">
     <span class="koboSpan" id="kobo.777.1">
      <img alt="Figure 10.18 – Chrome DevTools memory snapshot comparison interface" src="image/Figure_10.18_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.778.1">
     Figure 10.18 – Chrome DevTools memory snapshot comparison interface
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.779.1">
     Observe that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.780.1">
      MaxListenersExceededWarning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.781.1">
     warning is no longer appearing, indicating
    </span>
    <a id="_idIndexMarker820">
    </a>
    <span class="koboSpan" id="kobo.782.1">
     that we’ve fixed our
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.783.1">
      memory leak.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.784.1">
     With that, we’ve learned how to take heap snapshots of our application, enabling us to diagnose a memory leak in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.785.1">
      our application.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-328">
    <a id="_idTextAnchor335">
    </a>
    <span class="koboSpan" id="kobo.786.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.787.1">
     The V8 JavaScript engine is used by both Google Chrome and Node.js.
    </span>
    <span class="koboSpan" id="kobo.787.2">
     The common underlying engine means that we can use Chrome DevTools to debug and profile Node.js applications.
    </span>
    <span class="koboSpan" id="kobo.787.3">
     To enable the debugging client, we must pass the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.788.1">
      --inspect
     </span>
    </strong>
    <span class="koboSpan" id="kobo.789.1">
     command-line flag to the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.790.1">
      node
     </span>
    </strong>
    <span class="koboSpan" id="kobo.791.1">
     process.
    </span>
    <span class="koboSpan" id="kobo.791.2">
     Passing this flag instructs the V8 inspector to open a port that accepts WebSocket connections.
    </span>
    <span class="koboSpan" id="kobo.791.3">
     The WebSocket connection allows the client and V8 inspector
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.792.1">
      to interact.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.793.1">
     The V8 JavaScript engine retains a heap of all the objects and primitives referenced in our JavaScript code.
    </span>
    <span class="koboSpan" id="kobo.793.2">
     The JavaScript heap can be exposed via an internal V8 API (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.794.1">
      v8_inspector
     </span>
    </strong>
    <span class="koboSpan" id="kobo.795.1">
     ).
    </span>
    <span class="koboSpan" id="kobo.795.2">
     Chrome DevTools uses this internal API to provide tooling interfaces, including the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.796.1">
      Memory Profiler
     </span>
    </strong>
    <span class="koboSpan" id="kobo.797.1">
     interface we used in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.798.1">
      this recipe.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.799.1">
     We used the
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.800.1">
      Memory
     </span>
    </strong>
    <span class="koboSpan" id="kobo.801.1">
     interface of Chrome DevTools to take an initial heap snapshot of the server.
    </span>
    <span class="koboSpan" id="kobo.801.2">
     This snapshot is considered our baseline.
    </span>
    <span class="koboSpan" id="kobo.801.3">
     Then, we generated load on the server using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.802.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.803.1">
     tool to simulate usage over time.
    </span>
    <span class="koboSpan" id="kobo.803.2">
     For our server, the memory leak could be observed with the default
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.804.1">
      autocannon
     </span>
    </strong>
    <span class="koboSpan" id="kobo.805.1">
     load (
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.806.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.807.1">
     connections for
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.808.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.809.1">
     seconds).
    </span>
    <span class="koboSpan" id="kobo.809.2">
     Some memory leaks may only be observable under considerable load; in these cases, we’d
    </span>
    <a id="_idIndexMarker821">
    </a>
    <span class="koboSpan" id="kobo.810.1">
     need to simulate a more extreme load on the server, potentially for a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.811.1">
      longer period.
     </span>
    </span>
   </p>
   <p class="callout-heading">
    <span class="koboSpan" id="kobo.812.1">
     autocannon
    </span>
   </p>
   <p class="callout">
    <span class="koboSpan" id="kobo.813.1">
     The
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.814.1">
      Benchmarking HTTP requests
     </span>
    </em>
    <span class="koboSpan" id="kobo.815.1">
     recipe in this chapter goes into more detail about how we can simulate more extreme server loads with the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.816.1">
       autocannon
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.817.1">
      tool.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.818.1">
     Once we directed the load to our server, we took a second heap snapshot.
    </span>
    <span class="koboSpan" id="kobo.818.2">
     This showed how much impact the load had on the heap size.
    </span>
    <span class="koboSpan" id="kobo.818.3">
     Our second snapshot was much larger than the first, which is an indication of a memory leak.
    </span>
    <span class="koboSpan" id="kobo.818.4">
     The heap snapshot
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.819.1">
      Comparison
     </span>
    </strong>
    <span class="koboSpan" id="kobo.820.1">
     view can be utilized to identify which constructors have the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.821.1">
      largest deltas.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.822.1">
     From inspecting and expanding the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.823.1">
      (array)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.824.1">
     constructor, we found a long list
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.825.1">
      of
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.826.1">
       connection
      </span>
     </strong>
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.827.1">
      Listener()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.828.1">
     events stemming from
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.829.1">
      line 4
     </span>
    </em>
    <span class="koboSpan" id="kobo.830.1">
     of our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.831.1">
      leaky-server.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.832.1">
     file.
    </span>
    <span class="koboSpan" id="kobo.832.2">
     This enabled us to identify the memory leak.
    </span>
    <span class="koboSpan" id="kobo.832.3">
     Note that the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.833.1">
      (array)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.834.1">
     constructor refers to an internal structure used by V8.
    </span>
    <span class="koboSpan" id="kobo.834.2">
     For a JavaScript array, the constructor would be
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.835.1">
      named
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.836.1">
       Array
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.837.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.838.1">
     Once the memory leak has been identified and fixed, it’s prudent to rerun the test and confirm that the new heap snapshot shows a reduction in deltas.
    </span>
    <span class="koboSpan" id="kobo.838.2">
     The snapshot is still likely to be larger than the initial baseline snapshot because of the load.
    </span>
    <span class="koboSpan" id="kobo.838.3">
     However, it shouldn’t be as drastically large as it was with our
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.839.1">
       leaky-server.js
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.840.1">
      file.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-329">
    <a id="_idTextAnchor336">
    </a>
    <span class="koboSpan" id="kobo.841.1">
     There’s more…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.842.1">
     In this recipe, when under
    </span>
    <a id="_idIndexMarker822">
    </a>
    <span class="koboSpan" id="kobo.843.1">
     load,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.844.1">
      leaky-server.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.845.1">
     emitted
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.846.1">
      MaxListenersExceededWarning
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.847.1">
      before crashing:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.848.1">
$ node --max-old-space-size=10 leaky-server.js
Server listening on port 3000
(node:16402) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. </span><span class="koboSpan" id="kobo.848.2">11 connection listeners added to [Server]. </span><span class="koboSpan" id="kobo.848.3">Use emitter.setMaxListeners() to increase limit</span></pre>
   <p>
    <span class="koboSpan" id="kobo.849.1">
     By default, Node.js allows a maximum of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.850.1">
      10
     </span>
    </strong>
    <span class="koboSpan" id="kobo.851.1">
     listeners to be registered for a single event.
    </span>
    <span class="koboSpan" id="kobo.851.2">
     In
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.852.1">
      leaky-server.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.853.1">
     , we were registering a new listener for each request.
    </span>
    <span class="koboSpan" id="kobo.853.2">
     Once our application registered
    </span>
    <a id="_idIndexMarker823">
    </a>
    <span class="koboSpan" id="kobo.854.1">
     the 11th request, it emitted
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.855.1">
      MaxListenersExceededWarning
     </span>
    </strong>
    <span class="koboSpan" id="kobo.856.1">
     .
    </span>
    <span class="koboSpan" id="kobo.856.2">
     This is an early warning sign of a memory leak.
    </span>
    <span class="koboSpan" id="kobo.856.3">
     It’s possible to change the maximum number of listeners.
    </span>
    <span class="koboSpan" id="kobo.856.4">
     To change the threshold for an individual
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.857.1">
      EventEmitter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.858.1">
     instance, we can use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.859.1">
      emitter.setMaxListeners()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.860.1">
     method.
    </span>
    <span class="koboSpan" id="kobo.860.2">
     For example, to lower the maximum number of listeners on our server to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.861.1">
      1
     </span>
    </strong>
    <span class="koboSpan" id="kobo.862.1">
     , we could change
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.863.1">
      leaky-server.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.864.1">
     to
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.865.1">
      the following:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.866.1">
const http = require('node:http');
const server = http.createServer((req, res) =&gt; {
  </span><strong class="bold"><span class="koboSpan" id="kobo.867.1">server.setMaxListeners(1);</span></strong><span class="koboSpan" id="kobo.868.1">
  server.on('connection', () =&gt; { });
  res.end('Hello World!');
});
server.listen(3000, () =&gt; {
  console.log('Server listening on port 3000');
});</span></pre>
   <p>
    <span class="koboSpan" id="kobo.869.1">
     Then, if we were to run the same experiment, we’d see the following error after just two event listeners
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.870.1">
      were registered:
     </span>
    </span>
   </p>
   <pre class="console"><span class="koboSpan" id="kobo.871.1">
(node:16629) MaxListenersExceededWarning: Possible EventEmitter memory leak detected. </span><span class="koboSpan" id="kobo.871.2">2 connection listeners added to [Server]. </span><span class="koboSpan" id="kobo.871.3">Use emitter.setMaxListeners() to increase limit</span></pre>
   <p>
    <span class="koboSpan" id="kobo.872.1">
     It’s also possible to use the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.873.1">
      EventEmitter.defaultMaxListeners
     </span>
    </strong>
    <span class="koboSpan" id="kobo.874.1">
     property to change the default maximum listeners for all
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.875.1">
      EventEmitter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.876.1">
     instances.
    </span>
    <span class="koboSpan" id="kobo.876.2">
     This should be done with caution as it will impact all
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.877.1">
      EventEmitter
     </span>
    </strong>
    <span class="koboSpan" id="kobo.878.1">
     instances.
    </span>
    <span class="koboSpan" id="kobo.878.2">
     You could use the following to set the
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.879.1">
       EventEmitter.defaultMaxListeners
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.880.1">
      value:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.881.1">
require('events').EventEmitter.defaultMaxListeners = 15;</span></pre>
   <p>
    <span class="koboSpan" id="kobo.882.1">
     Note that
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.883.1">
      emitter.setMaxListeners()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.884.1">
     will always take precedence over the global default set via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.885.1">
      EventEmitter.defaultMaxListeners
     </span>
    </strong>
    <span class="koboSpan" id="kobo.886.1">
     .
    </span>
    <span class="koboSpan" id="kobo.886.2">
     Before raising the maximum threshold
    </span>
    <a id="_idIndexMarker824">
    </a>
    <span class="koboSpan" id="kobo.887.1">
     of listeners, it’s worth considering whether you’re inadvertently masking a memory leak in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.888.1">
      your application.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-330">
    <a id="_idTextAnchor337">
    </a>
    <span class="koboSpan" id="kobo.889.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.890.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.891.1">
       Interpreting flame graphs
      </span>
     </em>
     <span class="koboSpan" id="kobo.892.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.893.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.894.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.895.1">
       Optimizing synchronous functions
      </span>
     </em>
     <span class="koboSpan" id="kobo.896.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.897.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.898.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.899.1">
       Optimizing asynchronous functions
      </span>
     </em>
     <span class="koboSpan" id="kobo.900.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.901.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.902.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.903.1">
       Debugging with Chrome DevTools
      </span>
     </em>
     <span class="koboSpan" id="kobo.904.1">
      recipe in
     </span>
     <a href="B19212_12.xhtml#_idTextAnchor388">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.905.1">
         Chapter 12
        </span>
       </em>
      </span>
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-331">
    <a id="_idTextAnchor338">
    </a>
    <span class="koboSpan" id="kobo.906.1">
     Optimizing synchronous functions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.907.1">
     The previous recipes
    </span>
    <a id="_idIndexMarker825">
    </a>
    <span class="koboSpan" id="kobo.908.1">
     of this chapter covered how to detect hot code paths in our applications.
    </span>
    <span class="koboSpan" id="kobo.908.2">
     Once a hot code path is identified, we can focus our optimization efforts on it to reduce
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.909.1">
      the bottleneck.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.910.1">
     It’s important to optimize any hot code paths as any function that takes a long time to process can prevent I/O and other functions from executing, impacting the overall performance of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.911.1">
      your application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.912.1">
     This recipe will cover how to micro-benchmark and optimize a synchronous function.
    </span>
    <span class="koboSpan" id="kobo.912.2">
     A
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.913.1">
      micro-benchmark
     </span>
    </strong>
    <span class="koboSpan" id="kobo.914.1">
     is a type
    </span>
    <a id="_idIndexMarker826">
    </a>
    <span class="koboSpan" id="kobo.915.1">
     of performance test that focuses on a small, specific piece of code or functionality within a larger system.
    </span>
    <span class="koboSpan" id="kobo.915.2">
     We’ll use Benchmark.js (
    </span>
    <a href="https://benchmarkjs.com/">
     <span class="koboSpan" id="kobo.916.1">
      https://benchmarkjs.com/
     </span>
    </a>
    <span class="koboSpan" id="kobo.917.1">
     ) to create
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.918.1">
      a micro-benchmark.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-332">
    <a id="_idTextAnchor339">
    </a>
    <span class="koboSpan" id="kobo.919.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.920.1">
     In real applications, we’d use tooling such as flame graphs or profilers to identify slow functions in our applications.
    </span>
    <span class="koboSpan" id="kobo.920.2">
     For this recipe, we’ll create a single slow function that we can learn how to micro-benchmark
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.921.1">
      and optimize:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.922.1">
      First, create a directory for this recipe’s code and initialize
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.923.1">
       the project:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.924.1">$ mkdir optimize-sync</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.925.1">$ cd optimize-sync</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.926.1">$ npm init --yes</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.927.1">
      We also need to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.928.1">
       install Benchmark.js:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.929.1">$ npm install benchmark</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.930.1">
     Now that we’ve initialized our directory, we can start
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.931.1">
      this recipe.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-333">
    <a id="_idTextAnchor340">
    </a>
    <span class="koboSpan" id="kobo.932.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.933.1">
     Let’s assume
    </span>
    <a id="_idIndexMarker827">
    </a>
    <span class="koboSpan" id="kobo.934.1">
     that we’ve identified a bottleneck in our code base and it happens to be a function called
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.935.1">
      sumOfSquares()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.936.1">
     .
    </span>
    <span class="koboSpan" id="kobo.936.2">
     Our task is to make this
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.937.1">
      function faster:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.938.1">
      First, let’s create a file named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.939.1">
       slow.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.940.1">
      , which will hold our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.941.1">
       unoptimized function:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.942.1">$ touch slow.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.943.1">
      Add the following to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.944.1">
       slow.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.945.1">
      to create the slow
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.946.1">
       sumOfSquares()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.947.1">
      implementation.
     </span>
     <span class="koboSpan" id="kobo.947.2">
      This uses the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.948.1">
       Array.from()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.949.1">
      method to generate an array of integers.
     </span>
     <span class="koboSpan" id="kobo.949.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.950.1">
       map
      </span>
     </strong>
     <span class="koboSpan" id="kobo.951.1">
      function is used to square each number in the array, while the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.952.1">
       reduce
      </span>
     </strong>
     <span class="koboSpan" id="kobo.953.1">
      function is used to sum the elements of
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.954.1">
       the array:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.955.1">
function sumOfSquares(maxNumber) {
  const array = Array.from(Array(maxNumber + 1).keys());
  return array
    .map((number) =&gt; {
      return number ** 2;
    })
    .reduce((accumulator, item) =&gt; {
      return accumulator + item;
    });
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.956.1">
      Now that we have a slow version of our function, let’s turn it into a module so that we can benchmark it with ease.
     </span>
     <span class="koboSpan" id="kobo.956.2">
      If our function formed part of a larger script or application, it would be worthwhile trying to extract it into a standalone script or module to enable it to be benchmarked in isolation.
     </span>
     <span class="koboSpan" id="kobo.956.3">
      Add the following line to the bottom
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.957.1">
       of
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.958.1">
        slow.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.959.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.960.1">
module.exports = sumOfSquares;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.961.1">
      Now, we can write a micro-benchmark for our
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.962.1">
       sumOfSquares()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.963.1">
      function using Benchmark.js.
     </span>
     <span class="koboSpan" id="kobo.963.2">
      Create a file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.964.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.965.1">
        benchmark.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.966.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.967.1">$ touch benchmark.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.968.1">
      Add the following code to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.969.1">
       benchmark.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.970.1">
      to create a benchmark for our
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.971.1">
        sumOfSquares()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.972.1">
       function:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.973.1">
const benchmark = require('benchmark');
const slow = require('./slow');
const suite = new benchmark.Suite();
const maxNumber = 100;
suite.add('slow', function () {
  slow(maxNumber);
});
suite.on('complete', printResults);
suite.run();
function printResults () {
  this.forEach((benchmark) =&gt; {
    console.log(benchmark.toString());
  });
  console.log('Fastest implementation is', this.filter('fastest')[0].name);
}</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.974.1">
       This file contains
      </span>
      <a id="_idIndexMarker828">
      </a>
      <span class="koboSpan" id="kobo.975.1">
       the configuration of Benchmark.js, a single benchmark that calls our
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.976.1">
        slow.js
       </span>
      </strong>
      <span class="koboSpan" id="kobo.977.1">
       module, and a
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.978.1">
        printResults()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.979.1">
       function, which outputs the benchmark
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.980.1">
        run information.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.981.1">
      Now, we can run the benchmark with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.982.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.983.1">$ node benchmark.js</span></strong><span class="koboSpan" id="kobo.984.1">
slow x 231,893 ops/sec ±0.90% (90 runs sampled)
Fastest implementation is slow</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.985.1">
      Let’s generate a flame graph using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.986.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.987.1">
      tool.
     </span>
     <span class="koboSpan" id="kobo.987.2">
      A flame graph can help us identify which of the lines of our code are spending the most time on the CPU.
     </span>
     <span class="koboSpan" id="kobo.987.3">
      Generate a flame graph with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.988.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.989.1">
      by using the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.990.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.991.1">$ npx 0x benchmark.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.992.1">
      Open the flame graph in your browser.
     </span>
     <span class="koboSpan" id="kobo.992.2">
      In the following example, there’s one pink frame, indicating a hot code path.
     </span>
     <span class="koboSpan" id="kobo.992.3">
      Hover over the hotter frames to identify which line of the application they’re
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.993.1">
       referring to:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer071">
     <span class="koboSpan" id="kobo.994.1">
      <img alt="Figure 10.19 – ﻿An overview of the 0x flame graph showing a hot frame on line 9 of slow.js" src="image/Figure_10.19_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.995.1">
     Figure 10.19 – An overview of the 0x flame graph showing a hot frame on line 9 of slow.js
    </span>
   </p>
   <ol>
    <li value="9">
     <span class="koboSpan" id="kobo.996.1">
      In the flame graph, we can see that the hottest function is an anonymous function
     </span>
     <a id="_idIndexMarker829">
     </a>
     <span class="koboSpan" id="kobo.997.1">
      on
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.998.1">
       line 9
      </span>
     </em>
     <span class="koboSpan" id="kobo.999.1">
      of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1000.1">
       slow.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1001.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1001.2">
      If we look at our code, we’ll see that this points to our use of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1002.1">
       Array.reduce()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1003.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1003.2">
      Note that the line number may be different should you have formatted this recipe’s
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1004.1">
       code differently.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1005.1">
      As we suspect that it’s the use of
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1006.1">
       Array.reduce()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1007.1">
      that’s slowing our operations down, we should try rewriting the function in a procedural form (using a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1008.1">
       for
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1009.1">
      loop) to see whether it improves the performance.
     </span>
     <span class="koboSpan" id="kobo.1009.2">
      Create a file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1010.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1011.1">
        loop.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1012.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1013.1">$ touch loop.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1014.1">
      Add the following to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1015.1">
       loop.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1016.1">
      to create a procedural implementation of the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1017.1">
        sumOfSquares()
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1018.1">
       function:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1019.1">
function sumOfSquares(maxNumber) {
    let i = 0;
    let sum = 0;
    for (i; i &lt;= maxNumber; i++) {
        sum += i ** 2;
    }
    return sum;
}
module.exports = sumOfSquares;</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1020.1">
      Now, let’s add a
     </span>
     <a id="_idIndexMarker830">
     </a>
     <span class="koboSpan" id="kobo.1021.1">
      benchmark for the implementation of the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1022.1">
       sumOfSquares()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1023.1">
      function in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1024.1">
       loop.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1025.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1025.2">
      First, import the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1026.1">
       loop.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1027.1">
      module by adding the following line below the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1028.1">
       slow.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1029.1">
      import
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1030.1">
       in
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1031.1">
        benchmark.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1032.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1033.1">
const loop = require('./loop');</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1034.1">
      Then, add a new benchmark to the suite, below the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1035.1">
       slow run:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1036.1">
suite.add('loop', function () {
  loop(maxNumber);
});</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1037.1">
      Rerun the benchmark.
     </span>
     <span class="koboSpan" id="kobo.1037.2">
      This time, it will run both of our implementations and determine which one
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1038.1">
       is fastest:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1039.1">$ node benchmark.js</span></strong><span class="koboSpan" id="kobo.1040.1">
slow x 247,958 ops/sec ±1.17% (90 runs sampled)
loop x 7,337,014 ops/sec ±0.86% (94 runs sampled)
Fastest implementation is loop</span></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.1041.1">
     With that, we’ve confirmed that our procedural/loop implementation of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1042.1">
      sumOfSquares()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1043.1">
     function is much faster than the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1044.1">
      original implementation.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-334">
    <a id="_idTextAnchor341">
    </a>
    <span class="koboSpan" id="kobo.1045.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1046.1">
     This recipe stepped through the process of optimizing a synchronous function call, starting with the slow implementation of a
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1047.1">
       sumOfSquares()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1048.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1049.1">
     We created a micro-benchmark using Benchmark.js to create a baseline measure of our initial
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1050.1">
      sumOfSquares()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1051.1">
     implementation in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1052.1">
      slow.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1053.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1053.2">
     This baseline measure is called a micro-benchmark.
    </span>
    <strong class="bold">
     <span class="koboSpan" id="kobo.1054.1">
      Micro-benchmarks
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1055.1">
     are used to
    </span>
    <a id="_idIndexMarker831">
    </a>
    <span class="koboSpan" id="kobo.1056.1">
     benchmark a small facet of an application.
    </span>
    <span class="koboSpan" id="kobo.1056.2">
     In our case, it was for the single
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1057.1">
       sumOfSquares()
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1058.1">
      function.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1059.1">
     Once our micro-benchmark was created, we ran the benchmark via
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1060.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1061.1">
     to generate a flame graph.
    </span>
    <span class="koboSpan" id="kobo.1061.2">
     This flame graph enabled us to identify which frames were spending the most time on the CPU, which provided us with an indication of which specific line of code within our
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1062.1">
      sumOfSquares()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1063.1">
     function was
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1064.1">
      the bottleneck.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1065.1">
     From the flame graph, we determined that the use of the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1066.1">
      map
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1067.1">
     and
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1068.1">
      reduce
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1069.1">
     functions of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1070.1">
      sumOfSquares()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1071.1">
     was slowing the operation down.
    </span>
    <span class="koboSpan" id="kobo.1071.2">
     Therefore, we created a second implementation of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1072.1">
      sumOfSquares()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1073.1">
     .
    </span>
    <span class="koboSpan" id="kobo.1073.2">
     The second implementation used traditional procedural code (a
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1074.1">
      for
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1075.1">
     loop).
    </span>
    <span class="koboSpan" id="kobo.1075.2">
     Once we had the second implementation of the function, in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1076.1">
      loop.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1077.1">
     , we added it to our benchmarks.
    </span>
    <span class="koboSpan" id="kobo.1077.2">
     This allowed us to compare the two implementations to see which
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1078.1">
      was faster.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1079.1">
     Based on the number of operations that could be handled per second,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1080.1">
      loop.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1081.1">
     was found to be
    </span>
    <a id="_idIndexMarker832">
    </a>
    <span class="koboSpan" id="kobo.1082.1">
     significantly faster than the initial
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1083.1">
      slow.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1084.1">
     implementation.
    </span>
    <span class="koboSpan" id="kobo.1084.2">
     The benefit of writing a micro-benchmark is that you have evidence and confirmation of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1085.1">
      your optimizations.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-335">
    <a id="_idTextAnchor342">
    </a>
    <span class="koboSpan" id="kobo.1086.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1087.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1088.1">
       Benchmarking HTTP requests
      </span>
     </em>
     <span class="koboSpan" id="kobo.1089.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1090.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1091.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1092.1">
       Interpreting flame graphs
      </span>
     </em>
     <span class="koboSpan" id="kobo.1093.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1094.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1095.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1096.1">
       Detecting memory leaks
      </span>
     </em>
     <span class="koboSpan" id="kobo.1097.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1098.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1099.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1100.1">
       Optimizing asynchronous functions
      </span>
     </em>
     <span class="koboSpan" id="kobo.1101.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1102.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1103.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1104.1">
       Working with worker threads
      </span>
     </em>
     <span class="koboSpan" id="kobo.1105.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1106.1">
       this chapter
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-336">
    <a id="_idTextAnchor343">
    </a>
    <span class="koboSpan" id="kobo.1107.1">
     Optimizing asynchronous functions
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1108.1">
     The Node.js runtime
    </span>
    <a id="_idIndexMarker833">
    </a>
    <span class="koboSpan" id="kobo.1109.1">
     was built with I/O in mind, hence its asynchronous programming model.
    </span>
    <span class="koboSpan" id="kobo.1109.2">
     In the previous recipes of this chapter, we explored how to diagnose performance issues within synchronous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1110.1">
      JavaScript functions.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1111.1">
     However, a performance bottleneck may occur as part of an asynchronous workflow.
    </span>
    <span class="koboSpan" id="kobo.1111.2">
     In this recipe, we’ll cover profiling and optimizing an asynchronous
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1112.1">
      performance problem.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-337">
    <a id="_idTextAnchor344">
    </a>
    <span class="koboSpan" id="kobo.1113.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1114.1">
     In this recipe, we’ll diagnose a bottleneck in an Express.js web server that communicates with a MongoDB database.
    </span>
    <span class="koboSpan" id="kobo.1114.2">
     For more information on MongoDB, please refer to the
    </span>
    <em class="italic">
     <span class="koboSpan" id="kobo.1115.1">
      Storing and retrieving data with MongoDB
     </span>
    </em>
    <span class="koboSpan" id="kobo.1116.1">
     recipe in
    </span>
    <a href="B19212_05.xhtml#_idTextAnchor139">
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1117.1">
        Chapter 5
       </span>
      </em>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1118.1">
      :
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1119.1">
      To start MongoDB, we’ll use Docker (as we did in
     </span>
     <a href="B19212_05.xhtml#_idTextAnchor139">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.1120.1">
         Chapter 5
        </span>
       </em>
      </span>
     </a>
     <span class="koboSpan" id="kobo.1121.1">
      ).
     </span>
     <span class="koboSpan" id="kobo.1121.2">
      Ensuring that you have Docker running, enter the following command in your terminal to initialize a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1122.1">
       MongoDB database:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1123.1">$ docker run --publish 27017:27017 --name node-mongo --detach mongo:7</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1124.1">
      Now, we need to create a directory to work in.
     </span>
     <span class="koboSpan" id="kobo.1124.2">
      We’ll also install the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1125.1">
       express
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1126.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1127.1">
       mongodb
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1128.1">
      modules
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1129.1">
       from
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1130.1">
        npm
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1131.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1132.1">$ mkdir optimize-async</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1133.1">$ cd optimize-async</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1134.1">$ npm init --yes</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1135.1">$ npm install express mongodb</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1136.1">
      To simulate a real application, some data needs to be present in MongoDB.
     </span>
     <span class="koboSpan" id="kobo.1136.2">
      Create a file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1137.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1138.1">
        values.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1139.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1140.1">$ touch values.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1141.1">
      Add the following to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1142.1">
       values.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1143.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1143.2">
      This creates a load script that will enter a series of numbers into
     </span>
     <a id="_idIndexMarker834">
     </a>
     <span class="koboSpan" id="kobo.1144.1">
      our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1145.1">
       MongoDB database:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1146.1">
const { MongoClient } = require('mongodb');
const URL = 'mongodb://localhost:27017/';
const numberOfValues = 1000;
const values = [];
for (let count = 0; count &lt; numberOfValues; count++) {
  values.push({ value: Math.round(Math.random() * 100000) });
}
async function main () {
  const client = new MongoClient(URL);
  try {
    await client.connect();
    const db = client.db('data');
    await db.collection('values').insertMany(values);
    console.log(`Added ${numberOfValues} random values.`);
  } catch (err) {
    console.error(err);
  } finally {
    await client.close();
  }
}
main().catch(console.error);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1147.1">
      Run the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1148.1">
       values.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1149.1">
      script to populate the database for
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1150.1">
       this recipe:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1151.1">$ node values.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1152.1">
      Make sure the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1153.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1154.1">
      and
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1155.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1156.1">
      performance tools are
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1157.1">
       installed globally:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1158.1">$ npm install --global 0x autocannon</span></strong></pre>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.1159.1">
     Now that our directory has been initialized and a MongoDB database is available with some sample data, let’s start
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1160.1">
      this recipe.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-338">
    <a id="_idTextAnchor345">
    </a>
    <span class="koboSpan" id="kobo.1161.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1162.1">
     In this recipe, we’re going to diagnose a bottleneck in a web application that communicates with a MongoDB database.
    </span>
    <span class="koboSpan" id="kobo.1162.2">
     We’ll build a sample application that calculates the average
    </span>
    <a id="_idIndexMarker835">
    </a>
    <span class="koboSpan" id="kobo.1163.1">
     of all the values stored in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1164.1">
      the database:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1165.1">
      Create a file named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1166.1">
       server.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1167.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1167.2">
      This will store our server that calculates the average of the values in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1168.1">
       the database:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1169.1">$ touch server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1170.1">
      A
     </span>
     <a id="_idTextAnchor346">
     </a>
     <span class="koboSpan" id="kobo.1171.1">
      dd the following code
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1172.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1173.1">
        server.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1174.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1175.1">
const { MongoClient } = require('mongodb');
const express = require('express');
const URL = 'mongodb://localhost:27017/';
const app = express();
(async () =&gt; {
  try {
    const client = new MongoClient(URL);
    await client.connect();
    const db = client.db('data');
    const values = db.collection('values');
    app.get('/', async (req, res) =&gt; {
      try {
        const data = await values.find({}).toArray();
        const average =
          data.reduce((accumulator, value) =&gt; accumulator + value.value, 0) /
          data.length;
        res.send(`Average of all values is ${average}.`);
      } catch (err) {
        res.send(err);
      }
    });
    app.listen(3000, () =&gt; {
      console.log('Server is running on port 3000');
    });
  } catch (err) {
    console.error(err);
  }
})();</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1176.1">
      Start the server by entering the following command in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1177.1">
       your terminal:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1178.1">$ node server.js</span></strong><span class="koboSpan" id="kobo.1179.1">
Server is running on port 3000</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1180.1">
      Navigate to
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1181.1">
       http://localhost:3000
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1182.1">
      in your browser to check that the server is running.
     </span>
     <span class="koboSpan" id="kobo.1182.2">
      Expect to see a message printing the average of the random values we persisted to the database in the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1183.1">
       Getting
      </span>
     </em>
     <span class="No-Break">
      <em class="italic">
       <span class="koboSpan" id="kobo.1184.1">
        ready
       </span>
      </em>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1185.1">
       section.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1186.1">
      In a second terminal, we’ll use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1187.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1188.1">
      benchmarking tool to simulate a load on
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1189.1">
       the server:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1190.1">$ autocannon --connections 500 http://localhost:3000</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.1191.1">
       Expect to see the
      </span>
      <a id="_idIndexMarker836">
      </a>
      <span class="koboSpan" id="kobo.1192.1">
       following
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1193.1">
        autocannon
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1194.1">
       result summary once the load test has
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1195.1">
        been completed:
       </span>
      </span>
     </p>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer072">
     <span class="koboSpan" id="kobo.1196.1">
      <img alt="Figure 10.20 – autocannon result summary for server.js" src="image/Figure_10.20_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1197.1">
     Figure 10.20 – autocannon result summary for server.js
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.1198.1">
     This load test shows an average of around
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1199.1">
      317
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1200.1">
     requests
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1201.1">
      per second.
     </span>
    </span>
   </p>
   <ol>
    <li value="6">
     <span class="koboSpan" id="kobo.1202.1">
      Now, let’s see where the bottlenecks are in our application.
     </span>
     <span class="koboSpan" id="kobo.1202.2">
      We’ll use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1203.1">
       0x
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1204.1">
      tool to generate a flame graph.
     </span>
     <span class="koboSpan" id="kobo.1204.2">
      Restart the server with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1205.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1206.1">$ 0x server.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1207.1">
      In the second terminal, let’s simulate a load on the server again using the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1208.1">
        autocannon
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1209.1">
       tool:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1210.1">$ autocannon --connections 500 http://localhost:3000</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1211.1">
      Stop the server and open the generated flame graph in your browser.
     </span>
     <span class="koboSpan" id="kobo.1211.2">
      Expect a flame graph similar
     </span>
     <a id="_idIndexMarker837">
     </a>
     <span class="koboSpan" id="kobo.1212.1">
      to
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1213.1">
       the following:
      </span>
     </span>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer073">
     <span class="koboSpan" id="kobo.1214.1">
      <img alt="Figure 10.21 – ﻿An overview of the 0x flame graph showing deserializeObject() hot frames" src="image/Figure_10.21_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1215.1">
     Figure 10.21 – An overview of the 0x flame graph showing deserializeObject() hot frames
    </span>
   </p>
   <ol>
    <li value="9">
     <span class="koboSpan" id="kobo.1216.1">
      As we learned in the
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1217.1">
       Interpreting flame graphs
      </span>
     </em>
     <span class="koboSpan" id="kobo.1218.1">
      recipe of this chapter, the darker/more red frames can indicate bottlenecks in our application.
     </span>
     <span class="koboSpan" id="kobo.1218.2">
      In our example, the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1219.1">
       deserializeObject()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1220.1">
      function appears to be the hottest, meaning it was spending the most amount of time on the CPU.
     </span>
     <span class="koboSpan" id="kobo.1220.2">
      This is a commonly observed bottleneck in MongoDB-based applications.
     </span>
     <span class="koboSpan" id="kobo.1220.3">
      The bottleneck in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1221.1">
       deserializeObject()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1222.1">
      is related to the large amount of data we’re querying and receiving from our
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1223.1">
       MongoDB instance.
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1224.1">
      Let’s try and solve this bottleneck by precomputing and storing the average in the database.
     </span>
     <span class="koboSpan" id="kobo.1224.2">
      This should help by reducing the amount of data we request from MongoDB and removing the need to calculate the average.
     </span>
     <span class="koboSpan" id="kobo.1224.3">
      We’ll create a script called
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1225.1">
       calculate-average.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1226.1">
      that calculates the average and stores it in MongoDB.
     </span>
     <span class="koboSpan" id="kobo.1226.2">
      Create the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1227.1">
        calculate-average.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1228.1">
       file:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1229.1">$ touch calculate-average.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1230.1">
      Add the following
     </span>
     <a id="_idIndexMarker838">
     </a>
     <span class="koboSpan" id="kobo.1231.1">
      code
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1232.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1233.1">
        calculate-average.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1234.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1235.1">
const { MongoClient } = require('mongodb');
const URL = 'mongodb://localhost:27017/';
async function main () {
  const client = new MongoClient(URL);
  try {
    await client.connect();
    const db = client.db('data');
    const values = db.collection('values');
    const averages = db.collection('averages');
    const data = await values.find({}).toArray();
    // Calculate average
    const average =
      data.reduce((accumulator, value) =&gt; accumulator + value.value, 0) /
      data.length;
    await averages.insertOne({ value: average });
    console.log('Stored average in database.');
  } catch (err) {
    console.error(err);
  } finally {
    await client.close();
  }
}
main().catch(console.error);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1236.1">
      Run the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1237.1">
       calculate-averages.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1238.1">
      script to calculate and store the average in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1239.1">
       the
      </span>
     </span>
     <span class="No-Break">
      <a id="_idIndexMarker839">
      </a>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1240.1">
       database:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1241.1">$ node calculate-average.js</span></strong><span class="koboSpan" id="kobo.1242.1">
Stored average in database.</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1243.1">
      Now, we can rewrite the server so that it returns the stored average, rather than calculating it upon each request.
     </span>
     <span class="koboSpan" id="kobo.1243.2">
      Create a new file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1244.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1245.1">
        server-no-processing.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1246.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1247.1">$ touch server-no-processing.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1248.1">
      Add the following
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1249.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1250.1">
        server-no-processing.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1251.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1252.1">
const { MongoClient } = require('mongodb');
const express = require('express');
const URL = 'mongodb://localhost:27017/';
const app = express();
async function main () {
  const client = new MongoClient(URL);
  try {
    await client.connect();
    const db = client.db('data');
    const average = db.collection('averages');
    app.get('/', async (req, res) =&gt; {
      try {
        const data = await average.findOne({});
        res.send(`Average of all values is ${data.value}.`);
      } catch (err) {
        console.error(err);
        res.status(500).send('Error fetching average');
      }
    });
    app.listen(3000, () =&gt; {
      console.log('Server is listening on port 3000');
    });
  } catch (err) {
    console.error(err);
  }
}
main().catch(console.error);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1253.1">
      Let’s rerun the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1254.1">
       autocannon
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1255.1">
      benchmark.
     </span>
     <span class="koboSpan" id="kobo.1255.2">
      Start the server with
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1256.1">
       $ node server-no-process.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1257.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1257.2">
      Then, in a second terminal window, rerun the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1258.1">
       autocannon
      </span>
     </strong>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1259.1">
       load test:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1260.1">$ autocannon --connections 500 http://localhost:3000</span></strong></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.1261.1">
       Expect to see
      </span>
      <a id="_idIndexMarker840">
      </a>
      <span class="koboSpan" id="kobo.1262.1">
       the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1263.1">
        autocannon
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1264.1">
       result summary once the load test has
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1265.1">
        been completed:
       </span>
      </span>
     </p>
    </li>
   </ol>
   <div>
    <div class="IMG---Figure" id="_idContainer074">
     <span class="koboSpan" id="kobo.1266.1">
      <img alt="Figure 10.22 – autocannon result summary for server-no-processing.js" src="image/Figure_10.22_B19212.jpg"/>
     </span>
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    <span class="koboSpan" id="kobo.1267.1">
     Figure 10.22 – autocannon result summary for server-no-processing.js
    </span>
   </p>
   <p class="list-inset">
    <span class="koboSpan" id="kobo.1268.1">
     Here, we can see that the average number of requests per second has increased from around
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1269.1">
      317
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1270.1">
     in
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1271.1">
      server.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1272.1">
     to
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1273.1">
      6430
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1274.1">
     using the precomputed average
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1275.1">
      in
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1276.1">
       server-no-processing.js
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1277.1">
      .
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1278.1">
     In this recipe, we learned how obtaining and processing large amounts of data from MongoDB can introduce bottlenecks in our application.
    </span>
    <span class="koboSpan" id="kobo.1278.2">
     We solved the bottleneck showcased in this recipe by precomputing and storing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1279.1">
      the average.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-339">
    <a id="_idTextAnchor347">
    </a>
    <span class="koboSpan" id="kobo.1280.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1281.1">
     This recipe demonstrated
    </span>
    <a id="_idIndexMarker841">
    </a>
    <span class="koboSpan" id="kobo.1282.1">
     a bottleneck in an application that communicated with a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1283.1">
      MongoDB database.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1284.1">
     The slowness was caused by both the large amount of data being requested and the calculation of the average upon each request.
    </span>
    <span class="koboSpan" id="kobo.1284.2">
     By using the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1285.1">
      0x
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1286.1">
     tool to generate a flame graph, it was possible to diagnose the specific function that was causing
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1287.1">
      the bottleneck.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1288.1">
     In this case, the bottleneck was solved by precomputing the average and storing it in the database.
    </span>
    <span class="koboSpan" id="kobo.1288.2">
     This meant that instead of having to query the database for all values and computing the average on each request, it was possible to just query and obtain the average directly.
    </span>
    <span class="koboSpan" id="kobo.1288.3">
     This showed a significant increase
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1289.1">
      in performance.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1290.1">
     It was worthwhile amending the data model to store the precomputed average so that it didn’t need to be calculated on each request.
    </span>
    <span class="koboSpan" id="kobo.1290.2">
     However, in a real application, it may not always be possible to edit the data model to store computed values.
    </span>
    <span class="koboSpan" id="kobo.1290.3">
     When building a new application, it’s worth considering what data should be stored in the data model to minimize computation on the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1291.1">
      live server.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1292.1">
     Micro-optimizations, such as precomputing an average, can enhance performance by reducing runtime computation.
    </span>
    <span class="koboSpan" id="kobo.1292.2">
     These small improvements can boost efficiency, especially under heavy load.
    </span>
    <span class="koboSpan" id="kobo.1292.3">
     However, premature optimizations can complicate code, making maintenance harder.
    </span>
    <span class="koboSpan" id="kobo.1292.4">
     As such, it’s usually recommended to prioritize optimizations that offer substantial performance gains for your application and
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1293.1">
      end users.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-340">
    <a id="_idTextAnchor348">
    </a>
    <span class="koboSpan" id="kobo.1294.1">
     See also
    </span>
   </h2>
   <ul>
    <li>
     <span class="koboSpan" id="kobo.1295.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1296.1">
       Creating an Express.js web application
      </span>
     </em>
     <span class="koboSpan" id="kobo.1297.1">
      recipe in
     </span>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.1298.1">
         Chapter 6
        </span>
       </em>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1299.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1300.1">
       Storing and retrieving data with MongoDB
      </span>
     </em>
     <span class="koboSpan" id="kobo.1301.1">
      recipe in
     </span>
     <a href="B19212_07.xhtml#_idTextAnchor212">
      <span class="No-Break">
       <em class="italic">
        <span class="koboSpan" id="kobo.1302.1">
         Chapter 7
        </span>
       </em>
      </span>
     </a>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1303.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1304.1">
       Benchmarking HTTP requests
      </span>
     </em>
     <span class="koboSpan" id="kobo.1305.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1306.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1307.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1308.1">
       Detecting memory leaks
      </span>
     </em>
     <span class="koboSpan" id="kobo.1309.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1310.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1311.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1312.1">
       Optimizing synchronous functions
      </span>
     </em>
     <span class="koboSpan" id="kobo.1313.1">
      recipe in
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1314.1">
       this chapter
      </span>
     </span>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1315.1">
      The
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1316.1">
       Working with worker threads
      </span>
     </em>
     <span class="koboSpan" id="kobo.1317.1">
      recipe in
     </span>
     <a id="_idIndexMarker842">
     </a>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1318.1">
       this chapter
      </span>
     </span>
    </li>
   </ul>
   <h1 id="_idParaDest-341">
    <a id="_idTextAnchor349">
    </a>
    <span class="koboSpan" id="kobo.1319.1">
     Working with worker threads
    </span>
   </h1>
   <p>
    <span class="koboSpan" id="kobo.1320.1">
     JavaScript is a single-threaded
    </span>
    <a id="_idIndexMarker843">
    </a>
    <span class="koboSpan" id="kobo.1321.1">
     programming language, meaning that it executes one task at a time within a process.
    </span>
    <span class="koboSpan" id="kobo.1321.2">
     Node.js also runs on a single thread, but it uses an event loop to handle asynchronous operations, enabling non-blocking I/O calls.
    </span>
    <span class="koboSpan" id="kobo.1321.3">
     Despite this, the event loop processes one task at a time.
    </span>
    <span class="koboSpan" id="kobo.1321.4">
     As a result, CPU-intensive tasks can block the event loop and degrade the overall performance of
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1322.1">
      your application.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1323.1">
     To handle CPU-intensive tasks in Node.js efficiently, you should consider using worker threads.
    </span>
    <span class="koboSpan" id="kobo.1323.2">
     Worker threads were declared stable in Node.js version 12 and later and are accessible through the core
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1324.1">
      worker_threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1325.1">
     core module.
    </span>
    <span class="koboSpan" id="kobo.1325.2">
     The worker threads API allows you to run JavaScript code in parallel across multiple threads, making it well-suited for
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1326.1">
      CPU-intensive operations.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1327.1">
     This tutorial will introduce the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1328.1">
      worker_threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1329.1">
     module and demonstrate how to use it to manage
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1330.1">
      CPU-intensive tasks.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-342">
    <a id="_idTextAnchor350">
    </a>
    <span class="koboSpan" id="kobo.1331.1">
     Getting ready
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1332.1">
     First, ensure you’re using Node.js 22.
    </span>
    <span class="koboSpan" id="kobo.1332.2">
     Then, create a project directory to work in
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1333.1">
      named
     </span>
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1334.1">
       worker-app
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1335.1">
      :
     </span>
    </span>
   </p>
   <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1336.1">$ mkdir worker-app</span></strong>
<strong class="bold"><span class="koboSpan" id="kobo.1337.1">$ cd worker-app</span></strong></pre>
   <p>
    <span class="koboSpan" id="kobo.1338.1">
     Now that we’ve created a directory to work in, we can start
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1339.1">
      this recipe.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-343">
    <a id="_idTextAnchor351">
    </a>
    <span class="koboSpan" id="kobo.1340.1">
     How to do it…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1341.1">
     In this recipe, we’ll learn how to leverage worker threads to handle a
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1342.1">
      CPU-intensive task:
     </span>
    </span>
   </p>
   <ol>
    <li>
     <span class="koboSpan" id="kobo.1343.1">
      We’ll start by creating a simplified worker that returns the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1344.1">
       Hello &lt;name&gt;!
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1345.1">
      string.
     </span>
     <span class="koboSpan" id="kobo.1345.2">
      Create a file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1346.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1347.1">
        hello-worker.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1348.1">
       :
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1349.1">$ touch hello-worker.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1350.1">
      In
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1351.1">
       hello-worker.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1352.1">
      , we need to import the necessary class
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1353.1">
       and methods:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1354.1">
const {
  Worker,
  isMainThread,
  parentPort,
  workerData
} = require('node:worker_threads');</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1355.1">
      Now, we need to create an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1356.1">
       if
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1357.1">
      statement using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1358.1">
       isMainThread()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1359.1">
      method from the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1360.1">
       worker_threads
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1361.1">
      module.
     </span>
     <span class="koboSpan" id="kobo.1361.2">
      Anything within the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1362.1">
       if
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1363.1">
      block will be executed on the
     </span>
     <a id="_idIndexMarker844">
     </a>
     <span class="koboSpan" id="kobo.1364.1">
      main thread.
     </span>
     <span class="koboSpan" id="kobo.1364.2">
      Code within the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1365.1">
       else
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1366.1">
      block will be executed in the worker.
     </span>
     <span class="koboSpan" id="kobo.1366.2">
      Add the following
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1367.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1368.1">
        hello-worker.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1369.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1370.1">
if (isMainThread) {
  // Main thread code
} else {
  // Worker code
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1371.1">
      Now, let’s populate the main thread code.
     </span>
     <span class="koboSpan" id="kobo.1371.2">
      First, create a new worker and pass the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1372.1">
       Worker
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1373.1">
      constructor two arguments.
     </span>
     <span class="koboSpan" id="kobo.1373.2">
      The first argument will be the filename of the worker’s main script or module.
     </span>
     <span class="koboSpan" id="kobo.1373.3">
      In this case, we’ll use
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1374.1">
       __filename
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1375.1">
      to reference our current file.
     </span>
     <span class="koboSpan" id="kobo.1375.2">
      The second parameter will be an
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1376.1">
       options
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1377.1">
      object, which will specify a
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1378.1">
       workerData
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1379.1">
      property that holds the name we want to pass through to the worker thread.
     </span>
     <span class="koboSpan" id="kobo.1379.2">
      The
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1380.1">
       workerData
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1381.1">
      property is used to share values with the worker thread.
     </span>
     <span class="koboSpan" id="kobo.1381.2">
      Add the following line under the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1382.1">
       // Main thread
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1383.1">
        code
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1384.1">
       comment:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1385.1">
  const worker = new Worker(__filename, {
    workerData: 'Beth'
  });</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1386.1">
      Now, expect the worker thread to pass a value back to the main thread.
     </span>
     <span class="koboSpan" id="kobo.1386.2">
      To capture this, we can create a worker message event listener.
     </span>
     <span class="koboSpan" id="kobo.1386.3">
      Add the following line below the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1387.1">
       worker initialization:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1388.1">
  worker.on('message', (msg) =&gt; {
    console.log(msg);
  });</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1389.1">
      Now, we can write the worker code that will construct the greeting.
     </span>
     <span class="koboSpan" id="kobo.1389.2">
      Using the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1390.1">
       parentPort.postMessage()
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1391.1">
      method will return the value to our main thread.
     </span>
     <span class="koboSpan" id="kobo.1391.2">
      Add the
     </span>
     <a id="_idIndexMarker845">
     </a>
     <span class="koboSpan" id="kobo.1392.1">
      following code below the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1393.1">
       // Worker
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1394.1">
        code
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1395.1">
       comment:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1396.1">
  const greeting = `Hello ${workerData}!`;
  parentPort.postMessage(greeting);</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1397.1">
      Now, run the program with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1398.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1399.1">$ node hello-worker.js</span></strong><span class="koboSpan" id="kobo.1400.1">
Hello Beth!</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1401.1">
      Now, let’s try something CPU-intensive and compare the behaviors when using and not using worker threads.
     </span>
     <span class="koboSpan" id="kobo.1401.2">
      First, create a file named
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1402.1">
       fibonacci.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1403.1">
      .
     </span>
     <span class="koboSpan" id="kobo.1403.2">
      This will contain a Fibonacci calculator program that returns the Fibonacci number at a given index.
     </span>
     <span class="koboSpan" id="kobo.1403.3">
      Create the
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1404.1">
        fibonacci.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1405.1">
       file:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1406.1">$ touch fibonacci.js</span></strong></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1407.1">
      Add the following
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1408.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1409.1">
        fibonacci.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1410.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1411.1">
const n = 10;
// Fibonacci calculator
const fibonacci = (n) =&gt; {
  let a = 0;
  let b = 1;
  let next = 1;
  let i = 2;
  for (i; i &lt;= n; i++) {
    next = a + b;
    a = b;
    b = next;
  }
  console.log(`The Fibonacci number at position ${n} is ${next}`);
};
fibonacci(n);
console.log('...');</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1412.1">
      Run the script
     </span>
     <a id="_idIndexMarker846">
     </a>
     <span class="koboSpan" id="kobo.1413.1">
      with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1414.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1415.1">$ node fibonacci.js</span></strong><span class="koboSpan" id="kobo.1416.1">
The Fibonacci number at position 10 is 55
...</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.1417.1">
       In this case, the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1418.1">
        fibonacci()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1419.1">
       function blocks the execution of
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1420.1">
        console.log("...");
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1421.1">
       until the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1422.1">
        fibonacci()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1423.1">
       function has
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1424.1">
        finished running.
       </span>
      </span>
     </p>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1425.1">
      Now, let’s try writing it using worker threads to see how we can avoid blocking the main thread.
     </span>
     <span class="koboSpan" id="kobo.1425.2">
      Create a file
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1426.1">
       named
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1427.1">
        fibonacci-worker.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1428.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1429.1">
$ touch fibonacci-worker.js</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1430.1">
      Start by adding the following imports
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1431.1">
       to
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1432.1">
        fibonacci-worker.js
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1433.1">
       :
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1434.1">
const {
  Worker,
  isMainThread,
  parentPort,
  workerData
} = require('node:worker_threads');</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1435.1">
      Next, as we
     </span>
     <a id="_idIndexMarker847">
     </a>
     <span class="koboSpan" id="kobo.1436.1">
      did in
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1437.1">
       fibonacci.js
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1438.1">
      in
     </span>
     <em class="italic">
      <span class="koboSpan" id="kobo.1439.1">
       Step 8
      </span>
     </em>
     <span class="koboSpan" id="kobo.1440.1">
      , add the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1441.1">
       Fibonacci
      </span>
     </strong>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1442.1">
        calculator
       </span>
      </strong>
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1443.1">
       function:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1444.1">
const n = 10;
// Fibonacci calculator
const fibonacci = (n) =&gt; {
  let a = 0;
  let b = 1;
  let next = 1;
  let i = 2;
  for (i; i &lt;= n; i++) {
    next = a + b;
    a = b;
    b = next;
  }
  return next;
};</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1445.1">
      Finally, we can implement the structure that enables us to use the
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1446.1">
       worker
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1447.1">
      thread.
     </span>
     <span class="koboSpan" id="kobo.1447.2">
      Add the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1448.1">
       following code:
      </span>
     </span>
     <pre class="source-code"><span class="koboSpan" id="kobo.1449.1">
if (isMainThread) {
  // Main thread code
  const worker = new Worker(__filename, {
    workerData: n
  });
  worker.on('message', (msg) =&gt; {
    console.log(`The Fibonacci number at position ${n} is ${msg}`);
  });
  console.log('...');
} else {
  // Worker code
  parentPort.postMessage(fibonacci(workerData));
}</span></pre>
    </li>
    <li>
     <span class="koboSpan" id="kobo.1450.1">
      Now, run this
     </span>
     <a id="_idIndexMarker848">
     </a>
     <span class="koboSpan" id="kobo.1451.1">
      script with the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1452.1">
       following command:
      </span>
     </span>
     <pre class="source-code">
<strong class="bold"><span class="koboSpan" id="kobo.1453.1">$ node fibonacci-worker.js</span></strong><span class="koboSpan" id="kobo.1454.1">
...
</span><span class="koboSpan" id="kobo.1454.2">The Fibonacci number at position 10 is 55</span></pre>
     <p class="list-inset">
      <span class="koboSpan" id="kobo.1455.1">
       Observe that
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1456.1">
        console.log("...");
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1457.1">
       is being printed before the result of the
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1458.1">
        fibonacci()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1459.1">
       function returns.
      </span>
      <span class="koboSpan" id="kobo.1459.2">
       The
      </span>
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1460.1">
        fibonacci()
       </span>
      </strong>
      <span class="koboSpan" id="kobo.1461.1">
       function has been offloaded to the worker thread, meaning work on the main thread
      </span>
      <span class="No-Break">
       <span class="koboSpan" id="kobo.1462.1">
        can continue.
       </span>
      </span>
     </p>
    </li>
   </ol>
   <p>
    <span class="koboSpan" id="kobo.1463.1">
     With that, we’ve learned how to offload tasks to a worker thread using the Node.js core
    </span>
    <span class="No-Break">
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1464.1">
       worker_threads
      </span>
     </strong>
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1465.1">
      module.
     </span>
    </span>
   </p>
   <h2 id="_idParaDest-344">
    <a id="_idTextAnchor352">
    </a>
    <span class="koboSpan" id="kobo.1466.1">
     How it works…
    </span>
   </h2>
   <p>
    <span class="koboSpan" id="kobo.1467.1">
     This recipe served as an introduction to worker threads.
    </span>
    <span class="koboSpan" id="kobo.1467.2">
     As we’ve seen, worker threads can be used to handle CPU-intensive computations.
    </span>
    <span class="koboSpan" id="kobo.1467.3">
     Offloading CPU-intensive computations to a worker thread can help avoid blocking the Node.js event loop.
    </span>
    <span class="koboSpan" id="kobo.1467.4">
     This means the application can continue to handle other work – for example, I/O operations – while CPU-intensive
    </span>
    <a id="_idIndexMarker849">
    </a>
    <span class="koboSpan" id="kobo.1468.1">
     tasks are
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1469.1">
      being processed.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1470.1">
     Worker threads are exposed via the core Node.js
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1471.1">
      worker_threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1472.1">
     module.
    </span>
    <span class="koboSpan" id="kobo.1472.2">
     To use a worker thread in this recipe, we imported the following four assets from the
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1473.1">
      worker_threads
     </span>
    </strong>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1474.1">
      core module:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1475.1">
       Worker
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1476.1">
      : The worker thread class, which represents an independent
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1477.1">
       JavaScript thread.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1478.1">
       isMainThread
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1479.1">
      : A property that returns
     </span>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1480.1">
       true
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1481.1">
      if the code isn’t running in a
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1482.1">
       worker thread.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1483.1">
       parentPort
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1484.1">
      : This is a message port that allows communication from the worker to the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1485.1">
       parent thread.
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1486.1">
       workerData
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1487.1">
      : This property clones the data that’s passed in the worker thread constructor.
     </span>
     <span class="koboSpan" id="kobo.1487.2">
      This is how the initial data from the main thread is passed to the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1488.1">
       worker thread.
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1489.1">
     In this recipe, we initialized a worker thread with the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1490.1">
      following code:
     </span>
    </span>
   </p>
   <pre class="source-code"><span class="koboSpan" id="kobo.1491.1">
  const worker = new Worker(__filename, {
    workerData: n,
  });</span></pre>
   <p>
    <span class="koboSpan" id="kobo.1492.1">
     The
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1493.1">
      Worker
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1494.1">
     constructor requires a mandatory first argument – that is, a filename.
    </span>
    <span class="koboSpan" id="kobo.1494.2">
     This filename is the path to the worker thread’s main script
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1495.1">
      or module.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1496.1">
     The second argument is an
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1497.1">
      options
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1498.1">
     object, which can accept many different configuration options.
    </span>
    <span class="koboSpan" id="kobo.1498.2">
     In
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1499.1">
      fibonacci-worker.js
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1500.1">
     , we provided just one configuration option,
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1501.1">
      workerData
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1502.1">
     , to pass the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1503.1">
      n
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1504.1">
     to the worker thread.
    </span>
    <span class="koboSpan" id="kobo.1504.2">
     The full list of options that can be passed via the worker thread’s
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1505.1">
      options
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1506.1">
     object is listed in the Node.js
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1507.1">
      worker_threads
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1508.1">
     API
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1509.1">
      documentation (
     </span>
    </span>
    <a href="https://nodejs.org/api/worker_threads.html#worker_threads_new_worker_filename_options">
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1510.1">
       https://nodejs.org/api/worker_threads.html#worker_threads_new_worker_filename_options
      </span>
     </span>
    </a>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1511.1">
      ).
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1512.1">
     Once the worker has been initialized, we can register event listeners on it.
    </span>
    <span class="koboSpan" id="kobo.1512.2">
     In this recipe, we registered a message event listener function that executes every time a message is received from the worker.
    </span>
    <span class="koboSpan" id="kobo.1512.3">
     The
    </span>
    <a id="_idIndexMarker850">
    </a>
    <span class="koboSpan" id="kobo.1513.1">
     following events can be listened for on
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1514.1">
      a worker:
     </span>
    </span>
   </p>
   <ul>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1515.1">
       error
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1516.1">
      : Emitted when the worker thread throws an
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1517.1">
       uncaught exception
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1518.1">
       exit
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1519.1">
      : Emitted once the worker thread has stopped
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1520.1">
       executing code
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1521.1">
       message
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1522.1">
      : Emitted when the worker thread emits a message
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1523.1">
       using
      </span>
     </span>
     <span class="No-Break">
      <strong class="source-inline">
       <span class="koboSpan" id="kobo.1524.1">
        parentPort.postMessage()
       </span>
      </strong>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1525.1">
       messagerror
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1526.1">
      : Emitted when deserializing the
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1527.1">
       message fails
      </span>
     </span>
    </li>
    <li>
     <strong class="source-inline">
      <span class="koboSpan" id="kobo.1528.1">
       online
      </span>
     </strong>
     <span class="koboSpan" id="kobo.1529.1">
      : Emitted when the worker thread starts executing
     </span>
     <span class="No-Break">
      <span class="koboSpan" id="kobo.1530.1">
       JavaScript code
      </span>
     </span>
    </li>
   </ul>
   <p>
    <span class="koboSpan" id="kobo.1531.1">
     We use
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1532.1">
      parentPort.postMessage()
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1533.1">
     to send the value of
    </span>
    <strong class="source-inline">
     <span class="koboSpan" id="kobo.1534.1">
      fibonacci(n)
     </span>
    </strong>
    <span class="koboSpan" id="kobo.1535.1">
     back to the parent thread.
    </span>
    <span class="koboSpan" id="kobo.1535.2">
     In the parent thread, we register a message event listener to detect incoming
    </span>
    <a id="_idIndexMarker851">
    </a>
    <span class="koboSpan" id="kobo.1536.1">
     messages from the
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1537.1">
      worker thread.
     </span>
    </span>
   </p>
   <p>
    <span class="koboSpan" id="kobo.1538.1">
     With that, we’ve introduced worker threads and showcased how they can be used to handle
    </span>
    <span class="No-Break">
     <span class="koboSpan" id="kobo.1539.1">
      CPU-intensive tasks.
     </span>
    </span>
   </p>
  </div>
 </body></html>