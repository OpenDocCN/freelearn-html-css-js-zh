- en: Functional Programming Learning Road Map
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following guide can be used to track our level of knowledge regarding functional
    programming. This guide was developed for the *Fantasyland* institute of learning
    for the *LambdaConf* conference. It was designed for statically-typed functional
    programming languages that implement category theory.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Languages such as Haskell support category theory natively, but, as we learned
    previously, we can take advantage of category theory in TypeScript by implementing
    it or using some third-party libraries. Not all the items in the list are 100%
    applicable to TypeScript due to language differences, but most of them are 100%
    applicable.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Beginner
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reach the *beginner* level, you will need to master the following concepts
    and skills:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '| **CONCEPTS** | **SKILLS** |'
  id: totrans-5
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second-order functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructoring and destructuring
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-class functions and lambdas
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Use second-order functions (`map`, `filter`, `fold`) on immutable data structures
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructure values to access their components
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use data types to represent optionality
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read basic type signatures
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass lambdas to second-order functions
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: Advanced beginner
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reach the *advanced beginner* level, you will need to master the following
    concepts and skills:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: '| **CONCEPTS** | **SKILLS** |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic data types
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parametric polymorphism
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General recursion
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type classes, instances, and laws
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower-order abstractions (equal, semigroup, monoid, and so on)
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referential transparency and totality
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial application, currying, and point-free style
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: Solve problems without nulls, exceptions, or type casts
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process and transform recursive data structures using recursion
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to use functional programming *in the small*
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write basic monadic code for a concrete monad
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create type class instances for custom data types
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model a business domain with **abstract data types** (**ADTs**)
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write functions that take and return functions
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliably identify and isolate pure code from impure code
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid introducing unnecessary lambdas and named parameters
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reach the *intermediate* level, you will need to master the following concepts
    and skills:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '| **CONCEPTS** | **SKILLS** |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
- en: '|'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Generalized algebraic data type
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-kinded types
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rank-N types
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folds and unfolds
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order abstractions (category, functor, monad)
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic optics
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement efficient persistent data structures
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existential types
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded DSLs using combinators
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: Able to implement large functional programming applications
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test code using generators and properties
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write imperative code in a purely functional way through monads
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use popular purely functional libraries to solve business problems
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate decision from effects
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a simple custom lawful monad
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write production medium-sized projects
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lenses and prisms to manipulate data
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify types by hiding irrelevant data with existential
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Proficient
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reach the *proficient* level, you will need to master the following concepts
    and skills:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到**熟练**水平，你需要掌握以下概念和技能：
- en: '| **CONCEPTS** | **SKILLS** |'
  id: totrans-69
  prefs: []
  type: TYPE_TB
  zh: '| **概念** | **技能** |'
- en: '|'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Codata
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Codata
- en: (Co)recursion schemes
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （共）递归方案
- en: Advanced optics
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级光学
- en: Dual abstractions (comonad)
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 双重抽象（comonad）
- en: Monad transformers
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单子变换器
- en: Free monads and extensible effects
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自由单子和可扩展效应
- en: Functional architecture
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数架构
- en: Advanced functors (exponential, profunctors, contravariant)
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级函子（指数， profunctors，逆变）
- en: Embedded **domain-specific languages** (**DSLs**) using **generalized algebraic
    datatypes** (**GADTs**)
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**泛化代数数据类型**（**GADTs**）嵌入**领域特定语言**（**DSLs**）
- en: Advanced monads (continuation, logic)
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级单子（延续，逻辑）
- en: Type families, **functional dependencies** (**FDs**)
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型族，**函数依赖**（**FDs**）
- en: '|'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Design a minimally powerful monad transformer stack
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个最小化强大的单子变换器堆栈
- en: Write concurrent and streaming programs
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写并发和流程序
- en: Use purely functional mocking in tests.
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在测试中使用纯函数模拟
- en: Use type classes to modularly model different effects
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用类型类以模块化方式建模不同的效应
- en: Recognize type patterns and abstract over them
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别类型模式并在其上抽象
- en: Use functional libraries in novel ways
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 以新颖的方式使用函数库
- en: Use optics to manipulate state
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用光学来操作状态
- en: Write custom lawful monad transformers
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写定制的合法单子变换器
- en: Use free monads/extensible effects to separate concerns
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用自由单子/可扩展效应来分离关注点
- en: Encode invariants at the type level.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在类型级别编码不变量。
- en: Effectively use FDs/type families to create safer code
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有效使用FDs/类型族来创建更安全的代码
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Expert
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 专家
- en: 'To reach the *expert* level, you will need to master the following concepts
    and skills:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要达到**专家**水平，你需要掌握以下概念和技能：
- en: '| **CONCEPTS** | **SKILLS** |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| **概念** | **技能** |'
- en: '|'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: High performance
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高性能
- en: Kind polymorphism
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型多态
- en: Generic programming
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型编程
- en: Type-level programming
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型级编程
- en: Dependent-types, singleton types
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖类型，单例类型
- en: Category theory
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类别理论
- en: Graph reduction
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图归约
- en: Higher-order abstract syntax
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高阶抽象语法
- en: Compiler design for functional languages
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 函数语言的编译器设计
- en: Profunctor optics
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Profunctor optics
- en: '|'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Design a generic, lawful library with broad appeal
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计一个通用、合法的库，具有广泛的吸引力
- en: Prove properties manually using equational reasoning
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用等价推理手动证明属性
- en: Design and implement a new functional programming language
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计和实现一个新的函数式编程语言
- en: Create novel abstractions with laws
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用法则创建新颖的抽象
- en: Write distributed systems with certain guarantees
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写具有某些保证的分布式系统
- en: Use proof systems to formally prove properties of code
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用证明系统正式证明代码的性质
- en: Create libraries that do not permit invalid states.
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建不允许无效状态的库。
- en: Use dependent typing to prove more properties at compile time
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用依赖类型在编译时证明更多属性
- en: Understand deep relationships between different concepts
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解不同概念之间的深层关系
- en: Profile, debug, and optimize purely functional code with minimal sacrifices
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用最小牺牲对纯函数代码进行性能分析、调试和优化
- en: '|'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Summary
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This guide should be a good resource to guide you in your future functional-programming
    learning efforts. In this book, we started without any previous knowledge of functional
    programming, and we have reached the *intermediate* level. Becoming an expert
    on functional programming will take some time, but at this point, we know enough
    about it to take advantage of its capabilities and enjoy its main benefits.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这份指南应该是一个很好的资源，可以帮助你在未来的函数式编程学习上取得进步。在这本书中，我们没有任何函数式编程的先验知识，我们已经达到了**中级**水平。成为函数式编程的专家需要一些时间，但在这个阶段，我们对其了解足够，可以充分利用其功能并享受其主要好处。
