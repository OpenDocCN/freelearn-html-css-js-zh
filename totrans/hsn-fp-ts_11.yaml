- en: Functional Programming Learning Road Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following guide can be used to track our level of knowledge regarding functional
    programming. This guide was developed for the *Fantasyland* institute of learning
    for the *LambdaConf* conference. It was designed for statically-typed functional
    programming languages that implement category theory.
  prefs: []
  type: TYPE_NORMAL
- en: Languages such as Haskell support category theory natively, but, as we learned
    previously, we can take advantage of category theory in TypeScript by implementing
    it or using some third-party libraries. Not all the items in the list are 100%
    applicable to TypeScript due to language differences, but most of them are 100%
    applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Beginner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reach the *beginner* level, you will need to master the following concepts
    and skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CONCEPTS** | **SKILLS** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Immutable data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Second-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructoring and destructuring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: First-class functions and lambdas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Use second-order functions (`map`, `filter`, `fold`) on immutable data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destructure values to access their components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use data types to represent optionality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read basic type signatures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pass lambdas to second-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Advanced beginner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reach the *advanced beginner* level, you will need to master the following
    concepts and skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CONCEPTS** | **SKILLS** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Algebraic data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parametric polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: General recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type classes, instances, and laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lower-order abstractions (equal, semigroup, monoid, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referential transparency and totality
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Partial application, currying, and point-free style
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Solve problems without nulls, exceptions, or type casts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Process and transform recursive data structures using recursion
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Able to use functional programming *in the small*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write basic monadic code for a concrete monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create type class instances for custom data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Model a business domain with **abstract data types** (**ADTs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write functions that take and return functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reliably identify and isolate pure code from impure code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid introducing unnecessary lambdas and named parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Intermediate
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reach the *intermediate* level, you will need to master the following concepts
    and skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CONCEPTS** | **SKILLS** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Generalized algebraic data type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-kinded types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rank-N types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folds and unfolds
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order abstractions (category, functor, monad)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic optics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implement efficient persistent data structures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Existential types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded DSLs using combinators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Able to implement large functional programming applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Test code using generators and properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write imperative code in a purely functional way through monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use popular purely functional libraries to solve business problems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Separate decision from effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write a simple custom lawful monad
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write production medium-sized projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use lenses and prisms to manipulate data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Simplify types by hiding irrelevant data with existential
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Proficient
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reach the *proficient* level, you will need to master the following concepts
    and skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CONCEPTS** | **SKILLS** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Codata
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: (Co)recursion schemes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced optics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dual abstractions (comonad)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monad transformers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Free monads and extensible effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Functional architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced functors (exponential, profunctors, contravariant)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Embedded **domain-specific languages** (**DSLs**) using **generalized algebraic
    datatypes** (**GADTs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced monads (continuation, logic)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type families, **functional dependencies** (**FDs**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Design a minimally powerful monad transformer stack
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write concurrent and streaming programs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use purely functional mocking in tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use type classes to modularly model different effects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Recognize type patterns and abstract over them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use functional libraries in novel ways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use optics to manipulate state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write custom lawful monad transformers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use free monads/extensible effects to separate concerns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encode invariants at the type level.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Effectively use FDs/type families to create safer code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Expert
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To reach the *expert* level, you will need to master the following concepts
    and skills:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **CONCEPTS** | **SKILLS** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: High performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Kind polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Type-level programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dependent-types, singleton types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Category theory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph reduction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher-order abstract syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compiler design for functional languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profunctor optics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Design a generic, lawful library with broad appeal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Prove properties manually using equational reasoning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Design and implement a new functional programming language
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create novel abstractions with laws
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Write distributed systems with certain guarantees
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use proof systems to formally prove properties of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create libraries that do not permit invalid states.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use dependent typing to prove more properties at compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand deep relationships between different concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Profile, debug, and optimize purely functional code with minimal sacrifices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This guide should be a good resource to guide you in your future functional-programming
    learning efforts. In this book, we started without any previous knowledge of functional
    programming, and we have reached the *intermediate* level. Becoming an expert
    on functional programming will take some time, but at this point, we know enough
    about it to take advantage of its capabilities and enjoy its main benefits.
  prefs: []
  type: TYPE_NORMAL
