- en: Modules and Toolkits
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have reviewed what Node.js's new features are, and now that we know
    what a microservice is, it's time to see what tools or modules we can we to create
    one. We'll review a couple of options and build a more or less simple microservice
    so that we can point out advantages and disadvantages for each approach.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll look at different modules:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: '**Seneca**: A microservice toolkit based on property matching'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Hydra**: A package that bundles a couple of modules to help you resolve many
    microservices concerns, such as distribution and monitoring'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seneca
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at framework called Seneca which was designed to help you develop
    message-based microservices. It has two distinct characteristics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: '**T****ransport agnostic**: Communication and message transport is separated
    from your service logic and it''s easy to swap transports'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Pattern matching**: Messages are JSON objects and each function exposes what
    sort of messages they can handle based on object properties'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'What is really interesting about Seneca is its ability to expose functions
    based on object patterns. Let''s start by installing Seneca:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'For now, let''s forget the transport and create a producer and consumer in
    the same file. Let''s look at an example:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We first include the `seneca` module and create a new service. We then expose
    a producer function that matches an object that has `math` equal to `sum`. This
    means that any request object to the service that has the property `math` and
    that is equal to `sum` will be passed to this function. This function accepts
    two arguments. The first, which we called `msg`, is the request object. The second
    argument, `next`, is the callback that the function should invoke when finished
    or in case of an error. In this particular case, we're expecting an object that
    also has a `values` list and we're returning the sum of all values by using the
    `reduce` method that's available in arrays. Finally, we invoke `act`, expecting
    it to consume our producer. We pass an object with the `math` equal to `sum` and
    a list of `values`. Our producer should be invoked and should return the sum.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming you have this code in `app.js`, if you run this in the command line,
    you should see something like this:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let's try and replicate our previous stack example. This time, instead of having
    the consumer and producer in the code, we'll use `curl` as the consumer, just
    like we did previously.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create our `service`. We do that, as we''ve seen before,
    by loading Seneca and creating an instance:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We explicitly tell it that we don''t care about logging for now. Now, let''s
    create a variable to hold our stack:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We then create our producers. We''ll create three of them: one for adding an
    element to the stack, called push; one to remove the last element from the stack,
    called pop; and one to see the stack, called get. Both push and pop will return
    the final stack result. The third producer is just a helper function so that we
    can see the stack without performing any operations.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'To add elements to the stack, we define:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There are a few new things to see here:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: We defined our pattern as a string instead of an object. This action string
    is a shortcut to the extended object definition.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explicitly indicate that we need a value.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also indicate that we don't care what the value is (remember, this is pattern
    matching).
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We now define a simpler function to remove the last element of the `stack`:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This one is simpler as we don't need a value, we're just removing the last one.
    We're not addressing the case where the stack is empty already. An empty array
    won't throw an exception, but perhaps, in a real scenario, you would want another
    response.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'Our third function is even simpler as we just return the `stack`:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally, we need to tell our `service` to listen for messages. The default
    transport is HTTP and we just indicate port `3000` as we did in our previous examples:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Wrap all this code in a file and try it out. You can use curl or just try it
    in your browser. Seneca won''t differentiate between HTTP verbs in this case.
    Let''s begin by checking our `stack`. The URL describes an action (`/act`) we
    want to perform and the query parameter gets converted to our pattern:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f272cfa-7bc7-445b-b506-7494b9365918.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: 'We can then try adding the value `one` to our `stack` and see the final `stack`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fd2bb60-ddae-48aa-a36f-8150eb30f4f6.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
- en: 'We can continue and add the value `two` and see how the `stack` grows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9765d76f-b004-469f-9582-fbeebe6a33df.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
- en: 'If we then try to remove the last element, we''ll see the `stack` shrinking:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5d18267f-0b27-4d44-acc9-af7b2ef87ed1.png)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
- en: As in Express, Seneca also has middleware that you can install and use. In this
    case, the middleware is called plugins. By default, Seneca includes a number of
    core plugins for transport, and both HTTP and TCP transports are supported. There
    are more transports available, such as **Advanced Message Queuing Protocol** (**AMQP**)
    and Redis.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'There are also storage plugins for persistent data and there''s support for
    several database servers, both relational and non-relational. Seneca exposes an
    **o****bject-relational mapping** (**ORM**)-like interface to manage data entities.
    You can manipulate entities and use a simple storage in development and then move
    to production storage later on. Let''s see a more complex example of this:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Just run this new code and we''ll see how this code behaves by making some
    requests to test it. First, let''s see how our `stack` is by requesting it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8562bd7e-ce15-4e5f-ab0e-afd983610ba2.png)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
- en: 'Nothing different. Now, let''s add the value `one` to the `stack`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5e8c79dc-6ed3-4ccd-a429-7bc3cdcf5621.png)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
- en: 'Well, we haven''t received the final `stack`. We could, but instead we changed
    the service to return the exact item that was added. It''s actually a good way
    to confirm what we just did. Let''s add another one:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d0a0b98b-9518-4224-8496-916a3097902b.png)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
- en: 'Again, it returns the value we just added. Now, let''s see how our stack is:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5189716-9284-48e2-b6bc-a82ebaa670cc.png)'
  id: totrans-53
  prefs: []
  type: TYPE_IMG
- en: Our `stack` now has our two values. Now comes one big difference compared with
    the previous code. We're using *entities*, an API exposed by Seneca, which helps
    you store and manipulate data objects using a simple abstraction layer similar
    to an ORM, or to people who are familiar with Ruby, an `ActiveRecord`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new code, instead of just popping out the last value, removes a value we
    indicate. So, let''s remove the value `one` instead of `two`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf96bdff-3fd7-4ba4-b597-8a39a1e10cf1.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
- en: 'Success! We removed exactly one item. Our code will remove all items from the
    `stack` that match the value (it has no duplication check so you can have repeated
    items). Let''s try to remove the same item again:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/98a3dabd-f496-4b1a-a365-6e95ee918e80.png)'
  id: totrans-58
  prefs: []
  type: TYPE_IMG
- en: 'No more items match `one`, so it didn''t remove anything. We can now check
    our `stack` and confirm that we still have the value `two`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8ddfe232-1446-4940-9a93-75ed0c3d7690.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
- en: Correct! And, as a bonus, you can stop and restart the code and your stack will
    still have the value `two`. That's because we're using the JSON file store plugin.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: When testing using Chrome or any other browser, be aware that sometimes, browsers
    make requests in advance while you're typing. Because we already tested our first
    code, which had the same URL addresses, the browser might duplicate requests and
    you might get a stack with duplicated values without knowing why. This is why.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Hydra
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's get back to Express. As you've seen before, it's a rock-solid layer on
    top of the `http` module. Although it adds an important base layer in the somewhat
    raw module, it still lacks many features you need to make a good microservice.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: As there are lots of plugins out there to extend Express, it can be hard to
    pick a useful list for us to use.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'After picking the right list, you''ll still need to make other decisions:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: How can I distribute my service with multiple instances?
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can the service be discovered?
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How can I monitor whether my service is running properly?
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enter Hydra, a framework that facilitates building distributed microservices.
    Hydra leverages the power of Express and helps you create microservices or communicate
    with microservices.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: 'It will, out of the box, enable you to:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: Do service registration and service discovery, allowing your microservices to
    discover and be discoverable
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communicate with microservices and load balance communication between multiple
    instances, taking care of failed instances and automatically rerouting requests
    to other running instances
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor instances, checking whether the microservice is available and operating
    normally
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Unlike the other modules we''ve reviewed so far, Hydra has a dependency that
    is not installable directly using the NPM. Hydra uses Redis to accomplish its
    goal. Look for information on the Redis website at [https://redis.io/](https://redis.io/)
    to install it on your operating system before continuing. If you have macOS and
    use Homebrew, type the following to install `redis`:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dfdb0104-7906-4919-ad18-48f4839b8d5d.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s make sure `redis` has successfully started:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/df9525cb-5e2b-44ca-9948-288dff2a4572.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: 'After that, we need to install Hydra command-line tools:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We now need to configure the connection to Redis. We do this by creating a
    configuration. Type in the command and follow the instructions. If you installed
    it locally (or used the preceding instructions), you should answer something similar
    to the following screenshot:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/130a1c25-01fb-4389-8c74-a56a66fd5fcc.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create a very simple microservice, just to see what the workflow
    is like. Hydra has a scaffolding tool using `yeoman`. To create a service, type
    the following command and follow the instructions:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d00ff9e-fda1-423a-a9bc-edda341e9ba6.png)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
- en: 'On the name of the service, just type hello. Just hit *Enter* to the rest of
    the questions to use the defaults. In the end, enter the folder that was created
    and install the dependencies:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/11d89f4f-7424-42a5-8cdd-01f69cc1d427.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
- en: 'The service is now ready to start. You might have already seen the instructions
    when scaffolding the service. Let''s start the service:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b745a179-c4e5-461a-abbc-4a6bf684b7f6.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
- en: 'As we can see from the preceding screenshot, the service has started and has
    been attached to a local IP (192.168.1.108) and port (45394). Open up the folder
    in your code editor:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/774328d2-8714-43d2-8db1-85995dce6e95.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
- en: 'You''ll see a file in the base folder called `hello-service.js`, which has
    the service routes inside it. You''ll find the `/v1/hello` route, which points
    to another file in `routes/hello-v1-routes.js`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ebd2d928-eeac-4e32-a563-343dbc72f82f.png)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: 'Inside that file, you''ll see the response to that route. Now, let''s jump
    to a web browser and see if it''s up and running:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8b40b263-ed17-48dd-bcab-979f1083384d.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
- en: What we saw in the file is inside the result property of the JSON response.
    We just deployed our first Hydra microservice without writing a single line of
    code!
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've just covered a range of different modules and toolkits to help develop
    microservices. From patterns in Seneca, to the Hydra bundle, many approaches are
    available.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: They all target different audiences and fill different needs. I would advise
    you to experiment with some of them to help you make a better choice instead of
    just picking one.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Let's dig into some of these tools and start creating a more complete microservice.
    In the next chapter, we'll be making a useful microservice, covering different
    use cases, while we develop a fully functional and distributed microservice.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入研究这些工具，并开始创建一个更完整的微服务。在下一章中，我们将构建一个有用的微服务，涵盖不同的用例，同时开发一个功能齐全且分布式的微服务。
