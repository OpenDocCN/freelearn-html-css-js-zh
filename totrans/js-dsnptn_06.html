<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-68"><a id="_idTextAnchor130" class="pcalibre1 calibre6 pcalibre"/>4</h1>
<h1 id="_idParaDest-69" class="calibre5"><a id="_idTextAnchor131" class="pcalibre1 calibre6 pcalibre"/>Exploring Reactive View Library Patterns</h1>
<p class="calibre3">Reactive view library patterns <a id="_idIndexMarker168" class="pcalibre1 calibre6 pcalibre"/>give us tools to build applications in a scalable and maintainable manner when we could benefit from breaking out of the component primitive. Using the React view library, we’ll cover different techniques for going beyond component-based composition to inject functionality into our components – the render prop, a higher-order component, hooks, and provider patterns.</p>
<p class="calibre3">We’ll cover the following main topics in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">An introduction to reactive view library patterns and where we can benefit the most by using them</li>
<li class="calibre11">Examples and implementation approaches for the render prop pattern</li>
<li class="calibre11">Implementing and using the higher-order component pattern</li>
<li class="calibre11">Using hooks to build React function components</li>
<li class="calibre11">Multiple ways to implement the provider pattern</li>
</ul>
<p class="calibre3">By the end of this chapter, you’ll be able to discern when and how to use Reactive view library patterns to build React applications.</p>
<h1 id="_idParaDest-70" class="calibre5"><a id="_idTextAnchor132" class="pcalibre1 calibre6 pcalibre"/>Technical requirements</h1>
<p class="calibre3">To follow along in this chapter, you’ll need the following:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Node.js </strong><strong class="bold">20+</strong>: <a href="https://nodejs.org/en" class="pcalibre1 calibre6 pcalibre">https://nodejs.org/en</a></li>
<li class="calibre11"><strong class="bold">Npm 8+</strong>: Comes with most Node.js installations</li>
<li class="calibre11"><a href="https://parceljs.org/" class="pcalibre1 calibre6 pcalibre">https://parceljs.org/</a> is used in some examples and has similar platform support to Node.js</li>
<li class="calibre11"><strong class="bold">React</strong>: React DOM and Formik are installed via npm; an understanding of <a href="https://react.dev/" class="pcalibre1 calibre6 pcalibre">https://react.dev/</a> basics in a web context is required</li>
</ul>
<p class="calibre3">You can find the code files for this chapter on GitHub at <a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre">https://github.com/PacktPublishing/Javascript-Design-Patterns</a></p>
<h1 id="_idParaDest-71" class="calibre5"><a id="_idTextAnchor133" class="pcalibre1 calibre6 pcalibre"/>What are reactive view library patterns?</h1>
<p class="calibre3">Reactive view<a id="_idIndexMarker169" class="pcalibre1 calibre6 pcalibre"/> libraries are extensively used for JavaScript and web frontend development. A few<a id="_idIndexMarker170" class="pcalibre1 calibre6 pcalibre"/> very popular<a id="_idIndexMarker171" class="pcalibre1 calibre6 pcalibre"/> options<a id="_idIndexMarker172" class="pcalibre1 calibre6 pcalibre"/> are <strong class="bold">React</strong>, <strong class="bold">Angular</strong>, and <strong class="bold">Vue</strong>.</p>
<p class="calibre3">Reactive view libraries provide a way to write applications in a more scalable fashion by allowing the user interface (usually the browser) to react to changes in the data. Application development is, therefore, simplified, since the view library or framework takes care of all the direct manipulation necessary to maintain synchronization between the underlying data and the browser.</p>
<p class="calibre3">One of the key common denominators between these libraries and frameworks is the concept of a <strong class="bold">component</strong>, which<a id="_idIndexMarker173" class="pcalibre1 calibre6 pcalibre"/> contains business logic and/or rendering logic. The component is a key building block of an application. It can be reused or not, but it usually encapsulates a set of responsibilities and enforces interfaces around it.</p>
<p class="calibre3">A trait of components is that a developer should be able to use them as building blocks, and without component internals changing significantly, an application’s behavior can be changed significantly.</p>
<p class="calibre3">Reactive view library patterns, therefore, help us build components in a reusable fashion, but they also cover techniques to work around situations where the component abstraction has shortcomings.</p>
<p class="calibre3">In the following sections, we’ll cover the render props, higher-order component, hooks, and the provider pattern in React. We’ll be focusing on React, but the patterns have equivalents in Vue.</p>
<h1 id="_idParaDest-72" class="calibre5"><a id="_idTextAnchor134" class="pcalibre1 calibre6 pcalibre"/>The render prop pattern</h1>
<p class="calibre3">The render prop <a id="_idIndexMarker174" class="pcalibre1 calibre6 pcalibre"/>pattern is apparent <a id="_idIndexMarker175" class="pcalibre1 calibre6 pcalibre"/>when a component allows its consumer to define how a part of that component is rendered, via a function prop. These can be children as a function or another prop, which is a function that takes some parameters and returns JSX.</p>
<p class="calibre3">Render props allow for a level of inversion of control. Although a component could completely encapsulate rendering and business logic, it instead yields control of some parts of the rendering logic to its consumer.</p>
<p class="calibre3">Such inversion of control is useful to share logic without sharing the visuals or actually rendering the UI. Therefore, this pattern is widespread among libraries. A prime <a id="_idIndexMarker176" class="pcalibre1 calibre6 pcalibre"/>example is <strong class="bold">Formik</strong>, which gives consumers flexibility on how to <a id="_idIndexMarker177" class="pcalibre1 calibre6 pcalibre"/>render a form <a id="_idIndexMarker178" class="pcalibre1 calibre6 pcalibre"/>while providing an abstraction over the form’s state management logic.</p>
<h2 id="_idParaDest-73" class="calibre7"><a id="_idTextAnchor135" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor136" class="pcalibre1 calibre6 pcalibre"/>Use cases</h2>
<p class="calibre3">Let’s start with a <a id="_idIndexMarker179" class="pcalibre1 calibre6 pcalibre"/>scenario where we build a <code>CoupledSelect</code> component, which is a wrapper for the <code>select</code> native element. We’ll build this component in a way that the data and the rendering are closely coupled, providing a simple example of when render props can be useful.</p>
<p class="calibre3">A consumer’s expectation from <code>CoupledSelect</code> is that it would behave mostly like the <code>select</code> native element, with some caveats.</p>
<p class="calibre3">Our <code>CoupledSelect</code> component takes the following props:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1">selectedOption</strong>: This sets the selected option; it is akin to the selected prop on the <strong class="source-inline1">option</strong> native element</li>
<li class="calibre11"><strong class="source-inline1">options</strong>: This is an array of strings that are rendered as <strong class="source-inline1">option</strong> elements</li>
<li class="calibre11"><strong class="source-inline1">onChange</strong>: This is an optional callback for the component rendering <strong class="source-inline1">CoupledSelect</strong> to react to option selections</li>
</ul>
<p class="calibre3">We can implement it as follows. <code>CoupledSelect</code> will wrap around <code>onChange</code>, since it’s optional:</p>
<pre class="source-code">
import React from 'react';
export function CoupledSelect({ selectedOption, options,
  onChange }) {
  const onChangeHandler = (event) =&gt; {
    if (onChange) onChange(event.target.value);
  };
}</pre> <p class="calibre3">Let’s move on to the rendering logic. We’ll return a select element with <code>onChange={onChangeHandler}</code> and <code>value={selectedOption}</code> so that select will be in sync with <code>selectedOption</code> and propagate changes back:</p>
<pre class="source-code">
import React from 'react';
export function CoupledSelect({ selectedOption, options,
  onChange }) {
  const onChangeHandler = (event) =&gt; {
    if (onChange) onChange(event.target.value);
  };
  return &lt;select onChange={onChangeHandler}
    value={selectedOption}&gt;&lt;/select&gt;;
}</pre> <p class="calibre3">Finally, we’ll render the <code>props.options</code> using .map, which will return an &lt;<code>option</code>&gt; element, with the value and key properties set to option and whose content will be the <code>option</code> value also:</p>
<pre class="source-code">
export function CoupledSelect({ selectedOption, options,
  onChange }) {
  // no change to onChangeHandler
  return (
    &lt;select onChange={onChangeHandler}
      value={selectedOption}&gt;
      {options.map((option) =&gt; (
        &lt;option value={option} key={option}&gt;
          {option}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
}</pre> <p class="calibre3">Using our <code>CoupledSelect</code> might look something as follows.</p>
<p class="calibre3">We define an array of <a id="_idIndexMarker180" class="pcalibre1 calibre6 pcalibre"/>options. Here, we structure them as a list of objects with a <code>value</code> key that’s a string:</p>
<pre class="source-code">
const options = [
  { value: 'apple' },
  { value: 'pear' },
  { value: 'orange' },
  { value: 'grape' },
  { value: 'banana' },
];</pre> <p class="calibre3">We can then use <code>CoupledSelect</code> by ensuring that <code>props.options</code> is an array of strings:</p>
<pre class="source-code">
function App() {
  return (
    &lt;&gt;
      &lt;CoupledSelect
        options={options.map((option) =&gt; option.value)}
      /&gt;
    &lt;&gt;
  );
}</pre> <p class="calibre3">Next, we can save <code>selectedOption</code> by using the <code>useState </code>hook. We will name this particular piece of state <code>selectedOption</code> and its update function <code>setSelectedOption</code>. This will allow us to make <code>CoupledSelect</code> interactive:</p>
<pre class="source-code">
function App() {
  const [selectedOption, setSelectedOption] = useState();
  return (
    &lt;&gt;
      &lt;p&gt;Selected Option: {selectedOption}&lt;/p&gt;
      &lt;CoupledSelect
        selectedOption={selectedOption}
        onChange={(selectedOption) =&gt; setSelectedOption
          (selectedOption)}
        options={options.map((option) =&gt; option.value)}
      /&gt;
    &lt;&gt;
  );
}</pre> <p class="calibre3">Finally, we will set an initial <a id="_idIndexMarker181" class="pcalibre1 calibre6 pcalibre"/>value for <code>selectedOption</code> to show that this functionality of the <code>CoupledSelect</code> component works:</p>
<pre class="source-code">
function App() {
  const [selectedOption, setSelectedOption] = useState
    (options[3].value);
  // no change to the returned JSX
}</pre> <p class="calibre3">Starting with the initial <code>selectedOption</code> functionality, we can see that the item at index 3 of the options array, <code>{ value: 'grape' }</code>, is the initially selected option, as shown in <em class="italic">Figure 4</em><em class="italic">.1</em>:</p>
<div><div><img alt="Figure 4.1: The CoupledSelect initial state, with grape selected" src="img/B19109_04_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.1: The CoupledSelect initial state, with grape selected</p>
<p class="calibre3">When opening <code>select</code>, the <code>select</code> is in the correct state.</p>
<div><div><img alt="Figure 4.2: The CoupledSelect select open state, hovering on the orange option" src="img/B19109_04_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.2: The CoupledSelect select open state, hovering on the orange option</p>
<p class="calibre3">Finally, when we select a different option, <code>onChange</code> handler also works as expected.</p>
<div><div><img alt="Figure 4.3: In the CoupledSelect post-selection state, orange is now selected" src="img/B19109_04_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.3: In the CoupledSelect post-selection state, orange is now selected</p>
<p class="calibre3">The <code>CoupledSelect</code> component has limited flexibility due to the <code>options.map()</code> call in the render function. Since we’re<a id="_idIndexMarker182" class="pcalibre1 calibre6 pcalibre"/> using the option variable as the option element’s value, it must be a string or number. The value is also equal to the rendered text content of the option element, but there are often situations where we want to display something different from the value that we’re storing. It’s a presentation versus persistence concern here. For example, we can’t change the values rendered without changing what’s being stored in <code>onChange</code>.</p>
<p class="calibre3">If we want to add a <code>Fruit</code>: prefix to <code>select</code>, a naive approach is to implement it as follows:</p>
<pre class="source-code">
&lt;CoupledSelect
  {/* other props don't change */}
  options={options.map((option) =&gt; `Fruit:
     ${option.value}`)}
/&gt;</pre> <p class="calibre3">Unfortunately, this doesn’t work as expected, as the initial selection doesn’t work anymore:</p>
<div><div><img alt="Figure 4.4: The CoupledSelect initial state, where the initial selection does not work correctly" src="img/B19109_04_4.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.4: The CoupledSelect initial state, where the initial selection does not work correctly</p>
<p class="calibre3">When opening the <code>select,</code> things seem to work OK; we can see the <strong class="bold">Fruit:</strong> prefix for all the options, as shown in <em class="italic">Figure 4</em><em class="italic">.5</em>.</p>
<div><div><img alt="Figure 4.5: The CoupledSelect open state, with the Fruit: prefix" src="img/B19109_04_5.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.5: The CoupledSelect open state, with the Fruit: prefix</p>
<p class="calibre3">On selection of a new option, we can see that what’s being stored in the <code>selectedOption</code> is <strong class="bold">Fruit: pear</strong> instead of <strong class="bold">pear</strong>.</p>
<div><div><img alt="Figure 4.6: The CoupledSelect post-selection state – note that the selected option Fruit: pear includes the prefix Fruit:" src="img/B19109_04_6.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.6: The CoupledSelect post-selection state – note that the selected option Fruit: pear includes the prefix Fruit:</p>
<p class="calibre3">Therefore, the <code>CoupledSelect</code> component <a id="_idIndexMarker183" class="pcalibre1 calibre6 pcalibre"/>can’t be used flexibly, due to the coupling of the render logic and the data logic.</p>
<p class="calibre3">We’ll now see how render props could have alleviated this issue by decoupling data and rendering logic.</p>
<h2 id="_idParaDest-74" class="calibre7">I<a id="_idTextAnchor137" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor138" class="pcalibre1 calibre6 pcalibre"/>mplementation/example</h2>
<p class="calibre3">In our <code>CoupledSelect</code> example, we <a id="_idIndexMarker184" class="pcalibre1 calibre6 pcalibre"/>saw how the stored data and what is displayed to the user are tightly coupled. We’ll now see how to break that coupling using render props.</p>
<h3 class="calibre9">Decoupling presentation from data logic by using render props</h3>
<p class="calibre3">An alternative way to have <a id="_idIndexMarker185" class="pcalibre1 calibre6 pcalibre"/>written the <code>CoupledSelect</code> component with render props is as follows. The key additional prop we’re passing is <code>renderOption</code>, a render prop. Most of the remaining components are similar but are included for completeness:</p>
<pre class="source-code">
export function SelectRenderProps({
  selectedOption,
  options,
  renderOption,
  onChange,
}) {
  const onChangeHandler = (event) =&gt; {
    if (onChange) onChange(event.target.value);
  };
  return (
    &lt;select onChange={onChangeHandler} value=
      {selectedOption}&gt;
      {options.map((option) =&gt; renderOption(option))}
    &lt;/select&gt;
  );
}</pre> <p class="calibre3">Usage of the <code>SelectRenderProps </code>component is very similar to that of <code>CoupledSelect</code>. The only additional prop we need to provide an implementation for is the <code>renderOption</code> prop, which we implement with <a id="_idIndexMarker186" class="pcalibre1 calibre6 pcalibre"/>a function that returns an <code>option</code> element:</p>
<pre class="source-code">
function App() {
  return (
    &lt;SelectRenderProps
      selectedOption={selectedOption}
      onChange={(selectedOption) =&gt; setSelectedOption
        (selectedOption)}
      options={options.map((option) =&gt; option.value)}
      renderOption={(option) =&gt; (
        &lt;option value={option} key={option}&gt;
          {option}
        &lt;/option&gt;
      )}
    /&gt;
  );
}</pre> <p class="calibre3">So far, the implementation is very similar to <code>CoupledSelect</code>, apart from the fact that the parent of <code>SelectRenderProps</code> now decides how to render an option.</p>
<p class="calibre3">Given the same requirement to prefix the options with <code>Fruit:</code>, we can now implement it as follows:</p>
<pre class="source-code">
&lt;SelectRenderProps
  {/* rest of the props remain unchanged */}
  renderOption={(option) =&gt; (
    &lt;option value={option} key={option}&gt;
      Fruit: {option}
    &lt;/option&gt;
  )}
/&gt;</pre> <p class="calibre3">Note that counter to what we did with <code>CoupledSelect</code>, we’re not even touching the options prop. Our only change is to the <code>renderOption</code> prop. We’ll now test this example and show that decoupling the rendering logic (with a render prop) from the data logic works much better for extensibility.</p>
<p class="calibre3">The <code>SelectRenderProps</code> initial state renders correctly, with <code>select</code> and <strong class="bold">grape</strong> in the parent component:</p>
<div><div><img alt="Figure 4.7: The SelectRenderProps initial state – the options and initial selection are displayed correctly" src="img/B19109_04_7.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.7: The SelectRenderProps initial state – the options and initial selection are displayed correctly</p>
<p class="calibre3">When we open <code>select</code>, we can see that the <strong class="bold">Fruit:</strong> prefix is rendered.</p>
<div><div><img alt="Figure 4.8: The SelectRenderProps open state – the options include the Fruit: prefix" src="img/B19109_04_8.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.8: The SelectRenderProps open state – the options include the Fruit: prefix</p>
<p class="calibre3">Finally, upon selection of an <a id="_idIndexMarker187" class="pcalibre1 calibre6 pcalibre"/>option, the state is updated correctly, the parent stores <code>select</code> has <strong class="bold">Fruit: </strong><strong class="bold">banana</strong> selected:</p>
<div><div><img alt="Figure 4.9: The SelectRenderProps post-selection state – the selected option does not include the Fruit: prefix" src="img/B19109_04_9.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.9: The SelectRenderProps post-selection state – the selected option does not include the Fruit: prefix</p>
<p class="calibre3">We’ve now seen how render props can allow the rendering logic and data logic to be edited separately when making a rendering change.</p>
<p class="calibre3">Now that we’ve implemented a basic example of the render prop pattern, we’ll see how libraries leverage it to provide flexibility to consumers.</p>
<h3 class="calibre9">A<a id="_idTextAnchor139" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor140" class="pcalibre1 calibre6 pcalibre"/>dditional render prop patterns when providing components with flexible presentation</h3>
<p class="calibre3">The React form <a id="_idIndexMarker188" class="pcalibre1 calibre6 pcalibre"/>management library Formik uses a render prop to provide form state back to consumers. The render prop is the children prop of the Formik component. In other words, what’s between the opening <code>&lt;Formik&gt;</code> tag and the closing <code>&lt;/Formik&gt;</code> tag is a function, which provides props such as values, <code>isSubmitting</code>, and <code>handleChange</code>.</p>
<p class="calibre3">See the following example, which is a single-input form that takes a name, validates that it’s at least two characters long, and allows the form to be submitted.</p>
<p class="calibre3">To begin, we’ll render the form and input that will store the <code>fields</code> value in <code>Formik</code>:</p>
<pre class="source-code">
import { Formik } from 'formik';
export function FormikIntegrationExample() {
  return (
    &lt;Formik
      initialValues={{ name: '' }}
    &gt;
      {({
        values,
        errors,
        touched,
        handleChange,
        handleBlur,
        handleSubmit,
        isSubmitting,
      }) =&gt; (
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;fieldset&gt;
            &lt;input
              type="text"
              id="name"
              name="name"
              onChange={handleChange}
              onBlur={handleBlur}
              value={values.name}
              aria-required="true"
            /&gt;
          &lt;/fieldset&gt;
        &lt;/form&gt;
      )}
    &lt;/Formik&gt;
  );
}</pre> <p class="calibre3">Next, we can add submission <a id="_idIndexMarker189" class="pcalibre1 calibre6 pcalibre"/>handling and an inline validation error display:</p>
<pre class="source-code">
import { Formik } from 'formik';
export function FormikIntegrationExample() {
  return (
    &lt;Formik
      initialValues={{ name: '' }}
      validate={(values) =&gt; {
        const errors = {};
        if (!values.name) {
          errors.name = 'Required';
        } else if (values.name.length &lt; 2) {
          errors.name = 'Name too short';
        }
        return errors;
      }}
      onSubmit={(values, { setSubmitting }) =&gt; {
        setTimeout(() =&gt; {
          alert(JSON.stringify(values, null, 2));
          setSubmitting(false);
        }, 400);
      }}
    &gt;
      {({
        /* no change to props in render prop */
      }) =&gt; (
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;fieldset&gt;
            &lt;div&gt;
              &lt;label htmlFor="name"&gt;
                Name (Required)
                &lt;br /&gt;
                {errors.name &amp;&amp; touched.name ? (
                  &lt;&gt;Error: {errors.name}&lt;/&gt;
                ) : (
                  &lt;&gt;&amp;nbsp;&lt;/&gt;
                )}
              &lt;/label&gt;
            &lt;/div&gt;
            {/* no change to the input */}
          &lt;/fieldset&gt;
          &lt;button type="submit" disabled={isSubmitting}&gt;
            Submit
          &lt;/button&gt;
        &lt;/form&gt;
      )}
    &lt;/Formik&gt;
  );
}</pre> <p class="calibre3">In the initial state, we see the form with a single input and a submit button:</p>
<div><div><img alt="Figure 4.10: The Formik single field and Submit button in its initial state, which includes the Name (Required) label" src="img/B19109_04_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.10: The Formik single field and Submit button in its initial state, which includes the Name (Required) label</p>
<p class="calibre3">When we click (or otherwise focus) on the name input and then un-focus (the <em class="italic">blur</em> web event), the validation triggers, letting<a id="_idIndexMarker190" class="pcalibre1 calibre6 pcalibre"/> us know that the field is required.</p>
<div><div><img alt="Figure 4.11: Name input blur validation - Error: Required validation error" src="img/B19109_04_11.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.11: Name input blur validation - Error: Required validation error</p>
<p class="calibre3">If we input only one character and blur, we get a validation error, <strong class="bold">Name </strong><strong class="bold">too short</strong>.</p>
<div><div><img alt="Figure 4.12: H in the name input triggers the validation error Name too short" src="img/B19109_04_12.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.12: H in the name input triggers the validation error Name too short</p>
<p class="calibre3">When a name that meets the validation criteria is met, the validation errors are cleared.</p>
<div><div><img alt="Figure 4.13: A valid Formik field clears the validation errors" src="img/B19109_04_13.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.13: A valid Formik field clears the validation errors</p>
<p class="calibre3">Finally, when we click <strong class="bold">Submit</strong>, we get a browser alert with <strong class="bold">{ “name”: “</strong><strong class="bold">Hugo” }</strong>.</p>
<div><div><img alt="Figure 4.14: An alert on submission with { “name”: “Hugo” }" src="img/B19109_04_14.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.14: An alert on submission with { “name”: “Hugo” }</p>
<p class="calibre3">Now, let’s take a look at <a id="_idIndexMarker191" class="pcalibre1 calibre6 pcalibre"/>some limitations of the render prop pattern.</p>
<h2 id="_idParaDest-75" class="calibre7"><a id="_idTextAnchor141" class="pcalibre1 calibre6 pcalibre"/>Limitations</h2>
<p class="calibre3">One key limitation <a id="_idIndexMarker192" class="pcalibre1 calibre6 pcalibre"/>of the render prop pattern is that it provides units of reuse and integration that are functions and not components. It’s possible for a lot of the logic to end up in the render prop function itself that could have been better served by creating a new component.</p>
<p class="calibre3">Render props can make code harder to test when using a shallow renderer such as Enzyme’s <code>shallow</code>, which won’t render the full component tree. Components making heavy use of render props should probably use a full “mount” rendering approach so that all the children of the component (including the render props) are rendered.</p>
<p class="calibre3">In this section, we introduced you to the render prop pattern and described its use cases, examples, and limitations.</p>
<p class="calibre3">In the next section, we’ll learn about another reactive view library pattern – higher-order components.</p>
<h1 id="_idParaDest-76" class="calibre5">The hi<a id="_idTextAnchor142" class="pcalibre1 calibre6 pcalibre"/>gher-order component pattern</h1>
<p class="calibre3">A higher-order <a id="_idIndexMarker193" class="pcalibre1 calibre6 pcalibre"/>component is a function that takes a component and returns a component. The definition of higher-order components is similar to higher-order functions, which JavaScript supports. Higher-order functions are functions that receive a function as a parameter or return a function.</p>
<p class="calibre3">The higher-order component pattern allows us to pass additional props to a component.</p>
<h2 id="_idParaDest-77" class="calibre7">Implem<a id="_idTextAnchor143" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor144" class="pcalibre1 calibre6 pcalibre"/>entation/example</h2>
<p class="calibre3">The following is a <a id="_idIndexMarker194" class="pcalibre1 calibre6 pcalibre"/>simple render prop, <code>withLocation</code>, which injects <code>window.location.href</code> and <code>window.location.origin</code> into a component as props:</p>
<pre class="source-code">
const location = {
  href: window.location.href,
  origin: window.location.origin,
};
export function withLocation(Component) {
  return (props) =&gt; {
    return &lt;Component location={location} {...props} /&gt;;
  };
}</pre> <p class="calibre3">The pattern that’s used when using higher-order components is to export default the higher-order component called with the local component – in this case, <code>withLocation(Location)</code>. The <code>Location</code> component is a simple component that takes location as provided by <code>withLocation</code> and renders it:</p>
<pre class="source-code">
// in `location.jsx` file
function Location({ location }) {
  return (
    &lt;&gt;
      location.href: {location.href}, location.origin:
        {location.origin}
    &lt;/&gt;
  );
}
export default withLocation(Location);</pre> <p class="calibre3">In the consumer of <code>Location</code>, what we import as <code>Location</code> is the default export – that is, <code>withLocation(Location)</code>:</p>
<pre class="source-code">
import Location from './location';
function App() {
  return &lt;Location&gt;;
}</pre> <p class="calibre3">The <code>Location</code> component renders <code>location.href</code> and <code>location.origin</code>, based on what’s provided by <code>withLocation</code>.</p>
<div><div><img alt="" role="presentation" src="img/B19109_04_15.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"> Figure 4.15: The Location component rendering the href and origin, based on what’s provided by withlocation</p>
<p class="calibre3">We’ve now<a id="_idIndexMarker195" class="pcalibre1 calibre6 pcalibre"/> seen a simple example of a key benefit of higher-order components, which is that the component doing the rendering doesn’t need to be directly aware of where to receive information; it can read props instead.<a id="_idTextAnchor145" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor146" class="pcalibre1 calibre6 pcalibre"/></p>
<h2 id="_idParaDest-78" class="calibre7"><a id="_idTextAnchor147" class="pcalibre1 calibre6 pcalibre"/>Use cases</h2>
<p class="calibre3">The <code>withLocation</code> example<a id="_idIndexMarker196" class="pcalibre1 calibre6 pcalibre"/> already showed a simple reason why we could use higher-order components – to maintain separation of concerns.</p>
<p class="calibre3">In our Location component example, it’s completely possible for Location to access <code>window.location</code> directly. What that would mean, however, is that the Location component is aware of global objects, which could be undesirable. For example, it might make unit-testing of <code>Location</code> more difficult, since it’s accessing something beyond its props<a id="_idTextAnchor148" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor149" class="pcalibre1 calibre6 pcalibre"/>.</p>
<h2 id="_idParaDest-79" class="calibre7"><a id="_idTextAnchor150" class="pcalibre1 calibre6 pcalibre"/>Limitations</h2>
<p class="calibre3">As with all abstractions, higher-order<a id="_idIndexMarker197" class="pcalibre1 calibre6 pcalibre"/> components are a layer of indirection. This means that tracing where a prop comes from can be more difficult than when props are passed explicitly from the parent component.</p>
<p class="calibre3">Tracing the props becomes even more difficult when the higher-order component comes from a third-party library (and thus is harder to inspect).</p>
<p class="calibre3">Higher-order components can have a cost in terms of rendering in the browser, since we wrap our component in another component if we stack too many higher-order components on top of each other.</p>
<p class="calibre3">For example, the following <code>ConnectedComponent</code> uses three higher-level components:</p>
<pre class="source-code">
const ConnectedComponent = withRouter(
  withHttpClient(withAnotherDependency
    (ComponentWithDependencies))
);</pre> <p class="calibre3">As a consumer of <code>ConnectedComponent</code>, we’ll likely render four components – the ones provided by <code>withRouter</code>, <code>withHttpClient</code>, <code>withAnotherDependency</code>, and <code>ComponentWithDependencies</code>. If we had another way to inject the router, HTTP client and another dependency, we could reduce the number of components to one, only needing <code>ComponentWithDependencies</code>.</p>
<p class="calibre3">This <a id="_idIndexMarker198" class="pcalibre1 calibre6 pcalibre"/>drawback leads us to the next topic in this chapter – hooks. Hooks provide us a way to access data and logic in similar scenarios as higher-order components, without additional components being rendered. Hooks are a great replacement for logic-heavy higher-order componen<a id="_idTextAnchor151" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor152" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor153" class="pcalibre1 calibre6 pcalibre"/>ts.</p>
<h1 id="_idParaDest-80" class="calibre5"><a id="_idTextAnchor154" class="pcalibre1 calibre6 pcalibre"/>The hooks pattern</h1>
<p class="calibre3">We’ve<a id="_idIndexMarker199" class="pcalibre1 calibre6 pcalibre"/> now covered <a id="_idIndexMarker200" class="pcalibre1 calibre6 pcalibre"/>what might be considered <em class="italic">legacy</em> patterns in React – render props and higher-order components.</p>
<p class="author-quote">You’ll note that the React documentation page about higher-order components has the following disclaimer: “Higher-order components are not commonly used in modern React code.”</p>
<p class="callout-heading">Additional reading</p>
<p class="callout">The<a id="_idIndexMarker201" class="pcalibre1 calibre6 pcalibre"/> React <a id="_idIndexMarker202" class="pcalibre1 calibre6 pcalibre"/>documentation for <strong class="source-inline1">useState</strong> and <strong class="source-inline1">useEffect</strong> hooks:</p>
<p class="callout"><strong class="source-inline1">useState</strong>: <a href="https://react.dev/reference/react/useState" class="pcalibre1 calibre6 pcalibre">https://react.dev/reference/react/useState</a></p>
<p class="callout"><strong class="source-inline1">useEffect</strong>: <a href="https://react.dev/reference/react/useEffect" class="pcalibre1 calibre6 pcalibre">https://react.dev/reference/react/useEffect</a></p>
<p class="calibre3">So, what we know so far is that hooks allow us to do what we did with render props and that higher-order components are not recommended any more. This is because hooks provide a way to access all the React primitives, including state and the component life cycle.</p>
<p class="calibre3">React provides <a id="_idIndexMarker203" class="pcalibre1 calibre6 pcalibre"/>built-in hooks. The two we’ll focus on are <code>useState</code> and <code>useEffect</code>. One key feature of hooks is that we can write custom hooks that build on top of React built-in <a id="_idIndexMarker204" class="pcalibre1 calibre6 pcalibre"/>hooks and other custom hooks, which means we have a new way to share logic <a id="_idTextAnchor155" class="pcalibre1 calibre6 pcalibre"/>in React.</p>
<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor156" class="pcalibre1 calibre6 pcalibre"/>An implementation/example</h2>
<p class="calibre3">We’ll implement simple data<a id="_idIndexMarker205" class="pcalibre1 calibre6 pcalibre"/> fetching using the class React components, and then hooks. This will showcase how state and life cycle events are handled in both cases.</p>
<p class="calibre3">We’ll start with the class components. The regular way to implement data fetching is by using life cycle hooks; the initial one tends to be <code>componentDidMount</code>.</p>
<p class="calibre3">Our <code>BasketItemsClassical</code> component takes <code>httpClient</code> and <code>basketId</code>.</p>
<p class="calibre3">The component’s constructor initializes a <code>state.basketSession</code> variable to an empty object, <code>{}</code>:</p>
<pre class="source-code">
import React from 'react';
export class BasketItemsClassical extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      basketSession: {},
    };
  }</pre> <p class="calibre3">Next, we’ll add a <code>setBasketSession</code> method, which will call <code>this.setState</code> to set <code>basketSession</code> as the passed parameter.</p>
<p class="calibre3">We’ll also add <code>componentDidMount</code>, which calls <code>httpClient.get()</code> with the fakestoreapi.com URL<a id="_idIndexMarker206" class="pcalibre1 calibre6 pcalibre"/> to load carts, using the <code>basketId</code> prop:</p>
<pre class="source-code">
export class BasketItemsClassical extends React.Component {
  // no change to the constructor
  componentDidMount() {
    this.props.httpClient
      .get(`https://fakestoreapi.com/carts/${this.props.basketId}`)
      .then((session) =&gt; this.setBasketSession(session));
  }
  setBasketSession(session) {
    this.setState({ basketSession: session });
  }
}</pre> <p class="calibre3">What this now means is that we should be able to render out the contents of <code>this.state.basketSession</code> in the component’s <code>render()</code> method:</p>
<pre class="source-code">
export class BasketItemsClassical extends React.Component {
  // no change to the constructor, componentDidMount or
     setBasketSession
  render() {
    return &lt;pre&gt;{JSON.stringify(this.state.basketSession,
      null, 2)}&lt;/pre&gt;;
  }
}</pre> <p class="calibre3">Our <code>BasketItemsClassical</code> can be used as follows by passing <code>httpClient</code> and <code>basketId</code> as <a id="_idIndexMarker207" class="pcalibre1 calibre6 pcalibre"/>props:</p>
<pre class="source-code">
export function BasketClassical({ basketId, httpClient }) {
  return (
    &lt;form&gt;
      &lt;fieldset&gt;
        &lt;label&gt;Class&lt;/label&gt;
        &lt;BasketItemsClassical basketId={basketId}
           httpClient={httpClient} /&gt;
      &lt;/fieldset&gt;
    &lt;/form&gt;
  );
}</pre> <p class="calibre3"><code>BasketClassical</code> can then be used in our <code>App</code>, as follows:</p>
<pre class="source-code">
const httpClient = {
  async get(url) {
    const response = await fetch(url);
    return await response.json();
  },
};
function App() {
  return (
    &lt;&gt;
      &lt;BasketClassical basketId="5" httpClient={httpClient} /&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">In the browser, this <a id="_idIndexMarker208" class="pcalibre1 calibre6 pcalibre"/>displays as follows:</p>
<div><div><img alt="Figure 4.16: The Basket class component loading JSON data" src="img/B19109_04_16.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.16: The Basket class component loading JSON data</p>
<p class="calibre3">Here’s the same example with hooks; instead of using <code>componentDidMount</code>, we can use the <code>useEffect </code>hook, and instead of <code>this.state</code> in the constructor and <code>this.setState</code>, we use the <code>useState</code> hook. In order to use hooks, we use a React function component (React class components don’t support hooks):</p>
<pre class="source-code">
export function BasketItemsHooks({ basketId, httpClient }) {
  const [basketSession, setBasketSession] = useState({});
  useEffect(() =&gt; {
    httpClient
      .get(`https://fakestoreapi.com/carts/${basketId}`)
      .then((session) =&gt; setBasketSession(session));
  }, []);
  return &lt;pre&gt;{JSON.stringify(basketSession, null, 2)}&lt;/pre&gt;;
}</pre> <p class="calibre3">Our <code>BasketItemsHooks</code> can be <a id="_idIndexMarker209" class="pcalibre1 calibre6 pcalibre"/>used in the same way as <code>BasketItemsClassical</code>, by passing <code>httpClient</code> and <code>basketId</code> as props:</p>
<pre class="source-code">
export function BasketHooks({ basketId, httpClient }) {
  return (
    &lt;form&gt;
      &lt;fieldset&gt;
        &lt;label&gt;Hooks&lt;/label&gt;
        &lt;BasketItemsHooks basketId={basketId}
          httpClient={httpClient} /&gt;
      &lt;/fieldset&gt;
    &lt;/form&gt;
  );
}</pre> <p class="calibre3">We’ll also need<a id="_idIndexMarker210" class="pcalibre1 calibre6 pcalibre"/> to modify <code>App</code> to render <code>BasketHooks</code> in addition to <code>BasketClassical</code>:</p>
<pre class="source-code">
// no change to httpClient
function App() {
  return (
    &lt;&gt;
      &lt;BasketClassical basketId="5" httpClient={httpClient} /&gt;
      &lt;BasketHooks basketId="5" httpClient={httpClient} /&gt;
    &lt;/&gt;
  );
}</pre> <p class="calibre3">Both <code>BasketHooks</code> (<em class="italic">Figure 4</em><em class="italic">.17</em>) and <code>BasketClassical</code> (<em class="italic">Figure 4</em><em class="italic">.16</em>) yield the same JSON output after the HTTP requests are completed.</p>
<div><div><img alt="Figure 4.17: The Hooks basket loading JSON data" src="img/B19109_04_17.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.17: The Hooks basket loading JSON data</p>
<p class="calibre3">The hooks<a id="_idIndexMarker211" class="pcalibre1 calibre6 pcalibre"/> approach is slightly more compact; each part of the functionality does feel a bit more self-contained. For example, the initial state is handled in the same place that defines what the state update function will be in the hooks version. In the class example, the <code>initialisation</code> state is in the constructor, and the state update function is a method. In the <code>BasketClassical</code> example, there was the option to simplify the component by removing the state update method and using a direct <code>this.setState({ bookingSession: se<a id="_idTextAnchor157" class="pcalibre1 calibre6 pcalibre"/>ssion })</code> call.</p>
<h2 id="_idParaDest-82" class="calibre7"><a id="_idTextAnchor158" class="pcalibre1 calibre6 pcalibre"/>Use cases</h2>
<p class="calibre3">A simple way to think about hooks and <a id="_idIndexMarker212" class="pcalibre1 calibre6 pcalibre"/>class or function components is as follows:</p>
<ul class="calibre10">
<li class="calibre11">Hooks for shared logic</li>
<li class="calibre11">Components for logic that is related to rendering</li>
</ul>
<p class="calibre3">The higher-order component and render prop patterns, which are used to separate presentation and business logic, are unlikely to be needed any more and can be replaced by custom hooks.</p>
<p class="calibre3">React hooks and<a id="_idIndexMarker213" class="pcalibre1 calibre6 pcalibre"/> function components are the recommended way to develop modern React applications.</p>
<h2 id="_idParaDest-83" class="calibre7"><a id="_idTextAnchor159" class="pcalibre1 calibre6 pcalibre"/>Limitations</h2>
<p class="calibre3">Hooks can’t <a id="_idIndexMarker214" class="pcalibre1 calibre6 pcalibre"/>be used in React class components, as detailed in the React documentation: <a href="https://react.dev/reference/react/Component#defining-a-class-component" class="pcalibre1 calibre6 pcalibre">https://react.dev/reference/react/Component#defining-a-class-component</a>. Note that function components are the recommended way to build React components.</p>
<p class="calibre3">In code bases with heavy usage of class components, higher-order components should remain in use instead of migrating components to functions in order to use hooks.</p>
<p class="calibre3">The last piece of the puzzle with React components is how to bypass the prop drilling problem and pass data without changing each component in a React component tree. The pattern we use for this is the provider pattern, which we’ll cover in <a id="_idTextAnchor160" class="pcalibre1 calibre6 pcalibre"/>the next section.</p>
<h1 id="_idParaDest-84" class="calibre5"><a id="_idTextAnchor161" class="pcalibre1 calibre6 pcalibre"/>The provider pattern</h1>
<p class="calibre3">The <a id="_idIndexMarker215" class="pcalibre1 calibre6 pcalibre"/>provider <a id="_idIndexMarker216" class="pcalibre1 calibre6 pcalibre"/>pattern in React is where one component in the tree makes data accessible to all its descendants. This is usually accomplished using the<a id="_idIndexMarker217" class="pcalibre1 calibre6 pcalibre"/> Reac<a id="_idTextAnchor162" class="pcalibre1 calibre6 pcalibre"/>t <strong class="bold">Context</strong> primitive.</p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor163" class="pcalibre1 calibre6 pcalibre"/>Use case – the prop drilling problem</h2>
<p class="calibre3">The key use case for <a id="_idIndexMarker218" class="pcalibre1 calibre6 pcalibre"/>the provider<a id="_idIndexMarker219" class="pcalibre1 calibre6 pcalibre"/> pattern is to avoid the <strong class="bold">prop </strong><strong class="bold">drilling</strong> problem.</p>
<p class="calibre3">A large majority of the time, a component’s main input is the prop it receives from its parent component. A state management pattern to share state between components in React is to <em class="italic">lift state up</em>. Lifting state up means to store relevant state in a common ancestor of the components that require the shared state.</p>
<p class="calibre3">As stated in the React.js docs (<a href="https://react.dev/learn/sharing-state-between-components" class="pcalibre1 calibre6 pcalibre">https://react.dev/learn/sharing-state-between-components</a>)</p>
<p class="author-quote"> When you want to coordinate two components, move their state to their common parent. Then pass the information down through props from their common parent</p>
<p class="calibre3">This can lead to <strong class="bold">prop drilling</strong> when the common parent has multiple components between it and the components requiring the props. This means all the intermediate components will receive the props, but they will only use them to forward them on to the next layer of components.</p>
<p class="calibre3">As stated in the React.js docs (https://react.dev/learn/passing-data-deeply-with-context#the-problem-with-passing-props)</p>
<p class="author-quote"> Passing props is a great way to explicitly pipe data through your UI tree to the components that use it. But passing props can become verbose and inconvenient when you need to pass some prop deeply through the tree, or if many components need the same prop. The nearest common ancestor could be far removed from the components that need data, and lifting state up that high can lead to a situation called “prop drilling</p>
<p class="calibre3">The provider <a id="_idIndexMarker220" class="pcalibre1 calibre6 pcalibre"/>pattern is a solution to the prop drilling problem, since every <a id="_idIndexMarker221" class="pcalibre1 calibre6 pcalibre"/>descendent of the provider component will have access <a id="_idTextAnchor164" class="pcalibre1 calibre6 pcalibre"/>to the data it provides.</p>
<h2 id="_idParaDest-86" class="calibre7"><a id="_idTextAnchor165" class="pcalibre1 calibre6 pcalibre"/>An implementation/example</h2>
<p class="calibre3">Let’s look back<a id="_idIndexMarker222" class="pcalibre1 calibre6 pcalibre"/> to the examples from <em class="italic">The hooks pattern</em> section, where we had the App rendering <code>BasketClassical</code> and <code>BasketHooks</code>, which render <code>BasketItemsClassical</code> and <code>BasketItemsHooks</code>, respectively.</p>
<div><div><img alt="Figure 4.18: A React app tree with BasketClassical, BasketHooks, and their descendants" src="img/B19109_04_18.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.18: A React app tree with BasketClassical, BasketHooks, and their descendants</p>
<p class="calibre3">This <a id="_idIndexMarker223" class="pcalibre1 calibre6 pcalibre"/>illustrates the prop drilling problem, since <code>BasketClassical</code> and <code>BasketHooks</code> don’t use <code>basketId</code> or <code>httpClient</code> beyond passing it to <code>BasketItemsClassical</code> and <code>BasketItemsHooks</code>.</p>
<p class="calibre3">There are multiple ways to consume a context in React, but it all begins by creating a context:</p>
<pre class="source-code">
import React, { createContext } from 'react';
const HttpClientContext = createContext(null);
export function HttpClientProvider({ httpClient, children
  }) {
  return (
    &lt;HttpClientContext.Provider value={httpClient}&gt;
      {children}
    &lt;/HttpClientContext.Provider&gt;
  );
}</pre> <p class="calibre3"><code>HttpClientContext</code> is a context that’s initialized with the null value. <code>HttpClientProvider</code> is a component that takes a <code>httpClient</code> value, setting it as the value that <code>HttpClientContext.Provider</code> will pass to its descendants in the component tree.</p>
<p class="calibre3">In order to use <code>HttpClientContext</code>, we can use <code>HttpClientContext.Consumer</code>:</p>
<pre class="source-code">
export const HttpClientConsumer = HttpClientContext.Consumer;</pre> <p class="calibre3"><code>HttpClientContext.Consumer</code> has a children render-prop (function) that takes the value of the<a id="_idIndexMarker224" class="pcalibre1 calibre6 pcalibre"/> context (in this case, <code>httpClient</code>) and returns some JSX to render:</p>
<pre class="source-code">
// no change to httpClient
function App() {
  return (
    &lt;HttpClientProvider httpClient={httpClient}&gt;
      {/* what's below could be however deep in the
          component tree */}
      &lt;HttpClientConsumer&gt;
        {(httpClient) =&gt; (
          &lt;BasketItemsClassical basketId="5" httpClient=
           {httpClient} /&gt;
        )}
      &lt;/HttpClientConsumer&gt;
    &lt;/HttpClientProvider&gt;
  );
}</pre> <p class="calibre3">This yields the following output in the browser:</p>
<div><div><img alt="Figure 4.19: The JSON contents of basketId=5 from fakestoreapi.com" src="img/B19109_04_19.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.19: The JSON contents of basketId=5 from fakestoreapi.com</p>
<p class="calibre3">The approach<a id="_idIndexMarker225" class="pcalibre1 calibre6 pcalibre"/> using <code>HttpClientContext.Consumer</code> directly is a bit unwieldy. Instead, we could wrap it in a higher-order component, <code>withHttpClient</code>, which consumes <code>HttpClientConsumer</code>. The benefit here is that we only have one place that uses <code>HttpClientConsumer</code>:</p>
<pre class="source-code">
export function withHttpClient(Component) {
  return (props) =&gt; (
    &lt;HttpClientConsumer&gt;
      {(httpClient) =&gt; &lt;Component {...props} httpClient=
        {httpClient} /&gt;}
    &lt;/HttpClientConsumer&gt;
  );
}</pre> <p class="calibre3">With a slight<a id="_idIndexMarker226" class="pcalibre1 calibre6 pcalibre"/> difference from our example of a higher-order component, we’ll export const <code>Connected</code><code> BasketItemsClassical</code> with the value <code>withHttpClient(BasketItemsClassical)</code>. The <em class="italic">connected</em> nomenclature is a call back to the large React Redux code bases where the components are often split among <em class="italic">presentation</em> and <em class="italic">container</em> components. The Redux higher-order component is called <code>connect</code>, and all the containers are connected:</p>
<pre class="source-code">
export const ConnectedBasketItemsClassical =
  withHttpClient(BasketItemsClassical);</pre> <p class="calibre3">We can then use <code>ConnectedBasketItemsClassical</code> as follows. Note that we don’t pass an <code>httpClient</code> prop:</p>
<pre class="source-code">
function App() {
  return (
    &lt;HttpClientProvider httpClient={httpClient}&gt;
      {/* what's below could be however deep in the
          component tree */}
      &lt;ConnectedBasketItemsClassical basketId="5" /&gt;
    &lt;/HttpClientProvider&gt;
  );
}</pre> <p class="calibre3">The higher-order component version using <code>withHttpClient</code> outputs the same value as the direct <code>HttpClientConsumer</code> implementation.</p>
<div><div><img alt="Figure 4.20: The JSON contents of basketId=5 from fakestoreapi.com" src="img/B19109_04_20.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.20: The JSON contents of basketId=5 from fakestoreapi.com</p>
<p class="calibre3">The final approach<a id="_idIndexMarker227" class="pcalibre1 calibre6 pcalibre"/> to using context and the provider pattern is to leverage the React <code>useContext</code> hook. Similar to how <code>HttpClientContext.Consumer</code> allows us to access the context provider’s value, the hook fulfills that same role. So, the output of <code>useContext(context)</code> is the current value, based on where the hook renders in the component tree.</p>
<p class="calibre3">It’s customary to wrap the <code>useContext </code>hook in a more descriptive name (as we did for <code>HttpClientContext.Consumer</code>):</p>
<pre class="source-code">
import React, { createContext, useContext } from 'react';
// no changes to HttpClientContext definition or
    HttpClientContextConsumer
export function useHttpClient() {
  co<a id="_idTextAnchor166" class="pcalibre1 calibre16 pcalibre"/><a id="_idTextAnchor167" class="pcalibre1 calibre16 pcalibre"/>nst httpClient = useContext(HttpClientContext);
  return httpClient;
}</pre> <p class="calibre3">This time, using <code>httpClient</code> from the <code>HttpClientContext</code> requires component-level changes. So, we’ll<a id="_idIndexMarker228" class="pcalibre1 calibre6 pcalibre"/> write the following implementation of <code>BasketItemsHooksUseContext</code>:</p>
<pre class="source-code">
export function BasketItemsHooksUseContext({ basketId }) {
  const httpClient = useHttpClient();
  const [basketSession, setBasketSession] = useState({});
  useEffect(() =&gt; {
    // @ts-ignore
    httpClient
      .get(`https://fakestoreapi.com/carts/${basketId}`)
      .then((session) =&gt; setBasketSession(session));
  }, []);
  return &lt;pre&gt;{JSON.stringify(basketSession,
   null, 2)}&lt;/pre&gt;;
}</pre> <p class="calibre3"><code>BasketItemsHooksUseContext</code> can be used as follows. Note that we’re not passing <code>BasketItemsHooksUseContext</code>, a <code>httpClient</code> prop:</p>
<pre class="source-code">
function App() {
  return (
    &lt;HttpClientProvider httpClient={httpClient}&gt;
      {/* what's below could be however deep in the
      component tree */}
      &lt;BasketItemsHooksUseContext basketId="5" /&gt;
    &lt;/HttpClientProvider&gt;
  );
}</pre> <p class="calibre3">This implementation<a id="_idIndexMarker229" class="pcalibre1 calibre6 pcalibre"/> is yet again equivalent to the previous implementations we did with <code>HttpClientConsumer</code> and <code>HttpClient</code>.</p>
<div><div><img alt="Figure 4.21: The JSON contents of basketId=5 from fakestoreapi.com" src="img/B19109_04_21.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 4.21: The JSON contents of basketId=5 from fakestoreapi.com</p>
<p class="calibre3">We saw how to use the provider pattern to solve the prop drilling problem in React apps. Let’s now look at some limitations of this <a id="_idTextAnchor168" class="pcalibre1 calibre6 pcalibre"/>pattern in the next section.</p>
<h2 id="_idParaDest-87" class="calibre7"><a id="_idTextAnchor169" class="pcalibre1 calibre6 pcalibre"/>Limitations</h2>
<p class="calibre3">The provider pattern is a <a id="_idIndexMarker230" class="pcalibre1 calibre6 pcalibre"/>layer of indirection. It might not always be obvious where a context’s value is coming from, or it might sometimes be necessary to change the provider/context shape to make some changes at the component level. For example, when using context with hooks, the hook shows a direct link between consuming component and the context, but it doesn’t necessarily show the provider or how the value inside the context is defined.</p>
<p class="calibre3">It’s also sometimes possible to solve the prop drilling problem by making liberal use of children and composing the components in a single large JSX return, such as the following:</p>
<pre class="source-code">
function MyComponent() {
  return &lt;ContainerComponent requiredProp={'value'}&gt;
    &lt;OtherComponent prop="other-value"/&gt;
    &lt;FinalComponent prop="final-value"/&gt;
  &lt;/ContainerComponent&gt;
}</pre> <p class="calibre3">In <code>MyComponent</code>, we pass the props directly to <code>OtherComponent</code> and <code>FinalComponent</code> from <code>MyComponent</code>. If we had <code>ContainerComponent</code> encapsulating <code>OtherComponent</code> and <code>FinalComponent</code>, the props would be drilled via <code>ContainerComponent</code> (it doesn’t use the props but receives them, in order to p<a id="_idTextAnchor170" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor171" class="pcalibre1 calibre6 pcalibre"/>ass them to its descendants).</p>
<h1 id="_idParaDest-88" class="calibre5"><a id="_idTextAnchor172" class="pcalibre1 calibre6 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we looked at how reactive view library patterns enable us to build React applications more effectively when the component paradigm starts to break down.</p>
<p class="calibre3">The render prop pattern allows us to decouple data logic and rendering logic by yielding rendering control back to the consumer of a component.</p>
<p class="calibre3">The higher-order component pattern allows components to implement logic (data or rendering) against their props, without having to concern themselves with where the information comes from.</p>
<p class="calibre3">The hooks pattern means that React primitives that were only available in class components are now available as self-contained logic chunks to function components. Hooks can be composed separately of components, which makes hooks a powerful primitive and can partly replace the render prop and higher-order component patterns.</p>
<p class="calibre3">The provider pattern allows React components to pass data not only to their children but also to any descendent component.</p>
<p class="calibre3">Now that we’re familiar with reactive view library patterns, in the next chapter, we will look at rendering and page hydration strategies to improve web applications’ performance.</p>
</div>
</body></html>