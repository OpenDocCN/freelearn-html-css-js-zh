<html><head></head><body>
<div id="_idContainer040" class="calibre2">
<h1 class="chapter-number" id="_idParaDest-68"><a id="_idTextAnchor130" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.1.1">4</span></h1>
<h1 id="_idParaDest-69" class="calibre5"><a id="_idTextAnchor131" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.2.1">Exploring Reactive View Library Patterns</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.3.1">Reactive view library patterns </span><a id="_idIndexMarker168" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.4.1">give us tools to build applications in a scalable and maintainable manner when we could benefit from breaking out of the component primitive. </span><span class="kobospan" id="kobo.4.2">Using the React view library, we’ll cover different techniques for going beyond component-based composition to inject functionality into our components – the render prop, a higher-order component, hooks, and </span><span><span class="kobospan" id="kobo.5.1">provider patterns.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.6.1">We’ll cover the following main topics in </span><span><span class="kobospan" id="kobo.7.1">this chapter:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.8.1">An introduction to reactive view library patterns and where we can benefit the most by </span><span><span class="kobospan" id="kobo.9.1">using them</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.10.1">Examples and implementation approaches for the render </span><span><span class="kobospan" id="kobo.11.1">prop pattern</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.12.1">Implementing and using the higher-order </span><span><span class="kobospan" id="kobo.13.1">component pattern</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.14.1">Using hooks to build React </span><span><span class="kobospan" id="kobo.15.1">function components</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.16.1">Multiple ways to implement the </span><span><span class="kobospan" id="kobo.17.1">provider pattern</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.18.1">By the end of this chapter, you’ll be able to discern when and how to use Reactive view library patterns to build </span><span><span class="kobospan" id="kobo.19.1">React applications.</span></span></p>
<h1 id="_idParaDest-70" class="calibre5"><a id="_idTextAnchor132" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.20.1">Technical requirements</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.21.1">To follow along in this chapter, you’ll need </span><span><span class="kobospan" id="kobo.22.1">the following:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.23.1">Node.js </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.24.1">20+</span></strong></span><span><span class="kobospan" id="kobo.25.1">: </span></span><a href="https://nodejs.org/en" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.26.1">https://nodejs.org/en</span></span></a></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.27.1">Npm 8+</span></strong><span class="kobospan" id="kobo.28.1">: Comes with most </span><span><span class="kobospan" id="kobo.29.1">Node.js installations</span></span></li>
<li class="calibre11"><a href="https://parceljs.org/" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.30.1">https://parceljs.org/</span></a><span class="kobospan" id="kobo.31.1"> is used in some examples and has similar platform support </span><span><span class="kobospan" id="kobo.32.1">to Node.js</span></span></li>
<li class="calibre11"><strong class="bold"><span class="kobospan" id="kobo.33.1">React</span></strong><span class="kobospan" id="kobo.34.1">: React DOM and Formik are installed via npm; an understanding of </span><a href="https://react.dev/" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.35.1">https://react.dev/</span></a><span class="kobospan" id="kobo.36.1"> basics in a web context </span><span><span class="kobospan" id="kobo.37.1">is required</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.38.1">You can find the code files for this chapter on GitHub </span><span><span class="kobospan" id="kobo.39.1">at </span></span><a href="https://github.com/PacktPublishing/Javascript-Design-Patterns" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.40.1">https://github.com/PacktPublishing/Javascript-Design-Patterns</span></span></a></p>
<h1 id="_idParaDest-71" class="calibre5"><a id="_idTextAnchor133" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.41.1">What are reactive view library patterns?</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.42.1">Reactive view</span><a id="_idIndexMarker169" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.43.1"> libraries are extensively used for JavaScript and web frontend development. </span><span class="kobospan" id="kobo.43.2">A few</span><a id="_idIndexMarker170" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.44.1"> very popular</span><a id="_idIndexMarker171" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.45.1"> options</span><a id="_idIndexMarker172" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.46.1"> are </span><strong class="bold"><span class="kobospan" id="kobo.47.1">React</span></strong><span class="kobospan" id="kobo.48.1">, </span><strong class="bold"><span class="kobospan" id="kobo.49.1">Angular</span></strong><span class="kobospan" id="kobo.50.1">, </span><span><span class="kobospan" id="kobo.51.1">and </span></span><span><strong class="bold"><span class="kobospan" id="kobo.52.1">Vue</span></strong></span><span><span class="kobospan" id="kobo.53.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.54.1">Reactive view libraries provide a way to write applications in a more scalable fashion by allowing the user interface (usually the browser) to react to changes in the data. </span><span class="kobospan" id="kobo.54.2">Application development is, therefore, simplified, since the view library or framework takes care of all the direct manipulation necessary to maintain synchronization between the underlying data and </span><span><span class="kobospan" id="kobo.55.1">the browser.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.56.1">One of the key common denominators between these libraries and frameworks is the concept of a </span><strong class="bold"><span class="kobospan" id="kobo.57.1">component</span></strong><span class="kobospan" id="kobo.58.1">, which</span><a id="_idIndexMarker173" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.59.1"> contains business logic and/or rendering logic. </span><span class="kobospan" id="kobo.59.2">The component is a key building block of an application. </span><span class="kobospan" id="kobo.59.3">It can be reused or not, but it usually encapsulates a set of responsibilities and enforces interfaces </span><span><span class="kobospan" id="kobo.60.1">around it.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.61.1">A trait of components is that a developer should be able to use them as building blocks, and without component internals changing significantly, an application’s behavior can be </span><span><span class="kobospan" id="kobo.62.1">changed significantly.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.63.1">Reactive view library patterns, therefore, help us build components in a reusable fashion, but they also cover techniques to work around situations where the component abstraction </span><span><span class="kobospan" id="kobo.64.1">has shortcomings.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.65.1">In the following sections, we’ll cover the render props, higher-order component, hooks, and the provider pattern in React. </span><span class="kobospan" id="kobo.65.2">We’ll be focusing on React, but the patterns have equivalents </span><span><span class="kobospan" id="kobo.66.1">in Vue.</span></span></p>
<h1 id="_idParaDest-72" class="calibre5"><a id="_idTextAnchor134" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.67.1">The render prop pattern</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.68.1">The render prop </span><a id="_idIndexMarker174" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.69.1">pattern is apparent </span><a id="_idIndexMarker175" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.70.1">when a component allows its consumer to define how a part of that component is rendered, via a function prop. </span><span class="kobospan" id="kobo.70.2">These can be children as a function or another prop, which is a function that takes some parameters and </span><span><span class="kobospan" id="kobo.71.1">returns JSX.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.72.1">Render props allow for a level of inversion of control. </span><span class="kobospan" id="kobo.72.2">Although a component could completely encapsulate rendering and business logic, it instead yields control of some parts of the rendering logic to </span><span><span class="kobospan" id="kobo.73.1">its consumer.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.74.1">Such inversion of control is useful to share logic without sharing the visuals or actually rendering the UI. </span><span class="kobospan" id="kobo.74.2">Therefore, this pattern is widespread among libraries. </span><span class="kobospan" id="kobo.74.3">A prime </span><a id="_idIndexMarker176" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.75.1">example is </span><strong class="bold"><span class="kobospan" id="kobo.76.1">Formik</span></strong><span class="kobospan" id="kobo.77.1">, which gives consumers flexibility on how to </span><a id="_idIndexMarker177" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.78.1">render a form </span><a id="_idIndexMarker178" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.79.1">while providing an abstraction over the form’s state </span><span><span class="kobospan" id="kobo.80.1">management logic.</span></span></p>
<h2 id="_idParaDest-73" class="calibre7"><a id="_idTextAnchor135" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor136" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.81.1">Use cases</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.82.1">Let’s start with a </span><a id="_idIndexMarker179" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.83.1">scenario where we build a </span><strong class="source-inline"><span class="kobospan" id="kobo.84.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.85.1"> component, which is a wrapper for the </span><strong class="source-inline"><span class="kobospan" id="kobo.86.1">select</span></strong><span class="kobospan" id="kobo.87.1"> native element. </span><span class="kobospan" id="kobo.87.2">We’ll build this component in a way that the data and the rendering are closely coupled, providing a simple example of when render props can </span><span><span class="kobospan" id="kobo.88.1">be useful.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.89.1">A consumer’s expectation from </span><strong class="source-inline"><span class="kobospan" id="kobo.90.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.91.1"> is that it would behave mostly like the </span><strong class="source-inline"><span class="kobospan" id="kobo.92.1">select</span></strong><span class="kobospan" id="kobo.93.1"> native element, with </span><span><span class="kobospan" id="kobo.94.1">some caveats.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.95.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.96.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.97.1"> component takes the </span><span><span class="kobospan" id="kobo.98.1">following props:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.99.1">selectedOption</span></strong><span class="kobospan" id="kobo.100.1">: This sets the selected option; it is akin to the selected prop on the </span><strong class="source-inline1"><span class="kobospan" id="kobo.101.1">option</span></strong> <span><span class="kobospan" id="kobo.102.1">native element</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.103.1">options</span></strong><span class="kobospan" id="kobo.104.1">: This is an array of strings that are rendered as </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.105.1">option</span></strong></span><span><span class="kobospan" id="kobo.106.1"> elements</span></span></li>
<li class="calibre11"><strong class="source-inline1"><span class="kobospan" id="kobo.107.1">onChange</span></strong><span class="kobospan" id="kobo.108.1">: This is an optional callback for the component rendering </span><strong class="source-inline1"><span class="kobospan" id="kobo.109.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.110.1"> to react to </span><span><span class="kobospan" id="kobo.111.1">option selections</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.112.1">We can implement it as follows. </span><strong class="source-inline"><span class="kobospan" id="kobo.113.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.114.1"> will wrap around </span><strong class="source-inline"><span class="kobospan" id="kobo.115.1">onChange</span></strong><span class="kobospan" id="kobo.116.1">, since </span><span><span class="kobospan" id="kobo.117.1">it’s optional:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.118.1">
import React from 'react';
export function CoupledSelect({ selectedOption, options,
  onChange }) {
  const onChangeHandler = (event) =&gt; {
    if (onChange) onChange(event.target.value);
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.119.1">Let’s move on to the rendering logic. </span><span class="kobospan" id="kobo.119.2">We’ll return a select element with </span><strong class="source-inline"><span class="kobospan" id="kobo.120.1">onChange={onChangeHandler}</span></strong><span class="kobospan" id="kobo.121.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.122.1">value={selectedOption}</span></strong><span class="kobospan" id="kobo.123.1"> so that select will be in sync with </span><strong class="source-inline"><span class="kobospan" id="kobo.124.1">selectedOption</span></strong><span class="kobospan" id="kobo.125.1"> and propagate </span><span><span class="kobospan" id="kobo.126.1">changes back:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.127.1">
import React from 'react';
export function CoupledSelect({ selectedOption, options,
  onChange }) {
  const onChangeHandler = (event) =&gt; {
    if (onChange) onChange(event.target.value);
  };
  return &lt;select onChange={onChangeHandler}
    value={selectedOption}&gt;&lt;/select&gt;;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.128.1">Finally, we’ll render the </span><strong class="source-inline"><span class="kobospan" id="kobo.129.1">props.options</span></strong><span class="kobospan" id="kobo.130.1"> using .map, which will return an &lt;</span><strong class="source-inline"><span class="kobospan" id="kobo.131.1">option</span></strong><span class="kobospan" id="kobo.132.1">&gt; element, with the value and key properties set to option and whose content will be the </span><strong class="source-inline"><span class="kobospan" id="kobo.133.1">option</span></strong> <span><span class="kobospan" id="kobo.134.1">value also:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.135.1">
export function CoupledSelect({ selectedOption, options,
  onChange }) {
  // no change to onChangeHandler
  return (
    &lt;select onChange={onChangeHandler}
      value={selectedOption}&gt;
      {options.map((option) =&gt; (
        &lt;option value={option} key={option}&gt;
          {option}
        &lt;/option&gt;
      ))}
    &lt;/select&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.136.1">Using our </span><strong class="source-inline"><span class="kobospan" id="kobo.137.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.138.1"> might look something </span><span><span class="kobospan" id="kobo.139.1">as follows.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.140.1">We define an array of </span><a id="_idIndexMarker180" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.141.1">options. </span><span class="kobospan" id="kobo.141.2">Here, we structure them as a list of objects with a </span><strong class="source-inline"><span class="kobospan" id="kobo.142.1">value</span></strong><span class="kobospan" id="kobo.143.1"> key that’s </span><span><span class="kobospan" id="kobo.144.1">a string:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.145.1">
const options = [
  { value: 'apple' },
  { value: 'pear' },
  { value: 'orange' },
  { value: 'grape' },
  { value: 'banana' },
];</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.146.1">We can then use </span><strong class="source-inline"><span class="kobospan" id="kobo.147.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.148.1"> by ensuring that </span><strong class="source-inline"><span class="kobospan" id="kobo.149.1">props.options</span></strong><span class="kobospan" id="kobo.150.1"> is an array </span><span><span class="kobospan" id="kobo.151.1">of strings:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.152.1">
function App() {
  return (
    &lt;&gt;
      &lt;CoupledSelect
        options={options.map((option) =&gt; option.value)}
      /&gt;
    &lt;&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.153.1">Next, we can save </span><strong class="source-inline"><span class="kobospan" id="kobo.154.1">selectedOption</span></strong><span class="kobospan" id="kobo.155.1"> by using the </span><strong class="source-inline"><span class="kobospan" id="kobo.156.1">useState </span></strong><span class="kobospan" id="kobo.157.1">hook. </span><span class="kobospan" id="kobo.157.2">We will name this particular piece of state </span><strong class="source-inline"><span class="kobospan" id="kobo.158.1">selectedOption</span></strong><span class="kobospan" id="kobo.159.1"> and its update function </span><strong class="source-inline"><span class="kobospan" id="kobo.160.1">setSelectedOption</span></strong><span class="kobospan" id="kobo.161.1">. </span><span class="kobospan" id="kobo.161.2">This will allow us to make </span><span><strong class="source-inline"><span class="kobospan" id="kobo.162.1">CoupledSelect</span></strong></span><span><span class="kobospan" id="kobo.163.1"> interactive:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.164.1">
function App() {
  const [selectedOption, setSelectedOption] = useState();
  return (
    &lt;&gt;
      &lt;p&gt;Selected Option: {selectedOption}&lt;/p&gt;
      &lt;CoupledSelect
        selectedOption={selectedOption}
        onChange={(selectedOption) =&gt; setSelectedOption
          (selectedOption)}
        options={options.map((option) =&gt; option.value)}
      /&gt;
    &lt;&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.165.1">Finally, we will set an initial </span><a id="_idIndexMarker181" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.166.1">value for </span><strong class="source-inline"><span class="kobospan" id="kobo.167.1">selectedOption</span></strong><span class="kobospan" id="kobo.168.1"> to show that this functionality of the </span><strong class="source-inline"><span class="kobospan" id="kobo.169.1">CoupledSelect</span></strong> <span><span class="kobospan" id="kobo.170.1">component works:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.171.1">
function App() {
  const [selectedOption, setSelectedOption] = useState
    (options[3].value);
  // no change to the returned JSX
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.172.1">Starting with the initial </span><strong class="source-inline"><span class="kobospan" id="kobo.173.1">selectedOption</span></strong><span class="kobospan" id="kobo.174.1"> functionality, we can see that the item at index 3 of the options array, </span><strong class="source-inline"><span class="kobospan" id="kobo.175.1">{ value: 'grape' }</span></strong><span class="kobospan" id="kobo.176.1">, is the initially selected option, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.177.1">Figure 4</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.178.1">.1</span></em></span><span><span class="kobospan" id="kobo.179.1">:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer019">
<span class="kobospan" id="kobo.180.1"><img alt="Figure 4.1: The CoupledSelect initial state, with grape selected" src="image/B19109_04_1.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.181.1">Figure 4.1: The CoupledSelect initial state, with grape selected</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.182.1">When opening </span><strong class="source-inline"><span class="kobospan" id="kobo.183.1">select</span></strong><span class="kobospan" id="kobo.184.1">, the </span><strong class="bold"><span class="kobospan" id="kobo.185.1">grape</span></strong><span class="kobospan" id="kobo.186.1"> is also selected, which means </span><strong class="source-inline"><span class="kobospan" id="kobo.187.1">select</span></strong><span class="kobospan" id="kobo.188.1"> is in the </span><span><span class="kobospan" id="kobo.189.1">correct state.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer020">
<span class="kobospan" id="kobo.190.1"><img alt="Figure 4.2: The CoupledSelect select open state, hovering on the orange option" src="image/B19109_04_2.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.191.1">Figure 4.2: The CoupledSelect select open state, hovering on the orange option</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.192.1">Finally, when we select a different option, </span><strong class="bold"><span class="kobospan" id="kobo.193.1">orange</span></strong><span class="kobospan" id="kobo.194.1">, we see it’s reflected both in the select element and out of it (see </span><span><em class="italic"><span class="kobospan" id="kobo.195.1">Figure 4</span></em></span><em class="italic"><span class="kobospan" id="kobo.196.1">.3</span></em><span class="kobospan" id="kobo.197.1">), meaning our integrated </span><strong class="source-inline"><span class="kobospan" id="kobo.198.1">onChange</span></strong><span class="kobospan" id="kobo.199.1"> handler also works </span><span><span class="kobospan" id="kobo.200.1">as expected.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer021">
<span class="kobospan" id="kobo.201.1"><img alt="Figure 4.3: In the CoupledSelect post-selection state, orange is now selected" src="image/B19109_04_3.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.202.1">Figure 4.3: In the CoupledSelect post-selection state, orange is now selected</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.203.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.204.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.205.1"> component has limited flexibility due to the </span><strong class="source-inline"><span class="kobospan" id="kobo.206.1">options.map()</span></strong><span class="kobospan" id="kobo.207.1"> call in the render function. </span><span class="kobospan" id="kobo.207.2">Since we’re</span><a id="_idIndexMarker182" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.208.1"> using the option variable as the option element’s value, it must be a string or number. </span><span class="kobospan" id="kobo.208.2">The value is also equal to the rendered text content of the option element, but there are often situations where we want to display something different from the value that we’re storing. </span><span class="kobospan" id="kobo.208.3">It’s a presentation versus persistence concern here. </span><span class="kobospan" id="kobo.208.4">For example, we can’t change the values rendered without changing what’s being stored </span><span><span class="kobospan" id="kobo.209.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.210.1">onChange</span></strong></span><span><span class="kobospan" id="kobo.211.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.212.1">If we want to add a </span><strong class="source-inline"><span class="kobospan" id="kobo.213.1">Fruit</span></strong><span class="kobospan" id="kobo.214.1">: prefix to </span><strong class="source-inline"><span class="kobospan" id="kobo.215.1">select</span></strong><span class="kobospan" id="kobo.216.1">, a naive approach is to implement it </span><span><span class="kobospan" id="kobo.217.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.218.1">
&lt;CoupledSelect
  {/* other props don't change */}
  options={options.map((option) =&gt; `Fruit:
     ${option.value}`)}
/&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.219.1">Unfortunately, this doesn’t work as expected, as the initial selection doesn’t </span><span><span class="kobospan" id="kobo.220.1">work anymore:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer022">
<span class="kobospan" id="kobo.221.1"><img alt="Figure 4.4: The CoupledSelect initial state, where the initial selection does not work correctly" src="image/B19109_04_4.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.222.1">Figure 4.4: The CoupledSelect initial state, where the initial selection does not work correctly</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.223.1">When opening the </span><strong class="source-inline"><span class="kobospan" id="kobo.224.1">select,</span></strong><span class="kobospan" id="kobo.225.1"> things seem to work OK; we can see the </span><strong class="bold"><span class="kobospan" id="kobo.226.1">Fruit:</span></strong><span class="kobospan" id="kobo.227.1"> prefix for all the options, as shown in </span><span><em class="italic"><span class="kobospan" id="kobo.228.1">Figure 4</span></em></span><span><em class="italic"><span class="kobospan" id="kobo.229.1">.5</span></em></span><span><span class="kobospan" id="kobo.230.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer023">
<span class="kobospan" id="kobo.231.1"><img alt="Figure 4.5: The CoupledSelect open state, with the Fruit: prefix" src="image/B19109_04_5.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.232.1">Figure 4.5: The CoupledSelect open state, with the Fruit: prefix</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.233.1">On selection of a new option, we can see that what’s being stored in the </span><strong class="source-inline"><span class="kobospan" id="kobo.234.1">selectedOption</span></strong><span class="kobospan" id="kobo.235.1"> is </span><strong class="bold"><span class="kobospan" id="kobo.236.1">Fruit: pear</span></strong><span class="kobospan" id="kobo.237.1"> instead </span><span><span class="kobospan" id="kobo.238.1">of </span></span><span><strong class="bold"><span class="kobospan" id="kobo.239.1">pear</span></strong></span><span><span class="kobospan" id="kobo.240.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer024">
<span class="kobospan" id="kobo.241.1"><img alt="Figure 4.6: The CoupledSelect post-selection state – note that the selected option Fruit: pear includes the prefix Fruit:" src="image/B19109_04_6.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.242.1">Figure 4.6: The CoupledSelect post-selection state – note that the selected option Fruit: pear includes the prefix Fruit:</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.243.1">Therefore, the </span><strong class="source-inline"><span class="kobospan" id="kobo.244.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.245.1"> component </span><a id="_idIndexMarker183" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.246.1">can’t be used flexibly, due to the coupling of the render logic and the </span><span><span class="kobospan" id="kobo.247.1">data logic.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.248.1">We’ll now see how render props could have alleviated this issue by decoupling data and </span><span><span class="kobospan" id="kobo.249.1">rendering logic.</span></span></p>
<h2 id="_idParaDest-74" class="calibre7"><span class="kobospan" id="kobo.250.1">I</span><a id="_idTextAnchor137" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor138" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.251.1">mplementation/example</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.252.1">In our </span><strong class="source-inline"><span class="kobospan" id="kobo.253.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.254.1"> example, we </span><a id="_idIndexMarker184" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.255.1">saw how the stored data and what is displayed to the user are tightly coupled. </span><span class="kobospan" id="kobo.255.2">We’ll now see how to break that coupling using </span><span><span class="kobospan" id="kobo.256.1">render props.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.257.1">Decoupling presentation from data logic by using render props</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.258.1">An alternative way to have </span><a id="_idIndexMarker185" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.259.1">written the </span><strong class="source-inline"><span class="kobospan" id="kobo.260.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.261.1"> component with render props is as follows. </span><span class="kobospan" id="kobo.261.2">The key additional prop we’re passing is </span><strong class="source-inline"><span class="kobospan" id="kobo.262.1">renderOption</span></strong><span class="kobospan" id="kobo.263.1">, a render prop. </span><span class="kobospan" id="kobo.263.2">Most of the remaining components are similar but are included </span><span><span class="kobospan" id="kobo.264.1">for completeness:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.265.1">
export function SelectRenderProps({
  selectedOption,
  options,
  renderOption,
  onChange,
}) {
  const onChangeHandler = (event) =&gt; {
    if (onChange) onChange(event.target.value);
  };
  return (
    &lt;select onChange={onChangeHandler} value=
      {selectedOption}&gt;
      {options.map((option) =&gt; renderOption(option))}
    &lt;/select&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.266.1">Usage of the </span><strong class="source-inline"><span class="kobospan" id="kobo.267.1">SelectRenderProps </span></strong><span class="kobospan" id="kobo.268.1">component is very similar to that of </span><strong class="source-inline"><span class="kobospan" id="kobo.269.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.270.1">. </span><span class="kobospan" id="kobo.270.2">The only additional prop we need to provide an implementation for is the </span><strong class="source-inline"><span class="kobospan" id="kobo.271.1">renderOption</span></strong><span class="kobospan" id="kobo.272.1"> prop, which we implement with </span><a id="_idIndexMarker186" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.273.1">a function that returns an </span><span><strong class="source-inline"><span class="kobospan" id="kobo.274.1">option</span></strong></span><span><span class="kobospan" id="kobo.275.1"> element:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.276.1">
function App() {
  return (
    &lt;SelectRenderProps
      selectedOption={selectedOption}
      onChange={(selectedOption) =&gt; setSelectedOption
        (selectedOption)}
      options={options.map((option) =&gt; option.value)}
      renderOption={(option) =&gt; (
        &lt;option value={option} key={option}&gt;
          {option}
        &lt;/option&gt;
      )}
    /&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.277.1">So far, the implementation is very similar to </span><strong class="source-inline"><span class="kobospan" id="kobo.278.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.279.1">, apart from the fact that the parent of </span><strong class="source-inline"><span class="kobospan" id="kobo.280.1">SelectRenderProps</span></strong><span class="kobospan" id="kobo.281.1"> now decides how to render </span><span><span class="kobospan" id="kobo.282.1">an option.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.283.1">Given the same requirement to prefix the options with </span><strong class="source-inline"><span class="kobospan" id="kobo.284.1">Fruit:</span></strong><span class="kobospan" id="kobo.285.1">, we can now implement it </span><span><span class="kobospan" id="kobo.286.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.287.1">
&lt;SelectRenderProps
  {/* rest of the props remain unchanged */}
  renderOption={(option) =&gt; (
    &lt;option value={option} key={option}&gt;
      Fruit: {option}
    &lt;/option&gt;
  )}
/&gt;</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.288.1">Note that counter to what we did with </span><strong class="source-inline"><span class="kobospan" id="kobo.289.1">CoupledSelect</span></strong><span class="kobospan" id="kobo.290.1">, we’re not even touching the options prop. </span><span class="kobospan" id="kobo.290.2">Our only change is to the </span><strong class="source-inline"><span class="kobospan" id="kobo.291.1">renderOption</span></strong><span class="kobospan" id="kobo.292.1"> prop. </span><span class="kobospan" id="kobo.292.2">We’ll now test this example and show that decoupling the rendering logic (with a render prop) from the data logic works much better </span><span><span class="kobospan" id="kobo.293.1">for extensibility.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.294.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.295.1">SelectRenderProps</span></strong><span class="kobospan" id="kobo.296.1"> initial state renders correctly, with </span><strong class="bold"><span class="kobospan" id="kobo.297.1">Fruit: grape</span></strong><span class="kobospan" id="kobo.298.1"> inside </span><strong class="source-inline"><span class="kobospan" id="kobo.299.1">select</span></strong><span class="kobospan" id="kobo.300.1"> and </span><strong class="bold"><span class="kobospan" id="kobo.301.1">grape</span></strong><span class="kobospan" id="kobo.302.1"> in the </span><span><span class="kobospan" id="kobo.303.1">parent component:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer025">
<span class="kobospan" id="kobo.304.1"><img alt="Figure 4.7: The SelectRenderProps initial state – the options and initial selection are displayed correctly" src="image/B19109_04_7.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.305.1">Figure 4.7: The SelectRenderProps initial state – the options and initial selection are displayed correctly</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.306.1">When we open </span><strong class="source-inline"><span class="kobospan" id="kobo.307.1">select</span></strong><span class="kobospan" id="kobo.308.1">, we can see that the </span><strong class="bold"><span class="kobospan" id="kobo.309.1">Fruit:</span></strong><span class="kobospan" id="kobo.310.1"> prefix </span><span><span class="kobospan" id="kobo.311.1">is rendered.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer026">
<span class="kobospan" id="kobo.312.1"><img alt="Figure 4.8: The SelectRenderProps open state – the options include the Fruit: prefix" src="image/B19109_04_8.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.313.1">Figure 4.8: The SelectRenderProps open state – the options include the Fruit: prefix</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.314.1">Finally, upon selection of an </span><a id="_idIndexMarker187" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.315.1">option, the state is updated correctly, the parent stores </span><strong class="bold"><span class="kobospan" id="kobo.316.1">banana</span></strong><span class="kobospan" id="kobo.317.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.318.1">select</span></strong><span class="kobospan" id="kobo.319.1"> has </span><strong class="bold"><span class="kobospan" id="kobo.320.1">Fruit: </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.321.1">banana</span></strong></span><span><span class="kobospan" id="kobo.322.1"> selected:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer027">
<span class="kobospan" id="kobo.323.1"><img alt="Figure 4.9: The SelectRenderProps post-selection state – the selected option does not include the Fruit: prefix" src="image/B19109_04_9.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.324.1">Figure 4.9: The SelectRenderProps post-selection state – the selected option does not include the Fruit: prefix</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.325.1">We’ve now seen how render props can allow the rendering logic and data logic to be edited separately when making a </span><span><span class="kobospan" id="kobo.326.1">rendering change.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.327.1">Now that we’ve implemented a basic example of the render prop pattern, we’ll see how libraries leverage it to provide flexibility </span><span><span class="kobospan" id="kobo.328.1">to consumers.</span></span></p>
<h3 class="calibre9"><span class="kobospan" id="kobo.329.1">A</span><a id="_idTextAnchor139" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor140" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.330.1">dditional render prop patterns when providing components with flexible presentation</span></h3>
<p class="calibre3"><span class="kobospan" id="kobo.331.1">The React form </span><a id="_idIndexMarker188" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.332.1">management library Formik uses a render prop to provide form state back to consumers. </span><span class="kobospan" id="kobo.332.2">The render prop is the children prop of the Formik component. </span><span class="kobospan" id="kobo.332.3">In other words, what’s between the opening </span><strong class="source-inline"><span class="kobospan" id="kobo.333.1">&lt;Formik&gt;</span></strong><span class="kobospan" id="kobo.334.1"> tag and the closing </span><strong class="source-inline"><span class="kobospan" id="kobo.335.1">&lt;/Formik&gt;</span></strong><span class="kobospan" id="kobo.336.1"> tag is a function, which provides props such as values, </span><strong class="source-inline"><span class="kobospan" id="kobo.337.1">isSubmitting</span></strong><span class="kobospan" id="kobo.338.1">, </span><span><span class="kobospan" id="kobo.339.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.340.1">handleChange</span></strong></span><span><span class="kobospan" id="kobo.341.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.342.1">See the following example, which is a single-input form that takes a name, validates that it’s at least two characters long, and allows the form to </span><span><span class="kobospan" id="kobo.343.1">be submitted.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.344.1">To begin, we’ll render the form and input that will store the </span><strong class="source-inline"><span class="kobospan" id="kobo.345.1">fields</span></strong><span class="kobospan" id="kobo.346.1"> value </span><span><span class="kobospan" id="kobo.347.1">in </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.348.1">Formik</span></strong></span><span><span class="kobospan" id="kobo.349.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.350.1">
import { Formik } from 'formik';
export function FormikIntegrationExample() {
  return (
    &lt;Formik
      initialValues={{ name: '' }}
    &gt;
      {({
        values,
        errors,
        touched,
        handleChange,
        handleBlur,
        handleSubmit,
        isSubmitting,
      }) =&gt; (
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;fieldset&gt;
            &lt;input
              type="text"
              id="name"
              name="name"
              onChange={handleChange}
              onBlur={handleBlur}
              value={values.name}
              aria-required="true"
            /&gt;
          &lt;/fieldset&gt;
        &lt;/form&gt;
      )}
    &lt;/Formik&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.351.1">Next, we can add submission </span><a id="_idIndexMarker189" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.352.1">handling and an inline validation </span><span><span class="kobospan" id="kobo.353.1">error display:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.354.1">
import { Formik } from 'formik';
export function FormikIntegrationExample() {
  return (
    &lt;Formik
      initialValues={{ name: '' }}
      validate={(values) =&gt; {
        const errors = {};
        if (!values.name) {
          errors.name = 'Required';
        } else if (values.name.length &lt; 2) {
          errors.name = 'Name too short';
        }
        return errors;
      }}
      onSubmit={(values, { setSubmitting }) =&gt; {
        setTimeout(() =&gt; {
          alert(JSON.stringify(values, null, 2));
          setSubmitting(false);
        }, 400);
      }}
    &gt;
      {({
        /* no change to props in render prop */
      }) =&gt; (
        &lt;form onSubmit={handleSubmit}&gt;
          &lt;fieldset&gt;
            &lt;div&gt;
              &lt;label htmlFor="name"&gt;
                Name (Required)
                &lt;br /&gt;
                {errors.name &amp;&amp; touched.name ? </span><span class="kobospan1" id="kobo.354.2">(
                  &lt;&gt;Error: {errors.name}&lt;/&gt;
                ) : (
                  &lt;&gt;&amp;nbsp;&lt;/&gt;
                )}
              &lt;/label&gt;
            &lt;/div&gt;
            {/* no change to the input */}
          &lt;/fieldset&gt;
          &lt;button type="submit" disabled={isSubmitting}&gt;
            Submit
          &lt;/button&gt;
        &lt;/form&gt;
      )}
    &lt;/Formik&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.355.1">In the initial state, we see the form with a single input and a </span><span><span class="kobospan" id="kobo.356.1">submit button:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer028">
<span class="kobospan" id="kobo.357.1"><img alt="Figure 4.10: The Formik single field and Submit button in its initial state, which includes the Name (Required) label" src="image/B19109_04_10.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.358.1">Figure 4.10: The Formik single field and Submit button in its initial state, which includes the Name (Required) label</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.359.1">When we click (or otherwise focus) on the name input and then un-focus (the </span><em class="italic"><span class="kobospan" id="kobo.360.1">blur</span></em><span class="kobospan" id="kobo.361.1"> web event), the validation triggers, letting</span><a id="_idIndexMarker190" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.362.1"> us know that the field </span><span><span class="kobospan" id="kobo.363.1">is required.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer029">
<span class="kobospan" id="kobo.364.1"><img alt="Figure 4.11: Name input blur validation - Error: Required validation error" src="image/B19109_04_11.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.365.1">Figure 4.11: Name input blur validation - Error: Required validation error</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.366.1">If we input only one character and blur, we get a validation error, </span><strong class="bold"><span class="kobospan" id="kobo.367.1">Name </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.368.1">too short</span></strong></span><span><span class="kobospan" id="kobo.369.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer030">
<span class="kobospan" id="kobo.370.1"><img alt="Figure 4.12: H in the name input triggers the validation error Name too short" src="image/B19109_04_12.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.371.1">Figure 4.12: H in the name input triggers the validation error Name too short</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.372.1">When a name that meets the validation criteria is met, the validation errors </span><span><span class="kobospan" id="kobo.373.1">are cleared.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer031">
<span class="kobospan" id="kobo.374.1"><img alt="Figure 4.13: A valid Formik field clears the validation errors" src="image/B19109_04_13.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.375.1">Figure 4.13: A valid Formik field clears the validation errors</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.376.1">Finally, when we click </span><strong class="bold"><span class="kobospan" id="kobo.377.1">Submit</span></strong><span class="kobospan" id="kobo.378.1">, we get a browser alert with </span><strong class="bold"><span class="kobospan" id="kobo.379.1">{ “name”: “</span></strong><span><strong class="bold"><span class="kobospan" id="kobo.380.1">Hugo” }</span></strong></span><span><span class="kobospan" id="kobo.381.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer032">
<span class="kobospan" id="kobo.382.1"><img alt="Figure 4.14: An alert on submission with { “name”: “Hugo” }" src="image/B19109_04_14.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.383.1">Figure 4.14: An alert on submission with { “name”: “Hugo” }</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.384.1">Now, let’s take a look at </span><a id="_idIndexMarker191" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.385.1">some limitations of the render </span><span><span class="kobospan" id="kobo.386.1">prop pattern.</span></span></p>
<h2 id="_idParaDest-75" class="calibre7"><a id="_idTextAnchor141" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.387.1">Limitations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.388.1">One key limitation </span><a id="_idIndexMarker192" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.389.1">of the render prop pattern is that it provides units of reuse and integration that are functions and not components. </span><span class="kobospan" id="kobo.389.2">It’s possible for a lot of the logic to end up in the render prop function itself that could have been better served by creating a </span><span><span class="kobospan" id="kobo.390.1">new component.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.391.1">Render props can make code harder to test when using a shallow renderer such as Enzyme’s </span><strong class="source-inline"><span class="kobospan" id="kobo.392.1">shallow</span></strong><span class="kobospan" id="kobo.393.1">, which won’t render the full component tree. </span><span class="kobospan" id="kobo.393.2">Components making heavy use of render props should probably use a full “mount” rendering approach so that all the children of the component (including the render props) </span><span><span class="kobospan" id="kobo.394.1">are rendered.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.395.1">In this section, we introduced you to the render prop pattern and described its use cases, examples, </span><span><span class="kobospan" id="kobo.396.1">and limitations.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.397.1">In the next section, we’ll learn about another reactive view library pattern – </span><span><span class="kobospan" id="kobo.398.1">higher-order components.</span></span></p>
<h1 id="_idParaDest-76" class="calibre5"><span class="kobospan" id="kobo.399.1">The hi</span><a id="_idTextAnchor142" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.400.1">gher-order component pattern</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.401.1">A higher-order </span><a id="_idIndexMarker193" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.402.1">component is a function that takes a component and returns a component. </span><span class="kobospan" id="kobo.402.2">The definition of higher-order components is similar to higher-order functions, which JavaScript supports. </span><span class="kobospan" id="kobo.402.3">Higher-order functions are functions that receive a function as a parameter or return </span><span><span class="kobospan" id="kobo.403.1">a function.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.404.1">The higher-order component pattern allows us to pass additional props to </span><span><span class="kobospan" id="kobo.405.1">a component.</span></span></p>
<h2 id="_idParaDest-77" class="calibre7"><span class="kobospan" id="kobo.406.1">Implem</span><a id="_idTextAnchor143" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor144" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.407.1">entation/example</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.408.1">The following is a </span><a id="_idIndexMarker194" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.409.1">simple render prop, </span><strong class="source-inline"><span class="kobospan" id="kobo.410.1">withLocation</span></strong><span class="kobospan" id="kobo.411.1">, which injects </span><strong class="source-inline"><span class="kobospan" id="kobo.412.1">window.location.href</span></strong><span class="kobospan" id="kobo.413.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.414.1">window.location.origin</span></strong><span class="kobospan" id="kobo.415.1"> into a component </span><span><span class="kobospan" id="kobo.416.1">as props:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.417.1">
const location = {
  href: window.location.href,
  origin: window.location.origin,
};
export function withLocation(Component) {
  return (props) =&gt; {
    return &lt;Component location={location} {...props} /&gt;;
  };
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.418.1">The pattern that’s used when using higher-order components is to export default the higher-order component called with the local component – in this case, </span><strong class="source-inline"><span class="kobospan" id="kobo.419.1">withLocation(Location)</span></strong><span class="kobospan" id="kobo.420.1">. </span><span class="kobospan" id="kobo.420.2">The </span><strong class="source-inline"><span class="kobospan" id="kobo.421.1">Location</span></strong><span class="kobospan" id="kobo.422.1"> component is a simple component that takes location as provided by </span><strong class="source-inline"><span class="kobospan" id="kobo.423.1">withLocation</span></strong><span class="kobospan" id="kobo.424.1"> and </span><span><span class="kobospan" id="kobo.425.1">renders it:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.426.1">
// in `location.jsx` file
function Location({ location }) {
  return (
    &lt;&gt;
      location.href: {location.href}, location.origin:
        {location.origin}
    &lt;/&gt;
  );
}
export default withLocation(Location);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.427.1">In the consumer of </span><strong class="source-inline"><span class="kobospan" id="kobo.428.1">Location</span></strong><span class="kobospan" id="kobo.429.1">, what we import as </span><strong class="source-inline"><span class="kobospan" id="kobo.430.1">Location</span></strong><span class="kobospan" id="kobo.431.1"> is the default export – that </span><span><span class="kobospan" id="kobo.432.1">is, </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.433.1">withLocation(Location)</span></strong></span><span><span class="kobospan" id="kobo.434.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.435.1">
import Location from './location';
function App() {
  return &lt;Location&gt;;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.436.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.437.1">Location</span></strong><span class="kobospan" id="kobo.438.1"> component renders </span><strong class="source-inline"><span class="kobospan" id="kobo.439.1">location.href</span></strong><span class="kobospan" id="kobo.440.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.441.1">location.origin</span></strong><span class="kobospan" id="kobo.442.1">, based on what’s provided </span><span><span class="kobospan" id="kobo.443.1">by </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.444.1">withLocation</span></strong></span><span><span class="kobospan" id="kobo.445.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer033">
<span class="kobospan" id="kobo.446.1"><img alt="" role="presentation" src="image/B19109_04_15.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.447.1"> Figure 4.15: The Location component rendering the href and origin, based on what’s provided by withlocation</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.448.1">We’ve now</span><a id="_idIndexMarker195" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.449.1"> seen a simple example of a key benefit of higher-order components, which is that the component doing the rendering doesn’t need to be directly aware of where to receive information; it can read </span><span><span class="kobospan" id="kobo.450.1">props instead.</span></span><a id="_idTextAnchor145" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor146" class="pcalibre1 calibre6 pcalibre"/></p>
<h2 id="_idParaDest-78" class="calibre7"><a id="_idTextAnchor147" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.451.1">Use cases</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.452.1">The </span><strong class="source-inline"><span class="kobospan" id="kobo.453.1">withLocation</span></strong><span class="kobospan" id="kobo.454.1"> example</span><a id="_idIndexMarker196" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.455.1"> already showed a simple reason why we could use higher-order components – to maintain separation </span><span><span class="kobospan" id="kobo.456.1">of concerns.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.457.1">In our Location component example, it’s completely possible for Location to access </span><strong class="source-inline"><span class="kobospan" id="kobo.458.1">window.location</span></strong><span class="kobospan" id="kobo.459.1"> directly. </span><span class="kobospan" id="kobo.459.2">What that would mean, however, is that the Location component is aware of global objects, which could be undesirable. </span><span class="kobospan" id="kobo.459.3">For example, it might make unit-testing of </span><strong class="source-inline"><span class="kobospan" id="kobo.460.1">Location</span></strong><span class="kobospan" id="kobo.461.1"> more difficult, since it’s accessing something beyond </span><span><span class="kobospan" id="kobo.462.1">its props</span><a id="_idTextAnchor148" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor149" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.463.1">.</span></span></p>
<h2 id="_idParaDest-79" class="calibre7"><a id="_idTextAnchor150" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.464.1">Limitations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.465.1">As with all abstractions, higher-order</span><a id="_idIndexMarker197" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.466.1"> components are a layer of indirection. </span><span class="kobospan" id="kobo.466.2">This means that tracing where a prop comes from can be more difficult than when props are passed explicitly from the </span><span><span class="kobospan" id="kobo.467.1">parent component.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.468.1">Tracing the props becomes even more difficult when the higher-order component comes from a third-party library (and thus is harder </span><span><span class="kobospan" id="kobo.469.1">to inspect).</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.470.1">Higher-order components can have a cost in terms of rendering in the browser, since we wrap our component in another component if we stack too many higher-order components on top of </span><span><span class="kobospan" id="kobo.471.1">each other.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.472.1">For example, the following </span><strong class="source-inline"><span class="kobospan" id="kobo.473.1">ConnectedComponent</span></strong><span class="kobospan" id="kobo.474.1"> uses three </span><span><span class="kobospan" id="kobo.475.1">higher-level components:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.476.1">
const ConnectedComponent = withRouter(
  withHttpClient(withAnotherDependency
    (ComponentWithDependencies))
);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.477.1">As a consumer of </span><strong class="source-inline"><span class="kobospan" id="kobo.478.1">ConnectedComponent</span></strong><span class="kobospan" id="kobo.479.1">, we’ll likely render four components – the ones provided by </span><strong class="source-inline"><span class="kobospan" id="kobo.480.1">withRouter</span></strong><span class="kobospan" id="kobo.481.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.482.1">withHttpClient</span></strong><span class="kobospan" id="kobo.483.1">, </span><strong class="source-inline"><span class="kobospan" id="kobo.484.1">withAnotherDependency</span></strong><span class="kobospan" id="kobo.485.1">, and </span><strong class="source-inline"><span class="kobospan" id="kobo.486.1">ComponentWithDependencies</span></strong><span class="kobospan" id="kobo.487.1">. </span><span class="kobospan" id="kobo.487.2">If we had another way to inject the router, HTTP client and another dependency, we could reduce the number of components to one, only </span><span><span class="kobospan" id="kobo.488.1">needing </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.489.1">ComponentWithDependencies</span></strong></span><span><span class="kobospan" id="kobo.490.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.491.1">This </span><a id="_idIndexMarker198" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.492.1">drawback leads us to the next topic in this chapter – hooks. </span><span class="kobospan" id="kobo.492.2">Hooks provide us a way to access data and logic in similar scenarios as higher-order components, without additional components being rendered. </span><span class="kobospan" id="kobo.492.3">Hooks are a great replacement for logic-heavy </span><span><span class="kobospan" id="kobo.493.1">higher-order componen</span><a id="_idTextAnchor151" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor152" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor153" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.494.1">ts.</span></span></p>
<h1 id="_idParaDest-80" class="calibre5"><a id="_idTextAnchor154" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.495.1">The hooks pattern</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.496.1">We’ve</span><a id="_idIndexMarker199" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.497.1"> now covered </span><a id="_idIndexMarker200" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.498.1">what might be considered </span><em class="italic"><span class="kobospan" id="kobo.499.1">legacy</span></em><span class="kobospan" id="kobo.500.1"> patterns in React – render props and </span><span><span class="kobospan" id="kobo.501.1">higher-order components.</span></span></p>
<p class="author-quote"><span class="kobospan" id="kobo.502.1">You’ll note that the React documentation page about higher-order components has the following disclaimer: “Higher-order components are not commonly used in modern React code.”</span></p>
<p class="callout-heading"><span class="kobospan" id="kobo.503.1">Additional reading</span></p>
<p class="callout"><span class="kobospan" id="kobo.504.1">The</span><a id="_idIndexMarker201" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.505.1"> React </span><a id="_idIndexMarker202" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.506.1">documentation for </span><strong class="source-inline1"><span class="kobospan" id="kobo.507.1">useState</span></strong><span class="kobospan" id="kobo.508.1"> and </span><span><strong class="source-inline1"><span class="kobospan" id="kobo.509.1">useEffect</span></strong></span><span><span class="kobospan" id="kobo.510.1"> hooks:</span></span></p>
<p class="callout"><span><strong class="source-inline1"><span class="kobospan" id="kobo.511.1">useState</span></strong></span><span><span class="kobospan" id="kobo.512.1">: </span></span><a href="https://react.dev/reference/react/useState" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.513.1">https://react.dev/reference/react/useState</span></span></a></p>
<p class="callout"><span><strong class="source-inline1"><span class="kobospan" id="kobo.514.1">useEffect</span></strong></span><span><span class="kobospan" id="kobo.515.1">: </span></span><a href="https://react.dev/reference/react/useEffect" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.516.1">https://react.dev/reference/react/useEffect</span></span></a></p>
<p class="calibre3"><span class="kobospan" id="kobo.517.1">So, what we know so far is that hooks allow us to do what we did with render props and that higher-order components are not recommended any more. </span><span class="kobospan" id="kobo.517.2">This is because hooks provide a way to access all the React primitives, including state and the component </span><span><span class="kobospan" id="kobo.518.1">life cycle.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.519.1">React provides </span><a id="_idIndexMarker203" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.520.1">built-in hooks. </span><span class="kobospan" id="kobo.520.2">The two we’ll focus on are </span><strong class="source-inline"><span class="kobospan" id="kobo.521.1">useState</span></strong><span class="kobospan" id="kobo.522.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.523.1">useEffect</span></strong><span class="kobospan" id="kobo.524.1">. </span><span class="kobospan" id="kobo.524.2">One key feature of hooks is that we can write custom hooks that build on top of React built-in </span><a id="_idIndexMarker204" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.525.1">hooks and other custom hooks, which means we have a new way to share logic </span><a id="_idTextAnchor155" class="pcalibre1 calibre6 pcalibre"/><span><span class="kobospan" id="kobo.526.1">in React.</span></span></p>
<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor156" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.527.1">An implementation/example</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.528.1">We’ll implement simple data</span><a id="_idIndexMarker205" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.529.1"> fetching using the class React components, and then hooks. </span><span class="kobospan" id="kobo.529.2">This will showcase how state and life cycle events are handled in </span><span><span class="kobospan" id="kobo.530.1">both cases.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.531.1">We’ll start with the class components. </span><span class="kobospan" id="kobo.531.2">The regular way to implement data fetching is by using life cycle hooks; the initial one tends to </span><span><span class="kobospan" id="kobo.532.1">be </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.533.1">componentDidMount</span></strong></span><span><span class="kobospan" id="kobo.534.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.535.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.536.1">BasketItemsClassical</span></strong><span class="kobospan" id="kobo.537.1"> component takes </span><strong class="source-inline"><span class="kobospan" id="kobo.538.1">httpClient</span></strong> <span><span class="kobospan" id="kobo.539.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.540.1">basketId</span></strong></span><span><span class="kobospan" id="kobo.541.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.542.1">The component’s constructor initializes a </span><strong class="source-inline"><span class="kobospan" id="kobo.543.1">state.basketSession</span></strong><span class="kobospan" id="kobo.544.1"> variable to an empty </span><span><span class="kobospan" id="kobo.545.1">object, </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.546.1">{}</span></strong></span><span><span class="kobospan" id="kobo.547.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.548.1">
import React from 'react';
export class BasketItemsClassical extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      basketSession: {},
    };
  }</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.549.1">Next, we’ll add a </span><strong class="source-inline"><span class="kobospan" id="kobo.550.1">setBasketSession</span></strong><span class="kobospan" id="kobo.551.1"> method, which will call </span><strong class="source-inline"><span class="kobospan" id="kobo.552.1">this.setState</span></strong><span class="kobospan" id="kobo.553.1"> to set </span><strong class="source-inline"><span class="kobospan" id="kobo.554.1">basketSession</span></strong><span class="kobospan" id="kobo.555.1"> as the </span><span><span class="kobospan" id="kobo.556.1">passed parameter.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.557.1">We’ll also add </span><strong class="source-inline"><span class="kobospan" id="kobo.558.1">componentDidMount</span></strong><span class="kobospan" id="kobo.559.1">, which calls </span><strong class="source-inline"><span class="kobospan" id="kobo.560.1">httpClient.get()</span></strong><span class="kobospan" id="kobo.561.1"> with the fakestoreapi.com URL</span><a id="_idIndexMarker206" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.562.1"> to load carts, using the </span><span><strong class="source-inline"><span class="kobospan" id="kobo.563.1">basketId</span></strong></span><span><span class="kobospan" id="kobo.564.1"> prop:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.565.1">
export class BasketItemsClassical extends React.Component {
  // no change to the constructor
  componentDidMount() {
    this.props.httpClient
      .get(`https://fakestoreapi.com/carts/${this.props.basketId}`)
      .then((session) =&gt; this.setBasketSession(session));
  }
  setBasketSession(session) {
    this.setState({ basketSession: session });
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.566.1">What this now means is that we should be able to render out the contents of </span><strong class="source-inline"><span class="kobospan" id="kobo.567.1">this.state.basketSession</span></strong><span class="kobospan" id="kobo.568.1"> in the component’s </span><span><strong class="source-inline"><span class="kobospan" id="kobo.569.1">render()</span></strong></span><span><span class="kobospan" id="kobo.570.1"> method:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.571.1">
export class BasketItemsClassical extends React.Component {
  // no change to the constructor, componentDidMount or
     setBasketSession
  render() {
    return &lt;pre&gt;{JSON.stringify(this.state.basketSession,
      null, 2)}&lt;/pre&gt;;
  }
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.572.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.573.1">BasketItemsClassical</span></strong><span class="kobospan" id="kobo.574.1"> can be used as follows by passing </span><strong class="source-inline"><span class="kobospan" id="kobo.575.1">httpClient</span></strong><span class="kobospan" id="kobo.576.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.577.1">basketId</span></strong> <span><span class="kobospan" id="kobo.578.1">as </span></span><span><a id="_idIndexMarker207" class="pcalibre1 calibre6 pcalibre"/></span><span><span class="kobospan" id="kobo.579.1">props:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.580.1">
export function BasketClassical({ basketId, httpClient }) {
  return (
    &lt;form&gt;
      &lt;fieldset&gt;
        &lt;label&gt;Class&lt;/label&gt;
        &lt;BasketItemsClassical basketId={basketId}
           httpClient={httpClient} /&gt;
      &lt;/fieldset&gt;
    &lt;/form&gt;
  );
}</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.581.1">BasketClassical</span></strong><span class="kobospan" id="kobo.582.1"> can then be used in our </span><strong class="source-inline"><span class="kobospan" id="kobo.583.1">App</span></strong><span class="kobospan" id="kobo.584.1">, </span><span><span class="kobospan" id="kobo.585.1">as follows:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.586.1">
const httpClient = {
  async get(url) {
    const response = await fetch(url);
    return await response.json();
  },
};
function App() {
  return (
    &lt;&gt;
      &lt;BasketClassical basketId="5" httpClient={httpClient} /&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.587.1">In the browser, this </span><a id="_idIndexMarker208" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.588.1">displays </span><span><span class="kobospan" id="kobo.589.1">as follows:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer034">
<span class="kobospan" id="kobo.590.1"><img alt="Figure 4.16: The Basket class component loading JSON data" src="image/B19109_04_16.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.591.1">Figure 4.16: The Basket class component loading JSON data</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.592.1">Here’s the same example with hooks; instead of using </span><strong class="source-inline"><span class="kobospan" id="kobo.593.1">componentDidMount</span></strong><span class="kobospan" id="kobo.594.1">, we can use the </span><strong class="source-inline"><span class="kobospan" id="kobo.595.1">useEffect </span></strong><span class="kobospan" id="kobo.596.1">hook, and instead of </span><strong class="source-inline"><span class="kobospan" id="kobo.597.1">this.state</span></strong><span class="kobospan" id="kobo.598.1"> in the constructor and </span><strong class="source-inline"><span class="kobospan" id="kobo.599.1">this.setState</span></strong><span class="kobospan" id="kobo.600.1">, we use the </span><strong class="source-inline"><span class="kobospan" id="kobo.601.1">useState</span></strong><span class="kobospan" id="kobo.602.1"> hook. </span><span class="kobospan" id="kobo.602.2">In order to use hooks, we use a React function component (React class components don’t </span><span><span class="kobospan" id="kobo.603.1">support hooks):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.604.1">
export function BasketItemsHooks({ basketId, httpClient }) {
  const [basketSession, setBasketSession] = useState({});
  useEffect(() =&gt; {
    httpClient
      .get(`https://fakestoreapi.com/carts/${basketId}`)
      .then((session) =&gt; setBasketSession(session));
  }, []);
  return &lt;pre&gt;{JSON.stringify(basketSession, null, 2)}&lt;/pre&gt;;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.605.1">Our </span><strong class="source-inline"><span class="kobospan" id="kobo.606.1">BasketItemsHooks</span></strong><span class="kobospan" id="kobo.607.1"> can be </span><a id="_idIndexMarker209" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.608.1">used in the same way as </span><strong class="source-inline"><span class="kobospan" id="kobo.609.1">BasketItemsClassical</span></strong><span class="kobospan" id="kobo.610.1">, by passing </span><strong class="source-inline"><span class="kobospan" id="kobo.611.1">httpClient</span></strong><span class="kobospan" id="kobo.612.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.613.1">basketId</span></strong> <span><span class="kobospan" id="kobo.614.1">as props:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.615.1">
export function BasketHooks({ basketId, httpClient }) {
  return (
    &lt;form&gt;
      &lt;fieldset&gt;
        &lt;label&gt;Hooks&lt;/label&gt;
        &lt;BasketItemsHooks basketId={basketId}
          httpClient={httpClient} /&gt;
      &lt;/fieldset&gt;
    &lt;/form&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.616.1">We’ll also need</span><a id="_idIndexMarker210" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.617.1"> to modify </span><strong class="source-inline"><span class="kobospan" id="kobo.618.1">App</span></strong><span class="kobospan" id="kobo.619.1"> to render </span><strong class="source-inline"><span class="kobospan" id="kobo.620.1">BasketHooks</span></strong><span class="kobospan" id="kobo.621.1"> in addition </span><span><span class="kobospan" id="kobo.622.1">to </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.623.1">BasketClassical</span></strong></span><span><span class="kobospan" id="kobo.624.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.625.1">
// no change to httpClient
function App() {
  return (
    &lt;&gt;
      &lt;BasketClassical basketId="5" httpClient={httpClient} /&gt;
      &lt;BasketHooks basketId="5" httpClient={httpClient} /&gt;
    &lt;/&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.626.1">Both </span><strong class="source-inline"><span class="kobospan" id="kobo.627.1">BasketHooks</span></strong><span class="kobospan" id="kobo.628.1"> (</span><span><em class="italic"><span class="kobospan" id="kobo.629.1">Figure 4</span></em></span><em class="italic"><span class="kobospan" id="kobo.630.1">.17</span></em><span class="kobospan" id="kobo.631.1">) and </span><strong class="source-inline"><span class="kobospan" id="kobo.632.1">BasketClassical</span></strong><span class="kobospan" id="kobo.633.1"> (</span><span><em class="italic"><span class="kobospan" id="kobo.634.1">Figure 4</span></em></span><em class="italic"><span class="kobospan" id="kobo.635.1">.16</span></em><span class="kobospan" id="kobo.636.1">) yield the same JSON output after the HTTP requests </span><span><span class="kobospan" id="kobo.637.1">are completed.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer035">
<span class="kobospan" id="kobo.638.1"><img alt="Figure 4.17: The Hooks basket loading JSON data" src="image/B19109_04_17.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.639.1">Figure 4.17: The Hooks basket loading JSON data</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.640.1">The hooks</span><a id="_idIndexMarker211" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.641.1"> approach is slightly more compact; each part of the functionality does feel a bit more self-contained. </span><span class="kobospan" id="kobo.641.2">For example, the initial state is handled in the same place that defines what the state update function will be in the hooks version. </span><span class="kobospan" id="kobo.641.3">In the class example, the </span><strong class="source-inline"><span class="kobospan" id="kobo.642.1">initialisation</span></strong><span class="kobospan" id="kobo.643.1"> state is in the constructor, and the state update function is a method. </span><span class="kobospan" id="kobo.643.2">In the </span><strong class="source-inline"><span class="kobospan" id="kobo.644.1">BasketClassical</span></strong><span class="kobospan" id="kobo.645.1"> example, there was the option to simplify the component by removing the state update method and using a direct </span><strong class="source-inline"><span class="kobospan" id="kobo.646.1">this.setState({ bookingSession: se</span><a id="_idTextAnchor157" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.647.1">ssion })</span></strong> <span><span class="kobospan" id="kobo.648.1">call.</span></span></p>
<h2 id="_idParaDest-82" class="calibre7"><a id="_idTextAnchor158" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.649.1">Use cases</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.650.1">A simple way to think about hooks and </span><a id="_idIndexMarker212" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.651.1">class or function components is </span><span><span class="kobospan" id="kobo.652.1">as follows:</span></span></p>
<ul class="calibre10">
<li class="calibre11"><span class="kobospan" id="kobo.653.1">Hooks for </span><span><span class="kobospan" id="kobo.654.1">shared logic</span></span></li>
<li class="calibre11"><span class="kobospan" id="kobo.655.1">Components for logic that is related </span><span><span class="kobospan" id="kobo.656.1">to rendering</span></span></li>
</ul>
<p class="calibre3"><span class="kobospan" id="kobo.657.1">The higher-order component and render prop patterns, which are used to separate presentation and business logic, are unlikely to be needed any more and can be replaced by </span><span><span class="kobospan" id="kobo.658.1">custom hooks.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.659.1">React hooks and</span><a id="_idIndexMarker213" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.660.1"> function components are the recommended way to develop modern </span><span><span class="kobospan" id="kobo.661.1">React applications.</span></span></p>
<h2 id="_idParaDest-83" class="calibre7"><a id="_idTextAnchor159" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.662.1">Limitations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.663.1">Hooks can’t </span><a id="_idIndexMarker214" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.664.1">be used in React class components, as detailed in the React documentation: </span><a href="https://react.dev/reference/react/Component#defining-a-class-component" class="pcalibre1 calibre6 pcalibre"><span class="kobospan" id="kobo.665.1">https://react.dev/reference/react/Component#defining-a-class-component</span></a><span class="kobospan" id="kobo.666.1">. </span><span class="kobospan" id="kobo.666.2">Note that function components are the recommended way to build </span><span><span class="kobospan" id="kobo.667.1">React components.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.668.1">In code bases with heavy usage of class components, higher-order components should remain in use instead of migrating components to functions in order to </span><span><span class="kobospan" id="kobo.669.1">use hooks.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.670.1">The last piece of the puzzle with React components is how to bypass the prop drilling problem and pass data without changing each component in a React component tree. </span><span class="kobospan" id="kobo.670.2">The pattern we use for this is the provider pattern, which we’ll cover in </span><a id="_idTextAnchor160" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.671.1">the </span><span><span class="kobospan" id="kobo.672.1">next section.</span></span></p>
<h1 id="_idParaDest-84" class="calibre5"><a id="_idTextAnchor161" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.673.1">The provider pattern</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.674.1">The </span><a id="_idIndexMarker215" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.675.1">provider </span><a id="_idIndexMarker216" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.676.1">pattern in React is where one component in the tree makes data accessible to all its descendants. </span><span class="kobospan" id="kobo.676.2">This is usually accomplished using the</span><a id="_idIndexMarker217" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.677.1"> Reac</span><a id="_idTextAnchor162" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.678.1">t </span><span><strong class="bold"><span class="kobospan" id="kobo.679.1">Context</span></strong></span><span><span class="kobospan" id="kobo.680.1"> primitive.</span></span></p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor163" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.681.1">Use case – the prop drilling problem</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.682.1">The key use case for </span><a id="_idIndexMarker218" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.683.1">the provider</span><a id="_idIndexMarker219" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.684.1"> pattern is to avoid the </span><strong class="bold"><span class="kobospan" id="kobo.685.1">prop </span></strong><span><strong class="bold"><span class="kobospan" id="kobo.686.1">drilling</span></strong></span><span><span class="kobospan" id="kobo.687.1"> problem.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.688.1">A large majority of the time, a component’s main input is the prop it receives from its parent component. </span><span class="kobospan" id="kobo.688.2">A state management pattern to share state between components in React is to </span><em class="italic"><span class="kobospan" id="kobo.689.1">lift state up</span></em><span class="kobospan" id="kobo.690.1">. </span><span class="kobospan" id="kobo.690.2">Lifting state up means to store relevant state in a common ancestor of the components that require the </span><span><span class="kobospan" id="kobo.691.1">shared state.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.692.1">As stated in the React.js </span><span><span class="kobospan" id="kobo.693.1">docs (</span></span><a href="https://react.dev/learn/sharing-state-between-components" class="pcalibre1 calibre6 pcalibre"><span><span class="kobospan" id="kobo.694.1">https://react.dev/learn/sharing-state-between-components</span></span></a><span><span class="kobospan" id="kobo.695.1">)</span></span></p>
<p class="author-quote"><span class="kobospan" id="kobo.696.1"> When you want to coordinate two components, move their state to their common parent. </span><span class="kobospan" id="kobo.696.2">Then pass the information down through props from their common parent</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.697.1">This can lead to </span><strong class="bold"><span class="kobospan" id="kobo.698.1">prop drilling</span></strong><span class="kobospan" id="kobo.699.1"> when the common parent has multiple components between it and the components requiring the props. </span><span class="kobospan" id="kobo.699.2">This means all the intermediate components will receive the props, but they will only use them to forward them on to the next layer </span><span><span class="kobospan" id="kobo.700.1">of components.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.701.1">As stated in the React.js </span><span><span class="kobospan" id="kobo.702.1">docs (</span></span><span><span class="kobospan" id="kobo.703.1">https://react.dev/learn/passing-data-deeply-with-context#the-problem-with-passing-props</span></span><span><span class="kobospan" id="kobo.704.1">)</span></span></p>
<p class="author-quote"><span class="kobospan" id="kobo.705.1"> Passing props is a great way to explicitly pipe data through your UI tree to the components that use it. </span><span class="kobospan" id="kobo.705.2">But passing props can become verbose and inconvenient when you need to pass some prop deeply through the tree, or if many components need the same prop. </span><span class="kobospan" id="kobo.705.3">The nearest common ancestor could be far removed from the components that need data, and lifting state up that high can lead to a situation called “prop drilling</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.706.1">The provider </span><a id="_idIndexMarker220" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.707.1">pattern is a solution to the prop drilling problem, since every </span><a id="_idIndexMarker221" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.708.1">descendent of the provider component will have access </span><a id="_idTextAnchor164" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.709.1">to the data </span><span><span class="kobospan" id="kobo.710.1">it provides.</span></span></p>
<h2 id="_idParaDest-86" class="calibre7"><a id="_idTextAnchor165" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.711.1">An implementation/example</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.712.1">Let’s look back</span><a id="_idIndexMarker222" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.713.1"> to the examples from </span><em class="italic"><span class="kobospan" id="kobo.714.1">The hooks pattern</span></em><span class="kobospan" id="kobo.715.1"> section, where we had the App rendering </span><strong class="source-inline"><span class="kobospan" id="kobo.716.1">BasketClassical</span></strong><span class="kobospan" id="kobo.717.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.718.1">BasketHooks</span></strong><span class="kobospan" id="kobo.719.1">, which render </span><strong class="source-inline"><span class="kobospan" id="kobo.720.1">BasketItemsClassical</span></strong><span class="kobospan" id="kobo.721.1"> and </span><span><strong class="source-inline"><span class="kobospan" id="kobo.722.1">BasketItemsHooks</span></strong></span><span><span class="kobospan" id="kobo.723.1">, respectively.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer036">
<span class="kobospan" id="kobo.724.1"><img alt="Figure 4.18: A React app tree with BasketClassical, BasketHooks, and their descendants" src="image/B19109_04_18.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.725.1">Figure 4.18: A React app tree with BasketClassical, BasketHooks, and their descendants</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.726.1">This </span><a id="_idIndexMarker223" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.727.1">illustrates the prop drilling problem, since </span><strong class="source-inline"><span class="kobospan" id="kobo.728.1">BasketClassical</span></strong><span class="kobospan" id="kobo.729.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.730.1">BasketHooks</span></strong><span class="kobospan" id="kobo.731.1"> don’t use </span><strong class="source-inline"><span class="kobospan" id="kobo.732.1">basketId</span></strong><span class="kobospan" id="kobo.733.1"> or </span><strong class="source-inline"><span class="kobospan" id="kobo.734.1">httpClient</span></strong><span class="kobospan" id="kobo.735.1"> beyond passing it to </span><strong class="source-inline"><span class="kobospan" id="kobo.736.1">BasketItemsClassical</span></strong> <span><span class="kobospan" id="kobo.737.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.738.1">BasketItemsHooks</span></strong></span><span><span class="kobospan" id="kobo.739.1">.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.740.1">There are multiple ways to consume a context in React, but it all begins by creating </span><span><span class="kobospan" id="kobo.741.1">a context:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.742.1">
import React, { createContext } from 'react';
const HttpClientContext = createContext(null);
export function HttpClientProvider({ httpClient, children
  }) {
  return (
    &lt;HttpClientContext.Provider value={httpClient}&gt;
      {children}
    &lt;/HttpClientContext.Provider&gt;
  );
}</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.743.1">HttpClientContext</span></strong><span class="kobospan" id="kobo.744.1"> is a context that’s initialized with the null value. </span><strong class="source-inline"><span class="kobospan" id="kobo.745.1">HttpClientProvider</span></strong><span class="kobospan" id="kobo.746.1"> is a component that takes a </span><strong class="source-inline"><span class="kobospan" id="kobo.747.1">httpClient</span></strong><span class="kobospan" id="kobo.748.1"> value, setting it as the value that </span><strong class="source-inline"><span class="kobospan" id="kobo.749.1">HttpClientContext.Provider</span></strong><span class="kobospan" id="kobo.750.1"> will pass to its descendants in the </span><span><span class="kobospan" id="kobo.751.1">component tree.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.752.1">In order to use </span><strong class="source-inline"><span class="kobospan" id="kobo.753.1">HttpClientContext</span></strong><span class="kobospan" id="kobo.754.1">, we can </span><span><span class="kobospan" id="kobo.755.1">use </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.756.1">HttpClientContext.Consumer</span></strong></span><span><span class="kobospan" id="kobo.757.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.758.1">
export const HttpClientConsumer = HttpClientContext.Consumer;</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.759.1">HttpClientContext.Consumer</span></strong><span class="kobospan" id="kobo.760.1"> has a children render-prop (function) that takes the value of the</span><a id="_idIndexMarker224" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.761.1"> context (in this case, </span><strong class="source-inline"><span class="kobospan" id="kobo.762.1">httpClient</span></strong><span class="kobospan" id="kobo.763.1">) and returns some JSX </span><span><span class="kobospan" id="kobo.764.1">to render:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.765.1">
// no change to httpClient
function App() {
  return (
    &lt;HttpClientProvider httpClient={httpClient}&gt;
      {/* what's below could be however deep in the
          component tree */}
      &lt;HttpClientConsumer&gt;
        {(httpClient) =&gt; (
          &lt;BasketItemsClassical basketId="5" httpClient=
           {httpClient} /&gt;
        )}
      &lt;/HttpClientConsumer&gt;
    &lt;/HttpClientProvider&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.766.1">This yields the following output in </span><span><span class="kobospan" id="kobo.767.1">the browser:</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer037">
<span class="kobospan" id="kobo.768.1"><img alt="Figure 4.19: The JSON contents of basketId=5 from fakestoreapi.com" src="image/B19109_04_19.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.769.1">Figure 4.19: The JSON contents of basketId=5 from fakestoreapi.com</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.770.1">The approach</span><a id="_idIndexMarker225" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.771.1"> using </span><strong class="source-inline"><span class="kobospan" id="kobo.772.1">HttpClientContext.Consumer</span></strong><span class="kobospan" id="kobo.773.1"> directly is a bit unwieldy. </span><span class="kobospan" id="kobo.773.2">Instead, we could wrap it in a higher-order component, </span><strong class="source-inline"><span class="kobospan" id="kobo.774.1">withHttpClient</span></strong><span class="kobospan" id="kobo.775.1">, which consumes </span><strong class="source-inline"><span class="kobospan" id="kobo.776.1">HttpClientConsumer</span></strong><span class="kobospan" id="kobo.777.1">. </span><span class="kobospan" id="kobo.777.2">The benefit here is that we only have one place that </span><span><span class="kobospan" id="kobo.778.1">uses </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.779.1">HttpClientConsumer</span></strong></span><span><span class="kobospan" id="kobo.780.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.781.1">
export function withHttpClient(Component) {
  return (props) =&gt; (
    &lt;HttpClientConsumer&gt;
      {(httpClient) =&gt; &lt;Component {...props} httpClient=
        {httpClient} /&gt;}
    &lt;/HttpClientConsumer&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.782.1">With a slight</span><a id="_idIndexMarker226" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.783.1"> difference from our example of a higher-order component, we’ll export </span><span><span class="kobospan" id="kobo.784.1">const </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.785.1">Connected</span></strong></span><strong class="source-inline"><span class="kobospan" id="kobo.786.1"> BasketItemsClassical</span></strong><span class="kobospan" id="kobo.787.1"> with the value </span><strong class="source-inline"><span class="kobospan" id="kobo.788.1">withHttpClient(BasketItemsClassical)</span></strong><span class="kobospan" id="kobo.789.1">. </span><span class="kobospan" id="kobo.789.2">The </span><em class="italic"><span class="kobospan" id="kobo.790.1">connected</span></em><span class="kobospan" id="kobo.791.1"> nomenclature is a call back to the large React Redux code bases where the components are often split among </span><em class="italic"><span class="kobospan" id="kobo.792.1">presentation</span></em><span class="kobospan" id="kobo.793.1"> and </span><em class="italic"><span class="kobospan" id="kobo.794.1">container</span></em><span class="kobospan" id="kobo.795.1"> components. </span><span class="kobospan" id="kobo.795.2">The Redux higher-order component is called </span><strong class="source-inline"><span class="kobospan" id="kobo.796.1">connect</span></strong><span class="kobospan" id="kobo.797.1">, and all the containers </span><span><span class="kobospan" id="kobo.798.1">are connected:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.799.1">
export const ConnectedBasketItemsClassical =
  withHttpClient(BasketItemsClassical);</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.800.1">We can then use </span><strong class="source-inline"><span class="kobospan" id="kobo.801.1">ConnectedBasketItemsClassical</span></strong><span class="kobospan" id="kobo.802.1"> as follows. </span><span class="kobospan" id="kobo.802.2">Note that we don’t pass an </span><span><strong class="source-inline"><span class="kobospan" id="kobo.803.1">httpClient</span></strong></span><span><span class="kobospan" id="kobo.804.1"> prop:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.805.1">
function App() {
  return (
    &lt;HttpClientProvider httpClient={httpClient}&gt;
      {/* what's below could be however deep in the
          component tree */}
      &lt;ConnectedBasketItemsClassical basketId="5" /&gt;
    &lt;/HttpClientProvider&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.806.1">The higher-order component version using </span><strong class="source-inline"><span class="kobospan" id="kobo.807.1">withHttpClient</span></strong><span class="kobospan" id="kobo.808.1"> outputs the same value as the direct </span><span><strong class="source-inline"><span class="kobospan" id="kobo.809.1">HttpClientConsumer</span></strong></span><span><span class="kobospan" id="kobo.810.1"> implementation.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer038">
<span class="kobospan" id="kobo.811.1"><img alt="Figure 4.20: The JSON contents of basketId=5 from fakestoreapi.com" src="image/B19109_04_20.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.812.1">Figure 4.20: The JSON contents of basketId=5 from fakestoreapi.com</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.813.1">The final approach</span><a id="_idIndexMarker227" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.814.1"> to using context and the provider pattern is to leverage the React </span><strong class="source-inline"><span class="kobospan" id="kobo.815.1">useContext</span></strong><span class="kobospan" id="kobo.816.1"> hook. </span><span class="kobospan" id="kobo.816.2">Similar to how </span><strong class="source-inline"><span class="kobospan" id="kobo.817.1">HttpClientContext.Consumer</span></strong><span class="kobospan" id="kobo.818.1"> allows us to access the context provider’s value, the hook fulfills that same role. </span><span class="kobospan" id="kobo.818.2">So, the output of </span><strong class="source-inline"><span class="kobospan" id="kobo.819.1">useContext(context)</span></strong><span class="kobospan" id="kobo.820.1"> is the current value, based on where the hook renders in the </span><span><span class="kobospan" id="kobo.821.1">component tree.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.822.1">It’s customary to wrap the </span><strong class="source-inline"><span class="kobospan" id="kobo.823.1">useContext </span></strong><span class="kobospan" id="kobo.824.1">hook in a more descriptive name (as we did </span><span><span class="kobospan" id="kobo.825.1">for </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.826.1">HttpClientContext.Consumer</span></strong></span><span><span class="kobospan" id="kobo.827.1">):</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.828.1">
import React, { createContext, useContext } from 'react';
// no changes to HttpClientContext definition or
    HttpClientContextConsumer
export function useHttpClient() {
  co</span><a id="_idTextAnchor166" class="pcalibre1 calibre16 pcalibre"/><a id="_idTextAnchor167" class="pcalibre1 calibre16 pcalibre"/><span class="kobospan1" id="kobo.829.1">nst httpClient = useContext(HttpClientContext);
  return httpClient;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.830.1">This time, using </span><strong class="source-inline"><span class="kobospan" id="kobo.831.1">httpClient</span></strong><span class="kobospan" id="kobo.832.1"> from the </span><strong class="source-inline"><span class="kobospan" id="kobo.833.1">HttpClientContext</span></strong><span class="kobospan" id="kobo.834.1"> requires component-level changes. </span><span class="kobospan" id="kobo.834.2">So, we’ll</span><a id="_idIndexMarker228" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.835.1"> write the following implementation </span><span><span class="kobospan" id="kobo.836.1">of </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.837.1">BasketItemsHooksUseContext</span></strong></span><span><span class="kobospan" id="kobo.838.1">:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.839.1">
export function BasketItemsHooksUseContext({ basketId }) {
  const httpClient = useHttpClient();
  const [basketSession, setBasketSession] = useState({});
  useEffect(() =&gt; {
    // @ts-ignore
    httpClient
      .get(`https://fakestoreapi.com/carts/${basketId}`)
      .then((session) =&gt; setBasketSession(session));
  }, []);
  return &lt;pre&gt;{JSON.stringify(basketSession,
   null, 2)}&lt;/pre&gt;;
}</span></pre> <p class="calibre3"><strong class="source-inline"><span class="kobospan" id="kobo.840.1">BasketItemsHooksUseContext</span></strong><span class="kobospan" id="kobo.841.1"> can be used as follows. </span><span class="kobospan" id="kobo.841.2">Note that we’re not passing </span><strong class="source-inline"><span class="kobospan" id="kobo.842.1">BasketItemsHooksUseContext</span></strong><span class="kobospan" id="kobo.843.1">, a </span><span><strong class="source-inline"><span class="kobospan" id="kobo.844.1">httpClient</span></strong></span><span><span class="kobospan" id="kobo.845.1"> prop:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.846.1">
function App() {
  return (
    &lt;HttpClientProvider httpClient={httpClient}&gt;
      {/* what's below could be however deep in the
      component tree */}
      &lt;BasketItemsHooksUseContext basketId="5" /&gt;
    &lt;/HttpClientProvider&gt;
  );
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.847.1">This implementation</span><a id="_idIndexMarker229" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.848.1"> is yet again equivalent to the previous implementations we did with </span><strong class="source-inline"><span class="kobospan" id="kobo.849.1">HttpClientConsumer</span></strong> <span><span class="kobospan" id="kobo.850.1">and </span></span><span><strong class="source-inline"><span class="kobospan" id="kobo.851.1">HttpClient</span></strong></span><span><span class="kobospan" id="kobo.852.1">.</span></span></p>
<div class="calibre2">
<div class="img---figure" id="_idContainer039">
<span class="kobospan" id="kobo.853.1"><img alt="Figure 4.21: The JSON contents of basketId=5 from fakestoreapi.com" src="image/B19109_04_21.jpg" class="calibre4"/></span>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US"><span class="kobospan" id="kobo.854.1">Figure 4.21: The JSON contents of basketId=5 from fakestoreapi.com</span></p>
<p class="calibre3"><span class="kobospan" id="kobo.855.1">We saw how to use the provider pattern to solve the prop drilling problem in React apps. </span><span class="kobospan" id="kobo.855.2">Let’s now look at some limitations of this </span><a id="_idTextAnchor168" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.856.1">pattern in the </span><span><span class="kobospan" id="kobo.857.1">next section.</span></span></p>
<h2 id="_idParaDest-87" class="calibre7"><a id="_idTextAnchor169" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.858.1">Limitations</span></h2>
<p class="calibre3"><span class="kobospan" id="kobo.859.1">The provider pattern is a </span><a id="_idIndexMarker230" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.860.1">layer of indirection. </span><span class="kobospan" id="kobo.860.2">It might not always be obvious where a context’s value is coming from, or it might sometimes be necessary to change the provider/context shape to make some changes at the component level. </span><span class="kobospan" id="kobo.860.3">For example, when using context with hooks, the hook shows a direct link between consuming component and the context, but it doesn’t necessarily show the provider or how the value inside the context </span><span><span class="kobospan" id="kobo.861.1">is defined.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.862.1">It’s also sometimes possible to solve the prop drilling problem by making liberal use of children and composing the components in a single large JSX return, such as </span><span><span class="kobospan" id="kobo.863.1">the following:</span></span></p>
<pre class="source-code"><span class="kobospan1" id="kobo.864.1">
function MyComponent() {
  return &lt;ContainerComponent requiredProp={'value'}&gt;
    &lt;OtherComponent prop="other-value"/&gt;
    &lt;FinalComponent prop="final-value"/&gt;
  &lt;/ContainerComponent&gt;
}</span></pre> <p class="calibre3"><span class="kobospan" id="kobo.865.1">In </span><strong class="source-inline"><span class="kobospan" id="kobo.866.1">MyComponent</span></strong><span class="kobospan" id="kobo.867.1">, we pass the props directly to </span><strong class="source-inline"><span class="kobospan" id="kobo.868.1">OtherComponent</span></strong><span class="kobospan" id="kobo.869.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.870.1">FinalComponent</span></strong><span class="kobospan" id="kobo.871.1"> from </span><strong class="source-inline"><span class="kobospan" id="kobo.872.1">MyComponent</span></strong><span class="kobospan" id="kobo.873.1">. </span><span class="kobospan" id="kobo.873.2">If we had </span><strong class="source-inline"><span class="kobospan" id="kobo.874.1">ContainerComponent</span></strong><span class="kobospan" id="kobo.875.1"> encapsulating </span><strong class="source-inline"><span class="kobospan" id="kobo.876.1">OtherComponent</span></strong><span class="kobospan" id="kobo.877.1"> and </span><strong class="source-inline"><span class="kobospan" id="kobo.878.1">FinalComponent</span></strong><span class="kobospan" id="kobo.879.1">, the props would be drilled via </span><strong class="source-inline"><span class="kobospan" id="kobo.880.1">ContainerComponent</span></strong><span class="kobospan" id="kobo.881.1"> (it doesn’t use the props but receives them, in order to p</span><a id="_idTextAnchor170" class="pcalibre1 calibre6 pcalibre"/><a id="_idTextAnchor171" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.882.1">ass them to </span><span><span class="kobospan" id="kobo.883.1">its descendants).</span></span></p>
<h1 id="_idParaDest-88" class="calibre5"><a id="_idTextAnchor172" class="pcalibre1 calibre6 pcalibre"/><span class="kobospan" id="kobo.884.1">Summary</span></h1>
<p class="calibre3"><span class="kobospan" id="kobo.885.1">In this chapter, we looked at how reactive view library patterns enable us to build React applications more effectively when the component paradigm starts to </span><span><span class="kobospan" id="kobo.886.1">break down.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.887.1">The render prop pattern allows us to decouple data logic and rendering logic by yielding rendering control back to the consumer of </span><span><span class="kobospan" id="kobo.888.1">a component.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.889.1">The higher-order component pattern allows components to implement logic (data or rendering) against their props, without having to concern themselves with where the information </span><span><span class="kobospan" id="kobo.890.1">comes from.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.891.1">The hooks pattern means that React primitives that were only available in class components are now available as self-contained logic chunks to function components. </span><span class="kobospan" id="kobo.891.2">Hooks can be composed separately of components, which makes hooks a powerful primitive and can partly replace the render prop and higher-order </span><span><span class="kobospan" id="kobo.892.1">component patterns.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.893.1">The provider pattern allows React components to pass data not only to their children but also to any </span><span><span class="kobospan" id="kobo.894.1">descendent component.</span></span></p>
<p class="calibre3"><span class="kobospan" id="kobo.895.1">Now that we’re familiar with reactive view library patterns, in the next chapter, we will look at rendering and page hydration strategies to improve web </span><span><span class="kobospan" id="kobo.896.1">applications’ performance.</span></span></p>
</div>
</body></html>