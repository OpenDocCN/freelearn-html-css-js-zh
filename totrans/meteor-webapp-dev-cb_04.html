<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Creating Models</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem">Implementing a simple collection</li><li class="listitem">Using the Session object</li><li class="listitem">Sorting with MongoDB queries</li><li class="listitem">Filtering with MongoDB queries</li><li class="listitem">Creating upsert MongoDB queries</li><li class="listitem">Implementing a partial collection</li></ul></div><div><div><div><div><h1 class="title"><a id="ch04lvl1sec40"/>Introduction</h1></div></div></div><p>The Meteor data model<a id="id199" class="indexterm"/> is designed to be very easy to develop. Gone are the days of worrying about lengthy SQL statements, database drivers, and rigidly structured database tables. In its place is a straightforward, JSON-based document model that lets you focus on the functionality of your application. This chapter contains the most common recipes to interact with MongoDB and the reactive model context inside Meteor.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec41"/>Implementing a simple collection</h1></div></div></div><p>Collections <a id="id200" class="indexterm"/>are the <a id="id201" class="indexterm"/>medium of communication between the client and the server, with changes being pushed down to the client and requests being pushed up to the server. This recipe will show you how and where to declare a collection for use on both the client and the server.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec139"/>Getting ready</h2></div></div></div><p>First, you will need Meteor installed and have a project created. To create a standard project file structure, please see the <em>Setting up your project file structure</em> recipe in <a class="link" title="Chapter 1. Optimizing Your Workflow" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <em>Optimizing Your Workflow</em>.</p><p>For this <a id="id202" class="indexterm"/>particular exercise, you will also need to have the <code class="literal">autopublish</code> and <code class="literal">insecure</code> packages installed (which are installed by default). If you need to add them, please see the <em>Adding Meteor packages</em> recipe in <a class="link" title="Chapter 2. Customizing with Packages" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Customizing with Packages</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec140"/>How to do it...</h2></div></div></div><p>To implement a simple collection, proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Create a new file in your <code class="literal">both</code> folder, called <code class="literal">simple.js</code>.</li><li class="listitem">Open the <code class="literal">simple.js</code> file in an editor, and declare a MongoDB comments collection by entering the following:<div><pre class="programlisting">Comments = new Mongo.Collection('comments');</pre></div></li><li class="listitem">Now, open the <code class="literal">main.js</code> file in your client's <code class="literal">scripts</code> folder <code class="literal">([project root]/client/scripts/main.js</code>), add an action to the <code class="literal">click button</code> event handler, which will insert a record into the <code class="literal">Comments</code> collection:<div><pre class="programlisting">Template.hello.events({ 'click button': function () { // increment the counter when button is clicked
    Session.set('counter', Session.get('counter') + 1);
<strong>    Comments.insert({text:'This is comment #' + (Comments.find().count()+1)});</strong>
  }
});</pre></div></li><li class="listitem">We need to add a comments helper as well. Locate the <code class="literal">Template.hello.helpers</code> method and add the following helper to the beginning:<div><pre class="programlisting">Template.hello.helpers({
<strong>  comments: function () {</strong>
<strong>    return Comments.find();</strong>
<strong>  },</strong>
  ...
   });</pre></div></li><li class="listitem">Save these changes.</li><li class="listitem">Open your <code class="literal">main.html</code> page (<code class="literal">[project root]/client/main.html</code>), add a <code class="literal">{{ #each..}}</code> template fragment to the <code class="literal">hello</code> template as specified in the following example, and save your changes:<div><pre class="programlisting">&lt;template name="hello"&gt;
<strong>  {{#each comments}}</strong>
<strong>  &lt;div&gt;{{text}}&lt;/div&gt;</strong>
<strong>  {{/each}}</strong>
  ...
&lt;/template&gt;</pre></div></li><li class="listitem">Now, open a terminal window, navigate to the <code class="literal">[root]</code> folder of your project, and start up Meteor:<div><pre class="programlisting">
<strong>$ cd [project root]</strong>
<strong>$ meteor</strong>
</pre></div></li><li class="listitem">In a web <a id="id203" class="indexterm"/>browser, navigate to <code class="literal">http://localhost:3000/</code> and click on the button on the screen several times. The result should add comments with each click, similar to this:<p> </p><div><img src="img/image00360.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec141"/>How it works...</h2></div></div></div><p>The declaration in <code class="literal">simple.js</code> is read by both the client and the server:</p><div><pre class="programlisting">Comments = new Mongo.Collection('comments');</pre></div><p>This instantiates the model and manifests as a collection called <code class="literal">Comments</code>.</p><p>The changes to <code class="literal">main.js</code> consist of an extra action in the <code class="literal">click</code> event:</p><div><pre class="programlisting">Comments.insert({text:'This is comment #' + (Comments.find().count()+1)});</pre></div><p>This adds a comment object to the <code class="literal">Comments</code> collection on the client, which is quickly propagated to a minimongo on the client and then to MongoDB on the server. The UI is updated instantly because of the second change in <code class="literal">main.js</code>:</p><div><pre class="programlisting">comments: function () { return Comments.find();
  }</pre></div><p>The <code class="literal">comments</code> helper is a <a id="id204" class="indexterm"/>
<strong>reactive</strong> <strong>computation</strong>, which means that it reruns itself every time there is a change in one of the <a id="id205" class="indexterm"/>
<strong>reactive</strong> <strong>contexts</strong> (observed properties) it contains. In this example, <code class="literal">Comments.find()</code> is a reactive context, and therefore, whenever there is a change in the <code class="literal">Comments</code> collection, this <code class="literal">comments</code> helper will rerun.</p><p>Provided that the <a id="id206" class="indexterm"/>MongoDB collection (server side) ratifies the change, the UI will stay updated. If there was a conflict or some problem with the transaction, the server will send a corrective message, and Minimongo will be updated with the correct state. But, in this case, since we have no conflicts or latency, the change stuck, and comments are added after each click.</p><p>This template is reactive, which means when a change is found in the <code class="literal">Comments</code> collection, this function will be updated, and Blaze will re-render the <code class="literal">{{#each…}}</code> template block added to <code class="literal">main.html</code>:</p><div><pre class="programlisting">{{#each comments}}
  &lt;div&gt;{{text}}&lt;/div&gt;
  {{/each}}</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec142"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Creating dynamic lists</em> and <em>Using reactivity with HTML attributes</em> recipes in <a class="link" title="Chapter 3. Building Great User Interfaces" href="part0036.xhtml#aid-12AK81">Chapter 3</a>, <em>Building Great User Interfaces</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec42"/>Using the Session object</h1></div></div></div><p>The <strong>Session</strong> <strong>object</strong><a id="id207" class="indexterm"/> is a global client-side object, and as such, is part <a id="id208" class="indexterm"/>of the client model. Though it's not part of any collection, the Session object can be used in a reactive context, which means you can use it to make reactive methods rerun whenever it is changed. This recipe will show you how to use the Session object to update the elements on your page.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec143"/>Getting ready</h2></div></div></div><p>You will need to have Meteor installed and a project created. To create a standard project file structure, please see the <em>Setting up your project file structure</em> recipe in <a class="link" title="Chapter 1. Optimizing Your Workflow" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <em>Optimizing Your Workflow</em>. A quick default project will work just as well for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec144"/>How to do it…</h2></div></div></div><p>To use the Session object, proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">main.js</code> file in your client's <code class="literal">scripts</code> folder <code class="literal">([project root]/client/scripts/main.js</code>) and add a <code class="literal">greeting</code> helper to the beginning of <code class="literal">Template.hello.helpers</code>, as follows:<div><pre class="programlisting">Template.hello.helpers({ <strong>  greeting: function() { return Session.get('greeting')||'Welcome to Chapter 4';</strong>
<strong>  },</strong>
  ...</pre></div></li><li class="listitem">Open <code class="literal">main.html</code> and add the greeting to your <code class="literal">hello</code> template, as follows:<div><pre class="programlisting">&lt;template name="hello"&gt;
<strong>  &lt;h3&gt;{{greeting}}&lt;/h3&gt;</strong>
</pre></div></li><li class="listitem">If Meteor is not already running, initiate it by navigating to your project root folder in a terminal window and run the <code class="literal">meteor</code> command:<div><pre class="programlisting">
<strong>$ cd [project root]</strong>
<strong>$ meteor</strong>
</pre></div></li><li class="listitem">Now, open<a id="id209" class="indexterm"/> a browser, navigate to <code class="literal">http://localhost:3000/</code>, and open your web console.</li><li class="listitem">In the web console, enter and execute the following command:<div><pre class="programlisting">
<strong>&gt; Session.set('greeting','I just changed the Session Object')</strong>
</pre></div><p>The greeting on your screen should have changed from <strong>Welcome to Chapter 4</strong> to <strong>I just changed the Session Object</strong>, as shown in the following screenshot:</p><div><img src="img/image00361.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec145"/>How it works…</h2></div></div></div><p>Adding a<a id="id210" class="indexterm"/> call to <code class="literal">Session.get</code> inside the <code class="literal">greeting</code> template helper tells Meteor to look for a value placed in the greeting key of the <code class="literal">Session.keys</code> collection. As the collections are reactive contexts in Meteor, changes made in the <code class="literal">Session</code> collection (even when executed through the web console) are instantly reflected in the UI.</p><div><h3 class="title"><a id="note05"/>Note</h3><p>The <code class="literal">Session</code> object is literally a <em>Session</em> object. It lasts only until the next manual page refresh. If you want something more permanent, you will need to use offline storage or a MongoDB collection. Make sure to include this fact in your design/development plans.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec146"/>There's more…</h2></div></div></div><p>As of <code class="literal">0.9.1</code>, Meteor also provides single reactive variables. They can be used in place of the <code class="literal">Session</code> object, have a cleaner syntax, can be any type of object, and support checking for changes before a reactive invalidation is triggered.</p><p>To use reactive variables, add the <code class="literal">reactive-var</code> package to your Meteor project:</p><div><pre class="programlisting">
<strong>$ meteor add reactive-var</strong>
</pre></div><p>You can then declare and use a variable instead of the <code class="literal">Sessio</code>
<code class="literal">n</code> object:</p><div><pre class="programlisting">greeting = ReactiveVar("Welcome to Chapter 4");

greeting: function () {
    return greeting.get();
}</pre></div><p>This variable (declared properly) can be manipulated in the same way as the Session object, with cleaner syntax. The following command entered in the web debug console will change the display accordingly:</p><div><pre class="programlisting">
<strong>&gt; greeting.set('I just changed the reactive variable')</strong>
</pre></div><p>The preceding command will result in something similar to the following screenshot:</p><div><img src="img/image00362.jpeg" alt="There's more…"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec147"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Using reactivity with HTML attributes</em> recipe in <a class="link" title="Chapter 3. Building Great User Interfaces" href="part0036.xhtml#aid-12AK81">Chapter 3</a>, <em>Building Great User Interfaces</em></li><li class="listitem">The <em>Creating and consuming a reactive</em> value and <em>Updating Blaze template without Mongo</em> recipes in <a class="link" title="Chapter 6. Mastering Reactivity" href="part0058.xhtml#aid-1NA0K1">Chapter 6</a>, <em>Mastering Reactivity</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec43"/>Sorting with MongoDB queries</h1></div></div></div><p>There <a id="id211" class="indexterm"/>are many times when you will need to sort a collection. Most recent comments, alphabetized lists, and bank transactions by amount are all good examples. This recipe will show you how to sort MongoDB collections, using the options in your <code class="literal">find()</code> request.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec148"/>Getting ready</h2></div></div></div><p>We will be using the <em>Implementing a simple collection</em> recipe found in this chapter as a baseline. please follow that recipe in preparation for this activity.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec149"/>How to do it…</h2></div></div></div><p>To perform <a id="id212" class="indexterm"/>sorting with MongoDB queries, proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In your <code class="literal">main.html</code> file (located at <code class="literal">[project root]/client/main.html</code>), make the following modification to the <code class="literal">{{#each…}}</code> template fragment:<div><pre class="programlisting">{{#each comments}}
  &lt;div&gt;{{text}}<strong>{{number}}</strong>&lt;/div&gt;
  {{/each}}
  {{greeting}}</pre></div></li><li class="listitem">Next, modify the <code class="literal">Comments.insert</code> action inside the <code class="literal">click</code> event handler, found in <code class="literal">[project root]/client/script/main.js</code>:<div><pre class="programlisting">Template.hello.events({
    'click button' : function () {
      // template data, if any, is available in 'this'
      if (typeof console !== 'undefined')
        console.log("You pressed the button");
        Comments.insert({text:'This int #',
	<strong>        number:Random.hexString(3)});</strong>
    }
  });</pre></div></li><li class="listitem">Finally, inside <code class="literal">main.js</code>, modify the <code class="literal">find()</code> arguments to specify a <code class="literal">sort</code> comments by its <code class="literal">number</code> in descending order (<code class="literal">-1</code>):<div><pre class="programlisting">Template.hello.helpers({
  ...
  comments: function () {
  return Comments.find({},<strong>{sort:{number:-1}}</strong>);
  },
  ...
});</pre></div></li><li class="listitem">Save all <a id="id213" class="indexterm"/>the changes and run Meteor if necessary. Navigate to <code class="literal">http://localhost:3000/</code>, click on the button on the screen several times, and watch as the comments are sorted by a comment number:<div><img src="img/image00363.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec150"/>How it works…</h2></div></div></div><p>The crux of <a id="id214" class="indexterm"/>this recipe is found in the <code class="literal">find()</code> method arguments. We modified how the number was being stored by adding a random number so that if we do nothing else, the comments will appear out of order. But by adding <code class="literal">{sort:{number:-1}}</code> to the <code class="literal">comments</code> helper, we are giving results to Blaze that are sorted in descending order by the randomly generated <code class="literal">number</code> property. To sort in ascending order, use <code class="literal">1</code> as your parameter. To sort in descending order, use <code class="literal">-1</code>.</p><p>The rest of the changes are to support the sorting change. First, <code class="literal">main.js</code> was modified so that the <code class="literal">number</code> property could be assigned at random and added to the comment object when it is inserted into the <code class="literal">Comments</code> collection:</p><div><pre class="programlisting">Comments.insert({text:'This is comment #', <strong>number:Random.hexString(3)</strong>});</pre></div><p>The last change is made to <code class="literal">main.html</code> to display the new <code class="literal">number</code> property in the UI:</p><div><pre class="programlisting">&lt;div&gt;{{text}}<strong>{{number}}</strong>&lt;/div&gt;</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec151"/>There's more…</h2></div></div></div><p>You can perform complex sorts using multiple properties if the need arises. To do so, simply add the additional <a id="id215" class="indexterm"/>property key to the <code class="literal">sort</code> option, with <a id="id216" class="indexterm"/>either an ascending (<code class="literal">1</code>) or descending(<code class="literal">-1</code>) value, similar to the following:</p><div><pre class="programlisting">return Collection.find({},{sort:{prop1:-1, prop2:1}});</pre></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec152"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Inserting templates with Spacebars</em> recipe in <a class="link" title="Chapter 3. Building Great User Interfaces" href="part0036.xhtml#aid-12AK81">Chapter 3</a>, <em>Building Great User Interfaces</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec44"/>Filtering with MongoDB queries</h1></div></div></div><p>Whether<a id="id217" class="indexterm"/> you're performing searches, organizing records, or <a id="id218" class="indexterm"/>narrowing down results, sooner or later, you'll want to filter the results of your collections. This recipe shows you how to limit the number of records in a collection, using MongoDB's <code class="literal">find</code> method options.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec153"/>Getting ready</h2></div></div></div><p>We will use the project created in the <em>Sorting with MongoDB queries</em> recipe, found in this chapter. Please complete that recipe, and use the files as a baseline for this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec154"/>How to do it…</h2></div></div></div><p>To filter MongoDB queries, proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Make the following change to the <code class="literal">comments</code> helper function in <code class="literal">[project root]/client/scripts/main.js</code>:<div><pre class="programlisting">Template.hello.helpers({
  ...
  comments: function () {
    return Comments.find(<strong>{number:/[2468]/},{sort:{number:-1}}</strong>);
  },
  ...
});</pre></div></li><li class="listitem">Save <code class="literal">main.js</code> and start Meteor if necessary. Navigate to <code class="literal">http://localhost:3000/</code>; click the button on the screen several times and watch as only the comments that contain an even number are displayed. Your results after multiple clicks should look similar to the following screenshot:<p> </p><div><img src="img/image00364.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Change<a id="id219" class="indexterm"/> the regular expression in <code class="literal">main.js</code> to only show comments that contain an odd number by making the following change to the query:<div><pre class="programlisting">return Comments.find(<strong>{number:/[13579]/}</strong>, {sort:{number:-1}});</pre></div></li><li class="listitem">Save <a id="id220" class="indexterm"/>your changes and observe the change to your UI, which should look similar to the following screenshot:<div><img src="img/image00365.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec155"/>How it works…</h2></div></div></div><p>By adding a selector to the <code class="literal">find()</code> statement in the query, the collection is paired down to match whatever is specified in the selector. In this case, the selector was a regular expression, which returned results only if the <code class="literal">number</code> property contained at least one even number, and subsequently, if the <code class="literal">number</code> property contained at least one odd number.</p><p>Notice that this <a id="id221" class="indexterm"/>didn't change the <code class="literal">{sort:{number:-1}}</code> predicate in any way and that it works exactly the same, regardless of how we changed the query.</p><div><h3 class="title"><a id="tip26"/>Tip</h3><p>There is a healthy range of selectors that you can use to limit/filter your collection. For a complete list, check out the<a id="id222" class="indexterm"/> MongoDB query operators list found at <a class="ulink" href="http://docs.mongodb.org/manual/reference/operator/query/">http://docs.mongodb.org/manual/reference/operator/query/</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec156"/>There's more…</h2></div></div></div><p>Moving the filter<a id="id223" class="indexterm"/> to the server side provides security and performance advantages as the non-matching results are never sent down the wire to the client in the first place. In fact, <code class="literal">find()</code> is most commonly found on the server, using the Meteor publish and subscribe functionality. For an example of <code class="literal">find()</code> being used on the server, please see the <em>Implementing a partial collection</em> recipe found in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec157"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Implementing a partial collection</em> and <em>Sorting with MongoDB queries</em> recipes in this chapter</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec45"/>Creating upsert MongoDB queries</h1></div></div></div><p>As you <a id="id224" class="indexterm"/>are developing applications, on occasion, you will run into a situation where you need to either update an existing record, or insert a record if it doesn't exist already. This is done traditionally using conditional operators such as <code class="literal">if</code>.</p><p>Through MongoDB, Meteor removes the burden of checking by allowing you to upsert (update + insert) records using a simple syntax. This recipe will show you how.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec158"/>Getting ready</h2></div></div></div><p>We will again use the project created in the <em>Sorting with MongoDB queries</em> recipe, found in this chapter. Please create a fresh copy of this recipe, and use the files as a baseline for this recipe.</p><p>We will also be using the official <code class="literal">momentjs</code> package. To add the <code class="literal">momentjs</code> package, navigate to your project's root folder in a terminal window. Once there, execute the following command:</p><div><pre class="programlisting">
<strong>$ meteor add momentjs:moment</strong>
</pre></div><p>This will add the <code class="literal">momentjs</code> package, and you're now ready to complete this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec159"/>How to do it…</h2></div></div></div><p>We first need to increase the likelihood of duplicate records and identify the time at which each comment was inserted or updated. Proceed with the following steps to create upsert MongoDB queries:</p><div><ol class="orderedlist arabic"><li class="listitem">Open the <code class="literal">[project root]/client/scripts/main.js</code> file and modify <code class="literal">Template.hello.events</code> as follows:<div><pre class="programlisting">  'click button': function () {
  ...
  Session.set('counter', Session.get('counter') + 1);
<strong>  var newC = {</strong>
<strong>    text:'This is comment #',</strong>
<strong>    number:Random.hexString(1),</strong>
<strong>    time: moment().format('ll, hh:mm:ss')</strong>
<strong>  };</strong>
<strong>  Meteor.call('commentUpsert',newC);</strong>
}</pre></div></li><li class="listitem">We will <a id="id225" class="indexterm"/>now create a server method for the <code class="literal">upsert</code> function. By default, Meteor only allows modifications on the client by <code class="literal">_id</code>, and since an <code class="literal">_id</code> value may not exist, we need to create a server method for our <code class="literal">upsert</code> function. Open <code class="literal">[project root]/server/server.js</code> and add the following method to the bottom of the file:<div><pre class="programlisting">Meteor.methods({
  commentUpsert: function(newC){
    Comments.upsert({number:newC.number},{$set:newC});
  }
});</pre></div></li><li class="listitem">Finally, we will modify <code class="literal">[project root]/client/main.html</code> to display the timestamp on each comment in the <code class="literal">comments</code> collection:<div><pre class="programlisting">{{#each comments}}
  &lt;div&gt;{{text}}{{number}} <strong>at: {{time}}</strong>&lt;/div&gt;
  {{/each}}</pre></div></li><li class="listitem">Save your changes, start the Meteor if it is not already running, and navigate to <code class="literal">http://localhost:3000/</code>.</li><li class="listitem">Continuously, click on the button on the screen, and observe how, instead of new records being added on each and every click, if a record already exists, the record's timestamp is updated.</li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec160"/>How it works…</h2></div></div></div><p>In <code class="literal">server.js</code>, we created a method by declaring the <code class="literal">commentUpsert</code> method inside <code class="literal">Meteor.methods</code>.</p><p>This method <a id="id226" class="indexterm"/>receives a new comment object (<code class="literal">newC</code>) as an argument and calls <code class="literal">upsert</code> on the <code class="literal">Comments</code> collection. The first argument (the selector) tells MongoDB to look for any entries that match the <code class="literal">number</code> property found in the <code class="literal">newC</code> object. The second argument (the modifier) tells MongoDB which fields to insert/update on the <code class="literal">upsert</code> object.</p><p>If a match is found, the fields are updated. If no match is found, a new record is inserted, with the <code class="literal">newC</code> object providing the values.</p><p>In <code class="literal">main.html</code>, we simply added the new <code class="literal">time</code> property to the display:</p><div><pre class="programlisting">&lt;div&gt;{{text}}{{number}} at: {{time}}&lt;/div&gt;</pre></div><p>In <code class="literal">main.js</code>, we first remove the <code class="literal">Comments.insert()</code> statement. We then create the <code class="literal">newC</code> object, populating it with a random number, some text, and a timestamp using <code class="literal">moment().format()</code> to convert the timestamp into a readable format. Finally, we make a call to the <code class="literal">commentUpsert</code> server-side method, with a <code class="literal">Meteor.call</code> statement.</p><p>The result confirms that our <code class="literal">upsert</code> function is working properly, as each new comment (with a new <code class="literal">number</code> property) is added to our list, and each existing comment (with an already existing <code class="literal">number</code> property) has its timestamp updated.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec161"/>There's more…</h2></div></div></div><p>Meteor simplifies things a bit by adding the actual <code class="literal">upsert</code> function, rather than setting <code class="literal">{upsert:true}</code> inside a traditional MongoDB <code class="literal">update</code> query. Both <code class="literal">update</code> or <code class="literal">upsert</code> can be used in Meteor, and it's really up to you to choose.</p><div><h3 class="title"><a id="tip27"/>Tip</h3><p>Extensive documentation exists on updating and upserting records in a MongoDB collection. You <a id="id227" class="indexterm"/>can find more details at <a class="ulink" href="http://docs.mongodb.org/manual/reference/method/db.collection.update/">http://docs.mongodb.org/manual/reference/method/db.collection.update/</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec162"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Building custom server methods</em> recipe in <a class="link" title="Chapter 11. Leveraging Advanced Features" href="part0083.xhtml#aid-2F4UM1">Chapter 11</a>, <em>Leveraging Advanced Features</em></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec46"/>Implementing a partial collection</h1></div></div></div><p>Partial collections<a id="id228" class="indexterm"/> are collections sent down the wire from the server that contain only part of the information available on each record. This is useful for hiding properties or fields, and also for paring down the size of records containing a lot of information. In other words, partial collections can help with security and performance. This recipe will show you how to implement a partial collection on the server.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec163"/>Getting ready</h2></div></div></div><p>Let's use the <em>Creating upsert MongoDB queries</em> recipe found in this chapter as a baseline for this recipe. Create a fresh copy of this recipe and then proceed to the other preparations.</p><p>Let's spruce<a id="id229" class="indexterm"/> things up just a bit as well while we're at it. In a terminal window, navigate to the root project folder and execute the following command:</p><div><pre class="programlisting">
<strong>$ meteor add twbs:bootstrap</strong>
</pre></div><p>This will add the <code class="literal">bootstrap</code> CSS framework. We now want to take advantage of <code class="literal">bootstrap</code>, so open up your <code class="literal">main.html</code> file (found in <code class="literal">[project root]/client/</code>) and make the following changes to the <code class="literal">hello</code> template:</p><div><pre class="programlisting">&lt;template name="hello"&gt;
  ...
<strong>  &lt;div class="btn-group-vertical"&gt;</strong>
<strong>    {{#each comments}}</strong>
<strong>    &lt;div class="btn btn-default"&gt;{{text}}{{number}}</strong>
<strong>      &lt;span class="label label-warning"&gt;</strong>
<strong>        {{time}}</strong>
<strong>      &lt;/span&gt;</strong>
<strong>    &lt;/div&gt;</strong>
<strong>    {{/each}}</strong>
<strong>  &lt;/div&gt;</strong>
<strong>  &lt;p&gt;&lt;button&gt;Click Me&lt;/button&gt;&lt;/p&gt;</strong>
  ...
&lt;/template&gt;</pre></div><p>These changes will use some of the default <code class="literal">bootstrap</code> component styles to make our display look similar to the following screenshot:</p><div><img src="img/image00366.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p><p>We now need to remove the <code class="literal">autopublish</code> default Meteor package. In the terminal window, execute the following command:</p><div><pre class="programlisting">
<strong>$ meteor remove autopublish</strong>
</pre></div><p>This will <a id="id230" class="indexterm"/>temporarily <em>break</em> your application; in that no records from the <code class="literal">Comments</code> collection are being sent down the wire to the client, so no records will be displayed in the UI. Don't worry, we'll fix this!</p><p>You are now ready to move on to the recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec164"/>How to do it…</h2></div></div></div><p>First, since we removed <code class="literal">autopublish</code>, we need to prepare the client to subscribe to the <code class="literal">comments</code> data stream. To implement a partial collection, proceed with the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Open <code class="literal">[project root]/client/scripts/main.js</code> and add the following code to the very top of the document:<div><pre class="programlisting">
<strong>Meteor.subscribe('comments');</strong>
</pre></div></li><li class="listitem">While we have <code class="literal">main.js</code> open, let's also change what we sort, by making the following change to the <code class="literal">comments</code> helper function and save your changes:<div><pre class="programlisting">comments: function () {
  return Comments.find(<strong>{},{sort:{time:-1}</strong>});
},</pre></div></li><li class="listitem">Next, we need to have the server publish the <code class="literal">Comments</code> data collection. We'll simultaneously remove the text field from the response stream, implementing a <strong>partial collection</strong>. Open <code class="literal">[project root]/server/server.js</code>, add the following code, and save your changes:<div><pre class="programlisting">Meteor.publish ('comments',function(){
  return Comments.find({} , {fields:{text:false}});
});</pre></div><p>We can now immediately see that the text field is no longer being displayed in the UI, as shown in the following screenshot:</p><div><img src="img/image00367.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem">Let's clean <a id="id231" class="indexterm"/>up our UI a little bit now and make it obvious that the records are being reordered. Open <code class="literal">main.html</code> again, make the following changes, and save the file:<div><pre class="programlisting">&lt;div class="btn btn-default"&gt;<strong>{{time}}</strong>
  &lt;span class="label label-warning"&gt;
<strong>    {{number}}</strong>
  &lt;/span&gt;
&lt;/div&gt;</pre></div><p>Now, when you click on the button to update the <code class="literal">time</code> property, the timestamp will be updated, and the ordering of the records will change with each click (click several times to really see the effect in action):</p><div><img src="img/image00368.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec165"/>How it works…</h2></div></div></div><p>The crux of this recipe is found inside <code class="literal">server.js</code> where we added the <code class="literal">fields</code> field specifier to the MongoDB query (in the <code class="literal">Meteor.publish(…)</code> statement):</p><div><pre class="programlisting">Meteor.publish ('comments',function(){ return Comments.find({} , <strong>{fields:{text:false}}</strong>);
})</pre></div><p>This field specifier tells the MongoDB query to exclude the text field/property from the results. Once this change has been made, <code class="literal">main.html</code> still tries to call <code class="literal">{{text}}</code> in the template, but since it's null, it doesn't appear. We then removed the call to display <code class="literal">{{text}}</code> altogether, because it wasn't needed.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec166"/>There's more…</h2></div></div></div><p>The <code class="literal">fields</code> field specifier can be made <strong>exclusive</strong>, as we have seen in the preceding section, by only listing the fields we don't want to see. To do this, simply use the <code class="literal">:false</code> (or <code class="literal">:0</code>) parameter for each field you don't want to see, and the rest of the fields will be included by default. For example:</p><div><pre class="programlisting">record.find({} , <strong>{fields:{f1:false , f2:false}}</strong>);</pre></div><p>The field <a id="id232" class="indexterm"/>specifier can also be made <strong>inclusive</strong>, which<a id="id233" class="indexterm"/> means that only the fields specified will be included by using the <code class="literal">:true</code> (or <code class="literal">:1</code>) parameter. This would look similar to the following code:</p><div><pre class="programlisting">record.find({} , <strong>{fields:{f3:true , f4:true}}</strong>);</pre></div><div><h3 class="title"><a id="tip28"/>Tip</h3><p>To read more about the <a id="id234" class="indexterm"/>
<code class="literal">fields</code> field specifier, check out the official Meteor documentation at <a class="ulink" href="http://docs.meteor.com/#/full/fieldspecifiers">http://docs.meteor.com/#/full/fieldspecifiers</a>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec167"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem">The <em>Basic safety – turning off autopublish</em> recipe in <a class="link" title="Chapter 9. Securing Your Application" href="part0073.xhtml#aid-25JP21">Chapter 9</a>, <em>Securing Your Application</em></li></ul></div></div></div></body></html>