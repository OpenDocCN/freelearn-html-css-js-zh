- en: Advanced Server-Side Scripting
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will be taking a look at the advanced side of server-side
    scripting. We will explore some more advanced methods and techniques that can
    be used on the server side, building upon what we learned in the previous chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a look at the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: Script includes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduled jobs
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Background scripts
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Workflow scripts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event management
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script actions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced server script examples
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Script includes
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Script includes are at the heart of scripting in ServiceNow, and are arguably
    the most commonly used when it comes to writing code. Script includes are used
    to hold classes of code, and for a lot of the backend script used by the ServiceNow
    platform.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
- en: When creating your script include, you first need to give it a name. This name
    will be important, as it will be used in other code to call the methods in your
    script include.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Ensure that the name you choose for your script include does not contain spaces
    in it. It is best to use underscores to separate words in the name.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: Once you enter a name for your script include, you will notice that the API
    Name and the script fields are populated. The API name is read-only, and given
    based upon the name of the application this script include is being created in,
    followed by the name of the script include itself.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: 'The script field is populated with some introductory script creating a class
    for this script include, taking into account the name of the script include. As
    an example, if we named our script include `script_utils`, we would be given the
    following script:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This gives us the basic code to create a script include class that can be called
    from the server side. One of the first questions to ask when creating a script
    include is whether the script will be called from the server side only, or from
    the client side. This is because if we are going to be calling the script include
    from the client side (for example, for an AJAX call), we need to tick the Client
    callable checkbox, and in doing this, you will also notice that the code changes,
    too.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: 'For our example, this will change the code to the following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This changed script allows the script include to inherit the `AbstractAjaxProcessor`.
    Without this, AJAX calls will not work, so it is important to remember this if
    the script include will be called on the client.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: Although this is the starter code that ServiceNow provides for you, it is not
    necessary to create a class in a script include. You can also simply create a
    function to call in a script include when calling server-side script.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a short example of how that can be done:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a simple function that will just return the string of text, but can
    be called simply as a standalone function, rather than creating a whole class.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now have a look at creating a script include with a class and methods.
    We can add as many methods as we like to our script include:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Our `testMethod` method will return a string when called on the server side.
    To call it, we use the line of code as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We can also assign this line of code to a variable or use it for a condition
    check if the method returns true or false.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Script includes can also call each other and methods contained within them.
    When building up the bulk processing of server-side script, it is usually best
    to consider script includes for the job. Looking at the existing script includes
    that come with the ServiceNow platform is a good way to enhance your knowledge
    of writing script includes.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: Scheduled jobs
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Scheduled jobs are a way of generating a report or record and automatically
    running a script. Creating a report or record is a configuration and does not
    require scripting. What we are interested in for scheduled jobs is the ability
    to automatically run a script.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: A scheduled job is a helpful way to run a script at a time of your choosing.
    This can be an overnight job or a script that can run frequently, say, every hour.
    In my experience, running script out of hours is one of the main benefits and
    uses of a scheduled job. Common uses are preparing data for users first thing
    in the morning, or to remove old data.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: When creating a scheduled job, we set the frequency of the scheduled job by
    using the run field. The different time options in this field give the developer
    different fields to fill in to schedule the script execution appropriately. If
    the On Demand option is picked, the script will only run if the Execute Now button
    is pressed.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the schedule, we can also add a condition to the scheduled job
    so that it will only run when the condition evaluates to true. If you check the
    Conditional checkbox, then an additional Condition field is displayed. For the
    script in this Condition field, the final expression of the code needs to evaluate
    to true or false.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at an example of a condition script for a scheduled job:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: In the example, we are checking if the current day is Sunday, and if so, we
    will not run the scheduled job script. The `getDayOfWeek` method gives us the
    day of the week, with one being Monday and seven being Sunday.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: The second line of script above can give a syntax error saying that a semicolon
    is missing and an expression is seen when a function call or assignment was expected.
    Normally this would be valid, but for the condition field in a scheduled job we
    are expecting an expression and adding a semicolon here would cause the script
    to break.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Now let us look at the Run this script field. This is the field where we put
    the code that we would like to run at the scheduled time we have defined.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: 'For an example, let us log that our code has run and that it is not a Sunday:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We can write any server-side script we like in this field to run at the specified
    time. We will look at a more advanced example later in the chapter.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what our scheduled job will look like if we set it to run daily
    at 1:00 a.m. in *Figure 6.1*:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62e598d5-721a-4ba5-8b41-948d9c466704.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Scheduled job to check if the day is Sunday'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: A scheduled job is a great way to run script-performing server-side tasks out
    of business hours.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Background scripts
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Background scripts are server-side scripts that administrators can immediately
    run on the ServiceNow platform. A background script cannot be saved and does not
    exist as a record. However, they can be extremely useful for trialing scripts
    out and fixing one-off issues with an instance.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: To start creating a background script, you simply need to select the Scripts
    - Background module in the System Definition application. This brings up a large
    box for the developer to write their code into. If you have administrator access
    and you cannot see the module, there is a system property that can be set that
    means an elevated privilege is required to access background scripts. If this
    is the case, this usually means you need the security_admin role to access background
    scripts.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: Because background scripts grant the ability to run any JavaScript on the platform,
    this module is often locked down more securely for security purposes.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few choices and buttons that appear under the large script box
    for background scripts. These are:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: 'Run script (button): Runs the script currently in the Run script box on the
    server side'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'in scope (drop down): Allows the background script to be run in a different
    scope outside of global, if required'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Execute in sandbox? (checkbox): Executes the script with sandbox restrictions;
    for example, data cannot be inserted, updated, or deleted'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Cancel after 4 hours (checkbox): Check to cancel the script if it is still
    running after four hours'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at an example of a background script:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the example, we are checking for all of the incidents that have the software
    category. In the background script, we are logging each incident we find so that
    we can review the list before we go ahead with the deletion. Once we are happy
    with the list that will be deleted, we will see in the log that we can remove
    the log and remove the comment lines, allowing the deletion to take place.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: This type of example is useful when performing a large removal of records to
    gauge the impact before going ahead with the script.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at what the background script will look like:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/73762321-666e-49c6-ba62-dd04a5487b8c.png)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Background script to log records for deletion'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Background scripts are very helpful for running script to check results before
    performing actions, and also to test parts of a script involved in a long process
    so the process does not need to be walked through each time to test the code.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: Workflow scripts
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Workflows use a number of activities to build up a process in ServiceNow. These
    activities can often be used on a basic level, without the need for scripting.
    However, to build a more advanced workflow, we can use code to enhance the workflows
    we build.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: Scripts can appear in a number of workflow activities, including approvals and
    task creation. For approvals, it is possible to add users and groups to approval
    activities using script. In task creation, we can use script to set values on
    our task before it is created.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: The main area for scripting in a workflow, though, is in the Run Script Workflow
    Activity. This activity allows the developer to run any server-side script they
    like at a point in the workflow. This can be used to manipulate records, kick
    off integrations, or perform other outcomes using scripts.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: The other area of workflows in which you often come across scripts is in setting
    up approvals. A simple approval workflow activity will simply pick a user or group
    to approve, or perhaps the value of a particular field. However, if you require
    the selection of relevant approvals to be more complicated than this, then you
    may need to use some code.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: With scripts, you can add extra elements to who will be selected to approve,
    for example, by checking attributes about the users approving, or the record being
    approved. It may be that if a record has a particular category, it is sent to
    a certain approval group, or that the approver of the record must have a certain
    role. This type of functionality is achievable with script and can cater for many
    other scenarios too.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: The potential for building a complex approval system is huge, but be careful
    to make sure that what you create provides value and can be maintained.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us have a look at an example of a workflow script in a Run Script Workflow
    Activity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the example, we are adding `URGENT` to the short description of the record
    if the priority is critical. We also have access to the current record in the
    workflow script, with the current record being the one from which the workflow
    launched.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us have a look at what this activity will look like, in *Figure 6.3*:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d7f4875-9f7c-4d35-9f77-4bf124e4c267.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Workflow activity to update the short description based on priority'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Workflow script can be particularly handy for adding an extra layer of functionality
    to your workflows. Sometimes, when you look at the activities available, you cannot
    find one that will meet your requirements, and in this instance, scripting can
    be the solution.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: Event management
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Events that trigger different outcomes in an instance run in ServiceNow. An
    event can be invoked from any script on the server side. The main outcome from
    an event being triggered is either a notification or a script action. Notifications
    are usually emails, and we will take a look at script actions later on in this
    chapter.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: 'First of all, to trigger an event, the event will need to be defined. To define
    an event, we can navigate to System Policy | Events | Registry and click on the
    New button. Upon doing this, we are given the form shown in *Figure 6.4*:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9adebc8d-7c21-48ce-99d8-5cd58cc5415a.png)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: New event form'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: In the form, we need to give the event a name. Event names are usually words
    split by full stops and underscores, and if you look at the list of events, you
    will see the general format used for events. It is also good practice to fill
    in the table field for reference. The Fired by and Description fields are simple
    text fields, but it is a good idea to fill these in with details of when the event
    should be fired and how the event is fired. Then, the event can be used by others
    or its trigger point easily found by another administrator.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在表单中，我们需要为事件提供一个名称。事件名称通常是点号和下划线分隔的单词，如果您查看事件列表，您将看到用于事件的通用格式。填写表格字段作为参考也是良好的实践。触发者和描述字段是简单的文本字段，但填写这些字段以详细说明事件应该在何时触发以及如何触发事件是个好主意。然后，其他人可以使用事件，或者另一个管理员可以轻松地找到其触发点。
- en: 'Once we have defined an event, we then need to be able to call the event to
    add it to the event queue. We can use the `GlideSystem` method `eventQueue`, as
    shown in the following code:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们定义了一个事件，我们就需要能够调用该事件以将其添加到事件队列。我们可以使用`GlideSystem`方法`eventQueue`，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the preceding code, we would be calling the event `custom.event`, and this
    would need replacing with the name of the event you have created. The second,
    third, and fourth parameters are an object and two strings, respectively. The
    second parameter is almost always the current record, so that the current record
    data can be used once the event is processed. The third and fourth parameter are
    more commonly known as Parm1 and Parm2\. These can be used in scripts or in notifications;
    for example, you are able to send an email to the value held in Parm1.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将调用事件`custom.event`，这需要替换为您创建的事件的名称。第二个、第三个和第四个参数分别是一个对象和两个字符串。第二个参数几乎总是当前记录，这样一旦事件处理完毕，就可以使用当前记录的数据。第三个和第四个参数更常见地被称为Parm1和Parm2。这些可以在脚本或通知中使用；例如，您可以将电子邮件发送到Parm1中持有的值。
- en: In the example, we are sending the current logged-in user's ID and name. The
    information sent in these parameters often changes, and is often about the current
    user or a value that is useful once the event has been processed.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们正在发送当前登录用户的ID和名称。这些参数中发送的信息通常会变化，并且通常与当前用户或事件处理完毕后有用的值有关。
- en: We can also use the `GlideSystem` method `eventQueueScheduled`, which is very
    similar, except the fifth parameter is the time at which the event should run.
    This can be set as the value of a field that is of `glide_date_time` type.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用`GlideSystem`方法`eventQueueScheduled`，它与前面提到的非常相似，只是第五个参数是事件应该运行的时间。这可以设置为`glide_date_time`类型的字段值。
- en: 'We can see an example of this in the following code, using the same event from
    before:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在以下代码中看到这个示例，使用之前提到的相同事件：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once an event has been triggered, it will be processed fairly quickly, unless
    it has been scheduled for a certain time, and the events that have been processed
    can be seen in the event logs. To see the event logs, navigate to System Logs
    | Events. From here we can see the  events processed, the processing time, and
    events still to be processed.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦事件被触发，它将很快被处理，除非它被安排在特定的时间，并且已经处理的事件可以在事件日志中看到。要查看事件日志，请导航到系统日志 | 事件。从这里我们可以看到处理的事件、处理时间和尚未处理的事件。
- en: Events provide a great way to process multiple scripts or send notifications
    based on a single event, and because an event can be triggered in any server-side
    script, the ways in which an event can be triggered are almost limitless.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 事件提供了一种处理多个脚本或基于单个事件发送通知的绝佳方式，并且由于事件可以在任何服务器端脚本中触发，因此触发事件的方式几乎是无限的。
- en: Script actions
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本操作
- en: Script actions tend to be some of the lesser-used methods of server-side scripting.
    They are run after an event has run in the system scheduler. This can be helpful
    as a way to run some script at a set point in the future.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本操作通常是服务器端脚本中较少使用的方法之一。它们在系统调度器中某个事件运行之后执行。这可以作为在未来的某个设定点运行脚本的一种有用方式。
- en: There are some system events that will already exist in ServiceNow that you
    can use to run your script actions from, or you can create your own events and
    execute them from any server-side script.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在ServiceNow中已经存在一些系统事件，您可以使用这些事件来运行脚本操作，或者您可以创建自己的事件，并从任何服务器端脚本中执行它们。
- en: When creating a script action, you need to pick the event to run the script
    action against. This is picked from a list, so make sure the event exists before
    you create the script action. There is also the option to add a condition script,
    which is written in the same style as a business rule. You can also perform condition
    checks in the main script, but if you can use the condition script, it is considered
    better.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at a script action in use. The main script field can run
    any server-side script. Here, we will add a simple log:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This example will send a log to the system logs to say that an approval has
    been inserted. This is fine as an example or for debugging, but would not be recommended
    as a script for a production instance, as many approvals are created, and this
    would swamp the logs with this message.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the script action itself, shown in *Figure 6.5*:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/de0b276d-5d9b-41f6-8b96-fd10f0803567.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Approval-logging script action'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Script actions can also be used to set an action to be performed in the future;
    for example, keeping a record on hold until a certain time in the future.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: Script examples
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The advanced server-side techniques we have seen can be used in a number of
    ways, and you will find advanced server-side scripting to be some of the most
    common in the ServiceNow platform.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen where to write our advanced server-side code, we can have
    a look at some further examples to solidify our understanding.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: Let's have a look at a script include example first. We will write a script
    to return the active tasks of a requested item. This can be helpful for letting
    users know which tasks need to be completed for an item to be fulfilled.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'First we will take a look at the script include code:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We are using the `getActiveTasks` method to get all of the active tasks returned
    to us, passing in the item parameter as the requested item record to get the tasks
    for. Using a `gliderecord` query, we can find all of the tasks, and are returning
    them as an array.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: In the example, we have started the creation of an item utilities script include.
    You will often find these in ServiceNow instances having been developed by other
    developers. We have created the first method here, but you would usually build
    up more methods for requested items as part of this class to keep the code organized.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see what the script include will look like in *Figure 6.6*:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff0e0038-7e12-46a1-b352-0156b8f9f17f.png)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.6: Item utilities script include'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the script include, we need to call it from another location.
    Here, we will do this from a business rule, and simply log the result. You can
    use this type of script include to assist in whether to close out requested items,
    too.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the code for the business rule to call the script include:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We would run this business rule on the requested item table. In the code block,
    we put the value of the script include into the tasks variable. We also pass the
    current requested item record using `current`. We are just logging the output
    here, but this data could be used for other uses.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us also see what the business rule would look like, in *Figure 6.7*:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e09d3e77-afb0-419a-9e21-5a96f7d59df1.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.7: Business rule to log active requested item tasks'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us have a look at a further example of a scheduled job.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we will look at deleting all incidents that are over a year
    old. This kind of example shows how we can remove old records overnight for different
    tables.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us have a look at what the code would look like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this code, we get the current date and time by initiating a new `GlideDateTime`
    class, and then removing a year from this time. By using a negative number, in
    this case `-1`, we subtract a year from the current date and time. Using a `GlideRecord`
    query, we are finding all of the incidents updated over a year ago, and deleting
    them using `deleteMultiple`. This deletes all of the records without the need
    to query the `Gliderecord`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: This type of overnight job can be great for clearing out old records or performing
    updates, ready for the day ahead.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 6.8* shows what the scheduled job itself looks like:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8153a1c7-bfdb-4c37-b081-ec0a030e4d20.png)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.8: Scheduled job to delete old incidents'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the preceding figure, this scheduled job would run at 1:00
    a.m. and delete the incidents overnight. This is common practice so that system
    resources are not being used during the working day.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: It is also best practice to run long-running scripts overnight so that they
    do not impact the instance resources during business hours. There are also jobs
    that run overnight written by ServiceNow included in a brand new instance; for
    example, the `import set deleter`, which cleans up import sets after seven days.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: Running overnight scripts is a great way to use scheduled jobs. This can be
    useful for cleaning up old data or setting up reports so that they are available
    to users first thing in the morning.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Now, let us have a look at a workflow script example.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will use an approval activity to add an approval that is the director
    in charge of the current caller. This involves iterating through managers of users
    in the database until we find one that is a director.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us take a look at the code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In the example, we use the `manager` string to keep adding `.manager` to until
    we find a user that is a director. This means saying the manager of the manager
    of the manager, and so on, until a director is found. We can execute this in a
    loop to save time and resources by using `eval`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: '`eval` evaluates the contents of the brackets, rather than treating it as its
    current type: in this case, a string. This allows us to dot walk to find the title
    of the user and get the `sys_id` if we find a director. It is also how we can
    use a loop here, adding `.manager` to the string each time we run through the
    loop. `eval` can be very helpful when using script to find the field you require,
    and then to evaluate it once it is found.'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: If no director is found, then no approval will be added at this stage in the
    workflow, as when we get to the top of the organisational tree we would meet a
    user with no manager and exit the loop.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the approval activity from the workflow in *Figure 6.9*:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ec3a826e-7951-4fdd-b6f2-c1067c25864f.png)'
  id: totrans-143
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.9: Approval activity to find and add the user''s director as an approver'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: For our final example, we will take a look at a script action.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Sometimes we want to put an incident on hold, but incidents can get left on
    hold for extended periods of time. In this example, we will create a new field
    to hold a date and time for the incident to stay on hold until. Once the date
    and time are reached, an event fires which will run our script action and take
    the incident off hold and move the state to in progress.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'To achieve this goal, we also need to set the event to be scheduled in the
    future. Here, we will use a business rule to do this. The code we will need looks
    as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the business rule, we are using the `GlideSystem` method `eventQueueScheduled`
    to put an event into the system scheduler. We have set the third parameter, or
    what can be referenced as `event.parm1`, in later scripts to be the `sys_id` of
    the current incident. You will also notice that the final fifth parameter is the
    value of our custom field to hold the date and time we want the incident to stay
    on hold until.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: This method sets an event into the system scheduler which will run the event
    at the time we have set in the custom on hold until field. The event we are firing
    (`incident.off.hold`) is a custom one we have created for this particular functionality.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: Once the event fires, we need to move the incident out of the on hold state
    and into in progress. For this, we are going to use our script action.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: 'The code in our script action is as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: We are using the `event` parameter we set in the business rule to use `gliderecord`
    to get the incident record we want to update. Once we have the record, we can
    change the state to in progress, with a value of two, and reset the on hold until
    field before updating the incident record.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also see the full script action in *Figure 6.10*:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/045659ff-7ff3-4e96-a9f0-c69401be6c6d.png)'
  id: totrans-156
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.10: Script action to take an incident off hold'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: This combination of business rule and script action is a very useful technique
    to know for having the ability to run scripts at a specified time in the future.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: These practical examples are great for reinforcing the understanding of these
    more advanced server-side script techniques.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这些实用的示例对于加强对这些更高级服务器端脚本技术的理解非常有帮助。
- en: Summary
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Advanced server-side scripting was the theme for this chapter. We looked at
    the greatly used script includes and scheduling scripts using scheduled jobs,
    events, and script actions. We also saw how to write script as part of ServiceNow
    workflows and how to test aspects of our code using background scripts. We finished
    off with some great examples of how to use these advanced server-side techniques.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的主题是高级服务器端脚本。我们探讨了广泛使用的脚本包含以及使用计划任务、事件和脚本动作来安排脚本。我们还展示了如何将脚本作为ServiceNow工作流的一部分来编写，以及如何使用后台脚本来测试代码的各个方面。最后，我们提供了一些如何使用这些高级服务器端技术的优秀示例。
- en: In the next chapter, we look at building your own custom pages by utilizing
    UI pages. We introduce Jelly script and where it appears in ServiceNow, as well
    as show some examples of creating simple custom pages.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨如何通过利用UI页面来构建自己的自定义页面。我们介绍了Jelly脚本以及它在ServiceNow中的应用，并展示了创建简单自定义页面的示例。
