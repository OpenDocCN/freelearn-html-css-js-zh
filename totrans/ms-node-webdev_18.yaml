- en: '16'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SportsStore: A Real Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In each of the previous chapters, I focused on a particular feature required
    by web applications, which allowed me to dig into detail. In this part of the
    book, I show how the features described in earlier chapters are combined to build
    a simple but realistic e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: My application, called SportsStore, will follow the classic approach taken by
    online stores everywhere. I will create an online product catalog that customers
    can browse or search through, a shopping cart where users can add and remove products,
    and a checkout where customers can enter their shipping details. I will also create
    an administration area that provides facilities to manage the catalog, and I will
    protect it so that only authorized users can make changes.
  prefs: []
  type: TYPE_NORMAL
- en: My goal in this part of the book is to give you a sense of what real web application
    development is by creating as realistic an example as possible. I want to focus
    on Node.js, of course, so I have simplified integration with external systems,
    such as the database, and omitted others entirely, such as payment processing.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the project structure
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The SportsStore application spans six chapters and contains many files, some
    of which have the same name, either because that’s what TypeScript/JavaScript
    requires or because of my development style. There will be multiple `index.ts`
    files, for example, because that’s the filename that JavaScript uses when importing
    from modules. There will also be multiple files whose name contains the term *helper*
    because that’s how I tend to write code that supports some other part of the application.
    For quick reference, *Table 16.1* provides a high-level overview of the structure
    of the completed SportsStore project, which will provide context as you read through
    the chapters and follow the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16.1: The project layout and key files'
  prefs: []
  type: TYPE_NORMAL
- en: '| Folder | Description |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder will contain the JavaScript files created by the TypeScript compiler,
    which will be executed by Node.js. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder will contain all of the source code for the SportsStore application
    and will be compiled into the `dist` folder. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder supports the administration features created in *Chapter 20*.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder contains the code that provides configuration settings to the
    rest of the application, which is read from configuration files and environment
    settings. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder contains all the functionality related to handling data. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder contains the `Sequelize` implementation of the data model. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder contains the code to validate user input. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder contains helpers for the logicless template package. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder contains the HTTP routes that match and handle requests. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '| The code in this file configures user authentication. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '| The code in this file creates HTTP error responses. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '| The code in this file is executed when the SportsStore application starts
    and is responsible for setting up the application features and creating the HTTP
    server. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '| The code in this file sets up cookie-based HTTP sessions. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '| This folder contains templates the server will use to render content for
    HTML clients. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '| This file contains product data that will be used to populate the catalog.
    |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '| This is the main configuration file for the application. |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '| This file is used to store secrets as environment variables during development.
    |'
  prefs: []
  type: TYPE_TB
- en: The structure of the *SportsStore* project reflects, at least in part, the way
    that I like to write software. You don’t have to follow this pattern in your projects,
    and I encourage you to find ways to organize features such that they correspond
    to how you think about the problems you need to solve.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open a new command prompt, navigate to a convenient location, and create a folder
    named `sportsstore`. Navigate to the `sportsstore` folder, run the command shown
    in *Listing 16.1* to initialize the project, and create the `package.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tip**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example project for this chapter – and for all the other
    chapters in this book – from [https://github.com/PacktPublishing/Mastering-Node.js-Web-Development](https://github.com/PacktPublishing/Mastering-Node.js-Web-Development).
    See *Chapter 1* for how to get help if you have problems running the examples.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.1: Initializing the project'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Setting up the development tools
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I am going to start by setting up a toolchain that will monitor the TypeScript
    files in the project, and then compile and execute them when there is a change.
    Run the commands shown in *Listing 16.2* in the `sportsstore` folder to install
    the development tool packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.2: Installing the development tool packages'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: These packages are described in *Table 16.2* for quick reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16.2: The development packages'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `typescript` | This package contains the TypeScript compiler. |'
  prefs: []
  type: TYPE_TB
- en: '| `tsc-watch` | This package monitors the TypeScript files in a project and
    compiles them when there is a change. |'
  prefs: []
  type: TYPE_TB
- en: '| `nodemon` | This package monitors a wider range of file types and executes
    a command when a change is detected. |'
  prefs: []
  type: TYPE_TB
- en: '| `@tsconfig/node20` | This package contains a TypeScript compiler configuration
    file for Node.js projects. |'
  prefs: []
  type: TYPE_TB
- en: '| `@types/node` | This package contains type descriptions for the Node.js API.
    |'
  prefs: []
  type: TYPE_TB
- en: Create the `src` folder, and add to it a file named `server.ts` with the content
    shown in *Listing 16.3*, which will act as a placeholder while setting up the
    development tools.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.3: The contents of the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: To configure the TypeScript compiler, add a file named `tsconfig.json` to the
    `sportsstore` folder with the content shown in *Listing 16.4*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.4: The contents of the tsconfig.json file in the sportsstore folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The configuration builds on the basic settings provided by the `@tsconfig/node20`
    package, specifying that the source files can be found in the `src` folder and
    the compiled JavaScript files should be written to the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: To set up the file watchers, replace the `scripts` section of the `package.json`
    file and add the `nodemonConfig` section, as shown in *Listing 16.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.5: Setting the scripts section of the package.json file in the sportsstore
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Earlier chapters used only the `tsc-watch` package to monitor and build TypeScript
    files, and restart the application when there is a change. This can be frustrating
    when working with other file types, such as templates, where changes do not trigger
    a restart. Bundler packages, such as webpack (used in *Chapter 7*), can be used
    to create complex build pipelines, but my preference is to combine `tsc-watch`
    with the `nodemon` package, which restarts a process when a file is changed. The
    `start` script uses `nodemon` to run `tsc-watch`, which in turn starts the TypeScript
    compiler in watch mode. If a TypeScript file is changed, then the TypeScript compiler
    compiles the TypeScript files into JavaScript, which is then executed by the `tsc-watch`
    package. If a non-TypeScript file is changed, then the `nodemon` package restarts
    `tsc-watch`, which ensures that the application is restarted. The `nodemonConfig`
    section specifies the file extension that `nodemon` reacts to and a set of directories
    to ignore. This is not a perfect arrangement of tools, but it is reliable and
    responsive, and I have had fewer problems using these packages than when trying
    to configure webpack, which has some limitations when dealing with TypeScript
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Open a new command prompt, navigate to the `sportsstore` folder, and run the
    command shown in *Listing 16.6* to start the build process.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The build tools will generate pure JavaScript files, which will be executed
    by Node.js, producing the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Changes to files will be detected automatically, triggering a new build and
    then executing the output.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP requests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to add support to handle HTTP requests, which is the foundation
    for the SportsStore application and everything that it does. Run the commands
    shown in *Listing 16.7* in the `sportsstore` folder to add the HTTP packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.7: Installing the basic application packages'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: These packages are described in *Table 16.3* for quick reference, but they provide
    enhancements to the basic Node.js HTTP features and set a sensible content security
    policy.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16.3: The HTTP handling packages'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `express` | This package contains the Express HTTP framework, which was introduced
    in *Chapter 5*. |'
  prefs: []
  type: TYPE_TB
- en: '| `helmet` | This package is used to set an HTTP content security policy, as
    described in *Chapter 7*. |'
  prefs: []
  type: TYPE_TB
- en: '| `@types/express` | This package contains type descriptions for the Express
    API. |'
  prefs: []
  type: TYPE_TB
- en: Replace the contents of the `server.ts` file with the code shown in *Listing
    16.8* to create a basic HTTP server. (Plain HTTP will be used for development,
    and HTTPS will be introduced in *Chapter 21* when the application is prepared
    for deployment.)
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.8: Creating a basic HTTP server in the server.ts file in the src
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The new code uses Express and enables support to decode JSON and form-encoded
    content, using the `json` and `urlencoded` methods. There is a single route that
    handles `GET` requests and responds with a string. Open a web browser, request
    `http://localhost:5500`, and you should see the response shown in *Figure 16.1*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_16_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.1: A response from the application'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a configuration system
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The port on which the server listens for HTTP requests is hardcoded into the
    `server.ts` file, which means that changing ports will require a new version of
    the application to be built and deployed. A more flexible approach is to define
    settings in a configuration file, which is read when the application starts and
    can be modified without requiring a code change.
  prefs: []
  type: TYPE_NORMAL
- en: Create the `src/config` folder, and add to it a file named `environment.ts`,
    with the content shown in *Listing 16.9*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.9: The contents of the environment.ts file in the src/config folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Most applications require different configurations for different environments,
    such as development and production. The convention for Node.js is to specify the
    environment using an environment variable, named `NODE_ENV`. Applications can
    support as many environments as needed, but a minimal approach is to support development
    and production environments. If the `NODE_ENV` variable isn’t set or has been
    set to `development`, then the application is in the development environment.
    The code in *Listing 16.9* allows the environment to be read consistently, without
    the need for different parts of the application to inspect and interpret environment
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: The environment is important for a configuration system because it allows a
    base configuration file to be supplemented with settings that are specific to
    each environment. The simplest way to define configuration settings is to use
    the JSON format, which can be parsed into JavaScript objects at runtime. Objects
    read from multiple configuration files can be merged to create the overall configuration.
    JavaScript doesn’t have integrated support for merging objects, so add a file
    named `merge.ts` to the `src/config` folder with the content shown in *Listing
    16.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.10: The contents of the merge.ts file in the src/config folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `merge` function accepts `source` and `target` objects and copies the properties
    defined by the `source` object to the `target`, overriding the existing values.
    Next, add a file named `index.ts` to the `src/config` folder, with the content
    shown in *Listing 16.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.11: The contents of the index.ts file in the src/config folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The code in *Listing 16.11* uses an environment variable named `SERVER_CONFIG`
    to get the name of the configuration file, falling back to `server.config.json`
    if the variable isn’t defined. The contents of the file are read and merged with
    an environment-specific file, the name of which is determined by appending the
    current environment, such as `production.server.config.json`. The `getConfig`
    function accepts a string in the form `http:port`, where keys are separated by
    colons (the `:` character). The keys are used to navigate through the configuration
    data to find a value. A default value can be provided, which will be returned
    if a value has not been loaded from the configuration files.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: Environment variables can be set on most platforms, but Node.js also supports
    `.env` files, which can be used to set values and are loaded with the Node `--env-file`
    argument. In *Chapter 21*, I will set environment variables as part of the containerization
    process used to prepare the application for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: To start the configuration, add a file named `server.config.json` to the `sportsstore`
    folder with the content shown in *Listing 16.12*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.12: The contents of the server.config.json file in the SportsStore
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The configuration file defines a section named `http` that contains a `port`
    setting. *Listing 16.13* updates the `server.ts` file to use this configuration
    setting to listen to HTTP requests, with a fallback value that will be used if
    no configuration setting has been defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.13: Using configuration data in the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The configuration file will be populated as new features are added, but the
    overall effect is to allow the settings used by the application to change without
    altering code files.
  prefs: []
  type: TYPE_NORMAL
- en: Adding application routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the application grows, there will be a large number of HTTP routes to define
    and manage, so it will be useful to introduce a structure that allows related
    routes to be grouped and easily located. Create the `src/routes` folder, and add
    to it a file named `catalog.ts` with the content shown in *Listing 16.14*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.14: The contents of the catalog.ts file in the src/routes folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This file will contain the routes that present a catalog of products to the
    user, but it contains a placeholder for now. To combine the individual route modules
    so that they can be applied in a single step, add a file named `index.ts` to the
    `src/routes` folder with the content shown in *Listing 16.15*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.15: The contents of the index.ts file in the src/routes folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '*Listing 16.16* uses the new module to enable the routes it defines.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.16: Applying routes to the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Use a web browser request, `http://localhost:5000`, and you will see the response
    shown in *Figure 16.2*, which shows the response has been generated by the request
    handler defined in *Listing 16.14*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_16_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.2: The effect of a separate module for routes'
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for HTML templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: HTML templates will be used to render the content presented to the user. Run
    the commands shown in *Listing 16.17* in the `sportsstore` folder to install the
    packages required to support templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.17: Installing template packages'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: These packages are described in *Table 16.4* for quick reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16.4: The template packages'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `bootstrap` | This package contains CSS stylesheets that are used to style
    the HTML content produced by the application. |'
  prefs: []
  type: TYPE_TB
- en: '| `handlebars` | This package contains the Handlebars template engine, which
    was introduced in *Chapter 10*. |'
  prefs: []
  type: TYPE_TB
- en: '| `express-handlebars` | This package integrates the Handlebars template engine
    with the Express package. |'
  prefs: []
  type: TYPE_TB
- en: As explained in *Chapter 10*, the templates rendered by the Handlebars package
    rely on helper functions instead of including code expressions. Create the `src/helpers`
    folder, and add to it a file named `env.ts` with the content shown in *Listing
    16.18*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.18: The contents of the env.ts file in the src/helpers folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `isDevelopment` helper can be used to determine whether the application
    has been configured for development or production. To set up the template system,
    add a file named `index.ts` to the `src/helpers` folder with the content shown
    in *Listing 16.19*.
  prefs: []
  type: TYPE_NORMAL
- en: Listing 16.19\. The contents of the index.ts file in the src/helpers folder
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: The `createTemplates` function configures the template engine and registers
    it with Express. Add the settings to the configuration file, as shown in *Listing
    16.20*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.20: Adding settings to the server.config.json file in the SportsStore
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getConfig` function defined in *Listing 16.11* can be used to get entire
    configuration sections, as well as individual values, and these sections can be
    used to directly configure packages. This statement is used to get a configuration
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is an object whose properties correspond to the `templates:config`
    section of the configuration file, which has been parsed from JSON into a JavaScript
    object and is used to configure the template engine:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The properties read from the configuration file are combined with the helper
    functions imported from the `helpers` module.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: '*Listing 16.20* configures the template engine so that templates, partials,
    and layouts are all in the same folder. This is not a requirement, but I prefer
    to keep the files together and use the filename to indicate the content rendered
    by a template.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating layouts and templates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Create the `sportsstore/templates` folder, and add to it a file named `index.handlebars`
    with the placeholder contents shown in *Listing 16.21*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.21: The contents of the index.handlebars file in the templates folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Add a file named `main_layout.handlebars` to the templates folder with the content
    shown in *Listing 16.22*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.22: The contents of the main_layout.handlebars file in the templates
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The layout contains an HTML document that includes a `link` element for the
    CSS stylesheet from the `Bootstrap` package and a *SportsStore* header. *Listing
    16.23* completes the setup for the templates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.23: Completing the template setup in the server.ts file in the src
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: In addition to calling the `createTemplates` function, *Listing 16.23* uses
    the Express `static` middleware to serve content from the Bootstrap package. *Listing
    16.24* uses a template to render a response instead of returning a plain string.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.24: Using a template in the catalog.ts file in the src/routes folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000`, and you will see the response
    shown in *Figure 16.3*, which is produced using a template and a layout.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_16_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.3: Adding layouts to the application'
  prefs: []
  type: TYPE_NORMAL
- en: Creating error handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Express includes support to generate responses when a request is made for a
    URL for which there is no handler, or when a handler throws an error. To demonstrate
    the default error handlers and prepare for custom replacements, *Listing 16.25*
    defines routes that always create errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.25: Creating errors in the catalog.ts file in the src/routes folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Use a browser to request `http://localhost:5000/nosuchfile`, and you will see
    the default response created by Express, which is shown on the left side of *Figure
    16.3*. This error is shown when no handler generates a response. Use a browser
    to request `http://localhost:5000/err`, and you will see the other error message
    shown in *Figure 16.4*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_16_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.4: A default Express error message'
  prefs: []
  type: TYPE_NORMAL
- en: The handler for errors doesn’t deal with errors thrown by asynchronous handlers.
    You can see the problem by requesting `http://localhost:5000/asyncerr`. A stack
    trace will be written at the Node.js console, but no response is sent to the browser,
    which will eventually assume that the application has refused to accept the HTTP
    request.
  prefs: []
  type: TYPE_NORMAL
- en: There is an excellent package that adds support for errors in asynchronous handlers.
    Run the command shown in *Listing 16.26* in the `sportsstore` folder to add the
    package, which is called `express-async-errors`, to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.26: Adding the asynchronous error package'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: For quick reference, this package is described in *Table 16.5*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16.5: The errors package'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `express-async-errors` | This package adds support to process errors produced
    by asynchronous request handlers. |'
  prefs: []
  type: TYPE_TB
- en: The custom error handlers will use templates to display formatted responses.
    Add a file named `not_found.handlebars` to the `templates` folder with the content
    shown in *Listing 16.27*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.27: The contents of the not_found.handlebars file in the templates
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This template will be rendered when a request isn’t matched by a route. It doesn’t
    include any dynamic content, but it will be displayed within the default layout.
    Next, add a file named `error.handlebars` to the `templates` folder with the content
    shown in *Listing 16.28*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.28: The contents of the error.handlebars file in the templates folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: This template uses the `isDevelopment` helper to include details of the error
    when the application is configured in the development environment. *Listing 16.29*
    adds a new configuration section that specifies the error template files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.29: Adding a configuration section to the server.config.json file
    in the SportsStore folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Add a file named `errors.ts` to the `src` folder with the content shown in *Listing
    16.30*. This file imports the `express-async-errors` module, which is all that’s
    required to use the package, and defines error handlers that use templates to
    generate responses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.30: The contents of the errors.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `createErrorHandlers` function sets up a request handler that will generate
    a 404 response, and that will be the last handler to run when a request is received.
    There is also an error handler, which works like a middleware component but with
    an additional `error` parameter. There is a danger that something will go wrong
    when rendering an error response, in which case the default error handler will
    be used. To prevent the new error from being the one displayed to the user, a
    try/catch block is used, and the `catch` clause invokes the `next` method using
    the original error, which tells Express which error needs to be processed.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the setup, *Listing 16.31* calls the `createErrorHandlers` function
    as part of the application startup.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.31: Setting up error handlers in the server.ts file in the src folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Save the changes, and use a browser to request `http://localhost:5000/nosuchfile`,
    `http://localhost:5000/err`, and `http://localhost:5000/asyncerr`. Asynchronous
    errors are now handled correctly, and users will see the custom error responses,
    which are shown in *Figure 16.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_16_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.5: Custom error responses'
  prefs: []
  type: TYPE_NORMAL
- en: Starting the data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once the basic building blocks are in place, it is time to start working on
    the data model. For the SportsStore application, the key data is a catalog of
    products from which customers will make selections. Run the commands shown in
    *Listing 16.32* in the `sportsstore` folder to install the data storage packages.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.32: Adding data storage packages'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: For quick reference, these packages are described in *Table 16.6*. I am going
    to use SQLite during development because it is easy to set up and then change
    to PostgreSQL, which is a more conventional database server, in *Chapter 21* to
    prepare for deployment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Table 16.6: The data packages'
  prefs: []
  type: TYPE_NORMAL
- en: '| Name | Description |'
  prefs: []
  type: TYPE_TB
- en: '| `sqlite3` | This package contains the SQLite database manager, which stores
    its data in a file and was first used in *Chapter 12*. |'
  prefs: []
  type: TYPE_TB
- en: '| `sequelize` | This package contains the `Sequelize` ORM framework, which
    maps between relational data and JavaScript objects and was introduced in *Chapter
    12*. |'
  prefs: []
  type: TYPE_TB
- en: There are different ways to create data models for web applications. As I explained
    in *Chapter 12*, I like to use a repository that allows the details of how the
    data is stored to be hidden from the rest of the application. Create the `src/data`
    folder, and add to it a file named `catalog_models.ts` file with the content shown
    in *Listing 16.33*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.33: The contents of the catalog_models.ts file in the src/data folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This file defines three model interfaces that provide the building blocks for
    a basic product catalog. A real online store would have a more complex data model,
    but much of the additional complexity relates to external processes, such as procurement,
    dispatch, customer service, and so on, which won’t be part of the *SportsStore*
    application. These three interfaces in *Listing 16.33* are enough to get started.
    To describe a repository, add a file named `catalog_repository.ts` to the `src/data`
    folder, with the content shown in *Listing 16.34*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.34: The contents of the catalog_repository.ts file in the src/data
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `CatalogRepository` interface defines methods to query and store objects
    that implement the `Product`, `Category`, and `Supplier` interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the repository
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of a repository means that the details of how data is stored don’t have
    to align with how data is used by the rest of the application. In *Chapter 12*,
    for example, I used a set of conversion functions to convert the data read from
    the database into the format expected by the rest of the application. This works
    well because it means that the application gets data in a format that is natural
    to work with, and the repository gets data that is easily stored and queried.
    The downside is that data must be transformed as it passes between the repository
    and the rest of the application.
  prefs: []
  type: TYPE_NORMAL
- en: An alternative approach is to implement the repository so that it stores data
    without transformation, ensuring that the results of querying the database, for
    example, are objects whose type matches the expectations of the rest of the application.
    This approach doesn’t require conversion functions, but it can require some effort
    to override the default behavior of the ORM package. This is the approach that
    I am going to take for the SportsStore application.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: This isn’t an issue if you are using an object database, such as MongoDB, or
    if you are writing native SQL queries without using an ORM package. However, as
    noted in *Chapter 12*, relational databases are used by the majority of projects,
    and ORM packages allow developers to perform complex queries without needing deep
    SQL knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: To get started, create the `src/data/orm/models` folder, and add to it a file
    named `catalog_models.ts`, with the content shown in *Listing 16.35*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.35: The contents of the catalog_models.ts file in the src/data/orm/models
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `ProductModel`, `CategoryModel`, and `SupplierModel` classes conform to
    the interfaces defined in *Listing 16.33*, with some additions required for storage
    in a relational database, which means that the objects created by the ORM package
    will have a superset of the properties expected by the rest of the application
    – notably, the `categoryId` and `supplierId` properties defined by the `ProductModel`
    class, which represent relationships between tables in the database.
  prefs: []
  type: TYPE_NORMAL
- en: To describe the format and relationships between the model classes, add a file
    named `catalog_helpers.ts` to the `src/data/orm/models` folder with the content
    shown in *Listing 16.36*.
  prefs: []
  type: TYPE_NORMAL
- en: '**The iterative process of defining a data model**'
  prefs: []
  type: TYPE_NORMAL
- en: Figuring out the `Sequelize` configuration for this example took a couple of
    hours of trial and error, which is not easily conveyed in the linear progression
    shown by a book example. I wrote the code in *Listing 16.35* at the same time
    as the initial implementation of the repository. This allowed me to make sure
    that the data storage and queries worked as expected, and to reset the database
    each time I made a change.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two challenges in this process: ensuring that the database schema
    makes sense and that results conform to the model interfaces.'
  prefs: []
  type: TYPE_NORMAL
- en: To check the schema, I use the excellent DB Browser for SQLite ([https://sqlitebrowser.org](https://sqlitebrowser.org))
    package, which allows SQLite databases to be opened and inspected. This allows
    me to check that I have configured `Sequelize` to correctly create the relationships
    between tables, and it also allows me to check that data is written as it should
    be.
  prefs: []
  type: TYPE_NORMAL
- en: To check that data objects are created correctly, I query the database and write
    out the results as JSON data. This reveals the structure of the objects created
    by `Sequelize` and lets me see how columns in the database are represented as
    JavaScript object properties.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have confirmed that `Sequelize` creates data objects correctly, the
    final step is to make sure that you have described those objects accurately with
    the `declare` keyword. Bear in mind that the TypeScript annotations applied to
    the model classes are not used by `Sequelize` and only exist so that the TypeScript
    compiler can check the way that data is used. The type annotations have no effect
    at runtime because `Sequelize` creates objects dynamically, so it is important
    to confirm that the data is stored and retrieved as you intended and that the
    type annotations correctly describe those processes.
  prefs: []
  type: TYPE_NORMAL
- en: This can be a time-consuming process – and for some, it is an argument in favor
    of object databases – but working methodically and checking the results after
    each change will keep you on the right path.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.36: The contents of the catalog_helpers.ts file in the src/data/orm/models
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The `initializeCatalogModels` function accepts a `Sequelize` object, which is
    used to initialize the model classes and create the relationships between them.
    The `belongsTo` and `hasMany` methods used to create the relationships between
    models accept a configuration object, which is used to override the default names
    used for the foreign key and association properties.
  prefs: []
  type: TYPE_NORMAL
- en: To complete the initial ORM models, add a file named `index.ts` to the `src/data/orm/models`
    folder with the content shown in *Listing 16.37*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.37: The contents of the index.ts file in the src/data/orm/models
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This file will be updated as new model classes are created and will help organize
    the features required for different parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the repository class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: My preference for repositories is to break up the code into smaller sections
    that are more easily maintained. This is purely a matter of personal style, but
    I don’t like large code files, and I am willing to accept some degree of complexity
    if I can split up something like a repository into more manageable pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The way that JavaScript supports this style of development is called *mixins*,
    where classes are defined as function results, which allows complex functionality
    to be built up piece by piece. To start the implementation of the repository,
    add a file named `core.ts` to the `src/data/orm` folder, with the content shown
    in *Listing 16.38*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.38: The contents of the core.ts file in the src/data/orm folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: The `BaseRepo` class is responsible for configuring `Sequelize`, which is done
    by reading a configuration section, appending the logging settings, and invoking
    the constructor. There is an `initModelsAndDatabase` model that calls the `initializeModels`
    function and, if configured, resets the database and invokes the `addSeedData`
    method to populate the database with seed data. The `addSeedData` method reads
    a JSON data file and uses the `Sequelize` `bulkCreate` method to store multiple
    objects in a single operation, which is a good way to populate the database. The
    last statement in *Listing 16.38* defines a type that will be used to create the
    `mixin` and represents a type that can be instantiated with the `new` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to define the query features. Add a file named `queries.ts`
    to the `src/data/orm` folder with the content shown in *Listing 16.39*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.39: The contents of the queries.ts file in the src/data/orm folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The `AddQueries` function accepts a base class and returns a new class that
    adds the `getProducts`, `getCategories`, and `getSuppliers` methods. The `getProducts`
    method includes associated data in its query, and the `model` and `as` properties
    are required to match the configuration in *Listing 16.36*, where the default
    property names used by `Sequelize` were overridden so that query results conformed
    to the data model interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: All of the query methods are configured with the `raw` and `nest` options set
    to `true`. The objects created by `Sequelize` cannot be used directly with the
    Handlebars template engine, which places restrictions on how properties are defined.
    The `Sequelize` object appears like a regular JavaScript object, but values are
    presented in a way that allows for changes to be tracked so that the database
    can be updated, which is contrary to the expectations Handlebars has for the data
    it processes. The `raw` option tells `Sequelize` not to process the data it receives,
    which means that simple data objects are created. The `nest` option ensures that
    nested values, such as those produced for associated data, are presented as nested
    data objects.
  prefs: []
  type: TYPE_NORMAL
- en: These configuration settings were not required in *Part 2* of this book because
    conversion functions were used, which meant that the objects created by `Sequelize`
    were not the ones consumed by the template engine. Using the `raw` setting works
    when the structure of the data read from the database naturally matches the data
    structure the application requires, which depends on the query being executed.
    For queries with complex associations between data – of which there are examples
    in later chapters – the `raw` keyword will produce results that cannot be used
    directly, and in these cases, the best approach is to allow `Sequelize` to process
    the results, and then use the `toJSON` method that is inherited by all `Sequelize`
    model objects to create simple objects that can be used with templates.
  prefs: []
  type: TYPE_NORMAL
- en: The generic type arguments used to describe the `AddQueries` function allow
    TypeScript to understand that the result combines the features defined by the
    base class, plus the new methods. As noted previously, working this way is not
    required, but it does allow small amounts of related functionality to be defined
    in a way that is easy to maintain and combined to produce a more complex component.
  prefs: []
  type: TYPE_NORMAL
- en: To implement the repository storage methods, add a file named `storage.ts` to
    the `src/data/orm` folder, with the content shown in *Listing 16.40*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.40: The contents of the storage.ts file in the src/data/orm folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `storeCategory` and `storeSupplier` methods define optional parameters that
    allow operations to be included in a transaction. Because these parameters are
    optional, these methods are valid implementations of the ones defined by the repository
    interface. The `storeProduct` method uses the transaction parameter to ensure
    that data is written atomically, and the use of the mixin means that the `sequelize`
    property defined in *Listing 16.38* is accessible in *Listing 16.40*. All three
    methods use the `upsert` method to create or update data if it already exists,
    which means they can be used to both store and update data.
  prefs: []
  type: TYPE_NORMAL
- en: To combine the three parts of the mixin into a single class, add a file named
    `index.ts` to the `src/data/orm` folder with the content shown in *Listing 16.41*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.41: The contents of the index.ts file in the src/data/orm folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'The process of creating a mixin starts by calling the function that adds the
    query methods to the `BaseRepo` class, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a class that combines the base features and the query methods,
    and this is passed to the function that adds the storage methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is a class that defines all the methods and can be instantiated
    with the new keyword. The combined class can be instantiated and used as an implementation
    of the `CategoryRepository` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: I like being able to compose features this way, and I find it useful to be able
    to keep the storage methods separate from the query methods, for example, but
    I appreciate that not everyone dislikes long code files as much as I do. However,
    even if you don’t want to adopt this technique in your projects, it does serve
    as a demonstration of the flexibility that JavaScript provides to compose features
    with class expressions.
  prefs: []
  type: TYPE_NORMAL
- en: '**Note**'
  prefs: []
  type: TYPE_NORMAL
- en: I use a repository for the main parts of the *SportsStore* application. However,
    just to show the alternative, the administration features in *Chapter 20* are
    implemented by working directly with `Sequelize` in the HTTP request handlers.
  prefs: []
  type: TYPE_NORMAL
- en: To instantiate the repository implementation so that an instance can be used
    by the rest of the application, add a file named `index.ts` to the `src/data`
    folder with the content shown in *Listing 16.42*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.42: The contents of the index.ts file in the src/data folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This file will be the point at which the implementations of repository interfaces
    will be created and added to in later chapters, as different types of data are
    added to the application. But for now, the file exports an object named `catalog_repository`
    that implements the `CatalogRepository` interface. Notice that the TypeScript
    compiler can determine that the combination of methods conforms to the `CatalogRepository`
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the configuration settings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The repository is set up using configuration settings, which are defined in
    *Listing 16.43*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.43: Adding settings to the server.config.json file in the SportsStore
    folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: The `catalog:orm_repo` section is read by the base class defined in *Listing
    16.38*. The `settings` section is passed to the `Sequelize` constructor and specifies
    that data should be stored in an SQLite database file named `catalog.db`. The
    `logging` setting determines whether the repository configures `Sequelize` to
    log messages, and the `rest_db` setting determines whether the database is reset
    and seeded every time the repository is created, which can be useful during development
    but will be disabled when the application is prepared for deployment in *Chapter
    21*.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the seed data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `seed_file` setting added in *Listing 16.43* specifies the name of the file
    that will be used to seed the catalog database with product data. To define the
    data, add a file named `products.json` to the `sportsstore` folder with the content
    shown in *Listing 16.44*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.44: The contents of the products.json file in the SportsStore folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This data defines three suppliers, three categories, and nine products. Real
    online stores have larger catalogs, of course, but this data will be enough to
    continue building the application.
  prefs: []
  type: TYPE_NORMAL
- en: Using the catalog data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is to confirm that the repository works as expected by presenting
    the user with a list of products. *Listing 16.45* uses the repository to read
    the product data from the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.45: Querying data in the catalog.ts file in the src/routes folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: Replace the contents of the `index.handlebars` file in the `templates` folder
    with the content shown in *Listing 16.46*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Listing 16.46: The contents of the index.handlebars file in the templates folder'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This isn’t the final presentation of the data, but putting the product data
    into a table is a good way to check that all of the fields are accessible and
    read from the database, before figuring out the detailed formatting. Use a browser
    to request `http://localhost:5000`, and you will see the data shown in *Figure
    16.6*.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21959_16_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 16.6: Displaying data'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we started work on the *SportsStore* project, and we demonstrated
    how the key features described in earlier chapters are combined to create a more
    realistic web application:'
  prefs: []
  type: TYPE_NORMAL
- en: The development tools monitor TypeScript files and other project resources so
    that the code is built and executed when changes are detected.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The configuration system locates and merges JSON files to present consolidated
    settings that can be read consistently by the rest of the application and overridden
    with environment-specific values.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routes defined using the Express package handle HTTP requests and generate responses,
    using templates rendered by the Handlebars template engine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom error handlers produce responses consistent with the rest of the application
    and deal with errors in asynchronous request handlers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Sequelize` package creates a database that stores product data in an SQLite
    database, which will be replaced with PostgreSQL before deployment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The database is reset and reseeded with data every time the application starts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will continue building the SportsStore application by
    completing the product catalog and introducing a shopping cart.
  prefs: []
  type: TYPE_NORMAL
