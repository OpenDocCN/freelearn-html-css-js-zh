- en: Chapter 3. The Login Page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very common to have a login page for an application of which we want to
    control the access to the system by identifying and authenticating the user through
    the credentials presented by the user. Once the user is logged in, we can track
    the actions performed by the user. We can also restrain access to some features
    and screens of the system that we do not want a particular user to have access
    to or even a specific group of users.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating the login page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling the login page on the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding the Caps Lock warning message in the **Password** field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submitting the form when pressing the *Enter* key
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypting the password before sending to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Login screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The **Login** window will be the first view that we are going to implement
    in this project. We are going to build it step-by-step, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The user will enter the username and password to log in
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side validation (username and password required to log in)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submit the login form by pressing *Enter*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Encrypt the password before sending to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password Caps Lock warning (similar to Windows OS)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multilingual capability
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Except for the multilingual capability, which we are going to implement in
    the next chapter, we will implement all the other features throughout this topic.
    So at the end of the implementation, we will have a **Login** window that looks
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The Login screen](img/0457OT_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Login screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Under the `app/view` directory, we will create a new folder to organize all
    the source code related to the **Login** screen named `login`. Inside the `login`
    folder, we will also create a new file named `Login.js`. In this file, we will
    implement all the code that the user is going to see on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `view/login/Login.js`, we will implement the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'On the first line (`#1`), we have the definition of the class. To define a
    class, we use `Ext.define`, which (`define`) is a method call of the `Ext` singleton
    class, and which takes two arguments: the class name (`#1`) and the object literal
    with the configuration of the class (`#2`–`#13`).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to pay attention to the name of the class. This is the formula
    suggested by Sencha in Ext JS MVC projects: *App Namespace + package name + name
    of the JS file*. In the previous chapter, we defined the namespace as `Packt`
    (the name of the application we passed as parameter for the `sencha generate app`
    command). If we open an existing file that was created by Sencha Cmd (the `app/view/main/Main.js`
    file) for example, we will note that the name of the class starts with `Packt`.
    So all the classes we are going to create through out this book will start with
    the namespace `Packt`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are creating a View for this project, so we will create the JS file under
    the `view` folder. For organization purposes, we created a subfolder named `login`.
    And then, the name of the file we created is `Login.js`; therefore, we will lose
    the `.js` and use only `Login` as the name of the View. Putting it all together,
    we have `Packt.view.login.Login`, and this will be the name of our class. It is
    very important that the class name follows the directory layout as explained;
    otherwise, we can get an error in the code saying Ext JS did not find the class.
    The following screenshot shows the dependency between the project directory layout
    and the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Login screen](img/0457OT_03_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Then, we say that the `login` class will extend from the `Window` class (`#2`).
    Recapitulating what we have covered in [Chapter 1](ch01.html "Chapter 1. Sencha
    Ext JS Overview"), *Sencha Ext JS Overview*, we can use inheritance in Ext JS.
    The `login` class will inherit the behavior from the `Window` class (it is a subclass
    of the `Component` class). The `window` component represents a pop up that is
    rendered centralized in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about the window component, please access [http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.window.Window](http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.window.Window).
    And for more details on inheritance, please read [http://goo.gl/v4bmq8](http://goo.gl/v4bmq8).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also assign this class: `xtype` (`#3`). The `xtype` class is a shorter name
    that can be used to instantiate the class instead of using its full name. We can
    also use the configuration `alias` instead of `xtype`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `alias` for a class that extends from a component always starts with `widget`,
    followed by the `alias` or `xtype` class we want to assign. If we want to use
    the `alias` configuration instead of `xtype`, we could use `alias: ''widget.login-dialog''`
    instead of `xtype: ''login-dialog''`. The result will be the same; it is just
    a matter of personal preference.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The naming convention for `xtype` and `alias` is lowercase. It is also important
    to remember that the alias must be unique in an application. In this case, we
    want to assign the `xtype` class `login` to this class so that later we can instantiate
    this same class using its `alias` (which is the same as `xtype`). For example,
    we can instantiate the `Login` class in five different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Option 1: Using the complete name of the class, which is the most used method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Option 2: Using `alias` in the `Ext.create` method:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Option 3: Using `Ext.widget`, which is shorthand for `Ext.ClassManager.instantiateByAlias`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Option 4: Using `xtype` as an item of another component:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Option 5: Using the `new` keyword:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this book, we will use the options 1, 3, and 4 the most. Options 1, 2, 3,
    and 5 return a reference to the instantiated component.
  prefs: []
  type: TYPE_NORMAL
- en: Option number 5 is not a good practice. Although options 4 and 5 were the only
    way to instantiate classes until Ext JS 3, the other options were introduced in
    Ext JS 4, and option 5 became deprecated.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although option 5 became deprecated with Ext JS 4 and later versions, we can
    still find some code in the Ext JS documentation and official Ext JS examples
    that use the `new` keyword. But do not get confused because of it. Option 5 should
    be avoided, always!
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we have the `autoShow` configured to `true` (`#4`). Consider the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'When we execute the preceding code, an instance of the `Login` class will be
    created (and if we need to, we can store this reference in a variable to manipulate
    it later). As the `Login` class is a subclass of the `Window` class, it inherits
    all its behavior, and one if its behaviors is that the window is not displayed
    automatically when instantiated. If we want to display the `Window` class (or
    any of its subclasses in the application), we need to call the `show()` method
    manually, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: An alternative to the preceding code is to have the `autoShow` configuration
    set to `true`. This way the `Window` class (or the `login` class in our case)
    will be automatically displayed when we instantiate it.
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `height` (`#5`) and `width` (`#6`) of the window.
  prefs: []
  type: TYPE_NORMAL
- en: We set `layout` as `fit` (`#7`). Recapitulating, the `fit` layout is used when
    the parent container (in this case, `Login`) has only one child, and this child
    will occupy all the available space of the parent container. As our **Login**
    window will have two fields inside it (username and password), these two fields
    need to be placed inside the `form` subclass . In this case, the `form` subclass
    will be the child of the `Login` class.
  prefs: []
  type: TYPE_NORMAL
- en: We are setting `iconCls` (`#8`) to the **Login** window; this way, we will have
    an icon of a key in the header of the window (we will set up the icons later in
    this chapter). We can also give a `title` to the window (`#9`), and in this case,
    we chose `Login`.
  prefs: []
  type: TYPE_NORMAL
- en: There are also the `closeAction` (`#10`) and `closable` (`#11`) configurations.
    The `closeAction` will tell if we want to destroy the window when we close it.
    In this case, we do not want to destroy it; we only want to hide it. And the `closable`
    configuration tells us whether we want to display the *X* icon on the top-right
    corner of the window. As this is a **Login** window, we do not want to give this
    option for the user (the user can only try to submit the username and password
    to log in to the application).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the difference between the methods `close`, `hide`, and `destroy`? The
    `close` method closes the panel, and by default, this method removes it from the
    DOM and destroys the panel object and all its descendant components. The `hide`
    method hides the component, setting it to invisible (it can be made visible again
    by calling the `show` method). And the `destroy` method cleans up the object and
    its resources, but removes it from the DOM and frees the object so that it can
    be cleaned by the garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `draggable` (`#12`) and `resizable` (`#13`) configurations.
    The `draggable` configuration controls whether the component can be `draggable`
    throughout the browser space. When the `resizable` configuration is set to `true`
    (its default value), the user can scroll over the corner of the component and
    resize it.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, this is the output we have—a single window with a blank icon in the
    top-left corner with the title **Login** (we will set up all the icons later in
    this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Login screen](img/0457OT_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next step is to add the `form` with the `username` and `password` fields.
    We are going to add the following code to the `Login` class (after line `#13`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As we are using the `fit` layout, we can only declare one child `item` inside
    the `Login` class. So we are going to add a `form` (`#14`) inside the `Login`
    class. Note that here we are using option 4 presented earlier. When declaring
    items in Ext JS, this is usually the way we instantiate the components (using
    option 4). We added a body `padding` to the `form` body (`#15`), which is going
    to add a space between the form and the window border, making it look prettier.
  prefs: []
  type: TYPE_NORMAL
- en: As we are going to add two fields to the form, we probably want to avoid repeating
    some code. That is why we are going to declare some field configurations inside
    the `defaults` configuration of the `form` (`#16`); this way, the configuration
    we declare inside `defaults` will be applied to all items of the `form`, and we
    will need to declare only the configurations we want to customize. As we are going
    to declare two fields, both of them will be of the type `textfield` (`#17`).
  prefs: []
  type: TYPE_NORMAL
- en: The default layout used by the `form` component is the `anchor` layout, so we
    do not need to make this declaration explicit. However, we want both fields to
    occupy all the horizontal available space of the body of the form. That is why
    we are declaring the `anchor` as `100%` (`#18`).
  prefs: []
  type: TYPE_NORMAL
- en: While the `fit` layout allows you to render only one child component that will
    occupy all the available space within the parent container, the Anchor layout
    enables you to anchor child containers relative to the parent container dimensions.
    In this case, we want the text fields to occupy 100 percent of the horizontal
    space available in the form. If we wanted the text fields to occupy only 70 percent
    of the available horizontal space, we could set the `anchor` config to `70%`.
  prefs: []
  type: TYPE_NORMAL
- en: By default, the `width` attribute of the label of the `textfield` class is 100
    pixels. This is too much space for a label `User` and `Password`, so we are going
    to decrease this value to `60 pixels` (`#19`).
  prefs: []
  type: TYPE_NORMAL
- en: And finally, we have the `user` `textfield` and the `password` `textfield`.
    The configuration `name` is what we are going to use to identify each field when
    we submit the form to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is only one detail missing: when the user types the password into the
    field, the system cannot display its value—we need to mask it somehow. That is
    why `inputType` is `''password''` (`#20`) for the `password` field because we
    want to display bullets instead of the original value—and the user will not be
    able to see the password value.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other input types can be used with the `textfield` as well. Input types of HTML5,
    such as `email`, `url`, and `tel` can be used as well. However, if the application
    is being executed from an older browser (or a browser that does not support the
    input type), Ext JS automatically changes it to its default value, which is `text`.
    For more information about HTML5 input types and browsers that support each type,
    please visit [http://www.w3schools.com/html/html5_form_input_types.asp](http://www.w3schools.com/html/html5_form_input_types.asp).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have improved our **Login** window a little more. This is the output
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Login screen](img/0457OT_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Client-side validations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The field component in Ext JS provides some client-side validation capability.
    This can save time and also bandwidth (the system will only make a server request
    when it is sure the information has the basic validation and we also do not need
    to wait for the server to validate the input). It also helps to point out to the
    user where they have gone wrong in filling out the form. Of course it is also
    good to validate the information again on the server side for security reasons,
    but for now we will focus on the validations we can apply to the form of our **Login**
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s brainstorm some validations we can apply to the username and password
    fields:'
  prefs: []
  type: TYPE_NORMAL
- en: The `username` and `password` must be mandatory—how are you going to authenticate
    the user without a username and password?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can only enter alphanumeric characters (A-Z, a-z, and 0-9) in both
    fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can only type between 3 and 25 chars on the `username` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user can only type between 3 and 15 chars on the `password` field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So let''s add into the code the ones that are common to both fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We are going to add the preceding configurations inside the `defaults` configuration
    of the `form` as they all apply to both fields we have. First, both need to be
    mandatory (`#21`), second, we can only allow the user to enter alphanumeric characters
    (`#22`), and the minimum number of characters the user needs to input is three
    (`#23`). Then, a last common configuration is that we want to display any validation
    error message under the field (`#24`).
  prefs: []
  type: TYPE_NORMAL
- en: 'And the only validation customized for each field is that we can enter a maximum
    of 25 characters in the **User** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'And a maximum of 15 characters in the **Password** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After we apply the client validations, we will have the following output just
    in case the user went wrong in filling out the **Login** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Client-side validations](img/0457OT_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'If you do not like the error message being displayed under the field, we can
    change the place where the error message appears. We just need to change the `msgTarget`
    value. The available options are: `title`, `under`, `side`, and `none`. We can
    also show the error message as a `tooltip` (`qtip`) or display them in a specific
    target (`innerHTML` of a specific component).'
  prefs: []
  type: TYPE_NORMAL
- en: For the `side` option, for example, the red exclamation mark will be displayed
    on the side of the field, and when the user does a mouseover on it, the `tooltip`
    with the error message is displayed. Once the input is valid (the user enters
    more characters in the **User** field or deletes some characters from the **Password**
    field, the error message disappears automatically).
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom VTypes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Many systems have a special format for passwords. Let's say we need the password
    to have at least one digit (0-9), one letter lowercase, one letter uppercase,
    one special character (@,#,$,%, and so on) and its length between 6 and 20 characters.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a regular expression to validate that the password is being entered
    into the app. And to do this, we can create a custom `VType` to do the validation
    for us. To create a custom `VType` is simple. For our case, we can create a custom
    `VType` called `customPass`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The name of our custom `VType` is `customPass`, and we need to declare a function
    that will validate our regular expression. And `customPassText` is the message
    that will be displayed to the user just in case the incorrect password format
    is entered.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about regular expressions, please visit [http://www.regular-expressions.info/](http://www.regular-expressions.info/).
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code can be added anywhere in the code, inside the `init` function
    of a Controller, inside the `launch` function of `app.js`, or even in a separate
    JavaScript file (recommended) where you can put all your custom `Vtypes`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `VType` is a singleton class that contains a set of commonly used field
    validation functions and provides a mechanism to create reusable custom field
    validations. For more information about this class and the default validations
    supported by Ext JS, please visit [http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.form.field.VTypes](http://docs.sencha.com/extjs/5.1/5.1.0-apidocs/#!/api/Ext.form.field.VTypes).
  prefs: []
  type: TYPE_NORMAL
- en: Create a new file named `CustomVTypes.js` under the `app` directory. Add the
    preceding code to this file. Now, we need this file to be loaded with our application
    as well. But hold your instincts to manually include this JavaScript file in the
    `index.html` file. We are going to follow best practices!
  prefs: []
  type: TYPE_NORMAL
- en: 'Locate the following code around line 110 of the `app.json` file inside the
    `masteringextjs` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To make our `CustomVTypes.js` file automatically load with our application,
    we simply need to add the following highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `includeInBundle` configuration tells Sencha Cmd that this file needs to
    be added to the final `.js` file that is generated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Only one file can have the `bundle: true` configuration. This means that it
    is the main file of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Always remember to have the `sencha app watch` command running in a terminal
    window so that Sencha Cmd can make a new build every time we make changes to the
    code. In this case, `CustomVTypes.js` will be loaded without any further changes
    to the `index.html` file. Really cool!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s apply the custom `VType` to our code. Add the following code to
    the password field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, change the message target for the password field. As the error message
    is quite long, it will not look nice with the message target `under`. This will
    be the result after we apply the custom `vType`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating custom VTypes](img/0457OT_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding the toolbar with buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until now, we created the **Login** window, which contains a form with two fields
    and it is already being validated as well. The only thing missing is to add the
    two buttons, **Cancel** and **Submit**.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add the buttons as items of a `toolbar`, and the `toolbar`
    will be added on the `form` as a docked item. The `dockedItems` can be docked
    to either the *top*, *right*, *left*, or *bottom* of a panel (both form and window
    components are subclasses of a panel). In this case, we will `dock` the `toolbar`
    at the bottom of the form. Add the following code right after the items configuration
    of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we take a look back to the screenshot of the **Login** screen that we first
    presented at the beginning of this chapter, we will notice that there is a component
    for the translation/multilingual capability. And after this component, there is
    a space and then we have the **Cancel** and **Submit** buttons. As we do not have
    the multilingual component yet, we can only implement the two buttons, but they
    need to be at the right end of the form, and we need to leave that space. That
    is why we first need to add a `tbfill` component (`#25`), which is going to instruct
    the toolbar's layout to begin using the right-justified button container.
  prefs: []
  type: TYPE_NORMAL
- en: Then we will add the **Cancel** button (`#26`) and then the **Submit** button
    (`#27`). We are going to add an icon to both buttons (`iconCls`) that we will
    add to our CSS file later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We already have the client validations, but even with the validations, the user
    can click on the **Submit** button, and we want to avoid this behavior. That is
    why we are binding the **Submit** button to the form (`#28`); this way, the button
    will only be enabled if the form has no error from the client validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the current output of the **Login**
    form (after we added the toolbar) and also verify the behavior of the **Submit**
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the toolbar with buttons](img/0457OT_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we want to add a toolbar with buttons in a form, we can add it using the
    configuration `buttons` as well. For more information, please access [http://goo.gl/X38h8Q](http://goo.gl/X38h8Q).
  prefs: []
  type: TYPE_NORMAL
- en: Running the code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To execute the code we have created so far, we need to make a few changes in
    the `Application.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to declare the `views` we are using (only one in this case),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And the last change is inside the `launch` function. In the preceding chapter,
    we left a `console.log` message where we needed to instantiate our initial view;
    now we only need to replace the `console.log` message with the `Login` instance
    (`#1`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now that `Application.js` is OK, and we can execute what we have implemented
    so far!
  prefs: []
  type: TYPE_NORMAL
- en: A quick overview about Ext JS dynamic class loading
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Dynamic class loading was introduced in Ext JS 4\. It provides an integrated
    dependency management capability, and it is very useful, especially when working
    on the development (local) environment (it also plays an important role in the
    final production build). This capability is also one of the reasons why option
    5 for instantiating classes in Ext JS (using the keyword `new`) became deprecated
    and not a best practice.
  prefs: []
  type: TYPE_NORMAL
- en: What does dynamic loading mean? It means that we do not need to load all Ext
    JS SDK classes prior to load our application. For example, for the Login window,
    we are using the `Window`, `Form`, and `TextField` classes from the Ext JS SDK.
    To execute our application, we do not need the source code of the grid, tree,
    and charts. Do you agree?
  prefs: []
  type: TYPE_NORMAL
- en: Still on the Login window example, when our application is loaded, Ext JS will
    read that the '`login.Login`' view needs to be loaded. As all the application
    source code is inside the `app` folder, and the views are inside the `app/view`
    folder, the Ext JS loader will expect to find the `app/view/login/Login.js` file,
    and inside this file it expects to find the '`Packt.view.login.Login`' class definition
    (this is why it is very important to follow the naming conventions we introduced
    earlier). The Ext JS loader will then see that this class inherits from the `Ext.window.Window`
    class, and if this class was not loaded yet, it is going to figure out all its
    dependencies (from the `extend` and `requires` declarations—we will discuss `requires`
    in a bit) and load them until we have all the source code required to execute
    the application loaded (and it will do this recursively until all code is loaded).
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, when you try to execute the application, open the Chrome Developer
    Tools (*Ctrl + Shift + I* or *Command + Shift + I*) or Firebug for Firefox (enable
    all panels) and open the **Network** tab. We will be able to see all files that
    were loaded for our application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A quick overview about Ext JS dynamic class loading](img/0457OT_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We know that **5MB** is scary for only a **Login** screen, but we will solve
    this issue when we do the production build later on this book. We do not need
    to worry about it for now.
  prefs: []
  type: TYPE_NORMAL
- en: What will happen later when we do the production build is that Ext JS will know
    which classes from the SDK need to be included in the final JavaScript file, will
    concatenate everything into a single file, and will also obfuscate it. If you
    try to open any of the files listed in the preceding screenshot, you will be able
    to read the source code (and it will be pretty and indented as the development
    source code should be).
  prefs: []
  type: TYPE_NORMAL
- en: Adding Font Awesome support (Glyph icons)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using icons on the application improves its look and feel, it makes the application
    look prettier, and users usually enjoy it. However, unless we get (or buy) icons
    with different sizes, the icons are 16 x 16 pixels big. With the introduction
    of **CSS3**, one of the new features is called **CSS3 Web Fonts** ([http://www.w3schools.com/css/css3_fonts.asp](http://www.w3schools.com/css/css3_fonts.asp)),
    which allow us to use fonts that are not installed on the user's computer.
  prefs: []
  type: TYPE_NORMAL
- en: This feature allowed developers to create a new type of icons, called **Glyph
    icons**, which are not actually icons, but fonts where each character looks like
    an icon (similar to the *Webding* font, [http://en.wikipedia.org/wiki/Webdings](http://en.wikipedia.org/wiki/Webdings)).
  prefs: []
  type: TYPE_NORMAL
- en: Using Glyph icons is great because we can change the size and color of the icon
    to match the application's theme. Whenever possible, we will use Glyph icons in
    our application. There is an open source and free font that is used widely by
    modern applications (HTML5 applications) called **Font Awesome**, and we are going
    to use this in our project as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the first step is downloading the Font Awesome files from [http://fortawesome.github.io/Font-Awesome/](http://fortawesome.github.io/Font-Awesome/).
    Click on the **Download** button. The file that is going to be downloaded is a
    `.zip` file. Unzip it. Copy the `fonts` folder and paste it inside the `resources`
    folder of the `masteringextjs` application. Copy the `scss` folder and paste it
    inside the `sass/etc` folder. Rename the `scss` folder to `fontAwesome`. This
    is how the `sass/etc` and `resource` folders will look after the changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Font Awesome support (Glyph icons)](img/0457OT_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We are almost there! Open the `sass/etc/fontAwesome/_variables.scss` file,
    and change the variable `$fa-font-path` to the following value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This is to tell Sass where we placed the font files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now all we have to do is open the `sass/etc/all.scss` file and add the following
    code in the first line of the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are running `sencha app watch` in the terminal application, you should
    note that the application was rebuilt and we are ready to see the icons in our
    application. The following is how the **Login** screen will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Font Awesome support (Glyph icons)](img/0457OT_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The next step is to add some action to the **Cancel** and **Submit** buttons.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about Sass variables and import capabilities, please visit [http://sass-lang.com/guide](http://sass-lang.com/guide).
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Login Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created the view for the **Login** screen so far. As we are following
    the MVC architecture, we are not implementing the user interaction on the `View`
    class. If we click on the buttons on the `Login` class, nothing will happen, because
    we have not implemented this logic yet. We are going to implement this logic now
    on the `Controller` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ext JS 5, we have two options to do this: use the default MVC architecture
    or use the MVVM architecture pattern (or a *hybrid* pattern).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the MVVM architecture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the preceding chapter, we covered an introduction of the MVC architecture
    in Ext JS. Let''s refresh our memory quickly of how MVC works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the MVVM architecture](img/0457OT_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Model** represents the information that is being used by the application.
    The **View** is what the user will see on the screen—the components. In each interaction
    of the user with the application, the components will fire events. The **Controller**
    is where we are going to handle the events and execute any logic that is needed;
    the Controller is going to manage the information (**Model**) and also manage
    the **View** (and the interaction between the **View** and **Model**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Ext JS 5, Sencha introduced this new pattern called **Model View ViewModel**
    (**MVVM)**, which is shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the MVVM architecture](img/0457OT_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What happens in the MVVM is that using this pattern, it is much easier to control
    the **View** and the **Model** if they are bound. For example, consider that we
    have a data grid where we list some contacts. When we select a contact and click
    on the **Edit** button, we want the application to open a pop up about the title
    that will be the name of the contact and the pop up will also have a form that
    will display the contact details for editing. If we use the default MVC pattern,
    we will need to control the way the **View** (data grid, pop up, and form) interacts
    with the **Model** (contact information). The MVVM (which is based on the MVC)
    introduces a new abstraction entity that is the **ViewModel**. The **ViewModel**
    mediates changes between the **View** and the associated **Model**.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, with this new pattern and new **ViewModel** abstraction, Sencha also
    introduced an abstraction for the controller, which is bound to the **View**,
    called the **ViewController**. The **ViewController** is very similar to the traditional
    controller of the MVC pattern, which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing the MVVM architecture](img/0457OT_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: However, as we learned in [Chapter 2](ch02.html "Chapter 2. Getting Started"),
    *Getting Started*, the controllers of the MVC pattern are created in the scope
    of the application, and they are unique instances (meaning a single instance of
    each controller of the application). As long as the application is running, the
    controllers are also alive.
  prefs: []
  type: TYPE_NORMAL
- en: The **ViewModel** and **ViewController** are part of the component (we learned
    about component in [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"),
    *Sencha Ext JS Overview*). As long as the **View** is alive, they are also alive.
    When the **View** is destroyed, they also get destroyed. This means that we can
    save some memory (if we do not have many instances of the same **View** at once).
  prefs: []
  type: TYPE_NORMAL
- en: Do not worry if you do not understand all these concepts 100 percent right now.
    We will learn how to use them and how they work with some examples, and throughout
    this book we will use these different options of architecture so that we can learn
    how each one works, and maybe you can choose the one you like the most or the
    one that is going to fit your project best.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the ViewController for Login View
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let''s stop to think a little bit. Logging in is performed once during the
    application''s lifetime. There are three things we can do in the application:
    log in to start using it, use its capabilities, or log out (because we clicked
    on the logout button or the session expired). Once we have logged in, we are in,
    and that is it.'
  prefs: []
  type: TYPE_NORMAL
- en: In the previous topic we learned that the **ViewModel** and the **ViewController**
    are destroyed once the **View** is destroyed. So, instead of having a controller
    for the login alive during the application's lifetime, we can have a controller
    that will be alive only during the time that the login View is alive. For this
    reason, for the **Login** screen, we will use the **ViewController**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is creating the JavaScript file. Inside `app/view/login`, we
    will create the `LoginController.js` file. Inside this file, we will implement
    the following code, which is only a base of the `ViewController` class we are
    going to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As usual, on the first line of the class, we have its name (`#1`). Following
    the same formula we used for the `view/login/Login.js`, we will have `Packt` (*app
    namespace*) + `view` (*name of the package*) + `login` (*name of the sub package*)
    + `LoginController` (*name of the file*), resulting in `Packt.view.login.LoginController`.
  prefs: []
  type: TYPE_NORMAL
- en: The `ViewController` classes need to extend from `Ext.app.ViewController` (`#2`)
    so that we will always use this parent class for our `ViewController`.
  prefs: []
  type: TYPE_NORMAL
- en: We also need to give an `alias` to this `ViewController` (`#3`). Aliases for
    ViewControllers start with `'controller'`, followed by the alias we want to assign
    (remember that the alias is always in lowercase).
  prefs: []
  type: TYPE_NORMAL
- en: For `#4`–`#10`, we have the signature of some methods we will implement until
    the end of this chapter. We will go through each of them later.
  prefs: []
  type: TYPE_NORMAL
- en: Binding the ViewController to the View
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'Now that we have the base of our ViewController ready, we need to bind the
    ViewController to its View, which is the `Login` View. Going back to the `Packt.view.login.Login`
    class, we are going to add the following configuration to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The preceding configuration will bind the `ViewController` class to the `Login`
    class life cycle. Note that we are using the alias we defined in `#3`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to execute the code, it will throw an error. This is because Ext
    JS does not know which `ViewController` class has the `login` alias (since this
    alias is not a native of the framework; we are creating it). To make it work,
    we need to add the following code to the `login` class as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will tell the Ext JS loader that it also needs to be loaded when loading
    the `Login` class. Ext JS will load this class and all its dependencies. By the
    time Ext JS parses the `controller: ''login''` code, it will have registered the
    `login` alias for a controller and it is going to be OK.'
  prefs: []
  type: TYPE_NORMAL
- en: Listening to the button click event
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our next step now is to start listening to the **Login** window events. First,
    we are going to listen to the **Submit** and **Cancel** buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we are using a `ViewController` class and not a Controller (MVC), we need
    to add listeners inside the `Login` class. First, let''s do it for the **Cancel**
    button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code means that when a user clicks on the **Cancel** button, the `onButtonClickCancel`
    method from the `Login ViewController` class will be executed. So let''s implement
    this method! Back to the `LoginController` class, we already know that this is
    the method we are going to implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'But how do we know which are the parameters the method can receive? We can
    find the answer to this question in the documentation. If we take a look at the
    click event in the documentation (`Button` class), this is what we will find:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listening to the button click event](img/0457OT_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is exactly what we declared. For all the other event listeners, we will
    go to the docs and see which are the parameters the event accepts, and then list
    them as parameters in our code. This is also a very good practice. We should always
    list out all the arguments from the docs even if we are only interested in the
    first one (or even none). This way, we always know that we have the full collection
    of the parameters, and this can come in very handy when we are doing maintenance
    on the application.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Make sure the documentation becomes your best friend while developing Ext JS
    applications. The Ext JS documentation is really good and user friendly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we also want to listen to the **Submit** button click. The `onButtonClickSubmit`
    method has the same signature as the `onButtonClickCancel` method. Let''s go ahead
    and also add the listener to the **Submit** button, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s do a quick test to see if everything is working as expected so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: For now, we are only going to output a message on the console to make sure our
    code is working. So, we are going to output `'login submit'` (`#2`) if the user
    clicks on the **Submit** button, and `'login cancel'` (`#1`) if the user clicks
    on the **Cancel** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go ahead and try it. Click on the **Cancel** button and then on the
    **Submit** button. This should be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listening to the button click event](img/0457OT_03_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cancel Button Listener implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's remove the `console.log` messages and add the code we actually want the
    methods to execute. First, let's work on the `onButtonClickCancel` method. When
    we execute this method, we want it to reset the **Login** form.
  prefs: []
  type: TYPE_NORMAL
- en: 'So this is the logic sequence we want to program:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the form reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call the `reset` method to reset the form
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we take a look at the parameters we have available on the `onButtonClickCancel`
    method, we have `button`, `e`, and `options`, and none of them provides us with
    the form reference. So what can we do about it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ViewController` class has an interesting way of getting a reference of
    the `Login` class or any of its children, which uses the method `lookupReference(reference)`
    from the `ViewController` class. To be able to use this method, all we have to
    do is add a reference for the `form` in the `Login View` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With this reference, we will be able to call the `this.lookupReference(''form'')`
    method directly to retrieve the form reference. With the form reference, all we
    have to do is call the method `reset()` from the `form` class. The complete code
    for the `onButtonClickCancel` method would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Submit Button Listener implementation
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now we need to implement the `onButtonClickSubmit` method. Inside this method,
    we want to program the logic to send the **User** and **Password** values to the
    server so that the user can be authenticated.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can implement two programming logics inside this method: the first one is
    to use the `submit` method that is provided by the `Form Basic` class, and the
    second one is to use an Ajax call to submit the values to the server. Either way,
    we will achieve what we want to do. For this example, we will use the default
    form submit call.'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps we need to perform in this method:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the **Login** form reference
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Get the **Login** window reference (so we can close it once the user has been
    authenticated)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Send Login information to the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Handle the server response, as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the user is authenticated, display application
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If not, display error message
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We already know how to get the form reference. This is how `onButtonClickSubmit`
    will look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'So first, before doing anything, we will make sure the user has entered all
    the required information (user name and valid password (`#1`)). If everything
    is OK, then we call a helper method that will handle the authentication (`#2`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First, just to make sure the data we are trying to submit is valid (we will
    call this `doLogin` method from another method as well, so to be sure we are sending
    valid data to server is never too much!), we set the `clientValidation` configuration
    as `true` to validate the information one more time (`#3`). Then we have the `url`
    that is going to be called (`#4`). The `success` (`#6`) and `failure` (`#7`) callbacks
    were declared as separate functions, which belong to the `ViewController` class,
    and that is why the scope is the `ViewController` class (`#5`).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We could implement the success and failure methods inside the submit call as
    well (as showed by the example in the documentation [http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.form.Basic-method-submit](http://docs.sencha.com/extjs/5.0.0/apidocs/#!/api/Ext.form.Basic-method-submit)).
    But we do not know how much code we will need to handle the authentication. Working
    with scoped callbacks is better because our code stays organized, with better
    readability.
  prefs: []
  type: TYPE_NORMAL
- en: If we try to run this code, the application will send the request to the server,
    but we will get an error as response because we do not have the `login.php` page
    implemented yet. That's OK because we are interested in other details right now.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Firebug or Chrome Developer Tools enabled, open the **Network** tab and
    filter by the **XHR** requests. Make sure to enter a `username` and `password`
    (any valid value so we can click on the **Submit** button). This will be the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Submit Button Listener implementation](img/0457OT_03_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note that the user and password are being sent as form data. This information
    is useful to handle the information on the server side (which in our case is the
    PHP code).
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Whenever you have questions or you have no idea how you are going to handle
    the information sent by Ext JS to the server, open the debug tool of your browser
    and inspect the call. This helps a lot and also helps you to learn more about
    how Ext JS works when communicating with the server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the User and Groups tables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we start coding the `login.php` page, we need to add two tables to the
    Sakila database. These two tables are going to represent the users and also the
    group that the user can belong to. In our project, a user can belong to only one
    group, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User and Groups tables](img/0457OT_03_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, we are going to create the `Group` table, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we are going to create the `User` table containing the indexes and also
    the `foreign key` to the `Group` table:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The next step is to insert some data into these tables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As the password will be saved hashed on the database, the value `$2a$10$2a4e8803c91cc5edca222evoNPfhdRyGEG9RZcg7.qGqTjuCgXKda`
    corresponds to the value `Packt123@`. We will be hashing our password for more
    security in the user administration module.
  prefs: []
  type: TYPE_NORMAL
- en: Now we are ready to start developing the `login.php` page.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Login page on the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have part of the Ext JS code to send the login information to the server,
    we can implement the server-side code. As mentioned in the first chapter of this
    book, we are going to use PHP to implement the server-side code. But if you do
    not know PHP, do not worry because the code is not going to be complicated, and
    we are going to use pure PHP as well. The goal is to focus on the programming
    logic we need to use on the server side; this way we apply the same programming
    logic to any other server-side language that you like to use (Java, .NET, Ruby,
    Python, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first step is to create the file that is going to be responsible for connecting
    to the database. We are going to reuse this file in almost every PHP page that
    we are going to develop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new folder named `php` under the project''s root folder, and under
    `php`, create a new folder named `db`. Then, create a new file named `db.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The connection is pretty straightforward. We simply need to inform the `server`
    (which is going to be `localhost`), the databases `username` and `password`, and
    also the database `name` that we want to connect to. And at last, we can check
    whether the connection was done successfully or any error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about MySQLi, please visit [http://php.net/manual/en/book.mysqli.php](http://php.net/manual/en/book.mysqli.php).
  prefs: []
  type: TYPE_NORMAL
- en: Login.php
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we can create the `login.php` file under the `php/security` folder.
    So let''s start implementing it, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to *require* the `db.php` file to connect to the database (`#1`).
    We are also going to `require` the `PassHash.php` file (`#2`). This file contains
    the `check_password` method, which will compare the password entered by the user
    with the one that is stored in the database (hashed).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we start a session (`#3`)—we are going to store the username on the session
    later.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to retrieve the `user` and `password` values sent by the form
    submit method from Ext JS (`#4` and `#5`).
  prefs: []
  type: TYPE_NORMAL
- en: The `stripslashes` function removes the backslashes from the given string (`#6`
    and `#7`). For example, if the user value is `"Loiane\'s"`, the return of `stripslashes`
    will be `"Loiane's"`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: These two steps help a little bit to ensure the security of the application;
    however, they are not enough. It is very important to *sanitize* the user input
    in the server so that we do not store or try to execute SQL statements with malicious
    input. For the purpose of this book, we will not apply this technique to keep
    the server-side code simple, so even though you do not know PHP, you will be able
    to read and understand the logic behind it and implement something similar in
    the server-side language of your choice. However, be aware that in real-world
    applications, it is very important to apply this step, especially if you are releasing
    your application to the general public (not for internal use only).
  prefs: []
  type: TYPE_NORMAL
- en: There is a project called **Open Web Application Security Project** (**OWASP**),
    which is free and open source that provides a set of libraries and APIs to apply
    security techniques in your application. There are subprojects available for .NET,
    Java, and PHP, tutorials on how to avoid XSS attacks and SQL injections, and how
    to prevent other security vulnerabilities. For more information, please visit
    [https://www.owasp.org](https://www.owasp.org).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we prepare the `$username` variables for the SQL statement using the function
    `real_escape_string` (`#8`), which escapes special characters in a string for
    use in a SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we prepare the SQL query that is going to be executed (`#9`). It is a
    simple `SELECT` statement that is going to return a result matching the given
    `username`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s continue with the next part of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Next, we need to execute the SQL query, and we are going to store the result
    set in the `resultDb` variable (`#10`). Then, we are going to store data according
    to whether the result set returned any rows within the result set (`#11`).
  prefs: []
  type: TYPE_NORMAL
- en: Now comes the most important part of the code. We are going to verify whether
    the result set returned any rows. As we passed the `username`, the number of rows
    returned within the result set must be exactly `1`. So, if the number of rows
    is equal to `1` (`#12`), we need to see whether the hashed password stored in
    the database matches the password entered by the user, but first, we need to retrieve
    this information from the record that was fetched from the database (`#13`).
  prefs: []
  type: TYPE_NORMAL
- en: The `PassHash` class is responsible for hashing the password, making it a little
    bit more secure to save the hashed password in the database (instead of the plain
    password), for decrypting the hashed password from the database (`$record['password']`),
    and for comparing to the password the user entered in the login page (`#14`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For now, you can get the complete code for `PassHash.php` from the source code
    downloaded from this book. In [Chapter 6](ch06.html "Chapter 6. User Management"),
    *User Management*, we will go through it line by line.
  prefs: []
  type: TYPE_NORMAL
- en: If the password entered by the user and the decrypted hash password from the
    database match, it means the user can be authenticated. We are going to store
    the `username` of the authenticated user (`#16`) in the `Session` and also the
    information that the user is `authenticated` (`#15`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to prepare the result that we are going to return to Ext JS. We
    are going to send back two pieces of information: the first one is about whether
    the user is `authenticated` (`#17`)—in this case `"true"`—and we can also send
    back a message (`#18`).'
  prefs: []
  type: TYPE_NORMAL
- en: If the password entered by the user and the one from the database do not match,
    then we also need to return something to Ext JS. The `success` is going to be
    `false` (`#19`), and we are going to return a message so that we can display to
    the user (`#20`).
  prefs: []
  type: TYPE_NORMAL
- en: If the `username` does not exist in the database (number of rows returned within
    the result set is different from `1`), we are also going to send back a message
    to Ext JS saying the username or password informed by the user is incorrect (`#22`).
    Therefore, the `success` information will be `false` (`#21`).
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to close the result set (`#23`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the third and last part of the code of `login.php`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We need to close the database connection (`#23`), and we are going to `encode`
    the `result` that we are going to send back to Ext JS in the JSON format (`#24`).
  prefs: []
  type: TYPE_NORMAL
- en: And now, the `login.php` code is complete. We cannot forget to add `<?php` before
    the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the return of the server – logged in or not?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We already took care of the server-side code. Now, we need to go back to the
    Ext JS code and handle the response from the server.
  prefs: []
  type: TYPE_NORMAL
- en: Success and failure in Ext JS has two different concepts. The form handles it
    in a way and the Ajax request handles it in a different one. This can be a little
    bit confusing, so we are going to implement requests to the server using the form
    submit (as this example) and also the Ajax request so that we can learn how to
    implement the proper code using both ways.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the form, the server needs to return the `success: true` information so
    that the callback to be executed is a successful one. For failure, the server
    needs to return `success: false`, which can be returned if any communication error
    might have occurred (page nor found, exception on server, and so on). For the
    Ajax request, it does not matter whether `success` is `true` or `false`; it is
    going to execute the success callback; only if any communication error occurs
    is it going to execute the failure callback.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is good to remember that the content type that the server needs to return
    to Ext JS is `application/json` and in the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s handle the success callback first. In the event of success, the `onLoginSuccess`
    method is going to be executed. In this case, we want to close the **Login** window
    and display the main screen of the application, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `Window` class has a method called `close` that we can call to close the
    window. The question is how to get the reference of the `login window` class.
    The `ViewController` class is directly bound to it, and we can reference the `Login`
    class itself by calling the method `getView` of the `ViewController` class (`#1`).
    Then, we can create the main screen by instantiating the `Main` class (`#2`) that
    was created by Sencha Cmd when we created the application. We are going to reuse
    this class to create our main screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the preceding approach, there is a flaw with the security of the code.
    A smart user who understands how Ext JS works can access the main page using a
    code similar to the preceding one even if the user is not authenticated. A more
    secure way would be to redirect to a page that holds the application (calling
    the `Main` class directly). As we are working with an example here, that is OK.
    However, keep that in mind when developing a real application!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the event of failure, there are two cases that we need to handle: the first
    one is if the user was not authenticated because the user does not exist or because
    the password is incorrect. The second one is if there is any communication failure
    (for example, error 404). Our `onLoginFailure` method will look like the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we dive into the failure callback, note that both `onLoginFailure` and
    `onLoginSuccess` receive two parameters: `form` and `action`. Where do they come
    from?'
  prefs: []
  type: TYPE_NORMAL
- en: If we take a look at the documentation, specifically on the `submit` method
    of the `Form` class (`Ext.form.Panel`), we will see that this `submit` method
    is calling the `submit` method from the class `Ext.form.Basic` (which is the class
    that actually contains all methods to handle form actions). If we take a look
    at the `submit` method from the `Ext.form.Basic` class ([http://docs.sencha.com/extjs/5.0/5.0.1-apidocs/#!/api/Ext.form.Basic-method-submit](http://docs.sencha.com/extjs/5.0/5.0.1-apidocs/#!/api/Ext.form.Basic-method-submit)),
    we will see a code similar to ours as an example. If we read the description,
    it says that this `submit` method is a shortcut to the `doAction` method from
    the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we open the documentation for this method ([http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.form.Basic-method-doAction](http://docs.sencha.com/extjs/5.0/apidocs/#!/api/Ext.form.Basic-method-doAction)),
    we will be able to see the parameters we used for the form submit call (`url`,
    `success`, and `failure` callbacks, among others) and also the parameters that
    both success and failure callbacks receive—`form` and `action`—as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling the return of the server – logged in or not?](img/0457OT_03_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The `action` parameter contains four attributes inside it. For our failure
    callback, we are interested in two of them: `failureType` and `response`. Let''s
    analyze `response` first. Add the following code (`console.log(action);`) to the
    first line of the failure callback, and try to submit an incorrect user or password
    in the **Login** screen. Before submitting to the server, open Chrome Developer
    Tools or Firebug to see what is going to be logged, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling the return of the server – logged in or not?](img/0457OT_03_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Inside the response, note that there is `responseText` with JSON that we returned
    from the server. So, the first thing we are going to do is decode this JSON (`#3`).
    After we decode it, we will be able to access `result.success` and `result.msg`.
    We also need to be careful about one detail: we do not know what is going to be
    returned from the server. We always hope that is our `success` and `msg` information;
    however, we cannot be sure of it. If any other error is returned, it is also going
    to be returned inside `action.response.responseText`, and it cannot have the JSON
    format we are expecting (cannot be a JSON either). If this happens, `Ext.JSON.decode`
    will fail, and it will throw an exception. We can silence the exception (passing
    `true` as the second parameter to the `Ext.JSON.decode` function, and the `result`
    will have the value `null`), but we still need to handle it. And it is what we
    do when checking whether the `result` variable is `null` (`#4`). If it is null,
    we are instantiating the `result` and assigning some values (the `msg` will receive
    the error sent by the server).'
  prefs: []
  type: TYPE_NORMAL
- en: After that, we will use the action `failureType` to see what type of error occurred.
    As `failureType` is code, Ext JS has some constants defined that are more developer
    friendly (`Ext.form.action.Action.CLIENT_INVALID`, for example). If `failureType`
    is `'client'` (`#5`), then we will display an error message in an alert pop up
    with an error icon. If a connection error happened with the server, then (`#6`)
    will handle it by displaying an error alert pop up as well. And if any exception
    or success is returned as false, (`#7`) will handle it. As we treated the return
    of the server to display the custom error message or any other message, we can
    simply display `result.msg` on the alert pop up (`#8`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Try entering a wrong user or password again and see what happens. Change `login.php`
    `url` to `login.php` (or change to any other `url`), or inside the `db.php` file,
    enter the incorrect password to connect to the database to simulate an error,
    and here''s what you will see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Handling the return of the server – logged in or not?](img/0457OT_03_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This way, we can handle all kind of server responses; not only the ones we are
    waiting for, but also any exceptions!
  prefs: []
  type: TYPE_NORMAL
- en: Reusing code by creating a Util class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that in (`#5`), (`#6`), and (`#7`) we are using the same error alert pop
    up, so code is repeated. Alert errors like this are used in different places of
    the application. As we are going to handle more Ajax requests and form submits
    in other screens of the application as well, the code in (`#3`) and (`#4`) will
    be repeated as well. For this reason, we can create a `Util` class that will encapsulate
    this code and provide us with the means to reuse it. Besides the reuse pro, it
    is also good to establish a pattern to be followed by the application, such as
    working out the JSON format that the server needs to return to Ext JS. This will
    make the application more organized, and it is also good when working in a team
    (usually each developer has their own pattern that they like to follow, and this
    way, we follow the same pattern for the same application, and it will not look
    as though it was implemented by different developers).
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s go ahead and create our first `Util` class. We will name it `Packt.util.Util`.
    For this reason, we are going to create a new file named `Util.js`, and we are
    also going to create a new folder named `util` under the `app` folder, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: All methods will be inside the `statics` declaration (`#1`). As we learned in
    [Chapter 1](ch01.html "Chapter 1. Sencha Ext JS Overview"), *Sencha Ext JS Overview*,
    we can simply call `Packt.util.Util.decodeJSON` for example, without needing to
    instantiate the `Packt.util.Util` class. The `decodeJSON` method (`#2`) contains
    the code to handle the JSON decoding, and the method `showErrorMsg` (`#3`) contains
    the code to display an error pop up alert with the content passed in the text
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Static methods do not require an instance of the class to be called. It is a
    concept of object-oriented programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s rewrite the `onLoginFailure` method by using the `Util` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Instead of 36 lines of code, now we have only 15, and the readability is better
    as well! In case we need to maintain this code, we can make the changes in the
    `Util` class, and the changes will be applied everywhere in the code that the
    class is being used! Best practices make our code really cool!
  prefs: []
  type: TYPE_NORMAL
- en: 'One last detail: we need to add the `Packt.util.Util` class in the `requires`
    declaration of the `ViewController` class as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This is because of the dynamic loading we discussed earlier in this chapter.
    If we try to execute the preceding code without having the `Util` class loaded,
    we can get an error.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing the Login screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our **Login** screen is done. However, there are some enhancements we can apply
    to it to make it even better and also offer a better experience to the user.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following list details the enhancements that we are going to apply in our
    **Login** screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Apply a loading mask while authenticating
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Submit the form when the user presses *Enter*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a Caps Lock warning message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying a loading mask on the form while authenticating
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, when the user clicks on the **Submit** button, there can be some
    delay while waiting for the server to send back the response. Some users will
    be patient, while some others will not. The ones that are not very patient will
    be able to click on the **Submit** button again, and this means making another
    request to the server. We can avoid this behavior by applying a loading mask to
    the **Login** window while awaiting the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to add the following code right before the `form.submit` call
    (inside the `doLogin` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: This will apply the mask to the **Login** screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, on the first line inside the `onLoginSuccess` and `onLoginFailure` functions,
    we need to add the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: And this will remove the mask from the **Login** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to execute the code, we will have the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Applying a loading mask on the form while authenticating](img/0457OT_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the Login screen is not reachable and the user cannot click on the
    buttons again until the server sends back a response and removes the mask.
  prefs: []
  type: TYPE_NORMAL
- en: Form submit on Enter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For some forms, especially for the **Login** form, it is very natural for people
    to hit *Enter* when they are ready. This behavior is not automatic for Ext JS;
    therefore, we have to implement it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `textfield` component has an event to handle special keys, such as *Enter*.
    This event is called `specialkey`, and it is the one that we are going to listen
    to in our login controller. As we want to listen to this event for both text fields
    we have (**User** and **Password**), we can add the following code inside the
    defaults of the form from the **Login** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement the `onTextFieldSpecialKey` method inside the `ViewController`
    class as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: First, we are going to verify that the key pressed by the user is *Enter*. If
    positive, we call the `doLogin` method we implemented earlier. Then, the form
    validation will be done and if the form is valid, it will try to log in. This
    will be the same as clicking on the **Submit** button.
  prefs: []
  type: TYPE_NORMAL
- en: Caps Lock warning message
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last enhancement we will apply to the form is the **Caps Lock** message.
    Sometimes the *Caps Lock* key is active, and when we input the password, we can
    input the correct password, but the system will say it is incorrect because it
    is case sensitive; warning the user about this is a nice thing to do.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot presents the final result of the **Caps Lock** warning
    implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Caps Lock warning message](img/0457OT_03_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding screenshot, we will display the warning as
    a tooltip. So the first thing we need to do is go back to the `Application.js`
    launch function, and on the first line, we need to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'An alternative is using the configuration `enableQuickTips: true` inside `Aplication.js`
    as well. You can use either one, and the result will be the same.'
  prefs: []
  type: TYPE_NORMAL
- en: Without the preceding code, the tooltips will not work in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Ext JS has two concepts of tooltips. The first one is the `Tooltip` class, which
    does not have a built-in method of automatically populating the tooltip's text
    based on the target element; you must either configure a fixed HTML value for
    each tooltip instance or implement custom logic (inside an event listener). The
    second one is the `QuickTip` class, which automatically populates and configures
    a tooltip based on specific DOM attributes of each target element. Tooltips are
    enabled by default. QuickTips are managed by the `QuickTipManager`, which requires
    to be manually initiated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The event that we are going to listen to is the `keypress` event, and we are
    only going to listen to this event fired by the `password` field. By default,
    the `textfield` component does not fire this event because it is a little bit
    heavy with regard to performance. As we want to listen to this event, we need
    to add a configuration (`enableKeyEvents`) to the `password` field (inside the
    `view/login/Login.js` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: We also need to add an `id` value to this field. Later, we will discuss the
    importance of avoiding using `id` in the components (since it is not a good practice),
    but in this case, there is nothing we can do about it. This is because when creating
    the `Tooltip` class, we need to set a `target` (in this case, the `password` field),
    and this `target` only accepts the `id` of the component, and not `itemId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we add the code to the Controller, we need to create the `Tooltip` class.
    We are going to create a new view called `Packt.view.login.CapsLockTooltip`, so
    we need to create a file named `CapsLockTooltip.js` under the `app/view/login`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'In `Packt.view.login.CapsLockTooltip`, we declare some configurations that
    are going to set the behavior of the `Tooltip` class. For example, we have the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`target`: This has the `id` value of the `password` field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchor`: This indicates that the tip should be anchored to a particular side
    of the target element (the `password` `id` field), with an arrow pointing back
    at the target.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`anchorOffset`: This is a numeric value (in pixels) used to offset the default
    position of the anchor arrow. In this case, the arrow will be displayed 60 pixels
    after the tooltip box beginning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width`: This is the numeric value (in pixels) to represent the `width` of
    the tooltip box.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dismissDelay`: This is the delay value (in milliseconds) before the tooltip
    automatically hides. As we do not want the tooltip to be automatically hidden,
    we set the value to `0` (zero) to disable it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`autoHide`: Set it to `true` to automatically hide the tooltip after the mouse
    exits the target element. And as we do not want it, we set it to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`title`: This is the title text to be used as the title of the tooltip.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`html`: This is the HTML fragment that will be displayed in the tooltip body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that on the title, we added a class to the `<div>` tag. This will display
    a warning icon from Font Awesome that we configured earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To see all icons from Font Awesome that are available to be used in the application,
    please visit [http://fortawesome.github.io/Font-Awesome/cheatsheet/](http://fortawesome.github.io/Font-Awesome/cheatsheet/).
  prefs: []
  type: TYPE_NORMAL
- en: 'And at last, we need to make some changes in the `ViewController` class. First,
    in the `requires` declaration, we will add the `CapsLockTooltip` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we are going to implement the `onTextFieldKeyPress` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: First, we need to get the `code` of the key that the user pressed (`#1`). Then,
    we need to verify that the *Shift* key is pressed and if the user pressed one
    of the small alphabet keys (a-z), or if the *Shift* key is not pressed and the
    user pressed one of the capital alphabet keys (A-Z) (`#2`). If the result of this
    verification is true, this means that the *Caps Lock* is active. If you want to
    check the values of each key, you can go to [http://www.asciitable.com/](http://www.asciitable.com/).
  prefs: []
  type: TYPE_NORMAL
- en: If the *Caps Lock* is active, we will verify that there is a reference of the
    `CapsLockTooltip` class (`#3`). If there is not, we will create a reference using
    its `xtype` (`#4`) and store it in a variable named `capslockTooltip`. This variable
    will be created as part of the `ViewController` class, so if this method is executed
    again, we can access it. Then, we display it by executing the method shown (`#5`).
  prefs: []
  type: TYPE_NORMAL
- en: If the *Caps Lock* is not active, we need to verify that there is a reference
    to the `CapsLockTooltip` class (`#6`). If positive, we will `hide` the tooltip
    because the *Caps Lock* is not active.
  prefs: []
  type: TYPE_NORMAL
- en: The Caps Lock warning code is now complete. We can save the project and test
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the details on how to implement a login page step
    by step. We covered how to create the login View and the `Login` `ViewController`
    class. We applied client validations on the form to make sure we send acceptable
    data to the server. We covered how to do a basic login using PHP, and we covered
    important concepts of how to handle the data that the server is going to send
    back to Ext JS.
  prefs: []
  type: TYPE_NORMAL
- en: We learned about some enhancements that we can apply to the **Login** screen,
    such as submitting the form when the user hit *Enter*, displaying a Caps Lock
    warning in the password field, and also how to apply a load mask on the form while
    it is sending data and waiting for information from the server.
  prefs: []
  type: TYPE_NORMAL
- en: We also added support to Font Awesome that will be used throughout our project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will continue to work on the **Login** screen. We will
    learn how to add the multilingual capability and also implement the Logout and
    Session Monitor capabilities.
  prefs: []
  type: TYPE_NORMAL
