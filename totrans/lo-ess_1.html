<html><head></head><body><div class="chapter" title="Chapter&#xA0;1.&#xA0;Working with Arrays and Collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch01"/>Chapter 1. Working with Arrays and Collections</h1></div></div></div><p>Lo-Dash<a id="id0" class="indexterm"/> offers a wide variety of functions that operate on arrays and collections. This generally involves iterating over the collection in one form or another. Lo-Dash helps make iterative behavior easy to implement, including searching for data, as well as building new data structures.</p><p>Collections are at the heart of applicative programming. This is where we will successively apply functions to each element in the collection. This chapter introduces the concept of the collection, something Lo-Dash code uses extensively.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Iterating over collections</li><li class="listitem" style="list-style-type: disc">Sorting data</li><li class="listitem" style="list-style-type: disc">Searching for data</li><li class="listitem" style="list-style-type: disc">Slicing collections into smaller pieces</li><li class="listitem" style="list-style-type: disc">Transforming collections</li></ul></div><div class="section" title="The difference between arrays and collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec08"/>The difference between arrays and collections</h1></div></div></div><p>One of the initial sources <a id="id1" class="indexterm"/>of confusion for newcomers to Lo-Dash is the distinction<a id="id2" class="indexterm"/> between arrays and collections. The Lo-Dash API<a id="id3" class="indexterm"/> has a set of functions for arrays, and a set of functions for collections. But why? It would appear that these functions are interchangeable for any collection. Well, a better definition of what a collection actually is according to Lo-Dash might clear things up.</p><p>A collection<a id="id4" class="indexterm"/> is an abstract concept. That is, we can use the collection functions found in Lo-Dash on any JavaScript object that we'd like to iterate over. For example, the <code class="literal">forEach()</code> function<a id="id5" class="indexterm"/> will happily iterate over an array, a string, or an object. The subtle differences between these types, and what they mean when it comes to iterating, are hidden from the developer.</p><p>The array <a id="id6" class="indexterm"/>functions provided by Lo-Dash are less abstract, they do, in fact, expect an array. In a sense, even these functions are abstract because they don't explicitly check for the <code class="literal">Array</code> type. They require that the object supports numerical indices and that it has a numerical <code class="literal">length</code> property.</p><p>The takeaway is that, in the overwhelming majority of your days as a Lo-Dash programmer, the distinction between arrays and collections does not matter. Mainly, because the primary<a id="id7" class="indexterm"/> collection type will be an array anyway. In a small <a id="id8" class="indexterm"/>minority of cases, where the distinction does matter, just remember that the array functions have a slightly stricter criteria for what they consider acceptable data.</p></div></div>
<div class="section" title="Iterating over collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec09"/>Iterating over collections</h1></div></div></div><p>Lo-Dash does a lot of<a id="id9" class="indexterm"/> iterating over collections, whether it's done explicitly by the developer, or done implicitly through a higher level Lo-Dash function. Let's take a <a id="id10" class="indexterm"/>look at the basic <code class="literal">forEach()</code> function:</p><div class="informalexample"><pre class="programlisting">var collection = [
    'Lois',
    'Kathryn',
    'Craig',
    'Ryan'
];

_.forEach(collection, function(name) {
    console.log(name);
});
// → 
// Lois
// Kathryn
// Craig
// Ryan</pre></div><p>This code doesn't do much, aside from logging the value of each item in the collection. It does, however, give you a general sense of what iterative functions look like in Lo-Dash. As the name implies, for each element in the array, apply the function callback. There's more than just the current element that's passed to the callback function. We also get the current index.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip01"/>Tip</h3><p><span class="strong"><strong>Downloading the example code</strong></span></p><p>You can download the example code files from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [
    'Timothy',
    'Kelly',
    'Julia',
    'Leon'
];

_.forEach(collection, function(name, index) {
    if (name === 'Kelly') {
        console.log('Kelly Index: ' + index);
        return false;
    }
});
// → Kelly Index: 1</pre></div><p>Returning <code class="literal">false</code> <a id="id11" class="indexterm"/>tells <code class="literal">forEach()</code> that this iteration will be the last. The index, with each iteration, is incremented and passed to the callback function as the second argument.</p><p>The <code class="literal">forEach()</code> function iterates over the collection in the typical left-to-right fashion. If we want the inverse behavior, we can use <a id="id12" class="indexterm"/>the cousin function, <code class="literal">forEachRight()</code>:</p><div class="informalexample"><pre class="programlisting">var collection = [
    'Carl',
    'Lisa',
    'Raymond',
    'Rita'
];

var result = [];

_.forEachRight(collection, function(name) {
    result.push(name);
});
// →
// [
//   "Rita",
//   "Raymond",
//   "Lisa",
//   "Carl"
// ]</pre></div><p>This type of behavior is useful when we're working with sorted collections, as is the case in the preceding code. But, let's say we wanted to render this array data in the DOM in descending order. The preceding code shows that we can render each item in a given iteration. Using the <code class="literal">forEachRight()</code> function <a id="id13" class="indexterm"/>for this scenario has the advantage of not having to reverse-sort the array.</p><p>However, many times this shortcut will not suffice, and you have to sort your collections. We'll take a look at the Lo-Dash functions that assist with sorting next.</p></div>
<div class="section" title="Sorting data"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec10"/>Sorting data</h1></div></div></div><p>In Vanilla JavaScript, the approach to sorting <a id="id14" class="indexterm"/>involves arrays and two methods. The <code class="literal">sort()</code> method<a id="id15" class="indexterm"/> sorts the array in ascending order, using primitive comparison operations between the items. You can customize this behavior by passing <code class="literal">sort()</code>, a <a id="id16" class="indexterm"/>
<span class="strong"><strong>comparator</strong></span> function. For example, you use this callback function to sort an array in descending order. The other <a id="id17" class="indexterm"/>method, <code class="literal">reverse()</code>, simply reverses the order of the array. It's the inverse of the current order, whatever that might be.</p><p>The native array <code class="literal">sort()</code> method sorts the array in-place although you might not want that to happen. Immutable operations reduce side effects because they don't change the original collection. Specifically, you might have requested the API data in a specific order. A region of the UI wants to render this array in a different sort order. Well, you don't want to change the order from what was requested. In this case, it would be better to have a function that returns a new array that contains the items of the original, but in the expected sort order.</p><div class="section" title="Using sortBy()"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec07"/>Using sortBy()</h2></div></div></div><p>The <code class="literal">sortBy()</code> function<a id="id18" class="indexterm"/> is the<a id="id19" class="indexterm"/> Lo-Dash answer to the native <code class="literal">Array.sort()</code> method. Since it's an abstract collection function, it's not limited to arrays. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">_.sortBy('cba').join('');</pre></div><p>While the function works just fine with strings as the input, the output is a sorted array of characters; hence, the call to join them back together. This is because the <code class="literal">sortBy()</code>function always returns an array as the result.</p><p>The <code class="literal">sortBy()</code> function is similar to the native <code class="literal">Array.sort()</code> method, in that it sorts collection items in ascending order by default. Also, similar to the native method, we can pass in a callback function to <code class="literal">sortBy()</code> that'll customize the sorting behavior, as follows:</p><div class="informalexample"><pre class="programlisting">var collection = [
    { name: 'Moe' },
    { name: 'Seymour' },
    { name: 'Harold' }, 
    { name: 'Willie' }
];

_.sortBy(collection, function(item) {
    return item.name;
});</pre></div><p>The preceding <a id="id20" class="indexterm"/>callback function passed to <code class="literal">sortBy()</code> returns the <a id="id21" class="indexterm"/>value of an object property. By doing this, the sorting behavior will compare the property values—in this case, <code class="literal">name</code>—instead of the objects themselves. There's actually a shorter way to achieve the same result:</p><div class="informalexample"><pre class="programlisting">_.sortBy(collection, 'name');</pre></div><p>This is what's referred to as the <span class="strong"><strong>pluck style</strong></span> shorthand<a id="id22" class="indexterm"/> in Lo-Dash terminology. We pass in the name of the property we want to sort the collection by. The value of this property is then plucked from each object in the collection. There's actually a <code class="literal">pluck()</code> function<a id="id23" class="indexterm"/> we'll look at in more depth later on.</p><p>The last trick <code class="literal">sortBy()</code> has up its sleeve takes the pluck shorthand to the next level and allows sorting by multiple property names, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [
    { name: 'Clancy', age: 43 },
    { name: 'Edna', age: 32 },
    { name: 'Lisa', age: 10 },
    { name: 'Philip', age: 10 }
];

_.sortBy(collection, [ 'age', 'name' ]);
// →
// [
//   { name: "Lisa", age: 10 },
//   { name: "Philip", age: 10 },
//   { name: "Edna", age: 32 },
//   { name: "Clancy", age: 43 }
// ]</pre></div><p>The primary determinant of order here is the <code class="literal">age</code> property. If we specify a second property name, this is used to determine the order of elements that have the same primary sort order. It serves as a tie breaker. Here, there are two objects where <code class="literal">age</code> equals <code class="literal">10</code>. Since the <code class="literal">name</code> property is the secondary sort order, this is how these two objects are sorted. Multiple sort properties is a typical use case in web applications, which would require us to write a surprisingly large amount of JavaScript to achieve, if not for this Lo-Dash utility.</p></div><div class="section" title="Maintaining the sort order"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec08"/>Maintaining the sort order</h2></div></div></div><p>Using the <code class="literal">sortBy()</code> function<a id="id24" class="indexterm"/> is a great tool for changing the sort order of an existing collection, especially if we don't want to permanently alter the default sort order of that collection. Other times, however, you'll want to permanently keep a collection sorted. Sometimes, this is actually done for us by the backend API that sends us collections in the form of JSON data.</p><p>In these situations, sorting is easy <a id="id25" class="indexterm"/>because you don't actually have to sort anything. It's already done. The challenge lies in maintaining the sort order. Because, sometimes elements get added to collections in real time. The naive approach to maintain sort order here would be to simply add the new element to the collection then resort it. The Lo-Dash alternative is to figure out the insertion point that will keep the current collection sort order intact. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    'Carl',
    'Gary',
    'Luigi',
    'Otto'
];

var name = 'Luke';

collection.splice(_.sortedIndex(collection, name), 0, name);
// → 
// [
//   "Carl",
//   "Gary",
//   "Luigi",
//   "Luke",
//   "Otto"
// ]</pre></div><p>The new <code class="literal">name</code> variable gets inserted into the second-last position. This is really the only function needed to maintain the order of a sorted collection. The same <code class="literal">splice()</code> array method is used to remove items from the collection, which doesn't disrupt the order. Adding new items is a challenge because of the search that takes place to figure out the insertion index. The <code class="literal">sortedIndex()</code> function<a id="id26" class="indexterm"/> does a binary search on the collection to figure out where the new item fits.</p></div></div>
<div class="section" title="Searching for data"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec11"/>Searching for data</h1></div></div></div><p>Applications don't use entire<a id="id27" class="indexterm"/> collections. Rather, they iterate over a collection subset, or they look for a specific item in the collection. Lo-Dash has a number of functional tools to help the programmer find the data they need.</p><div class="section" title="Filtering collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec09"/>Filtering collections</h2></div></div></div><p>The simplest way to perform <a id="id28" class="indexterm"/>a filter operation on a collection using Lo-Dash is to use the <code class="literal">where()</code> function. This function takes an object argument and will match its properties against each item in the collection, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Moe', age: 47, gender: 'm' },
    { name: 'Sarah', age: 32, gender: 'f' },
    { name: 'Melissa', age: 32, gender: 'f' },
    { name: 'Dave', age: 32, gender: 'm' }
];

_.where(collection, { age: 32, gender: 'f' });
// →
// [
//   { name: "Sarah", age: 32, gender: "f" },
//   { name: "Melissa", age: 32, gender: "f" }
// ]</pre></div><p>The preceding code filters the collection on both the <code class="literal">age</code> and the <code class="literal">gender</code> properties. The query translates to thirty-two year old females. The <code class="literal">Moe</code> object matches with neither property, while the <code class="literal">Dave</code> object matches with the <code class="literal">age</code> property, but not <code class="literal">gender</code>. A good way to think about <code class="literal">where()</code> filtering is that each object property you pass in as the filter will be logical <span class="emphasis"><em>and</em></span> joined together. For example, match the <code class="literal">age</code> <span class="emphasis"><em>and</em></span> the <code class="literal">gender</code> properties.</p><p>The <code class="literal">where()</code> function<a id="id29" class="indexterm"/> is great for its concise syntax and intuitive application to collections. With this simplicity comes a few limitations. First, the property values that we're comparing to each item in the collection must match exactly. Sometimes, we need comparisons a little more exotic than strict equality. Second, the logical <code class="literal">and</code> way that <code class="literal">where()</code> joins query conditions together isn't always desirable. Logical <code class="literal">or</code> conditions are just as common.</p><p>For these types of advanced filtering capabilities, you should turn to the <code class="literal">filter()</code> function. Here's a basic filter operation that's even simpler than the <code class="literal">where()</code> queries:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Sean', enabled: false },
    { name: 'Joel', enabled: true },
    { name: 'Sue', enabled: false },
    { name: 'Jackie', enabled: true }
];

_.filter(collection, 'enabled');
// →
// [
//   { name: "Joel", enabled: true },
//   { name: "Jackie", enabled: true }
// ]</pre></div><p>Since the <code class="literal">enabled</code> property has <a id="id30" class="indexterm"/>
<span class="strong"><strong>truthy</strong></span> values for two objects in this collection, they're <a id="id31" class="indexterm"/>returned in a new array.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note02"/>Note</h3><p>Lo-Dash uses the notion of truthy values everywhere. This simply means that a value will test positive if used in an <code class="literal">if</code> statement or a ternary operator. Values don't need to be of Boolean type and <code class="literal">true</code> to be truthy. An object, an array, a string, a number—these are all truthy values. Whereas null, undefined, and 0— are all false.</p></div></div><p>As mentioned, the <code class="literal">filter()</code> function fills gaps in the <code class="literal">where()</code> function. Unlike <code class="literal">where()</code>,<code class="literal">filter()</code> accepts a callback function that's applied to each item in the collection, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { type: 'shirt', size: 'L' },
    { type: 'pants', size: 'S' },
    { type: 'shirt', size: 'XL' },
    { type: 'pants', size: 'M' }  
];

_.filter(collection, function(item) {
    return item.size === 'L' || item.size === 'M';
});
// →
// [
//   { type: "shirt", size: "L" },
//   { type: "pants", size: "M" }
// ]</pre></div><p>The callback function uses an <code class="literal">or</code> condition to satisfy the <code class="literal">size</code> constraint here—<code class="literal">medium</code> or <code class="literal">large</code>. This is simply not doable with the <code class="literal">where</code> function.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note03"/>Note</h3><p>The <code class="literal">filter()</code> function<a id="id32" class="indexterm"/> accepts an object argument as well. In Lo-Dash terminology, this is called<a id="id33" class="indexterm"/> a <span class="strong"><strong>where style callback</strong></span>. There are many functions, not just <code class="literal">filter()</code>, that accept the filter criteria specified as an object and behave like <code class="literal">where()</code>.</p></div></div><p>Filtering collections<a id="id34" class="indexterm"/> using the <code class="literal">filter()</code> function is good when we know what we're looking for. The callback function gives the programmer enough flexibility to compose elaborate criteria. But sometimes, we don't know what you need from a collection. Instead, you only know what you <span class="emphasis"><em>don't</em></span> need, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [
    { name: 'Ryan', enabled: true },
    { name: 'Megan', enabled: false },
    { name: 'Trevor', enabled: false },
    { name: 'Patricia', enabled: true }
];

_.reject(collection, { enabled: false });
// →
// [
//   { name: "Ryan", enabled: true },
//   { name: "Patricia", enabled: true }
// ]</pre></div><p>You can see here that only <code class="literal">enabled</code> items are returned that are equivalent to doing <code class="literal">_.filter(collection, {enabled: true})</code>,which is a simple inversion of <code class="literal">filter()</code>. Which function you use is a matter of personal preference and the context in which they're used. Go for the one that reads cleaner in your code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note04"/>Note</h3><p><code class="literal">reject()</code> actually <a id="id35" class="indexterm"/>uses the <code class="literal">filter()</code> function internally. It uses the <code class="literal">negate()</code> function<a id="id36" class="indexterm"/> to invert the result of the callback passed to <code class="literal">filter()</code>.</p></div></div></div><div class="section" title="Finding items in collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec10"/>Finding items in collections</h2></div></div></div><p>Sometimes, we <a id="id37" class="indexterm"/>need a specific collection item. Filtering a collection <a id="id38" class="indexterm"/>simply generates a new collection with less items in it. Conversely, finding items in a collection means finding a specific item.</p><p>The function used to find items in a collection is aptly named <code class="literal">find()</code>. This function accepts the same arguments as the <code class="literal">filter()</code> function. You can pass the name of the property as a string, an object filled with property names and values to execute a where style search, or just a plain callback function to match against whatever you want. The following is an example of this:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Derek', age: 37 },
    { name: 'Caroline', age: 35 },
    { name: 'Malcolm', age: 37 },
    { name: 'Hazel', age: 62 } 
];

_.find(collection, { age:37 });
// → { name: "Derek", age: 37 }</pre></div><p>There're actually two<a id="id39" class="indexterm"/> items matching this where style criteria in the <a id="id40" class="indexterm"/>collection—<code class="literal">Derek</code> and <code class="literal">Malcolm</code>. If we were to run this code though, we'd see that only <code class="literal">Derek</code> is returned. That's because <code class="literal">find()</code> returns as soon as a match is found. Collection order matters when searching for items in collections. It doesn't take into consideration duplicate values.</p><p>Let's look in the other direction and see what we find. Using the same collection and the same search criteria, you can search in the opposite direction:</p><div class="informalexample"><pre class="programlisting">_.findLast(collection, { age:37 });
// → { name: "Malcolm", age: 37 }</pre></div><p>While <code class="literal">find()</code> searches for the first occurrence of the matching item in the collection, <code class="literal">findLast()</code> searches for the last occurrence. This is useful when we're working with sorted collections—you can better optimize your linear searches.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note05"/>Note</h3><p>While Lo-Dash heavily optimizes the <code class="literal">while</code> loops used when iterating over collections, searches executed using functions <a id="id41" class="indexterm"/>such as <code class="literal">find()</code> are linear. It's important to remember that it's up to the programmer using Lo-Dash to consider the performance implications of their unique application data. Lo-Dash functions are optimized for the generic common case, they're not going to magically make your code faster by virtue of using them. They're tools to <span class="emphasis"><em>assist</em></span> the programmer to make incredibly high-performance code.</p></div></div></div></div>
<div class="section" title="Slicing collections into smaller pieces"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec12"/>Slicing collections into smaller pieces</h1></div></div></div><p>So far we've seen how <a id="id42" class="indexterm"/>collections can be filtered, creating a new smaller collection. Lo-Dash supplies you with a number of functions that take existing arrays and produce one or more smaller arrays. For example, you might want a portion of the first part of any array—or a portion of the last part. Arrays can be divided into chunks of smaller arrays that are useful for batched processing. You can also use Lo-Dash array tools to remove duplicates, thus ensuring the uniqueness of your array.</p><div class="section" title="First and last collection portions"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec11"/>First and last collection portions</h2></div></div></div><p>With native JavaScript arrays, you<a id="id43" class="indexterm"/> can slice off the first<a id="id44" class="indexterm"/> portion of an array using the <code class="literal">slice()</code> array method. Lo-Dash provides abstractions on top of the native array <code class="literal">slice()</code> method<a id="id45" class="indexterm"/> that make it a little easier for the developer to write intuitive code—this isn't always the case with the native array approach. Further, the Lo-Dash <code class="literal">take()</code> function<a id="id46" class="indexterm"/> operates on collections, so it'll work with both arrays and strings, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var array = [ 
    'Steve',
    'Michelle',
    'Rebecca',
    'Alan'
];

_.take(array, 2);
// → [ "Steve", "Michelle" ]

_.take('lodash', 2).join('');
// → "lo"</pre></div><p>There's a difference in the output when using <code class="literal">take()</code> on arrays and strings. When applying it to an array, it generates a new array, a subset of the original. However, when applying <code class="literal">take()</code> to strings, it returns a new array of individual characters. The preceding code will return <code class="literal">[ 'l', 'o' ]</code>. That's probably not what we're after most of the time, so we'll just join these characters back together with an empty string.</p><p>We can slice off the last portions of collections and strings <a id="id47" class="indexterm"/>using the <code class="literal">takeRight()</code> function. Using the same array and string, you can run the following code to get the last portions of the collections:</p><div class="informalexample"><pre class="programlisting">_.takeRight(array, 2);
_.takeRight(string, 4).join('');</pre></div><p>The resulting array looks like <code class="literal">[ 'Rebecca', 'Alan']</code>. The resulting string looks like <code class="literal">'dash'</code>.</p><p>Applying <code class="literal">take()</code> to a collection <a id="id48" class="indexterm"/>without any arguments will slice the first item. Likewise, applying <code class="literal">takeRight()</code> without any arguments slices off the last item. In both the cases, the returned value is a one item array, not the item itself. If you're just after the first or last collection items, use the <code class="literal">first()</code> and <code class="literal">last()</code> Lo-Dash functions respectively.</p></div><div class="section" title="Splitting collections into chunks"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec12"/>Splitting collections into chunks</h2></div></div></div><p>Sometimes, we're <a id="id49" class="indexterm"/>faced with large collections. Really large collections. Especially<a id="id50" class="indexterm"/> when using API data, the frontend doesn't always have control over the size of the dataset that's returned. When the API does return a mountain of data, there's a good chance that our code that processes it will lock the UI. We can't exactly say give me less data to work with so that the UI doesn't freeze. Freezing the UI is also unacceptable.</p><p>Lo-Dash iterates through collections very efficiently. It doesn't, however, have any control over the potentially expensive operations carried out by your code. And this is what causes the UI to freeze – not the size of the collection by itself, and not by executing an expensive operation once – it's the two factors combined together that become lethal for UI responsiveness.</p><p>The <code class="literal">chunk()</code> function<a id="id51" class="indexterm"/> is an easy way to split the processing of a really large collection into several smaller tasks. This gives the chance for the UI to update—render the pending DOM updates and processes the pending events. The usage of this function can be seen in the following code:</p><div class="informalexample"><pre class="programlisting">function process(chunks, index) {
    var chunk = chunks[index];
    if (_.isUndefined(chunk)) {
        return;
    };  
    console.log('doing expensive work ' + _.last(chunk));
    _.defer(_.partial(process, chunks, ++index));
}

var collection = _.range(10000),
    chunks = _.chunk(collection, 50);

process(chunks, 0);
// → 
// doing expensive work 49
// doing expensive work 99
// doing expensive work 149</pre></div><p>If the preceding code is a bit of a turn off, don't worry. There're a few new concepts introduced here that you might find confusing. Let's start by explaining at a high level what the code is actually doing. A large collection is created and it's split into chunks of smaller collections. The <code class="literal">process()</code> function<a id="id52" class="indexterm"/> does some work with each chunk, then calls itself again to process the next chunk, until there are no chunks left.</p><p>The collection itself is generated using <a id="id53" class="indexterm"/>the <code class="literal">range()</code> function, with <code class="literal">10000</code> integers in it. It's not the content that's important, but rather, the large size. The <code class="literal">chunk()</code> function is used to split the large collection into smaller ones. We specify the size we want each chunked collection to be and in this case, we get 20 smaller collections with 50 items each. The processing work is kicked off by the call to <code class="literal">process(chunks, 0)</code>. The second argument is the first chunk to begin with.</p><p>The <code class="literal">process()</code> function<a id="id54" class="indexterm"/> itself grabs the next chunk to process based on the <code class="literal">index</code> <a id="id55" class="indexterm"/>argument. If the chunk is undefined, it means that the end has been reached and there are no more chunks to process. Otherwise, we can start doing expensive processing on the chunk, as illustrated in the example with the <code class="literal">console.log()</code> call. Finally, the <code class="literal">defer()</code> function will start processing the next chunk. The reason we're using <code class="literal">defer()</code> is so that the call stack has a chance to clear, and the DOM operations have a <a id="id56" class="indexterm"/>chance to run. If we don't do this, there wouldn't be any point in using <code class="literal">chunk()</code> to split the processing. The <code class="literal">defer()</code> function<a id="id57" class="indexterm"/> expects a callback, and we make one<a id="id58" class="indexterm"/> using <code class="literal">partial()</code>, which creates a new function, with arguments already supplied to it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note06"/>Note</h3><p>The <code class="literal">defer()</code> and <code class="literal">partial()</code> functions are covered in much more depth in <a class="link" href="ch03.html" title="Chapter 3. Working with Functions">Chapter 3</a>, <span class="emphasis"><em>Working with Functions</em></span>.</p></div></div><p>How do we know what size to make our array chunks? In the previous code, we chose <code class="literal">50</code> as the chunk size. But is that an arbitrary decision, or is it based on the typical datasets used in the application? The short answer is that we have to tinker a little and optimize for the common case. This might mean doing something such as figuring out the chunk size based on a percentage of the overall collection size, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = _.range(10),
    size = Math.ceil(0.25 * collection.length);
_.chunk(collection, size);
// → 
// [
//   [ 0, 1, 2 ],
//   [ 3, 4, 5 ],
//   [ 6, 7, 8 ],
//   [ 9 ]
// ]</pre></div><p>The chunk size here turns out to be <code class="literal">3</code>. The actual size is 2.5, but you take the ceiling of that since there's no such thing as 2.5 collection elements. Besides, what you're interested in is not the exactness of the chunk size, but rather, the proximity to the 25 percent.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note07"/>Note</h3><p>You might have noticed that <code class="literal">3</code> doesn't divide evenly into 10. The <code class="literal">chunk()</code> function is smart enough to not leave out items. Any remaining items that do not fill the chunk size are still included.</p></div></div></div><div class="section" title="Building unique arrays"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec13"/>Building unique arrays</h2></div></div></div><p>Collections sometimes <a id="id59" class="indexterm"/>have unwanted duplicates in them. This could be a result of <a id="id60" class="indexterm"/>the API data itself that contains the duplicates, or as a side effect of other computations you're performing in the frontend. Regardless of the cause, Lo-Dash provides the tools necessary to quickly generate unique collections.</p><p>The <code class="literal">uniq()</code> function<a id="id61" class="indexterm"/> takes a collection as the input and generates a new collection as output, with any duplicates removed:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    'Walter',
    'Brenda',
    'Arthur',
    'Walter'
];

_.uniq(collection);
// → [ "Walter", "Brenda", "Arthur" ]</pre></div><p>By default, the potential duplicates are compared against one another using the strict equality operator. In the preceding collection, the duplicate is found and removed because of <code class="literal">'Walter' === 'Walter'</code>. You can specify, in more detail, how you want <code class="literal">uniq()</code> to compare values. For example, if we had a collection of objects and we only want unique objects based on the <code class="literal">name</code> property, we could write <code class="literal">_.uniq(collection, 'name')</code>. The function also accepts a callback, which is used to compute the values before they're compared. This is useful in situations where the uniqueness of an object isn't so straightforward, as in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { first: 'Julie', last: 'Sanders' },
    { first: 'Craig', last: 'Scott' },
    { first: 'Catherine', last: 'Stewart' },
    { first: 'Julie', last: 'Sanders' },
    { first: 'Craig', last: 'Scott' },
    { first: 'Janet', last: 'Jenkins' }
];

_.uniq(collection, function(item) {
    return item.first + item.last;
});
// →
// [
//   { first: "Julie", last: "Sanders" },
//   { first: "Craig", last: "Scott" },
//   { first: "Catherine", last: "Stewart" },
//   { first: "Janet", last: "Jenkins" }
// ]</pre></div><p>This code ensures that the <a id="id62" class="indexterm"/>uniqueness of each object in the collection is<a id="id63" class="indexterm"/> based on the full name. There's no full name property, perhaps it's not needed anywhere else in the application. So, the <code class="literal">uniq()</code> function can just construct one on-the-fly, which is used for the sole purpose of validating this constraint.</p></div></div>
<div class="section" title="Transforming collections"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec13"/>Transforming collections</h1></div></div></div><p>Lo-Dash has a number of<a id="id64" class="indexterm"/> tools for transforming collections into new data structures. Additionally, there are tools that can take two or more collections and combine them into a single collection. These functions focus on the most common, yet most burdensome programming tasks faced by frontend developers. Instead of focusing on boilerplate collection transformations, you can get back to making a great application—users don't care about awesome compact code as much as you do.</p><div class="section" title="Grouping collection items"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec14"/>Grouping collection items</h2></div></div></div><p>Items in collections are <a id="id65" class="indexterm"/>sometimes grouped implicitly. For example, let's say there's a <code class="literal">size</code> property for a given class of objects whose allowable values are <code class="literal">'S'</code>, <code class="literal">'M'</code>, or <code class="literal">'L'</code>. The code in your frontend application might need to round up the items that contain these various groups for display purposes. Rather than writing our own code, we'll let the <code class="literal">groupBy()</code> function handle the intricacies of constructing such a grouping:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Lori', size: 'S' },
    { name: 'Johnny', size: 'M' },
    { name: 'Theresa', size: 'S' },
    { name: 'Christine', size: 'S' }
];

_.groupBy(collection, 'size');
// →
// {
//   S: [
//     { name: "Lori", size: "S" },
//     { name: "Theresa", size: "S" },
//     { name: "Christine", size: "S" }
//   ],
//   M: [
//     { name: "Johnny", size: "M" }
//   ]
// }</pre></div><p>The <code class="literal">groupBy()</code> function, as you<a id="id66" class="indexterm"/> might have noticed by now, doesn't return a collection—it takes a collection as the input, but transforms it into an object. This object that <code class="literal">groupBy()</code> returns contains the original items of the input collection, they're just organized differently. The properties of the object are the values you want to group by. A majority of collection items in the preceding code will reside in the <code class="literal">S</code> property.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note08"/>Note</h3><p>You'll also see that transformative functions such as <code class="literal">groupBy()</code> don't actually modify the items themselves—just the collections they're in. That's why, in the resulting object from the preceding code, each item still has its <code class="literal">size</code> property, despite not really being needed.</p></div></div><p>When you pass in the <a id="id67" class="indexterm"/>property name as a string, <code class="literal">groupBy()</code> will use a pluck style callback to grab the value of that property from each item in the collection. The unique property values form the keys of the group object. As is often the case, object properties aren't clear-cut and need to be computed at runtime. In the context of grouping items, function callbacks can be used to group collection items in cases where grouping isn't a matter of a simple comparison, as in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Andrea', age: 20 },    
    { name: 'Larry', age: 50 },  
    { name: 'Beverly', age: 67 },
    { name: 'Diana', age: 39 }
];

_.groupBy(collection, function(item) {
    return item.age &gt; 65 ? 'retired' : 'working';
});
// →
// {
//   working: [
//     { name: "Andrea", age: 20 },
//     { name: "Larry", age: 50 },
//     { name: "Diana", age: 39 }
//   ],
//   retired: [
//     { name: "Beverly", age: 67 }
//   ]
// }</pre></div><p>Rather than test for equality, this callback function tests for approximations. That is, anything greater than <code class="literal">65</code> in the <code class="literal">age</code> property is assumed to be retired. And we return that string as the group label. Keep in mind that it's best if these callback functions return primitive types for the keys. For any other values, the string <code class="literal">working</code> is returned. What's nice about these callback <a id="id68" class="indexterm"/>functions is that they can be used to quickly generate reports on the API data you're working with. The preceding example illustrates this with a one-liner callback function passed to <code class="literal">groupBy()</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note09"/>Note</h3><p>Although the <code class="literal">groupBy()</code> function<a id="id69" class="indexterm"/> will accept a where style object as the second parameter, this might not be what you're after. For example, if an item in the collection passes the test, it'll end up in the <code class="literal">true</code> group. Otherwise, it's a part of the <code class="literal">false</code> group. Be careful before going too far down the road with a pluck or where style callback—they might not do what you expect. Fiddle around and get quick results to sanity check your approach.</p></div></div></div><div class="section" title="Counting collection items"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec15"/>Counting collection items</h2></div></div></div><p>Lo-Dash helps us find the <a id="id70" class="indexterm"/>minimum and maximum values of a collection. We might not need any help if we're working with a lot of arrays that contain only numbers. If that's the case, <code class="literal">Math.min()</code> is our friend. In nearly any other scenario, the <code class="literal">min()</code> and <code class="literal">max()</code> functions are the way to go, if for no other reason than the callback support. Let's take a look at the following example:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Douglas', age: 52, experience: 5 }, 
    { name: 'Karen', age: 36, experience: 22 },
    { name: 'Mark', age: 28, experience: 6 }, 
    { name: 'Richard', : age: 30, experience: 16 }
];

_.min(collection, 'age'),
// → { name: "Mark", age: 28, experience: 6 }

_.max(collection, function(item) {
    return item.age + item.experience;
});
// → { name: "Karen", age: 36, experience: 22 }</pre></div><p>The first call is to <code class="literal">min()</code> and it gets a string argument—the name of the property we want the minimum value of in the collection. This uses the pluck style callback shorthand and produces concise code where you know the property you're working with. The second call in the preceding code is to <code class="literal">max()</code>. This function supports the same callback shorthand as <code class="literal">min()</code>, but here, there's no pre-existing property value for you to work with. Since what you want is the <code class="literal">age</code> property plus the <code class="literal">experience</code> property, the callback function supplied to <code class="literal">max()</code> computes this for us and figures out the maximum.</p><p>Note that the <code class="literal">min()</code> and <code class="literal">max()</code> functions <a id="id71" class="indexterm"/>return the actual collection item and not the minimum <a id="id72" class="indexterm"/>or maximum value. This makes sense because we're probably going to want to do something with the item itself, and not just the min/max value.</p><p>Beyond locating the<a id="id73" class="indexterm"/> minimum and maximum values of collections is finding the actual size of collections. This is easy if you're working with arrays because they already have the built-in <code class="literal">length</code> property. It is the same with strings. However, objects don't always have a <code class="literal">length</code> property. The Lo-Dash <code class="literal">size()</code> function tells you how many keys an object has, which is the intuitive behavior you'd expect from an object, but isn't there, by default. Take a look at the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Gloria' },
    { name: 'Janice' },
    { name: 'Kathryn' },
    { name: 'Roger' }
];  

var first = _.first(collection);
_.size(collection); // → 4
_.size(first); // → 1
_.size(first.name); // → 6</pre></div><p>The first call to <code class="literal">size()</code> returns<a id="id74" class="indexterm"/> the length of the collection. It'll look for a <code class="literal">length</code> property, and if the collection has one, this is the value that's returned. Since it's an array, the <code class="literal">length</code> property exists, and has a value of <code class="literal">4</code>. This is what's returned. The <code class="literal">first</code> variable is an object, so it has no <code class="literal">length</code> property. It'll count the number of keys in the object and return this value—in this case, <code class="literal">1</code>. Lastly, <code class="literal">size()</code> is called on a string. This has a length value of <code class="literal">6</code>.</p><p>We can see from all three uses of <code class="literal">size()</code> that there's little guessing involved. Where the default JavaScript behavior is inconsistent and unintuitive, Lo-Dash provides a single function to address common use cases.</p></div><div class="section" title="Flattening and compacting"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec16"/>Flattening and compacting</h2></div></div></div><p>Arrays can nest to<a id="id75" class="indexterm"/> arbitrary depth <a id="id76" class="indexterm"/>and sometimes contain falsey values that are of no practical use. Lo-Dash has functions to deal with both these situations. For example, a component of our UI might get passed as an array that has arrays nested inside it. But our component doesn't make use of this structure, and it's, in fact, more of a hindrance than it is helpful. We can <span class="emphasis"><em>flatten</em></span> the array to extract and throw away the unnecessary structure your component does not need, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { employer: 'Lodash', employees: [
        { name: 'Barbara' },
        { name: 'Patrick' },
        { name: 'Eugene' }
    ]}, 
    { employer: 'Backbone', employees: [
        { name: 'Patricia' },
        { name: 'Lillian' },
        { name: 'Jeremy' }
    ]}, 
    { employer: 'Underscore', employees: [
        { name: 'Timothy' },
        { name: 'Bruce' },
        { name: 'Fred' }
    ]}  
];  
var employees = _.flatten(_.pluck(collection, 'employees'));

_.filter(employees, function(employee) {
    return (/^[bp]/i).test(employee.name);
});
// → 
// [
//   { name: "Barbara" },
//   { name: "Patrick" },
//   { name: "Patricia" },
//   { name: "Bruce" }
// ]</pre></div><p>Of course, we don't<a id="id77" class="indexterm"/> actually alter the structure of the original collection, we build a<a id="id78" class="indexterm"/> new one on the fly, better suited for the current context. In the preceding example, the collection consists of <code class="literal">employer</code> objects. However, our component is more concerned with the <code class="literal">employee</code> objects. So, the first step is to pluck those out of their objects using <code class="literal">pluck()</code>. This gets us an array of arrays. Because what we're actually plucking is the <code class="literal">employee</code> array from each <code class="literal">employer</code> array.</p><p>The next step is to flatten this <code class="literal">employee</code> array into an array of <code class="literal">employee</code> objects, which <code class="literal">flatten()</code> handles easily. The point of doing all this, which isn't really a lot, is now we have an easy structure to filter. Particularly, this code uses the flattened collection structure to filter out the employee names that start with <code class="literal">b</code> or <code class="literal">p</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note10"/>Note</h3><p>There's another flatten function<a id="id79" class="indexterm"/> called <code class="literal">flattenDeep()</code>, which goes to arbitrary nested array depths to create a flattened structure. This is handy when you need to go beyond the one level of nesting that <code class="literal">flatten()</code> looks in. However, it's not a good idea to flatten arrays of unknown size and depth, simply due to the performance implications. There's a good chance that large array structures can lock the UI for your users.</p></div></div><p>A close <a id="id80" class="indexterm"/>cousin <a id="id81" class="indexterm"/>to <code class="literal">flatten()</code> is the <code class="literal">compact()</code> function, often used in <a id="id82" class="indexterm"/>conjunction with one another. We'll use<a id="id83" class="indexterm"/> <code class="literal">compact()</code> to remove the falsey values from a flattened array, to just use it on a plain array that already exists, or just to take out the falsey values before it's filtered. This is shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Sandra' },
    0,  
    { name: 'Brandon' },
    null,
    { name: 'Denise' },
    undefined,
    { name: 'Jack' }
    ];
var letters = [ 's', 'd' ],
    compact = _.compact(collection),
    result = [];

_.each(letters, function(letter) {
    result = result.concat(
        _.filter(compact, function(item) {
            return _.startsWith(item.name.toLowerCase(), letter);
        })
    );  
});
// → 
// [
//   { name: "Sandra" },
//   { name: "Denise" }
// ]</pre></div><p>We can see that this collection has some values in it that we clearly don't want to deal with. But, the hopefully-not-so-sad reality is that doing frontend development in a dynamically-typed language with backend data means that you have no control over a lot of sanity checking. All that the preceding code does with the <code class="literal">compact()</code> function is remove any of the falsey values from the collection. These are things such as <code class="literal">0</code>, <code class="literal">null</code>, and <code class="literal">undefined</code>. In fact, this code wouldn't even run without compacting the collection since it makes the implicit assumption about the <code class="literal">name</code> property being defined on each object in the collection.</p><p>Not only can <code class="literal">compact()</code> be used for safety purposes—removing items that violate contracts—but also for performance purposes. You'll see that the preceding code searches the collection, <span class="emphasis"><em>inside</em></span> a loop. Therefore, any items removed from the collection <span class="emphasis"><em>before</em></span> the outer loop is entered, the greater the performance gain.</p><p>Going back to <a id="id84" class="indexterm"/>the preceding code, there's one issue that can catch Lo-Dash<a id="id85" class="indexterm"/> programmers off guard. Let's say that we don't want anything that doesn't have a <code class="literal">name</code> property. Well, we're only shaving off falsey values—objects without <code class="literal">name</code> properties are still valid, and the <code class="literal">compact()</code> function lets them through. For example, <code class="literal">{}</code> doesn't have a <code class="literal">name</code> property, and neither does <code class="literal">2</code>, but they're both allowed through in the previous approach. A safer approach might be to pluck then compact, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Sandra' },
    {}, 
    { name: 'Brandon' },
    true,
    { name: 'Denise' },
    1,  
    { name: 'Jack' }
    ];
var letters = [ 's', 'd' ],
    names = _.compact(_.pluck(collection, 'name')),
    result = [];

_.each(letters, function(letter) {
    result = result.concat(
        _.filter(names, function(name) {
            return _.startsWith(name.toLowerCase(),
                                letter);
        })  
    );  
});</pre></div><p>Here, we're faced with a similar filtering task but with a slightly different collection. It has objects that will cause our code to fail because they don't have a name key with a string value. The quick-and-dirty workaround is to pluck the <code class="literal">name</code> property from all items in the collection before performing the <code class="literal">compact()</code> call. This will yield undefined values for objects that don't have a <code class="literal">name</code> property. But that's exactly what we're after, since <code class="literal">compact()</code> has no trouble excluding these values. Moreover, our code is actually simpler now. The caveat being, sometimes the simple approach doesn't work. Sometimes, you need the full object and not just the name. Cheat only when you can get away with it.</p></div><div class="section" title="Validating some or all items"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec17"/>Validating some or all items</h2></div></div></div><p>Sometimes, sections of our <a id="id86" class="indexterm"/>code hinge on the validity of all, or some collection items. Lo-Dash provides you with two complementary tools for the job. The <code class="literal">every()</code> function<a id="id87" class="indexterm"/> returns <code class="literal">true</code> if the callback returns <code class="literal">true</code> for every item in the collection. The <code class="literal">some()</code> function<a id="id88" class="indexterm"/> is a lazy brother of <code class="literal">every()</code>—it gives and returns <code class="literal">true</code> as soon as the callback returns <code class="literal">true</code> for an item, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Jonathan' },
    { first: 'Janet' },
    { name: 'Kevin' },
    { name: 'Ruby' }
];

if (!_.every(collection, 'name')) {
    return 'Missing name property';
}
// → "Missing name property"</pre></div><p>This code checks every item in the collection for a <code class="literal">name</code> property before doing anything with it. Since one of the items is using an incorrect property name, the code will return early. The code that runs below the <code class="literal">if</code> statement can assume that each item has a <code class="literal">name</code> property.</p><p>On the other hand, we might only want to know whether <span class="emphasis"><em>any</em></span> items have a necessary value. You can use this technique to greatly increase performance. For example, say that you have a loop that performs expensive operations on each collection item. You can do a <a id="id89" class="indexterm"/>
<span class="strong"><strong>preflight check</strong></span>, which is relatively inexpensive, to determine whether the expensive loop is worth running. An example for this is as follows:</p><div class="informalexample"><pre class="programlisting">var collection = [ 
    { name: 'Sean' },
    { name: 'Aaron' },
    { name: 'Jason' },
    { name: 'Lisa' }
];
if (_.some(collection, 'name')) {
    // Perform expensive processing...
}</pre></div><p>If the <code class="literal">some()</code> call makes it all the way through the collection without any <code class="literal">true</code> callback return values, it means that we can skip the more expensive processing. For example, if we have a potentially large collection and we need to filter it using some nontrivial comparison operators, perhaps some function calls as well, the overhead really starts to add up. Using <code class="literal">some()</code> is a <a id="id90" class="indexterm"/>cheap way to avoid this heavy processing if it's needless.</p></div><div class="section" title="Unions, intersections, and differences"><div class="titlepage"><div><div><h2 class="title"><a id="ch01lvl2sec18"/>Unions, intersections, and differences</h2></div></div></div><p>The last section of this<a id="id91" class="indexterm"/> chapter looks at Lo-Dash functions that compare two or more arrays and yield a resulting array. In a way, we're combining several collections into a single collection. The <code class="literal">union()</code> function<a id="id92" class="indexterm"/> concatenates collections, with duplicate values removed. The <code class="literal">intersection()</code> function<a id="id93" class="indexterm"/> builds a collection with values common to all the provided collections. Lastly, the <code class="literal">xor()</code> function<a id="id94" class="indexterm"/> builds a collection that contains the differences between all provided collections. It's kind of like the inverse of <code class="literal">intersection()</code>.</p><p>You can use the <code class="literal">union()</code> function when there are several overlapping collections that contain similar items—possibly the same items. Rather than iterate through each collection individually, it's easier to combine the collections, while at the same time removing duplicates, as you can see in the following code:</p><div class="informalexample"><pre class="programlisting">var css = [ 
    'Philip',
    'Donald',
    'Mark'
];  
var sass = [ 
    'Gary',
    'Michelle',
    'Philip'
];  
var less = [ 
    'Wayne',
    'Ruth',
    'Michelle'
];

_.union(css, sass, less);
// →
// [
//   "Philip",
//   "Donald",
//   "Mark",
//   "Gary",
//   "Michelle",
//   "Wayne",
//   "Ruth"
// ]</pre></div><p>This code takes three arrays <a id="id95" class="indexterm"/>and transforms them into a single array. You can see in the resulting array that there's no overlap. That is, any items that exist in more than one of the input arrays are only included in the resulting array once. Let's see what the overlap looks like using <code class="literal">intersection()</code>:</p><div class="informalexample"><pre class="programlisting">var css = [ 
    'Rachel',
    'Denise',
    'Ernest'
];  

var sass = [ 
    'Lisa',
    'Ernest',
    'Rachel'
];  

var less = [ 
    'Ernest',
    'Rachel',
    'William'
];

_.intersection(css, sass, less);
// → [ "Rachel", "Ernest" ]</pre></div><p>Here, the intersection is <code class="literal">Ernest</code> and <code class="literal">Rachel</code>, since these strings exist in all three collections that were passed into <code class="literal">intersection()</code>. Now it's time to look at comparing the differences between two collections using <code class="literal">xor()</code>:</p><div class="informalexample"><pre class="programlisting">var sass = [ 
    'Lisa',
    'Ernest',
    'Rachel'
];
var less = [ 
    'Ernest',
    'Rachel',
    'William'
];

return _.xor(sass, less);
// → [ "Lisa", "William" ]</pre></div><p>Passing these two arrays to <code class="literal">xor()</code> will <a id="id96" class="indexterm"/>generate a new array that contains the difference between the two. In this case, the difference is <code class="literal">Lisa</code> and <code class="literal">William</code>. Everything else is the intersection.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note11"/>Note</h3><p>The <code class="literal">xor()</code> function <a id="id97" class="indexterm"/>accepts an arbitrary number of collections to compare with. Exercise caution, however, when comparing more than two collections. The most common case is to compare two collections to figure out the difference between the two. Going beyond that is venturing into set theory, and you might not get the results you'd expect.</p></div></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch01lvl1sec14"/>Summary</h1></div></div></div><p>This chapter introduced you to the concept of a collection and how they can be compared to arrays. Lo-Dash treats collections as an abstract concept—all JavaScript arrays are collections, but not all collections are arrays. We were introduced to the concept of iterating over collections using the tools provided by Lo-Dash—a fundamental concept in applicative programming and will be touched upon frequently throughout this book.</p><p>Collections can be filtered and items can be fetched from the collection. Lo-Dash also gives you the tools needed to transform collections into other structures you need when implementing frontend UI components.</p><p>We've been given a taste of some common themes in Lo-Dash programming—like the idea that callback functions are central to almost everything, and the various shorthands that can save on coding effort, such as the pluck and where callbacks. Now it's time to look at how Lo-Dash works with objects, and the various functions at our disposal there, which will be covered in the next chapter.</p></div></body></html>