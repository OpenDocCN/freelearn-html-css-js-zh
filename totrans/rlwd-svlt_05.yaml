- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: Custom Events with Actions
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 带有动作的定制事件
- en: Actions are one of the most powerful features of Svelte.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是 Svelte 最强大的功能之一。
- en: They are a lightweight alternative to a component that encapsulates logic and
    data into a reusable unit. They help us reuse the same logic on different elements.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 它是封装逻辑和数据到可重用单元的组件的轻量级替代品。它们帮助我们在不同元素上重用相同的逻辑。
- en: While components have life cycle methods such as `onMount` and `onDestroy` that
    run when all the elements within the component are added to or removed from the
    DOM, actions are designed to handle the logic for individual elements, running
    only when that specific element is added to or removed from the DOM.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然组件具有生命周期方法，如 `onMount` 和 `onDestroy`，这些方法在组件内的所有元素添加到或从 DOM 中移除时运行，但动作被设计来处理单个元素的逻辑，仅在特定元素添加到或从
    DOM 中移除时运行。
- en: While components can receive and react to prop changes, you can pass data to
    actions from a parent component to a child component. The actions will react when
    the data is changed and you can specify how the action should react when that
    data changes.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然组件可以接收并响应属性变化，但你也可以从父组件向子组件传递数据到动作。当数据发生变化时，动作会做出反应，并且你可以指定动作在数据变化时应该如何反应。
- en: Actions are simple yet amazingly versatile. You can use them for various things.
    In this and the following chapters, we are going to explore some of the use cases
    of actions.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 动作简单却非常灵活。你可以用它们做很多事情。在本章和下一章中，我们将探讨动作的一些用例。
- en: One of the many use cases of actions is to manage elements’ event listeners.
    Event listeners are very common in web applications as they allow us to implement
    specific behaviors in response to user actions. This makes our application more
    interactive and dynamic. So, it will be interesting to see how Svelte actions
    can be used to help us manage event listeners.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 动作的一个许多用途案例是管理元素的监听器。事件监听器在 Web 应用程序中非常常见，因为它们允许我们针对用户操作实现特定的行为。这使得我们的应用程序更加互动和动态。因此，将很有趣地看到
    Svelte 动作如何帮助我们管理事件监听器。
- en: In this chapter, we will start by looking at how we can use actions to help
    manage event listeners for elements. We will follow that up with examples and
    exercises to reinforce the idea.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先探讨如何使用动作帮助管理元素的监听器。我们将通过示例和练习来加强这一概念。
- en: 'This chapter includes sections on the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包括以下内容：
- en: Managing event listeners with actions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动作管理事件监听器
- en: Creating custom events with actions
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用动作创建自定义事件
- en: Technical requirements
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You can find the projects of the chapter here: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里找到本章的项目：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05)
- en: Defining actions
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义动作
- en: Before we start to talk about using Svelte actions to create custom events,
    let’s quickly recap how to define an action in Svelte.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始讨论如何使用 Svelte 动作创建自定义事件之前，让我们快速回顾一下如何在 Svelte 中定义动作。
- en: 'In Svelte, an action is nothing but a function that follows an action contract.
    This means if a function follows a specific function signature, it is considered
    an action. Here is the function signature of an action:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Svelte 中，动作不过是一个遵循动作合约的函数。这意味着如果一个函数遵循特定的函数签名，它就被认为是动作。以下是动作的函数签名：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: It is a function that optionally returns an object that has a `destroy` method.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个可选返回具有 `destroy` 方法的对象的函数。
- en: In this case, since the `action` function follows the action contract, it is
    a Svelte action.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于 `action` 函数遵循动作合约，它是一个 Svelte 动作。
- en: 'To use the Svelte action on an element, you can use the `use:` directive:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要在元素上使用 Svelte 动作，你可以使用 `use:` 指令：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Here, we used the Svelte action named `action` on the `div` element.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们在 `div` 元素上使用了名为 `action` 的 Svelte 动作。
- en: So, what will happen to the `div` element with a Svelte action?
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，带有 Svelte 动作的 `div` 元素会发生什么？
- en: 'When the `<div>` element is mounted to the DOM, Svelte will call the `action`
    function with the reference to the `<``div>` element:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `<div>` 元素挂载到 DOM 上时，Svelte 将使用 `<div>` 元素的引用调用 `action` 函数：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the element is removed from the DOM, Svelte will call the `destroy` method
    from the object returned from calling the `action` function:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当元素从 DOM 中移除时，Svelte 将调用从调用 `action` 函数返回的对象中的 `destroy` 方法：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can customize the behavior of a Svelte action by using parameters. We can
    pass in an extra parameter to the `action` function:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用参数来自定义 Svelte 动作的行为。我们可以向 `action` 函数传递一个额外的参数：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, you can add another method to the returning object, `update`, which will
    be called when the value of the parameter changes:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以向返回的对象添加另一个方法，`update`，当参数的值发生变化时将被调用：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'To pass in an additional parameter, you can specify it in a similar syntax
    as the `value` attribute:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 要传递一个额外的参数，你可以使用与 `value` 属性类似的语法来指定它：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Now that we know how to use and define an action in Svelte, let’s take a look
    at our first use case of actions.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经知道了如何在 Svelte 中使用和定义动作，让我们看看动作的第一个用例。
- en: Reusing DOM event logic with custom events
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用自定义事件重用 DOM 事件逻辑
- en: 'Before we start talking directly about actions, let’s look at an example of
    using the `mousedown` and `mouseup` events to create a long-press behavior. We
    shall see how this simple example will lead us on to Svelte actions:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们直接讨论动作之前，让我们看看如何使用 `mousedown` 和 `mouseup` 事件来创建长按行为的一个例子。我们将看到这个简单的例子将如何引导我们进入
    Svelte 动作：
- en: '[PRE7]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In the preceding example, we tried to implement a long-press behavior in a button.
    The idea is to press and hold the button for more than two seconds and then perform
    some action. As we detect it’s a long press, we print `'long press!'` into the
    console.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，我们尝试在按钮中实现长按行为。想法是按住按钮超过两秒钟，然后执行某些操作。当我们检测到是长按时，我们在控制台中打印 `'long press!'`。
- en: 'To implement the long-press behavior, I attached two event listeners: `mousedown`
    and `mouseup`. The two event listeners work together. `mousedown` starts counting
    down using `setTimeout` for two seconds, and `mouseup` clears the countdown using
    `clearTimeout`. If the user did not hold onto the button for long enough, the
    timeout would not be triggered and it would not be considered a long press. Note
    that to coordinate the timers between the two event listeners, the `timer` variable
    is shared across the event listeners.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现长按行为，我附加了两个事件监听器：`mousedown` 和 `mouseup`。这两个事件监听器协同工作。`mousedown` 使用 `setTimeout`
    开始计时两秒钟，而 `mouseup` 使用 `clearTimeout` 清除计时。如果用户没有足够长时间地按住按钮，超时就不会被触发，就不会被视为长按。请注意，为了在两个事件监听器之间协调计时器，`timer`
    变量在事件监听器之间是共享的。
- en: As you can see, to implement a long-press behavior, you will need two event
    listeners and one shared variable.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，要实现长按行为，你需要两个事件监听器和共享的一个变量。
- en: Now, what if you need to have this long-press behavior on another button?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你需要在另一个按钮上实现这个长按行为怎么办？
- en: You can’t really share the same event listener and the variable, as you might
    want a different duration to be considered as a timeout or a different behavior
    when a long press happens.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你实际上不能共享相同的事件监听器和变量，因为你可能希望将不同的持续时间视为超时，或者在长按发生时有不同的行为。
- en: So, you would have to redeclare them again and remember to pair the right event
    with the right event listener.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你必须再次声明它们，并记住将正确的事件与正确的事件监听器配对。
- en: Encapsulating logic into a component
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将逻辑封装到组件中
- en: A way to recreate a different long-press button is to encapsulate it as a component,
    putting all the long-press button logic into a component and reusing the component
    as a means to reuse the logic.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 重新创建不同长按按钮的一种方法是将其封装为一个组件，将所有长按按钮逻辑放入组件中，并作为重用逻辑的手段重用组件。
- en: When you define a component, you define the logic as well as the elements in
    the component. This means that if we put both the long-press logic and the `button`
    element into the component, we have to use the long-press logic together with
    the `button` element and no other elements.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 当你定义一个组件时，你也在定义组件中的逻辑以及元素。这意味着如果我们把长按逻辑和 `button` 元素都放入组件中，我们必须与 `button` 元素一起使用长按逻辑，而不能使用其他元素。
- en: 'If you want to customize the element, maybe by using a different element, having
    a different style, showing a different text content, or adding more event listeners,
    you would have to define the styles, text contents, or event listeners as props
    of the component and pass them into the `button` element in the component:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要自定义元素，比如使用不同的元素、不同的样式、显示不同的文本内容或添加更多的事件监听器，你必须定义样式、文本内容或事件监听器作为组件的属性，并将它们传递到组件中的
    `button` 元素：
- en: '[PRE8]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In the preceding code, we passed in extra attributes from the props into the
    `button` element along with forwarding two events, `click` and `dblclick`, from
    the button element out to the component.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将从props中传递的额外属性以及从按钮元素中转发两个事件（`click`和`dblclick`）到组件中。
- en: The point I am trying to make here is that if you wish to reuse event listener
    logic via components, you will find yourself having to take care of other attributes
    that go along with the element in the component.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 我在这里试图说明的是，如果你希望通过组件重用事件监听器逻辑，你将发现自己必须处理与元素一起在组件中出现的其他属性。
- en: We can do much more with a component, but if we are trying to reuse just the
    long-press behavior, then reusing it by defining it in a component is a bit overkill,
    and it can grow unmanageable rather quickly.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用组件做更多的事情，但如果我们只是尝试重用长按行为，那么通过在组件中定义它来重用它就有点过度了，而且它可能会很快变得难以管理。
- en: So, what other options do we have?
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们还有其他什么选择？
- en: Encapsulating logic into an action
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将逻辑封装到动作中
- en: A better option is to use an action to encapsulate the long-press behavior.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 使用动作封装长按行为是一个更好的选择。
- en: 'Let’s just do that and then I’ll explain why using an action is a better approach:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们就这样做，然后我会解释为什么使用动作是一个更好的方法：
- en: '[PRE9]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'With the action defined (as shown in the preceding code), we can use the action
    over multiple elements:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了动作（如前述代码所示），我们可以在多个元素上使用这个动作：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'You can apply the action to a different type of element:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将动作应用于不同类型的元素：
- en: '[PRE11]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'You can also use it alongside other attributes or event listeners:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以将它与其他属性或事件监听器一起使用：
- en: '[PRE12]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: I hope you can see that the `longPress` action encapsulates only the long-press
    behavior. Unlike the `LongPressButton` component, the `longPress` action can easily
    be reused in any element.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望你能看到，`longPress`动作只封装了长按行为。与`LongPressButton`组件不同，`longPress`动作可以很容易地在任何元素中重用。
- en: So, as a rule of thumb, when abstracting logic from an element, if you are abstracting
    it together with the elements, it is okay to use a component. But if you only
    need to abstract the logic behavior from an element, use actions.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，作为一个经验法则，当你从元素中抽象逻辑时，如果你需要与元素一起抽象它，使用组件是可以的。但如果你只需要从元素中抽象逻辑行为，请使用动作。
- en: 'Actions are a great tool for abstracting out element-level logic. But there
    is still one missing piece of the puzzle: how should we add a different long-press
    handler for a different element? We’ll see how next.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 动作是抽象元素级逻辑的强大工具。但仍然缺少一个拼图的一部分：我们应该如何为不同的元素添加不同的长按处理程序？我们将在下一部分看到。
- en: Passing parameters to an action
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向动作传递参数
- en: So, how do we customize the behavior of our `longPress` action?
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们如何自定义`longPress`动作的行为呢？
- en: You could have probably guessed the answer since you’ve seen it in the previous
    section. We can customize the behavior of an action by passing parameters into
    the action.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你在前面的部分已经看到了它，你可能已经猜到了答案。我们可以通过向动作传递参数来自定义动作的行为。
- en: 'For example, if we want to have a different function to handle a long-press
    action on different `button` elements, we can pass a different function into the
    action through action parameters:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想在不同的`button`元素上处理长按动作，我们可以通过动作参数传递一个不同的函数：
- en: '[PRE13]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will then receive this function within the second argument of the action
    function:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将在动作函数的第二个参数中接收到这个函数：
- en: '[PRE14]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We call the function passed in when it is considered a long press:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当被视为长按时，我们调用传递的函数：
- en: '[PRE15]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We can similarly pass in other parameters, such as the duration to be considered
    as a long press.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以类似地传递其他参数，例如，将持续时间考虑为长按。
- en: In Svelte actions, you can only pass in one parameter. To pass in multiple parameters,
    you will have to turn them into an object and pass them in as one parameter.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Svelte动作中，你只能传递一个参数。要传递多个参数，你必须将它们转换成一个对象，并将它们作为一个参数传递。
- en: 'Over in our `longPress` action, we want to pass the function to be called when
    the `longPress` action is detected, as well as the duration to be considered a
    long press, into the `longPress` action. To pass both the function and the duration
    in, we create an object that has them as object values and pass the object as
    the action parameter:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的`longPress`动作中，我们想要传递当检测到`longPress`动作时要调用的函数，以及被视为长按的持续时间，到`longPress`动作中。为了传递这两个值，我们创建一个包含它们作为对象值的对象，并将该对象作为动作参数传递：
- en: '[PRE16]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Some of the parameters in the object could be optional, so we might need to
    provide a default value when reading them within the action:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 对象中的某些参数可能是可选的，因此在操作中读取它们时，我们可能需要提供默认值：
- en: '[PRE17]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: At this stage, you might wonder, can the `onLongPress` be optional too?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你可能想知道，`onLongPress` 是否也可以是可选的？
- en: It does not make much sense in our case since the main goal of our action is
    to detect a long press and call the `onLongPress` function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，这没有太多意义，因为我们的操作的主要目标是检测长按并调用 `onLongPress` 函数。
- en: However, this is a good question.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这是一个好问题。
- en: In some other actions, you may have function handlers that are optional.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他一些操作中，你可能会有可选的函数处理程序。
- en: 'For example, what if we have a `gesture` action that can detect different gestures
    performed on the element? In that case, each `gesture` callback function can be
    optional since you may only be interested in one of the gestures:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们有一个可以检测元素上不同手势的 `gesture` 操作，那么每个 `gesture` 回调函数都是可选的，因为你可能只对其中的一种手势感兴趣：
- en: '[PRE18]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `onSwipe`, `onDrag`, and `onPinch` function handlers in this `gesture` action
    are optional and could be undefined.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `gesture` 操作中，`onSwipe`、`onDrag` 和 `onPinch` 函数处理程序是可选的，可能是未定义的。
- en: 'Instead of creating an empty function as a fallback, we should instead check
    whether the function is defined before calling it:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该创建一个空函数作为后备，而应该在使用之前检查函数是否已定义：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This way, we don’t have to create a function unnecessarily.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就不必创建不必要的函数。
- en: However, this gets messier when you have multiple callback functions and you
    need to check whether each of them has been defined before calling them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你有多个回调函数并且需要检查它们是否已定义后再调用它们时，这会变得复杂。
- en: Is there a better way to handle this?
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 有没有更好的处理方式？
- en: Yes, there is.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，确实有。
- en: In fact, a more idiomatic Svelte way of having an action to notify or call a
    function when something happens is to dispatch a custom event.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在 Svelte 中，有一个更符合习惯的方式，当发生某些操作时，可以通过派发一个自定义事件来通知或调用一个函数。
- en: 'For example, to know whether the user has long-pressed the `<button>` element,
    it would be natural to listen to the `''longpress''` custom event on the `<``button>`
    element:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要确定用户是否长按了 `<button>` 元素，自然是在 `<button>` 元素上监听 `'longpress'` 自定义事件：
- en: '[PRE20]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: However, there’s no native event called `'longpress'`.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，没有名为 `'longpress'` 的原生事件。
- en: But no worries, we can create a custom `'``longpress'` event.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 但别担心，我们可以创建一个自定义的 `'longpress'` 事件。
- en: 'Luckily, we have the `longPress` action to determine when the user long-presses
    a button. What we need to create a custom `''longpress''` event is to trigger
    the `''longpress''` event after determining the user has long-pressed a button
    in our `longPress` action. And so, in the line of code where we have determined
    that the user is long-pressing the button, we can dispatch a custom event from
    the button:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们有 `longPress` 操作来确定用户何时长按按钮。要创建自定义的 `'longpress'` 事件，我们需要在 `longPress`
    操作中确定用户长按按钮后触发 `'longpress'` 事件。因此，在确定用户正在长按按钮的代码行中，我们可以从按钮中派发一个自定义事件：
- en: '[PRE21]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s listen to the `longpress` custom event and create the custom `''longpress''`
    event in our action. Here is the final code:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们监听 `'longpress'` 自定义事件，并在我们的操作中创建自定义的 `'longpress'` 事件。以下是最终的代码：
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: <input on:input={(event) => event.target.checkValidity()} />
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: <input on:input={(event) => event.target.checkValidity()} />
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: <input
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: <input
- en: on:input={(event) => event.target.checkValidity()}
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: on:input={(event) => event.target.checkValidity()}
- en: on:invalid={(event) => console.log(event.target.validity)}
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: on:invalid={(event) => console.log(event.target.validity)}
- en: />
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: '[PRE24]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: <input on:validate={(event) => {
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: <input on:validate={(event) => {
- en: if (event.detail.isValid) {
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: if (event.detail.isValid) {
- en: errorMessage = '';
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: errorMessage = '';
- en: '} else {'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '} else {'
- en: errorMessage = event.detail.errorMessage;
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: errorMessage = event.detail.errorMessage;
- en: '}'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '}'
- en: '}} />'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '}} />'
- en: '[PRE25]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: function validateOnType(input) {
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: function validateOnType(input) {
- en: input.addEventListener('input', onInput);
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: input.addEventListener('input', onInput);
- en: return {
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: return {
- en: destroy() {
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: destroy() {
- en: input.removeEventListener('input', onInput);
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: input.removeEventListener('input', onInput);
- en: '}'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '};'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '};'
- en: '}'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE26]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: function validateOnType(input) {
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: function validateOnType(input) {
- en: function onInput() {
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: function onInput() {
- en: const isValid = input.checkValidity();
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: const isValid = input.checkValidity();
- en: 'const errorMessage = isValid ? '''' : getErrorMessage(input.validity);'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 'const errorMessage = isValid ? '''' : getErrorMessage(input.validity);'
- en: '}'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-132
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE27]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: function validateOnType(input) {
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: function validateOnType(input) {
- en: function onInput() {
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: function onInput() {
- en: // ...
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ...
- en: input.dispatchEvent(
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: input.dispatchEvent(
- en: new CustomEvent(
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: new CustomEvent(
- en: '''validate'','
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '''validate'','
- en: '{ detail: { isValid, errorMessage } }'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{ detail: { isValid, errorMessage } }'
- en: )
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: )
- en: );
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: );
- en: '}'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: // ...
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: // ...
- en: '}'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE28]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: <input
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <input
- en: use:validateOnType
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: use:validateOnType
- en: on:validate={(event) => console.log(event.detail)}
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当：validate={(event) => console.log(event.detail)}
- en: />
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: />
- en: '[PRE29]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: <script>
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <script>
- en: let isValid = false;
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: let isValid = false;
- en: </script>
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </script>
- en: <input
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <input
- en: class:invalid={!isValid}
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 类：invalid={!isValid}
- en: use:validateOnType
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用：validateOnType
- en: on:validate={(event) => isValid = event.detail.isValid}
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当：validate={(event) => isValid = event.detail.isValid}
- en: />
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: />
- en: <style>
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: <style>
- en: '.invalid { border: red 1px solid; }'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '.invalid { border: red 1px solid; }'
- en: </style>
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: </style>
- en: '[PRE30]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: <div
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: <div
- en: use:dragAndDrop
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 使用：dragAndDrop
- en: on:dragStart={...}
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 当：dragStart={...}
- en: on:dragMove={...}
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 当：dragMove={...}
- en: on:dragEnd={...}
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 当：dragEnd={...}
- en: />
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: />
- en: '[PRE31]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
