- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Custom Events with Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actions are one of the most powerful features of Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: They are a lightweight alternative to a component that encapsulates logic and
    data into a reusable unit. They help us reuse the same logic on different elements.
  prefs: []
  type: TYPE_NORMAL
- en: While components have life cycle methods such as `onMount` and `onDestroy` that
    run when all the elements within the component are added to or removed from the
    DOM, actions are designed to handle the logic for individual elements, running
    only when that specific element is added to or removed from the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: While components can receive and react to prop changes, you can pass data to
    actions from a parent component to a child component. The actions will react when
    the data is changed and you can specify how the action should react when that
    data changes.
  prefs: []
  type: TYPE_NORMAL
- en: Actions are simple yet amazingly versatile. You can use them for various things.
    In this and the following chapters, we are going to explore some of the use cases
    of actions.
  prefs: []
  type: TYPE_NORMAL
- en: One of the many use cases of actions is to manage elements’ event listeners.
    Event listeners are very common in web applications as they allow us to implement
    specific behaviors in response to user actions. This makes our application more
    interactive and dynamic. So, it will be interesting to see how Svelte actions
    can be used to help us manage event listeners.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start by looking at how we can use actions to help
    manage event listeners for elements. We will follow that up with examples and
    exercises to reinforce the idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter includes sections on the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Managing event listeners with actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating custom events with actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the projects of the chapter here: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter05)'
  prefs: []
  type: TYPE_NORMAL
- en: Defining actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we start to talk about using Svelte actions to create custom events,
    let’s quickly recap how to define an action in Svelte.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Svelte, an action is nothing but a function that follows an action contract.
    This means if a function follows a specific function signature, it is considered
    an action. Here is the function signature of an action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: It is a function that optionally returns an object that has a `destroy` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, since the `action` function follows the action contract, it is
    a Svelte action.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use the Svelte action on an element, you can use the `use:` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we used the Svelte action named `action` on the `div` element.
  prefs: []
  type: TYPE_NORMAL
- en: So, what will happen to the `div` element with a Svelte action?
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `<div>` element is mounted to the DOM, Svelte will call the `action`
    function with the reference to the `<``div>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the element is removed from the DOM, Svelte will call the `destroy` method
    from the object returned from calling the `action` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can customize the behavior of a Svelte action by using parameters. We can
    pass in an extra parameter to the `action` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, you can add another method to the returning object, `update`, which will
    be called when the value of the parameter changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To pass in an additional parameter, you can specify it in a similar syntax
    as the `value` attribute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Now that we know how to use and define an action in Svelte, let’s take a look
    at our first use case of actions.
  prefs: []
  type: TYPE_NORMAL
- en: Reusing DOM event logic with custom events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start talking directly about actions, let’s look at an example of
    using the `mousedown` and `mouseup` events to create a long-press behavior. We
    shall see how this simple example will lead us on to Svelte actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding example, we tried to implement a long-press behavior in a button.
    The idea is to press and hold the button for more than two seconds and then perform
    some action. As we detect it’s a long press, we print `'long press!'` into the
    console.
  prefs: []
  type: TYPE_NORMAL
- en: 'To implement the long-press behavior, I attached two event listeners: `mousedown`
    and `mouseup`. The two event listeners work together. `mousedown` starts counting
    down using `setTimeout` for two seconds, and `mouseup` clears the countdown using
    `clearTimeout`. If the user did not hold onto the button for long enough, the
    timeout would not be triggered and it would not be considered a long press. Note
    that to coordinate the timers between the two event listeners, the `timer` variable
    is shared across the event listeners.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, to implement a long-press behavior, you will need two event
    listeners and one shared variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, what if you need to have this long-press behavior on another button?
  prefs: []
  type: TYPE_NORMAL
- en: You can’t really share the same event listener and the variable, as you might
    want a different duration to be considered as a timeout or a different behavior
    when a long press happens.
  prefs: []
  type: TYPE_NORMAL
- en: So, you would have to redeclare them again and remember to pair the right event
    with the right event listener.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating logic into a component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A way to recreate a different long-press button is to encapsulate it as a component,
    putting all the long-press button logic into a component and reusing the component
    as a means to reuse the logic.
  prefs: []
  type: TYPE_NORMAL
- en: When you define a component, you define the logic as well as the elements in
    the component. This means that if we put both the long-press logic and the `button`
    element into the component, we have to use the long-press logic together with
    the `button` element and no other elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to customize the element, maybe by using a different element, having
    a different style, showing a different text content, or adding more event listeners,
    you would have to define the styles, text contents, or event listeners as props
    of the component and pass them into the `button` element in the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we passed in extra attributes from the props into the
    `button` element along with forwarding two events, `click` and `dblclick`, from
    the button element out to the component.
  prefs: []
  type: TYPE_NORMAL
- en: The point I am trying to make here is that if you wish to reuse event listener
    logic via components, you will find yourself having to take care of other attributes
    that go along with the element in the component.
  prefs: []
  type: TYPE_NORMAL
- en: We can do much more with a component, but if we are trying to reuse just the
    long-press behavior, then reusing it by defining it in a component is a bit overkill,
    and it can grow unmanageable rather quickly.
  prefs: []
  type: TYPE_NORMAL
- en: So, what other options do we have?
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulating logic into an action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A better option is to use an action to encapsulate the long-press behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s just do that and then I’ll explain why using an action is a better approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'With the action defined (as shown in the preceding code), we can use the action
    over multiple elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'You can apply the action to a different type of element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also use it alongside other attributes or event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: I hope you can see that the `longPress` action encapsulates only the long-press
    behavior. Unlike the `LongPressButton` component, the `longPress` action can easily
    be reused in any element.
  prefs: []
  type: TYPE_NORMAL
- en: So, as a rule of thumb, when abstracting logic from an element, if you are abstracting
    it together with the elements, it is okay to use a component. But if you only
    need to abstract the logic behavior from an element, use actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Actions are a great tool for abstracting out element-level logic. But there
    is still one missing piece of the puzzle: how should we add a different long-press
    handler for a different element? We’ll see how next.'
  prefs: []
  type: TYPE_NORMAL
- en: Passing parameters to an action
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So, how do we customize the behavior of our `longPress` action?
  prefs: []
  type: TYPE_NORMAL
- en: You could have probably guessed the answer since you’ve seen it in the previous
    section. We can customize the behavior of an action by passing parameters into
    the action.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we want to have a different function to handle a long-press
    action on different `button` elements, we can pass a different function into the
    action through action parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then receive this function within the second argument of the action
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We call the function passed in when it is considered a long press:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We can similarly pass in other parameters, such as the duration to be considered
    as a long press.
  prefs: []
  type: TYPE_NORMAL
- en: In Svelte actions, you can only pass in one parameter. To pass in multiple parameters,
    you will have to turn them into an object and pass them in as one parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Over in our `longPress` action, we want to pass the function to be called when
    the `longPress` action is detected, as well as the duration to be considered a
    long press, into the `longPress` action. To pass both the function and the duration
    in, we create an object that has them as object values and pass the object as
    the action parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Some of the parameters in the object could be optional, so we might need to
    provide a default value when reading them within the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: At this stage, you might wonder, can the `onLongPress` be optional too?
  prefs: []
  type: TYPE_NORMAL
- en: It does not make much sense in our case since the main goal of our action is
    to detect a long press and call the `onLongPress` function.
  prefs: []
  type: TYPE_NORMAL
- en: However, this is a good question.
  prefs: []
  type: TYPE_NORMAL
- en: In some other actions, you may have function handlers that are optional.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, what if we have a `gesture` action that can detect different gestures
    performed on the element? In that case, each `gesture` callback function can be
    optional since you may only be interested in one of the gestures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `onSwipe`, `onDrag`, and `onPinch` function handlers in this `gesture` action
    are optional and could be undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of creating an empty function as a fallback, we should instead check
    whether the function is defined before calling it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This way, we don’t have to create a function unnecessarily.
  prefs: []
  type: TYPE_NORMAL
- en: However, this gets messier when you have multiple callback functions and you
    need to check whether each of them has been defined before calling them.
  prefs: []
  type: TYPE_NORMAL
- en: Is there a better way to handle this?
  prefs: []
  type: TYPE_NORMAL
- en: Yes, there is.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a more idiomatic Svelte way of having an action to notify or call a
    function when something happens is to dispatch a custom event.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to know whether the user has long-pressed the `<button>` element,
    it would be natural to listen to the `''longpress''` custom event on the `<``button>`
    element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: However, there’s no native event called `'longpress'`.
  prefs: []
  type: TYPE_NORMAL
- en: But no worries, we can create a custom `'``longpress'` event.
  prefs: []
  type: TYPE_NORMAL
- en: 'Luckily, we have the `longPress` action to determine when the user long-presses
    a button. What we need to create a custom `''longpress''` event is to trigger
    the `''longpress''` event after determining the user has long-pressed a button
    in our `longPress` action. And so, in the line of code where we have determined
    that the user is long-pressing the button, we can dispatch a custom event from
    the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s listen to the `longpress` custom event and create the custom `''longpress''`
    event in our action. Here is the final code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: <input on:input={(event) => event.target.checkValidity()} />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: <input
  prefs: []
  type: TYPE_NORMAL
- en: on:input={(event) => event.target.checkValidity()}
  prefs: []
  type: TYPE_NORMAL
- en: on:invalid={(event) => console.log(event.target.validity)}
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: <input on:validate={(event) => {
  prefs: []
  type: TYPE_NORMAL
- en: if (event.detail.isValid) {
  prefs: []
  type: TYPE_NORMAL
- en: errorMessage = '';
  prefs: []
  type: TYPE_NORMAL
- en: '} else {'
  prefs: []
  type: TYPE_NORMAL
- en: errorMessage = event.detail.errorMessage;
  prefs: []
  type: TYPE_NORMAL
- en: '}'
  prefs: []
  type: TYPE_NORMAL
- en: '}} />'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: function validateOnType(input) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: input.addEventListener('input', onInput);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: return {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: destroy() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: input.removeEventListener('input', onInput);
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '};'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: function validateOnType(input) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function onInput() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: const isValid = input.checkValidity();
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'const errorMessage = isValid ? '''' : getErrorMessage(input.validity);'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: function validateOnType(input) {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: function onInput() {
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: input.dispatchEvent(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: new CustomEvent(
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '''validate'','
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '{ detail: { isValid, errorMessage } }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: )
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: );
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: // ...
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '}'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <input
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use:validateOnType
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: on:validate={(event) => console.log(event.detail)}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: let isValid = false;
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </script>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <input
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: class:invalid={!isValid}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: use:validateOnType
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: on:validate={(event) => isValid = event.detail.isValid}
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: />
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: <style>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '.invalid { border: red 1px solid; }'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: </style>
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: <div
  prefs: []
  type: TYPE_NORMAL
- en: use:dragAndDrop
  prefs: []
  type: TYPE_NORMAL
- en: on:dragStart={...}
  prefs: []
  type: TYPE_NORMAL
- en: on:dragMove={...}
  prefs: []
  type: TYPE_NORMAL
- en: on:dragEnd={...}
  prefs: []
  type: TYPE_NORMAL
- en: />
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
