- en: Chapter 1. Getting Started with Meteor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Meteor is a framework that is essentially fast for the purpose of development
    even if you program at a slow pace. The aim of this book is to increase your development
    speed and improve quality. There are two key ingredients required to improve development:
    compilers and patterns. Compilers add functionality to your coding language, while
    patterns increase the speed at which you solve common programming issues.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This book will mostly cover patterns, but we''ll use this chapter to quick
    start compilers and understand how they relate to Meteor—a vast but simple topic.
    The compilers that we will look at are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: CoffeeScript
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jade
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stylus
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will review some basic knowledge you should have about Meteor. This will
    cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Templates, helpers, and events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The event loop and the merge box
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The must-have packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folder structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CoffeeScript for Meteor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CoffeeScript is a compiler for JavaScript that adds "syntactic sugar" inspired
    by Ruby, Python, and Haskell; it effectively makes the writing of JavaScript easier
    and more readable. CoffeeScript simplifies the syntax of functions, objects, arrays,
    logical statements, binding, managing scope, and much more. All CoffeeScript files
    are saved with a `.coffee` extension. We will cover functions, objects, logical
    statements, and bindings as these are some of the most commonly used features.
  prefs: []
  type: TYPE_NORMAL
- en: Objects and arrays
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CoffeeScript gets rid of curly braces (`{}`), semicolons (`;`), and commas
    (`,`). This alone saves you from repeating unnecessary strokes on the keyboard.
    Instead, CoffeeScript emphasizes on the proper use of **tabbing**. Tabbing will
    not only make your code more readable, but it will be a key factor in making the
    code work as well. In fact, you are probably already tabbing the right way! Let''s
    look at some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs: []
  type: TYPE_NORMAL
- en: You can download the example code files from your account at [http://www.packtpub.com](http://www.packtpub.com)
    for all the Packt Publishing books you have purchased. If you purchased this book
    elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, we are creating an object named `toolbox` that contains two keys: `hammer`
    and `flashlight`. The equivalent in JavaScript will be this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Much easier! As you can see, we have to **tab** to indicate that both the `hammer`
    and `flashlight` properties are a part of `toolbox`. The `var` word is not allowed
    in CoffeeScript because CoffeeScript automatically applies it for you. Let''s
    have a look at how we would make an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, we can see that we don't need to have any commas, but we do need to have
    brackets to determine that this is an array.
  prefs: []
  type: TYPE_NORMAL
- en: Logical statements and operators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'CoffeeScript removes a lot of parenthesis (`()`) in logical statements and
    functions as well. This makes the logic of the code much easier to understand
    at first glance. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can clearly see that CoffeeScript is easier to read and
    write. CoffeeScript effectively replaces the entire **implied parenthesis** in
    any logical statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Operators such as `&&`, `||`, and `!==` are replaced by words to make the code
    more readable. Here is a list of the operators that you will be using the most:'
  prefs: []
  type: TYPE_NORMAL
- en: '| CoffeeScript | JavaScript |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `is` | `===` |'
  prefs: []
  type: TYPE_TB
- en: '| `isnt` | `!==` |'
  prefs: []
  type: TYPE_TB
- en: '| `not` | `!` |'
  prefs: []
  type: TYPE_TB
- en: '| `and` | `&&` |'
  prefs: []
  type: TYPE_TB
- en: '| `or` | `&#124;&#124;` |'
  prefs: []
  type: TYPE_TB
- en: '| `true, yes, on` | `true` |'
  prefs: []
  type: TYPE_TB
- en: '| `false, no, off` | `false` |'
  prefs: []
  type: TYPE_TB
- en: '| `@, this` | `this` |'
  prefs: []
  type: TYPE_TB
- en: 'Let''s look at a slightly more complex logical statement and see how it is
    compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the context of `this` is passed to the `@` symbol without the need
    for a period, making `@eye_color` equal to `this.eye_color`.
  prefs: []
  type: TYPE_NORMAL
- en: Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A JavaScript function is a block of code designed to perform a particular task.
    JavaScript has a couple of ways of creating functions that are simplified in CoffeeScript.
    They look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'CoffeeScript uses `->` instead of the `function()` keyword. The following example
    outputs a `hello_world` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we will use a tab to specify the contents of the function so that
    there is no need for curly braces (`{}`). This means that you have to make sure
    that you have the entire logic of the function tabbed under its namespace.
  prefs: []
  type: TYPE_NORMAL
- en: 'What about our parameters? We can use `(p1,p2) ->` where `p1` and `p2` are
    parameters. Let''s make our `hello_world` function output our name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can see how parameters are placed inside parentheses. We
    are also doing **string interpolation**. CoffeeScript allows the programmer to
    easily add logic to a string by escaping the string with `#{}`. Also notice that,
    unlike JavaScript, you do not have to return anything at the end of the function,
    CoffeeScript automatically returns the output of the last command.
  prefs: []
  type: TYPE_NORMAL
- en: Binding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In Meteor, we will often find ourselves using the properties of `this` within
    nested functions and callbacks. **Function binding** is very useful for these
    types of cases and helps to avoid saving data in additional variables. Function
    binding sets the value of the `this` object inside the function to the value of
    `this` outside the function. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the `this` object will return a top-level object such as the
    browser window. This is not useful at all. Let''s bind `this` now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The key difference is the use of `=>` instead of the expected `->` to define
    the function. Using `=>` will make the callback''s `this` object equal to the
    context of the executing function. The resulting compiled script is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'CoffeeScript will improve your coding quality and speed. Still, *CoffeeScript
    is not flawless*. When you start combining functions with nested arrays, things
    can get complex and difficult to read, especially when the functions are constructed
    with multiple parameters. Let''s look at a common query that does not look as
    readable as you would expect it to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This collection query is passing three parameters: the `filter` object, the
    `options` object, and the callback function. To differentiate between the first
    two objects, we had to place a comma at the same level as the function and then,
    indent the second parameter. This is unwieldy, but we can use variables in order
    to make the query more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Go to [coffeescript.org](http://coffeescript.org) and play around with the language
    by clicking on the "try coffeescript" link.
  prefs: []
  type: TYPE_NORMAL
- en: Jade for Meteor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jade works much like CoffeeScript but it is used for HTML instead. I recommend
    that you install the `mquandalle:jade` package. All the Jade files are saved with
    a `.jade` extension. This section will cover the most used aspects of Jade in
    Meteor such as HTML tags, components, and helpers.
  prefs: []
  type: TYPE_NORMAL
- en: HTML tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Much like CoffeeScript, Jade is a language that depends heavily on tabbing.
    When you want to add children to an HTML tag, you simply use tab. Tag IDs and
    classes can be added using the CSS selector notation (`''input#name.first''`).
    This means classes are expressed with a dot (`.`) and IDs are expressed with a
    pound (`#`). Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, **special** attributes such as `data-bind` are added with parenthesis.
    Symbols such as `<`, `>`, and **closures** are not required anymore. In this example,
    we have a `div` tag with an `id` attribute of `"container"`, a `ul` tag with a
    `class` attribute of list, and a `li` tag with a special attribute of `data-bind`.
  prefs: []
  type: TYPE_NORMAL
- en: You will find yourself using special attributes often for the `input` tags to
    add `value`, `placeholder`, and other attributes.
  prefs: []
  type: TYPE_NORMAL
- en: Templates and components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Meteor templates are Jade components. In Meteor, we define a template with
    the template tag and apply the special `name` attribute to create a reusable HTML
    block. In Jade, when we create a template, we create a component as well. This
    looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can use this template as a Jade component anywhere in our views. To
    call a Jade component, you simply prepend a plus sign to the name of the template.
    Let''s look at an example where we want to place a `landing` page inside a `main_layout`
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it! Notice that we have prepended the plus (`+`) sign to the name of
    the template to call it. This is equivalent to using `{{> landing}}` in SpaceBars
    (Meteor''s version of Handlebars). Components can have parameters as well, which
    can be later used in the templates'' instance. Let''s make our example output
    someone''s name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Adding attributes to your templates can make your templates flexible as shown
    in the preceding example. Still, it is unlikely that you will have to use this
    as templates "soak up" data from their parent context.
  prefs: []
  type: TYPE_NORMAL
- en: Helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Helpers in Meteor are functions that return data before rendering to the view.
    We use helpers for iteration, logical statements, and variables. The two basic
    helpers are `each` and `if`, but adding the `raix:handlebar-helpers` package will
    add a dictionary of other useful helpers to keep your code from repeating. Let''s
    have a look at how we can use our helpers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the `each` helper is iterating through the return value of
    another helper named `things` and if the `selected` helper resolves to `true`,
    then we will render `p.selected` with the `name` variable.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand that everything that is not an HTML tag is a helper,
    and that if you want to use a helper within a tag, you need to use `{{}}` or `#{}`
    to express this.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [jade-lang.com](http://jade-lang.com) and `handlebars.js` to know more
    specific information. With this information, you should be able to do just about
    anything.
  prefs: []
  type: TYPE_NORMAL
- en: Stylus for Meteor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Stylus works much like CoffeeScript and Jade but it is for CSS. I recommend
    that you install `mquandalle:stylus`. This package is preinstalled with useful
    tools such as `Jeet` and `Rupture`. All Stylus files are saved with a `.styl`
    extension. There are only three things that we need to learn about Stylus: CSS
    tags, variables, and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: CSS tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Stylus is a language that does away with the need for semicolons (`;`) and
    curly braces (`{}`) in exchange for making good use of tabbing. Let''s look at
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see in `PART 1` how properties are defined for a class by tabbing those
    properties in `.special` is used to select an HTML tag with the `special` class
    that is a child of the `vertical-align-middle` class. Let''s look at how `PART
    1` compiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add a more complex selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`PART 2` has a combination of special CSS2 selectors: specific parent (`>`)
    and all elements (`*`). In this particular order, the CSS2 selectors are picking
    the "any first sibling" element only and applying the rules. Let''s look at how
    `PART 2` compiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add a new class to the current class that aligns the object to the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '`PART 3` uses an ampersand (`&`) to describe an element that is not a child
    but instead is concatenated with the extra class. Let''s look at how `PART 3`
    compiles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike CSS, Stylus supports variables. This keeps a lot of things manageable
    when we want to make major changes to the look of our site. Suppose we have two
    colors that we want to use throughout our site, but we know that these colors
    are going to change. Let''s define them as variables so that we can easily modify
    them later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Easy right? In this example, both `primary-color` and `$secondary-color` are
    variables. Stylus optionally supports the use of the money sign (`$`) to indicate
    a variable. This can make it easier to spot variables.
  prefs: []
  type: TYPE_NORMAL
- en: Functions/mixins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unlike CSS, Stylus supports functions too. LESS, Stylus, and **Sassy CSS**
    (**SCSS**) refer to functions as **mixins**. Functions will make your CSS concoctions
    much easier to share across a project. We will cover the two types of mixins in
    Stylus: mixins and transparent mixins.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Mixins are functions that take a defined set of parameters. Let''s take a look
    at how we can write a mixin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we first define the `animation` mixin, and then we apply the
    mixin to the `button` HTML tag. However, there is a much easier and effective
    way of doing this via a transparent mixin.
  prefs: []
  type: TYPE_NORMAL
- en: 'A transparent mixin, basically, takes all the parameters and saves them in
    an `arguments` variable without you having to define anything. Let''s have a look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Notice how we did not have to define every single parameter in the mixin, and
    the `arguments` variable simply passed all the arguments that it could find. This
    is especially useful for keeping the code flexible.
  prefs: []
  type: TYPE_NORMAL
- en: Stylus essentially upgrades CSS in such a way that it makes the code much easier
    to manage and therefore, ends up saving us a lot of development time.
  prefs: []
  type: TYPE_NORMAL
- en: Go to [stylus-lang.com](http://stylus-lang.com) and [learnboost.github.io/stylus](http://learnboost.github.io/stylus)
    to learn more about Stylus.
  prefs: []
  type: TYPE_NORMAL
- en: Templates, helpers, and events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we are on the same page for the languages that we are going to use
    throughout the book, let's do a quick review of some of the elements that we will
    use during our development process.
  prefs: []
  type: TYPE_NORMAL
- en: Templates, helpers, and events are used to build the frontend of your application.
    Using them effectively is the key to how we design our backend as well (which
    we will address in [Chapter 2](part0021_split_000.html#page "Chapter 2. Publish
    and Subscribe Patterns"), *Publish and Subscribe Patterns*).
  prefs: []
  type: TYPE_NORMAL
- en: Templates
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Meteor templates are the special blocks of HTML code that generate Meteor template
    objects (`Template.<yourtemplate>`). It is through Meteor template objects that
    we wire the HTML code to logic. People who have worked with an MVC framework will
    refer to these templates as views. This is a key concept to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up your terminal and create a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s add our languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Remove the three visible files from `/basic_meteor` (do not remove any of the
    files starting with a dot), and create `/client/layout.jade`. This is something
    that exists in one way or another in every Meteor project. Let''s program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Behind the scenes, Meteor is compiling our Jade templates and putting them all
    in one big file. You will never have to worry about loading `basic_template.jade`
    before `layout.jade` when it comes to templating.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout the book, we will use `meteorhacks:flow-router` and `meteorhacks:flow-layout`
    to easily navigate to different templates.
  prefs: []
  type: TYPE_NORMAL
- en: Creating helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already discussed what helpers are in Jade, but how do we create helpers
    in Meteor? Let''s go back to our `basic_meteor` project and create `/client/basic_template.coffee`.
    It is important to understand that Meteor helpers are used to control the variables
    in our template. People who have worked with an MVC framework can view this file
    as a controller. Let''s write our first helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that the helper is defined within the `helpers` function of the Meteor
    template object: `Template.<your_template>.helpers(<your_helpers>)`. Helpers are
    mostly functions that will return anything you want them to including Meteor collection
    cursors. Let''s bring all this together now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output `Hello Mr Someone` inside the `h1` HTML tag. Let''s add a
    slightly more complex helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are using `with` to set up the **data context** of the HTML
    tags that belong to it; this data context is equivalent to `person`. Data context
    refers to the value of `this` inside a helper. So if you set up an object as the
    data context, `this` will be equivalent to that object. Also, we iterate through
    `children` with an `each` statement so that we can list out their names.
  prefs: []
  type: TYPE_NORMAL
- en: Events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Meteor taps into common JavaScript HTML events such as click, change, and focus.
    An event is anything that happens to an HTML element that you are listening to.
    Suppose we want to be able to change the name of a person to one of the children
    by clicking on them. We do this through the templates'' event map. Let''s take
    a look at an example of how we can do this without using reactivity or collections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Easy! So to catch template events, we need to use the `Template.<your_template>.events(<your_event_map>)`
    function. In this particular example, we are using jQuery to replace text.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `event map` is an object where the properties specify a set of events to
    be handled. These events may be specified in any of the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The key `string` of the event is composed of two parts: the first is always
    a type of event (click, hover, change, and so on) while the second is always a
    CSS selector.'
  prefs: []
  type: TYPE_NORMAL
- en: The event loop and the merge box
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before diving into Meteor, it is critical to understand what the event loop
    and the merge box are and how they can adversely affect your code. Both are relatively
    complex in the way that they were programmed, so we will focus on understanding
    the general concept.
  prefs: []
  type: TYPE_NORMAL
- en: The event loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The event loop is like a queue; it runs a series of functions one by one. Because
    functions are processed sequentially, each function effectively blocks others
    from being processed until the function is done.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, the event loop functions much like a single-line conveyor belt
    where things are being inspected. For every inspection made, the line is stopped
    and nothing moves.
  prefs: []
  type: TYPE_NORMAL
- en: Meteor uses Fibers – a NodeJS library – to get around this issue. Many of the
    functions that you will run will be on a separate fiber. What does this mean?
    This means that the functions will run on a separate conveyor belt for processing.
    Still, not all functions are built this way, you need to make sure your server-side
    functions do not block the server.
  prefs: []
  type: TYPE_NORMAL
- en: So which functions could potentially cause the server to get blocked? `Meteor.methods()`,
    `Meteor.publish()`, and `any` function that does not run inside a fiber on the
    server. Let's see how we can unblock each one and when we should do this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions defined under the `Meteor.methods()` that you know are going to take
    a long time to process, should always run on a Fiber or defer time consuming code
    to a Fiber. We can quickly solve this by calling the `@unblock()` function from
    within the method. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: In this example, when you run `Meteor.call("time_consuming")`, the server will
    be blocked. When the server is blocked, other visitors won't be able to reach
    your site! Instead if you run `Meteor.call("time_consuming_unblock")`, the server
    will continue to function properly but consume more resources to do so.
  prefs: []
  type: TYPE_NORMAL
- en: '`Meteor.publish()` can be easily unblocked after installing the `meteorhacks:unblock`
    package as well. This one will be particularly useful when we start to make very
    complex publishers that might consume a lot of resources. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are waiting for an HTTP call to respond. This will certainly
    block the server if we subscribe to `external_API_query`, so we use `external_API_query_unblocked`
    instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'All other functions that run on the server and you know are going to block
    the server, should run on a fiber. Meteor has a special function to help us make
    this easy. It is called `Meteor.wrapAsync()`. Let''s see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is very important to keep the event loop in mind, especially when we're connecting
    our web application to external services that are going to cause massive delays
    to our server.
  prefs: []
  type: TYPE_NORMAL
- en: The merge box
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The merge box is the algorithm that identifies all the changes that are happening
    to the database. It basically handles publishers, subscribers, and reactivity.
    The merge box also handles the initial load of data using DDP messages.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that we can communicate directly with the merge
    box via all the commands that are available to us under the `Meteor.publish()`
    function. The more optimal we can make our `Meteor.publish` functions, the faster
    the site will load.
  prefs: []
  type: TYPE_NORMAL
- en: The beginning of our online shop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Throughout the book we will be developing an e-commerce website to help us
    understand the core concepts of advanced Meteor web development. Let''s begin
    by creating a new project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The must-have packages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[Atmospherejs.com](http://Atmospherejs.com) has always been the "go to" website
    to find packages. Here you will find thousands of packages produced by the community
    for free. There are a handful of packages that we absolutely need to install to
    make our website function properly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we install the languages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, the router and functions that will help us with SEO and routing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**WARNING**: Do not run Meteor yet! Canonical could mess up your project unless
    you have it set up correctly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will need a couple of packages as well to help us manage publishers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'These next packages will extend Meteor''s functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'We will need these packages to properly manage time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'For the last set, we''ll be using a couple of additional packages that will
    make the design process much faster:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to remove some packages for security too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: All of these packages will be explained in more detail throughout the book,
    but all of these are must-haves. The first package that we need to explain is
    the `wizonesolutions:canonical` package. This package makes sure that all incoming
    traffic is routed to your `ROOT_URL`, so it is particularly useful when you want
    all the traffic to go to your SSL site. The first thing that we need to do before
    running Meteor is set up canonical to run only in the production environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create `/server/canonical.coffee`, and add this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: What are environment variables? These variables are defined within the scope
    of the deployment, and they make sure that the project knows information before
    the build finishes on the server. Information such as what database to use, which
    domains to use, and other setup information can usually be found in these variables.
    We will cover this information in the final chapter.
  prefs: []
  type: TYPE_NORMAL
- en: File structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A proper file structure is tremendously important in Meteor. We have found that
    the best way to work is with functional top-level modules. This means that every
    folder is a micro-service, and therefore can act on its own. This allows for a
    lot of modularity in the project, and it's very easy for others to understand
    what it is that you are trying to accomplish. In this section, we will cover this
    file structure and Meteor's special folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a sample web application folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'In this folder structure, `cart` is the micro-service, and it is composed of
    a route, view, controller, and publisher. The files placed under a `/client` directory
    will be published to the client and will only run on the client. The files placed
    under a `/server` directory will only run and be accessible on the server. If
    a file is placed in none of these directories, then the file will run on both
    the client and server. The expected structure goes like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that the `/lib` directory will always run before any
    other code does. Let's place our canonical file under the `/_globals/canonical/server`
    directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create our first module: the router. Create the `/router/client/layout.jade`
    directory, and we will only have one layout throughout the project. Now let''s
    code our layout:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have introduced the `Template.dynamic` component. This component may
    be used to render other templates dynamically by changing the value of a variable
    to the name of the template we want to render. We decided to use two variables—`nav`
    and `content`— that are controlled by the router. So, basically, the `content`
    variable will be changing to different strings that are equal to the names of
    our templates.
  prefs: []
  type: TYPE_NORMAL
- en: We will create our `landing` module in the next chapter to learn not only how
    to use the router but also how to properly subscribe to data.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have addressed a lot of things in this chapter. We can now program faster
    because we have tools such as CoffeeScript, Jade, and Stylus to help us. Also,
    we have learned how to use templates, helpers, and events to work with our Meteor
    frontend. Understanding the event loop and the merge box has made us a bit more
    precautious when it comes to running complex, time-consuming operations. Finally,
    we began to build a project, and we adopted a folder structure that is going to
    make development quicker.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter, we will cover two of the most important parts that make
    a Meteor application viable: Meteor publishers and Meteor subscribers. With these
    patterns, you will be able to produce sites that load quickly and that do not
    put too much strain on the server.'
  prefs: []
  type: TYPE_NORMAL
