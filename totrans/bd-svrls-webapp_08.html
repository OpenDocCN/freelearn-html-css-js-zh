<html><head></head><body>
        

                            
                    <h1 class="header-title">Securing the Serverless Application</h1>
                
            
            
                
<p>Handling security is an extensive and complex topic. If you don't do it right, you may be hacked. Even if you do everything right, you may be hacked. So it's important you understand the common security mechanisms to avoid exposing your website to vulnerabilities, and also, always follow the recommended practices and methodologies that have been largely tested and proven to be robust.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Basic security practices and concepts</li>
<li>Learning how to use Amazon Cognito</li>
<li>Developing the signup and login pages of the serverless store</li>
<li>Handling authorization and authentication of users in the backend</li>
</ul>
<p>By the end of this chapter, you will have acquired basic knowledge on how to handle security on AWS to build a serverless website.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Security basics</h1>
                
            
            
                
<p>One of the mantras of security experts is this: <em>don't roll your own</em>. It means you should never use in a production system any kind of crypto algorithm or security model that you developed by yourself. Always use solutions that have been highly used, tested, and recommended by trusted sources. Even experienced people may commit errors and expose a solution to attacks, especially in the cryptography field, which requires advanced math. However, when a proposed solution is analyzed and tested by a great number of specialists, errors are much less frequent.</p>
<p>In the security world, there is a term called <strong>security through obscurity</strong>. It is defined as a security model where the implementation mechanism is not publicly known, so there is a belief that it is secure because no one has prior information about the flaws it has. It can be indeed secure, but if used as the only form of protection, it is considered as a poor security practice. If a hacker is persistent enough, he or she can discover flaws even without knowing the internal code. In this case again, it's better to use a highly tested algorithm than your own.</p>
<p>Security through obscurity can be compared to someone trying to protect their own money by burying it in the backyard when the common security mechanism would be to put the money in a bank. The money can be safe while buried, but it will be protected only until someone finds about its existence and starts to look for it.</p>
<p>Due to this reason, when dealing with security, we usually prefer to use open source algorithms and tools. Everyone can access and discover flaws in them, but there are also a great number of specialists that are involved in finding the vulnerabilities and fixing them.</p>
<p>In this section, we will discuss other security concepts that everyone must know when building a system.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Information security</h1>
                
            
            
                
<p>When dealing with security, there are some attributes that need to be considered. The most important ones are the following:</p>
<ul>
<li><strong>Authentication</strong>: Confirm the user's identity by validating that the user is who they claim to be</li>
<li><strong>Authorization</strong>: Decide whether the user is allowed to execute the requested action</li>
<li><strong>Confidentiality</strong>: Ensure that data can't be understood by third-parties</li>
<li><strong>Integrity</strong>: Protect the message against undetectable modifications</li>
<li><strong>Non-repudiation</strong>: Ensure that someone can't deny the authenticity of their own message</li>
<li><strong>Availability</strong>: Keep the system available when needed</li>
</ul>
<p>These terms will be better explained in the next sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authentication</h1>
                
            
            
                
<p>Authentication is the ability to confirm the user's identity. It can be implemented by a login form where you request the user to type their username and password. If the hashed password matches what was previously saved in the database, you have enough proof that the user is who they claim to be. This model is good enough, at least for typical applications. You confirm the identity by requesting the user to provide what <em>they know</em>. Another kind of authentication is to request the user to provide what <em>they have</em>. It can be a physical device (like a dongle) or access to an e-mail account or phone number.</p>
<p>However, you can't ask the user to type their credentials for <em>every</em> request. As long as you <em>authenticate</em> it in the first request, you must create a security token that will be used in the subsequent requests. This token will be saved on the client side as a cookie and will be automatically sent to the server in allÂ requests.</p>
<p>On AWS, this token can be created using the Cognito service. How this is done will be described later in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authorization</h1>
                
            
            
                
<p>When a request is received in the backend, we need to check if the user is allowed to execute the requested action. For example, if the user wants to checkout the order with ID <kbd>123</kbd>, we need to make a query to the database to identify who is the owner of the order and compare if it is the same user.</p>
<p>Another scenario is when we have multiple roles in an application and we need to restrict data access. For example, a system developed to manage school grades may be implemented with two roles, such as <kbd>student</kbd> and <kbd>teacher</kbd>. The teacher will access the system to insert or update grades, while the students will access the system to read those grades. In this case, the authentication system must restrict the actions <em>insert</em> and <em>update</em> for users that are part of the <em>teachers</em> group and users in the <em>students</em> group must be restricted to <em>read</em> their own grades.</p>
<p>Most of the time, we handle authorization in our own backend, but some serverless services don't require a backend and they are responsible by themselves to properly check the authorization. For example, in the next chapter, we are going to see how serverless notifications are implemented on AWS. When we use AWS IoT, if we want a private channel of communication between two users, we must give them access to one specific resource known by both and restrict access to other users to avoid the disclosure of private messages. This kind of authorization will be detailed in the next chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Confidentiality</h1>
                
            
            
                
<p>In <a href="274d8aba-8e7e-4c5e-b55b-a8e1797d3057.xhtml">Chapter 4</a>, <em>Hosting the Website</em>, we learned how to use AWS Certificate Manager to request TLS certificates for free and how to add them to CloudFront distributions. Developing a website that uses HTTPS for <em>all</em> requests is the main drive to achieve confidentiality in the communication between the users and your site. As the data is encrypted, it's very hard for malicious users to decrypt and understand its contents.</p>
<p>Although there are some attacks that can intercept the communication and forge certificates (man-in-the-middle), those require the malicious user to have access to the machine or network of the victim user. From our side, adding HTTPS support is the best thing that we can do to minimize the chance of attacks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Integrity</h1>
                
            
            
                
<p>Integrity is related to confidentiality. While confidentiality relies on encrypting a message to prevent other users from accessing its contents, integrity deals with protecting the messages against modifications by encrypting messages with digital signatures (TLS certificates).</p>
<p>Integrity is an important concept when designing low level network systems, but all that matters for us is adding HTTPS support.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Non-repudiation</h1>
                
            
            
                
<p>Non-repudiation is a term that is often confused with authentication since both of them have the objective to prove who has sent the message. However, the main difference is that authentication is more interested in a technical view and the non-repudiation concept is interested in legal terms, liability, and auditing.</p>
<p>When you have a login form with user and password input, you can authenticate the user who correctly knows the combination, but you can't have 100% certain since the credentials can be correctly guessed or stolen by a third-party. On the other hand, if you have a stricter access mechanism, such as a biometric entry, you have more credibility. However, this is not perfect either. It's just a better non-repudiation mechanism.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Availability</h1>
                
            
            
                
<p>Availability is also a concept of interest in the information security field because availability is not restricted to how you provision your hardware to meet your user needs. Availability can suffer attacks and can suffer interruptions due to malicious users. There are attacks, such as <strong>Distributed Denial of Service</strong> (<strong>DDoS</strong>), that aim to create bottlenecks to disrupt site availability. In a DDoS attack, the targeted website is flooded with superfluous requests with the objective to overload the systems. This is usually accomplished by a controlled network of infected machines called a <strong>botnet</strong>.</p>
<p>On AWS, all services run under the AWS Shield service, which was designed to protect against DDoS attacks with no additional charge. However, if you run a very large and important service, you may be a direct target of advanced and large DDoS attacks. In this case, there is a premium tier offered in the AWS Shield service to ensure your website's availability even in worst case scenarios. This requires an investment of US$ 3,000 per month, and with this, you will have 24x7 support of a dedicated team and access to other tools for mitigation and analysis of DDoS attacks.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Security on AWS</h1>
                
            
            
                
<p>In this book, we use AWS credentials, roles, and policies, but security on AWS is much more than handling authentication and authorization of users. This is what we will discuss in this section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Shared responsibility model</h1>
                
            
            
                
<p>Security on AWS is based on a shared responsibility model. While Amazon is responsible for keeping the infrastructure safe, the customers are responsible for patching security updates to software and protecting their own user accounts.</p>
<p>AWS's responsibilities include the following:</p>
<ul>
<li>Physical security of the hardware and facilities</li>
<li>Infrastructure of networks, virtualization, and storage</li>
<li>Availability of services respecting <strong>Service Level Agreements</strong> (<strong>SLAs</strong>)</li>
<li>Security of managed services such as Lambda, RDS, DynamoDB, and others</li>
</ul>
<p>A customer's responsibilities are as follows:</p>
<ul>
<li>Applying security patches to the operating system on EC2 machines</li>
<li>Security of installed applications</li>
<li>Avoiding disclosure of user credentials</li>
<li>Correct configuration of access policies and roles</li>
<li>Firewall configurations</li>
<li>Network traffic protection (encrypting data to avoid disclosure of sensitive information)</li>
<li>Encryption of server-side data and databases</li>
</ul>
<p>In the serverless model, we rely only on managed services. In this case, we don't need to worry about applying security patches to the operating system or runtime, but we do need to worry about third-party libraries that our application depends on to execute. Also, of course, we need to worry about all the things that we need to configure (firewalls, user policies, and so on), the network traffic (supporting HTTPS) and how data is manipulated by the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Trusted Advisor tool</h1>
                
            
            
                
<p>AWS offers a tool named Trusted Advisor, which can be accessed through <a href="https://console.aws.amazon.com/trustedadvisor">https://console.aws.amazon.com/trustedadvisor</a>.</p>
<p>It was created to offer help on how you can optimize costs or improve performance, but it also helps identify security breaches and common misconfigurations. It searches for unrestricted access to specific ports on your EC2 machines, if Multi-Factor Authentication is enabled on the root account and if IAM users were created in your account.</p>
<p>You need to pay for AWS premium support to unlock other features, such as cost optimization advice. However, security checks are free.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Pen testing</h1>
                
            
            
                
<p>A penetration test (or pen test) is a good practice that all big websites must perform periodically. Even if you have a good team of security experts, the usual recommendation is to hire a specialized third-party company to perform pen tests and to find vulnerabilities. This is because they will most likely have tools and procedures that your team may not have tried yet.</p>
<p>However, the caveat here is that you can't execute these tests without contacting AWS first. To respect their user terms, you can only try to find breaches on your own account and assets, in scheduled time frames (so they can disable their intrusion detection systems for your assets), and only on restricted services, such as EC2 instances and RDS.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">AWS CloudTrail</h1>
                
            
            
                
<p>AWS CloudTrail is a service that was designed to record all AWS API calls that are executed on your account. The output of this service is a set of log files that register the API caller, the date/time, the source IP address of the caller, the request parameters, and the response elements that were returned.</p>
<p>This kind of service is pretty important for security analysis, in case there are data breaches, and for systems that need the auditing mechanism for compliance standards.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">MFA</h1>
                
            
            
                
<p><strong>Multi-Factor Authentication</strong> (<strong>MFA</strong>) is an extra security layer that everyone must add to their AWS root account to protect against unauthorized access. Besides knowing the user and password, a malicious user would also need physical access to your smartphone or security token, which greatly restricts the risks.</p>
<p>On AWS, you can use MFA through the following means:</p>
<ul>
<li><strong>Virtual devices</strong>: Application installed on Android, iPhone, or Windows phones</li>
<li><strong>Physical devices</strong>: Six-digit tokens or OTP cards</li>
<li><strong>SMS</strong>: Messages received on your phone</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling authentication and authorization</h1>
                
            
            
                
<p>In this section, we are going to use Amazon Cognito to create the users for our application and to be able to handle their login. After authenticating the user, we will be able to give proper authorization for the tasks that they are allowed to execute.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Amazon Cognito</h1>
                
            
            
                
<p>Cognito provides two services such as <strong>User Pools</strong> and <strong>Identity Pools</strong>. The first is where you create and store user credentials, the latter is where you set the permissions for the user to access AWS resources.</p>
<p>We will start by creating a user pool, so we can add signup and signin features to our website. We will add the user pool ID to our frontend code and requests will be done directly to the User Pool service, without needing to be executed from a Lambda function.</p>
<p>Later, we will configure an identity pool, which will be needed to give to the users temporary access to AWS resources. In our example, the user will be able to subscribe to IoT notifications directly, without requesting the backend to give this authorization.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a user pool</h1>
                
            
            
                
<p>Let's take a look at the following steps to create a user pool:</p>
<ol>
<li>To create a user pool, we will use the console, which can be accessed through <a href="https://console.aws.amazon.com/cognito">https://console.aws.amazon.com/cognito</a>. Select the Manage your User Pools option:</li>
</ol>
<div><img class="image-border" height="523" src="img/6d350df7-a3fe-417d-a42b-a7c9b00cf084.png" width="783"/></div>
<ol start="2">
<li>Click on Create a User Pool on the next screen, as shown in the following screenshot:</li>
</ol>
<div><img class="image-border" height="164" src="img/1c443303-e8fd-4c6c-bd1e-c5d081e88644.png" width="554"/></div>
<ol start="3">
<li>Now define a pool name for your user pool resource and check whether you want fast creation (using defaults) or whether you want to step through each setting. I've selected the former (Review defaults):</li>
</ol>
<div><img class="image-border" height="453" src="img/cf555eaf-d3f4-41eb-a31f-2f9f4d61fb0d.png" width="719"/></div>
<ol start="4">
<li>The next screen will be a list of defaults that you need to revise before hitting Create pool:</li>
</ol>
<div><img class="image-border" height="575" src="img/145b7121-247e-437e-a4bf-2027f705f6d2.png" width="719"/></div>
<ul>
<li>The following is a list of options and what you need to consider in each of them:
<ul>
<li>Attributes: This displays a list of user attributes that you can select as required options for login. Usually, only an e-mail is enough for most applications, but you can include attributes like username, phone number, or user picture. Also, you may set custom user attributes to be saved in your user profile.</li>
<li>Policies: This defines how strict the user's password must be. For example, if you require a minimum length, special characters, and upper or lower cases. Also, you can restrict user creation by admins only.</li>
<li>Verifications: You can request the user to verify the ownership of the e-mail address or phone number (SMS) upon registering. Cognito will send a message with a code for validation. Also, you can enable MFA for your users as a second layer of security. This feature is very important nowadays to prevent accounts being hacked and is already implemented by Cognito, making it very easy to integrate with your application. You can enable MFA by e-mail or phone.</li>
<li>Message customizations: This is related to the previous configuration where you can request users to validate their e-mails or phone numbers. The text of these messages is configurable here. Besides, you can set the e-mail messages to use your domain address, if it was already verified and configured in Amazon SES.</li>
<li>Tags: This option is useful if you want to associate the user pool with a tag that will show up in your billing data. With this option, you can create a tag with a cost center or application name for better management of cost allocation.</li>
<li>Devices: You can allow the device to be remembered for future accesses. This feature is useful as a convenience and you can also suppress MFA requests if the device has already been authenticated with MFA in the past.</li>
<li>Apps: You need to create an application specification to restrict the applications that will be able to handle the login process and handle forgotten passwords for your application. This feature creates an application key and secret.</li>
<li>Triggers: You can trigger Lambda functions in pre-signup, pre-authentication, post authentication, create authorization challenge, and other options. Basically, you can have control of server-side procedures to handle the user authentication.</li>
</ul>
</li>
</ul>
<ol start="5">
<li>After creating the user pool, you can see the assigned Pool Id and Pool ARN. Write down those values because they will be needed later:</li>
</ol>
<div><img class="image-border" height="155" src="img/fb5c1830-d1e5-4365-80c9-6ca88922ac3d.png" width="472"/></div>
<ol start="6">
<li>There is still one more thing before we complete this configuration. As we want our website to handle signup/signin, we need to create an application ID. Browse the App clients field to add an application for our website and uncheck the Generate client secret option, since this feature is not supported by the JavaScript SDK:</li>
</ol>
<div><img class="image-border" height="327" src="img/7dfe4806-0b9a-43d9-8e75-45743c2bca99.png" width="475"/></div>
<ol start="7">
<li>After creating theÂ app client, write down theÂ App client id:</li>
</ol>
<div><img class="image-border" height="241" src="img/3f50673c-0234-4f38-a1c9-7c29d19c0f55.png" width="507"/></div>
<p>Â </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an identity pool</h1>
                
            
            
                
<p class="CDPAlignLeft CDPAlign">Now we are going to create an identity pool. Let's take a look in the following steps:</p>
<ol>
<li>The first step is to browse to the Federated Identities page that can be found in Cognito home or from the user pool that we have just created:</li>
</ol>
<div><img class="image-border" height="135" src="img/bae88957-e920-428e-bcf5-63d1f17ef604.png" width="311"/></div>
<ol start="2">
<li>When creating a new identity pool, check the box Enable access to unauthenticated identities. We will configure later what resources an unsigned user can access, which will be different to the level of access that a signed user can have. Take a look at the following screenshot:</li>
</ol>
<div><img class="image-border" height="530" src="img/ba01fc26-87ff-4b04-824f-10569dcb2ec0.png" width="732"/></div>
<ol start="3">
<li>The next field is to set the Authentication providers parameter. Cognito Identity Pool is an <em>authorization</em> service that needs to receive as input the users from an <em>authentication</em> service. In our example, we will use the Cognito User Pool that we have just created by filling out the User Pool ID and the App Client ID fields, but if you want, you can add support for other providers as well, such as Facebook, Google+, or Twitter:</li>
</ol>
<div><img class="image-border" height="458" src="img/5308f479-2279-4520-96d2-6f66a47efb60.png" width="729"/></div>
<ol start="4">
<li>Now we need to configure the access of our authenticated and unauthenticated users. As an example, we could allow access to a folder of a S3 bucket to allow the user to directly upload photos from the website, without needing the backend to execute this action. In our serverless store, we need to handle notifications with IoT. So that's what we are going to configure next:</li>
</ol>
<div><img class="image-border" height="391" src="img/71a8de15-4c10-49fa-9140-668ec87a5bfb.png" width="431"/></div>
<ol start="5">
<li>You will need to edit the Policy Document option for both types (unauthenticated and authenticated). Start modifying the document for authenticated users:</li>
</ol>
<pre>
        {<br/>          "Version": "2012-10-17",<br/>          "Statement": [<br/>            {<br/>              "Effect": "Allow",<br/>              "Action": [<br/>                "mobileanalytics:PutEvents",<br/>                "cognito-sync:*",<br/>                "cognito-identity:*"<br/>              ],<br/>              "Resource": ["*"]<br/>            },<br/>            {<br/>              "Effect": "Allow",<br/>              "Action": [<br/>                "<strong>iot:Connect</strong>",<br/>                "<strong>iot:AttachPrincipalPolicy</strong>"<br/>              ],<br/>              "Resource": ["<strong>*</strong>"]<br/>            },<br/>            {<br/>              "Effect": "Allow",<br/>              "Action": ["<strong>iot:Subscribe</strong>"],<br/>              "Resource": [<br/><strong>               "arn:aws:iot:&lt;region&gt;:&lt;account&gt;:topicfilter/&lt;public-topic&gt;",<br/>               "arn:aws:iot:&lt;region&gt;:&lt;account&gt;:topicfilter/&lt;private-topic&gt;"</strong><br/>              ]<br/>            },<br/>            {<br/>              "Effect": "Allow",<br/>              "Action": [<br/><strong>                "iot:Publish",</strong><br/><strong>                "iot:Receive"</strong><br/>              ],<br/>              "Resource": [<br/><strong>                "arn:aws:iot:&lt;region&gt;:&lt;account&gt;:topic/&lt;public-topic&gt;",<br/>                "arn:aws:iot:&lt;region&gt;:&lt;account&gt;:topic/&lt;private-topic&gt;"</strong><br/>              ]<br/>            }<br/>          ]<br/>        }
</pre>
<div><kbd>iot:Connect</kbd> and <kbd>iot:AttachPrincipalPolicy</kbd> requires access to every resource (<kbd>*</kbd>), while we need to restrict the <kbd>iot:Subscribe</kbd> to a <kbd>topicfilter/&lt;topic&gt;</kbd> resource and the <kbd>iot:Publish</kbd> and <kbd>iot:Receive</kbd> to a <kbd>topic/&lt;topic&gt;</kbd>.</div>
<ol start="6">
<li>When building the ARNs, replace the <kbd>&lt;region&gt;</kbd> with the region of the AWS IoT that you are going to use, <kbd>&lt;account&gt;</kbd> with your Account ID, <kbd>&lt;public-topic&gt;</kbd> with <kbd>serverless-store-comments</kbd> and <kbd>&lt;private-topic&gt;</kbd> with <kbd>serverless-store-${cognito-identity.amazonaws.com:sub}</kbd>. The private topic will allow the authenticated user to access a topic defined by their federated identity.</li>
<li>For unauthenticated access, use the same policy document, but remove the extra ARN that was added for the private topic. You can also remove the <kbd>iot:AttachPrincipalPolicy</kbd> since it will not be necessary for unauthenticated users.</li>
</ol>
<ol start="8">
<li>After creating the identity pool, go to the Dashboard option and click on Edit identity pool. You will see the Identity pool ID option in this screen. Write it down because it will be needed later:</li>
</ol>
<div><img class="image-border" height="235" src="img/c410e65d-ea69-4b0c-80e1-4deba79b7d60.png" width="508"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Cognito in our serverless store</h1>
                
            
            
                
<p>Now we are going to integrate our React frontend with Cognito to implement the signup and login pages. The authentication methods will be done directly with Cognito, without using a Lambda function for this. To make this work, we need to configure our React application:</p>
<ol>
<li>First, install the module <kbd>amazon-cognito-identity-js</kbd> in our frontend folder by running the following command:</li>
</ol>
<pre>
<strong>      npm install amazon-cognito-identity-js --save</strong>
</pre>
<ol start="2">
<li>Inside the <kbd>lib</kbd> folder, create a <kbd>config.js</kbd> file to store our Cognito IDs:</li>
</ol>
<pre>
        export default {<br/>          "cognito": {<br/>            "USER_POOL_ID": "YOUR_USER_POOL_ID",<br/>            "APP_CLIENT_ID": "YOUR_APP_CLIENT_ID",<br/>            "IDENTITY_POOL_ID": "YOUR_IDENTITY_POOL_ID",<br/>            "REGION": "YOUR_COGNITO_REGION"<br/>          }<br/>        };
</pre>
<p>Â </p>
<ol start="3">
<li>As we did in previous chapters, we have created a <kbd>services.js</kbd> file inside the <kbd>lib</kbd> folder to make all Ajax requests. We need to import the following from the Cognito module:</li>
</ol>
<pre>
        import {<br/>          AuthenticationDetails,<br/>          CognitoUser,<br/>          CognitoUserAttribute,<br/>          CognitoUserPool<br/>        } from 'amazon-cognito-identity-js';
</pre>
<p>Now we have prepared our frontend to use Cognito.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Signup page</h1>
                
            
            
                
<p>The signup form was created in <a href="6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml">Chapter 5</a>, <em>Building the Frontend</em>, and it has the appearance as shown in the this screenshot:</p>
<div><img class="image-border" height="340" src="img/38ca87f0-c359-426c-97fc-3e2937aff779.png" width="521"/></div>
<p>We are going to implement the handler for the Signup button by performing the following steps:</p>
<ol>
<li>We start by creating a method in our <kbd>services.js</kbd> file that will execute a request to Cognito, invoking the <kbd>signUp</kbd> function that will use the e-mail and password provided by the form:</li>
</ol>
<pre>
        signup(email, password, callback) {<br/>          const userPool = new CognitoUserPool({<br/>            UserPoolId: config.cognito.USER_POOL_ID,<br/>            ClientId: config.cognito.APP_CLIENT_ID<br/>          });<br/><br/>          const attributeEmail = [<br/>            new CognitoUserAttribute({ <br/>              Name: 'email', <br/>              Value: email <br/>            })<br/>          ];<br/><br/><strong>          userPool.signUp</strong>(email, <br/>                          password, <br/>                          attributeEmail,<br/>                          null, <br/>                          callback);<br/>        }
</pre>
<ol start="2">
<li>The <kbd>App</kbd> component will call this function and it will save the resulting user object in its state:</li>
</ol>
<pre>
        handleSignup(email, password) {    <br/>          Services.signup(email, password, (err, res) =&gt; {<br/>            if (err) alert(err);<br/>            else <strong>this.setState({newUser: res.user})</strong>;<br/>          });<br/>        }
</pre>
<ol start="3">
<li>After registering the user successfully, we need to re-render the signup component to display a confirmation request. The user will be asked to fill the text input with the value sent to their e-mail:</li>
</ol>
<div><img class="image-border" height="328" src="img/e57e23bc-c4fc-47ba-b592-11e35a82d889.png" width="622"/></div>
<ol start="4">
<li>The request to Cognito will use the same <kbd>user</kbd> object that was returned in the signup result:</li>
</ol>
<pre>
        confirmSignup(newUser, code, callback) {<br/><strong>          newUser.confirmRegistration(code, true, callback);</strong><br/>        }
</pre>
<ol start="5">
<li>If the confirmation code is correct, we can use the e-mail and password that the user has provided and authenticate his access, without asking the user to type them again.</li>
</ol>
<p>How to authenticate will be defined in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Login page</h1>
                
            
            
                
<p>Implementing the Login page to authenticate users requires a few steps. Let's see how this is done by performing the following steps:</p>
<ol>
<li>The Login page was also created in <a href="6cb9ccdc-61f3-437d-81ac-d05ec652f1a4.xhtml">Chapter 5</a>, <em>Building the Frontend</em> and it has this look:</li>
</ol>
<div><img class="image-border" height="371" src="img/46df45d0-e6b3-4986-8608-18f47145a2a5.png" width="673"/></div>
<ol start="2">
<li>The <kbd>Login</kbd> button will trigger a request to Cognito defined in the <kbd>services.js</kbd> file:</li>
</ol>
<pre>
        login(email, password) {<br/>          const userPool = new CognitoUserPool({<br/>            UserPoolId: config.cognito.USER_POOL_ID,<br/>            ClientId: config.cognito.APP_CLIENT_ID<br/>          });<br/><br/>          const user = new CognitoUser({ <br/>            Username: email, <br/>            Pool: userPool <br/>          });<br/><br/>          const authenticationData = {<br/>            Username: email,<br/>            Password: password<br/>          };<br/><br/>          const authDetails = <br/>            new AuthenticationDetails(authenticationData);<br/><br/>          return new Promise((resolve, reject) =&gt; {<br/><strong>            user.authenticateUser(authDetails, {<br/>              onSuccess: (res) =&gt; <br/>                resolve(res.getIdToken().getJwtToken()),<br/>              onFailture: (err) =&gt; reject(err)<br/>            });<br/></strong>          });<br/>        }
</pre>
<ol start="3">
<li>This <kbd>login</kbd> function will be used by the <kbd>App</kbd> component. After signing successfully, we need to save <kbd>userToken</kbd> in the state of <kbd>App</kbd>:</li>
</ol>
<pre>
        handleLogin(email, password) {<br/>          Services.login(email, password)<br/>            .then(res =&gt; {<br/><strong>              this.setState({userToken: res});</strong><br/>            })<br/>            .catch(err =&gt; {<br/>              alert(err);<br/>            });<br/>        }
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Persisting the user token</h1>
                
            
            
                
<p>Fortunately, the Cognito SDK will persist the user token automatically in the browser local storage. If the user browses your website again before the token expiration, the data will be there, available, without the need to request the user to type the e-mail/password again.</p>
<p>This token can be retrieved with the following code:</p>
<pre>
    getUserToken(callback) {<br/>    <br/>      const userPool = new CognitoUserPool({<br/>        UserPoolId: config.cognito.USER_POOL_ID,<br/>        ClientId: config.cognito.APP_CLIENT_ID<br/>      });<br/>      <br/>      const currentUser = userPool.getCurrentUser();<br/><br/>      if (currentUser) {<br/><strong>        currentUser.getSession((err, res) =&gt; {</strong><br/><strong>          if (err) <br/>            callback(err);</strong><br/><strong>          else <br/>            callback(null, res.getIdToken().getJwtToken());</strong><br/><strong>        });<br/></strong>      } else {<br/>        callback(null);<br/>      }<br/>    }
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Logging out</h1>
                
            
            
                
<p>As the user token is being persisted, we can check its existence in the <kbd>App</kbd> initialization (<kbd>componentDidMount</kbd>) and display a Logout button instead of a Login button in the navigation bar:</p>
<div><img class="image-border" height="395" src="img/23081903-1f51-4f03-9bf4-98e5b23be6fd.png" width="509"/></div>
<p>When clicking in this Logout button, we can clear the token executing the following code:</p>
<pre>
    handleLogout() {<br/>      const userPool = new CognitoUserPool({<br/>        UserPoolId: config.cognito.USER_POOL_ID,<br/>        ClientId: config.cognito.APP_CLIENT_ID<br/>      });<br/><br/>      const currentUser = userPool.getCurrentUser();<br/>      if (currentUser !== null) {<br/><strong>        currentUser.signOut();</strong><br/>      }<br/><br/><strong>      this.setState({userToken: null});</strong><br/>    }
</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Handling authentication in Lambda functions</h1>
                
            
            
                
<p>API Gateway has a nice integration with Cognito Pools for user authentication. We can configure it through the Serverless Framework to retrieve the user data from Cognito whenever a request with a token ID is provided. Let's see how this is done by executing the following steps:</p>
<ol>
<li>Modify the <kbd>serverless.yml</kbd> file to use the Cognito User Pool authorizer:</li>
</ol>
<pre>
        functions:<br/>          products:<br/>            handler: functions/products.handler<br/>            events:<br/>              - http:<br/><strong>                  method: POST</strong><br/><strong>                  path: cart</strong><br/><strong>                  authorizer:</strong><br/><strong>                    arn: YOUR_COGNITO_USER_POOL_ARN</strong><br/>              - http: OPTIONS cart
</pre>
<ol start="2">
<li>Include <kbd>Authorization</kbd> as a valid header when the Lambda function answer an <kbd>OPTIONS</kbd> request:</li>
</ol>
<pre>
        "Accept-Control-Allow-Headers":<br/>          "Accept, <strong>Authorization</strong>, Content-Type, Origin"
</pre>
<ol start="3">
<li>Deploy the backend again by running the following command:</li>
</ol>
<pre>
<strong>      serverless deploy</strong>
</pre>
<ol start="4">
<li>Modify the frontend to always include theÂ <kbd>userToken</kbd>, if it is available, in an <kbd>Authorization</kbd> header by executing the following code:</li>
</ol>
<pre>
        headers: {<br/><strong>          "Authorization": userToken</strong><br/>        }
</pre>
<ol start="5">
<li>Now we have access to the user information in the backend. If we analyze the <kbd>event</kbd> object, we can retrieve the <kbd>userId</kbd> variable by executing the following code:</li>
</ol>
<pre class="mce-root">
        module.exports.handler = (event, context, callback) =&gt; {<br/><br/>          let userId = null;<br/><br/>          if (event.requestContext.authorizer)<br/><strong>            userId = event.requestContext.authorizer.claims.sub;</strong><br/> <br/>          // ...<br/>        }
</pre>
<p style="padding-left: 60px">The <kbd>userId</kbd> term is a <strong>Universally Unique Identifier</strong> (<strong>UUID</strong>). An example of <kbd>userId</kbd> is as follows:</p>
<pre>
<strong>        b90d0bba-0b65-4455-ab5a-f30477430f46</strong>
</pre>
<p>The <kbd>claims</kbd> object offers more user data, like the e-mail, using the <kbd>email</kbd> property.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have discussed the basic security concepts and how to apply them in a serverless project. For our demo application, we have used Amazon Cognito to handle the authentication and authorization of users, so you have learned how to implement signup, signin, and logout features.</p>
<p>In the next chapter, we will use the Cognito credentials to access AWS IoT resources to handle serverless notifications. We will see how the backend can send messages to an authenticated user and how to provide real-time notifications to anonymous users.</p>


            

            
        
    </body></html>