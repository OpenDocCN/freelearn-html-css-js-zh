<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Building a Chat Application</h1></div></div></div><p>So far, all the applications that we've built have used plain old Backbone. This isn't to say that we haven't used <a id="id338" class="indexterm"/>helper libraries, but that we haven't yet used any libraries that extend Backbone itself. However, such libraries do exist; the Backbone GitHub wiki has a whole list of them (<a class="ulink" href="https://github.com/jashkenas/backbone/wiki/Extensions%2C-Plugins%2C-Resources">https://github.com/jashkenas/backbone/wiki/Extensions%2C-Plugins%2C-Resources</a>). In this chapter, we'll use one of these libraries to make building this application a little simpler.</p><p>We'll be focusing on the following ideas:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using a third-party library to make large applications easier to handle</li><li class="listitem" style="list-style-type: disc">Doing real-time communication between the server and the client</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Outlining the application</h1></div></div></div><p>Before <a id="id339" class="indexterm"/>we get started, let's define exactly what it is we're going to build. It will be an online chat application; a user will go to the website, choose a screen name, choose a room, and chat with other members in the room. There won't be real user accounts; you join by simply giving a name, kind of like a simpler version of IRC. If someone else is using that name, you'll have to choose another. Users will also be able to create new rooms.</p><p>We will be using a few new tools in this chapter: Socket.IO and Marionette. <strong>Socket.IO</strong><a id="id340" class="indexterm"/> (<a class="ulink" href="http://socket.io">http://socket.io</a>) is a real-time communication library that allows the client to talk to the server quickly and easily. Think of it as a publish and subscribe system (like Backbone's <code class="literal">trigger</code> and <code class="literal">listenTo</code> methods) between the client and the server; you can read more about that design pattern on Wikipedia (<a class="ulink" href="https://en.wikipedia.org/wiki/Publish_and_subscribe">https://en.wikipedia.org/wiki/Publish_and_subscribe</a>). We'll use this to make the live aspect of our chat application a lot easier to write.</p><p>
<strong>Marionette</strong> (<a class="ulink" href="http://marionettejs.com">http://marionettejs.com</a>), <a id="id341" class="indexterm"/>however, is a little more interesting. It bills itself as a composite application library for Backbone.js that aims to simplify the construction of large scale JavaScript applications. Here's the idea; as you may have noticed from all the previous chapters, a lot of the code that we write in Backbone applications is repeated<a id="id342" class="indexterm"/> in each application. For example, we have views for both models and collections. Often, the collection view will loop over the models in the collection and render a model view for each of them, putting them in a container element. As this is a common pattern, Marionette wraps all this up for us and allows us to write just a few lines to do it all. However, Marionette also offers other tools that make managing large applications a little easier. We'll look at a bunch of these in this chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Setting up the application</h1></div></div></div><p>We <a id="id343" class="indexterm"/>have to begin this application with a bit of server-side code. We will use Express as our primary server; however, we also want to use Socket.IO, so we have to set it up. Copy the template to start the new project. Then, in the project directory, go ahead and install all our packages and then Socket.IO with npm as follows:</p><div><pre class="programlisting">
<strong>npm install</strong>
<strong>npm install socket.io --save</strong>
</pre></div><p>Now, to get Express and Socket.IO to play together nicely, we need to do things a bit differently in our <code class="literal">server.js</code> file. First, we require the <code class="literal">http</code> library of Node.js and <code class="literal">socket.io</code>. Here's how:</p><div><pre class="programlisting">var http = require('http');
var socketio = require('socket.io');</pre></div><p>Then, we have to wrap our Express application (the <code class="literal">app</code> object) in a Node.js server object as follows:</p><div><pre class="programlisting">var server = http.createServer(app);</pre></div><p>Now we have a server. The final step to getting things working with Socket.IO is to create a Socket.IO instance that listens to our server. We do that this way:</p><div><pre class="programlisting">var io = socketio.listen(server);</pre></div><p>Currently in the <code class="literal">server.js</code> file, you'll have the code that calls the <code class="literal">app.listen</code> function. However, as we're now wrapping our Express app in a Node.js server object, we need to call <code class="literal">listen</code> on that. So remove the <code class="literal">app.listen</code> call, and replace it with the following code:</p><div><pre class="programlisting">server.listen(3000);</pre></div><p>At this point, you should be able to boot up the server (<code class="literal">npm start</code>) and go to <code class="literal">http://localhost:3000</code> and get our blank page.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Preparing our template</h1></div></div></div><p>The<a id="id344" class="indexterm"/> next step takes us into the <code class="literal">views/index.ejs</code> file. Marionette, of course, is a client library, but Socket.IO has a client component too; so we'll need to add script tags for both of them. Put these just below the tag for <code class="literal">backbone.js</code>:</p><div><pre class="programlisting">&lt;script src="img/backbone.marionette.js"&gt;&lt;/script&gt;
&lt;script src="img/socket.io.js"&gt;&lt;/script&gt;</pre></div><p>Socket.IO on the backend will send the right file to that route, even though we never put <code class="literal">socket.io.js</code> in place. However, we do need to download Marionette. If you head over to the Marionette downloads page (<a class="ulink" href="http://marionettejs.com/#download">http://marionettejs.com/#download</a>), you'll see there are a few versions available. The Marionette library uses two main components: <code class="literal">Backbone.Wreqr</code> and <code class="literal">Backbone.BabySitter</code> (both have been built by the same good folks who made Marionette). You can download Wreqr, BabySitter, and Marionette separately, or you can get them bundled together. Make sure you download the bundled version and place it in the <code class="literal">public</code> directory.</p><p>Also, we will split our application into many smaller pieces and place them in their own files, similar to how we've done in the previous two chapters. For each file we make, you would want to add a script tag for it to the <code class="literal">views/index.ejs</code> file. In this case, the order will matter, and we'll see why that is and how to order them correctly.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec51"/>A word about Socket.IO</h1></div></div></div><p>Socket.IO <a id="id345" class="indexterm"/>makes<a id="id346" class="indexterm"/> it really easy to send data back and forth between the server and the client. As we've seen, this is one of the most important parts of Backbone; sending our models to and from the server. It would be relatively easier to replace the <code class="literal">Backbone.sync</code> function (as we did in <a class="link" href="ch02.html" title="Chapter 2. Building a Photo-sharing Application">Chapter 2</a>, <em>Building a Photo-sharing Application</em>) with an implementation that uses Socket.IO. For example, we might do something like what is shown in the following code:</p><div><pre class="programlisting">var SOCKET = io.connect('http://localhost:3000');

Backbone.sync = function (method, model, options) {
  var success = function (data) {
    if (options.success) options.success(data, null, null);
    model.trigger('sync', model, data, options);
  };

  var data;
  if (method === 'create' || method === 'update') {
    data = model.toJSON();
  } else {
    data = { id: model.get('id') };
  }
  socket.emit(method, data, success);
};</pre></div><p>If you haven't used Socket.IO before, this code won't make much sense just yet; but look at this again towards the end of the chapter and it should be clear. While we could write a Backbone application using Socket.IO this way, that's not the way we're going to be doing it here. To the get the live aspect of our chat application, we can't use the regular Backbone methods that talk to the server, such as <code class="literal">save</code> and <code class="literal">create</code>; we'll need to take things into our own hands. Part of the beauty of Backbone is that this will work out fine; if we decide to use Backbone to build an application that doesn't really fall within its <em>normal</em> usage, there's no extra friction from Backbone. However, you should know that you can use Socket.IO to do the syncing of a normal Backbone application.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec52"/>Creating modules</h1></div></div></div><p>Almost <a id="id347" class="indexterm"/>all of our code in this chapter will be put into modules, which Marionette will provide for us. But we need to start with some application preparation code. Previously, we've seen how we can put all the components of our application in a single global variable. Marionette takes this a step further by giving us an <code class="literal">Application</code> class; it's more than just an object onto which we can hang our own classes. As you'll see, it provides a lot of other interesting features.</p><p>So we start in the usual <code class="literal">app.js</code> file. Here's the code that we'll put in that file for starters:</p><div><pre class="programlisting">_.templateSettings = {
  interpolate: /\{\{(.+?)\}\}/g
};

var App = new Backbone.Marionette.Application();
App.on('initialize:after', function () {
  Backbone.history.start({ pushState: true });
});</pre></div><p>We're already familiar with template settings for Underscore, so the other lines are what you should focus on. The first line is how we create our single global variable for our application. All the special classes and components that Marionette gives us are available through the <code class="literal">Backbone.Marionette</code> namespace, and here, we will create an instance of the <code class="literal">Backbone.Marionette.Application</code>.</p><p>The way a<a id="id348" class="indexterm"/> Marionette application object works is that we'll eventually start up the application with <code class="literal">App.start()</code>. When we do that, any initializers we have added (with the <code class="literal">App.addInitializer</code> method) to the application will be run. We haven't added any initializers yet, but we will later.</p><p>In the final part of that code, we're listening for the <code class="literal">initialize:after</code> event. Marionette fires many different events at many points in the life of an application, and this is one of them. As you probably suspect, this event is fired after all the initializers we set up have been run. Once the application is initialized, we can start the router by starting Backbone's history mechanism, as we've done before.</p><p>Now that we have a basic application object, we can create modules. In general, in any programming language or library, modules are a way of grouping related code into one piece; the internals are kept hidden, and only the pieces we choose can be accessed from outside the module. This is exactly how Marionette uses them.</p><p>Our first module will be very simple; it's the Socket module. The file will be <code class="literal">public/socket.js</code>. The following is the code for this file:</p><div><pre class="programlisting">App.module('Socket', function (Socket) {
  Socket.io = io.connect('http://localhost:3000');
});</pre></div><p>This is the Marionette way of creating a module. We call the <code class="literal">App.module</code> method; it takes two parameters. The first is the name of the module. The module will be made available as a property of our <code class="literal">App</code> object by this name. As we call it <code class="literal">Socket</code> here, we'll be able to access this module in other places through <code class="literal">App.Socket</code>.</p><p>The second parameter is a function; of course, in this function we create the module. You might expect that whatever object we return from this function becomes our module, but that's not actually how it works. Instead, the <code class="literal">App.module</code> function<a id="id349" class="indexterm"/> will pass a parameter to our function; we will call it <code class="literal">Socket</code> as well. This is the object that will become our property. Anything we make a property of that object will be accessible from the <code class="literal">App</code> object. So in all our other modules, we can call the <code class="literal">App.Socket.io</code> property. However, what exactly is this property that we've just created?</p><p>The script that we added to the <code class="literal">index.ejs</code> file will give us a global <code class="literal">io</code> object that we can work with. We create our connection by calling the <code class="literal">connect</code> method and passing it the URL to which<a id="id350" class="indexterm"/> we want to connect. Since we're running our local server on port 3000, this is the path we connect to; if you were to use this in a public application, you'll want to put the public URL for your application in there. So this is our connection object, and as we just saw, we'll be able to access it from other modules.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Creating users</h1></div></div></div><p>Next, <a id="id351" class="indexterm"/>we'll create users. Unlike some of our previous applications, these aren't user accounts that users can log into. Instead, a user is just someone who is currently using our chat application; all they need to provide is a screen name. So a collection of users is really just a list of currently used screen names.</p><p>So, create a <code class="literal">public/user.js</code> file and start with the following code:</p><div><pre class="programlisting">App.module('User', function (User) { 
  var UserModel = Backbone.Model.extend({});

  User.Collection = Backbone.Collection.extend({
    model: UserModel,
    initialize: function () {
      var thiz = this;
      App.Socket.io.on('user:join', function (user) {
        thiz.add(user);
      });

      App.Socket.io.on('user:leave', function (user) {
        thiz.findWhere(user).destroy();
      });
    }
  });
});</pre></div><p>Here's how we start. First, we create a basic <code class="literal">UserModel</code> class (we can't just call it <code class="literal">User</code> because that would overwrite our module variable). Then, we create a collection class. As we've done before, we give it the model class. Things begin to get interesting in the collection's <code class="literal">initialize</code> function. Remember, we're not using the normal channels for communicating with the server here, so, we need to set up a way to discover when other users join or leave the site. We'll use Socket.IO on the server to emit a <code class="literal">user:join</code> event whenever a user joins the site; the event will send the new user's data to the client, which is an object with a name property, such as <code class="literal">{ name: 'Andrew' }</code>. We can listen for this event with <code class="literal">App.Socket.io.on</code>; this method takes the name of the event we're listening for and a function that will be run each time the event occurs. As you can see, each time a user joins, we'll add that user to the collection.</p><p>We also need<a id="id352" class="indexterm"/> to know when a user leaves. We'll listen for the <code class="literal">user:leave</code> event; when this happens, we'll use the collection's <code class="literal">findWhere</code> method to find that <code class="literal">UserModel</code> instance, and then destroy it, removing it from the collection. A Backbone collection's <code class="literal">findWhere</code> method will return the first model that matches the attributes hash we pass to it. Since we'll make sure that each name is unique on the server side, we can be sure we're destroying the right user.</p><p>One last thing to point out is that we will keep the <code class="literal">UserModel</code> class local to the module, but we will make the <code class="literal">Collection</code> class public by putting it on the <code class="literal">User</code> object. This is because we will never need to use the model class directly (only through the collection), so we can keep it hidden. There's no need to give the code outside this module access to more functionality from within this module than we need to.</p><p>Now that we've created our model and collection classes, let's make views for them. These views go in the <code class="literal">User</code> module too. The views look like this:</p><div><pre class="programlisting">var ItemView = Backbone.Marionette.ItemView.extend({
  tagName: 'li', 
  template: '#user'
});

User.CollectionView = Backbone.Marionette.CollectionView.extend({
  tagName: 'ul',
  itemView: ItemView
});</pre></div><p>Here, we're using two of the handy view classes that Marionette gives us: <code class="literal">Backbone.Marionette.ItemView</code> and <code class="literal">Backbone.Marionette.CollectionView</code>. We commonly create views specifically to render individual models or collections, and these classes wrap up that common code for us. First, we create an <code class="literal">ItemView</code> class. The only properties we need to give it are <code class="literal">tagName</code> and <code class="literal">template</code>. These are both properties that we usually use; however, you'll notice something different about the <code class="literal">template </code>attribute. Instead of getting the template text via jQuery and using Underscore to convert it to a template function, all we have to do is set the template to a selector string. Here, we will set it to <code class="literal">#user</code>. Of course, we'll put this template in the <code class="literal">index.ejs</code> file, with the following lines of code:</p><div><pre class="programlisting">&lt;script type='text/template' id='user'&gt;
  {{ name }}x
&lt;/script&gt;</pre></div><p>A simple template for sure. However, it shows how the extensions that Marionette provides can make complex applications simpler.</p><p>The <code class="literal">User.CollectionView</code> is even simpler. We don't have to give it a <code class="literal">tagName</code>, but we can, and as our <code class="literal">ItemView</code> instances are list items, it makes sense to make the elements of <code class="literal">CollectionView</code> a list. <a id="id353" class="indexterm"/>Then, we only have to say what <code class="literal">itemView</code> is. In our case, this is the <code class="literal">ItemView</code> class we just created. The way a <code class="literal">Marionette.CollectionView</code> works is that it will loop over the collection, create an <code class="literal">itemView</code> for each item, and append it to the collection's element.</p><p>So that's our first module. We'll be creating several more modules in this application, but the <code class="literal">User</code> module is a good example of a typical Marionette module.</p><p>We've created three files here (<code class="literal">app.js</code>, <code class="literal">socket.js</code>, and <code class="literal">users.js</code>), so let's add them to the <code class="literal">index.ejs</code> file. Make sure that <code class="literal">app.js</code> comes first. We will add the three files using the following code:</p><div><pre class="programlisting">&lt;script src="img/app.js"&gt;&lt;/script&gt;
&lt;script src="img/socket.js"&gt;&lt;/script&gt;
&lt;script src='/users.js'&gt;&lt;/script&gt;</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Building the layout</h1></div></div></div><p>The next <a id="id354" class="indexterm"/>step is the layout. This isn't something we've done in the previous applications, but it is something that Marionette gives us. This functionality allows us to organize and manipulate the many views we'll have on screen at once. In a large application, this can get tricky, and Marionette has two classes that make this simpler: <code class="literal">Region</code> and <code class="literal">Layout</code>. A region is basically an area of the screen, an object we can use to easily show and hide views or layouts. A layout is basically a group of regions.</p><p>We're going to create a <code class="literal">Layout</code> module for our layout classes. The following is the whole of our <code class="literal">public/layout.js</code> file:</p><div><pre class="programlisting">App.module('Layout', function (Layout, App) {
  Layout.Layout = Backbone.Marionette.Layout.extend({
    template: '#appLayout',
    regions: {
      users: '#users',
      rooms: '#rooms',
      conversation: '#conversation',
      controls: '#controls' 
    }
  });

  Layout.MainRegion = Backbone.Marionette.Region.extend({
    el: '#main'
  });
});</pre></div><p>The first <a id="id355" class="indexterm"/>class is the layout for our application. Think of it as a view class but with no model or collection to display. Instead, it gives us access to several regions. Just like with the <code class="literal">ItemView</code>, the <code class="literal">template</code> property is a selector for the template. The template is as follows:</p><div><pre class="programlisting">&lt;script type='text/template' id='appLayout'&gt;
  &lt;div id='users'&gt;&lt;/div&gt;
  &lt;div id='conversation'&gt;&lt;/div&gt;
  &lt;div id='rooms'&gt;&lt;/div&gt;
  &lt;div id='controls'&gt;&lt;/div&gt;
&lt;/script&gt;</pre></div><p>As you can see, we have four main areas, and these are the regions. We have a list of users, a list of rooms, the actual chat conversation, and a controls area where the user will log in and type in their message. In our <code class="literal">Layout</code> class, we have a <code class="literal">regions</code> property, which defines what the regions of our layout are. Each one is a selector, pointing to each of the four <code class="literal">&lt;div&gt;</code> elements in our template. When we create an instance of this <code class="literal">Layout</code> class, we'll be able to control the content of each of these regions individually.</p><p>After that comes the <code class="literal">MainRegion</code> class, which is a <code class="literal">Marionette Region</code>. This time, instead of setting a <code class="literal">tagName</code>, we will set the <code class="literal">el</code> property. When we do this, the class will use an existing DOM element instead of creating a new one. This is simply a region within which we will render our layout. In fact, this is our next step; to make our <code class="literal">App</code> object aware of this main region. In <code class="literal">app.js</code>, we need to add a call to the <code class="literal">addInitialize</code> method we discussed earlier. This can be done as follows:</p><div><pre class="programlisting">App.addInitializer(function () {
  App.addRegions({
    main: App.Layout.MainRegion
  });
});</pre></div><p>Our <code class="literal">App</code> object has an <code class="literal">addRegions</code> method that takes an object as a parameter. The property names are the names of the regions, and the value is the region class we're using. Here, we will <a id="id356" class="indexterm"/>create a single region, <code class="literal">main</code>, with our <code class="literal">MainRegion</code> class. Notice how, since we assigned <code class="literal">main</code> as a property of <code class="literal">Layout</code> in <code class="literal">layout.js</code>, we can access it via <code class="literal">App.Layout.MainRegion</code>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Starting the router</h1></div></div></div><p>Without<a id="id357" class="indexterm"/> a doubt, the most complex part of this chapter's application is the router, and with more advanced applications, this will often be the case. Due to this, Marionette's recommended pattern is to split the functionality of the Backbone router into two parts. The first part is still called the router; its job is to decide what should be done based on the current route. Then, there's the controller that actually performs the action decided upon by the router. Marionette has the <code class="literal">Marionette.AppRouter</code> class for the routing functionality. Interestingly, Marionette provides no framework for the controller. All that's required is a basic object with the right methods. We will create a constructor function and place all our methods on the prototype. So, let's create <code class="literal">router.js</code> within <code class="literal">public</code> and get started.</p><p>As Marionette recommends shifting most of the traditional Backbone router's work to the controller, the router itself is very minimal. Here's how it starts:</p><div><pre class="programlisting">App.module('Router', function (Router) {
  var Router = Backbone.Marionette.AppRouter.extend({
    initialize: function () {
      App.layout = new App.Layout.Layout();
      App.main.show(App.layout);
    },
    appRoutes: {
      '': 'index'
    }
  });
});</pre></div><p>We wrap this in a <code class="literal">Router</code> module. Then, we use Marionette's <code class="literal">AppRouter</code> class; as in many other Backbone classes, we create an <code class="literal">initialize</code> function that will run when we create our router instance. This is where we render our layout. We create a new instance of our <code class="literal">Layout</code> class and pass it to the <code class="literal">main</code> region's <code class="literal">show</code> method. As you'll see in the controller, this is the Marionette way of rendering layouts and views. we never call the <code class="literal">render</code> method ourselves. Instead, we pass a layout or view instance to a region's <code class="literal">show</code> method.</p><p>Also, notice that we're making our layout instance a property on our <code class="literal">App</code> module: <code class="literal">App.layout</code>. This is how we'll access our four regions from within the controller using <code class="literal">App.layout.users</code> or <code class="literal">App.layout.controls</code>. As these are regions, they will have the <code class="literal">show</code> method, to which we can pass the views we want to render.</p><p>Finally, instead <a id="id358" class="indexterm"/>of a <code class="literal">routes</code> property, our <code class="literal">AppRouter</code> will have an <code class="literal">appRoutes</code> property. This works just like the <code class="literal">routes</code> method of a normal router, except that the methods we call will be in the controller instead of on the router itself. We will start with a simple <code class="literal">index</code> route.</p><p>Now, let's start with the controller. This also goes inside the <code class="literal">Router</code> module that we've created. The controller can be started like this:</p><div><pre class="programlisting">function Controller () {
  this.users = new App.User.Collection();
}
Controller.prototype.index = function () {
  App.layout.users.show(new App.User.CollectionView({
    collection: this.users
  }));
};</pre></div><p>There's a lot more to come, but this is what we can do right now with the code we've already written. In the constructor function, we'll create a <code class="literal">users</code> property. This is the collection that will manage our list of users. As our router will be looking for a method called <code class="literal">index</code>, we'll add that to <code class="literal">prototype</code> of our <code class="literal">Controller </code>function. This method simply creates an <code class="literal">App.User.CollectionView </code>instance and renders it in the <code class="literal">users</code> region of our layout.</p><p>Before we load up our page, we need to instantiate the router. At the bottom of the <code class="literal">Router</code> module, add the following code:</p><div><pre class="programlisting">App.addInitializer(function () {
  var r = new Router({
    controller: new Controller()    
  });
});</pre></div><p>Here, we instantiate our router, passing it a new <code class="literal">Controller</code> object as a property in an options object. The router will use this object as the controller for our application.</p><p>The last step to having some code we can actually run is to add a few lines to the <code class="literal">index.ejs</code> file. This can be done as follows:</p><div><pre class="programlisting">&lt;script src='/layout.js'&gt;&lt;/script&gt;
&lt;script src='/router.js'&gt;&lt;/script&gt;
&lt;script&gt;
  App.start();
&lt;/script&gt;</pre></div><p>We add our layout and router modules, and then, right at the bottom, we start the application. <a id="id359" class="indexterm"/>Remember that, even when we add other script tags later on, it is important that the <code class="literal">router.js</code> script should be the last one loaded because it references almost all the other files.</p><p>Now, you can run <code class="literal">npm start</code> to boot the server up and load <code class="literal">http://localhost:3000</code> in a browser. At this point, you won't see anything at all on the page; however, open the developer tools and you'll see that things are starting to take shape. We can see this in the following screenshot:</p><div><img src="img/6997OS_05_01.jpg" alt="Starting the router"/></div><p>You can see that our layout has been rendered and that the <code class="literal">&lt;ul&gt;</code> element of our <code class="literal">User.CollectionView</code> instance is present. Even though we aren't rendering any content, this is an important step. We've written a lot of code that might seem disparate and unconnected, but it has all come together to create the humble beginnings of our application. Now that we have the infrastructure working, we can start to think about specific features.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec56"/>Letting users join the fun</h1></div></div></div><p>Our first <a id="id360" class="indexterm"/>serious feature will be allowing users to choose a screen name and join the chat rooms. We'll need a view with a form where a user can submit their name. However, as part of this, we'll need a way to ask the server if this name has been taken yet.</p><p>For all this, we go back to the <code class="literal">User</code> module, and add a method to the <code class="literal">User.CollectionView</code>, using the following code:</p><div><pre class="programlisting">addUser: function (name, callback, context) {
  App.Socket.io.emit('join', name, function (joined) {
    if (joined) App.name = name;
    callback.call(context joined);
  });
}</pre></div><p>This method<a id="id361" class="indexterm"/> takes the <code class="literal">name</code> that the user wants to use as well as a <code class="literal">callback</code> function. Inside the method, we use another Socket.IO method: <code class="literal">emit</code>. This is the flip side of the <code class="literal">App.Socket.io.on</code> method we saw earlier in this class's <code class="literal">initialize</code> method. The <code class="literal">on</code> method listens for events while <code class="literal">emit</code> actually makes the occurrence of the event. The <code class="literal">emit</code> method takes at least one parameter; the name of the event that we're triggering. We can then pass as many subsequent parameters as we like; these are pieces of data that we can associate with the event. If the server is listening for this event, it will receive these parameters. We pass the user's name and a function. The name makes sense; if the server is going to tell us whether this name is already in use, we need to send it the name. However, the function is a little different. We receive the function on the server side, but when we call the function (from the server, remember!) it will be executed here in the browser. This is not only incredibly cool, it's also very useful. On the server, we'll pass that function a Boolean value; <code class="literal">true</code> if the user can use this name and has been added to the list of current users or <code class="literal">false</code> if the name is already in use.</p><p>If the user has successfully joined the chat rooms, we'll set their screen name as a property of our <code class="literal">App</code> object, so we can access it from other places. Then, we'll call the <code class="literal">callback</code> function that was passed to the <code class="literal">addUser</code> method, passing it the <code class="literal">joined</code> value. The <code class="literal">context</code> parameter is actually just a nice touch. I'm not a fan of having to put the value of <code class="literal">this</code> in a variable every time I enter a callback function, so when I have the option, I'll create functions that take a context as a final parameter. This way, I can use <code class="literal">this</code> as I want inside the function.</p><p>With that in place, let's move over to <code class="literal">server.js</code>. We haven't written any Socket.IO-specific code yet, but we're going to start that now. Start by adding this to <code class="literal">server.js</code>:</p><div><pre class="programlisting">var users = {};
io.sockets.on('connection', function (socket) {
});</pre></div><p>We start with a <code class="literal">users</code> object; it's empty right now, but as users join, it will be used. As we aren't creating actual user accounts, there's no need for this record to be persistent; a regular object will do.</p><p>Earlier, we<a id="id362" class="indexterm"/> created the <code class="literal">io</code> object. This object has a <code class="literal">sockets</code> object on which we have the <code class="literal">on</code> method, which we can use to listen for connections being opened from browsers. As you can see here, we're listening for the <code class="literal">connection</code> event. The callback function here will be run when a new connection is made. The new socket (the connection to the browser) is a parameter of the function.</p><p>Inside this callback, we'll start by listening for the <code class="literal">join</code> event that the <code class="literal">User.CollectionView</code> class' <code class="literal">addUser</code> method was emitting. Add this inside that callback function:</p><div><pre class="programlisting">socket.on('join', function (name, response) {
  if (userExists(name)) {
    response(false); 
  } else {
    response(true);
    users[socket.id] = { name: name };
    io.sockets.emit('user:join', { name: name });
  }
});</pre></div><p>Remember that when we emitted the <code class="literal">join</code> event, we sent the name and a function along with it. You can see these here on the server as the parameters of the function that will be called when this event occurs. In this function, we check to see whether the user exists using a <code class="literal">userExists</code> function, which we haven't written yet. If the user already exists, we'll call that <code class="literal">response</code> function (that is executed on the client, remember?) and pass <code class="literal">false</code> (because the user can't join under that name). However, if the user doesn't currently exist, we'll respond with <code class="literal">true</code>. Then, we'll add the user to the <code class="literal">users</code> object. We can use the unique <code class="literal">socket.id</code> as a key. Finally, we'll emit the <code class="literal">user:join</code> event, passing a basic user object as the data associated with that event. All the currently connected clients (including the client that sent the join event) will receive this event. Remember that in our <code class="literal">User.Collection</code> class' <code class="literal">initialize</code> method, we're listening for this event. This is how the client can learn about new users joining the chat room.</p><p>You might wonder why we can't just look at the users in the collection to see whether a name is in use, instead of asking the server whenever a new user tries to join. After all, if the collection is a list of currently connected users, it should know whether the name is already in use. The problem with this is that in some scenarios, which we haven't yet come to, the user will try to join before the server has had the chance to send the current list of users to the collection.</p><p>This is something we have to add. When a new socket is connected, we need to send it the list of the currently connected users. This can be done as follows:</p><div><pre class="programlisting">Object.keys(users).forEach(function (id) {
  socket.emit('user:join', users[id]);
});</pre></div><p>The <a id="id363" class="indexterm"/>
<code class="literal">Object.keys</code> method <a id="id364" class="indexterm"/>takes an object and returns an array of its keys. We can loop over all the users in our <code class="literal">users</code> object and emit the <code class="literal">user:join</code> event for each one. There's an important difference between this event and the <code class="literal">user:join</code> event we emitted previously. In the <code class="literal">join</code> event listener, we use <code class="literal">io.sockets.emit</code>, which emits the event to all sockets. Here, we use <code class="literal">socket.emit</code>. This way, only that socket will receive these events.</p><p>With this code in place, we're ready to write the view that allows our users to join the chat rooms. We'll put this code in our <code class="literal">User</code> module:</p><div><pre class="programlisting">User.LogInView = Backbone.Marionette.ItemView.extend({
  tagName: 'form',
  template: '#form',
  model: new Backbone.Model({ 
    placeholder: 'name',
    button: 'Join' 
  }),
  events: {
    'click button': 'addUser'
  },
  ui: {
    'input': 'input'
  },
  addUser: function (e) {
    e.preventDefault();
    var name = this.ui.input.val();
    this.collection.addUser(name, function (joined) {
      if (joined) {
        this.trigger('user-added');
      } else {
        this.ui.input.val('');
      }
    }, this);
    return false;
  }
});</pre></div><p>Here, we create a <code class="literal">Marionette.ItemView</code> class, so we don't have to write the <code class="literal">render</code> method ourselves. Instead of passing in a <code class="literal">model</code>, when creating an instance of this class, we're putting it <a id="id365" class="indexterm"/>right here in the class definition (this is possible in a regular Backbone view too; it's not special to Marionette). We're doing this because of the template. Normally, our views that display forms don't have models, but this one does because we want to use this template for multiple views. We will use a template with the ID <code class="literal">form</code>. The template is as follows:</p><div><pre class="programlisting">&lt;script type='text/template' id='form'&gt;
  &lt;input type='text' placeholder='{{placeholder}}' /&gt;
  &lt;button&gt; {{button}} &lt;/button&gt;
&lt;/script&gt;</pre></div><p>This is very basic. It has only an input element and a button. The placeholder text and the button text need to come from a model, so that's why we add a basic Backbone model with the right attributes to this class definition.</p><p>The <code class="literal">events</code> property is not new or special. When we click on the button, we'll call the <code class="literal">addUser</code> method (of this class). The <code class="literal">ui</code> property, on the other hand, is special to Marionette views; we often need to reference specific elements of the view from within view methods, and the <code class="literal">ui</code> property is a shortcut to access them. The keys are the names by which we'll refer to the element, and the value is a selector for the element. In this case, we find the input element and call it <code class="literal">input</code>. You can see this in use in the <code class="literal">addUser</code> method. Instead of searching for the input element with <code class="literal">this.$("input")</code>, we can just reference <code class="literal">this.ui.input</code>; it's even a jQuery object.</p><p>In <code class="literal">addUser</code>, we start by preventing the default submission of the form. Then, we get whatever name the user typed into the textbox, and send it to the collection's <code class="literal">addUser</code> method. In our callback function, if the user has successfully joined the chat rooms, we'll trigger the <code class="literal">user-added</code> event on this view. This is the Backbone equivalent of emitting an event with Socket.IO (this isn't Marionette-specific; you can trigger and listen for events in plain Backbone applications as well). Later, we'll listen for this event. If the user did not join successfully, we'll clear the input element so that they can try a new name.</p><p>Now, go back to the <code class="literal">Controller.prototype.index</code> method in the <code class="literal">router.js</code> file. We need to render a <code class="literal">LogInView</code> instance, like this:</p><div><pre class="programlisting">var loginView = new App.User.LogInView({
  collection: this.users
});	
App.layout.controls.show(loginView);</pre></div><p>Notice that this is where the collection in the <code class="literal">addUser</code> method comes from. With this code in place, things are starting to get interesting. If you open <code class="literal">http://localhost:3000</code>, you'll see a textbox and button. Type in a name and click on <strong>Join</strong>; and the name will appear above in the list. Now, the magic begins. Open the site in another browser tab.<a id="id366" class="indexterm"/> You'll see the first name already in the list. Go ahead and add another one; it will appear in the list. Now, go back to the first window. You'll see that it also received the second name. Isn't that amazing! This works for two reasons. First, Socket.IO makes sure every new user is added to the user collection of every connected browser. Then, Marionette's <code class="literal">CollectionView</code> will immediately render new models added to the collection, which is why it appears in the list without us doing any manual rendering or watching the collection for changes.</p><p>There's a little problem, though. If you close the second window and go back to the first one, you'll find that both names are still in the list. We need to remove a name from the collection when a user closes the site.</p><p>This is done in <code class="literal">server.js</code>. When a socket disconnects from the server, we get a disconnect event; so let's listen for that (within the <code class="literal">connection</code> event callback). We can do that as follows:</p><div><pre class="programlisting">socket.on('disconnect', function () {
  if (users[socket.id]) {
    io.sockets.emit('user:leave', users[socket.id]);
    delete users[socket.id]; 
  }
});</pre></div><p>When this socket disconnects, we check the user's object to see whether there's an entry for this Socket ID. Remember, if the user never tried to join the chat rooms (maybe they loaded the page and then closed it), they won't have an entry; that's why we check. If they do, we'll emit a <code class="literal">user:leave</code> event to all sockets, and then delete that entry from our users hash.</p><p>Now, we know that our user collection is listening for the <code class="literal">user:leave</code> event, and when it occurs, the user will be removed from the collection. Accordingly, Marionette will update the <code class="literal">User.CollectionView</code>. Now, if you do our quick-and-dirty test in the browser again, you'll see that when you close the second browser window, the second name disappears from the first window. Clever, no?</p><p>Before leaving the user module behind, let's add one more feature. Later, we'll be writing some CSS for <a id="id367" class="indexterm"/>our application; so let's highlight the user's own name in the list. In the <code class="literal">ItemView</code> class in the <code class="literal">User </code>module, let's add a method called <code class="literal">onRender</code>. This method will be called after the view has been rendered. Here's how that looks:</p><div><pre class="programlisting">onRender: function () {
  if (this.model.get('name') === App.name) {
    this.el.className = "highlight";
  }
}</pre></div><p>It's quick and simple. If the model we're rendering this view for has the same name as the user in this browser, add the class <code class="literal">highlight</code> to the element.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Joining a room</h1></div></div></div><p>Once a <a id="id368" class="indexterm"/>user has selected their screen name, the next step is selecting a room. This is a bit more complex than choosing a name because they can either choose from a list of existing rooms, or they can start a new room by typing in a new name. If the user types in the name of an existing room, they'll go to the existing rooms because we obviously can't have multiple rooms with the same name. The tricky part in all this is that while we're calling them rooms, they're actually more like tags. The only place they exist is as a property on the chat messages; they aren't stored on their own. When a user creates a new room, there's no actual record of the room until they write the first message in that room. If they create a room and then close the page, the room doesn't exist. All this will make it a bit trickier to keep track of the rooms, but we love a good challenge, right?</p><p>Open a new file, <code class="literal">rooms.js</code>, in <code class="literal">public</code>. Just like our <code class="literal">user.js</code> file, this will have a model, collection, model view, collection view, and form view. The following code shows how we start with this file:</p><div><pre class="programlisting">App.module('Room', function (Room) {
  var RoomModel = Backbone.Model.extend({
    url: function () {
      return '/room/' + this.get('name');
    }
  });
});</pre></div><p>We call the module <code class="literal">Room</code>, and we start with <code class="literal">RoomModel</code>. This model has a single method; it returns the URL for the room. The plan is to eventually allow users to go straight to the room of their <a id="id369" class="indexterm"/>choice by having it in the URL. This makes specific rooms easy to bookmark. Of course, they'll still have to enter their screen name before they can actually see the room, but it will omit the "choose a room" step from the process. We'll use this method to get the route to a given room model. Next, we write the collection, which looks like this:</p><div><pre class="programlisting">Room.Collection = Backbone.Collection.extend({
  model: RoomModel,
  initialize: function () {
    App.Socket.io.on('room:new', this.getRoom.bind(this));
  },
  getRoom: function(room) {
    return this.findWhere({ name: room }) || this.add({ name: room });
  }
});</pre></div><p>Just like in our <code class="literal">User.Collection</code> class, the <code class="literal">initialize</code> method here listens for an event. In this case, it's the <code class="literal">room:new</code> event. When that happens, we'll call this class's <code class="literal">getRoom</code> method. This method probably doesn't look like what you'd expect. Its purpose, in this context is to add the room to the collection if it isn't already there. You might expect it to look something like the following code:</p><div><pre class="programlisting">addRoom: function (room) {
  if (!this.findWhere({ name: room }).length) {
    this.add({ name: room });
  }
}</pre></div><p>However, later on we'll also need a method that takes a room name, and either returns the existing room by that name or creates a new room with that name, and this is exactly what the <code class="literal">getRoom</code> method does. As it turns out, the logic in <code class="literal">getRoom</code> is exactly the same as this example <code class="literal">addRoom</code> method. If the room doesn't exist, add it. So our <code class="literal">getRoom</code> method is a two-for-one deal.</p><p>Let's move over to <code class="literal">server.js</code> for a moment. When a new socket connects, we need to send the list of existing rooms to this room collection. Inside the function that is run when a new socket connects, add this code:</p><div><pre class="programlisting">db.find(function (err, records) {
  var rooms = {};
  records.forEach(function (record) { rooms[record.room] = 0; });
  Object.keys(rooms).forEach(function (room) {
    socket.emit('room:new', room);
  })
});</pre></div><p>What we're doing in the preceding code is finding all the records in our database; these records are the chat messages. What we need to do is convert this array of messages into a list of the rooms<a id="id370" class="indexterm"/> that they are in. Although we don't have any messages yet, each one will have a <code class="literal">room</code> property. We loop over each model and add a property to a disposable <code class="literal">rooms</code> object. As an object can't have multiple properties with the same name, the result will be an object whose keys are a unique list of the existing rooms. Then, we can use <code class="literal">Object.keys</code> to get an array of just those keys; finally, we'll loop over that array and emit the <code class="literal">room:new</code> event for each room. As we've just seen, the <code class="literal">Room.Collection</code> instance will catch these on the browser's end and fill the list.</p><p>Now that we have our model and collection, we can make their respective views as follows:</p><div><pre class="programlisting">var RoomView = Backbone.Marionette.ItemView.extend({
  tagName: 'li',
  template: '#room',
  events: {
    'click a': 'chooseRoom'
  },
  chooseRoom: function (e) {
    e.preventDefault();
    Backbone.history.navigate(this.model.url(), { trigger: true });
  }
});

Room.CollectionView = Backbone.Marionette.CollectionView.extend({
  tagName: 'ul',
  itemView: RoomView
});</pre></div><p>The <code class="literal">RoomView</code> class is the item view in this case. It will be a list item element; the template has the ID <code class="literal">room</code>. Here's that template:</p><div><pre class="programlisting">&lt;script type='text/template' id='room'&gt;
  &lt;a href='/room/{{ name }}'&gt;{{ name }}&lt;/a&gt;
&lt;/script&gt;</pre></div><p>As you can see, the list of rooms will be links; then in the view, we'll listen for a click on one of these anchor elements. When that happens, we'll prevent the default reloading of the page, and <a id="id371" class="indexterm"/>use Backbone to navigate to the room's URL. This time, instead of pulling a method from the router, we're using the <code class="literal">Backbone.history.navigate</code> method. Of all the ways of changing the route that we've looked at, this is clearly the best one (of course, it's good to know about the others).</p><p>The <code class="literal">Room.CollectionView</code> class is very basic. We just make the wrapping element a list and point to the item view.</p><p>This is all we need to display the list of existing rooms. However, if a user wants to create a new room, we need a view for that. So, here's that view:</p><div><pre class="programlisting">Room.CreateRoomView = Backbone.Marionette.ItemView.extend({
  tagName: 'form',
  template: '#form',
  model: new Backbone.Model({ 
    placeholder: 'room name', 
    button: 'Join' 
  }),
  events: {
    'click button': 'createRoom'
  },
  ui: {
    'input': 'input'
  },
  createRoom: function (e) {
    e.preventDefault();
    var name = this.ui.input.val().toLowerCase()
          .replace('/ /g, '_').replace(/\W/g, ''),
        room = this.collection.getRoom(name);
    Backbone.history.navigate(room.url(), { trigger: true });
    return false;
  }
});</pre></div><p>The <code class="literal">Room.CreateRoomView</code> class will use the same form template that we used in <code class="literal">Login View</code>, so the whole class will look pretty similar. We're adding the model here, so we can set the template's placeholder text and button text. When the button is clicked, we'll call the <code class="literal">createRoom</code> method. This method will prevent the default form submission and then get the text from the input element. As our room names will be used in URLs, we need to clean the name up a bit by first replacing all spaces with underscores and then removing all other non-word characters. Then, we pass the room name to the collection's <code class="literal">getRoom</code> function. As we know, this will return a room (either a newly created one or an existing one with that name). Then, we'll navigate to that room's URL.</p><p>Now that we have these classes, we can use them. First, in <code class="literal">index.ejs</code>, add the <code class="literal">Room</code> module:</p><div><pre class="programlisting">&lt;script src='/rooms.js'&gt;&lt;/script&gt;</pre></div><p>Then, in <a id="id372" class="indexterm"/>the <code class="literal">Controller</code> function in <code class="literal">router.js</code>, add the following line of code. It will be the collection object that our application uses to keep track of the rooms:</p><div><pre class="programlisting">this.rooms = new App.Room.Collection();</pre></div><p>Now, go to our controller's <code class="literal">index</code> function; we've already written part of it, but here's the whole new and improved version:</p><div><pre class="programlisting">Controller.prototype.index = function () {
  App.layout.users.show(new App.User.CollectionView({ 
    collection: this.users 
  }));
  App.layout.rooms.show(new App.Room.CollectionView({ 
    collection: this.rooms 
  }));

  var loginView = new App.User.LogInView({
    collection: this.users
  });
  App.layout.controls.show(loginView);
  loginView.on('user-added', function () {
    App.layout.controls.show(new App.Room.CreateRoomView({ 
      collection: this.rooms 
    }));
  }, this);
};</pre></div><p>As earlier, we render the list of users and the login form. However, we're also rendering our new rooms collection in the appropriate collection view in the <code class="literal">rooms</code> region of the layout. Then, we listen for the <code class="literal">user-added</code> event on the login form. Remember, that event will be emitted when a user successfully joins the site. When that happens, we'll render a different view in the <code class="literal">controls</code> region; the view to create a new room. We can't forget to give that view the collection, to which it can add the new room. The Backbone <code class="literal">on</code> method takes a context variable as a third parameter, so we can use <code class="literal">this</code> inside the callback.</p><p>Now, if you test our application, you'll see that after you put in a screen name, the form will change and ask for a room name, as shown in the following screenshots:</p><div><img src="img/6997OS_05_03.jpg" alt="Joining a room"/></div><div><img src="img/6997OS_05_04.jpg" alt="Joining a room"/></div><p>Of course, there's no list of room names to choose from as we haven't stored any messages yet, <a id="id373" class="indexterm"/>but if you look at the DOM, you'll see the empty <code class="literal">&lt;ul&gt;</code> element waiting. Type in a room name and click on the button, and two things should happen. First, the room name should appear on screen in a list. Second, the URL will change to the room route.</p><p>This URL change means we need to add a route to our <code class="literal">Router</code> class. In the <code class="literal">appRoutes</code> property, add this line of code:</p><div><pre class="programlisting">'room/:room': 'room'</pre></div><p>This means that we need to create a <code class="literal">room</code> method on our controller prototype. Before we write the method, think of this; if choosing a room sends our user to the room route, it's also possible that the user could directly to the route. If they do this, the room will be selected, but the user will not have chosen a screen name. This means that this method will have to check for the presence of a screen name, and if a screen name hasn't been given, we'll have to get one before showing the room.</p><p>First, as it is possible that this route will be loaded directly (and not via Backbone through the room link), we'll need to render the user list and the room list. Since we'll do this first in all the routes we will end up creating, let's move that into a helper function:</p><div><pre class="programlisting">Controller.prototype.showUsersAndRooms = function () {
  App.layout.users.show(new App.User.CollectionView({
    collection: this.users 
  }));
  App.layout.rooms.show(new App.Room.CollectionView({
    collection: this.rooms 
  }));
};</pre></div><p>The <code class="literal">showUsersAndRooms</code> method on the controller prototype renders those views in the right regions.</p><p>Let's write one more helper function. As we figured out, if the user hasn't selected a screen name yet, we'll <a id="id374" class="indexterm"/>need to display the same view we're showing in the <code class="literal">index</code> route: <code class="literal">logInView</code>. So let's write a <code class="literal">showLogin</code> function:</p><div><pre class="programlisting">Controller.prototype.showLogin = function () {
  var loginView = new App.User.LogInView({
    collection: this.users
  });
  App.layout.controls.show(loginView);
  return loginView;
};</pre></div><p>We'll create <code class="literal">loginView</code>, display it in the <code class="literal">controls</code> region, and then return the view. We return it because the route function that calls this helper function will probably want to listen for that <code class="literal">user-added</code> event. With these two helper functions in place, we can really clean up the <code class="literal">index</code> function as follows:</p><div><pre class="programlisting">Controller.prototype.index = function () {
  this.showUsersAndRooms();
  this.showLogin().on('user-added', function () {
    App.layout.controls.show(new App.Room.CreateRoomView({ 
      collection: this.rooms 
    }));
  }, this);
};</pre></div><p>However, the reason for creating these helper functions is that they'll also be useful in the room route function we need to create:</p><div><pre class="programlisting">Controller.prototype.room = function (room) {
  this.showUsersAndRooms();
  App.room = this.rooms.getRoom(room);
  if (!App.name) {
    this.showLogin().on('user-added', function () { 
      // render chat room conversation
    });
  } else {
    // render chat room conversation
  }
};</pre></div><p>We first render the users and rooms lists. Then, we set a property on our global <code class="literal">App</code> object for the room <a id="id375" class="indexterm"/>that the user chooses to view. Then, we check to see whether <code class="literal">App.name</code> is set. If the user has come from the <code class="literal">index</code> route (or has switched rooms by clicking on a link from the list), <code class="literal">App.name</code> will be set. If it isn't set, we'll show the login form. If the name is set, or after the name is set (determined by the <code class="literal">user-added</code> event we're listening for), we'll need to render the chat room conversation. To do this, we need to create the <code class="literal">Chat</code> module.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Building the chat module</h1></div></div></div><p>To create <a id="id376" class="indexterm"/>the <code class="literal">Chat</code> module, we'll create the <code class="literal">chat.js</code> file within <code class="literal">public</code>. Once again, we'll start with the model and collection classes:</p><div><pre class="programlisting">App.module('Chat', function (Chat) {
  var Message = Backbone.Model.extend({});

  Chat.Collection = Backbone.Collection.extend({
    model: Message,
    initialize: function (models, options) {
      var thiz = this;
      App.Socket.io.emit('room:join', options.room, this.add.bind(this)); 

      App.Socket.io.on('message:new', function (data) {
        if (data.room === options.room) {
          thiz.add(data);
        }
      });
    }
  });
});</pre></div><p>The <code class="literal">Message</code> model is very simple, but the <code class="literal">Chat.Collection</code> class is a little more interesting. First, notice that this function takes two parameters: <code class="literal">models</code> and <code class="literal">options</code>. We never actually expect to receive any models, but it is a Backbone convention for a collection to receive <a id="id377" class="indexterm"/>these two parameters. So, we'll follow this convention. We expect that option's object to have the name of the room that these messages are in. Once we have that name, we can emit the <code class="literal">room:join</code> event with two parameters: the name of the room and a callback function. The function is this collection's <code class="literal">add</code> method. We expect the server to call the callback function with a list of all the messages currently in the room. Then, for all messages created after the collection is created, the server will emit a <code class="literal">message:new</code> event. We'll pick up on this <code class="literal">message:new</code> event here, and if the room on the new message is in the same room as the room this <code class="literal">Chat.Collection</code> instance is for, we'll add it to the collection.</p><p>Also, we'll add item and collection views as we've done before. Here's how that works:</p><div><pre class="programlisting">var MessageView = Backbone.Marionette.ItemView.extend({
  tagName: 'li',
  template: '#message'
});

Chat.CollectionView = Backbone.Marionette.CollectionView.extend({
  tagName: 'ul',
  itemView: MessageView,
  onRender: function () {
    setTimeout(this.render.bind(this), 60000);
  }
});</pre></div><p>The <code class="literal">MessageView</code> is simple: a list item element that will render the message template. Here's that template:</p><div><pre class="programlisting">&lt;script type='text/template' id='message'&gt;
  &lt;strong&gt; {{ user }} &lt;/strong&gt;: 
  {{ text }}
  &lt;span&gt; {{ moment(date).fromNow() }} &lt;/span&gt;
&lt;/script&gt;</pre></div><p>Every message will have a user name, the text of the message, and the date and time when the message was created. Notice that we're not displaying the date value as it is. Instead, we use the Moment library to convert that date to a string such as <code class="literal">10 minutes ago</code>. As we've done in previous applications, we can go ahead and download<a id="id378" class="indexterm"/> Moment (<a class="ulink" href="http://momentjs.com">http://momentjs.com</a>) and add the appropriate script tag to <code class="literal">index.ejs</code>.</p><p>The <code class="literal">CollectionView</code> makes use of the <code class="literal">onRender</code> function in an interesting way. After the view renders, this function will set a timeout, to recall the <code class="literal">render</code> method again in 60 seconds. This is done<a id="id379" class="indexterm"/> so that the <em>time ago</em> timestamp will update on our message views.</p><p>The last view for this module is the <code class="literal">Chat.CreateMessageView</code> view:</p><div><pre class="programlisting">Chat.CreateMessageView = Backbone.Marionette.ItemView.extend({
  tagName: 'form',
  template: '#form',
  model: new Backbone.Model({ 
    placeholder: 'message', 
    button: 'Post' 
  }),
  events: {
    'click button': 'addMessage'
  },
  ui: {
    'input': 'input'
  },
  addMessage: function (e) {
    e.preventDefault();
    App.Socket.io.emit('message:new', { 
      user: App.name,
      text: this.ui.input.val(), 
      room: App.room.get('name'),
      date: new Date()
    });
    this.ui.input.val('').focus();
    return false;
  }
});</pre></div><p>This is very similar to our other two form views. We have the model for setting the placeholder and button text. Then, when we click on the button, we run the <code class="literal">addMessage</code> method. This method will prevent the form from getting submitted, and then emit a <code class="literal">message:new</code> event to the server. As data, we get the user's name, the text in the input element, the name of the room that the user is currently in, and the current date and time. All this data is sent to the server. Then, we clear the input element, and focus it for the next message.</p><p>Now that we're done with <code class="literal">chat.js</code>, add it to the <code class="literal">index.ejs</code> file.</p><p>So what happens on the server? Well, that's where we listen for the the <code class="literal">message:new</code> event:</p><div><pre class="programlisting">socket.on('message:new', function (data) {
  db.insert(data, function (msg) {
    io.sockets.emit('message:new', msg);

    db.find({ room:data.room }, function (msgs) {
      if (msgs.length === 1) {
        io.sockets.emit('room:new', data.room);
      }
    });
  });
});</pre></div><p>When that happens, <a id="id380" class="indexterm"/>we'll insert the data into the database. Once it has been successfully saved, we'll emit the <code class="literal">message:new</code> event to all connected clients. Those viewing the room this message was in will see it almost immediately. We also search the database for records in the same room. If a user has started a new chat room, there will be only one message with that room name (the one we just saved). However, this also means that all the other clients don't yet have this room in their <code class="literal">Room.Collection</code> object. So, we'll send them all a <code class="literal">room:new</code> event with the room's name.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Back to the controller</h1></div></div></div><p>With the <code class="literal">Chat</code> module <a id="id381" class="indexterm"/>created, we can turn back to the controller, where we want to render the chat for the chosen room. Let's create a helper function for this:</p><div><pre class="programlisting">Controller.prototype.showChat = function () {
  App.layout.controls.show(new App.Chat.CreateMessageView());
  App.layout.conversation.show(new App.Chat.CollectionView({
    collection: new App.Chat.Collection([], { 
      room: App.room.get('name') 
    })
  }));
};</pre></div><p>In the <code class="literal">controls</code> region, we put <code class="literal">Chat.CreateMessageView</code>. Then, in the <code class="literal">conversation</code> region, we render a <code class="literal">Chat.CollectionView</code> instance. Now, in our <code class="literal">Controller.prototype.room</code> method, we can call this <code class="literal">showChat</code> method:</p><div><pre class="programlisting">Controller.prototype.room = function (room) {
  this.showUsersAndRooms();
  App.room = this.rooms.getRoom(room);
  if (!App.name) {
    this.showLogin().on('user-added', this.showChat.bind(this));
  } else {
    this.showChat();
  }
};</pre></div><p>Now, this route is <a id="id382" class="indexterm"/>complete. Once we have a name, we'll show the chat messages.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Adding some other routes</h1></div></div></div><p>Right now, <a id="id383" class="indexterm"/>we have two routes. However, we want to add a few more. Next, we'll add a <code class="literal">/user/:name</code> route, so that the user can skip the logging-in step. For example, I could go directly to <code class="literal">http://localhost:3000/user/Andrew</code>, and I wouldn't have to log in; I could just choose a room. While this may not be practical or realistic, I think it's a fun touch that is very simple to add.</p><p>In the router class, add the following route:</p><div><pre class="programlisting">'user/:user': 'user'</pre></div><p>Now, let's write this method in the controller as follows:</p><div><pre class="programlisting">Controller.prototype.user = function (user) {
  this.showUsersAndRooms();

  this.users.addUser(user, function (joined) {
    if (joined) {
      App.layout.controls.show(new App.Room.CreateRoomView({
        collection: this.rooms 
      }));
    } else {
      Backbone.history.navigate('', { trigger: true });
    }
  }, this);
};</pre></div><p>First, we'll call our <code class="literal">showUsersAndRooms</code> helper method to display the lists of users and rooms. Then, we'll call the user collection's <code class="literal">addUser</code> method. Remember that this method will decide whether the user can use the screen name they chose. Since the screen name is part of the URL, we get it as a parameter to the function. In the callback function, if the user has successfully<a id="id384" class="indexterm"/> joined, we'll display <code class="literal">CreateRoomView</code> where they can start a new room (alternatively, they can click on a room in the rooms list). Otherwise, we'll redirect them to the root route where they can choose an unused screen name.</p><p>So, we've made it possible for someone coming to our application to choose either their screen name or a room right from the URL. Why don't we take it one step further and allow users to do both? We can make it work in both ways:</p><div><pre class="programlisting">/room/Pets/name/Andrew
/name/Andrew/room/Pets</pre></div><p>In the router, add the following lines of code to the <code class="literal">appRoutes</code> property:</p><div><pre class="programlisting">'room/:room/user/:user': 'room_user',
'user/:user/room/:room': 'user_room'</pre></div><p>We'll start with the <code class="literal">room_user</code> method:</p><div><pre class="programlisting">Controller.prototype.room_user = function (room, user) {
  this.showUsersAndRooms();
  App.room = this.rooms.getRoom(room);

  this.users.addUser(user, function (joined) {
    if (joined) {
      this.showChat(room);
    } else {
      Backbone.history.navigate(App.room.url(), { trigger: true });
    }
  }, this);
};</pre></div><p>We start by calling <code class="literal">showUsersAndRooms</code> again. Then, we get the room model through the name given to us in the URL. Lastly, we try to log the user in. If they join successfully, we'll show the chat room they chose. If they need to pick another screen name, we'll redirect them to the URL for that room.</p><p>With this in place, the <code class="literal">user_room</code> method simply switches the order of the parameters:</p><div><pre class="programlisting">Controller.prototype.user_room = function (user, room) {
  this.room_user(room, user);
};</pre></div><p>With that, we have all the functionality we need in place! Our application is just about finished. All it needs now is a coat of paint.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec61"/>Writing CSS</h1></div></div></div><p>Since<a id="id385" class="indexterm"/> styling isn't the main purpose of this book, we've left this for the end; if you aren't interested, jump to the chapter summary.</p><p>While our application is functioning very well right now, it's certainly not easy on the eyes. Let's fix that. First, we'll link to a stylesheet from the <code class="literal">&lt;head&gt;</code> element in the <code class="literal">index.ejs</code> file as follows:</p><div><pre class="programlisting">&lt;link rel="stylesheet"  href="/style.css" /&gt;</pre></div><p>Now, create that file in <code class="literal">style.css</code> within <code class="literal">public</code>. We'll start with some generic styling:</p><div><pre class="programlisting">body {
  font-family: sans-serif;  
  padding: 0;
  margin: 0;
}

ul {
  margin: 0;
  padding: 0;
  list-style-type: none;
}</pre></div><p>It's really just a mini reset; we use several <code class="literal">&lt;ul&gt;</code> elements in this application, so this will be important.</p><p>The next few lines of code are mainly for styling the list of users:</p><div><pre class="programlisting">#users, #rooms {
  float: left;
  width: 13%;
  margin: 1%;
  font-size: 80%;
}

#users li {
  padding: 5px;
  border-bottom: 1px solid #ccc;
}
.highlight {
  font-weight: bold;
  background: #ececec;
}</pre></div><p>The users and room lists will be the sidebars on the left and right, respectively. We'll set their width <a id="id386" class="indexterm"/>and margin, shrink the font size a bit, and then float them to the left. We then do some basic styling for the user list items. You'll recall that we added the <code class="literal">highlight</code> class to the user view for the logged-in user; we're defining that class here.</p><p>Next, we style the list of rooms with these lines:</p><div><pre class="programlisting">#rooms li {
  padding: 0;
  border-bottom: 1px solid #ccc;
}
#rooms li a {
  text-decoration: none;
  color: #000;
  display: block;
  padding: 5px;
}
#rooms li a:hover {
  background: #ececec;
}</pre></div><p>Then, we provide some styling for the user list; it's a bit more complex as the list items have anchor elements inside them. Of course, we add some basic hover styling.</p><p>Next, we style the conversation itself:</p><div><pre class="programlisting">#conversation {
  float: left;
  width:68%;
  margin: 1%;
  margin-bottom: 60px;
}

#conversation li {
  padding: 10px;
  border-bottom: 1px solid #ececec;
}
#conversation li span {
  color: #ccc;
  font-size: 75%;
  float: right;
}</pre></div><p>The <code class="literal">conversation</code> region goes in the middle, between the two sidebars, so it is important <a id="id387" class="indexterm"/>that it be floated to the left-hand side as well. The <code class="literal">&lt;span&gt;</code> element we style is where the date and time of the message will be displayed, so we shrink the text a bit, and move it to the right.</p><p>Finally, we style the controls:</p><div><pre class="programlisting">#controls {
  background: #ececec;
  padding: 10px;
  position: fixed;
  bottom: 0;
  width: 100%;
}

#controls input {
  border: 1px solid #ccc;
  padding: 5px;
  width: 300px;
}

#controls button {
  border: 1px solid #ccc;
  background: #efefef;
  padding: 5px 15px;
}</pre></div><p>The last portion of the CSS styles is the <code class="literal">control</code> region. This is where all the forms will be displayed. We're doing something a bit different here. We're using a position that is fixed to attach it to the bottom of the screen. Now, the conversation can get as long as it wants, but the message form will always be visible.</p><p>Now, the code is complete. The following is a screenshot of the final application in use:</p><div><img src="img/6997OS_05_02.jpg" alt="Writing CSS"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Summary</h1></div></div></div><p>I hope you found this chapter interesting. The biggest idea we've looked at here is using Marionette instead of plain Backbone to build our application. As you've seen, when using a framework designed for large applications, there's a lot more of what you might call scaffolding code. Basing everything on an application object, using modules, splitting routers and controllers, it all makes for a lot more moving parts. Here's the thing; the application we've built here really can't be called large, so you might think it doesn't really make that much sense to use Marionette. However, if you've worked on any large projects, you know that the more code that's involved, the more you'll appreciate the constructs that a framework like Marionette gives you. That extra level of boundaries is certainly not required, but I think you'll find that it can be extremely helpful and that it keeps a huge project manageable as it grows and changes.</p><p>The other big idea in this chapter was Socket.IO. In this application, we completely ignored the built-in syncing channels that Backbone gives us, but as I mentioned earlier, that's not the only way it can be done. Now would be a good time to go back and look at the implementation of <code class="literal">Backbone.sync</code> using Socket.IO, and maybe even build a small application to test it. The bigger thing to take away from the way in which we used Socket.IO is that Backbone is just another tool, and there's no one right way to use it. Don't ignore the conventions and suggestions of the Backbone community, but don't be afraid to bend it to your will and see what happens. We'll do more of this in the next chapter when we create a podcast subscription application.</p></div></body></html>