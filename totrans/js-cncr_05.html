<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Working with Workers</h1></div></div></div><p>Web workers enable true parallelism within a web browser. They've spent time maturing, and have pretty good vendor support today. Before web workers, our JavaScript code was confined to the CPU, where our execution environment started when the page first loaded. Web workers have evolved out of necessity—web applications are growing more capable. They have also started to require more compute power. At the same time, multiple CPU cores are common place today—even on low-end hardware.</p><p>In this chapter, we'll walk through the conceptual ideas of web workers, and how they relate to the concurrency principles that we're trying to achieve in our applications. Then, you'll learn how to use web workers by example, so that, later on in the book, we can start tying parallelism to some of the other ideas that we've already explored, such as promises and generators.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec33"/>What are workers?</h1></div></div></div><p>Before we dive into <a id="id215" class="indexterm"/>implementation examples, this section will give us a quick conceptual breakdown of what web workers are. It's good to know exactly how web workers cooperate with the rest of the system under the hood. Web workers are operating system threads—a target where we can dispatch events, and they execute our JavaScript code in a truly parallel fashion.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec63"/>OS threads</h2></div></div></div><p>At their core, web<a id="id216" class="indexterm"/> workers are nothing more than operating system-level threads. Threads are kind of like processes, except they require less overhead because they share memory addresses with the process from which they're created. Since the threads that power web workers are at the level of the operating system, we're at the mercy of the system and its process scheduler. Most of the time, this is exactly what we want—let the kernel figure out when our JavaScript code should run in order to best utilize the CPU.</p><p>Here's a diagram showing how the browser maps its web workers to OS threads, and how these are mapped to CPU cores:</p><div><img src="img/B05133_05_01.jpg" alt="OS threads"/></div><p>At the end of the day, it's <a id="id217" class="indexterm"/>best that the operating system be left responsible for handling what it's good at—scheduling software tasks on physical hardware. In more traditional multi-threaded programming environments, our code lives much closer to the operating system kernel. This isn't the case with web workers. While the underlying mechanism is a thread, the exposed programming interface looks more like something you might find in the DOM.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Event targets</h2></div></div></div><p>Web workers implement the familiar<a id="id218" class="indexterm"/> event target interface. This makes web workers behavior similar to other components that we're used to working with, such as DOM elements or XHR requests. Workers trigger events, and this is how we receive data from them back in our main thread. We can also send data to workers, but this uses a simple method call.</p><p>When we pass data into workers, we actually trigger another event; only this time, it's in the execution context of the worker and not the main page execution context. There isn't much more to it than that: data in, data out. There's no <code class="literal">mutex</code> construct or anything of this sort. This is actually a good thing because the web browser, as a platform, already has many moving parts. Imagine if we threw in a more complex multi-threading model instead of just a simple event-target-based approach. We already have enough bugs to fix day-to-day.</p><p>Here's a rough idea of how the <a id="id219" class="indexterm"/>web worker layout looks, relative to the main thread that spawned these workers:</p><div><img src="img/B05133_05_02.jpg" alt="Event targets"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec65"/>True parallelism</h2></div></div></div><p>Web workers are the means to <a id="id220" class="indexterm"/>achieving the parallelize principle in our architecture. As we know, workers are operating system threads, meaning that the JavaScript code that's running inside them could possibly be running at the same exact instance as some DOM event handler code in the main thread. The ability to do stuff like this has been a goal of JavaScript programmers for quite a while. Before web workers, true parallelism simply wasn't possible. The best we could do was to fake it, giving a user the impression of many things happening simultaneously.</p><p>However, there are problems with always running on the same CPU core. We're fundamentally restricted in how many computations we can execute within a given time window. This restriction changes when true parallelism is introduced because the time window, in which computations may be run, grows with each CPU core that's added.</p><p>That being said, for most of the things that our application does, the single thread model works just fine. Machines today are powerful. We can get a lot done in a small time window. The problem arises when we experience spikes. These could be any event that disrupts the processing efficiency of our code. Our applications are constantly being asked to do more—more features, more data, more this, and more that.</p><p>The simple idea that we can make better use of the hardware that's sitting right in front of us, is what web workers are all about. Web workers, if used right, don't have to be this insurmountable new thing that we'll never use in our projects because it has concepts that fall outside of our comfort zone.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec34"/>Types of workers</h1></div></div></div><p>There are three types of web <a id="id221" class="indexterm"/>workers that we're likely to encounter during the development of concurrent JavaScript applications. In this section, we'll compare the three types so that we can understand which type of worker makes sense in any given context.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Dedicated workers</h2></div></div></div><p>Dedicated workers <a id="id222" class="indexterm"/>are probably the most common worker type. They're<a id="id223" class="indexterm"/> considered the default type of web worker. When our page creates a new worker, it's dedicated to the page's execution context and nothing else. When our page goes away, so do all the dedicated workers created by the page.</p><p>The communication path between the page and any dedicated worker that it creates is straightforward. The page posts messages to the workers, which in turn post messages back to the page. The exact orchestration of these messages is dependent on the problem that we're trying to solve using web workers. We'll dig into more of these messaging patterns throughout the book.</p><div><div><h3 class="title"><a id="note09"/>Note</h3><p>The terms main thread and page are synonymous in this book. The main thread is your typical execution context, where we can manipulate the page and listen for input. The web worker context is largely the same, only with access to fewer components. We will go over these restrictions shortly.</p></div></div><p>Here's a depiction of the<a id="id224" class="indexterm"/> page communicating with its dedicated <a id="id225" class="indexterm"/>workers:</p><div><img src="img/B05133_05_03.jpg" alt="Dedicated workers"/></div><p>As we can see, dedicated workers are, well, dedicated. They only exist to help serve the page that created them. They don't directly communicate with other workers, and they can't communicate with <a id="id226" class="indexterm"/>any <a id="id227" class="indexterm"/>other page.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Sub-workers</h2></div></div></div><p>Sub-workers are very <a id="id228" class="indexterm"/>similar to dedicated workers. The main difference is that they're<a id="id229" class="indexterm"/> created by a dedicated worker, not by the main thread. For example, if a dedicated worker has a task that would benefit from parallel execution, it can spawn its own workers and orchestrate the execution of the task between the sub-workers.</p><p>Apart from having a different creator, sub-workers share the same characteristics of a dedicated worker. Sub-workers don't communicate directly with JavaScript running in the main thread. It's up to the worker that creates the sub-workers to facilitate their communication. Here's an illustration of how sub-workers fit into the scheme of things:</p><div><img src="img/B05133_05_04.jpg" alt="Sub-workers"/></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Shared workers</h2></div></div></div><p>The third type of web worker is <a id="id230" class="indexterm"/>called a shared worker. Shared workers are named so<a id="id231" class="indexterm"/> because multiple pages can share the same instance of this type of worker. The pages that can access a given shared worker instance are restricted by the same-origin policy, which means, if a page was served from a different domain than the worker, the worker isn't allowed to communicate with this page.</p><p>Shared workers solve different type of problem than those solved by dedicated workers. Think of dedicated workers as functions without side-effects. You pass data to them and get different data in return. Think of shared workers as an application object following the singleton pattern. They're a means to sharing state between different browsing contexts. So, for instance, we wouldn't create a shared worker for the sole purpose of crunching numbers; we can use a dedicated worker for this.</p><p>It makes sense to use shared workers when there's application data in memory that we want from access from any page from the same application. Think about a user opening links in a new tab. This creates a new browsing context. It also means that our JavaScript components need to go through the process of fetching all the data required for the page, doing all the initialization steps, and so on. This gets repetitive and wasteful. Why not conserve these resources by sharing them between different browsing contexts? Here is an illustration of multiple <a id="id232" class="indexterm"/>pages from the same application communicating with a shared <a id="id233" class="indexterm"/>worker instance:</p><div><img src="img/B05133_05_05.jpg" alt="Shared workers"/></div><p>There's actually a fourth type of web worker called a service worker. These are shared workers embellished with additional capabilities related to caching network resources and offline functionality. Service workers are still in the early stages of their specification, but they look promising. Anything that we can learn about shared workers today will be applicable to service workers should they ever become a viable web technology.</p><p>Another important <a id="id234" class="indexterm"/>factor to consider here is the added complexity of service<a id="id235" class="indexterm"/> workers. The communication mechanism between the main thread and a service worker involves using ports. Likewise, the code running within the shared worker needs to make sure it's communicating over the correct port. We'll cover shared worker communication in much more depth later on in this chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec35"/>Worker environments</h1></div></div></div><p>Web worker environments<a id="id236" class="indexterm"/> aren't same as the typical JavaScript environment, where our code usually runs. In this section, we'll point out critical differences between the JavaScript environment of the main thread and web worker threads.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>What's available, what isn't?</h2></div></div></div><p>A common misconception of web workers is that they're radically different environments from the default JavaScript execution context. It's true that they're different, but not so different as to be unapproachable. Perhaps, it's for this reason that JavaScript developers shy away from using web workers when they could be beneficial.</p><p>The obvious gap is the DOM—it doesn't exist in web worker execution environments. Its absence was a conscious decision on the part of specification writers. By avoiding DOM integration into worker threads, browser vendors can avoid many potential edge cases. We all value browser stability over convenience, or at least, we should. And would it really be all that convenient to have DOM access from within web workers? We'll see throughout the next few chapters of this book that workers are good at lots of other tasks, which ultimately contribute to successfully implementing concurrency principles.</p><p>With no DOM access in our web worker code, we're less likely to shoot ourselves in the foot. It actually forces us to really think about why we're using the workers in the first place. And we might actually take a step back and rethink our approach. Apart from the DOM, most of what we use on a day-to-day basis is exactly where we expect it to be. This includes using our favorite libraries inside web workers.</p><div><div><h3 class="title"><a id="note10"/>Note</h3><p>For a more detailed breakdown of what's missing from web worker execution environments, see this <a id="id237" class="indexterm"/>page <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers">https://developer.mozilla.org/en-US/docs/Web/API/Worker/Functions_and_classes_available_to_workers</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Loading scripts</h2></div></div></div><p>We would never write our<a id="id238" class="indexterm"/> entire application in a single JavaScript file. Instead, we will promote modularity by dividing our source code into files in a way that logically decomposes the design into something we can map mentally. Likewise, we probably don't want to compose web workers that consist of thousands of lines of code. Luckily, web workers come with a mechanism that allows us to import code into our web workers.</p><p>The first scenario is importing our own code into a web worker context. We are likely to have many low-level utilities that are specifically tailored for our application. There's a high probability that we'll need to use these utilities in both: a regular scripting context and within a worker thread. We want to keep our code modular, and we want our code to function the same way in workers as it would in any other context.</p><p>The second scenario is loading third-party libraries in web workers. It's the same principle as loading our own modules into web workers—our code will work in any context with a few exceptions, like DOM code. Let's look at an example that creates a web worker and loads the <code class="literal">lodash</code> library. First, we'll launch the worker:</p><div><pre class="programlisting">// Loads the worker script, and starts the
// worker thread.
var worker = new Worker('worker.js');</pre></div><p>Next, we'll use the <code class="literal">loadScripts()</code> function to bring the <code class="literal">lodash</code> library into our library:</p><div><pre class="programlisting">// Imports the lodash library, making the global "_"
// variable available in the worker context.
importScripts('lodash.min.js');

// We can use the library within the worker now.
console.log('in worker', _.at([ 1, 2, 3], 0, 2));
// → in worker [1, 3]</pre></div><p>We don't need to worry <a id="id239" class="indexterm"/>about waiting for the script to load before we can start using it—<code class="literal">importScripts()</code> is a blocking operation.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec36"/>Communicating with workers</h1></div></div></div><p>The preceding example <a id="id240" class="indexterm"/>created a web worker, which indeed ran in its own thread. But, this is not very helpful to us because we need to be able to communicate with the workers that we create. In this section, we'll cover the basic mechanisms involved with sending and receiving messages from web workers, including how these messages are serialized.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Posting messages</h2></div></div></div><p>When we want to pass data into a<a id="id241" class="indexterm"/> web worker, we use the <code class="literal">postMessage()</code> method. As the name suggests, this method posts the given message to the worker. If there are any message event handlers set up within the worker, they'll respond to this call. Let's look at a basic example that sends a string to a worker:</p><div><pre class="programlisting">// Launches the worker thread.
var worker = new Worker('worker.js');

// Posts a message to the worker, triggering
// any "message" event handlers.
worker.postMessage('hello world');</pre></div><p>Now let's look at the worker that responds to this message by setting up an event handler for the message event:</p><div><pre class="programlisting">// Setup an event listener for any "message"
// events dispatched to this worker.
addEventListener('message', (e) =&gt; {

    // The posted data is accessible through
    // the "data" property of the event.
    console.log(e.type, `"${e.data}"`);
    // → message "hello world"
});</pre></div><div><div><h3 class="title"><a id="note11"/>Note</h3><p>The <code class="literal">addEventListener()</code> function is implicitly called on something called a global dedicated worker context. We can think of this as the  window object for web workers.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>Message serialization</h2></div></div></div><p>The message data that gets <a id="id242" class="indexterm"/>passed from the main thread to worker threads goes through a serialization transformation. When this serialized data arrives at the worker thread, it's deserialized, and the data is usable as a JavaScript primitive type. The same process is in place when the worker thread wants to send data back to the main thread.</p><p>Needless to say, this is an added step that adds overhead to our possibly already over-worked application. Therefore, some thought must be put into passing data back and forth between threads, as this is not a free operation in terms of CPU cost. Throughout the web worker code examples in this book, we'll treat message serialization as a key factor in our concurrency decision-making process.</p><p>So the question is—why go to such lengths? If the workers that we're using in our JavaScript code are simply threads, we should technically be able to use the same objects, since these threads use the same section of memory addresses. When threads share resources, such as objects in memory, challenging resource contention scenarios are likely to occur. For example, if one worker locks an object and another tries to use it, then this is an error. We have to implement  logic that gracefully waits for the object to become available, and we have to implement  logic in the worker that frees the locked resources.</p><p>In short, this is an error prone headache that we're much better off without. Thankfully, there's no resources shared between threads—only serialized messages. This means that we're limited in terms of what types of things can actually be passed to a worker. The rule of thumb is that it's generally safe to pass something that can be encoded as a JSON string. Remember, the worker has to reconstruct the object from this serialized string, so a string representation of a function or a class instance, simply will not work. Let's look at an example to see how this works. First, a simple worker to log the messages it receives:</p><div><pre class="programlisting">// Simply display the content of any
// messages received.
addEventListener('message', (e) =&gt; {
    console.log('message', e.data);
});</pre></div><p>Now let's see what<a id="id243" class="indexterm"/> kind of data we can serialize and send to this worker using <code class="literal">postMessage()</code>:</p><div><pre class="programlisting">// Launches the worker.
var worker = new Worker('worker.js');

// Sends a plain object.
worker.postMessage({ hello: 'world' });
// → message { hello: "world" }

// Sends an array.
worker.postMessage([ 1, 2, 3 ]);
// → message [ 1, 2, 3 ]

// Tries to send a function, results in
// an error being thrown.
worker.postMessage(setTimeout);
// → Uncaught DataCloneError</pre></div><p>As we can see, there's a slight problem when we try to pass a function to <code class="literal">postMessage()</code>. This type cannot be reconstructed once it arrives on the worker thread, and so, <code class="literal">postMessage()</code> simply throws an exception. These types of restrictions may seem overly limiting, but they do eliminate the possibility of many concurrency issues.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Receiving messages from workers</h2></div></div></div><p>Without the ability to pass <a id="id244" class="indexterm"/>data back into the main thread, workers aren't all<a id="id245" class="indexterm"/> that useful to us. At some point, the work <a id="id246" class="indexterm"/>performed by a worker needs to be reflected in the UI. We may recall that worker instances are event targets. This means that we can listen for the message event and respond accordingly when the worker sends back data. Think of this as the inverse of sending data to the worker. The worker simply treats the main thread as another worker by posting messages to it, while the main thread listens for messages. The same serialization restrictions that we explored in the preceding section are relevant here.</p><p>Let's look at some worker code that sends a message back to the main thread:</p><div><pre class="programlisting">// After 2 seconds, post some data back to
// the main thread using the "postMessage()"
// function.
setTimeout(() =&gt; {
    postMessage('hello world');
}, 2000);</pre></div><p>As we can see, this<a id="id247" class="indexterm"/> worker starts, and after 2 seconds, sends a string <a id="id248" class="indexterm"/>back to the main thread. Now, let's see how <a id="id249" class="indexterm"/>we can handle these incoming messages in the main page JavaScript:</p><div><pre class="programlisting">// Launches the new worker.
var worker = new Worker('worker.js');

// Adds an event listener for the "message"
// event. Notice that the "data" property
// contains the actual message payload, the
// same way messages sent to workers do.
worker.addEventListener('message', (e) =&gt; {
    console.log('from worker', `"${e.data}"`);
});</pre></div><div><div><h3 class="title"><a id="note12"/>Note</h3><p>You may have noticed that we do not explicitly terminate any of our worker threads. This is okay. When the browsing context is terminated, all active worker threads are terminated with it. We can explicitly terminate workers using the <code class="literal">terminate()</code> method, which will explicitly stop the thread without waiting for any existing code to complete. However, it's rare to explicitly terminate workers. Once created, workers generally survive the duration of the page. Spawning workers isn't free, it incurs overhead, so we should aim to only do this once, if possible.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec37"/>Sharing application state</h1></div></div></div><p>In this section, we'll <a id="id250" class="indexterm"/>introduce shared workers. First, we'll look at how the same data objects in memory can be accessed by multiple browsing contexts. Then, we'll look at fetching remote resources, and how to notify multiple browsing contexts about the arrival of new data. Finally, we'll look at how shared workers can be leveraged to allow for direct messaging between browser contexts.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>Consider this section  advanced material for experimental coding. The browser support for shared workers isn't that great at the moment (only Firefox and Chrome). Web workers are still in the candidate recommendation phase at the W3C. Once they become a recommendation and better browser support is in place for shared workers, we'll be ready to use them. For extra motivation, as the service worker spec matures, shared worker proficiency will be all the more relevant.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec74"/>Sharing memory</h2></div></div></div><p>The serialization mechanism<a id="id251" class="indexterm"/> that we've seen so far with web workers is in place because we cannot directly reference the same object from more than one thread. However, shared workers have a memory space that's not restricted to just one page, which means that we can indirectly access these objects in memory through various message-passing methods. In fact, this is a good opportunity to demonstrate how we pass messages using ports. Let's get down to it.</p><p>The notion of a port is necessary with shared workers. Without them, there would be no governing mechanism to control the inflow and outflow of messages from shared workers. For example, let's say we had three pages using the same shared worker, then we would have to create three ports to communicate with this worker. Think of a port as a gateway into the worker from the outside world. It's a minor indirection. </p><p>Here's a basic shared worker to give us an idea of what's involved with setting up these types of workers:</p><div><pre class="programlisting">// This is the shared state between the pages that
// connect to this worker.
var connections = 0;

// Listen for pages that connect to this worker, so
// we can setup the message ports.
addEventListener('connect', (e) =&gt; {

    // The "source" property represents the
    // message port created by the page that's
    // connecting to this worker. We have to call
    // "start()" to actually establish the connection.
    e.source.start();

    // We post a message back to the page, the payload
    // is the updated number of connections.
    e.source.postMessage(++connections);
});</pre></div><p>There's a <code class="literal">connect</code> <a id="id252" class="indexterm"/>event that gets triggered once a page connects with this worker. The<code class="literal"> connect</code> event has a <code class="literal">source</code> property, and this is a message port. We have to tell it that the worker is ready to communicate with it by calling <code class="literal">start()</code>. Notice that we have to call <code class="literal">postMessage()</code> on a port, not in the global context. How else would the worker know which page to send the message to? The port acts as a proxy between the worker and the page, as illustrated in the following diagram:</p><div><img src="img/B05133_05_06.jpg" alt="Sharing memory"/></div><p>Now let's see how we can use this shared worker from more than one page:</p><div><pre class="programlisting">// Launches the shared worker.
var worker = new SharedWorker('worker.js');

// Sets up our "message" event handler. By connecting
// to the shared worker, we're actually causing a
// a message to be posted to our messaging port.
worker.port.addEventListener('message', (e) =&gt; {
    console.log('connections made', e.data);
});

// Starts the messaging port, indicating that we're
// ready to start sending and receiving messages.
worker.port.start();</pre></div><p>There are only two major differences between this shared worker and a dedicated worker. They are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We have a <code class="literal">port</code> <a id="id253" class="indexterm"/>object that we can use to communicate with the worker by posting messages and attaching event listeners.</li><li class="listitem" style="list-style-type: disc">We tell the worker that we're ready to start communication by calling the <code class="literal">start()</code> method on the port, just like the worker does. Think of these two <code class="literal">start()</code> calls as a handshake between the shared worker, and its new client.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Fetching resources</h2></div></div></div><p>The preceding example gave us a taste of how <a id="id254" class="indexterm"/>different pages from the same application can share data, avoiding the need to allocate the exact same structure twice any time a page is loaded. Let's build on this idea and use a shared worker to fetch remote resources to share the result with any pages that depend on it. Here's the worker code:</p><div><pre class="programlisting">// Where we store the ports of connected
// pages so we can broadcast messages.
var ports = [];

// Fetches a resource from the API.
function fetch() {
    var request = new XMLHttpRequest();

    // When the response arrives, we only have
    // to parse the JSON string once, and then
    // broadcast it to any ports.
    request.addEventListener('load', (e) =&gt; {
        var resp = JSON.parse(e.target.responseText);

        for (let port of ports) {
            port.postMessage(resp);
        }
    });

    request.open('get', 'api.json');
    request.send();
}

// When a page connects to this worker, we push the
// port to the "ports" array so the worker can keep
// track of it.
addEventListener('connect', (e) =&gt; {
    ports.push(e.source);
    e.source.start();
});

// Now we can "poll" the API, and broadcast the result
// to any pages.
setInterval(fetch, 1000);</pre></div><p>Instead of responding to the<a id="id255" class="indexterm"/> port when the page connects to the worker, we simply store a reference to it in the <code class="literal">ports</code> array. This is how we keep track of the pages connected to the worker, which is important here because not all messages follow the command-response pattern. In this case, we want to broadcast the updated API resource to any page that maybe listening to it. A common case will be one page, but in the case where there are many browser tabs open looking at the same application, we can use the same data.</p><p>For example, if the API resource were a large JSON array that needed to be parsed, this would get wasteful if the exact same data needs to be parsed by three different browser tabs. Another savings is that we're not polling the API 3 times per second, which would be the case if each page was running its own polling code. When it's in the shared worker context, it only happens once, and the data is distributed out to the connected pages. This is less taxing on the back-end as well because in the aggregate, there are far fewer requests made. Let's <a id="id256" class="indexterm"/>look at the code that uses this worker now:</p><div><pre class="programlisting">// Launch the worker.
var worker = new SharedWorker('worker.js');

// Listen to the "message" event, and log
// any data that's sent back from the worker.
worker.port.addEventListener('message', (e) =&gt; {
    console.log('from worker', e.data);
});

// Inform the shared worker that we're ready
// to start receiving messages.
worker.port.start();</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Communicating between pages</h2></div></div></div><p>So far, we've treated data within <a id="id257" class="indexterm"/>shared workers as a central resource. That is, it comes from a centralized place, such as an API, and then it is read by the pages connected to the worker. We haven't actually modified any data directly from a page yet. For instance, let's say we're not even connected to a back-end, and a page is manipulating a data structure in the shared worker. Other pages would then need to know about these changes.</p><p>But then, let's say the user switches to one of these pages and makes some adjustments. We have to support bidirectional updating. Let's take a look at how we will go about implementing such capabilities using a shared worker:</p><div><pre class="programlisting">// Stores the ports of any connected pages.
var ports = [];

addEventListener('connect', (e) =&gt; {

    // The received message data is distributed to any
    // pages connected to this worker. The page code
    // decides how to handle the data.
    e.source.addEventListener('message', (e) =&gt; {
        for (let port of ports) {
            port.postMessage(e.data);
        }
    });

    // Store the port reference for the connected page,
    // and start communications using the "start()"
    // method.
    ports.push(e.source);
    e.source.start();
});</pre></div><p>This worker is <a id="id258" class="indexterm"/>nothing more than a satellite; it simply transmits anything it receives to all connected ports. This is all we need, so why add more? Let's take a look at the page code that connects to this worker:</p><div><pre class="programlisting">// Launch the shared worker, and store a reference
// to the main UI element we're working with.
var worker = new SharedWorker('worker.js');
var input = document.querySelector('input');

// Whenever the input value changes, post the input
// value to the worker for other pages to consume.
input.addEventListener('input', (e) =&gt; {
    worker.port.postMessage(e.target.value);
});

// When we receive input data, update the value of our
// text input. That is, unless the value is already
// updated.
worker.port.addEventListener('message', (e) =&gt; {
    if (e.data !== input.value) {
        input.value = e.data;
    }
});

// Starts worker communications.
worker.port.start();</pre></div><p>Interesting! So now, if <a id="id259" class="indexterm"/>we go ahead and open up two or more browser tabs with this page inside, any changes we make to the input value will be reflected in other pages—instantly. What's neat about this design is that it works the same; no matter which page is performing the update, any other page receives the updated data. In other words, the pages take on the dual role of data producer and data consumer.</p><div><div><h3 class="title"><a id="note14"/>Note</h3><p>You may have noticed that the worker in this last example sends a message to to all ports, including the port that sent the message. We probably don't want to do this. To avoid sending messages to the sender, we would need to somehow exclude the sending port in the <code class="literal">for..of</code> loop.</p><p>This actually isn't easy to do since no port-identifying information is sent with the <code class="literal">message</code> event. We can establish port identifiers and have messages contain IDs. There's a lot of work here, and the benefit isn't all that great. The concurrency design trade-off here is to simply check in the page code that the message is actually relevant to the page.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec38"/>Performing sub-tasks with sub-workers</h1></div></div></div><p>All the workers that we've <a id="id260" class="indexterm"/>created so far in this chapter—dedicated<a id="id261" class="indexterm"/> workers and shared workers—were launched by the main thread. In this section, we'll address the idea of sub-workers. They're similar to dedicated workers, only with a different creator. For example, a sub-worker can't directly interact with the main thread, only by proxy through the thread that spawned the sub-worker.</p><p>We'll look at dividing larger tasks into smaller ones, and we'll also look at some challenges surrounding sub-workers.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Dividing work into tasks</h2></div></div></div><p>The job of our <a id="id262" class="indexterm"/>web workers is to carry out tasks in such a way that the <a id="id263" class="indexterm"/>main thread can continue to service things, such as DOM events, without interruption. Some tasks are straightforward for a web worker thread to handle. They take input, compute a result, and return that result as output. But, what if the task is larger? What if it involves a number of smaller discrete steps, allowing us to breakdown the larger task into smaller ones?</p><p>With tasks like these, it makes sense to break them down into smaller sub-tasks so that we can further leverage all available CPU cores. However, decomposing the task into smaller ones can itself incur a heavy performance penalty. If the decomposition is left in the main thread, our user experience could suffer. One technique that we would utilize here involves launching a web worker whose job is to break down a task into smaller steps and launch a sub-worker for each of these steps.</p><p>Let's create a worker that searches an array for a specific item and returns true if the item exists. If the input array is large, we would split it into several smaller arrays, each of which is searched in parallel. These parallel search tasks will be created as sub-workers. First, we'll take <a id="id264" class="indexterm"/>a look <a id="id265" class="indexterm"/>at the sub-worker:</p><div><pre class="programlisting">// Listens for incoming messages.
addEventListener('message', (e) =&gt; {

    // Posts a result back to the worker.
    // We call "indexOf()" on the input
    // array, looking for the "search" data.
    postMessage({
        result: e.data.array
            .indexOf(e.data.search) &gt; -1
    });
});</pre></div><p>So, we now have a sub-worker that can take a chunk of an array and return a result. This is pretty simple. Now for the tricky part, let's implement the worker that divides the input array into smaller inputs, which are then fed into the sub-workers.</p><div><pre class="programlisting">addEventListener('message', (e) =&gt; {

    // The array that we're going to divide into
    // 4 smaller chunks.
    var array = e.data.array;

    // Computes the size, roughly, of a quarter
    // of the array - this is our chunk size.
    var size = Math.floor(0.25 * array.length);

    // The search data we're looking for.
    var search = e.data.search;

    // Used to divide the array into chunks in
    // the "while" loop below.
    var index = 0;

    // Where our chunks go, once they've been sliced.
    var chunks = [];

    // We need to store references to our sub-workers,
    // so we can terminate them.
    var workers = [];

    // This is for counting the number of results
    // returned from sub-workers.
    var results = 0;

    // Splits the array into proportionally-sized chunks.
    while (index &lt; array.length) {
    chunks.push(array.slice(index, index + size));
        index += size;
    }

    // If there's anything left over (a 5th chunk),
    // throw it into the chunk before it.
    if (chunks.length &gt; 4) {
        chunks[3] = chunks[3].concat(chunks[4]);
        chunks = chunks.slice(0, 4);
    }

    for (let chunk of chunks) {

        // Launches our sub-worker and stores a
        // reference to it in "workers".
        let worker = new Worker('sub-worker.js');
        workers.push(worker);

        // The sub-worker has a result.
        worker.addEventListener('message', (e) =&gt; {
            results++;

            // The the result is "truthy", we can post
            // a response back to the main thread.
            // Otherwise, we check if all the
            // responses are back yet. If so, we can
            // post a false value back. Either way, we
            // terminate all sub-workers.
            if (e.data.result) {
                postMessage({
                    search: search,
                    result: true
                });

                workers.forEach(x =&gt; x.terminate());
            } else if (results === 4) {
                postMessage({
                    search: search,
                    result: false
                });

                workers.forEach(x =&gt; x.terminate());
            }
        });

        // Give the worker a chunk of array to search.
        worker.postMessage({
            array: chunk,
            search: search
        });
    }
});</pre></div><p>What's neat about this approach is that once we have a positive result, we can terminate all the existing sub-workers. So, if we work through an especially large data set, we can avoid having one or more sub-workers churn needlessly in the background.</p><p>The approach that we've taken here is to slice the input array into four proportional (25%) chunks. This way, we limit the concurrency level to four. In the next chapter, we'll further address subdividing tasks and tactics for determining the concurrency level to use.</p><p>For now, let's <a id="id266" class="indexterm"/>complete our example by writing some code to use this <a id="id267" class="indexterm"/>worker on our page:</p><div><pre class="programlisting">// Launches the worker...
var worker = new Worker('worker.js');

// Generates some input data, an array
// of numbers for 0 - 1041.
var input = new Array(1041)
    .fill(true).map((v, i) =&gt; i);

// When the worker responds, display the
// results of our search. 
worker.addEventListener('message', (e) =&gt; {
    console.log(`${e.data.search} exists?`, e.data.result);
});

// Search for an item that exists.
worker.postMessage({
    array: input,
    search: 449
});
// → 449 exists? true

// Search for an item that doesn't exist.
worker.postMessage({
    array: input,
    search: 1045
});
// → 1045 exists? false</pre></div><p>We're able to talk to the worker, passing it an input array and data to search for. The results are passed by to the main thread, and they include the search term, so we're able to reconcile the output with the original message that we sent to the worker. However, there are some significant hurdles to overcome here. While this is really useful, being able to subdivide tasks to make better use of multi-core CPUs, there's a lot of complexity involved. Once we have the results from each subworker, we have to deal with reconciliation.</p><p>If this simple example can grow as complex as it has, then imagine similar code in the context of a large application. There are two angles from which we can tackle these concurrency issues. The first is the up-front design challenges around concurrency. These are tackled<a id="id268" class="indexterm"/> in the next chapter. Then, there are the synchronization challenges—how do we avoid <a id="id269" class="indexterm"/>callback hell? This topic is addressed in depth, in <a class="link" href="ch07.html" title="Chapter 7. Abstracting Concurrency">Chapter 7</a>, <em>Abstracting Concurrency</em>.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec78"/>A word of caution</h2></div></div></div><p>While the preceding example is a powerful <a id="id270" class="indexterm"/>concurrency technique that can offer huge performance gains, there are a couple downsides to be aware of. So before diving into an implementation that involves sub-workers, consider some of these challenges and the trade-offs that you'll have to make.</p><p>Sub-workers <a id="id271" class="indexterm"/>don't have a parent page to directly communicate with. This complicates designs because even a simple response from a sub-worker needs to be proxied through a worker that was created directly by JavaScript running in the main thread. What this leads to is a pile of tangled communication paths. In other words, it's easy to complicate the design by adding more moving parts than might actually be warranted. So, before deciding on sub-workers as a design option, let's first rule out an approach that can rely on dedicated workers.</p><p>The second problem is that since web workers are still a candidate W3C recommendation, not all browsers implement certain aspects of web workers consistently. Shared workers and sub-workers are the two areas we're likely to encounter cross-browser issues. On the other hand, dedicated workers have great browser support and behave consistently across most vendors. Once again, start with a simple dedicated worker design, and if that doesn't work, think about introducing shared workers, and sub-workers.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Error handling in web workers</h1></div></div></div><p>All the code in this<a id="id272" class="indexterm"/> chapter has made a naive assumption that the code running in our workers was error-free. Obviously, our workers will encounter situations where exceptions are thrown, or we'll just write buggy code during development—it's the reality we face as programmers. However, without proper error event handlers in place, web workers can be difficult to debug. Another approach we can take is to explicitly send back a message that identifies itself as being in an error state. We'll cover these two error-handling topics in this section.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec79"/>Error condition checking</h2></div></div></div><p>Let's say our main application <a id="id273" class="indexterm"/>code sends a message to a worker thread and expects to get some data in return. What if something goes wrong and the code that was expecting data needs to know about it? One possibility is to still send the message that the main thread is expecting; only that it has a field that indicates the errant state of the operation. The following illustration gives us an idea of what this looks like:</p><div><img src="img/B05133_05_07.jpg" alt="Error condition checking"/></div><p>Now let's look at some code that implements this approach. First, the worker that determines the state of the message to return either a successful or an error state:</p><div><pre class="programlisting">// When a message arrives, check if the provided
// data is an array. If not, post a response
// with the "error" property set. Otherwise,
// compute and respond with the result.
addEventListener('message', (e) =&gt; {
    if (!Array.isArray(e.data)) {
        postMessage({
            error: 'expecting an array'
        });
    } else {
        postMessage({
            result: e.data[0]
        });
    }
});</pre></div><p>This worker will always <a id="id274" class="indexterm"/>respond by posting a message, but it doesn't always compute a result. First, it checks to make sure that the input value is acceptable. If it doesn't get the array it's expecting, it posts a message with the error state set. Otherwise, it posts the result like normal. Now, let's write some code to use this worker:</p><div><pre class="programlisting">// Launches the worker.
var worker = new Worker('worker.js');

// Listens for messages coming from the worker.
// If we get back an error, we log the error
// message. Otherwise, we log the successful result.
worker.addEventListener('message', (e) =&gt; {
    if (e.data.error) {
        console.error(e.data.error);
    } else {
        console.log('result', e.data.result);
    }
});

worker.postMessage([ 3, 2, 1 ]);
// → result 3

worker.postMessage({});
// → expecting an array</pre></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec80"/>Exception handling</h2></div></div></div><p>Even if we explicitly check for error<a id="id275" class="indexterm"/> conditions in our workers, as we did in the last example, there are cases where exceptions might be thrown. From the perspective of our main application thread, we need to handle these types of uncaught errors. Without the proper error-handling mechanism in place, our web workers will fail silently. Sometimes, it seems that the workers don't even load—dealing with this radio silence is a nightmare to debug.</p><p>Let's take a look at an example that listens to the <code class="literal">error</code> event of a web worker. Here's a web worker that tries to access a non-existent property:</p><div><pre class="programlisting">// When a message arrays, post a response
// that contains the "name" property of
// the input data. The what if data isn't
// defined?
addEventListener('message', (e) =&gt; {
    postMessage(e.data.name);
});</pre></div><p>There's no error-handling code here. All we're doing is responding to a message by reading the <code class="literal">name</code> property and sending it back. Let's take a look at some code that uses this worker, and how it can respond to exceptions raised in this worker:</p><div><pre class="programlisting">// Launches our worker.
var worker = new Worker('worker.js');

// Listen to messages sent back from the worker,
// and log the result.
worker.addEventListener('message', (e) =&gt; {
    console.log('result', `"${e.data}"`);
});

// Listen to errors sent back from the worker,
// and log the error message.
worker.addEventListener('error', (e) =&gt; {
    console.error(e.message);
});

worker.postMessage(null);
// → Uncaught TypeError: Cannot read property 'name' of null

worker.postMessage({ name: 'JavaScript' });
// → result "JavaScript"</pre></div><p>Here, we can see that the first message posted to the worker results in an exception being thrown within the worker. However, this exception is encapsulated within the worker—it isn't thrown in our main thread. Since we're listening to the <code class="literal">error</code> event in our main thread, we can<a id="id276" class="indexterm"/> respond accordingly. In this case, we simply log the error message. However, in other cases, we may need to take more elaborate corrective action, such as freeing resources or posting a different message to the worker.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Summary</h1></div></div></div><p>In this chapter, we introduced the concept of parallel execution using web workers. Before web workers, there were no means for our JavaScript to utilize the multiple CPU cores found on most hardware today.</p><p>We started off with a high-level overview of what web workers are. They're operating-system-level threads at their foundation. From a JavaScript perspective, they're event targets where we can post messages and listen to <code class="literal">message</code> events. Workers come in three varieties—dedicated, shared, and sub-workers.</p><p>You then learned how to communicate with web workers by posting messages and listening to events. You learned that there's a limitation in place in terms of what can be passed in a message. This is due to the fact that all message data is serialized and reconstructed in the target thread.</p><p>We wrapped up the chapter with a look at how to go about handling errors and exceptions in web workers. In the following chapter, we'll address the practical aspects of parallelization—the types of work should we perform in parallel, and the best way to implement it.</p></div></body></html>