- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Introduction to Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to the first chapter of the book! Node.js is one of the most relevant
    technologies available and allows you to build any kind of project (web, desktop,
    CLI tools, microservices, IoT, and so on) within the same stack. The community
    around the project is very powerful and innovative.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will explore the main features of Node.js and why it became
    so popular over time. Then, we will explore the Node.js architecture and how it
    works. Finally, we will explore the different versions of Node.js available to
    us.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What makes Node.js so special and why it is a revolutionary technology
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Node.js architecture and how it works
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to identify the right Node.js version for your projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This knowledge will help you to decide when it is a good fit for your projects
    and will guide you around the complex ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code files for the chapter can be found at [https://github.com/PacktPublishing/NodeJS-for-Beginners](https://github.com/PacktPublishing/NodeJS-for-Beginners).
  prefs: []
  type: TYPE_NORMAL
- en: Why is Node.js so popular?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The official definition of Node.js is very simple, but it doesn’t explain why
    Node.js has become so popular over time:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“*Node.js® is an open-source, cross-platform JavaScript runtime environment.*”*'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 1**.1*, we can see how the popularity of Node.js has been increasing
    over time, and even today, it is still growing fast.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – The interest in Node.js, generated using Google Trends](img/B21678_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – The interest in Node.js, generated using Google Trends
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s explore the main reasons why Node.js is so popular.
  prefs: []
  type: TYPE_NORMAL
- en: Lightweight and fast
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is a lightweight and fast runtime based on the V8 JavaScript engine,
    which is the same engine that powers Google Chrome and Microsoft Edge, among others.
    It is based on a single-thread architecture and event-driven model, which means
    that it doesn’t need to create a new thread for each request, as in other popular
    tools such as PHP. This is a huge advantage because the memory consumption is
    very low and the performance is very high.
  prefs: []
  type: TYPE_NORMAL
- en: We will explore the single-thread architecture in detail in the upcoming sections.
  prefs: []
  type: TYPE_NORMAL
- en: Cross-platform and multi-purpose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is cross-platform, which means that we can run it on any operating system
    and architecture available in the modern market.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js is not only used to build web applications but it can also be used to
    build any kind of application, from a simple command-line tool to a complex desktop
    application such as Slack or Visual Studio Code.
  prefs: []
  type: TYPE_NORMAL
- en: Easy learning curve
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js is based on JavaScript, which is one of the most popular programming
    languages in the world. This means that millions of developers already know the
    language and they can easily start using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Any application that can be written in JavaScript, will eventually be written
    in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: – Jeff Atwood (Atwood’s Law)
  prefs: []
  type: TYPE_NORMAL
- en: Also, the Node.js **application programming interface** (**API**) – the methods,
    libraries, and utilities that Node.js provides for us to use – is very simple
    and easy to use, so the learning curve is very small. You don’t need to master
    the Node.js API to start building web applications; you can progressively learn
    while you are building your application.
  prefs: []
  type: TYPE_NORMAL
- en: There are a lot of resources available to learn Node.js, from official documentation
    to online courses and tutorials in many languages and oriented to different profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Ecosystem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js has a huge ecosystem of packages, JavaScript libraries, and resources
    developed by the community that can be used to build any kind of application.
    There are more than two and a half million packages available in the npm Registry
    ([https://www.npmjs.com/](https://www.npmjs.com/)), which is the official package
    manager for Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Also, Node.js has huge support from cloud providers, which means that you can
    easily deploy your application to the cloud and scale it as much as you need.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the emerging technologies provide **software development kits** (**SDKs**)
    for Node.js, so you can easily integrate your application with them. Many companies
    are using Node.js in production, so you can easily find support and resources
    to solve any problem that you may have.
  prefs: []
  type: TYPE_NORMAL
- en: Also, many popular libraries are isomorphic, which means that they can be used
    in the browser and in the server, so you can reuse your code and avoid duplications.
  prefs: []
  type: TYPE_NORMAL
- en: Community-powered
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For me, the most important reason why Node.js is so popular is the community.
    Node.js has a huge community of developers that are constantly contributing to
    the project. This means that you can easily find support and resources to solve
    any problem that you may have and also to include new features or solve specific
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js Foundation merged with the JS Foundation in 2019 to create the OpenJS
    Foundation [https://openjsf.org/](https://openjsf.org/), which is the current
    organization that governs the Node.js project and other key projects in the JavaScript
    ecosystem, such as Appium, jQuery, Electron, Express, and webpack.
  prefs: []
  type: TYPE_NORMAL
- en: Important information
  prefs: []
  type: TYPE_NORMAL
- en: You can find the governance model of the OpenJS Foundation at [https://openjsf.org/about/governance/](https://openjsf.org/about/governance/)
    and the Node.js project at [https://nodejs.org/en/about/governance](https://nodejs.org/en/about/governance).
  prefs: []
  type: TYPE_NORMAL
- en: Many companies are members of the OpenJS Foundation, such as Google, IBM, Microsoft,
    Netflix, Red Hat, GitHub, and many others ([https://openjsf.org/about/members/](https://openjsf.org/about/members/)).
    These provide a lot of support and resources to keep the project alive.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, many factors are helping Node.js to become so popular, from
    a proven community-powered model to a solid ecosystem that brings many capabilities
    to Node.js. It appears that Node.js will remain popular in the future!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore how the architecture works under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js single-thread architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When Node.js came out in 2009, it was a revolution in the web development world,
    as Ryan Dahl, the creator of Node.js, decided to use a very unusual approach at
    that time: a single-thread architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In his presentation about Node.js at the JSConf ([https://www.youtube.com/watch?v=EeYvFl7li9E](https://www.youtube.com/watch?v=EeYvFl7li9E)),
    Ryan Dahl said he wanted to achieve two key things when building Node.js: server-side
    JavaScript and non-blocking I/O.'
  prefs: []
  type: TYPE_NORMAL
- en: I/O needs to be done differently
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The common approach for I/O operations in web applications is to create a new
    thread for each request. This is a very expensive operation because the memory
    consumption is very high and the performance is very low.
  prefs: []
  type: TYPE_NORMAL
- en: The idea behind this approach is to split the system resources and assign them
    to each thread. This is a very inefficient approach because, most of the time,
    the CPUs are idle, just waiting for the resources.
  prefs: []
  type: TYPE_NORMAL
- en: The other problem is that we are limited in the amount of memory that we can
    use because each thread needs to have its own memory space.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, this process was very inefficient, and it was not scalable.
  prefs: []
  type: TYPE_NORMAL
- en: Non-blocking I/O
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Node.js, we use a different approach. We won’t split the resources; we
    keep a single thread and use a non-blocking I/O model that allows us to free the
    resources while waiting, so we can continue processing requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this possible, Node.js has two key dependencies: libuv ([https://libuv.org/](https://libuv.org/))
    and V8 ([https://v8.dev/](https://v8.dev/)).'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Diagram that showcase the relationship between the user code,
    v8, Node API and libuv (event queue and worker threads)](img/B21678_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Diagram that showcase the relationship between the user code, v8,
    Node API and libuv (event queue and worker threads)
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the architecture has many pieces and it can be a bit overwhelming
    at first. This diagram is not the full picture but it is a good starting point
    to understand how Node.js works in the context of this chapter. There are many
    pieces to understand from this figure, so let’s go step by step.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js application
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the code that we write to build our application. It will be done in
    JavaScript and it can use Node.js APIs and third-party libraries.
  prefs: []
  type: TYPE_NORMAL
- en: V8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the engine encapsulated in Node.js that will execute our JavaScript
    code. V8 is the same engine that is used in the Chrome browser under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js bindings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is surprising for many developers to see that Node.js is written mostly in
    C/C++, but this is one of the reasons why Node.js is so fast. The Node.js bindings
    are the C/C++ code that will be executed when we use the Node.js APIs under the
    hood.
  prefs: []
  type: TYPE_NORMAL
- en: libuv
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is the C library that will handle the I/O operations with multi-platform
    support. It will use the thread pool to execute the blocking operations and it
    will notify the Node.js bindings when the operation is completed. We will program
    Node.js defining functions that will be executed when certain async operations
    are completed. For example, when we try to read the content from a file, we will
    execute certain code when the content is available. libuv handles the low-level
    logic for this coordination to happen.
  prefs: []
  type: TYPE_NORMAL
- en: Going deeper into the event loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The event loop is the most critical part of the Node.js architecture. Keeping
    this in mind will help you to understand how Node.js works.
  prefs: []
  type: TYPE_NORMAL
- en: As we have seen before, the new I/O operations approach is not magic, just a
    very smart way to handle and abstract using an asynchronous layer that is easily
    handled with JavaScript. This introduces the need for us to know how to do asynchronous
    programming. We will cover this topic in more detail in [*Chapter 4*](B21678_04.xhtml#_idTextAnchor132),
    but for now, we need to understand how the event loop works.
  prefs: []
  type: TYPE_NORMAL
- en: 'One fantastic resource to understand the event loop in more depth is this talk
    from Philip Roberts at JSConf EU 2014: *What the heck is the event loop anyway?*
    ([https://www.youtube.com/watch?v=8aGhZQkoFbQ](https://www.youtube.com/watch?v=8aGhZQkoFbQ)).
    It also includes a tool called Loupe ([http://latentflip.com/loupe](http://latentflip.com/loupe))
    to experiment with the event loop architecture yourself.'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, Node.js is the product of combining several technologies. The
    event loop is quite an advanced topic that you will require some time to digest
    and understand fully, but don’t worry, as you can start working with Node.js even
    if you are not yet 100% clear on how the event loop and all the pieces work together.
    You will be able to learn about it better in practice with the exercises from
    the book. Now, let’s explore how Node.js organizes the versions.
  prefs: []
  type: TYPE_NORMAL
- en: Node.js versions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js follows **semantic versioning** (**SemVer**) ([https://semver.org/](https://semver.org/))
    and it is important to understand how this versioning works in order to choose
    the best version for the project.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning (SemVer)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When considering semantic versioning, it helps to determine what changes to
    anticipate as a user, especially whether they might cause disruptions or not.
    This understanding assists our end users in preparing for potential updates.
  prefs: []
  type: TYPE_NORMAL
- en: Semantic versioning is one of the most popular ways to version software. In
    the following figure, we can differentiate the elements used to build the release
    version.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Parts of a semantic version number (source: Devopedia 2020,
    https://devopedia.org/images/article/279/2766.1593275997.svg)](img/B21678_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1.3 – Parts of a semantic version number (source: Devopedia 2020, [https://devopedia.org/images/article/279/2766.1593275997.svg](https://devopedia.org/images/article/279/2766.1593275997.svg))'
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new version is released, the version number is incremented following
    the SemVer rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Major** versions add incompatible API changes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Minor** versions add functionality in a backward-compatible manner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Patch** versions add backward-compatible bug fixes'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Following these rules, we can easily upgrade the Node.js version in any project
    without breaking the code when the changes are cataloged as minor or a patch.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to upgrade to a new major version, we will need to check whether
    there are any breaking changes that we need to address before upgrading. In most
    cases, the breaking changes are not related to our own code but to the dependencies
    that we are using in the project.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: '**Metadata** is optional, and it is not used to define the version of the software
    but provides additional information. In general, we will try to avoid using versions
    with metadata as they are not stable versions but they can be used for testing
    purposes.'
  prefs: []
  type: TYPE_NORMAL
- en: Release details
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we move on to the release schedule, it is important to understand how
    we can check the details of any release. This is very important if we plan to
    upgrade to a major version, as it contains breaking changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, we will analyze the Node.js 20.0.0 release, so we can see the
    details of the latest LTS version through the blog details: [https://nodejs.org/en/blog/release/v20.0.0/](https://nodejs.org/en/blog/release/v20.0.0/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every release has a structured blog post with the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Summary**: Here, we can find a brief description of the release.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Notable Changes**: Here, we can find the most important changes in the release,
    including examples and a lot of contexts behind the new features or deprecations.
    We can also see the more relevant changes in the dependencies that may affect
    the Node.js APIs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Semver-(*) Commits**: Here, we can find the commits that are related to the
    SemVer changes (**Semver-Major Commits**, **Semver-Minor Commits**, and **Semver-Patch
    Commits**) and access the code changes directly using the *commits* reference.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Information
  prefs: []
  type: TYPE_NORMAL
- en: The release information is available directly in the changelog. The changelog
    version includes references to all the commits and pull requests included in the
    release, so it is a great source of information when you need to migrate from
    another Node.js version. You can find the changelog version at [https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V20.md#2023-04-18-version-2000-current-rafaelgss](https://github.com/nodejs/node/blob/main/doc/changelogs/CHANGELOG_V20.md#2023-04-18-version-2000-current-rafaelgss).
  prefs: []
  type: TYPE_NORMAL
- en: One of the best ways to explore the change in a release in more detail is to
    directly use the Node.js documentation – for example, [https://nodejs.org/dist/latest-v20.x/docs/api/](https://nodejs.org/dist/latest-v20.x/docs/api/).
    The website offers the option to navigate through the different versions so we
    can check the changes in the APIs between versions more easily.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Node.js official documentation screenshot](img/B21678_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Node.js official documentation screenshot
  prefs: []
  type: TYPE_NORMAL
- en: Release schedule
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js project has a release schedule that is published on the official
    website ([https://nodejs.org/en/about/releases/](https://nodejs.org/en/about/releases/))
    and it is updated by the Node.js Release Working Group.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Official release schedule from the Node.js website](img/B21678_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Official release schedule from the Node.js website
  prefs: []
  type: TYPE_NORMAL
- en: 'In Node.js, releases have three different phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Current** is the phase where new features (non-major changes) are added to
    the project. This phase is very active, and it is not always recommended to use
    it in production as it is not a stable version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Active Long-Term Support** (**LTS**) is the phase where the version is stable
    and has been updated by the LTS team. This phase still includes new features,
    bug fixes, and updates. This phase is stable, so it is recommended to use it in
    production.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance** is the phase where the version is not receiving any new features,
    only critical bug fixes and security updates. This phase is recommended for projects
    that are not able to upgrade yet to the latest active LTS version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Odd-numbered release lines are not promoted to active LTS, so they are not recommended
    for production use.
  prefs: []
  type: TYPE_NORMAL
- en: As of today, for any new project, I will recommend using the latest LTS version,
    which is 20.11.0\. This version will be supported until April 2026, so it is a
    good choice for any new project.
  prefs: []
  type: TYPE_NORMAL
- en: For any existing project using Node.js v18, it is recommended to start migrating
    to Node.js 20 as v18 is entering the *maintenance* phase.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'While releasing a new version seems like an easy task, it is not. The Release
    Working Group has defined the complete process, which includes more than 20 steps.
    You can find all the relevant information in the official documentation ([https://github.com/nodejs/node/blob/main/doc/contributing/releases.md](https://github.com/nodejs/node/blob/main/doc/contributing/releases.md))
    or this talk: *The Life and Times of a Node.js Release*, by Danielle Adams at
    NodeConf EU 2022 ([https://www.youtube.com/watch?v=OiSBodpU174](https://www.youtube.com/watch?v=OiSBodpU174)).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored what makes Node.js so special and how it differs
    from other backend systems. We also covered the history of Node.js and how it
    has evolved over the years.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, we covered the Node.js architecture and how it works under the
    hood. We learned about the event loop and how it allows Node.js to handle many
    concurrent requests efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to set up the development environment
    and start using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Node.js governance: [https://nodejs.org/en/about/governance](https://nodejs.org/en/about/governance)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'OpenJS Foundation governance: [https://openjsf.org/about/governance/](https://openjsf.org/about/governance/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The Life and Times of a Node.js Release*, by Danielle Adams at NodeConf EU
    2022: [https://www.youtube.com/watch?v=OiSBodpU174](https://www.youtube.com/watch?v=OiSBodpU174)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node.js dependencies: [https://github.com/nodejs/node/blob/main/doc/contributing/maintaining/maintaining-dependencies.md](https://github.com/nodejs/node/blob/main/doc/contributing/maintaining/maintaining-dependencies.md)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Node.js event loop architecture: [https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4](https://medium.com/preezma/node-js-event-loop-architecture-go-deeper-node-core-c96b4cec7aa4)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How Node.js Bootstraps Itself*, 2019 edition, Joyee Cheung, Igalia: [https://www.youtube.com/watch?v=bwiLlcGvFEk](https://www.youtube.com/watch?v=bwiLlcGvFEk)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Node.js 12: A Decade of Node.js*, Beth Griggs, IBM: [https://www.youtube.com/watch?v=HP4N0u_dEgI](https://www.youtube.com/watch?v=HP4N0u_dEgI)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Node.js 2023 Year in An* *Article*: [https://blog.rafaelgss.dev/nodejs-2023-year-in-review](https://blog.rafaelgss.dev/nodejs-2023-year-in-review)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
