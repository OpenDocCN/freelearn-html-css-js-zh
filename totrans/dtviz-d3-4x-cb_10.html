<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Interacting with Your Visualization</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Interacting with the mouse</li><li class="listitem" style="list-style-type: disc">Interacting with a multi-touch device</li><li class="listitem" style="list-style-type: disc">Implementing the zoom and pan behavior</li><li class="listitem" style="list-style-type: disc">Implementing the drag behavior</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec70"/>Introduction</h1></div></div></div><div><blockquote class="blockquote"><p>
<em>The ultimate goal of visualization design is to optimize applications so that they help us perform cognitive work more efficiently.</em>
</p></blockquote></div><div><blockquote class="blockquote"><p>
<em>Ware C. (2012)</em>
</p></blockquote></div><p>The goal of data visualization is to help the audience gain information from a large quantity of raw data quickly and efficiently through metaphor, mental model alignment, and cognitive magnification. So far, in this book, we have introduced various techniques to leverage D3 library by implementing many types of visualization. However, we haven't touched a crucial aspect of visualization: human interaction. Various research have concluded the unique value of human interaction in information visualization.</p><div><blockquote class="blockquote"><p>
<em>Visualization combined with computational steering allows faster analyses of more sophisticated scenarios...This case study adequately demonstrate that the interaction of a complex model with steering and interactive visualization can extend the applicability of the modelling beyond research</em>
</p></blockquote></div><div><blockquote class="blockquote"><p>
<em>Barrass I. &amp; Leng J (2011)</em>
</p></blockquote></div><p>In this chapter, we will focus on D3 human visualization interaction support; or, as mentioned earlier, you will learn how to add computational steering capability to your visualization.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Interacting with mouse events</h1></div></div></div><p>The mouse is the most common and popular human-computer interaction control found on most desktop and laptop computers. Even today, with multi-touch devices rising to dominance, touch events are still commonly emulated with mouse events. In this recipe, we will learn how to handle standard mouse events in D3.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec206"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter10/mouse.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter10/mouse.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec207"/>How to do it...</h2></div></div></div><p>In the following code example, we will explore techniques of registering and handling mouse events in D3. Although in this particular example we are handling only <code class="literal">click</code> and <code class="literal">mousemove</code>, the techniques utilized here can be applied easily to all other standard mouse events supported by modern browsers:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var r = 400; 
 
    var svg = d3.select("body") 
            .append("svg"); 
 
    var positionLabel = svg.append("text") 
            .attr("x", 10) 
            .attr("y", 30); 
 
    svg.on("mousemove", function () { //&lt;-A 
        printPosition(); 
    }); 
             
    function printPosition() { //&lt;-B 
        var position = d3.mouse(svg.node()); //&lt;-C 
        positionLabel.text(position); 
    }   
 
    svg.on("click", function () { //&lt;-D 
        for (var i = 1; i &lt; 5; ++i) { 
            var position = d3.mouse(svg.node()); 
 
            var circle = svg.append("circle") 
                    .attr("cx", position[0]) 
                    .attr("cy", position[1]) 
                    .attr("r", 0) 
                    .style("stroke-width", 5 / (i)) 
                    .transition() 
                        .delay(Math.pow(i, 2.5) * 50) 
                        .duration(2000) 
                        .ease(d3.easeQuadIn) 
                    .attr("r", r) 
                    .style("stroke-opacity", 0) 
                    .on("end", function () { 
                        d3.select(this).remove(); 
                    }); 
        } 
    }); 
&lt;/script&gt; 
</pre><p>This recipe generates the following interactive visualization when you click on the SVG image:</p><p>
</p><div><img src="img/image_10_001.jpg" alt="How to do it..."/></div><p>
</p><p>Mouse interaction</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec208"/>How it works...</h2></div></div></div><p>In D3, to register an event listener, we need to invoke the <code class="literal">on</code> function on a particular selection. The given event listener will be attached to all the selected elements for the specified event (refer to line A). The following code in this recipe attaches a <code class="literal">mousemove</code> event listener, which displays the current mouse position (refer to line B):</p><pre class="programlisting">svg.on("mousemove", function () { //&lt;-A 
    printPosition(); 
}); 
             
function printPosition() { //&lt;-B 
    var position = d3.mouse(svg.node()); //&lt;-C 
    positionLabel.text(position); 
}   
</pre><p>On line C, we used <code class="literal">d3.mouse</code> function to obtain the current mouse position relative to the given container element. This function returns a two-element array [x, y]. After this, we also registered an event listener for a mouse <code class="literal">click</code> event on line D using the same <code class="literal">on</code> function:</p><pre class="programlisting">svg.on("click", function () { //&lt;-D 
        for (var i = 1; i &lt; 5; ++i) { 
            var position = d3.mouse(svg.node()); 
 
        var circle = svg.append("circle") 
                .attr("cx", position[0]) 
                .attr("cy", position[1]) 
                .attr("r", 0) 
                .style("stroke-width", 5 / (i)) // &lt;-E 
                .transition() 
                    .delay(Math.pow(i, 2.5) * 50) // &lt;-F 
                    .duration(2000) 
                    .ease('quad-in') 
                .attr("r", r) 
                .style("stroke-opacity", 0) 
                .each("end", function () { 
                    d3.select(this).remove(); // &lt;-G 
                }); 
        } 
}); 
</pre><div><div><h3 class="title"><a id="note80"/>Note</h3><p>Once again, we retrieved the current mouse position using the <code class="literal">d3.mouse</code> function and then generated five concentric expanding circles to simulate the ripple effect. The ripple effect was simulated using geometrically increasing delay (refer to line F) with decreasing <code class="literal">stroke-width</code> (refer to line E). Finally, when the transition effect is over, the circles were removed using a transition <code class="literal">end</code> listener (refer to line G). If you are not familiar with this type of transition control, refer to <a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em>, for more details.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec209"/>There's more...</h2></div></div></div><p>Although we have only demonstrated how to listen on the <code class="literal">click</code> and <code class="literal">mousemove</code> events in this recipe, you can listen on any event that your browser supports through the <code class="literal">on</code> function. The following is a list of mouse events that are useful to know when building your interactive visualization:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">click</code>: Dispatched when a user clicks on a mouse button</li><li class="listitem" style="list-style-type: disc"><code class="literal">dbclick</code>: Dispatched when a mouse button is clicked twice</li><li class="listitem" style="list-style-type: disc"><code class="literal">mousedown</code>: Dispatched when the mouse button is pressed</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseenter</code>: Dispatched when the mouse button is moved onto the limits of an element or one of its descendent elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseleave</code>: Dispatched when the mouse button is moved off the limits of an element and all of its descendent elements</li><li class="listitem" style="list-style-type: disc"><code class="literal">mousemove</code>: Dispatched when the mouse button is moved over an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseout</code>: Dispatched when the mouse button is moved off of the boundaries of an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseover</code>: Dispatched when the mouse button is moved onto the limits of an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">mouseup</code>: Dispatched when a mouse button is released over an element</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec210"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to <a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em>, for more details on the ripple effect technique used in this recipe.</li><li class="listitem" style="list-style-type: disc">Refer to W3C DOM Level 3 Events specification for a complete list of event types at <a class="ulink" href="https://www.w3.org/TR/DOM-Level-3-Events/">https://www.w3.org/TR/DOM-Level-3-Events/
</a>.</li><li class="listitem" style="list-style-type: disc">Refer to the <code class="literal">d3.mouse</code> API document for more details on mouse detection at <a class="ulink" href="https://github.com/d3/d3-selection/blob/master/README.md#mouse">https://github.com/d3/d3-selection/blob/master/README.md#mouse
</a>.</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Interacting with a multi-touch device</h1></div></div></div><p>Today, with the proliferation of multi-touch devices, any visualization that targets mass consumption needs to worry about its interact-ability not only through the traditional pointing device but also through multi-touches and gestures. In this recipe, we will explore touch support offered by D3 to see how it can be leveraged to generate some pretty interesting interaction with multi-touch-capable devices.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec211"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter10/touch.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter10/touch.html
</a>.
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec212"/>How to do it...</h2></div></div></div><p>In this recipe, we will generate a progress-circle around the user's touches, and once the progress is completed, a subsequent ripple effect will be triggered around the circle. However, if the user prematurely ends their touch, we shall stop the progress-circle without generating the ripples:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var initR = 100,  
        r = 400,  
        thickness = 20; 
 
    var svg = d3.select("body") 
            .append("svg"); 
 
    d3.select("body") // &lt;-A 
            .on("touchstart", touch) 
            .on("touchend", touch); 
 
    function touch() { 
        d3.event.preventDefault(); // &lt;-B 
 
        var arc = d3.arc() 
                .outerRadius(initR) 
                .innerRadius(initR - thickness); 
 
        var g = svg.selectAll("g.touch") // &lt;-C 
                .data(d3.touches(svg.node()), function (d, i) { 
                    return i; 
                }); 
 
        g.enter() 
            .append("g") 
            .attr("class", "touch") 
            .attr("transform", function (d) { 
                return "translate(" + d[0] + "," + d[1] + ")"; 
            }) 
            .append("path") 
                .attr("class", "arc") 
                .transition().duration(2000).ease(d3.easeLinear) 
                .attrTween("d", function (d) { // &lt;-D 
                    var interpolate = d3.interpolate( 
                            {startAngle: 0, endAngle: 0}, 
                            {startAngle: 0, endAngle: 2 * Math.PI} 
                        ); 
                    return function (t) { 
                        return arc(interpolate(t)); 
                    }; 
                }) 
                .on("end", function (d) { 
                    if (complete(d)) // &lt;-E 
                        ripples(d); 
                    g.remove(); 
                }); 
 
        g.exit().remove().each(function (d) { 
            console.log("Animation stopped"); 
            d[2] = "stopped"; // &lt;-F 
        }); 
    } 
 
    function complete(d) { 
        console.log("Animation completed? " + (d.length &lt; 3)); 
        return d.length &lt; 3; 
    } 
 
    function ripples(position) { 
        console.log("Producing ripple effect..."); 
 
        for (var i = 1; i &lt; 5; ++i) { 
            var circle = svg.append("circle") 
                    .attr("cx", position[0]) 
                    .attr("cy", position[1]) 
                    .attr("r", initR - (thickness / 2)) 
                    .style("stroke-width", thickness / (i)) 
                .transition() 
                    .delay(Math.pow(i, 2.5) * 50) 
                    .duration(2000).ease(d3.easeQuadIn) 
                    .attr("r", r) 
                    .style("stroke-opacity", 0) 
                    .on("end", function () { 
                        d3.select(this).remove(); 
                    }); 
        } 
    } 
&lt;/script&gt; 
</pre><p>This recipe generates the following interactive visualization on a touch-enabled device:</p><p>
</p><div><img src="img/image_10_002.jpg" alt="How to do it..."/></div><p>
</p><p>Touch Interaction</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec213"/>How it works...</h2></div></div></div><p>Event listener for touch events are registered through D3 selection's <code class="literal">on</code> function similar to what we have done with mouse events in the previous recipe (refer to line A):</p><pre class="programlisting">d3.select("body") // &lt;-A 
            .on("touchstart", touch) 
            .on("touchend", touch); 
</pre><p>One crucial difference here is that we have registered our touch event listener on the <code class="literal">body</code> element instead of the <code class="literal">svg</code> element since there are default touch behaviors defined with many OS and browsers and we would like to override it with our custom implementation. This is done through the following function call (refer to line B):</p><pre class="programlisting">d3.event.preventDefault(); // &lt;-B 
</pre><p>Once the touch event is triggered, we will retrieve multiple touch point data using the <code class="literal">d3.touches</code> function, as illustrated by the following code snippet:</p><pre class="programlisting">var g = svg.selectAll("g.touch") // &lt;-C 
                .data(d3.touches(svg.node()), function (d, i) { 
                    return i; 
                });  
</pre><p>Instead of returning a two-element array as the <code class="literal">d3.mouse</code> function does, <code class="literal">d3.touches</code> returns an array of two-element arrays since there could be multiple touch points for each touch event. Each touch position array has data structure that looks like the following:</p><p>
</p><div><img src="img/image_10_003.jpg" alt="How it works..."/></div><p>
</p><p>Touch position array</p><p>Here, we also used array index in this recipe to establish object constancy. Once the touch data is bound to the selection, the progress circle was generated for each touch around the user's touch point:</p><pre class="programlisting">        g.enter() 
            .append("g") 
            .attr("class", "touch") 
            .attr("transform", function (d) { 
                return "translate(" + d[0] + "," + d[1] + ")"; 
            }) 
            .append("path") 
                .attr("class", "arc") 
                .transition().duration(2000).ease(d3.easeLinear) 
                .attrTween("d", function (d) { // &lt;-D 
                    var interpolate = d3.interpolate( 
                            {startAngle: 0, endAngle: 0}, 
                            {startAngle: 0, endAngle: 2 * Math.PI} 
                        ); 
                    return function (t) { 
                        return arc(interpolate(t)); 
                    }; 
                }) 
                .on("end", function (d) { 
                    if (complete(d))  
                        ripples(d); // &lt;-E 
                    g.remove(); 
                }); 
</pre><div><div><h3 class="title"><a id="note81"/>Note</h3><p>This is done through a standard arc transition with arc attribute tweening (refer to line D) as explained in <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>. If the progress-circle has not yet been canceled by the user even though the transition is over, then a ripple effect similar to what we have done in the previous recipe is generated on line E. Since we have registered the same event listener <code class="literal">touch</code> function on both the <code class="literal">touchstart</code> and <code class="literal">touchend</code> events, we can use the following lines to remove progress-circle and also set a flag to indicate that this progress circle has stopped prematurely:</p></div></div><pre class="programlisting">        g.exit().remove().each(function (d) { 
            console.log("Animation stopped"); 
            d[2] = "stopped"; // &lt;-F 
        }); 
     ... 
     function complete(d) { 
        console.log("Animation completed? " + (d.length &lt; 3)); 
        return d.length &lt; 3; 
    } 
</pre><p>We need to set this stateful flag on <code class="literal">d</code>, which is the touch data array, since there is no way to cancel a transition once it starts; hence, even after you remove the progress-circle element from the DOM tree, the transition will still complete and trigger line E.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec214"/>There's more...</h2></div></div></div><p>We have demonstrated touch interaction through the <code class="literal">touchstart</code> and <code class="literal">touchend</code> events; however, you can use the same pattern to handle any other touch events supported by your browser. The following list contains the proposed touch event types recommended by W3C:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">touchstart</code>: It is dispatched when the user places a touch point on the touch surface.</li><li class="listitem" style="list-style-type: disc"><code class="literal">touchend</code>: It is dispatched when the user removes a touch point from the touch surface.</li><li class="listitem" style="list-style-type: disc"><code class="literal">touchmove</code>: It is dispatched when the user moves a touch point along the touch surface.</li><li class="listitem" style="list-style-type: disc"><code class="literal">touchcancel</code>: It is dispatched when a touch point is disrupted in an implementation-specific manner.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec215"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to <a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em>, for more details on object constancy and the ripple effect technique used in this recipe.</li><li class="listitem" style="list-style-type: disc">Refer to <a class="link" href="ch07.html" title="Chapter 7. Getting into Shape">Chapter 7</a>, <em>Getting into Shape</em>, for more details on the progress-circle attribute tween transition technique used in this recipe</li><li class="listitem" style="list-style-type: disc">Refer to the W3C Touch Events proposed recommendation for a complete list of touch event types at <a class="ulink" href="https://www.w3.org/TR/touch-events/">https://www.w3.org/TR/touch-events
</a></li><li class="listitem" style="list-style-type: disc">Refer to the <code class="literal">d3.touch</code> API document for more details on multi-touch detection at <a class="ulink" href="https://github.com/d3/d3-selection/blob/master/README.md#touches">https://github.com/d3/d3-selection/blob/master/README.md#touches
</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Implementing zoom and pan behavior</h1></div></div></div><p>Zooming and panning are common and useful techniques in data visualization, which work particularly well with SVG-based visualization, since vector graphic does not suffer from pixilation as its bitmap counterpart would. Zooming is especially useful when you are dealing with large dataset when it is impractical or impossible to visualize the entire dataset, thus a zoom and drill-down approach needs to be employed. In this recipe, we will explore D3's built-in support for both zooming and panning.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec216"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter10/zoom.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter10/zoom.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec217"/>How to do it...</h2></div></div></div><p>In this recipe, we will implement geometric zooming and panning using D3 zoom support. Let's see how this is done in the following code:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 600, height = 350, r = 50; 
 
    var data = [ 
        [width / 2 - r, height / 2 - r], 
        [width / 2 - r, height / 2 + r], 
        [width / 2 + r, height / 2 - r], 
        [width / 2 + r, height / 2 + r] 
    ]; 
 
    var svg = d3.select("body").append("svg") 
            .attr("style", "1px solid black") 
            .attr("width", width) 
            .attr("height", height) 
            .call( // &lt;-A 
                    d3.zoom() // &lt;-B 
                    .scaleExtent([1, 10]) // &lt;-C 
                    .on("zoom", zoomHandler) // &lt;-D 
            ) 
            .append("g"); 
 
    svg.selectAll("circle") 
            .data(data) 
            .enter().append("circle") 
            .attr("r", r) 
            .attr("transform", function (d) { 
                return "translate(" + d + ")"; 
            }); 
 
    function zoomHandler() { 
        var transform = d3.event.transform; 
 
        svg.attr("transform", "translate(" 
            + transform.x + "," + transform.y 
            + ")scale(" + transform.k + ")"); 
    } 
&lt;/script&gt; 
</pre><p>This recipe generates the following zooming and panning effect:</p><p>
</p><div><img src="img/image_10_004.jpg" alt="How to do it..."/></div><p>
</p><p>Original</p><p>The previous image show the original state of the visualization while the following one shows what happen when user zooms in either through scrolling the mouse wheel on a desktop or using multi-gesture on touch screen devices.</p><p>
</p><div><img src="img/image_10_005.jpg" alt="How to do it..."/></div><p>
</p><p>Zoom</p><p>The following screenshot shows what happen when user drags (pan) the image either with their mouse or finger.</p><p>
</p><div><img src="img/image_10_006.jpg" alt="How to do it..."/></div><p>
</p><p>Pan</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec218"/>How it works...</h2></div></div></div><p>At this point, you might be surprised to see how little code is necessary to implement this fully functional zoom and pan effect with D3. If you have this recipe open in your browser, you will also notice zooming and panning reacts perfectly well to both mouse wheel and multi-touch gesture. Most of the heavy lifting is done by D3 library. What we have to do here is simply define what a zoom behavior is. Let's see how this is done in the code; firstly, we need to define zoom behavior on a SVG container:</p><pre class="programlisting">var svg = d3.select("body").append("svg") 
            .attr("style", "1px solid black") 
            .attr("width", width) 
            .attr("height", height) 
            .call( // &lt;-A 
                d3.behavior.zoom() // &lt;-B 
                    .scaleExtent([1, 10]) // &lt;-C 
                    .on("zoom", zoomHandler) // &lt;-D 
            ) 
            .append("g"); 
</pre><p>As we can see on line A, a <code class="literal">d3.zoom</code> function was created (refer to line B) and invoked on the <code class="literal">svg</code> container. The <code class="literal">d3.zoom</code> will automatically create event listeners to handle the low-level zooming and panning gesture on the associated SVG container (in our case, the <code class="literal">svg</code> element itself). The low-level zoom gesture will then be translated to a high-level D3 zoom event. The default event listeners support both mouse and touch events. On line C, we define <code class="literal">scaleExtent</code> with a two-element array [1, 10] (a range). The scale extent defines how much zoom should be allowed (in our case, we allow 10X zoom). Finally, on line D, we register a custom zoom event handler to handle D3 zoom events. Now, let's take a look at what task this zoom event handler performs:</p><pre class="programlisting">function zoomHandler() { 
    var transform = d3.event.transform; 
 
    svg.attr("transform", "translate(" 
        + transform.x + "," + transform.y 
        + ")scale(" + transform.k + ")"); 
} 
</pre><p>In the <code class="literal">zoom</code> function, we simply delegate the actual zooming and panning to SVG transformation. To further simplify this task, the D3 zoom event has also calculated the necessary translate and scale. So, all we need to do is embed them into a SVG transform attribute. Here are the properties contained in a zoom event:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">transform.x</code> and <code class="literal">transform.y</code>: Current translation vector</li><li class="listitem" style="list-style-type: disc"><code class="literal">transform.k</code>: A number representing the current scale</li></ul></div><p>At this point, you might be asking what the point of having this <code class="literal">zoomHandler</code> function is. Why can't D3 take care of this step for us? The reason is that D3 zoom behavior is not designed specifically for SVG, but rather designed as a general zoom behavior support mechanism. Therefore, this zoom function implements the translation of general zoom and pan events into SVG-specific transformation.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec219"/>There's more...</h2></div></div></div><p>The zoom function is also capable of performing additional tasks other than the simple coordinate system transformation. For example, a common technique is to load additional data when the user issues a zoom gesture, hence implementing the drill-down capability in zoom function. A well-known example is a digital map; as you increase zoom level on a map, more data and details then can be loaded and illustrated.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec220"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to <a class="link" href="ch02.html" title="Chapter 2. Be Selective">Chapter 2</a>, <em>Be Selective</em>, for more details on <code class="literal">d3.selection.call</code> function and selection manipulation</li><li class="listitem" style="list-style-type: disc">Refer to W3C SVG coordinate system transformations specification for more information on how zoom and pan effect was achieved in SVG at <a class="ulink" href="https://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace">https://www.w3.org/TR/SVG/coords.html#EstablishingANewUserSpace
</a></li><li class="listitem" style="list-style-type: disc">Refer to the <code class="literal">d3.zoom</code> API document for more details on D3 zoom support at <a class="ulink" href="https://github.com/d3/d3-zoom/blob/master/README.md#zoom">https://github.com/d3/d3-zoom/blob/master/README.md#zoom</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Implementing drag behavior</h1></div></div></div><p>Another common behavior in interactive visualization that we will cover in this chapter is <strong>dragging</strong>. Drag is useful to provide capabilities in visualization that allow graphical rearrangement or even user input through force; we will discuss this in the next chapter. In this recipe, we will explore how the drag behavior is supported in D3.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec221"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter10/drag.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter10/drag.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec222"/>How to do it...</h2></div></div></div><p>Here, we will produce four circles that can be dragged using D3 drag behavior support and additionally with SVG boundary detection while being dragging. Now, let's see how to implement this in code:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 960, height = 500, r = 50; 
 
    var data = [ 
        [width / 2 - r, height / 2 - r], 
        [width / 2 - r, height / 2 + r], 
        [width / 2 + r, height / 2 - r], 
        [width / 2 + r, height / 2 + r] 
    ]; 
 
    var svg = d3.select("body").append("svg") 
            .attr("width", width) 
            .attr("height", height) 
            .append("g"); 
 
    var drag = d3.drag() // &lt;-A 
            .on("drag", move); 
 
    svg.selectAll("circle") 
            .data(data) 
            .enter().append("circle") 
            .attr("r", r) 
            .attr("transform", function (d) { 
                return "translate(" + d + ")"; 
            }) 
            .call(drag); // &lt;-A 
 
    function move(d) { 
        var x = d3.event.x, // &lt;-C 
            y = d3.event.y; 
 
        if(inBoundaries(x, y)) 
            d3.select(this)  
                .attr("transform", function (d) { // &lt;-D 
                    return "translate(" + x + ", " + y + ")"; 
                }); 
    } 
     
    function inBoundaries(x, y){ 
        return (x &gt;= (0 + r) &amp;&amp; x &lt;= (width - r))  
            &amp;&amp; (y &gt;= (0 + r) &amp;&amp; y &lt;= (height - r)); 
    } 
&lt;/script&gt; 
</pre><p>This recipe generates the drag behavior on the following four circles:</p><p>
</p><div><img src="img/image_10_007.jpg" alt="How to do it..."/></div><p>
</p><p>Original</p><p>The preceding image shows what this recipe renders in its original state while the following image show what happens when user drags each circle away from the center.</p><p>
</p><div><img src="img/image_10_008.jpg" alt="How to do it..."/></div><p>
</p><p>Dragged</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec223"/>How it works...</h2></div></div></div><p>As we can see, drag support follows a pattern similar to the D3 zoom support. The main drag capability is provided by the <code class="literal">d3.drag</code> function (refer to line A). D3 drag behavior automatically creates appropriate low-level event listeners to handle drag gestures on the given element and then translates low-level events to high-level D3 drag events. Both mouse and touch events are supported, as follows:</p><pre class="programlisting">var drag = d3.behavior.drag() // &lt;-A 
            .on("drag", move); 
</pre><p>In this recipe, we are interested in the <code class="literal">drag</code> event, and it is handled by our <code class="literal">move</code> function. Similar to the zoom behavior, the D3 drag behavior support is event driven, therefore, it allows maximum flexibility in implementation, supporting not only SVG but also the HTML canvas. Once defined, the behavior can be attached to any element by calling it on a given selection:</p><pre class="programlisting">svg.selectAll("circle") 
            .data(data) 
            .enter().append("circle") 
            .attr("r", r) 
            .attr("transform", function (d) { 
                return "translate(" + d + ")"; 
            }) 
            .call(drag); // &lt;-B 
</pre><p>Next, in the <code class="literal">move</code> function, we simply use SVG transformation to move the dragged element to a proper location (refer to line D) based on the information conveyed by the drag event (refer to line C):</p><pre class="programlisting">   function move(d) { 
        var x = d3.event.x, // &lt;-C 
            y = d3.event.y; 
 
        if(inBoundaries(x, y)) 
            d3.select(this)  
                .attr("transform", function (d) { // &lt;-D 
                    return "translate(" + x + ", " + y + ")"; 
                }); 
} 
</pre><p>One additional condition we check here is to calculate the SVG boundaries constraint so the user cannot drag an element outside of the SVG. This is achieved by the following check:</p><pre class="programlisting">    function inBoundaries(x, y){ 
        return (x &gt;= (0 + r) &amp;&amp; x &lt;= (width - r))  
            &amp;&amp; (y &gt;= (0 + r) &amp;&amp; y &lt;= (height - r)); 
    } 
</pre></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec224"/>There's more...</h2></div></div></div><p>Other than the drag event, the D3 drag behavior also supports two other event types. The following list shows all supported drag event types and their attributes:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">dragstart</code>: It is triggered when a drag gesture starts.</li><li class="listitem" style="list-style-type: disc"><code class="literal">drag</code>: It is fired when the element is dragged. The <code class="literal">d3.event</code> object will contain <em>x</em> and <em>y</em> properties that represent the current absolute drag coordinates of the element. It will also contain the <em>dx</em> and <em>dy</em> properties representing the element's coordinates relative to its position at the beginning of the gesture.</li><li class="listitem" style="list-style-type: disc"><code class="literal">dragend</code>: It is triggered when a drag gesture has finished.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec225"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Refer to <a class="link" href="ch02.html" title="Chapter 2. Be Selective">Chapter 2</a>, <em>Be Selective</em>, for more details on <code class="literal">d3.selection.call</code> function and selection manipulation.</li><li class="listitem" style="list-style-type: disc">Refer to the <code class="literal">d3.behavior.drag</code> API document for more details on D3 drag support at <a class="ulink" href="https://github.com/d3/d3-drag/blob/master/README.md#drag">https://github.com/d3/d3-drag/blob/master/README.md#drag
</a>.</li></ul></div></div></div></div></div></body></html>