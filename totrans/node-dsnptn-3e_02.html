<html><head></head><body>
  <div id="_idContainer038">
    <h1 class="chapterNumber">2</h1>
    <h1 id="_idParaDest-34" class="chapterTitle">The Module System</h1>
    <p class="normal">In <em class="chapterRef">Chapter 1</em>, <em class="italic">The Node.js Platform</em>, we briefly introduced the importance of modules in Node.js. We discussed how modules play a fundamental role in defining some of the pillars of the Node.js philosophy and its programming experience. But what do we actually mean when we talk about modules and why are they so important?</p>
    <p class="normal">In generic terms, modules are the bricks for structuring non-trivial applications. Modules allow you to divide the codebase into small units that can be developed and tested independently. Modules are also the main mechanism to enforce information hiding by keeping private all the functions and variables that are not explicitly marked to be exported.</p>
    <p class="normal">If you come from other languages, you have probably seen similar concepts being referred to with different names: <strong class="keyword">package</strong> (Java, Go, PHP, Rust, or Dart), <strong class="keyword">assembly</strong> (.NET), <strong class="keyword">library</strong> (Ruby), or <strong class="keyword">unit</strong> (Pascal dialects). The terminology is not perfectly interchangeable because every language or ecosystem comes with its own unique characteristics, but there is a significant overlap between these concepts.</p>
    <p class="normal">Interestingly enough, Node.js currently comes with two different module systems: <strong class="keyword">CommonJS</strong> (<strong class="keyword">CJS</strong>) and <strong class="keyword">ECMAScript modules</strong> (<strong class="keyword">ESM</strong> or <strong class="keyword">ES modules</strong>). In this chapter, we will discuss why there are two alternatives, we will learn about their pros and cons, and, finally, we will analyze several common patterns that are relevant when using or writing Node.js modules. By the end of this chapter, you should be able to make pragmatic choices about how to use modules effectively and how to write your own custom modules.</p>
    <p class="normal">Getting a good grasp of Node.js' module systems and module patterns is very important as we will rely on this knowledge in all the other chapters of this book.</p>
    <p class="normal">In short, these are the main topics we will be discussing throughout this chapter:</p>
    <ul>
      <li class="Bullet--PACKT-">Why modules are necessary and the different module systems available in Node.js</li>
      <li class="Bullet--PACKT-">CommonJS internals and module patterns</li>
      <li class="Bullet--PACKT-">ES modules (ESM) in Node.js</li>
      <li class="Bullet-End--PACKT-">Differences and interoperability between CommonJS and ESM</li>
    </ul>
    <p class="normal">Let's begin with why we need modules.</p>
    <h1 id="_idParaDest-35" class="title">The need for modules</h1>
    <p class="normal">A good module system should help with addressing some fundamental needs of software engineering:</p>
    <ul>
      <li class="Bullet--PACKT-"><em class="italic">Having a way to split the codebase into multiple files</em>. This helps with keeping the code <a id="_idIndexMarker045"/>more organized, making it easier to understand but also helps with developing and testing various pieces of functionality independently from each other.</li>
      <li class="Bullet--PACKT-"><em class="italic">Allowing code reuse across different projects</em>. A module can, in fact, implement a generic feature that can be useful for different projects. Organizing such functionality within a module can make it easier to bring it into the different projects that may want to use it.</li>
      <li class="Bullet--PACKT-"><em class="italic">Encapsulation</em> (or <em class="italic">information hiding</em>). It is generally a good idea to hide implementation <a id="_idIndexMarker046"/>complexity and only expose simple interfaces with clear responsibilities. Most module systems allow to selectively keep the <em class="italic">private</em> part of the code hidden, while exposing a <em class="italic">public</em> interface, such as functions, classes, or objects that are meant to be used by the consumers of the module.</li>
      <li class="Bullet-End--PACKT-"><em class="italic">Managing dependencies</em>. A good module system should make it easy for module developers to build on top of existing modules, including third-party ones. A module system should also make it easy for module users to import the chain of dependencies that are necessary for a given module to run (transient dependencies).</li>
    </ul>
    <p class="normal">It is important to clarify the distinction between <em class="italic">a module</em> and <em class="italic">a module system</em>. We can define a module as the actual unit of software, while a module system is the syntax and the tooling that allows us to define modules and to use them within our projects.</p>
    <h1 id="_idParaDest-36" class="title">Module systems in JavaScript and Node.js</h1>
    <p class="normal">Not all <a id="_idIndexMarker047"/>programming languages come with a built-in module system, and JavaScript had been lacking this <a id="_idIndexMarker048"/>feature for a long time.</p>
    <p class="normal">In the browser landscape, it is possible to split the codebase into multiple files and then import them by using different <code class="Code-In-Text--PACKT-">&lt;script&gt;</code> tags. For many years, this approach was good enough to build simple interactive websites, and JavaScript developers managed to get things done without having a fully-fledged module system.</p>
    <p class="normal">Only when JavaScript browser applications became more complicated and frameworks like <em class="italic">jQuery</em>, <em class="italic">Backbone</em>, and <em class="italic">AngularJS</em> took over the ecosystem, the JavaScript community came up with several initiatives aimed at defining a module system that could be effectively adopted within JavaScript projects. The <a id="_idIndexMarker049"/>most successful <a id="_idIndexMarker050"/>ones were <strong class="keyword">asynchronous module definition</strong> (<strong class="keyword">AMD</strong>), popularized by RequireJS (<a href="http://nodejsdp.link/requirejs"><span class="url">nodejsdp.link/requirejs</span></a>), and <a id="_idIndexMarker051"/>later <strong class="keyword">Universal Module Definition</strong> (<strong class="keyword">UMD</strong> – <a href="http://nodejsdp.link/umd"><span class="url">nodejsdp.link/umd</span></a>).</p>
    <p class="normal">When Node.js was created, it was conceived as a server runtime for JavaScript with direct access to the underlying filesystem so there was a unique opportunity to introduce a different way to manage modules. The idea was not to rely on HTML <code class="Code-In-Text--PACKT-">&lt;script&gt;</code> tags and resources accessible through URLs. Instead, the choice was to rely purely on JavaScript files available on the local filesystem. For its module system, Node.js came up with an <a id="_idIndexMarker052"/>implementation of the <em class="italic">CommonJS</em> specification (sometimes also referred to as <em class="italic">CJS</em>, <a href="http://nodejsdp.link/commonjs"><span class="url">nodejsdp.link/commonjs</span></a>), which was designed to provide a module system for JavaScript in browserless environments.</p>
    <p class="normal">CommonJS has been the dominant module system in Node.js since its inception and it has become very prominent also in the <a id="_idIndexMarker053"/>browser landscape thanks <a id="_idIndexMarker054"/>to <em class="italic">module bundlers</em> like Browserify (<a href="http://nodejsdp.link/browserify"><span class="url">nodejsdp.link/browserify</span></a>) and webpack (<a href="http://nodejsdp.link/webpack"><span class="url">nodejsdp.link/webpack</span></a>).</p>
    <p class="normal">In 2015, with the release of <em class="italic">ECMAScript 6</em> (also called <em class="italic">ECMAScript 2015</em> or <em class="italic">ES2015</em>), there was finally an official proposal for a standard module system: <em class="italic">ESM</em> or <em class="italic">ECMAScript modules</em>. ESM brings a lot of innovation in the JavaScript ecosystem and, among other things, it tries to bridge the gap between how modules are managed on browsers and servers.</p>
    <p class="normal">ECMAScript 6 defined only the formal specification for ESM in terms of syntax and semantics, but it didn't provide any implementation details. It took different browser companies and the Node.js community several years to come up with solid implementations of the specification. Node.js ships with stable support for ESM starting from version 13.2.</p>
    <p class="normal">At the time of writing, the general feeling is that ESM is going to become the de facto way to manage JavaScript modules in both the browser and the server landscape. The reality today, though, is that the majority of projects are still heavily relying on CommonJS and it will take some time for ESM to catch up and eventually become the dominant standard.</p>
    <p class="normal">To provide a comprehensive overview of module-related patterns in Node.js, in the first part of this chapter, we will discuss them in the context of CommonJS, and then, in the second part of the chapter, we will revisit our learnings using ESM.</p>
    <p class="normal">The goal of this chapter is to make you comfortable with both module systems, but in the rest of the book, we will only be using ESM for our code examples. The idea is to encourage you to leverage ESM as much as possible so that your code will be more future-proof.</p>
    <p class="normal">If you are reading this chapter a few <a id="_idIndexMarker055"/>years after its publication, you are probably not too worried <a id="_idIndexMarker056"/>about CommonJS, and you might want to jump straight into the ESM part. This is probably fine, but we still encourage you to go through the entire chapter, because understanding CommonJS and its characteristics will certainly be beneficial in helping you to understand ESM and its strengths in much more depth.</p>
    <h1 id="_idParaDest-37" class="title">The module system and its patterns</h1>
    <p class="normal">As we said, modules are the bricks for structuring non-trivial applications and the main mechanism to <a id="_idIndexMarker057"/>enforce information hiding by keeping private all the functions and variables that are not explicitly marked to be exported.</p>
    <p class="normal">Before getting into the specifics of CommonJS, let's discuss a generic pattern that helps with information hiding and that we will be using for building a simple module system, which is the <strong class="keyword">revealing module pattern</strong>.</p>
    <h2 id="_idParaDest-38" class="title">The revealing module pattern</h2>
    <p class="normal">One of the bigger problems with JavaScript in the browser is the lack of namespacing. Every script runs in the global scope; therefore, internal application code or third-party dependencies can <a id="_idIndexMarker058"/>pollute the scope while exposing their own pieces of functionality. This can be extremely harmful. Imagine, for instance, that a third-party library instantiates a global variable called <code class="Code-In-Text--PACKT-">utils</code>. If any other library, or the application code itself, accidentally overrides or alters <code class="Code-In-Text--PACKT-">utils</code>, the code that relies on it will likely crash in some unpredictable way. Unpredictable side effects can also happen if other libraries or the application code accidentally invoke a function of another library meant for internal use only.</p>
    <p class="normal">In short, relying on the global scope is a very risky business, especially as your application grows and you have to rely more and more on functionality implemented by other individuals.</p>
    <p class="normal">A popular technique to solve this class of problems is called the <em class="italic">revealing module pattern</em>, and it looks <a id="_idIndexMarker059"/>like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> myModule = (<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-keyword">const</span> privateFoo = <span class="hljs-function">() =&gt;</span> {}
  <span class="hljs-keyword">const</span> privateBar = []
  <span class="hljs-keyword">const</span> exported = {
    <span class="hljs-attr">publicFoo</span>: <span class="hljs-function">() =&gt;</span> {},
    <span class="hljs-attr">publicBar</span>: <span class="hljs-function">() =&gt;</span> {}
  }
  <span class="hljs-keyword">return</span> exported
})<strong class="hljs-slc">()</strong> <span class="hljs-comment">// once the parenthesis here are parsed, the function</span>
     <span class="hljs-comment">// will be invoked</span>
<span class="hljs-built_in">console</span>.log(myModule)
<span class="hljs-built_in">console</span>.log(myModule.privateFoo, myModule.privateBar)
</code></pre>
    <p class="normal">This pattern leverages a self-invoking function. This type of function is sometimes also referred to as <strong class="keyword">Immediately Invoked Function Expression</strong> (<strong class="keyword">IIFE</strong>) and it is <a id="_idIndexMarker060"/>used to create a private scope, exporting only the parts that are meant to be public.</p>
    <p class="normal">In JavaScript, variables created inside a function are not accessible from the outer scope (outside the function). Functions can use the <code class="Code-In-Text--PACKT-">return</code> statement to selectively propagate information to the outer scope.</p>
    <p class="normal">This pattern is essentially exploiting these properties to keep the private information hidden and export only a public-facing API.</p>
    <p class="normal">In the preceding code, the <code class="Code-In-Text--PACKT-">myModule</code> variable contains only the exported API, while the rest of the module content is practically inaccessible from outside.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">log</code> statement is going to print something like this:</p>
    <pre class="programlisting con"><code class="hljs-con">{ publicFoo: [Function: publicFoo],
  publicBar: [Function: publicBar] }
undefined undefined
</code></pre>
    <p class="normal">This demonstrates that only the <code class="Code-In-Text--PACKT-">exported</code> properties are directly accessible from <code class="Code-In-Text--PACKT-">myModule</code>.</p>
    <p class="normal">As we will see in a <a id="_idIndexMarker061"/>moment, the idea behind this pattern is used as a base for the CommonJS module system.</p>
    <h1 id="_idParaDest-39" class="title">CommonJS modules</h1>
    <p class="normal">CommonJS is the first module system originally built into Node.js. Node.js' CommonJS implementation <a id="_idIndexMarker062"/>respects the CommonJS specification, with the addition of some custom extensions.</p>
    <p class="normal">Let's summarize two of the main concepts of the CommonJS specification:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">require</code> is a function that <a id="_idIndexMarker063"/>allows you to import a module from the local filesystem</li>
      <li class="Bullet-End--PACKT-"><code class="Code-In-Text--PACKT-">exports</code> and <code class="Code-In-Text--PACKT-">module.exports</code> are special <a id="_idIndexMarker064"/>variables that can be used to export public functionality from the current module</li>
    </ul>
    <p class="normal">This information is sufficient for now; we will learn more details and some of the nuances of the CommonJS specification in the next few sections.</p>
    <h2 id="_idParaDest-40" class="title">A homemade module loader</h2>
    <p class="normal">To understand how CommonJS works in Node.js, let's build a similar system from scratch. The code that <a id="_idIndexMarker065"/>follows creates a <a id="_idIndexMarker066"/>function that mimics a subset of the functionality of the original <code class="Code-In-Text--PACKT-">require()</code> function of Node.js.</p>
    <p class="normal">Let's start by creating a function that loads the content of a module, wraps it into a private scope, and evaluates it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">loadModule</span><span class="hljs-function"> (</span><span class="hljs-params">filename, module, require</span><span class="hljs-function">) </span>{
  <span class="hljs-keyword">const</span> wrappedSrc =
    <span class="hljs-string">`(function (module, exports, require) {</span>
<span class="hljs-string">      </span><span class="hljs-subst">${</span>fs.readFileSync(filename, <span class="hljs-string">'utf8'</span>)<span class="hljs-subst">}</span>
<span class="hljs-string">    })(module, module.exports, require)`</span>
  <span class="hljs-built_in">eval</span>(wrappedSrc)
}
</code></pre>
    <p class="normal">The source code of a module is essentially wrapped into a function, as it was for the revealing module pattern. The difference here is that we pass a list of variables to the module, in particular, <code class="Code-In-Text--PACKT-">module</code>, <code class="Code-In-Text--PACKT-">exports</code>, and <code class="Code-In-Text--PACKT-">require</code>. Make a note of how the <code class="Code-In-Text--PACKT-">exports</code> argument of the wrapping function is initialized with the content of <code class="Code-In-Text--PACKT-">module.exports</code>, as we will talk about this later.</p>
    <p class="normal">Another important detail to mention is that we are using <code class="Code-In-Text--PACKT-">readFileSync</code> to read the module's content. While it is generally not recommended to use the synchronous version of the filesystem APIs, here it makes sense to do so. The reason for that is that loading <a id="_idIndexMarker067"/>modules in CommonJS are deliberately <a id="_idIndexMarker068"/>synchronous operations. This approach makes sure that, if we are importing multiple modules, they (and their dependencies) are loaded in the right order. We will talk more about this aspect later in the chapter.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Bear in mind that this is only an example, and you will rarely need to evaluate some source code in a real application. Features such as <code class="Code-In-Text--PACKT-">eval()</code> or the functions of the <code class="Code-In-Text--PACKT-">vm</code> module (<a href="http://nodejsdp.link/vm"><span class="url">nodejsdp.link/vm</span></a>) can be easily used in the wrong way or with the wrong input, thus opening a system to code injection attacks. They should always be used with extreme care or avoided altogether.</p>
    </div>
    <p class="normal">Let's now implement the <code class="Code-In-Text--PACKT-">require()</code> function:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">require</span><span class="hljs-function"> (</span><span class="hljs-params">moduleName</span><span class="hljs-function">) </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Require invoked for module: </span><span class="hljs-subst">${moduleName}</span><span class="hljs-string">`</span>)
  <span class="hljs-keyword">const</span> id = <span class="hljs-built_in">require</span>.resolve(moduleName)                   <span class="hljs-comment">// (1)</span>
  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">require</span>.cache[id]) {                                 <span class="hljs-comment">// (2)</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>.cache[id].exports
  }
  <span class="hljs-comment">// module metadata</span>
  <span class="hljs-keyword">const</span> <span class="hljs-built_in">module</span> = {                                         <span class="hljs-comment">// (3)</span>
    <span class="hljs-built_in">exports</span>: {},
    id
  }
  <span class="hljs-comment">// Update the cache</span>
  <span class="hljs-built_in">require</span>.cache[id] = <span class="hljs-built_in">module</span>                               <span class="hljs-comment">// (4)</span>
  <span class="hljs-comment">// load the module</span>
  loadModule(id, <span class="hljs-built_in">module</span>, <span class="hljs-built_in">require</span>)                          <span class="hljs-comment">// (5)</span>
  <span class="hljs-comment">// return exported variables</span>
  <span class="hljs-keyword">return</span> <span class="hljs-built_in">module</span>.exports                                    <span class="hljs-comment">// (6)</span>
}
<span class="hljs-built_in">require</span>.cache = {}
<span class="hljs-built_in">require</span>.resolve = <span class="hljs-function">(</span><span class="hljs-params">moduleName</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-comment">/* resolve a full module id from the moduleName */</span>
}
</code></pre>
    <p class="normal">The previous function simulates the behavior of the original <code class="Code-In-Text--PACKT-">require()</code> function of Node.js, which is used to load a module. Of course, this is just for educational purposes and does not accurately or completely reflect the internal behavior of the real <code class="Code-In-Text--PACKT-">require()</code> function, but it's great to understand the internals of the Node.js module system, including how a <a id="_idIndexMarker069"/>module is defined and loaded.</p>
    <p class="normal">What our homemade module system does is explained as follows:</p>
    <ol>
      <li class="numbered">A module name is accepted as input, and the very first thing that we do is resolve the full path of the <a id="_idIndexMarker070"/>module, which we call <code class="Code-In-Text--PACKT-">id</code>. This task is delegated to <code class="Code-In-Text--PACKT-">require.resolve()</code>, which implements a specific resolving algorithm (we will talk about it later).</li>
      <li class="numbered">If the module has already been loaded in the past, it should be available in the cache. If this is the case, we just return it immediately.</li>
      <li class="numbered">If the module has never been loaded before, we set up the environment for the first load. In particular, we create a <code class="Code-In-Text--PACKT-">module</code> object that contains an <code class="Code-In-Text--PACKT-">exports</code> property initialized with an empty object literal. This object will be populated by the code of the module to export its public API.</li>
      <li class="numbered">After the first load, the <code class="Code-In-Text--PACKT-">module</code> object is cached.</li>
      <li class="numbered">The module source code is read from its file and the code is evaluated, as we saw before. We provide the module with the <code class="Code-In-Text--PACKT-">module</code> object that we just created, and a reference to the <code class="Code-In-Text--PACKT-">require()</code> function. The module exports its public API by manipulating or replacing the <code class="Code-In-Text--PACKT-">module.exports</code> object.</li>
      <li class="numbered">Finally, the content of <code class="Code-In-Text--PACKT-">module.exports</code>, which represents the public API of the module, is returned to the caller.</li>
    </ol>
    <p class="normal">As we can see, there is nothing magical behind the workings of the Node.js module system. The trick is all in the wrapper we create around a module's source code and the artificial environment in which we run it.</p>
    <h2 id="_idParaDest-41" class="title">Defining a module</h2>
    <p class="normal">By looking at how our custom <code class="Code-In-Text--PACKT-">require()</code> function works, we should now be able to understand how to <a id="_idIndexMarker071"/>define a module. The following code gives us an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// load another dependency</span>
<span class="hljs-keyword">const</span> dependency = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./anotherModule'</span>)
<span class="hljs-comment">// a private function</span>
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">log</span><span class="hljs-function">() </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Well done </span><span class="hljs-subst">${</span>dependency.<span class="hljs-subst">username}</span><span class="hljs-string">`</span>)
}
<span class="hljs-comment">// the API to be exported for public use</span>
<span class="hljs-built_in">module</span>.exports.run = <span class="hljs-function">() =&gt;</span> {
  log()
}
</code></pre>
    <p class="normal">The essential concept to remember is that everything inside a module is private unless it's assigned to the <code class="Code-In-Text--PACKT-">module.exports</code> variable. The content of this variable is then cached and returned when the module is loaded using <code class="Code-In-Text--PACKT-">require()</code>.</p>
    <h2 id="_idParaDest-42" class="title">module.exports versus exports</h2>
    <p class="normal">For many developers who are not yet familiar with Node.js, a common source of confusion is the difference between using <code class="Code-In-Text--PACKT-">exports</code> and <code class="Code-In-Text--PACKT-">module.exports</code> to expose a public API. The <a id="_idIndexMarker072"/>code of our custom <code class="Code-In-Text--PACKT-">require()</code> function should again clear any doubt. The <code class="Code-In-Text--PACKT-">exports</code> variable is just a reference to the initial value of <code class="Code-In-Text--PACKT-">module.exports</code>. We have seen that such a value is essentially a simple object literal created before the module is loaded.</p>
    <p class="normal">This means that we can only attach new properties to the object referenced by the <code class="Code-In-Text--PACKT-">exports</code> variable, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">exports</span>.hello = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
}
</code></pre>
    <p class="normal">Reassigning the <code class="Code-In-Text--PACKT-">exports</code> variable doesn't have any effect, because it doesn't change the content of <code class="Code-In-Text--PACKT-">module.exports</code>. It will only reassign the variable itself. The following code is therefore wrong:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">exports</span> = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
}
</code></pre>
    <p class="normal">If we want to export something other than an object literal, such as a function, an instance, or even <a id="_idIndexMarker073"/>a string, we have to reassign <code class="Code-In-Text--PACKT-">module.exports</code> as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">module</span>.exports = <span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'Hello'</span>)
}
</code></pre>
    <h2 id="_idParaDest-43" class="title">The require function is synchronous</h2>
    <p class="normal">A very important detail that we should take into account is that our homemade <code class="Code-In-Text--PACKT-">require()</code> function <a id="_idIndexMarker074"/>is synchronous. In fact, it returns the module contents using a simple direct style, and no callback is required. This is <a id="_idIndexMarker075"/>true for the original Node.js <code class="Code-In-Text--PACKT-">require()</code> function too. As a consequence, any assignment to <code class="Code-In-Text--PACKT-">module.exports</code> must be synchronous as well. For example, the following code is incorrect and it will cause trouble:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
  <span class="hljs-built_in">module</span>.exports = <span class="hljs-keyword">function</span><span class="hljs-function">() </span>{...}
}, <span class="hljs-number">100</span>)
</code></pre>
    <p class="normal">The synchronous nature of <code class="Code-In-Text--PACKT-">require()</code> has important repercussions on the way we define modules, as it limits us to mostly using synchronous code during the definition of a module. This is one of the most important reasons why the core Node.js libraries offer synchronous APIs as an alternative to most of the asynchronous ones.</p>
    <p class="normal">If we need some asynchronous initialization steps for a module, we can always define and export an uninitialized module that is initialized asynchronously at a later time. The problem with this approach, though, is that loading such a module using <code class="Code-In-Text--PACKT-">require()</code> does not guarantee that it's ready to be used. In <em class="chapterRef">Chapter 11</em>, <em class="italic">Advanced Recipes</em>, we will analyze this problem in detail and present some patterns to solve this issue elegantly.</p>
    <p class="normal">For the sake of curiosity, you might want to know that in its early days, Node.js used to have an asynchronous version of <code class="Code-In-Text--PACKT-">require()</code>, but it was soon removed because it was overcomplicating a functionality that was actually only meant to be used at initialization time and where asynchronous I/O brings more complexities than advantages.</p>
    <h2 id="_idParaDest-44" class="title">The resolving algorithm</h2>
    <p class="normal">The term <em class="italic">dependency hell</em> describes a situation whereby two or more dependencies of a program in turn depend on a shared dependency, but require different incompatible versions. Node.js solves this problem elegantly by loading a different version of a module depending on <a id="_idIndexMarker076"/>where the module is <a id="_idIndexMarker077"/>loaded from. All the merits of this feature go to the way Node.js package managers (such as npm or yarn) organize the dependencies of the application, and also to the resolving algorithm used in the <code class="Code-In-Text--PACKT-">require()</code> function.</p>
    <p class="normal">Let's now give a quick overview of this algorithm. As we saw, the <code class="Code-In-Text--PACKT-">resolve()</code> function takes a module name (which we will call <code class="Code-In-Text--PACKT-">moduleName</code>) as input and it returns the full path of the module. This path is then used to load its code and also to identify the module uniquely. The resolving algorithm can be divided into the following three major branches:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">File modules</strong>: If <code class="Code-In-Text--PACKT-">moduleName</code> starts with <code class="Code-In-Text--PACKT-">/</code>, it is already considered an absolute path to the module <a id="_idIndexMarker078"/>and it's returned as it is. If it starts with <code class="Code-In-Text--PACKT-">./</code>, then <code class="Code-In-Text--PACKT-">moduleName</code> is considered a relative path, which is calculated starting from the directory of the requiring module.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Core modules</strong>: If <code class="Code-In-Text--PACKT-">moduleName</code> is not <a id="_idIndexMarker079"/>prefixed with <code class="Code-In-Text--PACKT-">/</code> or <code class="Code-In-Text--PACKT-">./</code>, the algorithm will first try to search within the core Node.js modules.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Package modules</strong>: If no core module is found matching <code class="Code-In-Text--PACKT-">moduleName</code>, then the search continues by looking for a <a id="_idIndexMarker080"/>matching module in the first <code class="Code-In-Text--PACKT-">node_modules</code> directory that is found navigating up in the directory structure starting from the requiring module. The algorithm continues to search for a match by looking into the next <code class="Code-In-Text--PACKT-">node_modules</code> directory up in the directory tree, until it reaches the root of the filesystem.</li>
    </ul>
    <p class="normal">For file and package modules, both files and directories can match <code class="Code-In-Text--PACKT-">moduleName</code>. In particular, the algorithm will try to match the following:</p>
    <ul>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">&lt;moduleName&gt;.js</code></li>
      <li class="Bullet--PACKT-"><code class="Code-In-Text--PACKT-">&lt;moduleName&gt;/index.js</code></li>
      <li class="Bullet-End--PACKT-">The directory/file specified in the <code class="Code-In-Text--PACKT-">main</code> property of <code class="Code-In-Text--PACKT-">&lt;moduleName&gt;/package.json</code></li>
    </ul>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The complete, formal documentation of the <a id="_idIndexMarker081"/>resolving algorithm can be found at <a href="http://nodejsdp.link/resolve"><span class="url">nodejsdp.link/resolve</span></a>.</p>
    </div>
    <p class="normal">The <code class="Code-In-Text--PACKT-">node_modules</code> directory is actually where the package managers install the dependencies of each package. This means that, based on the algorithm we just described, each package can have its own private dependencies. For example, consider the following directory structure:</p>
    <pre class="programlisting code"><code class="hljs-code">myApp
├── foo.js
└── node_modules
    ├── depA
    │   └── index.js
    ├── depB
    │   ├── bar.js
    │   └── node_modules
    │       └── depA
    │           └── index.js
    └── depC
        ├── foobar.js
        └── node_modules
            └── depA
                └── index.js
</code></pre>
    <p class="normal">In the previous example, <code class="Code-In-Text--PACKT-">myApp</code>, <code class="Code-In-Text--PACKT-">depB</code>, and <code class="Code-In-Text--PACKT-">depC</code> all depend on <code class="Code-In-Text--PACKT-">depA</code>. However, they all have their own <a id="_idIndexMarker082"/>private version of the dependency! Following the rules of the resolving algorithm, using <code class="Code-In-Text--PACKT-">require('depA')</code> will load a different file <a id="_idIndexMarker083"/>depending on the module that requires it, for example:</p>
    <ul>
      <li class="Bullet--PACKT-">Calling <code class="Code-In-Text--PACKT-">require('depA')</code> from <code class="Code-In-Text--PACKT-">/myApp/foo.js</code> will load <code class="Code-In-Text--PACKT-">/myApp/node_modules/depA/index.js</code></li>
      <li class="Bullet--PACKT-">Calling <code class="Code-In-Text--PACKT-">require('depA')</code> from <code class="Code-In-Text--PACKT-">/myApp/node_modules/depB/bar.js</code> will load <code class="Code-In-Text--PACKT-">/myApp/node_modules/depB/node_modules/depA/index.js</code></li>
      <li class="Bullet-End--PACKT-">Calling <code class="Code-In-Text--PACKT-">require('depA')</code> from <code class="Code-In-Text--PACKT-">/myApp/node_modules/depC/foobar.js</code> will load <code class="Code-In-Text--PACKT-">/myApp/node_modules/depC/node_modules/depA/index.js</code></li>
    </ul>
    <p class="normal">The resolving algorithm is the core part behind the robustness of the Node.js dependency management, and it makes it possible to have hundreds or even thousands of packages in an application without having collisions or problems of version compatibility.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">The resolving algorithm is applied transparently for us when we invoke <code class="Code-In-Text--PACKT-">require()</code>. However, if needed, it can still be used directly by any module by simply invoking <code class="Code-In-Text--PACKT-">require.resolve()</code>.</p>
    </div>
    <h2 id="_idParaDest-45" class="title">The module cache</h2>
    <p class="normal">Each module is only loaded and evaluated the first time it is required, since any subsequent call of <code class="Code-In-Text--PACKT-">require()</code> will simply return the cached version. This should be clear by looking at the code of our homemade <code class="Code-In-Text--PACKT-">require()</code> function. Caching is crucial for performance, but it also <a id="_idIndexMarker084"/>has some important functional implications:</p>
    <ul>
      <li class="Bullet--PACKT-">It makes it <a id="_idIndexMarker085"/>possible to have cycles within module dependencies</li>
      <li class="Bullet-End--PACKT-">It guarantees, to some extent, that the same instance is always returned when requiring the same module from within a given package</li>
    </ul>
    <p class="normal">The module cache is exposed via the <code class="Code-In-Text--PACKT-">require.cache</code> variable, so it is possible to directly access it if needed. A common use case is to invalidate any cached module by deleting the relative key in the <code class="Code-In-Text--PACKT-">require.cache</code> variable, a practice that can be useful during testing but very dangerous if applied in normal circumstances.</p>
    <h2 id="_idParaDest-46" class="title">Circular dependencies</h2>
    <p class="normal">Many consider circular dependencies an intrinsic design issue, but it is something that might actually happen <a id="_idIndexMarker086"/>in a real project, so it's <a id="_idIndexMarker087"/>useful for us to know at least how this works with CommonJS. If we look again at our homemade <code class="Code-In-Text--PACKT-">require()</code> function, we immediately get a glimpse of how this might work and what its caveats are.</p>
    <p class="normal">But let's walk together through an example to see how CommonJS behaves when dealing with circular dependencies. Let's suppose we have the scenario represented in <em class="italic">Figure 2.1</em>:</p>
    <figure class="mediaobject"><img src="../Images/B15729_02_01.png" alt="02%20The%20Module%20system%20-%20Images/circular-dependency-example.png"/></figure>
    <p class="packt_figref">Figure 2.1: An example of circular dependency</p>
    <p class="normal">A module called <code class="Code-In-Text--PACKT-">main.js</code> requires <code class="Code-In-Text--PACKT-">a.js</code> and <code class="Code-In-Text--PACKT-">b.js</code>. In turn, <code class="Code-In-Text--PACKT-">a.js</code> requires <code class="Code-In-Text--PACKT-">b.js</code>. But <code class="Code-In-Text--PACKT-">b.js</code> relies on <code class="Code-In-Text--PACKT-">a.js</code> as well! It's obvious that we have a circular dependency here as module <code class="Code-In-Text--PACKT-">a.js</code> requires module <code class="Code-In-Text--PACKT-">b.js</code> and module <code class="Code-In-Text--PACKT-">b.js</code> requires module <code class="Code-In-Text--PACKT-">a.js</code>. Let's have a look at the code of these two modules:</p>
    <ul>
      <li class="Bullet--PACKT-">Module <code class="Code-In-Text--PACKT-">a.js</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">exports</span>.loaded = <span class="hljs-literal">false</span>
<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b'</span>)
<span class="hljs-built_in">module</span>.exports = {
  b,
  <span class="hljs-attr">loaded</span>: <span class="hljs-literal">true</span> <span class="hljs-comment">// overrides the previous export</span>
}
</code></pre>
      </li>
      <li class="Bullet--PACKT-">Module <code class="Code-In-Text--PACKT-">b.js</code>:
        <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">exports</span>.loaded = <span class="hljs-literal">false</span>
<span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a'</span>)
<span class="hljs-built_in">module</span>.exports = {
  a,
  <span class="hljs-attr">loaded</span>: <span class="hljs-literal">true</span>
}
</code></pre>
      </li>
    </ul>
    <p class="normal">Now, let's <a id="_idIndexMarker088"/>see how these <a id="_idIndexMarker089"/>modules are required by <code class="Code-In-Text--PACKT-">main.js</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> a = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./a'</span>)
<span class="hljs-keyword">const</span> b = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./b'</span>)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a -&gt;'</span>, <span class="hljs-built_in">JSON</span>.stringify(a, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>))
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b -&gt;'</span>, <span class="hljs-built_in">JSON</span>.stringify(b, <span class="hljs-literal">null</span>, <span class="hljs-number">2</span>))
</code></pre>
    <p class="normal">If we run <code class="Code-In-Text--PACKT-">main.js</code>, we will see the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">a -&gt; {
  "b": {
    "a": {
      "loaded": false
    },
    "loaded": true
  },
  "loaded": true
}
b -&gt; {
  "a": {
    "loaded": false
  },
  "loaded": true
}
</code></pre>
    <p class="normal">This result reveals the caveats of circular dependencies with CommonJS, that is, different parts of our application will have a different view of what is exported by module <code class="Code-In-Text--PACKT-">a.js</code> and module <code class="Code-In-Text--PACKT-">b.js</code>, depending <a id="_idIndexMarker090"/>on the order in which those dependencies are loaded. While both the <a id="_idIndexMarker091"/>modules are completely initialized as soon as they are required from the module <code class="Code-In-Text--PACKT-">main.js</code>, the <code class="Code-In-Text--PACKT-">a.js</code> module will be incomplete when it is loaded from <code class="Code-In-Text--PACKT-">b.js</code>. In particular, its state will be the one that it reached the moment <code class="Code-In-Text--PACKT-">b.js</code> was required.</p>
    <p class="normal">In order to understand in more detail what happens behind the scenes, let's analyze step by step how the different modules are interpreted and how their local scope changes along the way:</p>
    <figure class="mediaobject"><img src="../Images/B15729_02_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 2.2: A visual representation of how a dependency loop is managed in Node.js</p>
    <p class="normal">The steps are as follows:</p>
    <ol>
      <li class="numbered">The processing starts in <code class="Code-In-Text--PACKT-">main.js</code>, which immediately requires <code class="Code-In-Text--PACKT-">a.js</code></li>
      <li class="numbered">The first thing that module <code class="Code-In-Text--PACKT-">a.js</code> does is set an exported value called <code class="Code-In-Text--PACKT-">loaded</code> to <code class="Code-In-Text--PACKT-">false</code></li>
      <li class="numbered">At this point, module <code class="Code-In-Text--PACKT-">a.js</code> requires module <code class="Code-In-Text--PACKT-">b.js</code></li>
      <li class="numbered">Like <code class="Code-In-Text--PACKT-">a.js</code>, the first thing that module <code class="Code-In-Text--PACKT-">b.js</code> does is set an exported value called <code class="Code-In-Text--PACKT-">loaded</code> to <code class="Code-In-Text--PACKT-">false</code></li>
      <li class="numbered">Now, <code class="Code-In-Text--PACKT-">b.js</code> requires <code class="Code-In-Text--PACKT-">a.js</code> (cycle)</li>
      <li class="numbered">Since <code class="Code-In-Text--PACKT-">a.js</code> has already been traversed, its currently exported value is immediately copied into the scope of module <code class="Code-In-Text--PACKT-">b.js</code></li>
      <li class="numbered">Module <code class="Code-In-Text--PACKT-">b.js</code> finally changes the <code class="Code-In-Text--PACKT-">loaded</code> value to <code class="Code-In-Text--PACKT-">true</code></li>
      <li class="numbered">Now that <code class="Code-In-Text--PACKT-">b.js</code> has been fully executed, the control returns to <code class="Code-In-Text--PACKT-">a.js,</code> which now holds a copy of the current state of module <code class="Code-In-Text--PACKT-">b.js</code> in its own scope</li>
      <li class="numbered">The last step of module <code class="Code-In-Text--PACKT-">a.js</code> is to set its <code class="Code-In-Text--PACKT-">loaded</code> value to <code class="Code-In-Text--PACKT-">true</code></li>
      <li class="numbered">Module <code class="Code-In-Text--PACKT-">a.js</code> is now completely executed and the control returns to <code class="Code-In-Text--PACKT-">main.js</code>, which now has a copy of the <a id="_idIndexMarker092"/>current state of module <code class="Code-In-Text--PACKT-">a.js</code> in its internal scope</li>
      <li class="numbered"><code class="Code-In-Text--PACKT-">main.js</code> requires <code class="Code-In-Text--PACKT-">b.js</code>, which is immediately loaded from cache</li>
      <li class="numbered">The current state of module <code class="Code-In-Text--PACKT-">b.js</code> is copied into the scope of module <code class="Code-In-Text--PACKT-">main.js</code> where we can finally see the complete picture of <a id="_idIndexMarker093"/>what the state of every module is</li>
    </ol>
    <p class="normal">As we said, the issue here is that module <code class="Code-In-Text--PACKT-">b.js</code> has a partial view of module <code class="Code-In-Text--PACKT-">a.js</code>, and this partial view gets propagated over when <code class="Code-In-Text--PACKT-">b.js</code> is required in <code class="Code-In-Text--PACKT-">main.js</code>. This behavior should spark an intuition which can be confirmed if we swap the order in which the two modules are required in <code class="Code-In-Text--PACKT-">main.js</code>. If you actually try this, you will see that this time it will be the <code class="Code-In-Text--PACKT-">a.js</code> module that will receive an incomplete version of <code class="Code-In-Text--PACKT-">b.js</code>.</p>
    <p class="normal">We understand now that this can become quite a fuzzy business if we lose control of which module is loaded first, which can happen quite easily if the project is big enough.</p>
    <p class="normal">Later in this chapter, we will see how ESM can deal with circular dependencies in a more effective way. Meanwhile, if you are using CommonJS, be very careful about this behavior and the way it can affect your application.</p>
    <p class="normal">In the next section, we will discuss some patterns to define modules in Node.js.</p>
    <h1 id="_idParaDest-47" class="title">Module definition patterns</h1>
    <p class="normal">The module system, besides being a mechanism for loading dependencies, is also a tool for defining APIs. Like any <a id="_idIndexMarker094"/>other problem related to API design, the main factor to consider is the balance between private and public functionality. The aim is to maximize information hiding and API usability, while balancing these with other software qualities, such as <em class="italic">extensibility</em> and <em class="italic">code reuse</em>.</p>
    <p class="normal">In this section, we will analyze some of the most popular patterns for defining modules in Node.js, such as named <a id="_idIndexMarker095"/>exports, exporting functions, classes and instances, and monkey patching. Each one has its own balance of information hiding, extensibility, and code reuse.</p>
    <h2 id="_idParaDest-48" class="title">Named exports</h2>
    <p class="normal">The most basic method for exposing a public API is using <strong class="keyword">named exports</strong>, which involves assigning the values we <a id="_idIndexMarker096"/>want to make public to properties of the object referenced by <code class="Code-In-Text--PACKT-">exports</code> (or <code class="Code-In-Text--PACKT-">module.exports</code>). In this way, the resulting exported object becomes a container or namespace for a set of related functionalities.</p>
    <p class="normal">The following code shows a module implementing this pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// file logger.js</span>
<span class="hljs-built_in">exports</span>.info = <span class="hljs-function">(</span><span class="hljs-params">message</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`info: </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
}
<span class="hljs-built_in">exports</span>.verbose = <span class="hljs-function">(</span><span class="hljs-params">message</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`verbose: </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
}
</code></pre>
    <p class="normal">The exported functions are then available as properties of the loaded module, as shown in the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// file main.js</span>
<span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./logger'</span>)
logger.info(<span class="hljs-string">'This is an informational message'</span>)
logger.verbose(<span class="hljs-string">'This is a verbose message'</span>)
</code></pre>
    <p class="normal">Most of the Node.js core modules use this pattern. However, the CommonJS specification only allows the use of the <code class="Code-In-Text--PACKT-">exports</code> variable to expose public members. Therefore, the named exports pattern is the only one that is really compatible with the CommonJS specification. The use of <code class="Code-In-Text--PACKT-">module.exports</code> is an extension provided by Node.js to support a broader range of module definition patterns, which we are going to see next.</p>
    <h2 id="_idParaDest-49" class="title">Exporting a function</h2>
    <p class="normal">One of the most popular module definition patterns consists of reassigning the whole <code class="Code-In-Text--PACKT-">module.exports</code> variable to a function. The main strength of this pattern is the fact that it allows you to <a id="_idIndexMarker097"/>expose only a single functionality, which provides a clear entry point for the module, making it simpler to understand and use; it also honors the principle of <em class="italic">small surface</em> area very well. This way of defining modules is also <a id="_idIndexMarker098"/>known in the community as the <strong class="keyword">substack pattern</strong>, after one of its most prolific adopters, James Halliday (nickname substack – <a href="https://github.com/substack"><span class="url">https://github.com/substack</span></a>). Have a look at this pattern in the following example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// file logger.js</span>
<span class="hljs-built_in">module</span>.exports = <span class="hljs-function">(</span><span class="hljs-params">message</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`info: </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
}
</code></pre>
    <p class="normal">A possible extension of this pattern is using the exported function as a namespace for other public APIs. This is a very powerful combination because it still gives the module the clarity of a single entry point (the main exported function) and at the same time it allows us to expose other functionalities that have secondary or more advanced use cases. The following code shows us how to extend the module we defined previously by using the exported function as a namespace:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">module</span>.exports.verbose = <span class="hljs-function">(</span><span class="hljs-params">message</span><span class="hljs-function">) =&gt;</span> {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`verbose: </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
}
</code></pre>
    <p class="normal">This code demonstrates how to use the module that we just defined:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// file main.js</span>
<span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./logger'</span>)
logger(<span class="hljs-string">'This is an informational message'</span>)
logger.verbose(<span class="hljs-string">'This is a verbose message'</span>)
</code></pre>
    <p class="normal">Even though exporting just a function might seem like a limitation, in reality, it's a perfect way to put the emphasis on a single functionality, the most important one for the module, while giving less visibility to secondary or internal aspects, which are instead exposed as properties of the exported function itself. The modularity of Node.js heavily encourages the <a id="_idIndexMarker099"/>adoption of the <strong class="keyword">single-responsibility principle</strong> (<strong class="keyword">SRP</strong>): every module should have responsibility over a single functionality and that responsibility should be entirely encapsulated by the module.</p>
    <h2 id="_idParaDest-50" class="title">Exporting a class</h2>
    <p class="normal">A module that exports a class is a specialization of a module that exports a function. The difference is that with this new <a id="_idIndexMarker100"/>pattern we allow the user to create new instances using the constructor, but we also give them the ability to extend its prototype and forge new classes. The following is an example of this pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Logger</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (name) {
    <span class="hljs-built_in">this</span>.name = name
  }
  log (message) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">name}</span><span class="hljs-string">] </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
  }
  info (message) {
    <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`info: </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
  }
  verbose (message) {
    <span class="hljs-built_in">this</span>.log(<span class="hljs-string">`verbose: </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
  }
}
<span class="hljs-built_in">module</span>.exports = Logger
</code></pre>
    <p class="normal">And, we can use the preceding module as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// file main.js</span>
<span class="hljs-keyword">const</span> Logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./logger'</span>)
<span class="hljs-keyword">const</span> dbLogger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'DB'</span>)
dbLogger.info(<span class="hljs-string">'This is an informational message'</span>)
<span class="hljs-keyword">const</span> accessLogger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'ACCESS'</span>)
accessLogger.verbose(<span class="hljs-string">'This is a verbose message'</span>)
</code></pre>
    <p class="normal">Exporting a class still provides a single entry point for the module, but compared to the substack pattern, it exposes a lot more of the module internals. On the other hand, it allows much more power when it comes to extending its functionality.</p>
    <h2 id="_idParaDest-51" class="title">Exporting an instance</h2>
    <p class="normal">We can leverage the caching mechanism of <code class="Code-In-Text--PACKT-">require()</code> to easily define stateful instances created from a constructor or a <a id="_idIndexMarker101"/>factory, which can be shared across different modules. The following code shows an example of this pattern:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// file logger.js</span>
<span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Logger</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (name) {
    <span class="hljs-built_in">this</span>.count = <span class="hljs-number">0</span>
    <span class="hljs-built_in">this</span>.name = name
  }
  log (message) {
    <span class="hljs-built_in">this</span>.count++
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'['</span> + <span class="hljs-built_in">this</span>.name + <span class="hljs-string">'] '</span> + message)
  }
}
<span class="hljs-built_in">module</span>.exports = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'DEFAULT'</span>)
</code></pre>
    <p class="normal">This newly defined module can then be used as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./logger'</span>)
logger.log(<span class="hljs-string">'This is an informational message'</span>)
</code></pre>
    <p class="normal">Because the module is cached, every module that requires the <code class="Code-In-Text--PACKT-">logger</code> module will actually always retrieve the same instance of the object, thus sharing its state. This pattern is very much like creating a <strong class="keyword">singleton</strong>. However, it does not guarantee the uniqueness of the instance across the entire application, as it happens in the traditional singleton pattern. When analyzing the resolving algorithm, we have seen that a module might be installed multiple times inside the dependency tree of an application. This results in multiple instances of the same logical module, all running in the context of the same Node.js application. We will analyze the Singleton pattern and its caveats in more detail in <em class="chapterRef">Chapter 7</em>, <em class="italic">Creational Design Patterns</em>.</p>
    <p class="normal">One interesting detail of this pattern is that it does not preclude the opportunity to create new instances, even if we are not explicitly exporting the class. In fact, we can rely on the <code class="Code-In-Text--PACKT-">constructor</code> property of the exported instance to construct a new instance of the same type:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">const</span> customLogger = <span class="hljs-keyword">new</span> logger.constructor(<span class="hljs-string">'CUSTOM'</span>)
customLogger.log(<span class="hljs-string">'This is an informational message'</span>)
</code></pre>
    <p class="normal">As you can see, by using <code class="Code-In-Text--PACKT-">logger.constructor()</code>, we can instantiate new <code class="Code-In-Text--PACKT-">Logger</code> objects. Note that this technique must be used with caution or avoided altogether. Consider that, if the module author decided not to export the class explicitly, they probably wanted to keep this class private.</p>
    <h2 id="_idParaDest-52" class="title">Modifying other modules or the global scope</h2>
    <p class="normal">A module can even export nothing. This can seem a bit out of place; however, we should not forget that a <a id="_idIndexMarker102"/>module can modify the global scope and any object in it, including other <a id="_idIndexMarker103"/>modules in the cache. Please note that these are in general considered bad practices, but since this pattern can be useful and safe under some circumstances (for example, for testing) and it's sometimes used in real-life projects, it's worth knowing.</p>
    <p class="normal">We said that a module can modify other modules or objects in the global scope; well, this is called <strong class="keyword">monkey patching</strong>. It generally <a id="_idIndexMarker104"/>refers to the practice of modifying the existing objects at runtime to change or extend their behavior or to apply temporary fixes.</p>
    <p class="normal">The following example shows us how we can add a new function to another module:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// file patcher.js</span>
<span class="hljs-comment">// ./logger is another module</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">'./logger'</span>).customMessage = <span class="hljs-keyword">function</span><span class="hljs-function"> () </span>{
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'This is a new functionality'</span>)
}
</code></pre>
    <p class="normal">Using our new <code class="Code-In-Text--PACKT-">patcher</code> module is as easy as writing the following code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// file main.js</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">'./patcher'</span>)
<span class="hljs-keyword">const</span> logger = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./logger'</span>)
logger.customMessage()
</code></pre>
    <p class="normal">The technique described here can be very dangerous to use. The main concern is that having a module that modifies the global namespace or other modules is an operation with <em class="italic">side effects</em>. In other words, it affects the state of entities outside their scope, which can have consequences that aren't easily predictable, especially when multiple modules interact with the same entities. Imagine having two different modules trying to set the same global variable, or modifying the same property of the same module. The effects can be unpredictable (which module wins?), but most importantly it would have repercussions on the entire application.</p>
    <p class="normal">So, again use this technique with care and make sure you understand all the possible side effects while doing so.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">If you want a real-life example of how this can be useful, have a look at <code class="Code-In-Text--PACKT-">nock</code> (<a href="http://nodejsdp.link/nock"><span class="url">nodejsdp.link/nock</span></a>), a module that <a id="_idIndexMarker105"/>allows you to mock HTTP responses in your tests. The way <code class="Code-In-Text--PACKT-">nock</code> works is by monkey patching the Node.js <code class="Code-In-Text--PACKT-">http</code> module and by changing its behavior so that it will provide the mocked response rather than issuing a real HTTP request. This allows our unit test to run without hitting the actual production HTTP endpoints, something that's very convenient when writing tests for code that relies on third-party APIs.</p>
    </div>
    <p class="normal">At this point, we should <a id="_idIndexMarker106"/>have a quite complete under<a id="_idIndexMarker107"/>standing of CommonJS and some of the patterns that are generally used with it. In the next section, we will explore ECMAScript modules, also known as ESM.</p>
    <h1 id="_idParaDest-53" class="title">ESM: ECMAScript modules</h1>
    <p class="normal">ECMAScript modules (also known as ES modules or ESM) were introduced as part of the ECMAScript 2015 specification with the goal to give JavaScript an official <a id="_idIndexMarker108"/>module system suitable for different execution environments. The ESM specification tries to retain some good ideas from previous existing module systems like CommonJS and AMD. The syntax is very simple and compact. There is support for cyclic dependencies and the possibility to load modules asynchronously.</p>
    <p class="normal">The most important differentiator between ESM and CommonJS is that ES modules are <em class="italic">static</em>, which means that imports are described at the top level of every module and outside any control flow statement. Also, the name of the imported modules cannot be dynamically generated at runtime using expressions, only constant strings are allowed.</p>
    <p class="normal">For instance, the following code wouldn't be valid when using ES modules:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">if</span> (condition) {
  <span class="hljs-keyword">import</span> module1 <span class="hljs-keyword">from</span> <span class="hljs-string">'module1'</span>
} <span class="hljs-keyword">else</span> {
  <span class="hljs-keyword">import</span> module2 <span class="hljs-keyword">from</span> <span class="hljs-string">'module2'</span>
}
</code></pre>
    <p class="normal">While in CommonJS, it is perfectly fine to write something like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">let</span> <span class="hljs-built_in">module</span> = <span class="hljs-literal">null</span>
<span class="hljs-keyword">if</span> (condition) {
  <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'module1'</span>)
} <span class="hljs-keyword">else</span> {
  <span class="hljs-built_in">module</span> = <span class="hljs-built_in">require</span>(<span class="hljs-string">'module2'</span>)
}
</code></pre>
    <p class="normal">At a first glance, this characteristic of ESM might seem an unnecessary limitation, but in reality, having static imports opens up a number of interesting scenarios that are not practical with the dynamic <a id="_idIndexMarker109"/>nature of CommonJS. For instance, static imports allow the static analysis of the dependency tree, which allows optimizations such as dead code elimination (tree shaking) and more.</p>
    <h2 id="_idParaDest-54" class="title">Using ESM in Node.js</h2>
    <p class="normal">Node.js will consider every <code class="Code-In-Text--PACKT-">.js</code> file to be written using the CommonJS syntax by default; therefore, if we <a id="_idIndexMarker110"/>use the ESM syntax inside a <code class="Code-In-Text--PACKT-">.js</code> file, the <a id="_idIndexMarker111"/>interpreter will simply throw an error.</p>
    <p class="normal">There are several ways to tell the Node.js interpreter to consider a given module as an ES module rather than a CommonJS module:</p>
    <ul>
      <li class="Bullet--PACKT-">Give the module file the extension <code class="Code-In-Text--PACKT-">.mjs</code></li>
      <li class="Bullet-End--PACKT-">Add to the nearest parent <code class="Code-In-Text--PACKT-">package.json</code> a field called "<code class="Code-In-Text--PACKT-">type"</code> with a value of <code class="Code-In-Text--PACKT-">"module"</code></li>
    </ul>
    <div class="note">
      <p class="Information-Box--PACKT-">Throughout the rest of this book and in the code examples provided, we will keep using the <code class="Code-In-Text--PACKT-">.js</code> extension to keep the code more easily accessible to most text editors, so if you are copying and pasting examples straight from the book, make sure that you also create a <code class="Code-In-Text--PACKT-">package.json</code> file with the <code class="Code-In-Text--PACKT-">"type":"module"</code> entry.</p>
    </div>
    <p class="normal">Let's now have a look at the ESM syntax.</p>
    <h2 id="_idParaDest-55" class="title">Named exports and imports</h2>
    <p class="normal">ESM allows us to <a id="_idIndexMarker112"/>export functionality <a id="_idIndexMarker113"/>from a module <a id="_idIndexMarker114"/>through the <code class="Code-In-Text--PACKT-">export</code> keyword.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">Note that ESM uses the singular word <code class="Code-In-Text--PACKT-">export</code> as opposed to the plural (<code class="Code-In-Text--PACKT-">exports</code> and <code class="Code-In-Text--PACKT-">module.exports</code>) used by CommonJS.</p>
    </div>
    <p class="normal">In an ES module, everything is private by default and only exported entities are publicly accessible from other modules.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">export</code> keyword can be used in front of the entities that we want to make available to the module users. Let's see an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// logger.js</span>
<span class="hljs-comment">// exports a function as `log`</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">log</span><span class="hljs-function"> (</span><span class="hljs-params">message</span><span class="hljs-function">) </span>{
  <span class="hljs-built_in">console</span>.log(message)
}
<span class="hljs-comment">// exports a constant as `DEFAULT_LEVEL`</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> DEFAULT_LEVEL = <span class="hljs-string">'info'</span>
<span class="hljs-comment">// exports an object as `LEVELS`</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> LEVELS = {
  <span class="hljs-attr">error</span>: <span class="hljs-number">0</span>,
  <span class="hljs-attr">debug</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">warn</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">data</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">info</span>: <span class="hljs-number">4</span>,
  <span class="hljs-attr">verbose</span>: <span class="hljs-number">5</span>
}
<span class="hljs-comment">// exports a class as `Logger`</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Logger</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (name) {
    <span class="hljs-built_in">this</span>.name = name
  }
  log (message) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">name}</span><span class="hljs-string">] </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
  }
}
</code></pre>
    <p class="normal">If we want to import entities from a module we can use the <code class="Code-In-Text--PACKT-">import</code> keyword. The syntax is quite flexible, and it allows us to import one or more entities and even to rename imports. Let's see some examples:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> loggerModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger.js'</span>
<span class="hljs-built_in">console</span>.log(loggerModule)
</code></pre>
    <p class="normal">In this example, we are <a id="_idIndexMarker115"/>using the <code class="Code-In-Text--PACKT-">*</code> syntax (also called <strong class="keyword">namespace import</strong>) to import all the members of the <a id="_idIndexMarker116"/>module <a id="_idIndexMarker117"/>and assign them to the local <code class="Code-In-Text--PACKT-">loggerModule</code> variable. This <a id="_idIndexMarker118"/>example will output something like this:</p>
    <pre class="programlisting con"><code class="hljs-con">[Module] {
  DEFAULT_LEVEL: 'info',
  LEVELS: { error: 0, debug: 1, warn: 2, data: 3, info: 4,
    verbose: 5 },
  Logger: [Function: Logger],
  log: [Function: log]
}
</code></pre>
    <p class="normal">As we can see, all the entities exported in our module are now accessible in the <code class="Code-In-Text--PACKT-">loggerModule</code> namespace. For instance, we could refer to the <code class="Code-In-Text--PACKT-">log()</code> function through <code class="Code-In-Text--PACKT-">loggerModule.log</code>.</p>
    <div class="note">
      <p class="Information-Box--PACKT-">It's very important to note that, as opposed to CommonJS, with ESM we have to specify the file extension of the imported modules. With CommonJS we can use either <code class="Code-In-Text--PACKT-">./logger</code> or <code class="Code-In-Text--PACKT-">./logger.js</code>, with ESM we are forced to use <code class="Code-In-Text--PACKT-">./logger.js</code>.</p>
    </div>
    <p class="normal">If we are using a large module, most often we don't want to import all of its functionality, but only one or few entities from it:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { log } <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger.js'</span>
log(<span class="hljs-string">'Hello World'</span>)
</code></pre>
    <p class="normal">If we want to import more than one entity, this is how we would do that:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { log, Logger } <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger.js'</span>
log(<span class="hljs-string">'Hello World'</span>)
<span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> Logger(<span class="hljs-string">'DEFAULT'</span>)
logger.log(<span class="hljs-string">'Hello world'</span>)
</code></pre>
    <p class="normal">When we use this type of <code class="Code-In-Text--PACKT-">import</code> statement, the entities are imported into the current scope, so there is a risk of a name clash. The following code, for example, would not work:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { log } <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger.js'</span>
<span class="hljs-keyword">const</span> log = <span class="hljs-built_in">console</span>.log
</code></pre>
    <p class="normal">If we try to execute <a id="_idIndexMarker119"/>the preceding snippet, the interpreter fails with the following error:</p>
    <pre class="programlisting con"><code class="hljs-con">SyntaxError: Identifier 'log' has already been declared
</code></pre>
    <p class="normal">In situations like <a id="_idIndexMarker120"/>this one, we can resolve <a id="_idIndexMarker121"/>the clash by renaming the imported entity with the <code class="Code-In-Text--PACKT-">as</code> keyword:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { log <span class="hljs-keyword">as</span> log2 } <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger.js'</span>
<span class="hljs-keyword">const</span> log = <span class="hljs-built_in">console</span>.log
log(<span class="hljs-string">'message from log'</span>)
log2(<span class="hljs-string">'message from log2'</span>)
</code></pre>
    <p class="normal">This approach can be particularly useful when the clash is generated by importing two entities with the same name from different modules, and therefore changing the original names is outside the consumer's control.</p>
    <h2 id="_idParaDest-56" class="title">Default exports and imports</h2>
    <p class="normal">One widely used feature of CommonJS is the ability to export a single unnamed entity through the <a id="_idIndexMarker122"/>assignment of <code class="Code-In-Text--PACKT-">module.exports</code>. We saw that this is very convenient as it encourages module <a id="_idIndexMarker123"/>developers to follow the single-responsibility principle and expose only one clear interface. With ESM, we can do something similar through what's called a <strong class="keyword">default export</strong>. A default <a id="_idIndexMarker124"/>export makes use of the <code class="Code-In-Text--PACKT-">export default</code> keywords and it looks like this:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// logger.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">class</span><span class="hljs-class"> </span><span class="hljs-title">Logger</span><span class="hljs-class"> </span>{
  <span class="hljs-keyword">constructor</span> (name) {
    <span class="hljs-built_in">this</span>.name = name
  }
  log (message) {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[</span><span class="hljs-subst">${</span><span class="hljs-built_in">this</span>.<span class="hljs-subst">name}</span><span class="hljs-string">] </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
  }
}
</code></pre>
    <p class="normal">In this case, the name <code class="Code-In-Text--PACKT-">Logger</code> is ignored, and the entity exported is registered under the name <code class="Code-In-Text--PACKT-">default</code>. This exported name is handled in a special way, and it can be imported as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> MyLogger <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger.js'</span>
<span class="hljs-keyword">const</span> logger = <span class="hljs-keyword">new</span> MyLogger(<span class="hljs-string">'info'</span>)
logger.log(<span class="hljs-string">'Hello World'</span>)
</code></pre>
    <p class="normal">The difference with named ESM imports is that here, since the default export is considered unnamed, we can import it and at the same time assign it a local name of our choice. In this <a id="_idIndexMarker125"/>example, we can replace <code class="Code-In-Text--PACKT-">MyLogger</code> with anything else that makes sense in our context. This is <a id="_idIndexMarker126"/>very similar to what we do with CommonJS modules. Note also that we don't have to wrap the import name around brackets or use the <code class="Code-In-Text--PACKT-">as</code> keyword when renaming.</p>
    <p class="normal">Internally, a default export is equivalent <a id="_idIndexMarker127"/>to a named export with <code class="Code-In-Text--PACKT-">default</code> as the name. We can easily verify this statement by running the following snippet of code:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// showDefault.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> loggerModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger.js'</span>
<span class="hljs-built_in">console</span>.log(loggerModule)
</code></pre>
    <p class="normal">When executed, the previous code will print something like this:</p>
    <pre class="programlisting con"><code class="hljs-con">[Module] { default: [Function: Logger] }
</code></pre>
    <p class="normal">One thing that we cannot do, though, is import the default entity explicitly. In fact, something like the following will fail:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">default</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger.js'</span>
</code></pre>
    <p class="normal">The execution will fail with a <code class="Code-In-Text--PACKT-">SyntaxError: Unexpected reserved word</code> error. This happens <a id="_idIndexMarker128"/>because the <code class="Code-In-Text--PACKT-">default</code> keyword cannot be used as a variable name. It is valid as an object <a id="_idIndexMarker129"/>attribute, so in the <a id="_idIndexMarker130"/>previous example, it is okay to use <code class="Code-In-Text--PACKT-">loggerModule.default</code>, but we can't have a variable named <code class="Code-In-Text--PACKT-">default</code> directly in the scope.</p>
    <h2 id="_idParaDest-57" class="title">Mixed exports</h2>
    <p class="normal">It is possible to mix named <a id="_idIndexMarker131"/>exports and a default <a id="_idIndexMarker132"/>export within an ES module. Let's have a look at an example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// logger.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">log</span><span class="hljs-function"> (</span><span class="hljs-params">message</span><span class="hljs-function">) </span>{
  <span class="hljs-built_in">console</span>.log(message)
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">info</span><span class="hljs-function"> (</span><span class="hljs-params">message</span><span class="hljs-function">) </span>{
  log(<span class="hljs-string">`info: </span><span class="hljs-subst">${message}</span><span class="hljs-string">`</span>)
}
</code></pre>
    <p class="normal">The preceding code is exporting the <code class="Code-In-Text--PACKT-">log()</code> function as a default export and a named export for a function called <code class="Code-In-Text--PACKT-">info()</code>. Note that <code class="Code-In-Text--PACKT-">info()</code> can reference <code class="Code-In-Text--PACKT-">log()</code> internally. It would not be possible to replace the call to <code class="Code-In-Text--PACKT-">log()</code> with <code class="Code-In-Text--PACKT-">default()</code> to do that, as it would be a syntax error (Unexpected token <code class="Code-In-Text--PACKT-">default</code>).</p>
    <p class="normal">If we want to import both the default export and one or more named exports, we can do it using the following format:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> mylog, { info } <span class="hljs-keyword">from</span> <span class="hljs-string">'./logger.js'</span>
</code></pre>
    <p class="normal">In the preceding example, we are importing the default export from <code class="Code-In-Text--PACKT-">logger.js</code> as <code class="Code-In-Text--PACKT-">mylog</code> and also the named export <code class="Code-In-Text--PACKT-">info</code>.</p>
    <p class="normal">Let's now discuss some key details and differences between the default export and named exports:</p>
    <ul>
      <li class="Bullet--PACKT-">Named exports are explicit. Having predetermined names allows IDEs to support the developer with automatic imports, autocomplete, and refactoring tools. For instance, if we type <code class="Code-In-Text--PACKT-">writeFileSync</code>, the editor might automatically add <code class="Code-In-Text--PACKT-">import { writeFileSync } from 'fs'</code> at the beginning of the current file. Default exports, on the contrary, make all these things more complicated as a given functionality could have different names in different files, so it's harder to make inferences on which module might provide a given functionality based only on a given name.</li>
      <li class="Bullet--PACKT-">The default export is a convenient mechanism to communicate what is the single most important functionality for a module. Also, from the perspective of the user, it can be easier to import the obvious piece of functionality without having to know the exact <a id="_idIndexMarker133"/>name of the binding.</li>
      <li class="Bullet-End--PACKT-">In some circumstances, default exports might make it harder to apply dead code elimination (tree shaking). For example, a module could provide only a default export, which is an object where all the functionality is exposed as properties of such an object. When we import this default object, most module bundlers will consider the entire object being used and they won't be able to eliminate any unused code from the exported functionality.</li>
    </ul>
    <p class="normal">For these reasons, it is generally considered good practice to stick with named exports, especially when you want to <a id="_idIndexMarker134"/>expose more than one functionality, and only use default exports if it's one clear functionality you want to export.</p>
    <p class="normal">This is not a hard rule and there are notable exceptions to this suggestion. For instance, all Node.js core modules have both a default export and a number of named exports. Also, React (<a href="http://nodejsdp.link/react"><span class="url">nodejsdp.link/react</span></a>) uses mixed exports.</p>
    <p class="normal">Consider carefully what the best approach for your specific module is and what you want the developer experience to be for the users of your module.</p>
    <h2 id="_idParaDest-58" class="title">Module identifiers</h2>
    <p class="normal"><strong class="keyword">Module identifiers </strong>(also called <em class="italic">module specifiers</em>) are the different types of values that we can use in our <code class="Code-In-Text--PACKT-">import</code> statements <a id="_idIndexMarker135"/>to specify <a id="_idIndexMarker136"/>the location of the module we want to load.</p>
    <p class="normal">So far, we have seen only relative paths, but there are several other possibilities and some nuances to keep in mind. Let's list all the possibilities:</p>
    <ul>
      <li class="Bullet--PACKT-"><em class="italic">Relative specifiers</em> like <code class="Code-In-Text--PACKT-">./logger.js</code> or <code class="Code-In-Text--PACKT-">../logger.js</code>. They are used to refer to a path relative to the location of the importing file.</li>
      <li class="Bullet--PACKT-"><em class="italic">Absolute specifiers</em> like <code class="Code-In-Text--PACKT-">file:///opt/nodejs/config.js</code>. They refer directly and explicitly to a full path. Note that this is the only way with ESM to refer to an absolute path for a module, using a <code class="Code-In-Text--PACKT-">/</code> or a <code class="Code-In-Text--PACKT-">//</code> prefix won't work. This is a significant difference with CommonJS.</li>
      <li class="Bullet--PACKT-"><em class="italic">Bare specifiers</em> are identifiers like <code class="Code-In-Text--PACKT-">fastify</code> or <code class="Code-In-Text--PACKT-">http</code>, and they represent modules available in the <code class="Code-In-Text--PACKT-">node_modules</code> folder and generally installed through a package manager (such as npm) or available as core Node.js modules.</li>
      <li class="Bullet-End--PACKT-"><em class="italic">Deep import specifiers</em> like <code class="Code-In-Text--PACKT-">fastify/lib/logger.js</code>, which refer to a path within a package in <code class="Code-In-Text--PACKT-">node_modules</code> (<code class="Code-In-Text--PACKT-">fastify</code>, in this case).</li>
    </ul>
    <p class="normal">In browser <a id="_idIndexMarker137"/>environments, it is possible to import modules directly by <a id="_idIndexMarker138"/>specifying the module URL, for instance, <a href="https://unpkg.com/lodash"><span class="url">https://unpkg.com/lodash</span></a>. This feature <a id="_idIndexMarker139"/>is not supported by Node.js.</p>
    <h2 id="_idParaDest-59" class="title">Async imports</h2>
    <p class="normal">As we have seen in the previous section, the <code class="Code-In-Text--PACKT-">import</code> statement is static and therefore subject to two important limitations:</p>
    <ul>
      <li class="Bullet--PACKT-">A module <a id="_idIndexMarker140"/>identifier cannot be constructed at runtime</li>
      <li class="Bullet-End--PACKT-">Module imports are <a id="_idIndexMarker141"/>declared at the top level of every file and they cannot be nested within control flow statements</li>
    </ul>
    <p class="normal">There are some use cases when these limitations can become a little bit too restrictive. Imagine, for instance, if we have to import a specific translation module for the current user language, or a variation of a module that depends on the user's operating system. </p>
    <p class="normal">Also, what if we want to load a given module, which might be particularly heavy, only if the user is accessing the piece of functionality that requires that module?</p>
    <p class="normal">To allow us to overcome these limitations ES modules provides <em class="italic">async imports</em> (also called <em class="italic">dynamic imports</em>).</p>
    <p class="normal">Async imports can be performed at runtime using the special <code class="Code-In-Text--PACKT-">import()</code> operator.</p>
    <p class="normal">The <code class="Code-In-Text--PACKT-">import()</code> operator is syntactically equivalent to a function that takes a module identifier as an argument and it returns a promise that resolves to a module object.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">We will learn more about promises in <em class="chapterRef">Chapter 5</em>, <em class="italic">Asynchronous Control Flow Patterns with Promises and Async/Await</em>, so don't worry too much about understanding all the nuances of the specific promise syntax for now.</p>
    </div>
    <p class="normal">The module identifier can be any module identifier supported by static imports as discussed in the previous section. Now, let's see how to use dynamic imports with a simple example.</p>
    <p class="normal">We want to build a command line application that can print "Hello World" in different languages. In the future, we will probably want to support many more phrases and languages, so it makes <a id="_idIndexMarker142"/>sense to have one file with the translations of all the user-facing strings for each supported language.</p>
    <p class="normal">Let's create some <a id="_idIndexMarker143"/>example modules for some of the languages we want to support:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// strings-el.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HELLO = <span class="hljs-string">'Γεια σου κόσμε'</span>
<span class="hljs-comment">// strings-en.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HELLO = <span class="hljs-string">'Hello World'</span>
<span class="hljs-comment">// strings-es.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HELLO = <span class="hljs-string">'Hola mundo'</span>
<span class="hljs-comment">// strings-it.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HELLO = <span class="hljs-string">'Ciao mondo'</span>
<span class="hljs-comment">// strings-pl.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> HELLO = <span class="hljs-string">'Witaj świecie'</span>
</code></pre>
    <p class="normal">Now let's create the main script that takes a language code from the command line and prints "Hello World" in the selected language:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">const</span> SUPPORTED_LANGUAGES = [<span class="hljs-string">'el'</span>, <span class="hljs-string">'en'</span>, <span class="hljs-string">'es'</span>, <span class="hljs-string">'it'</span>, <span class="hljs-string">'pl'</span>]   <span class="hljs-comment">// (1)</span>
<span class="hljs-keyword">const</span> selectedLanguage = process.argv[<span class="hljs-number">2</span>]                     <span class="hljs-comment">// (2)</span>
<span class="hljs-keyword">if</span> (!SUPPORTED_LANGUAGES.includes(selectedLanguage)) {       <span class="hljs-comment">// (3)</span>
  <span class="hljs-built_in">console</span>.error(<span class="hljs-string">'The specified language is not supported'</span>)
  process.exit(<span class="hljs-number">1</span>)
}
<span class="hljs-keyword">const</span> translationModule = <span class="hljs-string">`./strings-</span><span class="hljs-subst">${selectedLanguage}</span><span class="hljs-string">.js`</span> <span class="hljs-comment">// (4)</span>
<strong class="hljs-keyword-slc">import</strong><strong class="hljs-slc">(translationModule)</strong>                                    <span class="hljs-comment">// (5)</span>
  .then(<span class="hljs-function">(</span><strong class="hljs-params-slc">strings</strong><span class="hljs-function">) =&gt;</span> {                                       <span class="hljs-comment">// (6)</span>
    <span class="hljs-built_in">console</span>.log(strings.HELLO)
  })
</code></pre>
    <p class="normal">The first part of the script is quite simple. What we do there is:</p>
    <ol>
      <li class="numbered">Define a list of supported languages.</li>
      <li class="numbered">Read the selected language from the first argument passed in the command line.</li>
      <li class="numbered">Finally, we handle the case where the selected language is not supported.
      </li>
    </ol>
    <p class="normal">The second part of the code is where we actually use dynamic imports:</p>
    <ol>
      <li class="numbered" value="4">First of all, we dynamically build the name of the module we want to import based on the selected language. Note that the module name needs to be a relative path to the module file, that's why we are prepending <code class="Code-In-Text--PACKT-">./</code> to the filename.</li>
      <li class="numbered">We use the <code class="Code-In-Text--PACKT-">import()</code> operator to trigger the dynamic import of the module.</li>
      <li class="numbered">The dynamic import <a id="_idIndexMarker144"/>happens asynchronously, so we can use the <code class="Code-In-Text--PACKT-">.then()</code> hook on the returned <a id="_idIndexMarker145"/>promise to get notified when the module is ready to be used. The function passed to <code class="Code-In-Text--PACKT-">then()</code> will be executed when the module is fully loaded and <code class="Code-In-Text--PACKT-">strings</code> will be the module namespace imported dynamically. After that, we can access <code class="Code-In-Text--PACKT-">strings.HELLO</code> and print its value to the console.</li>
    </ol>
    <p class="normal">Now we can execute this script like this:</p>
    <pre class="programlisting con"><code class="hljs-con">node main.js it
</code></pre>
    <p class="normal">And we should see <em class="italic">Ciao mondo</em> being printed to our console.</p>
    <h2 id="_idParaDest-60" class="title">Module loading in depth</h2>
    <p class="normal">To understand how ESM <a id="_idIndexMarker146"/>actually works and how it can deal effectively with circular dependencies, we have to deep dive a little bit more into how JavaScript code is parsed and evaluated when using ES modules.</p>
    <p class="normal">In this section, we will learn how ECMAScript modules are loaded, we will present the idea of read-only <a id="_idIndexMarker147"/>live bindings, and, finally, we will discuss an example with circular dependencies.</p>
    <h3 id="_idParaDest-61" class="title">Loading phases</h3>
    <p class="normal">The goal of the interpreter is to <a id="_idIndexMarker148"/>build a graph of all the necessary <a id="_idIndexMarker149"/>modules (a <strong class="keyword">dependency graph</strong>).</p>
    <div class="note">
      <p class="Information-Box--PACKT-">In generic terms, a <strong class="keyword">dependency graph</strong> can be defined as a <strong class="keyword">directed graph</strong> (<a href="http://nodejsdp.link/directed-graph"><span class="url">nodejsdp.link/directed-graph</span></a>) representing the <a id="_idIndexMarker150"/>dependencies of a group of objects. In the context of this section, when we refer to a dependency graph, we want to indicate the dependency relationship between ECMAScript modules. As we will see, using a dependency graph allows us to determine the order in which all the necessary modules should be loaded in a given project.</p>
    </div>
    <p class="normal">Essentially, the dependency graph is needed by the interpreter to figure out how modules depend on each other and in what order the code needs to be executed. When the <code class="Code-In-Text--PACKT-">node</code> interpreter is launched, it gets passed some code to execute, generally in the form of a JavaScript file. This file is the starting point for the dependency resolution, and it is called the <strong class="keyword">entry point</strong>. From the <a id="_idIndexMarker151"/>entry point, the interpreter will find and follow all the <code class="Code-In-Text--PACKT-">import</code> statements recursively in a depth-first fashion, until all the necessary code is explored and then evaluated.</p>
    <p class="normal">More specifically, this process happens in three separate phases:</p>
    <ul>
      <li class="Bullet--PACKT-"><strong class="keyword">Phase 1 - Construction (or parsing)</strong>: Find all <a id="_idIndexMarker152"/>the imports and recursively load the content of every module from the respective file.</li>
      <li class="Bullet--PACKT-"><strong class="keyword">Phase 2 - Instantiation</strong>: For every exported entity, keep a named reference in memory, but don't assign any <a id="_idIndexMarker153"/>value just yet. Also, references are created for all the <code class="Code-In-Text--PACKT-">import</code> and <code class="Code-In-Text--PACKT-">export</code> statements tracking the dependency relationship between them (<strong class="keyword">linking</strong>). No JavaScript code has been executed at this stage.</li>
      <li class="Bullet-End--PACKT-"><strong class="keyword">Phase 3 - Evaluation</strong>: Node.js finally executes the code so that all the previously instantiated entities can get an <a id="_idIndexMarker154"/>actual value. Now running the code from the entry point is possible because all the blanks have been filled.</li>
    </ul>
    <p class="normal">In simple terms, we could say that Phase 1 is about finding all the dots, Phase 2 connects those creating paths, and, finally, Phase 3 walks through the paths in the right order.</p>
    <p class="normal">At first glance, this approach doesn't seem very different from what CommonJS does, but there's a fundamental difference. Due to its dynamic nature, CommonJS will execute all the files while the dependency graph is explored. We have seen that every time a new <code class="Code-In-Text--PACKT-">require</code> statement is found, all the previous code has already been executed. This is why you can use <code class="Code-In-Text--PACKT-">require</code> even within <code class="Code-In-Text--PACKT-">if</code> statements or loops, and construct module identifiers from variables.</p>
    <p class="normal">In ESM, these three phases are totally separate from each other, no code can be executed until the <a id="_idIndexMarker155"/>dependency graph has been fully built, and therefore module imports and exports have to be static.</p>
    <h3 id="_idParaDest-62" class="title">Read-only live bindings</h3>
    <p class="normal">Another fundamental <a id="_idIndexMarker156"/>characteristic of ES modules, which helps with cyclic dependencies, is the idea that imported modules are effectively <em class="italic">read-only live bindings</em> to their exported values.</p>
    <p class="normal">Let's clarify what this means with a simple example:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// counter.js</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">increment</span><span class="hljs-function"> () </span>{
  count++
}
</code></pre>
    <p class="normal">This module exports two values: a simple integer counter called <code class="Code-In-Text--PACKT-">count</code> and an <code class="Code-In-Text--PACKT-">increment</code> function that increases the counter by one.</p>
    <p class="normal">Let's now write some code that uses this module:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> { count, increment } <span class="hljs-keyword">from</span> <span class="hljs-string">'./counter.js'</span>
<span class="hljs-built_in">console</span>.log(count) <span class="hljs-comment">// prints 0</span>
increment()
<span class="hljs-built_in">console</span>.log(count) <span class="hljs-comment">// prints 1</span>
count++ <span class="hljs-comment">// TypeError: Assignment to constant variable!</span>
</code></pre>
    <p class="normal">What we can see in this code is that we can read the value of <code class="Code-In-Text--PACKT-">count</code> at any time and change it using the <code class="Code-In-Text--PACKT-">increment()</code> function, but as soon as we try to mutate the <code class="Code-In-Text--PACKT-">count</code> variable directly, we get an error as if we were trying to mutate a <code class="Code-In-Text--PACKT-">const</code> binding.</p>
    <p class="normal">This proves that when an entity is imported in the scope, the binding to its original value cannot be changed (<em class="italic">read-only binding</em>) unless the bound value changes within the scope of the original module itself (<em class="italic">live binding</em>), which is outside the direct control of the consumer code.</p>
    <p class="normal">This approach is fundamentally different from CommonJS. In fact, in CommonJS, the entire <code class="Code-In-Text--PACKT-">exports</code> object is <a id="_idIndexMarker157"/>copied (shallow copy) when required from a module. This means that, if the value of primitive variables like numbers or string is changed at a later time, the requiring module won't be able to see those changes.</p>
    <h3 id="_idParaDest-63" class="title">Circular dependency resolution</h3>
    <p class="normal">Now to close the circle, let's reimplement <a id="_idIndexMarker158"/>the circular dependency example we saw in the <em class="italic">CommonJS modules</em> section using the ESM syntax:</p>
    <figure class="mediaobject"><img src="../Images/B15729_02_03.png" alt="02%20The%20Module%20system%20-%20Images/circular-dependency-example.png"/></figure>
    <p class="packt_figref">Figure 2.3: An example scenario with circular dependencies</p>
    <p class="normal">Let's have a look at the modules <code class="Code-In-Text--PACKT-">a.js</code> and <code class="Code-In-Text--PACKT-">b.js</code> first:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// a.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> bModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./b.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> loaded = <span class="hljs-literal">false</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> b = bModule
loaded = <span class="hljs-literal">true</span>
<span class="hljs-comment">// b.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> aModule <span class="hljs-keyword">from</span> <span class="hljs-string">'./a.js'</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> loaded = <span class="hljs-literal">false</span>
<span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = aModule
loaded = <span class="hljs-literal">true</span>
</code></pre>
    <p class="normal">And now let's see how to import those two modules in our <code class="Code-In-Text--PACKT-">main.js</code> file (the entry point):</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> a <span class="hljs-keyword">from</span> <span class="hljs-string">'./a.js'</span>
<span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> b <span class="hljs-keyword">from</span> <span class="hljs-string">'./b.js'</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'a -&gt;'</span>, a)
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'b -&gt;'</span>, b)
</code></pre>
    <p class="normal">Note that this time we are not using <code class="Code-In-Text--PACKT-">JSON.stringify</code> because that will fail with a <code class="Code-In-Text--PACKT-">TypeError: Converting circular structure to JSON</code>, since there's an actual circular reference between <code class="Code-In-Text--PACKT-">a.js</code> and <code class="Code-In-Text--PACKT-">b.js</code>.</p>
    <p class="normal">When we run <code class="Code-In-Text--PACKT-">main.js</code>, we will see the following output:</p>
    <pre class="programlisting con"><code class="hljs-con">a -&gt; &lt;ref *1&gt; [Module] {
  b: [Module] { a: [Circular *1], loaded: true },
  loaded: true
}
b -&gt; &lt;ref *1&gt; [Module] {
  a: [Module] { b: [Circular *1], loaded: true },
  loaded: true
}
</code></pre>
    <p class="normal">The interesting bit here is that the modules <code class="Code-In-Text--PACKT-">a.js</code> and <code class="Code-In-Text--PACKT-">b.js</code> have a complete picture of each other, unlike what would happen with CommonJS, where they would only hold partial information of each other. We can see that <a id="_idIndexMarker159"/>because all the <code class="Code-In-Text--PACKT-">loaded</code> values are set to <code class="Code-In-Text--PACKT-">true</code>. Also, <code class="Code-In-Text--PACKT-">b</code> within <code class="Code-In-Text--PACKT-">a</code> is an actual reference to the same <code class="Code-In-Text--PACKT-">b</code> instance available in the current scope, and the same goes for <code class="Code-In-Text--PACKT-">a</code> within <code class="Code-In-Text--PACKT-">b</code>. That's the reason why we cannot use <code class="Code-In-Text--PACKT-">JSON.stringify()</code> to serialize these modules. Finally, if we swap the order of the imports for the modules <code class="Code-In-Text--PACKT-">a.js</code> and <code class="Code-In-Text--PACKT-">b.js</code>, the final outcome does not change, which is another important difference in comparison with how CommonJS works</p>
    <p class="normal">It's worth spending some more time observing what happens in the three phases of the module resolution (parsing, instantiation, and evaluation) for this specific example.</p>
    <h4 class="title">Phase 1: Parsing</h4>
    <p class="normal">During the parsing phase, the code is explored starting from the entry point (<code class="Code-In-Text--PACKT-">main.js</code>). The interpreter <a id="_idIndexMarker160"/>looks only for <code class="Code-In-Text--PACKT-">import</code> statements to find all the necessary modules and to load the source code from the module files. The dependency graph is explored in a depth-first fashion, and every module is visited only once. This way the interpreter builds a view of the dependencies that looks like a tree structure, as shown in <em class="italic">Figure 2.4</em>:</p>
    <figure class="mediaobject"><img src="../Images/B15729_02_04.png" alt="02%20The%20Module%20system%20-%20Images/esm-circular-dependency-parsing-steps.png"/></figure>
    <p class="packt_figref">Figure 2.4: Parsing of cyclic dependencies with ESM</p>
    <p class="normal">Given the example in <em class="italic">Figure 2.4</em>, let's discuss the various steps of the parsing phase:</p>
    <ol>
      <li class="numbered">From <code class="Code-In-Text--PACKT-">main.js</code>, the first import found leads us straight into <code class="Code-In-Text--PACKT-">a.js</code>.</li>
      <li class="numbered">In <code class="Code-In-Text--PACKT-">a.js</code> we find an import pointing to <code class="Code-In-Text--PACKT-">b.js</code>.</li>
      <li class="numbered">In <code class="Code-In-Text--PACKT-">b.js</code>, we also have an import back to <code class="Code-In-Text--PACKT-">a.js</code> (our cycle), but since <code class="Code-In-Text--PACKT-">a.js</code> has already been visited, this path is not explored again.</li>
      <li class="numbered">At this point, the <a id="_idIndexMarker161"/>exploration starts to wind back: <code class="Code-In-Text--PACKT-">b.js</code> doesn't have other imports, so we go back to <code class="Code-In-Text--PACKT-">a.js</code>; <code class="Code-In-Text--PACKT-">a.js</code> doesn't have other <code class="Code-In-Text--PACKT-">import</code> statements so we go back to <code class="Code-In-Text--PACKT-">main.js</code>. Here we find another import pointing to <code class="Code-In-Text--PACKT-">b.js</code>, but again this module has been explored already, so this path is ignored.</li>
    </ol>
    <p class="normal">At this point, our depth-first visit of the dependency graph has been completed and we have a linear view of the modules, as shown in <em class="italic">Figure 2.5</em>:</p>
    <figure class="mediaobject"><img src="../Images/B15729_02_05.png" alt="02%20The%20Module%20system%20-%20Images/esm-circular-dependency-parsing-result.png"/></figure>
    <p class="packt_figref">Figure 2.5: A linear view of the module graph where cycles have been removed</p>
    <p class="normal">This particular view is <a id="_idIndexMarker162"/>quite simple. In more realistic scenarios with a lot more modules, the view will look more like a tree structure.</p>
    <h4 class="title">Phase 2: Instantiation</h4>
    <p class="normal">In the instantiation phase, the interpreter walks the tree view obtained from the previous phase from the bottom to the top. For every <a id="_idIndexMarker163"/>module, the interpreter will look for all the exported properties first and build out a map of the exported names in memory:</p>
    <figure class="mediaobject"><img src="../Images/B15729_02_06.png" alt="02%20The%20Module%20system%20-%20Images/esm-circular-dependencies-instantiation-link-exports.png"/></figure>
    <p class="packt_figref">Figure 2.6: A visual representation of the instantiation phase</p>
    <p class="normal"><em class="italic">Figure 2.6</em> describes the order in which every module is instantiated:</p>
    <ol>
      <li class="numbered">The interpreter starts from <code class="Code-In-Text--PACKT-">b.js</code> and discovers that the module exports <code class="Code-In-Text--PACKT-">loaded</code> and <code class="Code-In-Text--PACKT-">a</code>.</li>
      <li class="numbered">Then, the interpreter moves to <code class="Code-In-Text--PACKT-">a.js</code>, which exports <code class="Code-In-Text--PACKT-">loaded</code> and <code class="Code-In-Text--PACKT-">b</code>.</li>
      <li class="numbered">Finally, it moves to <code class="Code-In-Text--PACKT-">main.js</code>, which does not export any functionality.</li>
      <li class="numbered">Note that, in this phase, the <a id="_idIndexMarker164"/>exports map keeps track of the exported names only; their associated values are considered uninitialized for now.</li>
    </ol>
    <p class="normal">After this sequence of steps, the interpreter will do another pass to link the exported names to the modules importing them, as shown in <em class="italic">Figure 2.7</em>:</p>
    <figure class="mediaobject"><img src="../Images/B15729_02_07.png" alt="02%20The%20Module%20system%20-%20Images/esm-circular-dependencies-instantiation-link-imports.png"/></figure>
    <p class="packt_figref">Figure 2.7: Linking exports with imports across modules</p>
    <p class="normal">We can describe what we see in <em class="italic">Figure 2.7</em> through the following steps:</p>
    <ol>
      <li class="numbered">Module <code class="Code-In-Text--PACKT-">b.js</code> will link the exports from <code class="Code-In-Text--PACKT-">a.js</code>, referring to them as <code class="Code-In-Text--PACKT-">aModule</code>.</li>
      <li class="numbered">In turn, <code class="Code-In-Text--PACKT-">a.js</code> will link to all the exports from <code class="Code-In-Text--PACKT-">b.js</code>, referring to them as <code class="Code-In-Text--PACKT-">bModule</code>.</li>
      <li class="numbered">Finally, <code class="Code-In-Text--PACKT-">main.js</code> will import all the exports in <code class="Code-In-Text--PACKT-">b.js</code>, referring to them as <code class="Code-In-Text--PACKT-">b</code>; similarly, it will import everything from <code class="Code-In-Text--PACKT-">a.js</code>, referring to them as <code class="Code-In-Text--PACKT-">a</code>.</li>
      <li class="numbered">Again, it's important to note that all the values are still uninitialized. In this phase, we are only linking references to values that will be available at the end of the next phase.</li>
    </ol>
    <h4 class="title">Phase 3: Evaluation</h4>
    <p class="normal">The last step is the evaluation phase. In this phase, all the code in every file is finally executed. The execution <a id="_idIndexMarker165"/>order is again bottom-up respecting the post-order depth-first visit of our original dependency graph. With this approach, <code class="Code-In-Text--PACKT-">main.js</code> is the last file to be executed. This way, we can be sure that all the exported values have been initialized before we start executing our main business logic:</p>
    <figure class="mediaobject"><img src="../Images/B15729_02_08.png" alt="02%20The%20Module%20system%20-%20Images/esm-circular-dependency-evaluation.png"/></figure>
    <p class="packt_figref">Figure 2.8: A visual representation of the evaluation phase</p>
    <p class="normal">Following along from the diagram in <em class="italic">Figure 2.8</em>, this is what happens:</p>
    <ol>
      <li class="numbered">The execution starts from <code class="Code-In-Text--PACKT-">b.js</code> and the first line to be evaluated initializes the <code class="Code-In-Text--PACKT-">loaded</code> export to <code class="Code-In-Text--PACKT-">false</code> for the module.</li>
      <li class="numbered">Similarly, here the exported property <code class="Code-In-Text--PACKT-">a</code> gets evaluated. This time, it will be evaluated to a reference to the module object representing module <code class="Code-In-Text--PACKT-">a.js</code>.</li>
      <li class="numbered">The value of the <code class="Code-In-Text--PACKT-">loaded</code> property gets changed to <code class="Code-In-Text--PACKT-">true</code>. At this point, we have fully evaluated the state of the exports for module <code class="Code-In-Text--PACKT-">b.js</code>.</li>
      <li class="numbered">Now the execution moves to <code class="Code-In-Text--PACKT-">a.js</code>. Again, we start by setting <code class="Code-In-Text--PACKT-">loaded</code> to <code class="Code-In-Text--PACKT-">false</code>.</li>
      <li class="numbered">At this point, the <code class="Code-In-Text--PACKT-">b</code> export is evaluated to a reference to module <code class="Code-In-Text--PACKT-">b.js</code>.</li>
      <li class="numbered">Finally, the <code class="Code-In-Text--PACKT-">loaded</code> property is changed to <code class="Code-In-Text--PACKT-">true</code>. Now we have finally evaluated all the exports for <code class="Code-In-Text--PACKT-">a.js</code> as well.</li>
    </ol>
    <p class="normal">After all these steps, the code in <code class="Code-In-Text--PACKT-">main.js</code> can be executed, and at this point, all the exported properties are fully evaluated. Since imported modules are tracked as references, we can be sure every module has an up-to-date picture of the other modules, even in the presence of circular dependencies.</p>
    <h2 id="_idParaDest-64" class="title">Modifying other modules</h2>
    <p class="normal">We saw that entities imported through ES modules are <em class="italic">read-only live bindings</em>, and therefore we cannot reassign them from an external module.</p>
    <p class="normal">There's a caveat, though. It is true that we can't change the bindings of the default export or named exports of <a id="_idIndexMarker166"/>an existing module from another module, but, if one of these bindings is an object, we can still mutate the object itself by reassigning some of the object properties.</p>
    <p class="normal">This caveat can give us enough freedom to alter the behavior of other modules. To demonstrate this idea, let's write a module that can alter the behavior of the core <code class="Code-In-Text--PACKT-">fs</code> module so that it prevents the module from accessing the filesystem and returns mocked data instead. This kind of module is something that could be useful while writing tests for a component that relies on the filesystem:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// mock-read-file.js</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>                                        <span class="hljs-comment">// (1)</span>
<span class="hljs-keyword">const</span> originalReadFile = fs.readFile                       <span class="hljs-comment">// (2)</span>
<span class="hljs-keyword">let</span> mockedResponse = <span class="hljs-literal">null</span>
<span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">mockedReadFile</span><span class="hljs-function"> (</span><span class="hljs-params">path, cb</span><span class="hljs-function">) </span>{                       <span class="hljs-comment">// (3)</span>
  setImmediate(<span class="hljs-function">() =&gt;</span> {
    cb(<span class="hljs-literal">null</span>, mockedResponse)
  })
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">mockEnable</span><span class="hljs-function"> (</span><span class="hljs-params">respondWith</span><span class="hljs-function">) </span>{                 <span class="hljs-comment">// (4)</span>
  mockedResponse = respondWith
  fs.readFile = mockedReadFile
}
<span class="hljs-keyword">export</span> <span class="hljs-keyword">function</span><span class="hljs-function"> </span><span class="hljs-title">mockDisable</span><span class="hljs-function"> () </span>{                           <span class="hljs-comment">// (5)</span>
  fs.readFile = originalReadFile
}
</code></pre>
    <p class="normal">Let's review the preceding code:</p>
    <ol>
      <li class="numbered">The first thing we do is import the default export of the <code class="Code-In-Text--PACKT-">fs</code> module. We will get back to this in a second, for now, just keep in mind that the default export of the <code class="Code-In-Text--PACKT-">fs</code> module is an object that contains a collection of functions that allows us to interact with the filesystem.</li>
      <li class="numbered">We want to replace the <code class="Code-In-Text--PACKT-">readFile()</code> function with a mock implementation. Before doing that, we <a id="_idIndexMarker167"/>save a reference to the original implementation. We also declare a <code class="Code-In-Text--PACKT-">mockedResponse</code> value that we will be using later.</li>
      <li class="numbered">The function <code class="Code-In-Text--PACKT-">mockedReadFile()</code> is the actual mocked implementation that we want to use to replace the original implementation. This function invokes the callback with the current value of <code class="Code-In-Text--PACKT-">mockedResponse</code>. Note that this is a simplified implementation; the real function accepts an optional <code class="Code-In-Text--PACKT-">options</code> argument before the callback argument and is able to handle different types of encoding.</li>
      <li class="numbered">The exported <code class="Code-In-Text--PACKT-">mockEnable()</code> function can be used to activate the mocked functionality. The original implementation will be swapped with the mocked one. The mocked implementation will return the same value passed here through the <code class="Code-In-Text--PACKT-">respondWith</code> argument.</li>
      <li class="numbered">Finally, the exported <code class="Code-In-Text--PACKT-">mockDisable()</code> function can be used to restore the original implementation of the <code class="Code-In-Text--PACKT-">fs.readFile()</code> function.</li>
    </ol>
    <p class="normal">Now let's see a simple example that uses this module:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// main.js</span>
<span class="hljs-keyword">import</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>                                          <span class="hljs-comment">// (1)</span>
<span class="hljs-keyword">import</span> { mockEnable, mockDisable } <span class="hljs-keyword">from</span> <span class="hljs-string">'./mock-read-file.js'</span>
mockEnable(Buffer.from(<span class="hljs-string">'Hello World'</span>))                       <span class="hljs-comment">// (2)</span>
fs.readFile(<span class="hljs-string">'fake-path'</span>, <span class="hljs-function">(</span><span class="hljs-params">err, data</span><span class="hljs-function">) =&gt;</span> {                    <span class="hljs-comment">// (3)</span>
  <span class="hljs-keyword">if</span> (err) {
    <span class="hljs-built_in">console</span>.error(err)
    process.exit(<span class="hljs-number">1</span>)
  }
  <span class="hljs-built_in">console</span>.log(data.toString()) <span class="hljs-comment">// 'Hello World'</span>
})
mockDisable()
</code></pre>
    <p class="normal">Let's discuss step by step what happens in this example:</p>
    <ol>
      <li class="numbered">The first thing that we do is import the default export of the <code class="Code-In-Text--PACKT-">fs</code> module. Again, note that we are importing specifically the default export exactly as we did in our <code class="Code-In-Text--PACKT-">mock-read-file.js</code> module, but more on this later.</li>
      <li class="numbered">Here we enable the mock functionality. We want, for every file read, to simulate that the file contains the string "Hello World."</li>
      <li class="numbered">Finally, we read a file using a fake path. This code will print "Hello World" as it will be using the mocked <a id="_idIndexMarker168"/>version of the <code class="Code-In-Text--PACKT-">readFile()</code> function. Note that, after calling this function, we restore the original implementation by calling <code class="Code-In-Text--PACKT-">mockDisable()</code>.</li>
    </ol>
    <p class="normal">This approach works, but it is very fragile. In fact, there are a number of ways in which this may not work.</p>
    <p class="normal">On the <code class="Code-In-Text--PACKT-">mock-read-file.js</code> side, we could have tried the two following imports for the <code class="Code-In-Text--PACKT-">fs</code> module:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> fs <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span> <span class="hljs-comment">// then use fs.readFile</span>
</code></pre>
    <p class="normal">or</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { readFile } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>
</code></pre>
    <p class="normal">Both of them are valid imports because the <code class="Code-In-Text--PACKT-">fs</code> module exports all the filesystem functions as named exports (other than a default export which is an object with the same collection of functions as attributes).</p>
    <p class="normal">There are certain issues with the preceding two <code class="Code-In-Text--PACKT-">import</code> statements:</p>
    <ul>
      <li class="Bullet--PACKT-">We would get a read-only live binding into the <code class="Code-In-Text--PACKT-">readFile()</code> function, and therefore, we would be unable to mutate it from an external module. If we try these approaches, we will get an error when trying to reassign <code class="Code-In-Text--PACKT-">readFile()</code>.</li>
      <li class="Bullet-End--PACKT-">Another issue is on the consumer side within our <code class="Code-In-Text--PACKT-">main.js</code>, where we could use these two alternative import styles as well. In this case, we won't end up using the mocked functionality, and therefore the code will trigger an error while trying to read a nonexistent file.</li>
    </ul>
    <p class="normal">The reason why using one of the two <code class="Code-In-Text--PACKT-">import</code> statements mentioned above would not work is because our mocking utility is altering only the copy of the <code class="Code-In-Text--PACKT-">readFile()</code> function that is registered inside the object exported as the default export, but not the one available as a named export at the top level of the module.</p>
    <p class="normal">This particular example shows us <a id="_idIndexMarker169"/>how monkey patching could be much more complicated and unreliable in the context of ESM. For this reason, testing frameworks <a id="_idIndexMarker170"/>such as Jest (<a href="http://nodejsdp.link/jest"><span class="url">nodejsdp.link/jest</span></a>) provide special functionalities to be able to mock ES modules more reliably (<a href="http://nodejsdp.link/jest-mock"><span class="url">nodejsdp.link/jest-mock</span></a>).</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Another approach that can be used to mock modules is to rely on the hooks available in a special Node.js core <a id="_idIndexMarker171"/>module called <code class="Code-In-Text--PACKT-">module</code> (<a href="http://nodejsdp.link/module-doc"><span class="url">nodejsdp.link/module-doc</span></a>). One simple library that takes advantage of this module is <code class="Code-In-Text--PACKT-">mocku</code> (<a href="http://nodejsdp.link/mocku"><span class="url">nodejsdp.link/mocku</span></a>). Check <a id="_idIndexMarker172"/>out its source code if you are curious.</p>
    </div>
    <p class="normal">We could also use the <code class="Code-In-Text--PACKT-">syncBuiltinESMExports()</code> function from the <code class="Code-In-Text--PACKT-">module</code> package. When this function is invoked, the value of the properties in the default exports object gets mapped again into the equivalent named exports, effectively allowing us to propagate any external change applied to the module functionality even to named exports:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> fs, { readFileSync } <span class="hljs-keyword">from</span> <span class="hljs-string">'fs'</span>
<span class="hljs-keyword">import</span> { syncBuiltinESMExports } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>
fs.readFileSync = <span class="hljs-function">() =&gt;</span> Buffer.from(<span class="hljs-string">'Hello, ESM'</span>)
syncBuiltinESMExports()
<span class="hljs-built_in">console</span>.log(fs.readFileSync === readFileSync) <span class="hljs-comment">// true</span>
</code></pre>
    <p class="normal">We could use this to make our small filesystem mocking utility a little bit more flexible by invoking the <code class="Code-In-Text--PACKT-">syncBuiltinESMExports()</code> function after we enable the mock or after we restore the original functionality.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">Note that <code class="Code-In-Text--PACKT-">syncBuiltinESMExports()</code> works only for built-in Node.js modules like the <code class="Code-In-Text--PACKT-">fs</code> module in our example.</p>
    </div>
    <p class="normal">This concludes our exploration of ESM. At this point, we should be able to appreciate how ESM works, how it loads modules, and how it deals with cyclic dependencies. To close this chapter, we are now ready to discuss some key differences and some interesting interoperability techniques between CommonJS and ECMAScript modules.</p>
    <h1 id="_idParaDest-65" class="title">ESM and CommonJS differences and interoperability</h1>
    <p class="normal">We already mentioned several important differences between ESM and CommonJS, such as having to <a id="_idIndexMarker173"/>explicitly specify file extensions in imports with ESM, while file extensions are totally optional with the CommonJS <code class="Code-In-Text--PACKT-">require</code> function.</p>
    <p class="normal">Let's close this chapter by <a id="_idIndexMarker174"/>discussing some other important differences between ESM and CommonJS and how the two module systems can work together when necessary.</p>
    <h2 id="_idParaDest-66" class="title">ESM runs in strict mode</h2>
    <p class="normal">ES modules run implicitly in strict mode. This means that we don't have to explicitly add the <code class="Code-In-Text--PACKT-">"use strict"</code> statements <a id="_idIndexMarker175"/>at the beginning of every file. Strict mode cannot be disabled; therefore, we cannot use undeclared variables or the <code class="Code-In-Text--PACKT-">with</code> statement or have other features that are only available in non-strict mode, but this is definitely a good thing, as strict mode is a safer execution mode.</p>
    <div class="packt_tip">
      <p class="Tip--PACKT-">If you are curious to find out more about the differences between the two modes, you can check out a very detailed article on MDN Web Docs (<a href="https://nodejsdp.link/strict-mode"><span class="url">https://nodejsdp.link/strict-mode</span></a>).</p>
    </div>
    <h2 id="_idParaDest-67" class="title">Missing references in ESM</h2>
    <p class="normal">In ESM, some important CommonJS references are not defined. These include <code class="Code-In-Text--PACKT-">require</code>, <code class="Code-In-Text--PACKT-">exports</code>, <code class="Code-In-Text--PACKT-">module.exports</code>, <code class="Code-In-Text--PACKT-">__filename</code>, and <code class="Code-In-Text--PACKT-">__dirname</code>. If we try to use any of them within an ES module, since it <a id="_idIndexMarker176"/>also runs in strict mode, we will get a <code class="Code-In-Text--PACKT-">ReferenceError</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">exports</span>) <span class="hljs-comment">// ReferenceError: exports is not defined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">module</span>) <span class="hljs-comment">// ReferenceError: module is not defined</span>
<span class="hljs-built_in">console</span>.log(__filename) <span class="hljs-comment">// ReferenceError: __filename is not defined</span>
<span class="hljs-built_in">console</span>.log(__dirname) <span class="hljs-comment">// ReferenceError: __dirname is not defined</span>
</code></pre>
    <p class="normal">We already discussed at length the meaning of <code class="Code-In-Text--PACKT-">exports</code> and <code class="Code-In-Text--PACKT-">module</code> in CommonJS; <code class="Code-In-Text--PACKT-">__filename</code> and <code class="Code-In-Text--PACKT-">__dirname</code> represent the absolute path to the current module file and the absolute path to its parent folder. Those special variables can be very useful when we need to build a path relative to the current file.</p>
    <p class="normal">In ESM, it is possible to get a reference to the current file URL by using the special object <code class="Code-In-Text--PACKT-">import.meta</code>. Specifically, <code class="Code-In-Text--PACKT-">import.meta.url</code> is a reference to the current module file in a format similar to <code class="Code-In-Text--PACKT-">file:///path/to/current_module.js</code>. This value can be used to reconstruct <code class="Code-In-Text--PACKT-">__filename</code> and <code class="Code-In-Text--PACKT-">__dirname</code> in the form of absolute paths:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { fileURLToPath } <span class="hljs-keyword">from</span> <span class="hljs-string">'url'</span>
<span class="hljs-keyword">import</span> { dirname } <span class="hljs-keyword">from</span> <span class="hljs-string">'path'</span>
<span class="hljs-keyword">const</span> __filename = fileURLToPath(<span class="hljs-keyword">import</span>.meta.url)
<span class="hljs-keyword">const</span> __dirname = dirname(__filename)
</code></pre>
    <p class="normal">It is also possible to recreate the <code class="Code-In-Text--PACKT-">require()</code> function as follows:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { createRequire } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">require</span> = createRequire(<span class="hljs-keyword">import</span>.meta.url)
</code></pre>
    <p class="normal">Now we can use <code class="Code-In-Text--PACKT-">require()</code> to import <a id="_idIndexMarker177"/>functionality coming from CommonJS modules in the context of ES modules.</p>
    <p class="normal">Another interesting difference is the behavior of the <code class="Code-In-Text--PACKT-">this</code> keyword.</p>
    <p class="normal">In the global scope of an ES module, <code class="Code-In-Text--PACKT-">this</code> is <code class="Code-In-Text--PACKT-">undefined</code>, while in CommonJS, <code class="Code-In-Text--PACKT-">this</code> is a reference to <code class="Code-In-Text--PACKT-">exports</code>:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-comment">// this.js - ESM</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span>) <span class="hljs-comment">// undefined</span>
<span class="hljs-comment">// this.cjs – CommonJS</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">this</span> === <span class="hljs-built_in">exports</span>) <span class="hljs-comment">// true</span>
</code></pre>
    <h2 id="_idParaDest-68" class="title">Interoperability</h2>
    <p class="normal">We discussed in the previous section how to import CommonJS modules in ESM by using the <code class="Code-In-Text--PACKT-">module.createRequire</code> function. It is <a id="_idIndexMarker178"/>also possible to import CommonJS modules from ESM by using the standard <code class="Code-In-Text--PACKT-">import</code> syntax. This is only limited to default exports, though:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> packageMain <span class="hljs-keyword">from</span> <span class="hljs-string">'commonjs-package'</span> <span class="hljs-comment">// Works</span>
<span class="hljs-keyword">import</span> { method } <span class="hljs-keyword">from</span> <span class="hljs-string">'commonjs-package'</span>  <span class="hljs-comment">// Errors</span>
</code></pre>
    <p class="normal">Unfortunately, it is not possible to import ES modules from CommonJS modules.</p>
    <p class="normal">Also, ESM cannot import JSON files directly as modules, a feature that is used quite frequently with CommonJS. The following <code class="Code-In-Text--PACKT-">import</code> statement will fail:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> data <span class="hljs-keyword">from</span> <span class="hljs-string">'./data.json'</span>
</code></pre>
    <p class="normal">It will produce a <code class="Code-In-Text--PACKT-">TypeError</code> (<code class="Code-In-Text--PACKT-">Unknown file extension: .json</code>).</p>
    <p class="normal">To overcome this limitation, we can use again the <code class="Code-In-Text--PACKT-">module.createRequire</code> utility:</p>
    <pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword">import</span> { createRequire } <span class="hljs-keyword">from</span> <span class="hljs-string">'module'</span>
<span class="hljs-keyword">const</span> <span class="hljs-built_in">require</span> = createRequire(<span class="hljs-keyword">import</span>.meta.url)
<span class="hljs-keyword">const</span> data = <span class="hljs-built_in">require</span>(<span class="hljs-string">'./data.json'</span>)
<span class="hljs-built_in">console</span>.log(data)
</code></pre>
    <p class="normal">There is ongoing work to <a id="_idIndexMarker179"/>support JSON modules natively even in ESM, so we may not need to rely on <code class="Code-In-Text--PACKT-">createRequire()</code> in the near future for this functionality.</p>
    <h1 id="_idParaDest-69" class="title">Summary</h1>
    <p class="normal">In this chapter, we explored in depth what modules are, why they are useful, and why we need a module system. We also learned about the history of modules in JavaScript and about the two module systems available today in Node.js, namely CommonJS and ESM. We also explored some common patterns that are useful when creating modules or when using third-party modules.</p>
    <p class="normal">You should now be comfortable with understanding and writing code that takes advantage of the features of both CommonJS and ESM.</p>
    <p class="normal">In the rest of the book, we will rely mostly on ES modules, but you should now be equipped to be flexible with your choices and be able to deal with CommonJS effectively if necessary.</p>
    <p class="normal">In the next chapter, we will start to explore the idea of asynchronous programming with JavaScript, and we will examine callbacks, events, and their patterns in depth.</p>
  </div>
</body></html>