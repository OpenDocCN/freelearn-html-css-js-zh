<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;7.&#xA0;Ember Models and Ember Data" id="1O8H61-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07" class="calibre1"/>Chapter 7. Ember Models and Ember Data</h1></div></div></div><p class="calibre8">In this chapter, you'll learn the following recipes:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Understanding the functionalities of Ember Data</li><li class="listitem">Creating, reading, updating, and deleting records with Ember Data</li><li class="listitem">Using fixtures</li><li class="listitem">Customizing the adapter and serializer</li><li class="listitem">Working with relationships</li></ul></div></div>

<div class="book" title="Chapter&#xA0;7.&#xA0;Ember Models and Ember Data" id="1O8H61-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="Introduction"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch07lvl1sec53" class="calibre1"/>Introduction</h1></div></div></div><p class="calibre8">Models are objects in Ember that represent data that can be displayed to users. They are persistent and won't be lost when the user closes the browser window.</p><p class="calibre8">Many models are <a id="id318" class="calibre1"/>loaded from data that is stored in a server from a database. Typically, the data is sent back and forth as a JSON representation. This is where Ember Data comes in. Ember Data is included by default when you create an application in Ember. It helps retrieve data, store data locally, and save information to the server.</p><p class="calibre8">Ember Data can be configured to work with many different types of databases and servers. If used properly, Ember Data can help manage your application models without the use of multiple Ajax requests throughout your application.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Understanding the functionalities of Ember Data"><div class="book" id="1P71O2-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec54" class="calibre1"/>Understanding the functionalities of Ember Data</h1></div></div></div><p class="calibre8">Ember <a id="id319" class="calibre1"/>Data uses a single data store that can be accessed throughout an application. In this example, we'll create a simple application that retrieves a list of books and displays it to the user.</p></div>

<div class="book" title="Understanding the functionalities of Ember Data">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec95" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Before we begin, we'll need to mock data for our server. Ember CLI has a built-in mock server that can handle this <a id="id320" class="calibre1"/>situation by generating a basic <span class="strong"><strong class="calibre9">Express server</strong></span>. However, for the purposes of this recipe, we'll go ahead and use the Ember CLI Mirage add-on. It has more features and is easier to use. You can find more information about Ember <a id="id321" class="calibre1"/>CLI Mirage at <a class="calibre1" href="https://github.com/samselikoff/ember-cli-mirage">https://github.com/samselikoff/ember-cli-mirage</a>.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">To begin, let's <a id="id322" class="calibre1"/>create a new application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember new BookExample</strong></span>
</pre></div></li><li class="listitem" value="2">After the application has been created, let's install the add-on:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ cd BookExample</strong></span>
<span class="strong"><strong class="calibre9">$ ember install ember-cli-mirage</strong></span>
<span class="strong"><strong class="calibre9">$ ember g factory book</strong></span>
</pre></div><p class="calibre14">This will install the latest Bower and <code class="email">npm</code> packages needed and create the <code class="email">book</code> factory for Mirage.</p><p class="calibre14">To make this recipe work, we'll need to mock book data.</p></li><li class="listitem" value="3">Edit the <code class="email">config.js</code> file in the <code class="email">app/mirage</code> folder:<div class="informalexample"><pre class="programlisting">// app/mirage/config.js
export default function() {

    this.get('/books');
    this.get('/books/:id');
}</pre></div><p class="calibre14">This configuration file will set the fake routes that we need for our data. The <code class="email">/books</code> route will return all the book data and the <code class="email">/books/:id</code> route will return individual books based on the ID passed in the URL.</p></li><li class="listitem" value="4">Update the <code class="email">book.js</code> file in the <code class="email">app/mirage/factories</code> folder. Add the following properties:<div class="informalexample"><pre class="programlisting">// app/mirage/factories/book.js
import Mirage, {faker}  from 'ember-cli-mirage';

export default Mirage.Factory.extend({

    title: faker.lorem.sentence,  // using faker
    author() {return faker.name.findName(); },
    year: faker.date.past
});</pre></div><p class="calibre14">This file sets the properties that we'll use later for our model. The <code class="email">title</code> property refers to the name of the book, <code class="email">author</code> refers to the person who wrote the book, and <code class="email">year</code> is the year it was published. To make things a little easier, Ember CLI Mirage includes a library called <code class="email">faker</code>. This library generates data that we can use to populate our in-memory data store.</p></li><li class="listitem" value="5">Update <a id="id323" class="calibre1"/>the <code class="email">default.js</code> file in the <code class="email">app/mirage/scenarios</code> folder:<div class="informalexample"><pre class="programlisting">export default function( server ) {

    server.createList('book',10);
}</pre></div><p class="calibre14">Make sure to delete the comments around <code class="email">server</code>. This scenario will generate ten new <code class="email">'book'</code> records every time the browser is loaded. After the browser is loaded, the books will be generated via the factory.</p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Understanding the functionalities of Ember Data">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec96" class="calibre1"/>How to do it...</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Begin by creating a model file for our books, a REST adapter, and a route:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g model book title:string author:string year:date</strong></span>
<span class="strong"><strong class="calibre9">$ ember g adapter application</strong></span>
<span class="strong"><strong class="calibre9">$ ember g route books</strong></span>
<span class="strong"><strong class="calibre9">$ ember g route application</strong></span>
</pre></div><p class="calibre14">This command will generate a new model called <code class="email">book</code>, and set the <code class="email">title</code>, <code class="email">author</code>, and <code class="email">year</code> as properties in this model. The generate <code class="email">adapter</code> command will create a new adapter for our application, while the last commands will generate routes for the <code class="email">book</code> and <code class="email">application</code>.</p></li><li class="listitem" value="2">Open the <code class="email">book.js</code> file in the <code class="email">app/models</code> folder. It should look as follows:<div class="informalexample"><pre class="programlisting">// app/models/book.js
import DS from 'ember-data';

export default DS.Model.extend({
    title: DS.attr('string'),
    author: DS.attr('string'),
    year: DS.attr('date')
});</pre></div><p class="calibre14">The <code class="email">models</code> file is a representation of the data that we'll be using. We can use three different types of data: <code class="email">string</code>, <code class="email">number</code>, or <code class="email">date</code>. This data will be loaded from our mock server.</p></li><li class="listitem" value="3">Open the <code class="email">application.js</code> file created in the <code class="email">app/adapters</code> folder:<div class="informalexample"><pre class="programlisting">// app/adapters/application.js
import DS from 'ember-data';

export default DS.RESTAdapter.extend({
});</pre></div><p class="calibre14">Ember <a id="id324" class="calibre1"/>Data has several adapters available for it. One of the easiest to use is the REST adapter.</p></li><li class="listitem" value="4"> The REST adapter data expects the data from the server in this format:<div class="informalexample"><pre class="programlisting">{
  "books": [
    {
      "id": 1,
      "title": "Some title",
      "author": "Authors name",
      "date": "1980-05-23"
    }
    {
      "id": 2,
      "title": "Some other title",
      "author": "Authors name 2",
      "date": "1985-05-23"

    }
  ]
}</pre></div><p class="calibre14">The preceding JSON lists an array of books. If, by chance, only one record was returned, the REST adapter would expect the array to be named <code class="email">book</code> and not <code class="email">books</code>. Keep in mind that you should camel-case all record names and the data should be in the REST adapter format.</p></li><li class="listitem" value="5">We'll need to be able to retrieve data from our data store and present it to the user. Edit the <code class="email">application.js</code> file in the <code class="email">app/routes</code> folder. Add a new model that returns all the books listed:<div class="informalexample"><pre class="programlisting">// app/routes/application.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(){
      return this.store.findAll('book');
    }
});</pre></div><p class="calibre14">As discussed in <a class="calibre1" title="Chapter 4. Ember Router" href="part0039_split_000.html#1565U1-d21a6ad8148a415181fa52c0043435bb">Chapter 4</a>, <span class="strong"><em class="calibre13">Ember Router</em></span>, one of the responsibilities of the route is returning the model data. The Ember Data store has a method called <code class="email">findAll</code> that will return all the data from the <code class="email">book</code> model. By convention, the Ember application will execute an HTTP GET to the <code class="email">/book/ URL</code> and expect a JSON payload in response. As this model is in the application route, it can be accessed in any template.</p></li><li class="listitem" value="6">Update the <a id="id325" class="calibre1"/><code class="email">application.hbs</code> file and display the new data from the mock server:<div class="informalexample"><pre class="programlisting">// app/templates/application.hbs
{{#link-to 'index'}}&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;{{/link-to}}

{{outlet}}

{{#each model as |book|}}
    &lt;br&gt;
    title: {{#link-to 'books' book.id}}{{book.title}}{{/link-to}}&lt;br&gt;
{{/each}}</pre></div><p class="calibre14">This template uses the <code class="email">each</code> helper to iterate though all the data that is returned from the <code class="email">model</code> hook after the page loads. The <code class="email">link-to</code> helper will pass <code class="email">book.id</code> in the URL as an argument. We'll use the book <code class="email">title</code> as the link.</p></li><li class="listitem" value="7">Update the books route so that it returns a single record:<div class="informalexample"><pre class="programlisting">// app/routes/books.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(params){
      return this.store.findRecord('book',params.book_id);
    }
});</pre></div><p class="calibre14">The <code class="email">model</code> hook receives a parameter from the URL. The <code class="email">findRecord</code> Ember Data can be used to find individual records. It will make an HTTP GET request to the <code class="email">/books/:id</code> URL when the <code class="email">model</code> hook is loaded. The first argument is the data store and the second is the record ID.</p></li><li class="listitem" value="8">Update <a id="id326" class="calibre1"/>the <code class="email">router.js</code> file in the <code class="email">app</code> folder with the new dynamic route for <code class="email">books</code>:<div class="informalexample"><pre class="programlisting">// app/router.js
import Ember from 'ember';
import config from './config/environment';

var Router = Ember.Router.extend({
    location: config.locationType
});

Router.map(function() {
    this.route('books', {path:'/books/:book_id'});
});

export default Router;</pre></div><p class="calibre14">This new route for <code class="email">books</code> has a path of <code class="email">/books/:book_id</code>. To access the <code class="email">books</code> route, you have to submit an ID in the path.</p></li><li class="listitem" value="9">Update the <code class="email">books.hbs</code> template:<div class="informalexample"><pre class="programlisting">// app/templates/books.hbs
{{outlet}}
&lt;br&gt;
&lt;b&gt;Author: {{model.author}}&lt;/b&gt;&lt;br&gt;
&lt;b&gt;Year: {{model.year}}&lt;/b&gt;
&lt;br&gt;</pre></div><p class="calibre14">Accessing this route will trigger the <code class="email">model</code> hook. This will render <code class="email">author</code> and <code class="email">year</code> of the book selected.</p></li><li class="listitem" value="10">Run <code class="email">ember server</code> and open a web browser. You'll see a list of all the titles with links to each individual book:<div class="mediaobject"><img src="../images/00038.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">Each post has a unique ID. Clicking on a link will display the title and author of that book.</p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Understanding the functionalities of Ember Data">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec97" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Models represent data in Ember. These models can use Ember Data to store, update, and retrieve data from a server. The data from the server is usually sent in the JSON format. Ember offers a <a id="id327" class="calibre1"/>handful of adapters to the interface with the data coming from the server. The REST adapter is the most commonly used. It expects data in a certain format so that Ember can parse, store, and display it to the user.</p><p class="calibre8">Ember Data caches the data after it retrieves the data from the server. This minimizes the amount of round-trips to the server. However, Ember Data will make a request in the background <a id="id328" class="calibre1"/>whenever a cached data record is returned from the store. If the data has changed, it will be rerendered on the screen.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Creating, reading, updating, and deleting records with Ember Data"><div class="book" id="1Q5IA2-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec55" class="calibre1"/>Creating, reading, updating, and deleting records with Ember Data</h1></div></div></div><p class="calibre8">In <a id="id329" class="calibre1"/>the previous recipe, we retrieved already existing <a id="id330" class="calibre1"/>book data from our mock server and displayed <a id="id331" class="calibre1"/>it to the user. Ember Data also has the ability to <a id="id332" class="calibre1"/>create, delete, and even update records from the data store. We will be looking at these methods and more.</p></div>

<div class="book" title="Creating, reading, updating, and deleting records with Ember Data">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec98" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">Just like the previous example, we'll need to install Ember CLI Mirage. Take a look at the previous recipe for instructions on this process. We'll be using the same factories as the book recipe and we'll be adding new methods to add, edit, and delete data.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In the <code class="email">mirage</code> folder, open the <code class="email">config.js</code> file:<div class="informalexample"><pre class="programlisting">// app/mirage/config.js
export default function() {

    this.get('/books');
    this.get('/books/:id');
    this.put('/books/:id');
    this.post('/books');
    this.delete('/books/:id');
}</pre></div><p class="calibre14">This will mock our backend and allow us to create, update, and delete data. This is done using the HTTP PUT, POST, and DELETE requests. We'll use this later in our program.</p></li><li class="listitem" value="2">Update the <code class="email">book.js</code> file in the <code class="email">app/mirage</code> folder:<div class="informalexample"><pre class="programlisting">// app/mirage/factories/book.js
import Mirage, {faker}  from 'ember-cli-mirage';

export default Mirage.Factory.extend({

   title: faker.lorem.sentence,  // using faker
   author() {return faker.name.findName(); },
   year: faker.date.past
});</pre></div><p class="calibre14">This <a id="id333" class="calibre1"/>factory will be used to generate fake <a id="id334" class="calibre1"/>data that the Mirage in-memory database <a id="id335" class="calibre1"/>will return.</p></li><li class="listitem" value="3">Update <a id="id336" class="calibre1"/>the <code class="email">default.js</code> file in the <code class="email">scenarios</code> folder:<div class="informalexample"><pre class="programlisting">// app/mirage/scenarios/default.js
export default function( server ) {

    server.createList('book',10);
}</pre></div><p class="calibre14">Every time that the application loads, the server will create <code class="email">10</code> <code class="email">book</code> objects.</p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Creating, reading, updating, and deleting records with Ember Data">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec99" class="calibre1"/>How to do it...</h2></div></div></div><p class="calibre8">For this recipe, we'll be adding to the book example that we had in the <span class="strong"><em class="calibre13">Understanding the functionalities of Ember</em></span> <span class="strong"><em class="calibre13">Data</em></span> recipe.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a route called <code class="email">new</code> and controller named <code class="email">books</code>:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g route new</strong></span>
<span class="strong"><strong class="calibre9">$ ember g controller books</strong></span>
<span class="strong"><strong class="calibre9">$ ember g controller new</strong></span>
<span class="strong"><strong class="calibre9">$ ember g controller application</strong></span>
</pre></div><p class="calibre14">This will generate the <code class="email">new</code> route and <code class="email">books</code> controller files.</p></li><li class="listitem" value="2">Create a new template for the new route:<div class="informalexample"><pre class="programlisting">// app/templates/new.hbs
{{outlet}}
&lt;b&gt;title: {{input value=info.title size='15'}}&lt;/b&gt;&lt;br&gt;
&lt;b&gt;Author: {{input value=info.author size='15'}}&lt;/b&gt;&lt;br&gt;
&lt;b&gt;Year: {{input value=info.year size='35'}}&lt;/b&gt;&lt;br&gt;
&lt;button {{action 'newText' }}&gt;Submit Changes&lt;/button&gt;
&lt;button {{action 'cancel' }}&gt;Cancel&lt;/button&gt;&lt;br&gt;</pre></div><p class="calibre14">The new route will be used to add a new book to the repository. In this template, the <code class="email">input</code> helper is used to create three textboxes. Each will be bound to the info property. A button at the bottom will submit the changes to the <code class="email">newText</code> <code class="email">action</code> method. The <code class="email">cancel</code> button will trigger the <code class="email">cancel</code> action.</p></li><li class="listitem" value="3">Update <a id="id337" class="calibre1"/>the <code class="email">new.js</code> controller with the new <a id="id338" class="calibre1"/><code class="email">actions</code> for <code class="email">cancel</code> and <code class="email">newText</code>:<div class="informalexample"><pre class="programlisting">// app/controllers/new.js
import Ember from 'ember';

export default Ember.Controller.extend({
    info: {},
    actions:{
      newText(){
        let inf = this.get('info');
        let newBook = this.store.createRecord('book',{
          title: inf.title,
          author: inf.author,
          year: new Date(inf.year)
        });

      newBook.save().then(()=&gt;{
        this.transitionToRoute('application');
        this.set('info',{});
      },()=&gt; {
        console.log('failed');
      });
      },
      cancel(){
        return true;
      }

    }
});</pre></div></li><li class="listitem" value="4">There <a id="id339" class="calibre1"/>is a lot going on here; let's take a look <a id="id340" class="calibre1"/>at the <code class="email">newText</code> action first:<div class="informalexample"><pre class="programlisting">    newText(){
      let inf = this.get('info');
      let newBook = this.store.createRecord('book',{
        title: inf.title,
        author: inf.author,
        year: new Date(inf.year)
      });</pre></div><p class="calibre14">In this action, we are getting the <code class="email">info</code> property that was declared earlier. This property is an object that is used to store values from the template. The store has a method called <code class="email">createRecord</code> that takes two arguments. The first argument is the model. The second is the object that we want to store. In this case, we want to add a new <code class="email">book</code> record to the store. We use the <code class="email">inf</code> object to set the <code class="email">title</code>, <code class="email">author</code>, and <code class="email">year</code>.</p></li><li class="listitem" value="5">Using <a id="id341" class="calibre1"/>the <code class="email">createRecord</code> method doesn't <a id="id342" class="calibre1"/>persist the changes. The <code class="email">save()</code> method <a id="id343" class="calibre1"/>is used to persist data back to the server:<div class="informalexample"><pre class="programlisting">    newBook.save().then(()=&gt;{
      this.transitionToRoute('application');
      this.set('info',{});
    },()=&gt; {
      console.log('failed');
    });</pre></div><p class="calibre14">The <code class="email">save</code> <a id="id344" class="calibre1"/>method is a promise. It will either succeed or fail. If it succeeds, we use the <code class="email">transitionToRoute</code> method to change the route back to the main application.</p><p class="calibre14">Afterwards, we set the <code class="email">info</code> property back to an empty object. We do this so that the template <code class="email">input</code> helper is cleared of all data. If it doesn't succeed, then we output an error to the console:</p><div class="informalexample"><pre class="programlisting">    cancel(){
      return true;
    }</pre></div><p class="calibre14">The <code class="email">cancel</code> action returns <code class="email">true</code>. What this means is that instead of the controller handling it, it will be bubbled up to be handled by the route:</p><div class="note" title="Note"><h3 class="title2"><a id="tip27" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">REST with Ember</strong></span></p><p class="calibre8">When using the REST adapter in Ember, the <code class="email">save()</code> method will send a PUT, DELETE, GET, or POST HTTP request to the server. The PUT request will be sent during an update. The DELETE request is used to delete a record. POST is used to add a new record, and the GET request is used to retrieve records. This is done by convention by the Ember REST adapter.</p></div></li><li class="listitem" value="6">Update <a id="id345" class="calibre1"/>the <code class="email">books.hbs</code> template file with a <a id="id346" class="calibre1"/>new action to update:<div class="informalexample"><pre class="programlisting">// app/templates/books.hbs
{{outlet}}
&lt;br&gt;
&lt;b&gt;title: {{input value=model.title size='15'}}&lt;/b&gt;&lt;br&gt;
&lt;b&gt;Author: {{input value=model.author size='15'}}&lt;/b&gt;&lt;br&gt;
&lt;b&gt;Year: {{input value=model.year size='35'}}&lt;/b&gt;&lt;br&gt;
&lt;button {{action 'updateText'}}&gt;Submit Changes&lt;/button&gt;
&lt;button {{action 'cancel'}}&gt;cancel&lt;/button&gt;
&lt;br&gt;</pre></div><p class="calibre14">We've <a id="id347" class="calibre1"/>updated the books template to <a id="id348" class="calibre1"/>behave differently from our last example. In this example, it will allow us to edit the entries as follows:</p><div class="mediaobject"><img src="../images/00039.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p></li><li class="listitem" value="7">Update the <code class="email">books.js</code> controller to handle the new <code class="email">updateText</code> and <code class="email">cancel</code> actions:<div class="informalexample"><pre class="programlisting">// app/controllers/books.js
import Ember from 'ember';

export default Ember.Controller.extend({
    actions: {
      updateText(){
        let book = this.get('model');
        book.set('year',new Date(book.get('year')));
        book.save();
        this.transitionToRoute('application');
      },
      cancel() {
        return true;
      }
    }
});</pre></div><p class="calibre14">The <a id="id349" class="calibre1"/>
<code class="email">updateText</code> action gets the current <a id="id350" class="calibre1"/>book <code class="email">model</code>, sets the <code class="email">year</code>, and then <a id="id351" class="calibre1"/>saves it. Afterwards, it transitions <a id="id352" class="calibre1"/>to the <code class="email">application</code> route. If needed, we could handle the error condition if the save promise fails. For the sake of simplicity, we'll leave it as is. The <code class="email">cancel</code> action returns <code class="email">true</code>, which means that it will bubble up to the books route to be handled.</p></li><li class="listitem" value="8">Update the <code class="email">books.js</code> file in the route:<div class="informalexample"><pre class="programlisting">// app/routes/books.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(params){
      return this.store.findRecord('book',params.book_id);
    },
    actions:{
      cancel() {
        return true;
      }
    }
});</pre></div><p class="calibre14">The route file is the same as the previous recipe, except now we have a <code class="email">cancel</code> action. This <code class="email">cancel</code> action will be triggered after the controller returns <code class="email">true</code>. By returning <code class="email">true</code> here, the action bubbles up one more time to the application route.</p></li><li class="listitem" value="9">Update the <code class="email">new.js</code> route file:<div class="informalexample"><pre class="programlisting">// app/routes/new.js
import Ember from 'ember';

export default Ember.Route.extend({
    actions: {
      cancel() {
        return true;
      }
    }
});</pre></div><p class="calibre14">This <a id="id353" class="calibre1"/>file will receive the action from the new <a id="id354" class="calibre1"/>controller. It also returns <code class="email">true</code>, which <a id="id355" class="calibre1"/>means that the <code class="email">cancel</code> action <a id="id356" class="calibre1"/>will be handled by the application route as well.</p></li><li class="listitem" value="10">Update the application route file:<div class="informalexample"><pre class="programlisting">// app/routes/application.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(){
      return this.store.findAll('book');
    },
    actions: {
      cancel(){
        this.transitionTo('application');
      }
    }
});</pre></div><p class="calibre14">The <code class="email">cancel</code> action in the application route handles the new and book routes <code class="email">cancel</code> action. In either case, it will transition to the <code class="email">application</code> route. In summary, the bubbling of the action went from the new controller to the new route and finally to the application route. If the <code class="email">cancel</code> action was not included in the controller, by convention, the action will automatically bubble up.</p></li><li class="listitem" value="11">We need to update the application template and add a new option to delete records. Update the <code class="email">application.hbs</code> file with the new <code class="email">delete</code> action:<div class="informalexample"><pre class="programlisting">// app/templates/application.hbs
{{#link-to 'index'}}&lt;h2 id="title"&gt;Welcome to Ember&lt;/h2&gt;{{/link-to}}
{{#link-to 'new'}}&lt;h5&gt;Add New Book&lt;/h5&gt;{{/link-to}}

{{outlet}}

{{#each model as |book|}}
    &lt;br&gt;
    title: {{#link-to 'books' book.id}}{{book.title}}{{/link-to}} &lt;br&gt;
&lt;a href="" {{action 'delete' book}}&gt;delete?&lt;/a&gt;&lt;br&gt;
{{/each}}</pre></div><p class="calibre14">The application will display each book. There is also a <code class="email">delete</code> action button at the bottom of each record that passes in the <code class="email">book</code> record.</p></li><li class="listitem" value="12">Update <a id="id357" class="calibre1"/>the application controller to handle <a id="id358" class="calibre1"/>the new <code class="email">delete</code> action:<div class="informalexample"><pre class="programlisting">// app/controllers/application.js
import Ember from 'ember';

export default Ember.Controller.extend({
    actions:{
      delete(book){
        book.deleteRecord();
        console.log(book.get('isDeleted'));
        book.save();
      }
    }
});</pre></div><p class="calibre14">The <a id="id359" class="calibre1"/>book record has a method called <code class="email">deleteRecord</code>. This deletes the record; however, it doesn't send the HTTP delete <a id="id360" class="calibre1"/>request to the server until <code class="email">save()</code> is done. Another method called <code class="email">destroyRecord</code> will <code class="email">delete</code> and <code class="email">save</code> at the same time. For this example, we'll use <code class="email">deleteRecord</code> instead.</p></li><li class="listitem" value="13">Load the Ember server and you'll see a list of records. You can click on each record and delete or edit it:<div class="mediaobject"><img src="../images/00040.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><div class="note" title="Note"><h3 class="title2"><a id="tip28" class="calibre1"/>Tip</h3><p class="calibre8"><span class="strong"><strong class="calibre9">Not using Ember Data?</strong></span></p><p class="calibre8">Ember <a id="id361" class="calibre1"/>Data is the preferred method when working <a id="id362" class="calibre1"/>with a backend data store. However, it doesn't have to be the only option. When defining model information <a id="id363" class="calibre1"/>in a route, you can use Ajax methods or <a id="id364" class="calibre1"/>define your own repositories as well. You can use services and inject them throughout your application if needed. This will take a substantial amount of extra work, depending on your setup, but it is an option.</p></div></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Creating, reading, updating, and deleting records with Ember Data">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec100" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Ember Data comes with several adapters that can be used to retrieve data from a backend server. The REST adapter allows the user to make requests to a backend server using HTTP GET, DETETE, PUT, and POST requests. By default, it expects responses in JSON.</p><p class="calibre8">The Ember Data store methods allow a user to find, delete, and save records. The Ember <code class="email">save()</code> method triggers a response to the server. Before the save is done, records can be rolled back if needed.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using fixtures" id="1R42S1-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec56" class="calibre1"/>Using fixtures</h1></div></div></div><p class="calibre8">Fixtures are <a id="id365" class="calibre1"/>another way of mocking data. It's static data that can be used in our model to display to the user when testing our application. In this recipe, we'll see some basics on how to set it up with Ember CLI Mirage.</p></div>

<div class="book" title="Using fixtures" id="1R42S1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec101" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">As with many of our other examples, we'll be using Ember CLI Mirage. Instead of using a factory, we'll set up fixture data.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Begin by creating a new application. Then add the Ember CLI Mirage add-on and generate the model and routes for the application:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember install ember-cli-mirage</strong></span>
<span class="strong"><strong class="calibre9">$ ember g model student name:string age:number</strong></span>
<span class="strong"><strong class="calibre9">$ ember g route index</strong></span>
<span class="strong"><strong class="calibre9">$ ember g adapter application</strong></span>
<span class="strong"><strong class="calibre9">$ ember g fixture students</strong></span>
</pre></div><p class="calibre14">These commands will generate the basic structure of our app. In this application, fixture data will be used to display student information. For the sake of simplicity, we'll only be displaying this information and not manipulating it.</p></li><li class="listitem" value="2">In the <a id="id366" class="calibre1"/><code class="email">mirage</code> <code class="email">fixtures</code> folder, update the <code class="email">students.js</code> file and add the fixture data:<div class="informalexample"><pre class="programlisting">// app/mirage/fixtures/students.js
export default [
    {id: 1, name: 'John', age: 17},
    {id: 2, name: 'Jack', age: 18},
    {id: 3, name: 'Suze', age: 17},
    {id: 4, name: 'Jane', age: 18}
];</pre></div><p class="calibre14">The fixture data has four records. Each record has a different student's <code class="email">name</code> and <code class="email">age</code>. To use fixture data with Ember CLI Mirage, you must enter it as an array of objects.</p></li><li class="listitem" value="3">Update the <code class="email">config.js</code> file in the <code class="email">mirage</code> folder. This file is used to set the <code class="email">students</code> route:<div class="informalexample"><pre class="programlisting">// app/mirage/config.js
export default function() {

    this.get('/students');

}</pre></div><p class="calibre14">This will set up a mock server endpoint for Ember Data to reach. By convention, Ember Data will look for the URL path of the pluralized model name. In this example, our model will be student; therefore, when Ember Data looks for data, it will do a GET request to <code class="email">/students</code> on the server.</p></li><li class="listitem" value="4">Add a new scenario to the <code class="email">default.js</code> file for the fixture data:<div class="informalexample"><pre class="programlisting">// app/mirage/scenarios/default.js
export default function(server ) {
    server.loadFixtures();

}</pre></div><p class="calibre14">The <code class="email">loadFixtures()</code> command will load the fixtures in memory so that they are available to the <code class="email">students</code> route.</p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Using fixtures" id="1R42S1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec102" class="calibre1"/>How to do it...</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Earlier, we created the model file. Let's take a look at it first to make sure that everything is set up correctly:<div class="informalexample"><pre class="programlisting">// app/models/student.js
import DS from 'ember-data';

export default DS.Model.extend({
    name: DS.attr('string'),
    age: DS.attr('number')
});</pre></div><p class="calibre14">The <code class="email">student</code> <a id="id367" class="calibre1"/>model has two properties called <code class="email">name</code> and <code class="email">age</code>.</p></li><li class="listitem" value="2">Update the route <code class="email">index.js</code> file to return the students model:<div class="informalexample"><pre class="programlisting">// app/routes/index.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(){
      return this.store.findAll('student');
    }
});</pre></div><p class="calibre14">The route file will return all <code class="email">student</code> records using the <code class="email">findAll</code> method. This will trigger an HTTP GET request to the server at <code class="email">/students</code>. The <code class="email">model</code> hook is triggered when you visit the route. By convention, Ember will then cache these results.</p></li><li class="listitem" value="3">Open the application adapter. Set it to the REST adapter:<div class="informalexample"><pre class="programlisting">// app/adapters/application.js
import DS from 'ember-data';

export default DS.RESTAdapter.extend({
});</pre></div><p class="calibre14"><code class="email">RESTAdapter</code> will be used for all routes. It's a type of adapter that assumes that JSON data will be sent via XHR.</p></li><li class="listitem" value="4">Edit the <code class="email">index.hbs</code> file. This will display the model information:<div class="informalexample"><pre class="programlisting">// app/templates/index.hbs
{{#each model as |student|}}
    Name: {{student.name}}&lt;br&gt;
    age: {{student.age}}&lt;br&gt;
{{/each}}&lt;br&gt;</pre></div><p class="calibre14">In this example, we use the <code class="email">each</code> helper to iterate through all the records.</p></li><li class="listitem" value="5">Run <code class="email">ember server</code> <a id="id368" class="calibre1"/>and the following results should be displayed:<div class="mediaobject"><img src="../images/00041.jpeg" alt="How to do it..." class="calibre10"/></div><p class="calibre26"> </p><p class="calibre14">After the page loads, a list of the students' names and ages will be displayed. This data is retrieved from the fixture data that we set up earlier using our mock server.</p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Using fixtures" id="1R42S1-d21a6ad8148a415181fa52c0043435bb">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec103" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Fixtures are used when testing an application. It is well-known data and can be used for repeated tests. Ember CLI Mirage can be set up to use fixture data.</p><p class="calibre8">We'll be going over using fixture data with testing in the testing chapter in more detail.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Customizing the adapter and serializer"><div class="book" id="1S2JE2-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec57" class="calibre1"/>Customizing the adapter and serializer</h1></div></div></div><p class="calibre8">Ember <a id="id369" class="calibre1"/>Data is very opinionated on how it wants to access data. The <a id="id370" class="calibre1"/>adapter has built-in assumptions on what the data looks like. We can use serializers and adapters to change these assumptions.</p><p class="calibre8">For this recipe, we'll be building on the student application that we created in the previous section.</p></div>

<div class="book" title="Customizing the adapter and serializer">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec104" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">We'll be using the same application from the previous recipe. We'll need to edit Ember CLI Mirage to handle a new namespace.</p><p class="calibre8">In the <code class="email">config.js</code> file in the <code class="email">mirage</code> folder, update the <code class="email">students</code> route:</p><div class="informalexample"><pre class="programlisting">// app/mirage/config.js
export default function() {

    this.get('api/v1/students');
}</pre></div><p class="calibre8">This will change the endpoint to <code class="email">api/v1/students</code> instead of just <code class="email">/students</code>.</p></div></div>

<div class="book" title="Customizing the adapter and serializer">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec105" class="calibre1"/>How to do it...</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">In the students application from the previous section, edit the <code class="email">application.js</code> file in the <code class="email">adapters</code> folder.</li><li class="listitem" value="2">Add a new <code class="email">namespace</code>:<div class="informalexample"><pre class="programlisting">// app/adapters/application.js
import DS from 'ember-data';

export default DS.RESTAdapter.extend({
    namespace: 'api/v1'
});</pre></div><p class="calibre14">The <code class="email">namespace</code> property is used to prefix requests with a specific URL. In this case, all requests will have <code class="email">api/v1</code> prepended to them.</p></li><li class="listitem" value="3">Start the Ember server and you should see requests going to <code class="email">/api/v1/students</code>.</li></ol><div class="calibre15"/></div><div class="book" title="Optional customizations in Ember Data"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec50" class="calibre1"/>Optional customizations in Ember Data</h3></div></div></div><p class="calibre8">Ember <a id="id371" class="calibre1"/>offers a number of other customizations if needed. Here are a few important ones to keep in mind.</p><div class="book" title="Host customization"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch07lvl4sec01" class="calibre1"/>Host customization</h4></div></div></div><p class="calibre8">In the <a id="id372" class="calibre1"/>adapter file, you can add a new location where Ember Data should send requests. This overwrites the default location of the local server:</p><div class="informalexample"><pre class="programlisting">// app/adapters/application.js
import DS from 'ember-data';

export default DS.RESTAdapter.extend({
host: 'https://api.example.com'
});</pre></div><p class="calibre8">As an example, now all the requests will be sent to <code class="email">api.example.com</code>.</p></div><div class="book" title="Headers customization"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch07lvl4sec02" class="calibre1"/>Headers customization</h4></div></div></div><p class="calibre8">Depending <a id="id373" class="calibre1"/>on the API, you may need to send specific headers in each HTTP request. You can add this using the <code class="email">headers</code> property:</p><div class="informalexample"><pre class="programlisting">// app/adapters/application.js
import DS from 'ember-data';

export default DS.RESTAdapter.extend({
  headers: {
    'API_INFO:': 'key',
    'SECOND_HEADER': 'Some value'
  }
});</pre></div><p class="calibre8">This will add new <code class="email">headers</code> for every request that is sent. If needed, you can also use dynamic information in your headers by creating a computed property.</p></div></div><div class="book" title="Working with serializers"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch07lvl3sec51" class="calibre1"/>Working with serializers</h3></div></div></div><p class="calibre8">When using <a id="id374" class="calibre1"/>Ember Data, serializers format the data that's sent and received from the backend data store. We can customize this data to fit the needs of our backend.</p><div class="book" title="Updating IDs"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch07lvl4sec03" class="calibre1"/>Updating IDs</h4></div></div></div><p class="calibre8">By default, Ember <a id="id375" class="calibre1"/>Data expects each record to have an ID. We can change the name of this using the primary key property.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Generate a new <code class="email">serializer</code> file:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember g serializer application</strong></span>
</pre></div><p class="calibre14">This generates the <code class="email">serializer</code> file that we can update.</p></li><li class="listitem" value="2">Update the <code class="email">application.js</code> serializer with the new ID:<div class="informalexample"><pre class="programlisting">// app/serializers/application.js
import DS from 'ember-data';

export default DS.RESTSerializer.extend({
    primaryKey: '_id'
});</pre></div><p class="calibre14">This will <a id="id376" class="calibre1"/>transform the ID property to <code class="email">_id</code> when serializing and deserializing data. In other words, when data is sent or received from the server, it will have a primary key that is set to <code class="email">_id</code>.</p></li></ol><div class="calibre15"/></div></div><div class="book" title="KeyForAttribute when working a JSON payload"><div class="book"><div class="book"><div class="book"><h4 class="title3"><a id="ch07lvl4sec04" class="calibre1"/>KeyForAttribute when working a JSON payload</h4></div></div></div><p class="calibre8">At times, the <a id="id377" class="calibre1"/>data sent back from the server may not be in the correct format. For example, <code class="email">RESTAdapter</code> expects the JSON payload attribute names in camel-case. We can change this using the <code class="email">keyForAttribute</code> property:</p><div class="informalexample"><pre class="programlisting">// app/serializers/application.js
import DS from 'ember-data';

export default DS.RESTSerializer.extend({
    keyForAttribute(attr) {
      return Ember.String.decamelize(attr);
    }
});</pre></div><p class="calibre8">For example, let's say that the data sent back from the server is underscored instead of camel-cased. The server is returning <code class="email">school_name</code> instead of <code class="email">schoolName</code>. This can be fixed using <code class="email">keyForAttribute</code> and <code class="email">decamelize</code>. This will take the model name <code class="email">schoolName</code> and <code class="email">decamelize</code> it to <code class="email">school_name</code> so that it matches what's returned from the server.</p></div></div></div></div>

<div class="book" title="Customizing the adapter and serializer">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec106" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Adapters are used in Ember Data to help interpret data that is sent and retrieved from the server. It has a set of built-in assumptions on how the data should look. We can make changes so that we can accommodate different types of APIs. For example, we can customize the endpoint's path namespace as well as the host if needed.</p><p class="calibre8">Serializers format the data that is sent and received from the server. Ember Data expects data to be in a certain format. We can change many things in this data including the primary key and the keys in the JSON payload. This is accomplished by adding new properties to the serializer.</p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Working with relationships"><div class="book" id="1T1402-d21a6ad8148a415181fa52c0043435bb"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch07lvl1sec58" class="calibre1"/>Working with relationships</h1></div></div></div><p class="calibre8">When working <a id="id378" class="calibre1"/>with a data store, you'll need to be able to handle relationships. In this recipe, we'll go over some common relationships from one-to-many and many-to-one and also how to use it with Ember Data.</p></div>

<div class="book" title="Working with relationships">
<div class="book" title="Getting ready"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch07lvl2sec107" class="calibre1"/>Getting ready</h2></div></div></div><p class="calibre8">As with the other recipes, we'll be using Ember CLI Mirage to mock our backend. In this recipe, we'll create a simple one-to-many and many-to-one relationship. We'll mock a school that has instructors and classes. For every class, there is one instructor. Every instructor will have one or more classes.</p><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Create a new Ember application. In this application, generate the following files:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre9">$ ember install ember-cli-mirage</strong></span>
<span class="strong"><strong class="calibre9">$ ember g model instructor</strong></span>
<span class="strong"><strong class="calibre9">$ ember g model class</strong></span>
<span class="strong"><strong class="calibre9">$ ember g route index</strong></span>
<span class="strong"><strong class="calibre9">$ ember g helper addone</strong></span>
<span class="strong"><strong class="calibre9">$ ember g adapter application</strong></span>
<span class="strong"><strong class="calibre9">$ ember g fixture classes</strong></span>
<span class="strong"><strong class="calibre9">$ ember g fixture instructors</strong></span>
</pre></div><p class="calibre14">This will create the models, route, adapter, and helper that we'll need for this application.</p></li><li class="listitem" value="2">In the <code class="email">mirage</code> <code class="email">fixtures</code> folder, update these two files, <code class="email">classes.js</code> and <code class="email">instructors.js</code>:<div class="informalexample"><pre class="programlisting">// app/mirage/fixtures/classes.js
export default [
    {id: 1, subject: 'History',instructor:[1]},
    {id: 2, subject: 'Spanish',instructor:[1]},
    {id: 3, subject: 'Government',instructor:[3]},
    {id: 4, subject: 'English',instructor:[2]},
    {id: 5, subject: 'German',instructor:[2]},
    {id: 6, subject: 'Social Studies',instructor:[4]},
    {id: 7, subject: 'Math',instructor:[]}
];</pre></div><p class="calibre14">The <code class="email">classes.js</code> file has a list of classes and subjects.</p></li><li class="listitem" value="3">Create the <code class="email">instructors.js</code> file:<div class="informalexample"><pre class="programlisting">// app/mirage/fixtures/instructors.js
export default [
    {id: 1, name: 'John', age: 17, classes:[1,2]},
    {id: 2, name: 'Jack', age: 18, classes:[4,5]},
    {id: 3, name: 'Suze', age: 17, classes:[3]},
    {id: 4, name: 'Jane', age: 16, classes:[6]}
];</pre></div><p class="calibre14">As you can see, each young instructor has a list of classes that they teach. Each class has one, and only one, instructor for that class.</p></li><li class="listitem" value="4">Edit the <code class="email">config.js</code> file for Mirage. Add the new routes:<div class="informalexample"><pre class="programlisting">// app/mirage/config.js
export default function() {

    this.get('/instructors',['instructors','classes']);
    this.get('/classes',['instructors','classes']);
}</pre></div></li><li class="listitem" value="5">Each one of these <a id="id379" class="calibre1"/>endpoints will return the <code class="email">instructor</code> and <a id="id380" class="calibre1"/><code class="email">class</code> data. This is done via <span class="strong"><strong class="calibre9">sideloading</strong></span>. Here is an example of a JSON response sideloaded:<div class="informalexample"><pre class="programlisting">{
  "instructors": [
    {
      "id": 1,
      "name": "John",
      "age": "17",
      "classes": [1,2]
    },
    {
      "id": 2,
      "name": "Jack",
      "age": "18",
      "classes": [3,4]

    }
  ],
  "classes": [
    {
      "id": 1,
      "subject": "History",
      "instructor": [1]
    },
    {
      "id": 2,
      "subject": "Spanish",
      "instructor": [1]

    },
    {
      "id": 3,
      "subject": "Government",
      "instructor": [2]
    },
    {
      "id": 4,
      "subject": "English",
      "instructor": [2]

    },
  ]

}</pre></div><p class="calibre14">As you can see from the preceding example, both the <code class="email">instructor</code> and <code class="email">class</code> data was returned. This is the default that <code class="email">RESTAdapter</code> expects.</p><p class="calibre14">On the other <a id="id381" class="calibre1"/>hand, we could return the data using asynchronous relationships. When this occurs, the server data store returns records only for one model. Ember then does one or more HTTP requests to retrieve data for the other model. For the simplicity of this example, we'll assume that the data is sideloaded.</p></li><li class="listitem" value="6">Finally, create a new scenario that loads the fixture data for us to use:<div class="informalexample"><pre class="programlisting">// app/mirage/scenarios/default.js
export default function( server ) {

  server.loadFixtures();
}</pre></div><p class="calibre14">This will load both fixtures so that they can be returned to the Ember client.</p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Working with relationships">
<div class="book" title="How to do it..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch07lvl2sec108" class="calibre1"/>How to do it...</h2></div></div></div><div class="book"><ol class="orderedlist"><li class="listitem" value="1">Open the <code class="email">application.js</code> file in the <code class="email">adapter</code> folder. Set it to <code class="email">RESTAdapter</code>:<div class="informalexample"><pre class="programlisting">import DS from 'ember-data';

export default DS.RESTAdapter.extend({
});</pre></div><p class="calibre14"><code class="email">RESTAdapter</code> will be used for this recipe.</p></li><li class="listitem" value="2">Edit the <code class="email">class.js</code> and <code class="email">instructor.js</code> files in the <code class="email">models</code> folder. Add the new properties <a id="id382" class="calibre1"/>for the model:<div class="informalexample"><pre class="programlisting">// app/models/class.js
import DS from 'ember-data';

export default DS.Model.extend({
  subject: DS.attr('string'),
  instructor: DS.belongsTo('instructor')
});</pre></div><p class="calibre14">In this example, we need to make sure that the class has one <code class="email">instructor</code>. This can be accomplished using the <code class="email">DS.belongsTo</code> method. This tells Ember to look at the <code class="email">instructor</code> model for this property.</p></li><li class="listitem" value="3">The instructor has a one-to-many relationship with the class model. One instructor can have one or more classes that he teaches. We can accomplish this using the <code class="email">DS.hasMany()</code> method and providing the name of the model:<div class="informalexample"><pre class="programlisting">// app/models/instructor.js
import DS from 'ember-data';

export default DS.Model.extend({
    name: DS.attr('string'),
    age: DS.attr('number'),
    classes: DS.hasMany('class')
});</pre></div></li><li class="listitem" value="4">Update the <code class="email">index.js</code> file in the <code class="email">routes</code> folder. Specify it to return all the <code class="email">instructor</code> data:<div class="informalexample"><pre class="programlisting">// app/routes/index.js
import Ember from 'ember';

export default Ember.Route.extend({
    model(){
      return this.store.findAll('instructor');
    }
});</pre></div><p class="calibre14">This route uses the Ember Data <code class="email">findAll</code> method to return all the <code class="email">instructor</code> data.</p></li><li class="listitem" value="5">Update the <code class="email">helper</code> file:<div class="informalexample"><pre class="programlisting">// app/helpers/addone.js
import Ember from 'ember';

export function addone(params) {
    return +params+1;
}

export default Ember.Helper.helper(addone);</pre></div><p class="calibre14">Helpers in Ember are used to manipulate template data. You can pass information to one and return information. In this example, we are doing some simple mathematics.</p></li><li class="listitem" value="6">Edit <a id="id383" class="calibre1"/>the <code class="email">index.hbs</code> file with the model data:<div class="informalexample"><pre class="programlisting">// app/templates/index.hbs
{{outlet}}
{{#each model as |instructor|}}
Name of instructor: &lt;b&gt;{{instructor.name}}&lt;/b&gt;&lt;br&gt;
Teaches Classes:&lt;br&gt;
{{#each instructor.classes as |class index|}}
    &lt;b&gt;{{addone index}}: {{class.subject}}&lt;/b&gt;&lt;br&gt;
{{/each}}
&lt;br&gt;    &lt;br&gt;
{{/each}}</pre></div><p class="calibre14">In this template, we are using the <code class="email">each</code> helper to display the instructor's name. To access the class information, another <code class="email">each</code> helper iterates over <code class="email">instructor.classes</code>. In each iteration, we display the <code class="email">subject</code> and <code class="email">index</code> class. As the index starts at zero, we can pass it to the <code class="email">addone</code> helper. This helper increments the number passed to it.</p></li><li class="listitem" value="7">Run <code class="email">ember server</code> and you should see all the data displayed from the fixture data:<div class="mediaobject"><img src="../images/00042.jpeg" alt="How to do it..." class="calibre10"/><div class="caption"><p class="calibre27">Each instructor is listed with each class</p></div></div><p class="calibre26"> </p></li></ol><div class="calibre15"/></div></div></div>

<div class="book" title="Working with relationships">
<div class="book" title="How it works..."><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch07lvl2sec109" class="calibre1"/>How it works...</h2></div></div></div><p class="calibre8">Ember uses the <code class="email">DS.hasMany</code> and <code class="email">DS.belongsTo</code> methods to signify a one-to-many and a one-to-one <a id="id384" class="calibre1"/>relationship. Ember, by convention, assumes that you are using the JSON API adapter. At the time of writing this, the JSON API is the default adapter for Ember Data. It communicates with a server via well-defined JSON via XHR. Its goal is to be easy to work with on the client and server side while working with a broad set of use cases, including relationships. For the most part, the REST adapter works fine. So, I've included it in the book instead of the JSON API adapter. Be aware that you can use either to accomplish your goals.</p><p class="calibre8">This can be <a id="id385" class="calibre1"/>changed using <code class="email">RESTAdapter</code> instead. <code class="email">RESTAdapter</code> assumes that all keys are camel-cased and that any data sent is sideloaded. This is done to help developers easily integrate their backend APIs and data stores with Ember.</p></div></div></body></html>