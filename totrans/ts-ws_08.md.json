["```js\ntsc --target es2015 .\\decorator-example.ts\ndecorator-example.ts:18:5 – error TS1219: \n  Experimental support for decorators is a feature \n  that is subject to change in a future release. \n  Set the 'experimentalDecorators' option in your 'tsconfig' or \n  'jsconfig' to remove this warning.\n```", "```js\ntsc --experimentalDecorators --target es2015 \n  .\\decorator-example.ts\n```", "```js\n{\n  \"compilerOptions\": {\n    \"target\": \"ES2015\",\n    \"experimentalDecorators\": true,\n    \"emitDecoratorMetadata\": true,\n  }\n}\n```", "```js\nExample_Basketball.ts\n1  interface Team {\n2      score: number;\n3      name: string;\n4  }\n5  \n6  class BasketBallGame {\n7      private team1: Team;\n8      private team2: Team;\n9  \n10     constructor(teamName1: string, teamName2: string) {\n11         this.team1 = { score: 0, name: teamName1 };\n12         this.team2 = { score: 0, name: teamName2 };\n13     }\n14  \n15     getScore() {\n16         return `${this.team1.score}:${this.team2.score}`;\n17     }\n18 }\n19 \n20 const game = new BasketBallGame(\"LA Lakers\", \"Boston Celtics\");\nLink to the preceding example: https://packt.link/ORdNl.\n```", "```js\nupdateScore(byPoints: number, updateTeam1: boolean) {\n    if (updateTeam1) {\n        this.team1.score += byPoints;\n    } else {\n        this.team2.score += byPoints;\n    }\n}\n```", "```js\nconst game = new BasketBallGame(\"LA Lakers\", \"Boston Celtics\");\ngame.updateScore(3, true);\ngame.updateScore(2, false);\ngame.updateScore(2, true);\ngame.updateScore(2, false);\ngame.updateScore(2, false);\ngame.updateScore(2, true);\ngame.updateScore(2, false);\nconsole.log(game.getScore());\n```", "```js\nupdateScore(byPoints: number, updateTeam1: boolean) {\n    if (isAuthorized()) {\n        if (updateTeam1) {\n            this.team1.score += byPoints;\n        } else {\n            this.team2.score += byPoints;\n        }\n    } else {\n        console.log(\"You're not authorized to change the score\");\n    }\n}\n```", "```js\nupdateScore(byPoints: number, updateTeam1: boolean) {\n    audit(\"updateScore\", byPoints, updateTeam1);\n    const start = Date.now();\n    if (isAuthorized()) {\n        if (validatePoints(byPoints)) {\n            if (updateTeam1) {\n                this.team1.score += byPoints;\n            } else {\n                this.team2.score += byPoints;\n            }\n        } else {\n            console.log(`Invalid point value ${byPoints}`);\n        }\n    } else {\n        console.log(\"You're not authorized to change the score\");\n    }\n    const end = Date.now();\n    logDuration(\"updateScore\", start, end);\n}\n```", "```js\nconst start = Date.now();\n// actual code of the method\nconst end = Date.now();\nlogDuration(\"updateScore\", start, end);\n```", "```js\nfunction wrapWithDuration(method: Function) {\n    const result = {\n        [method.name]: function (this: any, ...args: any[]) {\n            const start = Date.now();\n            const result = method.apply(this, args);\n            const end = Date.now();\n            logDuration(method.name, start, end);\n            return result;\n        },\n    };\n    return result[method.name];\n}\n```", "```js\n@ClassDecorator\nclass SampleClass {\n    @PropertyDecorator\n    public sampleProperty:number = 0;\n    private _sampleField: number = 0;\n    @AccessorDecorator\n    public get sampleField() { return this._sampleField; }\n    @MethodDecorator\n    public sampleMethod(@ParameterDecorator paramName: string) {}\n}\n```", "```js\nfunction ClassDecorator (constructor: Function) {}\nfunction AccessorDecorator (target: any, propertyName: string, descriptor: PropertyDescriptor) {}\nfunction MethodDecorator (target: any, propertyName: string, descriptor: PropertyDescriptor) {}\nfunction PropertyDecorator (target: any, propertyName: string) {}\nfunction ParameterDecorator (target: any, propertyName: string, parameterIndex: number) {}\n```", "```js\nExample_Decorator_Factory.ts\n1 function ClassDecoratorFactory(message: string) {\n2     console.log(`${message} inside factory`);\n3     return function (constructor: Function) {\n4       console.log(`${message} inside decorator`);\n5     };\n6 }\nLink to the preceding example: https://packt.link/M2Ixp.\n```", "```js\n@ClassDecoratorFactory(\"Hi\")\nclass DecoratedOne {}\n@ClassDecoratorFactory(\"Hello\")\nclass DecoratedTwo {}\n```", "```js\nHi inside factory\nHi inside decorator\nHello inside factory\nHello inside decorator\n```", "```js\nclass Teacher {\n    constructor (public id: number, public name: string) {}\n    // other teacher specific code\n}\n```", "```js\nExample_PropertyInjection.ts\n1 @Token\n2 class Teacher {\n3     // old teacher specific code\n4 }\n```", "```js\n5 function Token (constructor: Function) {\n6     constructor.prototype.token = true;\n7 }\n```", "```js\n8 const teacher = new Teacher(1, \"John Smith\");\n9 console.log(\"Does the teacher have a token? \",teacher[\"token\"]);\n```", "```js\nDoes the teacher have a token? true\nLink to the preceding example: https://packt.link/asjvA.\n```", "```js\n    @Token\n    class Teacher {\n        constructor (public id: number, public name: string) {}\n        // teacher specific code\n    }\n    function Token (constructor: Function) {\n        constructor.prototype.token = true;\n    }\n    /////////////////////////\n    const teacher = new Teacher(1, \"John Smith\");\n    console.log(\"Does the teacher have a token? \",teacher[\"token\"]);\n    ```", "```js\n    class Student {\n        constructor (public id: number, public name: string) {}\n        // student specific code\n    }\n    ```", "```js\n    const student = new Student(101, \"John Bender\");\n    console.log(\"Does the student have a token? \",student[\"token\"]);\n    ```", "```js\n    @Token\n    class Student {//… \n    ```", "```js\n    function Token(hasToken: boolean) {\n        return function (constructor: Function) {\n            constructor.prototype.token = hasToken;\n        }\n    }\n    ```", "```js\n    @Token(true)\n    class Teacher {//…\n    ```", "```js\n    @Token(false)\n    class Student {//…\n    ```", "```js\n    Does the teacher have a token?  true\n    Does the student have a token?  false\n    ```", "```js\ntype Constructable = {new(...args: any[]):{}};\nfunction Token(hasToken: boolean) {\n    return function <T extends Constructable>(constructor: T) {\n        return class extends constructor {\n            token: boolean = hasToken;\n        }\n    }\n}\n```", "```js\n    class Teacher {\n        constructor (public id: number, public name: string) {}\n        // teacher specific code\n    }\n    /////////////////////////\n    const teacher = new Teacher(1, \"John Smith\");\n    console.log(\"Do you have a token:\", teacher[\"token\"]);\n    console.log(\"Do you have a token property: \", teacher.hasOwnProperty(\"token\"));\n    ```", "```js\n    Do we have a token: undefined\n    Do we have a token property:  false\n    ```", "```js\n    type Constructable = {new(...args: any[]):{}};\n    function Token(hasToken: boolean) {\n        return function <T extends Constructable>(constructor: T) {\n            return class extends constructor {\n                token: boolean = hasToken;\n            }\n        }\n    }\n    ```", "```js\n    @Token(true)\n    class Teacher {\n    ```", "```js\n    Do we have a token: true\n    Do we have a token property:  true\n    ```", "```js\nExample_ConstructorWrapping.ts\n1  type Constructable = { new (...args: any[]): {} };\n2  \n3  function WrapConstructor(message: string) {\n4      return function <T extends Constructable>(constructor: T) {\n5          const wrappedConstructor: any = function (...args: any[]) {\n6              console.log(`Decorating ${message}`);\n7              const result = new constructor(...args);\n8              console.log(`Decorated ${message}`);\n9              return result;\n10         };\n11         wrappedConstructor.prototype = constructor.prototype;\n12         return wrappedConstructor;\n13    };\n14  }\nLink to the preceding example: https://packt.link/kgAme.\n```", "```js\n@WrapConstructor(\"decorator\")\nclass Teacher {\n    constructor(public id: number, public name: string) {\n        console.log(\"Constructing a teacher class instance\");\n    }\n}\n```", "```js\nconst teacher = new Teacher(1, \"John\");\n```", "```js\nDecorating decorator\nConstructing a teacher class instance\nDecorated decorator\n```", "```js\n    class Teacher {\n        constructor(public id: number, public name: string) {\n            console.log(\"Constructing a teacher\");\n        }\n    }\n    /////////////////////////\n    const teacher = new Teacher(1, \"John Smith\");\n    ```", "```js\n    type Constructable = { new (...args: any[]): {} };\n    ```", "```js\n    function LogClass(message: string) {\n        return function <T extends Constructable>(constructor: T) {\n            return constructor;\n        };\n    }\n    ```", "```js\n    @LogClass(\"Teacher decorator\")\n    class Teacher {\n        constructor(public id: number, public name: string) {\n            console.log(\"Constructing a teacher\");\n        }\n    }\n    ```", "```js\n    const logger = {\n        info: (message: string) => {\n            console.log(`[INFO]: ${message}`);\n        },\n    };\n    ```", "```js\n        return function <T extends Constructable>(constructor: T) {\n            const loggingConstructor: any = function(...args: any[]){\n                logger.info(message);\n                return new constructor(...args);\n            }\n            loggingConstructor.prototype = constructor.prototype;\n            return loggingConstructor;\n        };\n    ```", "```js\n    [INFO]: Teacher decorator\n    Constructing a teacher\n    ```", "```js\n    for (let index = 0; index < 10; index++) {\n        const teacher = new Teacher(index +1, \"LouAnne Johnson\");\n    }\n    ```", "```js\n    [INFO]: Teacher decorator\n    Constructing a teacher\n    [INFO]: Teacher decorator\n    Constructing a teacher\n    [INFO]: Teacher decorator\n    Constructing a teacher\n    [INFO]: Teacher decorator\n    Constructing a teacher\n    [INFO]: Teacher decorator\n    Constructing a teacher\n    [INFO]: Teacher decorator\n    Constructing a teacher\n    [INFO]: Teacher decorator\n    Constructing a teacher\n    ```", "```js\n    interface PropertyDescriptor {\n        configurable?: boolean;\n        enumerable?: boolean;\n        value?: any;\n        writable?: boolean;\n        get?(): any;\n        set?(v: any): void;\n    }\n    ```", "```js\ninterface TypedPropertyDescriptor<T> {\n    enumerable?: boolean;\n    configurable?: boolean;\n    writable?: boolean;\n    value?: T;\n    get?: () => T;\n    set?: (value: T) => void;\n}\n```", "```js\nTS1207: Decorators cannot be applied to multiple get/set accessors of the same name.\n```", "```js\nExample_Decorators_Instance_Functions.ts\n1 function DecorateMethod(target: any, propertyName: string,\n2 descriptor: PropertyDescriptor) {\n3     console.log(\"Target is:\", target);\n4     console.log(\"Property name is:\", propertyName);\n5     console.log(\"Descriptor is:\", descriptor);\n6 }\nLink to the preceding example: https://packt.link/gle5U.\n```", "```js\nclass Teacher {\n    constructor (public name: string){}\n    private _title: string = \"\";\n    public get title() { \n        return this._title;\n    }\n\n    public set title(value: string) {\n        this._title = value;\n    }\n    public teach() {\n        console.log(`${this.name} is teaching`)\n    }\n}\n```", "```js\n    @DecorateMethod\n    public teach() {\n        // ....\n```", "```js\n    Target is: {}\n    Property name is: teach\n    Descriptor is: {\n        value: [Function: teach],\n        writable: true,\n        enumerable: false,\n        configurable: true\n    }\n```", "```js\n    @DecorateMethod\n    public get title() { \n        // ....\n```", "```js\n    @DecorateMethod\n    public set title(value: string) {\n        // ....\n```", "```js\n    Target is: {}\n    Property name is: title\n    Descriptor is: {\n        get: [Function: get title],\n        set: [Function: set title],\n        enumerable: false,\n        configurable: true\n    }\n```", "```js\n TS1206: Decorators are not valid here.\n```", "```js\n    class Teacher {\n        constructor (public name: string){}\n        private _title: string = \"\";\n        public get title() { \n            return this._title;\n        }\n\n        public set title(value: string) {\n            this._title = value;\n        }\n        public teach() {\n            console.log(`${this.name} is teaching`)\n        }\n    }\n    ```", "```js\n    const teacher = new Teacher(\"John Smith\");\n    ```", "```js\n    for (const key in teacher) {\n        console.log(key);\n    }\n    ```", "```js\n    function Enumerable(value: boolean) {\n        return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\n            descriptor.enumerable = value;\n        }\n    };\n    ```", "```js\n        @Enumerable(true)\n        public get title() { \n            return this._title;\n        }\n\n        public set title(value: string) {\n            this._title = value;\n        }\n        @Enumerable(true)\n        public teach() {\n            console.log(`${this.name} is teaching`)\n        }\n    ```", "```js\n    name\n    _title\n    title\n    teach\n    ```", "```js\nExample_Decorator_StaticFunctions.ts\n1 class Teacher {\n2     //.....\n3 \n4     public static showUsage() {\n5        console.log(\"This is the Teacher class\")\n6    }\n7    //.....\nLink to the preceding example https://packt.link/Ckuct.\n```", "```js\n    @DecorateMethod\n    public static showUsage() {\n        //......\n```", "```js\nTarget is: [Function: Teacher]\nProperty name is: showUsage\nDescriptor is: {\n  value: [Function: showUsage],\n  writable: true,\n  enumerable: false,\n  configurable: true\n}\n```", "```js\n    class Teacher {\n        constructor (public name: string){}\n        private _title: string = \"\";\n        public get title() { \n            return this._title;\n        }\n\n        public set title(value: string) {\n            this._title = value;\n        }\n        public teach() {\n            console.log(`${this.name} is teaching`)\n        }\n    }\n    /////////////////\n    const teacher = new Teacher(\"John Smith\");\n    teacher.teach(); // we're invoking the teach method\n    teacher.title = \"Mr.\" // we're invoking the title setter\n    console.log(`${teacher.title} ${teacher.name}`); // we're invoking the title getter\n    ```", "```js\n    function LogMethod(message: string) {\n        return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\n        };\n    }\n    ```", "```js\n        @LogMethod(\"Title property\")\n        public get title() { \n        //...    \n        @LogMethod(\"Teach method\")\n        public teach() {\n        //...    \n    ```", "```js\n    const logger = {\n        info: (message: string) => {\n            console.log(`[INFO]: ${message}`);\n        },\n    };\n    ```", "```js\n    function LogMethod(message: string) {\n        return function (target: any, propertyName: string, descriptor: PropertyDescriptor) {\n            if (descriptor.value) {\n                const original = descriptor.value;\n                descriptor.value = function (...args: any[]) {\n                    logger.info(`${message}: Method ${propertyName} invoked`);\n                    // we're passing in the original arguments to the method\n                    return original.apply(this, args);\n                }\n            }\n            if (descriptor.get) {\n                const original = descriptor.get;\n                descriptor.get = function () {\n                    logger.info(`${message}: Getter for ${propertyName} invoked`);\n                    // getter accessors do not take parameters\n                    return original.apply(this, []);\n                }\n            }\n            if (descriptor.set) {\n                const original = descriptor.set;\n                descriptor.set = function (value: any) {\n                    logger.info(`${message}: Setter for ${propertyName} invoked`);\n                    // setter accessors take a single parameter, i.e. the value to be set\n                    return original.apply(this, [value]);\n                }\n            }\n        }\n    }\n    ```", "```js\n    [INFO]: Teach method: Method teach invoked\n    John Smith is teaching\n    [INFO]: Title property: Setter for title invoked\n    [INFO]: Title property: Getter for title invoked\n    Mr. John Smith\n    ```", "```js\n{\n    person: 3,\n    \"person-full-name\": 3,\n    \"person-age\": 3,\n    \"person-title\": 6\n}\n```", "```js\nclass Teacher {\n    constructor (public name: string){}\n    private _title: string = \"\";\n    public get title() { \n        return this._title;\n    }\n\n    public set title(value: string) {\n        this._title = value;\n    }\n    public teach() {\n        console.log(`${this.name} is teaching`)\n    }\n}\n```", "```js\nReflect.defineMetadata(\"call-count\", 0, Teacher);\n```", "```js\nReflect.defineMetadata(\"call-count\", 10, Teacher, \"teach\");\n```", "```js\nReflect.getMetadata(\"call-count\", Teacher); // will return 0\nReflect.getMetadata(\"call-count\", Teacher, \"teach\"); // will return 10\n```", "```js\nfunction increaseCallCount(target: any, propertyKey: string) {\n    if (Reflect.hasMetadata(\"call-count\", target)) {\n        const value = Reflect.getMetadata(\"call-count\", target, propertyKey);\n        Reflect.defineMetadata(\"call-count\", value+1, target, propertyKey)\n    } else {\n        Reflect.defineMetadata(\"call-count\", 1, target, propertyKey)\n    }\n}\n```", "```js\n    class Calculator {\n        constructor (public first: number, public second: number) {}\n        public add() {\n            return this.first + this.second;\n        }\n        public subtract() {\n            return this.first – this.second;\n        }\n        public multiply() {\n            return this.first / this.second;\n        }\n        public divide() {\n            return this.first / this.second;\n        }\n    }\n    ```", "```js\n    Reflect.defineMetadata(\"description\", \"A class that offers common operations over two numbers\", Calculator);\n    Reflect.defineMetadata(\"description\", \"Returns the result of adding two numbers\", Calculator, \"add\");\n    Reflect.defineMetadata(\"description\", \"Returns the result of subtracting two numbers\", Calculator, \"subtract\");\n    Reflect.defineMetadata(\"description\", \"Returns the result of dividing two numbers\", Calculator, \"divide\");\n    ```", "```js\n    function showDescriptions (target: any) {\n        if (Reflect.hasMetadata(\"description\", target)) {\n            const classDescription = Reflect.getMetadata(\"description\", target);\n            console.log(`${target.name}: ${classDescription}`);\n        }\n    }\n    ```", "```js\n    Calculator: A class that offers common operations over two numbers\n    ```", "```js\n    function showDescriptions (target: any) {\n        if (Reflect.hasMetadata(\"description\", target)) {\n            const classDescription = Reflect.getMetadata(\"description\", target);\n            console.log(`${target.name}: ${classDescription}`);\n            const methodNames = Object.getOwnPropertyNames(target.prototype);\n            for (const methodName of methodNames) {\n                if (Reflect.hasMetadata(\"description\", target, methodName)) {\n                    const description = Reflect.getMetadata(\"description\", target, methodName);\n                    console.log(`  ${methodName}: ${description}`);\n                }\n            }\n        }\n    }\n    ```", "```js\n    Calculator: A class that offers common operations over two numbers\n      add: Returns the result of adding two numbers\n      subtract: Returns the result of subtracting two numbers\n      divide: Returns the result of dividing two numbers\n    ```", "```js\nExample_PropertyDecorators.ts\n1 function DecorateProperty(message: string) {\n2     return function (target: any, propertyKey: string) {\n3        console.log(`Decorated \n4 ${target.constructor.name}.${propertyKey} with '${message}'`);\n5     }\n6 }\nLink to the preceding example: https://packt.link/HkkNi.\n```", "```js\nclass Teacher {\n    public id: number;\n    public name: string;\n    constructor(id: number, name: string) {\n        this.id = id;\n        this.name = name;\n    }\n}\n```", "```js\n    @DecorateProperty(\"ID\")\n    public id: number;\n    @DecorateProperty(\"NAME\")\n    public name: string;\n```", "```js\nDecorated Teacher.id with 'ID'\nDecorated Teacher.name with 'NAME'\n```", "```js\n    class Teacher {\n        public id: number;\n        public name: string;\n        constructor(id: number, name: string) {\n            this.id = id;\n            this.name = name;\n        }\n    }\n    ```", "```js\n    function Description(message: string) {\n        return function (target: any, propertyKey: string) {\n            Reflect.defineMetadata(\"description\", message, target, propertyKey)\n        }\n    }\n    ```", "```js\n        @Description(\"This is the id of the teacher\")\n        public id: number;\n        @Description(\"This is the name of the teacher\")\n        public name: string;\n    ```", "```js\n    function showDescriptions (target: any) {\n        for (const key in target) {\n            if (Reflect.hasMetadata(\"description\", target, key)) {\n                const description = Reflect.getMetadata(\"description\", target, key);\n                console.log(`  ${key}: ${description}`);\n            }\n        }\n    }\n    ```", "```js\n    const teacher = new Teacher(1, \"John Smith\");\n    ```", "```js\n    showDescriptions(teacher);\n    ```", "```js\n      id: This is the id of the teacher\n      name: This is the name of the teacher\n    ```", "```js\nExample_ParameterDecorators.ts\n1 function DecorateParam(target: any, propertyName: string,\n2 parameterIndex: number) {\n3    console.log(\"Target is:\", target);\n4    console.log(\"Property name is:\", propertyName);\n5    console.log(\"Index is:\", parameterIndex);\n6 }\nLink to the preceding example: https://packt.link/5vuL2.\n```", "```js\nclass Teacher {\n    public id: number;\n    public name: string;\n    constructor(id: number, name: string) {\n        this.id = id;\n        this.name = name;\n    }\n    public getFullName(title: string, suffix: string) {\n        return `${title} ${this.name}, ${suffix}`\n    }\n}\n```", "```js\n     public getFullName(@DecorateParam title: string, suffix: string) {\n        // ....\n```", "```js\nTarget is: Teacher {}\nProperty name is: getFullName\nIndex is: 0\n```", "```js\n    constructor(id: number, @DecorateParam name: string) {\n        // ....\n```", "```js\nTarget is: [Function: Teacher]\nProperty name is: undefined\nIndex is: 1\n```", "```js\n    class Teacher {\n        public id: number;\n        public name: string;\n        constructor(id: number, name: string) {\n            this.id = id;\n            this.name = name;\n        }\n        public getFullName(title: string, suffix: string) {\n            return `${title} ${this.name}, ${suffix}`\n        }\n    }\n    ```", "```js\n    function Required(target: any, propertyKey: string, parameterIndex: number) {\n        if (Reflect.hasMetadata(\"required\", target, propertyKey)) {\n            const existing = Reflect.getMetadata(\"required\", target, propertyKey) as number[];\n            Reflect.defineMetadata(\"required\", existing.concat(parameterIndex), target, propertyKey);\n        } else {\n            Reflect.defineMetadata(\"required\", [parameterIndex], target, propertyKey)\n        }\n    }\n    ```", "```js\n    function Validate(target: any, propertyKey:string, descriptor: PropertyDescriptor) {\n        const original = descriptor.value;\n        descriptor.value = function (...args: any[]) {\n            // validate parameters\n            if (Reflect.hasMetadata(\"required\", target, propertyKey)) {\n                const requiredParams = Reflect.getMetadata(\"required\", target, propertyKey) as number[];\n                for (const required of requiredParams) {\n                    if (!args[required]) {\n                        throw Error(`The parameter at position ${required} is required`)\n                    }\n                }\n            }\n            return original.apply(this, args);\n        }\n    }\n    ```", "```js\n        @Validate\n        public getFullName(@Required title: string, suffix: string) {\n            // ....\n    ```", "```js\n    const teacher = new Teacher(1, \"John Smith\");\n    ```", "```js\n    try {\n         console.log(teacher.getFullName(\"\", \"Esq\"));\n    } catch (e) {\n         console.log(e.message);\n    }\n    ```", "```js\n    The parameter at position 0 is required\n    ```", "```js\nExample_MultipleDecorators.ts\n1 function First () {\n2    console.log(\"Generating first decorator\")\n3    return function (constructor: Function) {\n4        console.log(\"Applying first decorator\")\n5    }\n6 }\nLink to the preceding example https://packt.link/jMhDj.\n```", "```js\n7  function Second () {\n8      console.log(\"Generating second decorator\")\n9      return function (constructor: Function) {\n10         console.log(\"Applying second decorator\")\n11     }\n12 }\n```", "```js\n13 @First()\n14 @Second()\n15 class Target {}\n```", "```js\nGenerating first decorator\nGenerating second decorator\nApplying second decorator\nApplying first decorator\n```", "```js\n    Create a game object, and update its score a few times. The console should reflect the applications of all decoratorsas shown:\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 3, true ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    //…\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 2, true ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    [AUDIT] Updated score (updateScore) called with arguments:\n    [AUDIT] [ 2, false ]\n    [AUDIT] and returned result:\n    [AUDIT] undefined\n    7:8\n    ```"]