- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural Design Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will explore some of the most popular structural design
    patterns and discover how they apply to Node.js. Structural design patterns are
    focused on providing ways to realize relationships between entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'In particular, in this chapter, we will examine the following patterns:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Proxy**: A pattern that allows us to control access to another object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Decorator**: A common pattern to augment the behavior of an existing object
    dynamically'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Adapter**: A pattern that allows us to access the functionality of an object
    using a different interface'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Throughout the chapter, we will also explore some interesting concepts such
    as **reactive programming** (**RP**), and we will also spend some time playing
    with LevelDB, a database technology that is commonly adopted in the Node.js ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be familiar with several scenarios in which
    structural design patterns can be useful and you will be able to implement them
    effectively in your Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **proxy** is an object that controls access to another object, called the
    **subject**. The proxy and the subject have an identical interface, and this allows
    us to swap one for the other transparently; in fact, the alternative name for
    this pattern is **surrogate**.
  prefs: []
  type: TYPE_NORMAL
- en: 'A proxy intercepts all or some of the operations that are meant to be executed
    on the subject, augmenting or complementing their behavior. *Figure 8.1* shows
    a schematic representation of this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B15729_08_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.1: Proxy pattern schematic'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 8.1* shows us how the proxy and the subject have the same interface,
    and how this is transparent to the client, who can use one or the other interchangeably.
    The proxy forwards each operation to the subject, enhancing its behavior with
    additional preprocessing or postprocessing.'
  prefs: []
  type: TYPE_NORMAL
- en: It's important to observe that we are not talking about proxying between classes;
    the Proxy pattern involves wrapping an actual instance of the subject, thus preserving
    its internal state.
  prefs: []
  type: TYPE_NORMAL
- en: 'A proxy can be useful in several circumstances, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data validation**: The proxy validates the input before forwarding it to
    the subject'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: The proxy verifies that the client is authorized to perform the
    operation, and it passes the request to the subject only if the outcome of the
    check is positive'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: The proxy keeps an internal cache so that the proxied operations
    are executed on the subject only if the data is not yet present in the cache'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lazy initialization**: If creating the subject is expensive, the proxy can
    delay it until it''s really necessary'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging**: The proxy intercepts the method invocations and the relative parameters,
    recoding them as they happen'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Remote objects**: The proxy can take a remote object and make it appear local'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are more Proxy pattern applications, but these should give us an idea
    of its purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for implementing proxies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When *proxying* an object, we can decide to intercept all of its methods or
    only some of them, while delegating the rest directly to the subject. There are
    several ways in which this can be achieved, and in this section, we will present
    some of them.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be working on a simple example, a `StackCalculator` class that looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This class implements a simplified version of a stack calculator. The idea of
    this calculator is to keep all operands (values) in a stack. When you perform
    an operation, for example a multiplication, the multiplicand and the multiplier
    are extracted from the stack and the result of the multiplication is pushed back
    into the stack. This is not too different from how the calculator application
    on your mobile phone is actually implemented.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example of how we might use `StackCalculator` to perform some multiplications
    and divisions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There are also some utility methods such as `peekValue()`, which allows us to
    peek the value at the top of the stack (the last value inserted or the result
    of the last operation), and `clear()`, which allows us to reset the stack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fun fact: In JavaScript, when you perform a division by 0, you get back a mysterious
    value called `Infinity`. In many other programming languages dividing by 0 is
    an illegal operation that results in the program panicking or throwing a runtime
    exception.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Our task in the next few sections will be to leverage the Proxy pattern to
    enhance a `StackCalculator` instance by providing a more conservative behavior
    for division by 0: rather than returning `Infinity`, we will throw an explicit
    error.'
  prefs: []
  type: TYPE_NORMAL
- en: Object composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Composition is a technique whereby an object is combined with another object
    for the purpose of extending or using its functionality. In the specific case
    of the Proxy pattern, a new object with the same interface as the subject is created,
    and a reference to the subject is stored internally in the proxy in the form of
    an instance variable or a closure variable. The subject can be injected from the
    client at creation time or created by the proxy itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example implements a safe calculator using object composition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `safeCalculator` object is a proxy for the original `calculator` instance.
    By invoking `multiply()` on `safeCalculator`, we will end up calling the same
    method on `calculator`. The same goes for `divide()`, but in this case we can
    see that, if we try to divide by zero, we will get different outcomes depending
    on whether we perform the division on the subject or on the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: To implement this proxy using composition, we had to intercept the methods that
    we were interested in manipulating (`divide()`), while simply delegating the rest
    of them to the subject (`putValue()`, `getValue()`, `peekValue()`, `clear()`,
    and `multiply()`).
  prefs: []
  type: TYPE_NORMAL
- en: Note that the calculator state (the values in the stack) is still maintained
    by the `calculator` instance; `safeCalculator` will only invoke methods on `calculator`
    to read or mutate the state as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'An alternative implementation of the proxy presented in the preceding code
    fragment might just use an object literal and a factory function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is simpler and more concise than the class-based one, but,
    once again, it forces us to delegate all the methods to the subject explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Having to delegate many methods for complex classes can be very tedious and
    might make it harder to implement these techniques. One way to create a proxy
    that delegates most of its methods is to use a library that generates all the
    methods for us, such as `delegates` ([nodejsdp.link/delegates](http://nodejsdp.link/delegates)).
    A more modern and native alternative is to use the `Proxy` object, which we will
    discuss later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Object augmentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Object augmentation** (or **monkey patching**) is probably the simplest and
    most common way of proxying just a few methods of an object. It involves modifying
    the subject directly by replacing a method with its proxied implementation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the context of our calculator example, this could be done as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This technique is definitely convenient when we need to proxy only one or a
    few methods. Did you notice that we didn't have to reimplement the `multiply()`
    method and all the other delegated methods here?
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, simplicity comes at the cost of having to mutate the `subject`
    object directly, which can be dangerous.
  prefs: []
  type: TYPE_NORMAL
- en: Mutations should be avoided at all costs when the subject is shared with other
    parts of the codebase. In fact, "monkey patching" the subject might create undesirable
    side effects that affect other components of our application. Use this technique
    only when the subject exists in a controlled context or in a private scope. If
    you want to appreciate why "monkey patching" is a dangerous practice, you could
    try to invoke a division by zero in the original `calculator` instance. If you
    do so, you will see that the original instance will now throw an error rather
    than returning `Infinity`. The original behavior has been altered, and this might
    have unexpected effects on other parts of the application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will explore the built-in `Proxy` object, which is a
    powerful alternative for implementing the Proxy pattern and more.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in Proxy object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The ES2015 specification introduced a native way to create powerful proxy objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are talking about the ES2015 `Proxy` object, which consists of a `Proxy`
    constructor that accepts a `target` and a `handler` as arguments:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, `target` represents the object on which the proxy is applied (the **subject**
    for our canonical definition), while `handler` is a special object that defines
    the behavior of the proxy.
  prefs: []
  type: TYPE_NORMAL
- en: The `handler` object contains a series of optional methods with predefined names
    called **trap methods** (for example, `apply`, `get`, `set`, and `has`) that are
    automatically called when the corresponding operations are performed on the proxy
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand how this API works, let''s see how we can use the `Proxy`
    object to implement our safe calculator proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation of the safe calculator proxy using the `Proxy` object,
    we adopted the `get` trap to intercept access to properties and methods of the
    original object, including calls to the `divide()` method. When access to `divide()`
    is intercepted, the proxy returns a modified version of the function that implements
    the additional logic to check for possible divisions by zero. Note that we can
    simply return all other methods and properties unchanged by using `target[property]`.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it is important to mention that the `Proxy` object inherits the prototype
    of the subject, therefore running `safeCalculator instanceof StackCalculator`
    will return `true`.
  prefs: []
  type: TYPE_NORMAL
- en: With this example, it should be clear that the `Proxy` object allows us to avoid
    mutating the subject while giving us an easy way to proxy only the bits that we
    need to enhance, without having to explicitly delegate all the other properties
    and methods.
  prefs: []
  type: TYPE_NORMAL
- en: Additional capabilities and limitations of the Proxy object
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: The `Proxy` object is a feature deeply integrated into the JavaScript language
    itself, which enables developers to intercept and customize many operations that
    can be performed on objects. This characteristic opens up new and interesting
    scenarios that were not easily achievable before, such as *meta-programming*,
    *operator overloading*, and *object virtualization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see another example to clarify this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we are creating a virtual array that contains all even numbers.
    It can be used as a regular array, which means we can access items in the array
    with the regular array syntax (for example, `evenNumbers[7]`), or check the existence
    of an element in the array with the `in` operator (for example, `2 in evenNumbers`).
    The array is considered *virtual* because we never store data in it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Looking at the implementation, this proxy uses an empty array as the target
    and then defines the `get` and `has` traps in the handler:'
  prefs: []
  type: TYPE_NORMAL
- en: The `get` trap intercepts access to the array elements, returning the even number
    for the given index
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `has` trap instead intercepts the usage of the `in` operator and checks
    whether the given number is even or not
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Proxy` object supports several other interesting traps such as `set`, `delete`,
    and `construct`, and allows us to create proxies that can be revoked on demand,
    disabling all the traps and restoring the original behavior of the `target` object.
  prefs: []
  type: TYPE_NORMAL
- en: Analyzing all these features goes beyond the scope of this chapter; what is
    important here is understanding that the `Proxy` object provides a powerful foundation
    for implementing the Proxy design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: If you are curious to discover all the capabilities and trap methods offered
    by the Proxy object, you can read more in the related MDN article at [nodejsdp.link/mdn-proxy](http://nodejsdp.link/mdn-proxy).
    Another good source is this detailed article from Google at [nodejsdp.link/intro-proxy](http://nodejsdp.link/intro-proxy).
  prefs: []
  type: TYPE_NORMAL
- en: 'While the `Proxy` object is a powerful functionality of the JavaScript language,
    it suffers from a very important limitation: the `Proxy` object cannot be fully
    *transpiled* or *polyfilled*. This is because some of the `Proxy` object traps
    can be implemented only at the runtime level and cannot be simply rewritten in
    plain JavaScript. This is something to be aware of if you are working with old
    browsers or old versions of Node.js that don''t support the `Proxy` object directly.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Transpilation**: Short for *transcompilation*. It indicates the action of
    compiling source code by translating it from one source programming language to
    another. In the case of JavaScript, this technique is used to convert a program
    using new capabilities of the language into an equivalent program that can also
    run on older runtimes that do not support these new capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: '**Polyfill**: Code that provides an implementation for a standard API in plain
    JavaScript and that can be imported in environments where this API is not available
    (generally older browsers or runtimes). `core-js` ([nodejsdp.link/corejs](http://nodejsdp.link/corejs))
    is one of the most complete polyfill libraries for JavaScript.'
  prefs: []
  type: TYPE_NORMAL
- en: A comparison of the different proxying techniques
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Composition can be considered a simple and *safe* way of creating a proxy because
    it leaves the subject untouched without mutating its original behavior. Its only
    drawback is that we have to manually delegate all the methods, even if we want
    to proxy only one of them. Also, we might have to delegate access to the properties
    of the subject.
  prefs: []
  type: TYPE_NORMAL
- en: Object properties can be delegated using `Object.defineProperty()`. Find out
    more at [nodejsdp.link/define-prop](http://nodejsdp.link/define-prop).
  prefs: []
  type: TYPE_NORMAL
- en: Object augmentation, on the other hand, modifies the subject, which might not
    always be ideal, but it does not suffer from the various inconveniences related
    to delegation. For this reason, between these two approaches, object augmentation
    is generally the preferred technique in all those circumstances in which modifying
    the subject is an option.
  prefs: []
  type: TYPE_NORMAL
- en: However, there is at least one situation where composition is almost necessary;
    this is when we want to control the initialization of the subject, for example,
    to create it only when needed (*lazy initialization*).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, the `Proxy` object is the go-to approach if you need to intercept function
    calls or have different types of access to object attributes, even dynamic ones.
    The `Proxy` object provides an advanced level of access control that is simply
    not available with the other techniques. For example, the `Proxy` object allows
    us to intercept the deletion of a key in an object and to perform property existence
    checks.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, it's worth highlighting that the `Proxy` object does not mutate
    the subject, so it can be safely used in contexts where the subject is shared
    between different components of the application. We also saw that with the `Proxy`
    object, we can easily perform delegation of all the methods and attributes that
    we want to leave unchanged.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we present a more realistic example leveraging the Proxy
    pattern and use it to compare the different techniques we have discussed so far
    for implementing this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a logging Writable stream
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To see the Proxy pattern applied to a real example, we will now build an object
    that acts as a proxy to a Writable stream, which intercepts all the calls to the
    `write()` method and logs a message every time this happens. We will use the `Proxy`
    object to implement our proxy. Let''s write our code in a file called `logging-writable.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we created a factory that returns a proxied version
    of the `writable` object passed as an argument. Let''s see what the main points
    of the implementation are:'
  prefs: []
  type: TYPE_NORMAL
- en: We create and return a proxy for the original `writable` object using the ES2015
    `Proxy` constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We use the `get` trap to intercept access to the object properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We check whether the property accessed is the `write` method. If that is the
    case, we return a function to proxy the original behavior.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The proxy implementation logic here is simple: we extract the current `chunk`
    from the list of arguments passed to the original function, we log the content
    of the chunk, and finally, we invoke the original method with the given list of arguments.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We return unchanged any other property.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can now use this newly created function and test our proxy implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The proxy did not change the original interface of the stream or its external
    behavior, but if we run the preceding code, we will now see that every chunk that
    is written into the `writableProxy` stream is transparently logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Change observer with Proxy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Change Observer pattern** is a design pattern in which an object (the
    subject) notifies one or more observers of any state changes, so that they can
    "react" to changes as soon as they happen.
  prefs: []
  type: TYPE_NORMAL
- en: Although very similar, the Change Observer pattern should not be confused with
    the Observer pattern discussed in *Chapter 3*, *Callbacks and Events*. The Change
    Observer pattern focuses on allowing the detection of property changes, while
    the Observer pattern is a more generic pattern that adopts an event emitter to
    propagate information about events happening in the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proxies turn out to be quite an effective tool to create observable objects.
    Let''s see a possible implementation with `create-observable.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, `createObservable()` accepts a `target` object (the object
    to observe for changes) and an `observer` (a function to invoke every time a change
    is detected).
  prefs: []
  type: TYPE_NORMAL
- en: Here, we create the `observable` instance through an ES2015 Proxy. The proxy
    implements the `set` trap, which is triggered every time a property is set. The
    implementation compares the current value with the new one and, if they are different,
    the target object is mutated, and the observer gets notified. When the observer
    is invoked, we pass an object literal that contains information related to the change
    (the name of the property, the previous value, and the current value).
  prefs: []
  type: TYPE_NORMAL
- en: This is a simplified implementation of the Change Observer pattern. More advanced
    implementations support multiple observers and use more traps to catch other types
    of mutation, such as field deletions or changes of prototype. Moreover, our implementation
    does not recursively create proxies for nested objects or arrays—a more advanced
    implementation takes care of these cases as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see now how we can take advantage of observable objects with a trivial
    invoice application where the invoice total is updated automatically based on
    observed changes in the various fields of the invoice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous example, an invoice is composed of a `subtotal` value, a `discount`
    value, and a `tax` value. The total amount can be calculated from these three
    values. Let''s discuss the implementation in greater detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We declare a function that calculates the total for a given invoice, then we
    create an `invoice` object and a value to hold the `total` for it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Here we create an observable version of the `invoice` object. Every time there
    is a change in the original invoice object, we recalculate the total and we also
    print some logs to keep track of the changes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we apply some changes to the observable invoice. Every time we mutate
    the `obsInvoice` object the observer function is triggered, the total gets updated,
    and some logs are printed on the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we run this example, we will see the following output in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we could make the total calculation logic arbitrarily complicated,
    for instance, by introducing new fields in the computation (shipping costs, other
    taxes, and so on). In this case, it will be fairly trivial to introduce the new
    fields in the `invoice` object and update the `calculateTotal()` function. Once
    we do that, every change to the new properties will be observed and the `total`
    will be kept up to date with every change.
  prefs: []
  type: TYPE_NORMAL
- en: Observables are the cornerstone of **reactive programming** (**RP**) and **functional
    reactive programming** (**FRP**). If you are curious to know more about these
    styles of programming check out the *Reactive Manifesto*, at [nodejsdp.link/reactive-manifesto](http://nodejsdp.link/reactive-manifesto).
  prefs: []
  type: TYPE_NORMAL
- en: In the wild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Proxy pattern and more specifically the Change Observer pattern are widely
    adopted patterns, which can be found on backend projects and libraries as well
    as in the frontend world. Some popular projects that take advantage of these patterns
    include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: LoopBack ([nodejsdp.link/loopback](http://nodejsdp.link/loopback)) is a popular
    Node.js web framework that uses the Proxy pattern to provide the capability to
    intercept and enhance method calls on controllers. This capability can be used
    to build custom validation or authentication mechanisms.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Version 3 of Vue.js ([nodejsdp.link/vue](http://nodejsdp.link/vue)), a very
    popular JavaScript reactive UI framework, has reimplemented observable properties
    using the Proxy pattern with the `Proxy` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MobX ([nodejsdp.link/mobx](http://nodejsdp.link/mobx)) is a famous reactive
    state management library commonly used in frontend applications in combination
    with React or Vue.js. Like Vue.js, MobX implements reactive observables using
    the `Proxy` object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Decorator is a structural design pattern that consists in dynamically augmenting
    the behavior of an existing object. It's different from classical inheritance,
    because the behavior is not added to all the objects of the same class, but only
    to the instances that are explicitly decorated.
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementation-wise, it is very similar to the Proxy pattern, but instead of
    enhancing or modifying the behavior of the existing interface of an object, it
    augments it with new functionalities, as described in *Figure 8.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a cell phone  Description automatically generated](img/B15729_08_02.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.2: Decorator pattern schematic'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.2*, the `Decorator` object is extending the `Component` object
    by adding the `methodC()` operation. The existing methods are usually delegated
    to the decorated object without further processing but, in some cases, they might
    also be intercepted and augmented with extra behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Techniques for implementing decorators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although proxy and decorator are conceptually two different patterns with different
    intents, they practically share the same implementation strategies. We will review
    them shortly. This time we want to use the Decorator pattern to be able to take
    an instance of our `StackCalculator` class and "decorate it" so that it also exposes
    a new method called `add()`, which we can use to perform additions between two
    numbers. We will also use the decorator to intercept all the calls to the `divide()`
    method and implement the same division-by-zero check that we already saw in our
    `SafeCalculator` example.
  prefs: []
  type: TYPE_NORMAL
- en: Composition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using composition, the decorated component is wrapped around a new object that
    usually inherits from it. The decorator in this case simply needs to define the
    new methods, while delegating the existing ones to the original component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: If you remember our composition implementation for the Proxy pattern, you can
    probably see that the code here looks quite similar.
  prefs: []
  type: TYPE_NORMAL
- en: We created the new `add()` method and enhanced the behavior of the original
    `divide()` method (effectively replicating the feature we saw in the previous
    `SafeCalculator` example). Finally, we delegated the `putValue()`, `getValue()`,
    `peekValue()`, `clear()`, and `multiply()` methods to the original subject.
  prefs: []
  type: TYPE_NORMAL
- en: Object augmentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Object decoration** can also be achieved by simply attaching new methods
    directly to the decorated object (monkey patching), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this example, `calculator` and `enhancedCalculator` reference the
    same object (`calculator == enhancedCalculator`). This is because `patchCalculator()`
    is mutating the original `calculator` object and then returning it. You can confirm
    this by invoking `calculator.add()` or `calculator.divide()`.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating with the Proxy object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'It''s possible to implement object decoration by using the `Proxy` object.
    A generic example might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If we were to compare these different implementations, the same caveats discussed
    during the analysis of the Proxy pattern would also apply for the decorator. Let's
    focus instead on practicing the pattern with a real-life example!
  prefs: []
  type: TYPE_NORMAL
- en: Decorating a LevelUP database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start coding the next example, let's say a few words about **LevelUP**,
    the module that we are now going to work with.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing LevelUP and LevelDB
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**LevelUP** ([nodejsdp.link/levelup](http://nodejsdp.link/levelup)) is a Node.js
    wrapper around Google''s **LevelDB**, a key-value store originally built to implement
    IndexedDB in the Chrome browser, but it''s much more than that. LevelDB has been
    defined as the "Node.js of databases" because of its minimalism and extensibility.
    Like Node.js, LevelDB provides blazingly fast performance and only the most basic
    set of features, allowing developers to build any kind of database on top of it.'
  prefs: []
  type: TYPE_NORMAL
- en: The Node.js community, and in this case Rod Vagg, did not miss the chance to
    bring the power of this database into the Node.js world by creating LevelUP. Born
    as a wrapper for LevelDB, it then evolved to support several kinds of backends,
    from in-memory stores, to other NoSQL databases such as Riak and Redis, to web
    storage engines such as IndexedDB and localStorage, allowing us to use the same
    API on both the server and the client, opening up some really interesting scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Today, there is a vast ecosystem around LevelUP made of plugins and modules
    that extend the tiny core to implement features such as replication, secondary
    indexes, live updates, query engines, and more. Complete databases were also built
    on top of LevelUP, including CouchDB clones such as PouchDB ([nodejsdp.link/pouchdb](http://nodejsdp.link/pouchdb)),
    and even a graph database, LevelGraph ([nodejsdp.link/levelgraph](http://nodejsdp.link/levelgraph)),
    which can work both on Node.js and the browser!
  prefs: []
  type: TYPE_NORMAL
- en: Find out more about the LevelUP ecosystem at [nodejsdp.link/awesome-level](http://nodejsdp.link/awesome-level).
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a LevelUP plugin
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next example, we are going to show you how we can create a simple plugin
    for LevelUP using the Decorator pattern, and in particular, the object augmentation
    technique, which is the simplest but also the most pragmatic and effective way
    to decorate objects with additional capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: For convenience, we are going to use the `level` package ([nodejsdp.link/level](http://nodejsdp.link/level)),
    which bundles both `levelup` and the default adapter called `leveldown`, which
    uses LevelDB as the backend.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we want to build is a plugin for LevelUP that allows us to receive notifications
    every time an object with a certain pattern is saved into the database. For example,
    if we subscribe to a pattern such as `{a: 1}`, we want to receive a notification
    when objects such as `{a: 1, b: 3}` or `{a: 1, c: ''x''}` are saved into the database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start to build our small plugin by creating a new module called `level-subscribe.js`.
    We will then insert the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it for our plugin; it''s extremely simple. Let''s briefly analyze the
    preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: We decorate the `db` object with a new method named `subscribe()`. We simply
    attach the method directly to the provided `db` instance (object augmentation).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We listen for any `put` operation performed on the database.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We perform a very simple pattern-matching algorithm, which verifies that all
    the properties in the provided pattern are also available in the data being inserted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we have a match, we notify the listener.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s now write some code to try out our new plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is how the preceding code works:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we initialize our LevelUP database, choosing the directory where the
    files are stored and the default encoding for the values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we attach our plugin, which decorates the original `db` object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, we are ready to use the new feature provided by our plugin,
    which is the `subscribe()` method, where we specify that we are interested in
    all the objects with `doctype: ''tweet''` and `language: ''en''`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we save some values in the database using `put`. The first call triggers
    the callback associated with our subscription and we should see the stored object
    printed to the console. This is because, in this case, the object matches the
    subscription. The second call does not generate any output because the stored
    object does not match the subscription criteria.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This example shows a real application of the Decorator pattern in its simplest
    implementation, which is object augmentation. It may look like a trivial pattern,
    but it has undoubted power if used appropriately.
  prefs: []
  type: TYPE_NORMAL
- en: For simplicity, our plugin works only in combination with `put` operations,
    but it can be easily expanded to work even with `batch` operations ([nodejsdp.link/levelup-batch](http://nodejsdp.link/levelup-batch)).
  prefs: []
  type: TYPE_NORMAL
- en: In the wild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For more examples of how decorators are used in the real world, you can inspect
    the code of some more LevelUP plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '`level-inverted-index` ([nodejsdp.link/level-inverted-index](http://nodejsdp.link/level-inverted-index)):
    This is a plugin that adds inverted indexes to a LevelUP database, allowing us
    to perform simple text searches across the values stored in the database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`levelplus` ([nodejsdp.link/levelplus](http://nodejsdp.link/levelplus)): This
    is a plugin that adds atomic updates to a LevelUP database'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Aside from LevelUP plugins, the following projects are also good examples of
    the adoption of the Decorator pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '`json-socket` ([nodejsdp.link/json-socket](http://nodejsdp.link/json-socket)):
    This module makes it easier to send JSON data over a TCP (or a Unix) socket. It
    is designed to decorate an existing instance of `net.Socket`, which gets enriched
    with additional methods and behaviors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`fastify` ([nodejsdp.link/fastify](http://nodejsdp.link/fastify)) is a web
    application framework that exposes an API to decorate a Fastify server instance
    with additional functionality or configuration. With this approach, the additional
    functionality is made accessible to different parts of the application. This is
    a quite generalized implementation of the Decorator pattern. Check out the dedicated
    documentation page to find out more at [nodejsdp.link/fastify-decorators](http://nodejsdp.link/fastify-decorators).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The line between proxy and decorator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point in the book, you might have some legitimate doubts about the differences
    between the Proxy and the Decorator patterns. These two patterns are indeed very
    similar and they can sometimes be used interchangeably.
  prefs: []
  type: TYPE_NORMAL
- en: In its classic incarnation, the Decorator pattern is defined as a mechanism
    that allows us to enhance an existing object with new behavior, while the Proxy
    pattern is used to control access to a concrete or virtual object.
  prefs: []
  type: TYPE_NORMAL
- en: There is a conceptual difference between the two patterns, and it's mostly based
    on the way they are used at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: You can look at the Decorator pattern as a wrapper; you can take different types
    of objects and decide to wrap them with a decorator to enhance their capabilities
    with extra functionality. A proxy, instead, is used to control the access to an
    object and it does not change the original interface. For this reason, once you
    have created a proxy instance, you can pass it over to a context that expects
    the original object.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to implementation, these differences are generally much more obvious
    with strongly typed languages where the type of the objects you pass around is
    checked at compile time. In the Node.js ecosystem, given the dynamic nature of
    the JavaScript language, the line between the Proxy and the Decorator patterns
    is quite blurry, and often the two names are used interchangeably. We have also
    seen how the same techniques can be used to implement both patterns.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with JavaScript and Node.js, our advice is to avoid getting bogged
    down with the nomenclature and the canonical definition of these two patterns.
    We encourage you to look at the class of problems that proxy and decorator solve
    as a whole and treat these two patterns as complementary and sometimes interchangeable
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: Adapter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Adapter pattern allows us to access the functionality of an object using
    a different interface.
  prefs: []
  type: TYPE_NORMAL
- en: A real-life example of an adapter would be a device that allows you to plug
    a USB Type-A cable into a USB Type-C port. In a generic sense, an adapter converts
    an object with a given interface so that it can be used in a context where a different
    interface is expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'In software, the Adapter pattern is used to take the interface of an object
    (the **adaptee**) and make it compatible with another interface that is expected
    by a given client. Let''s have a look at *Figure 8.3* to clarify this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![A screenshot of a cell phone  Description automatically generated](img/B15729_08_03.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8.3: Adapter pattern schematic'
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 8.3*, we can see how the adapter is essentially a wrapper for the
    adaptee, exposing a different interface. The diagram also highlights the fact
    that the operations of the adapter can also be a composition of one or more method
    invocations on the adaptee. From an implementation perspective, the most common
    technique is composition, where the methods of the adapter provide a bridge to
    the methods of the adaptee. This pattern is pretty straightforward, so let's immediately
    work on an example.
  prefs: []
  type: TYPE_NORMAL
- en: Using LevelUP through the filesystem API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now going to build an adapter around the LevelUP API, transforming it
    into an interface that is compatible with the core `fs` module. In particular,
    we will make sure that every call to `readFile()` and `writeFile()` will translate
    into calls to `db.get()` and `db.put()`. This way we will be able to use a LevelUP
    database as a storage backend for simple filesystem operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new module named `fs-adapter.js`. We will begin
    by loading the dependencies and exporting the `createFsAdapter()` factory that
    we are going to use to build the adapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will implement the `readFile()` function inside the factory and ensure
    that its interface is compatible with the one of the original function from the
    `fs` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we had to do some extra work to make sure that the behavior
    of our new function is as close as possible to the original `fs.readFile()` function.
    The steps performed by the function are described as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: To retrieve a file from the `db` instance, we invoke `db.get()`, using `filename`
    as a key, by making sure to always use its full path (using `resolve()`). We set
    the value of the `valueEncoding` option used by the database to be equal to any
    eventual `encoding` option received as an input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the key is not found in the database, we create an error with `ENOENT` as
    the error code, which is the code used by the original `fs` module to indicate
    a missing file. Any other type of error is forwarded to `callback` (for the scope
    of this example, we are adapting only the most common error condition).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the key-value pair is retrieved successfully from the database, we will return
    the value to the caller using the `callback`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The function that we created does not want to be a perfect replacement for the
    `fs.readFile()` function, but it definitely does its job in the most common situations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To complete our small adapter, let''s now see how to implement the `writeFile()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, we don't have a perfect wrapper in this case either. We are ignoring
    some options such as file permissions (`options.mode`), and we are forwarding
    any error that we receive from the database as is.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our new adapter is now ready. If we now write a small test module, we can try
    to use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses the original `fs` API to perform a few read and write
    operations on the filesystem, and should print something like the following to
    the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can try to replace the `fs` module with our adapter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Running our program again should produce the same output, except for the fact
    that no parts of the file that we specified are read or written using the filesystem
    API directly. Instead, any operation performed using our adapter will be converted
    into an operation performed on a LevelUP database.
  prefs: []
  type: TYPE_NORMAL
- en: The adapter that we just created might look silly; what's the purpose of using
    a database in place of the real filesystem? However, we should remember that LevelUP
    itself has adapters that enable the database to also run in the browser. One of
    these adapters is `level-js` ([nodejsdp.link/level-js](http://nodejsdp.link/level-js)).
    Now our adapter makes perfect sense. We could use something similar to allow code
    leveraging the `fs` module to run on both Node.js and a browser. We will soon
    realize that Adapter is an extremely important pattern when it comes to sharing
    code with the browser, as we will see in more detail in *Chapter 10*, *Universal
    JavaScript for Web Applications*.
  prefs: []
  type: TYPE_NORMAL
- en: In the wild
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are plenty of real-world examples of the Adapter pattern. We''ve listed
    some of the most notable examples here for you to explore and analyze:'
  prefs: []
  type: TYPE_NORMAL
- en: We already know that LevelUP is able to run with different storage backends,
    from the default LevelDB to IndexedDB in the browser. This is made possible by
    the various adapters that are created to replicate the internal (private) LevelUP
    API. Take a look at some of them to see how they are implemented at [nodejsdp.link/level-stores](http://nodejsdp.link/level-stores).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JugglingDB is a multi-database ORM and of course, multiple adapters are used
    to make it compatible with different databases. Take a look at some of them at
    [nodejsdp.link/jugglingdb-adapters](http://nodejsdp.link/jugglingdb-adapters).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: nanoSQL ([nodejsdp.link/nanosql](http://nodejsdp.link/nanosql)) is a modern
    multi-model database abstraction library that makes heavy usage of the Adapter
    pattern to support a significant variety of databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The perfect complement to the example that we created is `level-filesystem`
    ([nodejsdp.link/level-filesystem](http://nodejsdp.link/level-filesystem)), which
    is the proper implementation of the `fs` API on top of LevelUP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Structural design patterns are definitely some of the most widely adopted design
    patterns in software engineering and it is important to be confident with them.
    In this chapter, we explored the Proxy, the Decorator, and the Adapter patterns
    and we discussed different ways to implement these in the context of Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how the Proxy pattern can be a very valuable tool to control access to
    existing objects. In this chapter, we also mentioned how the Proxy pattern can
    enable different programming paradigms such as reactive programming using the
    Change Observer pattern.
  prefs: []
  type: TYPE_NORMAL
- en: In the second part of the chapter, we found out that the Decorator pattern is
    an invaluable tool to be able to add additional functionality to existing objects.
    We saw that its implementation doesn't differ much from the Proxy pattern and
    we explored some examples built around the LevelDB ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we discussed the Adapter pattern, which allows us to wrap an existing
    object and expose its functionality through a different interface. We saw that
    this pattern can be useful to expose a piece of existing functionality to a component
    that expects a different interface. In our examples, we saw how this pattern can
    be used to implement an alternative storage layer that is compatible with the
    interface provided by the `fs` module to interact with files.
  prefs: []
  type: TYPE_NORMAL
- en: 'Proxy, decorator and adapter are very similar, the difference between them
    can be appreciated from the perspective of the interface consumer: proxy provides
    the same interface as the wrapped object, decorator provides an enhanced interface,
    and adapter provides a different interface.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will complete our journey through traditional design
    patterns in Node.js by exploring the category of behavioral design patterns. This
    category includes important patterns such as the Strategy pattern, the Middleware
    pattern, and the Iterator pattern. Are you ready to discover behavioral design
    patterns?
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**8.1 HTTP client cache**: Write a proxy for your favorite HTTP client library
    that caches the response of a given HTTP request, so that if you make the same
    request again, the response is immediately returned from the local cache, rather
    than being fetched from the remote URL. If you need inspiration, you can check
    out the `superagent-cache` module ([nodejsdp.link/superagent-cache](http://nodejsdp.link/superagent-cache)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8.2 Timestamped logs**: Create a proxy for the `console` object that enhances
    every logging function (`log()`, `error()`, `debug()`, and `info()`) by prepending
    the current timestamp to the message you want to print in the logs. For instance,
    executing `consoleProxy.log(''hello'')` should print something like `2020-02-18T15:59:30.699Z
    hello` in the console.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8.3 Colored console output**: Write a decorator for the console that adds
    the `red(message)`, `yellow(message)`, and `green(message)` methods. These methods
    will have to behave like `console.log(message)` except they will print the message
    in red, yellow, or green, respectively. In one of the exercises from the previous
    chapter, we already pointed you to some useful packages to to create colored console
    output. If you want to try something different this time, have a look at `ansi-styles`
    ([nodejsdp.link/ansi-styles](http://nodejsdp.link/ansi-styles)).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8.4 Virtual filesystem**: Modify our LevelDB filesystem adapter example to
    write the file data in memory rather than in LevelDB. You can use an object or
    a `Map` instance to store the key-value pairs of filenames and the associated
    data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**8.5 The lazy buffer**: Can you implement `createLazyBuffer(size)`, a factory
    function that generates a virtual proxy for a `Buffer` of the given size? The
    proxy instance should instantiate a `Buffer` object (effectively allocating the
    given amount of memory) only when `write()` is being invoked for the first time.
    If no attempt to write into the buffer is made, no `Buffer` instance should be
    created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
