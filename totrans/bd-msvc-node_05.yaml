- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Knowing the Infrastructure of Microservices in Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding the infrastructure of microservices in Node.js is crucial for
    building scalable and maintainable applications. Microservices architecture breaks
    down a monolithic application into smaller, independently deployable services
    that communicate with each other over a network.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start this chapter by covering the infrastructure of microservices in
    Node.js for microservices development. The infrastructure for microservices in
    Node.js should be designed carefully while considering factors such as scalability,
    reliability, security, and ease of maintenance. Node.js is a popular choice for
    implementing microservices due to its non-blocking, event-driven architecture,
    which aligns well with the demands of distributed systems. However, the choice
    of technologies and tools should be based on the specific requirements of your
    project.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand the infrastructure of microservices
    in Node.js for microservices development and how to apply the concepts in your
    everyday work.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery and API gateways
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load balancing and service orchestration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containerization and orchestration and centralized logging and monitoring
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing and event-driven communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database integration and continuous integration and deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service discovery and API gateways
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to learn about services that need to discover and
    communicate with each other dynamically and how these services can help you create
    the next generation of applications while you exceed in your work. Service discovery
    and API gateways are critical components in the infrastructure of microservices
    architecture. They play essential roles in ensuring that microservices can communicate
    with each other effectively and that clients can access the services seamlessly.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll explore these concepts in more detail in the following subsections.
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Service discovery** is the process by which microservices locate and communicate
    with each other in a dynamic and distributed environment. As microservices can
    be deployed and scaled independently, their network locations (IP addresses and
    ports) can change frequently. Service discovery mechanisms solve this challenge
    by maintaining an up-to-date registry of available services and their locations.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how service discovery works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Service registry**: A service registry is a centralized database or service
    that keeps track of the available microservices and their network locations. Examples
    of service registries include **Consul** (designed to simplify the development
    and operation of microservices-based applications by providing features such as
    service discovery, health checking, and key-value storage), **etcd** (an open
    source distributed key-value store and configuration management system that is
    often used for building highly available, distributed systems), and **Netflix
    Eureka** (an open source service discovery and registration server that is part
    of the Netflix **Open Source Software** (**OSS**) ecosystem). Eureka was originally
    developed by Netflix to manage and monitor the availability of services in a microservices
    architecture. It provides a simple and efficient way for microservices to locate
    and communicate with each other in a dynamic and distributed environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Registration**: When a microservice starts up, it registers itself with the
    service registry, providing information about its location, health, and available
    endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lookup**: When one microservice needs to communicate with another, it queries
    the service registry to discover the location of the target microservice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: Service discovery often includes load balancing, where
    incoming requests are distributed among multiple instances of the same microservice
    to ensure high availability and scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knowing how these concepts and tools work can help you and your team build better
    software and contribute to high-quality code, security, and compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.1* illustrates the process of service discovery:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Service discovery (image by vectorjuice on Freepik)](img/B14980_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Service discovery (image by vectorjuice on Freepik)'
  prefs: []
  type: TYPE_NORMAL
- en: Service discovery, with its tools and concepts, can lead to a higher understanding
    of microservices, which can also help you learn how to coordinate with your team
    of developers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn about API gateways.
  prefs: []
  type: TYPE_NORMAL
- en: API gateways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An **API gateway** is a server or service that acts as an entry point for clients
    (such as web browsers, mobile apps, or other microservices) to access the functionalities
    of a microservices-based application.
  prefs: []
  type: TYPE_NORMAL
- en: 'It serves several essential purposes, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Routing**: The API gateway routes client requests to the appropriate microservices
    based on the request’s URL or other criteria. It acts as a reverse proxy, forwarding
    requests to the relevant service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: In addition to service discovery, the API gateway often
    performs load balancing to evenly distribute incoming requests among multiple
    instances of a microservice.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication and authorization**: The API gateway can handle authentication
    and authorization, ensuring that only authorized users or systems can access specific
    endpoints.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Request transformation**: Request transformation can modify or transform
    incoming requests and outgoing responses to match the expected formats of microservices,
    abstracting away differences between services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: API gateways can cache responses to reduce the load on microservices
    and improve response times for frequently requested data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Logging and monitoring**: Centralized logging and monitoring can be implemented
    via the API gateway to collect data on incoming requests and responses, providing
    visibility into system behavior.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: API gateways can provide security features such as rate limiting,
    DDoS protection, and **web application firewall** (**WAF**) capabilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: API gateways can support versioning of APIs, allowing for backward
    compatibility as services evolve.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When we develop microservices in Node.js, we can use these tools and concepts
    to increase the efficiency and effectiveness of developers in creating software.
  prefs: []
  type: TYPE_NORMAL
- en: '**NGINX** can function as an API gateway, providing a unified entry point for
    clients to interact with different microservices. This involves the following
    aspects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API routing**: NGINX can route requests to specific microservices based on
    the API endpoint. This simplifies the client experience by presenting a single
    entry point for various microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Security**: NGINX can handle authentication, authorization, and SSL termination,
    enhancing the security of microservices by centralizing these concerns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Authentication** is the process of verifying the identity of a user, service,
    or system. In a microservices architecture, each service must handle authentication
    to ensure that only authorized entities can access its resources.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are some techniques for authentication:'
  prefs: []
  type: TYPE_NORMAL
- en: '**JSON Web Tokens** (**JWTs**): You can use JWTs to encode user information
    and create tokens that can be verified by each microservice. Then, you can verify
    tokens in each microservice before processing requests.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**OAuth 2.0**: You can implement OAuth 2.0 for secure, token-based authentication.
    OAuth allows third-party services to access resources on behalf of a user.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Passport.js` library to implement authentication strategies in Node.js. It
    supports various authentication mechanisms, including local authentication, OAuth,
    and OpenID Connect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of this when using a JWT:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Authorization** is the process of determining what actions a user or service
    is allowed to perform. It is usually based on the authenticated user’s role or
    specific permissions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following techniques can be used for authorization:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Role-based access control** (**RBAC**): You can assign roles to users and
    define permissions associated with each role. You can also check the user’s role
    before allowing access to certain resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Claims-based authorization**: You can use claims embedded in tokens to convey
    information about the user’s permissions. Microservices can then be authorized
    based on these claims.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware for authorization**: You can implement middleware functions in
    each microservice to check whether the authenticated user has the required permissions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s an example of this using RBAC:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '*Figure 5**.2* illustrates the concept of an API gateway:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.2: API gateway](img/B14980_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.2: API gateway'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, service discovery and API gateways are integral components of microservices
    infrastructure, enabling effective communication between services and providing
    a unified entry point for clients. These components enhance the scalability, reliability,
    security, and manageability of microservices-based applications, making them easier
    to develop and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand these concepts, let’s learn about load balancing and
    service orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing and service orchestration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Load balancing and service orchestration are essential components in the architecture
    of microservices-based applications. They both contribute to the scalability,
    availability, and efficient operation of a distributed system.
  prefs: []
  type: TYPE_NORMAL
- en: Load balancing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Load balancing** is the practice of distributing incoming network traffic
    across multiple instances of a service to ensure that no single instance is overwhelmed
    with requests, thereby optimizing resource utilization and improving system reliability.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In a microservices architecture, load balancing is crucial because it helps
    achieve the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**High availability**: Load balancers distribute traffic evenly across healthy
    service instances. If one instance fails or becomes overloaded, traffic is automatically
    redirected to other instances, ensuring uninterrupted service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: As the demand for a microservice increases, additional instances
    can be added, and the load balancer will automatically distribute traffic to these
    new instances, effectively scaling the application horizontally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource utilization**: Load balancers can monitor the health and performance
    of service instances and make routing decisions based on factors such as response
    times and server load. This ensures that each instance is used efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Failover**: Load balancers can detect when a service instance becomes unhealthy
    and stop sending traffic to it. This helps in isolating issues and maintaining
    the overall system’s integrity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Some common load balancing strategies are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Round-robin**: This is a simple and widely used load balancing algorithm
    that distributes incoming network traffic or requests evenly across a group of
    backend servers or resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Least connections**: This is a load balancing algorithm that’s used by load
    balancers to distribute incoming network traffic or requests to a group of backend
    servers or resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IP hashing**: Also known as *IP-based load balancing* or *IP hash load balancing*,
    PI hashing is a technique that’s used by load balancers to distribute incoming
    network traffic or requests to a group of backend servers or resources based on
    the source or destination IP address of the requests'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weighted distribution**: This refers to the practice of allocating resources
    or traffic among different instances or replicas of a microservice based on their
    relative weights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Load balancing is crucial in microservices architectures where multiple instances
    of a service may exist. NGINX supports the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Round-robin load balancing**: Distributes incoming requests evenly among
    the available microservice instances.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Health checks**: NGINX can perform health checks to identify and route traffic
    away from unhealthy instances, ensuring better reliability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'NGINX acts as a **reverse proxy**, sitting between client applications and
    microservices. This offers several advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Load balancing**: NGINX can distribute incoming requests among multiple instances
    of a microservice, ensuring even load distribution and improved system performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Routing**: NGINX can route requests to different microservices based on factors
    such as URL paths, headers, or other parameters. This enables efficient handling
    of various functionalities distributed across microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 5**.3* illustrates load balancing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3: Load balancing (image by vectorjuice on Freepik)](img/B14980_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.3: Load balancing (image by vectorjuice on Freepik)'
  prefs: []
  type: TYPE_NORMAL
- en: Popular load balancing solutions include hardware load balancers and software-based
    solutions such as NGINX and HAProxy, as well as cloud-based load balancers provided
    by cloud service providers.
  prefs: []
  type: TYPE_NORMAL
- en: With these concepts covered, next, we’ll look at service orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Service orchestration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Service orchestration** involves coordinating and managing the execution
    of multiple microservices to fulfill a specific business process or workflow.
    It ensures that the individual services work together harmoniously to achieve
    a higher-level objective.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how service orchestration contributes to a microservices architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Complex workflow handling**: Microservices often need to collaborate to perform
    complex tasks or workflows. Service orchestration defines the sequence of microservices
    to be executed and manages their interactions to complete the workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralized control**: Service orchestration typically involves a central
    orchestrator component that coordinates the execution of microservices, thereby
    handling error recovery and ensuring the correct order of operations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous communication**: Microservices can communicate with each other
    through asynchronous message passing, enabling loosely coupled interactions. Service
    orchestration manages the messaging and data flow between services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long-running processes**: For long-running processes that span multiple microservices,
    service orchestration ensures that steps are executed in the correct order and
    that data consistency is maintained.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic scaling**: Service orchestration can dynamically scale microservices
    based on the workload, ensuring that resources are allocated optimally to handle
    varying demands.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service orchestration can be implemented using various tools and patterns, including
    workflow engines, message queues, and choreography-based approaches. Tools such
    as Apache Camel, Netflix Conductor, and Kubernetes-based orchestration solutions
    are commonly used in microservices environments.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information
  prefs: []
  type: TYPE_NORMAL
- en: '*Apache Camel* is an open source integration framework that provides a lightweight,
    easy-to-use platform for routing and mediating message exchanges between different
    systems. You can access its documentation at [https://camel.apache.org/docs/](https://camel.apache.org/docs/).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Netflix Conductor* allows developers to design, execute, and manage complex
    workflows in a scalable and reliable manner. You can access its documentation
    at [https://orkes.io/content/](https://orkes.io/content/).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Kubernetes orchestration* is a platform for container orchestration that allows
    you to build application services that span multiple containers, schedule containers
    across a cluster, scale those containers, and manage their health over time. You
    can access its documentation at [https://kubernetes.io/docs/home/supported-doc-versions](https://kubernetes.io/docs/home/supported-doc-versions).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.4* depicts service orchestration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4: Service orchestration (image by Freepik)](img/B14980_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.4: Service orchestration (image by Freepik)'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, load balancing and service orchestration are fundamental components
    of microservices architecture. Load balancing ensures the efficient distribution
    of traffic and resource utilization, while service orchestration manages the coordination
    and execution of microservices to complete complex workflows and business processes.
    Together, these components contribute to the scalability, availability, and reliability
    of microservices-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can continue to the next section, in which we will talk about containerization
    and orchestration and centralized logging and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization and orchestration and centralized logging and monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Containerization and orchestration and centralized logging and monitoring are
    two critical components in the infrastructure of microservices-based applications.
    They play pivotal roles in ensuring the efficient deployment, management, and
    monitoring of microservices.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with containerization and orchestration.
  prefs: []
  type: TYPE_NORMAL
- en: Containerization and orchestration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Containerization** involves packaging an application and its dependencies
    into a standardized unit called a **container**.'
  prefs: []
  type: TYPE_NORMAL
- en: Orchestration refers to the process of automatically managing containerized
    applications. It involves deploying, scaling, load balancing, and maintaining
    containers across a cluster of machines. Kubernetes is the most popular container
    orchestration platform, but others, such as Docker Swarm and Apache Mesos, also
    exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how containerization and orchestration benefit microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Isolation**: Containers provide process isolation, ensuring that microservices
    do not interfere with each other, making it easier to maintain consistent environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Portability**: Containers can run on any platform that supports containerization,
    making it possible to move microservices across development, testing, and production
    environments seamlessly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resource efficiency**: Orchestration platforms such as Kubernetes automate
    the deployment and scaling of containers, optimizing resource utilization and
    ensuring that microservices have the required resources when needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**High availability**: Orchestration platforms monitor the health of microservices
    and can automatically replace failed instances, ensuring high availability and
    fault tolerance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scaling**: Microservices can be easily scaled up or down by adjusting the
    number of container replicas. This is crucial for handling variable workloads.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Containers encapsulate the application code, runtime, system libraries, and
    settings, ensuring consistency and portability across different environments.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information
  prefs: []
  type: TYPE_NORMAL
- en: '**Docker** is an open-source platform that allows you to automate the deployment,
    scaling, and management of applications using containerization and is a widely
    used containerization platform.'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.5* illustrates containerization and orchestration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5: Full-stack development process (image by vectorjuice on Freepik)](img/B14980_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.5: Full-stack development process (image by vectorjuice on Freepik)'
  prefs: []
  type: TYPE_NORMAL
- en: Containerization and orchestration can help ship software that will run on every
    platform and in every system. By automatically managing containerization, you
    can achieve greater versatility in deployment.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about centralized logging and monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Centralized logging and monitoring
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Centralized logging and monitoring systems** collect and analyze data from
    microservices and their environments. These systems help in diagnosing issues,
    optimizing performance, and ensuring the health of microservices- applications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at some of the common components of these systems include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Log collectors**: These are agents or services that gather logs generated
    by microservices and forward them to a central location.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log aggregators**: These are systems that consolidate logs from various sources,
    making it easier to search, analyze, and visualize log data. Examples include
    Elasticsearch, Fluentd, and Logstash.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Metrics and monitoring**: Tools such as Prometheus and Grafana (two popular
    open source tools used for monitoring and visualizing metrics and time series
    data) are used to collect and display real-time performance metrics from microservices.
    They provide insights into the behavior of the application and its components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Alerting**: Monitoring systems can generate alerts based on predefined thresholds,
    allowing operations teams to respond to issues promptly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Tracing**: Distributed tracing tools such as Jaeger and Zipkin (two distributed
    tracing systems that are used to monitor and troubleshoot complex, microservices-based
    architectures) help track the flow of requests across microservices, making it
    easier to identify bottlenecks and latency issues.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional information
  prefs: []
  type: TYPE_NORMAL
- en: '*Elasticsearch* is a highly scalable open source search and analytics engine
    built on top of Apache Lucene. You can access its documentation at [https://www.elastic.co/guide/index.html](https://www.elastic.co/guide/index.html).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Fluentd* is an open source data collector designed to unify data collection
    and consumption for better analysis and insights. You can access its documentation
    at [https://docs.fluentd.org/](https://docs.fluentd.org/).'
  prefs: []
  type: TYPE_NORMAL
- en: '*Logstash* is an open source data processing pipeline that allows you to collect,
    process, and ingest data from various sources into different output destinations
    (ELK Stack). You can access its documentation at [https://www.elastic.co/guide/en/logstash/current/introduction.html](https://www.elastic.co/guide/en/logstash/current/introduction.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Centralized logging and monitoring offer several benefits, including improved
    visibility, scalability, access to historical data, and increased efficiency in
    managing and analyzing logs and metrics.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.6* illustrates centralized logging and monitoring:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6: Centralized logging and monitoring (image by pch.vector on Freepik)](img/B14980_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.6: Centralized logging and monitoring (image by pch.vector on Freepik)'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, containerization and orchestration provide a scalable and efficient
    way to manage microservices, while centralized logging and monitoring ensure that
    these services operate reliably and can be effectively maintained. Together, these
    components form a robust foundation for microservices-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about distributed tracing and event-driven
    communication.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing and event-driven communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Distributed tracing and event-driven communication are two crucial concepts
    in the world of microservices and distributed systems. They address challenges
    related to monitoring and coordinating interactions between microservices. Let’s
    dive into these concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Distributed tracing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Distributed tracing** is a technique that’s used to track and monitor requests
    as they traverse multiple microservices in a distributed system. It provides end-to-end
    visibility into the flow of a request, allowing you to identify performance bottlenecks,
    troubleshoot issues, and optimize the system’s behavior.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how distributed tracing works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Instrumentation**: Each microservice in your architecture is instrumented
    to generate trace data. This typically involves adding trace headers to incoming
    requests and recording timing information for various operations within the service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Trace context**: The trace context is propagated along with the request as
    it moves from one microservice to another. This context includes a unique trace
    ID and span ID, which allows you to correlate activities across services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Centralized collector**: Trace data from all microservices is sent to a centralized
    collector or storage system. Popular options include Zipkin, Jaeger, and the Elastic
    Stack.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visualization and analysis**: Once the trace data has been collected, you
    can visualize it using specialized tools. This allows you to see the entire journey
    of a request, including service-to-service communication and the time spent at
    each step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved customer experience**: Once the trace data has been collected, you
    can visualize it using specialized tools. This allows you to see the entire journey
    of a request, including service-to-service communication and the time spent at
    each step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Distributed tracing is a powerful tool for performance optimization, root cause
    analysis, dependency mapping, and capacity planning in distributed systems. It
    provides detailed visibility into the behavior and performance of your applications,
    allowing you to make data-driven decisions for improving system performance and
    reliability.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will talk about event-driven communication.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven communication
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Event-driven communication** is a messaging pattern where microservices communicate
    asynchronously through the exchange of events or messages. This approach decouples
    services, allowing them to work independently and react to events triggered by
    other services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s how event-driven communication works:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event producers**: These are microservices that generate events or messages
    and publish them to a message broker or event bus. Events can represent various
    actions or state changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event consumers**: These are microservices that subscribe to specific events
    and react to them. They perform actions based on the information contained in
    the events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Message brokers**: These are middleware components that facilitate the exchange
    of messages between producers and consumers. Popular message brokers include Apache
    Kafka, RabbitMQ, and AWS SNS/SQS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, distributed tracing enhances your ability to monitor and diagnose
    the behavior of microservices, while event-driven communication fosters loose
    coupling and scalability in a microservices architecture. These concepts are valuable
    for building resilient and responsive distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to talk about database integration and continuous
    integration and deployment.
  prefs: []
  type: TYPE_NORMAL
- en: Database integration and continuous integration and deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database integration and **continuous integration/continuous deployment** (**CI/CD**)
    are critical aspects of a microservices architecture. They ensure that data is
    managed effectively and that changes to microservices are deployed efficiently
    and reliably.
  prefs: []
  type: TYPE_NORMAL
- en: Database integration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In a microservices architecture, each microservice typically has its own database
    or data store. This separation of data is known as *database* *per service*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key considerations for database integration in microservices:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Data consistency**: To ensure data consistency, three approaches are commonly
    used – two-phase commits, distributed transactions, and eventual consistency:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Two-phase commits**: **Two-phase commit** (**2PC**) is a protocol that ensures
    atomicity and consistency in distributed transactions. It involves coordinating
    multiple participants or resources to decide whether to commit or abort a transaction.
    The protocol consists of two phases: a preparation phase and a commit phase. In
    the preparation phase, each participant informs the coordinator whether it can
    successfully commit the transaction. In the commit phase, the coordinator sends
    a commit message to all participants if everyone agrees to commit, or an abort
    message if anyone disagrees. This ensures that all participants either commit
    or abort the transaction together.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed transactions**: Distributed transactions involve multiple independent
    systems or databases that participate in a single transaction. A transaction within
    a distributed environment has the same properties as a local transaction, including
    **Atomicity, Consistency, Isolation, and Durability** (**ACID**) properties. Distributed
    transaction management systems handle the coordination and synchronization between
    participating nodes to ensure the consistency of the entire transaction. These
    systems may employ protocols such as 2PC to coordinate the actions of the participants.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Eventual consistency**: Eventual consistency is a consistency model that’s
    used in distributed systems. It relaxes the strict consistency requirements of
    traditional ACID databases to provide high availability, scalability, and tolerance
    to network partitions. In an eventually consistent system, updates to replicated
    data occur asynchronously, allowing different replicas to diverge temporarily.
    However, the system guarantees that eventually, all replicas will converge to
    a consistent state. This approach prioritizes availability and performance over
    strict consistency, making it suitable for scenarios where data can tolerate temporary
    inconsistencies.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each approach has its advantages and trade-offs, depending on the specific requirements
    of the system. Two-phase commits and distributed transactions provide strong consistency
    guarantees but can introduce additional overhead and complexity due to coordination
    between participants. On the other hand, eventual consistency prioritizes availability
    and scalability but may lead to temporary data inconsistencies. The choice of
    approach depends on factors such as the system’s workload, performance requirements,
    and the level of consistency needed in the application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**APIs for data access**: Defining clear APIs for accessing and modifying data
    in each microservice’s database helps maintain control over data interactions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data synchronization**: This involves implementing data synchronization mechanisms
    or using event-driven architecture to propagate changes in one microservice’s
    data to others who may be interested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Caching**: You can use caching strategies to improve data retrieval performance
    and reduce the load on databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polyglot persistence**: This involves choosing the right database technology
    for each microservice’s specific data storage needs. Different microservices may
    use different types of databases (for example, relational, NoSQL, and so on) based
    on their requirements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data ownership**: You must clearly define which microservice is the authoritative
    source for specific types of data and ensure that data ownership is clear to prevent
    conflicts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database integration refers to strategies and techniques for managing data across
    these distributed databases and ensuring that data consistency and integrity are
    maintained.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.7* presents an example of database integration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7: Database integration (image from Freepik)](img/B14980_05_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.7: Database integration (image from Freepik)'
  prefs: []
  type: TYPE_NORMAL
- en: Database as a service can help developers develop faster while focusing on a
    single microservice and creating the best user experience for different users.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn more about CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: CI/CD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**CI/CD** is a set of practices and tools that enable the automated building,
    testing, and deployment of software changes, including those in microservices.
    CI/CD pipelines streamline the process of delivering updates to microservices-based
    applications and ensure that changes are integrated and tested seamlessly.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some key aspects of CI/CD in a microservices environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Automated builds**: Automate the process of building microservices and their
    dependencies whenever changes are pushed to a version control system (for example,
    Git).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Automated testing**: Run automated tests, including unit tests, integration
    tests, and end-to-end tests, to ensure that changes do not introduce regressions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artifact repository**: Store built artifacts (for example, Docker images)
    in a repository for easy access during deployment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Deployment automation**: Automate the deployment process to staging and production
    environments, including rolling updates, blue-green deployments, or canary releases.
    All these strategies are used in deployment automation to ensure smooth and safe
    application releases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Infrastructure as Code** (**IaC**): Define infrastructure components (for
    example, containers and virtual machines) as code to ensure consistent environments
    across stages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monitoring and rollback**: Integrate monitoring and alerting into the CI/CD
    pipeline to detect issues in production and enable rollback if necessary.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Versioning**: Manage versions of microservices and their dependencies to
    ensure that changes are tracked and can be rolled back if needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CI/CD pipelines help microservices teams deliver software changes quickly and
    reliably, reducing manual intervention and the risk of human error. They promote
    a culture of continuous improvement and allow teams to release new features and
    bug fixes more frequently.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 5**.8* illustrates the process of CI/CD:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8: CI/CD (image by vectorjuice on Freepik)](img/B14980_05_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.8: CI/CD (image by vectorjuice on Freepik)'
  prefs: []
  type: TYPE_NORMAL
- en: In summary, database integration strategies help manage data in a microservices
    architecture, ensuring consistency and coordination, while CI/CD pipelines streamline
    the development and deployment of microservices, enabling rapid and reliable software
    delivery. Both aspects are critical for the success of microservices-based applications.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a lot about services that need to discover and communicate
    with each other dynamically, load balancing and service orchestration, containerization
    and orchestration and centralized logging and monitoring, distributed tracing
    and event-driven communication, and database integration and CI/CD.
  prefs: []
  type: TYPE_NORMAL
- en: Building the infrastructure for microservices in Node.js involves carefully
    selecting and integrating these components and tools based on your specific requirements.
    It’s important to consider scalability, fault tolerance, observability, and ease
    of management when designing and implementing the infrastructure for your microservices
    architecture.
  prefs: []
  type: TYPE_NORMAL
- en: The infrastructure of microservices in Node.js is a critical foundation for
    developing scalable, distributed applications. It encompasses various components
    and practices that enable the effective operation of microservices-based systems.
  prefs: []
  type: TYPE_NORMAL
- en: This infrastructure is designed to handle the complexities of microservices
    architecture, ensuring they can work together cohesively, scale efficiently, and
    remain resilient in the face of failures. Node.js, with its non-blocking, event-driven
    architecture, is a popular choice for implementing microservices, making this
    infrastructure even more powerful and adaptable.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn how to design microservices architecture
    in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is service discovery?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are API gateways?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is load balancing?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is containerization?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
