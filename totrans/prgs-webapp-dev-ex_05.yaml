- en: The Service Worker Life Cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service worker life cycle is one of the most important concepts you must
    master in order to create proper service workers. This part of the service worker
    discipline is often overlooked and leads to many questions and frustrations expressed
    on sites such as Stack Overflow. But mastering the service worker life cycle allows
    you to seamlessly register and update service workers.
  prefs: []
  type: TYPE_NORMAL
- en: I think developers overlook the life cycle because it is not obvious until they
    hit an obstacle due to not understanding the service worker lifespan. The issue
    that confuses most developers is when a service worker becomes active.
  prefs: []
  type: TYPE_NORMAL
- en: Service workers obey a known life cycle that allows a new service worker to
    get itself ready without disrupting the current one. The life cycle is designed
    for the best user experience.
  prefs: []
  type: TYPE_NORMAL
- en: When a service worker is registered, it does not immediately seize control of
    the client. There are rules designed to minimize errors due to differences in
    code versions.
  prefs: []
  type: TYPE_NORMAL
- en: If a new service worker just took control of a client's context, there could
    be issues if the client or page is expecting the previous version. Even though
    the service worker operates on a separate thread, the UI code could have dependencies
    on service worker logic or cached assets. If the new version breaks the frontend,
    your user experience could go sideways.
  prefs: []
  type: TYPE_NORMAL
- en: 'The life cycle is designed to ensure that an in-scope page or task is controlled
    by the same service worker (or no service worker) throughout its session:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00063.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The life cycle consists of the registration, installation, and activation steps.
    The installation and activation events can have handlers bound to them so that
    they perform specific tasks.
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle also covers service worker updates, maybe the most important
    life cycle step, and unregistration. These last two tasks may not be used as often,
    but developers should still be familiar with how they work.
  prefs: []
  type: TYPE_NORMAL
- en: Each stage can be used for different process phases to manage the service worker,
    cached assets, and possibly state data. This chapter goes into details about the
    life cycle and how each phase can be used to make your application more performant
    and easier to manage.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topics will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Registering a service worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service worker clients
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Updating a service worker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service worker scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service worker updates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service worker events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a service worker is registered, the script is downloaded and then installed.
    At this point, it does not take over any active clients, including the page that
    registers the service worker. This is by design, to ensure that the client experience
    is not at risk of breaking due to changes in service worker code.
  prefs: []
  type: TYPE_NORMAL
- en: When a service worker becomes active, it claims or controls any clients within
    the worker's scope. Since there could be a previous worker controlling the clients,
    a new version does not automatically take over. This could lead to all sorts of
    trouble if there are logical differences between the two versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To avoid potential error states, the service worker specification errs on the
    side of caution. You can call the `skipWaiting` function in the install event
    handler to cause the new version to become active. When calling `skipWaiting`,
    you may still need to claim active clients:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If you use `skipWaiting`, it is best to call the method before you proceed to
    any pre-cache activities, because they may take a while. This is why the pre-cache
    logic is wrapped in a `waitUntil` method.
  prefs: []
  type: TYPE_NORMAL
- en: The `waitUntil` method holds the event handler open until the tasks have finished
    processing. Think about holding an elevator door open until everyone gets on or
    off the car. If you have extending processing, the service worker will not shut
    down.
  prefs: []
  type: TYPE_NORMAL
- en: If the service worker is idle for a long period of time, the active service
    worker is terminated to reduce CPU load and other resources it might otherwise
    consume. This is a good thing because continuous service workers would drain your
    devices battery if it ran continuously.
  prefs: []
  type: TYPE_NORMAL
- en: Beware, if you force a new service worker to become active, you need to make
    sure that it will not break your application. Users don't like it when the user
    experience breaks and error messages are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: A best practice is to execute some sort of testing to verify the integrity of
    your application. You may also want to warn the user that the application has
    been updated, possibly encouraging a manual refresh.
  prefs: []
  type: TYPE_NORMAL
- en: Never automatically refresh the page without warning the visitor as this could
    be confusing. The messaging API can be used to communicate with the user to coordinate
    the update.
  prefs: []
  type: TYPE_NORMAL
- en: If there are any errors during the service worker installation, the registration
    will fail and its life cycle will end. After installation, the service worker
    can become active. Once active, it can respond to function events such as `fetch`.
  prefs: []
  type: TYPE_NORMAL
- en: A common error during the installation handler is the cache. The `addAll` method
    may receive a 404 Not Found response. When this happens, the `addAll` method throws
    an exception. Since the install event cannot determine the error severity or context,
    it rolls back. The service worker never installs. This is represented by the red
    error block in the following flow chart.
  prefs: []
  type: TYPE_NORMAL
- en: You can catch exceptions and handle them gracefully. You can still make individual
    requests and cache those results. This requires a little more code, but gives
    you some insulation against a single request, causing the service worker install
    to fail. You can also make sure that good responses are cached, even when one
    fails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following flow chart demonstrates the core life cycle, but does not visualize
    how a service worker becomes active:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00064.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Registering a service worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Service workers must be registered from a web page. This is done in a normal
    UI script. Before you call the `register` method, you should feature detect service
    worker support. If supported, the `navigator` object has a `serviceWorker` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'If the browser supports service workers, you can then safely register your
    service worker. The `serviceWorker` object has a `register` method, so you need
    to supply a URL reference to the service worker script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `serviceWorker.register("sw path"[, options])` function accepts two parameters.
    The first is the path to the service worker. This path is relative to the site
    origin or root folder.
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter is optional, and is an object containing registration options.
    For now, the only option available is `scope`. An object was used to afford future
    modifications to the `register` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `scope` option is a string reference to the path that is relative to the
    site''s root the service worker is allowed to control. In the following example,
    a service worker is being registered for the human resources department. The same
    code would be used from the site''s root domain or the `hr` subfolder because
    all paths are relative to the site''s root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: You could register a service worker for any path within the site from anywhere.
    The scope is still limited to where the service worker physically resides. This
    means you could also register the marketing and finance service workers from the
    HR application. However, HR would not have the ability to manipulate anything
    in those applications and vice versa.
  prefs: []
  type: TYPE_NORMAL
- en: 'A script can be stored at any level at or above its designated scope. For example,
    if all of your application''s service workers were located in the site''s root
    folder, they would each need a different `scope` value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example demonstrates how the HR department's service worker is
    stored in the domain's root folder. Setting the scope to `/hr/` limits its scope
    to the `hr` folder and below.
  prefs: []
  type: TYPE_NORMAL
- en: Misunderstanding scope is one of the most common mistakes new service worker
    developers make. The first step is to accept that service workers are different
    from the client-side JavaScript we have been authoring for the past two decades.
  prefs: []
  type: TYPE_NORMAL
- en: You should make an effort to separate your service worker scripts from your
    traditional client script files. Place the service worker file of your register
    in your application's root folder. You can still import scripts from other folders,
    giving you the freedom to reuse code across application scopes.
  prefs: []
  type: TYPE_NORMAL
- en: '**Scope** is a valuable feature that guards against bad things happening due
    to external service providers or sites your customer may visit. You can think
    about it as a way to silo your logical business units. It is also a way to protect
    your applications from potential security threats if one application on your domain
    becomes compromised.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, a service worker is scoped to the folder the script resides in.
    The service worker is not allowed to control pages hosted at a higher folder level
    or in a sibling folder.
  prefs: []
  type: TYPE_NORMAL
- en: Service worker clients
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: I have mentioned the service worker clients several times in this chapter. The
    obvious definition is a browser tab with a site's page open. While this will be
    the case in most situations, it is not the only client type.
  prefs: []
  type: TYPE_NORMAL
- en: Because service workers execute in a separate context from a browser tab's UI
    thread, they can service multiple clients. This includes multiple tabs, push notifications,
    and background sync events. The latter two are clients without a traditional user
    interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'The service worker specification says ([https://w3c.github.io/ServiceWorker/#service-worker-client-concept](https://w3c.github.io/ServiceWorker/#service-worker-client-concept)):'
  prefs: []
  type: TYPE_NORMAL
- en: '"A service worker client is an environment."'
  prefs: []
  type: TYPE_NORMAL
- en: It goes on to define a series of potential client types. The concept of a service
    worker client is designed not to account for the obvious browser tab, but any
    process that might trigger a service worker event. For now, this includes push
    notifications and background sync events. The future is open as more features
    are being standardized to use the service worker infrastructure
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Chrome developer tools listing three different
    tabs that are open from the same site:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00065.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Each tab is a unique client. You can click the focus link to the right of any
    of the clients to immediately display the corresponding browser tab.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code allows you to check all of the service worker registrations
    for the current scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: You may be asking, why is there a `getRegistrations` method when you can only
    have a single service worker registered for a scope? The `getRegistrations` function
    returns a list of all registered service workers within the domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getRegistration` method works in a similar fashion but only returns the
    registered service worker for the current scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `getRegistration` method has an optional parameter where you can specify
    a URL and it returns the service worker registration for the worker that controls
    the URL's scope. For example, if you supplied `/marketing/`, the `registration.scope` would
    return `{domain}/marketing/`, assuming that you have a service worker registered
    for that scope.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker registration object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Registering a service worker creates an entry in a service worker registry that's
    maintained by the user agent. When you register or call the `getRegistration`
    or `getRegistrations` methods, they return a reference to the matching registration
    object(s).
  prefs: []
  type: TYPE_NORMAL
- en: 'The registration object contains the following members:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Properties**'
  prefs: []
  type: TYPE_NORMAL
- en: '`scope`: The service worker''s scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`installing`: If the service worker is installing, it returns a `ServiceWorker`
    object, otherwise it returns undefined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`waiting`: If the service worker is waiting, it returns a `ServiceWorker` object,
    otherwise it returns undefined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`active`: If the service worker is active or activating, it returns a `ServiceWorker`
    object, otherwise it returns undefined'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`navigationPreLoad`: Returns a reference to the service worker''s `preLoadManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`periodicSync`: Returns a reference to the service worker''s `PeriodicSyncManager`
    for background synchronization'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pushManager`: Returns a reference to the service worker''s `pushManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`: Returns a reference to the service worker''s `syncManager`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Methods**'
  prefs: []
  type: TYPE_NORMAL
- en: '`update`: Programmatically checks for a service worker update, bypassing caches'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`unregister`: Programmatically removes the service worker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getNotifications`: Returns a promise that resolves an array of notifications
    for the service worker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`showNotifications`: Displays a notification identified by the title'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event**'
  prefs: []
  type: TYPE_NORMAL
- en: '`onupdatefound`: Triggered any time there is a new service worker'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following is an example of how the `updatefound` event might be handled.
    When it triggers, there should be a `serviceworker` object present in the registration''s
    installing property. Here, the `serviceworker` object (`newWorker`) has had its
    state property interrogated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This event could be used to perform a series of logic to prepare the client
    for updating, including notifying the user to reload the browser to take advantage
    of the newer version.
  prefs: []
  type: TYPE_NORMAL
- en: The `update` and `unregister` methods will be covered in [Chapter 6](part0123.html#3L9L60-f12cdcca08b54960b3d271452dc7667d),
    *Mastering the Cache API – Managing Web Assets in a Podcast Application*. Let's
    take a moment to see how push notifications work.
  prefs: []
  type: TYPE_NORMAL
- en: Updating a service worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagrams show the sequence a service worker goes through during
    a replacement cycle. The first diagram shows how a new service worker is registered
    and lives *next to* an existing service worker. The new service worker is not
    active, but hangs around, waiting for all active clients to close:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00066.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the clients are closed, the initial service worker dies and the new service
    worker begins its new active role:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00067.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'After the new service worker becomes active, it is the only service worker
    that''s alive:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00068.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Service worker scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, service workers are limited to a single domain. The domain
    is your site's address, such as [https://podcast.love2dev.com/](https://podcast.love2dev.com/).
    This is a security feature. Limiting a service worker is known as the **service
    worker's scope**. This prevents external scripts from doing bad things to your
    site.
  prefs: []
  type: TYPE_NORMAL
- en: Imagine if your customer also visits your competition's web site, which installs
    a service worker. Without limits on service worker scope, they could conceivably
    manipulate your content or spy on you and your customer's private data.
  prefs: []
  type: TYPE_NORMAL
- en: In fact, a third-party script cannot register a service worker from a page on
    your site. This should keep external scripts and service providers from using
    service workers in conjunction with your domain.
  prefs: []
  type: TYPE_NORMAL
- en: A service worker is limited to the origin domain, and it is also limited to
    the folder in which it is physically located. This means you can register a service
    worker in any subfolder within the site's domain. The child script would control
    any request originating from its folder and below.
  prefs: []
  type: TYPE_NORMAL
- en: If another service worker were to register at a lower folder, then it would
    take control from that folder down and so on. Another way to think about a service
    worker's scope of control is downward, but not upward. A script residing in a
    subfolder does not execute in response to events triggered at the site's root.
  prefs: []
  type: TYPE_NORMAL
- en: Be careful about where your service worker file is located. The common practice
    is to store JavaScript files under a `/js` folder. This is fine for traditional
    UI JavaScript, but often leads to confusion when the service worker file is stored
    under the `js` folder. The best practice is to locate the service worker in your
    site's root folder or root folder of the scope it controls.
  prefs: []
  type: TYPE_NORMAL
- en: The scope determines which pages are controlled by the service worker. Once
    a page is controlled by a service worker, all HTTP requests originating from the
    page, regardless of the request URL, will trigger the service worker's fetch event.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the time, this means that your service worker is located in the top
    folder of your domain's website. But there are many scenarios where this would
    not be the case. Large sites and corporate intranet sites are often collections
    of different, isolated applications.
  prefs: []
  type: TYPE_NORMAL
- en: In architectures where there are different application islands, each application
    can have its own service worker. For example, an enterprise might have sibling
    sites for HR, finance, and marketing. Each one can have a separate service worker.
    The different service workers are isolated from each other and cannot access the
    other applications' scope.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these service workers could be registered anywhere within the site's
    root domain. This means you can register a child application's service worker
    from another scope. Each service worker is still limited in scope to the folder
    in which it resides and below.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows that four service workers can be registered
    for a single site, each controlling their own scope:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00069.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Service worker updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Updating the service worker file can be a tricky concept as well. There are
    several factors that determine when your service worker is updated. The update
    cycle does not start until the browser determines that there is a new service
    worker file available.
  prefs: []
  type: TYPE_NORMAL
- en: Once a service worker is registered, the browser treats the file like any other
    file when determining if there is a new version available. It makes a request
    to the server, which triggers a well-known cycle.
  prefs: []
  type: TYPE_NORMAL
- en: First, there is the local browser cache (not the service worker cache) for the
    file. If there is a local version available that has not become stale, it is retrieved.
    Next, the request is sent across the network to the server. If the server responds
    with a 304, it means that the browser has the most current version. If the file
    has not changed, then the service worker update cycle does not start. If there
    is a newer version, the service worker is updated.
  prefs: []
  type: TYPE_NORMAL
- en: The one exception to the basic update flow is a built-in guard against large
    Cache-Control header values. The browser will always retrieve the service worker
    from the server if it has not been updated within the past 24 hours.
  prefs: []
  type: TYPE_NORMAL
- en: Cache-Control headers tell the browser how long to persist a copy of a file
    in browser storage. For most assets, you want a long time to cache, for example,
    a year, because they don't change often. This could lead to a bad situation where
    your application is not updated.
  prefs: []
  type: TYPE_NORMAL
- en: For static assets such as style sheets and images, a common practice is to name
    them using a file hash generated value and assign a very long lifetime to them.
    This means any updates use a new file name and trigger a new request. You can
    certainly employ this strategy with service workers.
  prefs: []
  type: TYPE_NORMAL
- en: If you use the same service worker file name, then you should set a short lifetime.
    This can vary from a few minutes to a few hours. Anything over 24 hours will be
    ignored by the browser.
  prefs: []
  type: TYPE_NORMAL
- en: If the browser has not checked for a new service worker version within the past
    24 hours, it will force a server-side check. This was added to the spec as a safety
    precaution just in case you deploy a service worker that causes major problems
    and you cannot force an update programmatically.
  prefs: []
  type: TYPE_NORMAL
- en: This scenario could play out if you have a long cache time specified for the
    pages in your site that register the service worker and have done the same for
    the service worker script. This means that the worst-case scenario you would experience
    would a full day from the time the bad service worker was installed.
  prefs: []
  type: TYPE_NORMAL
- en: Not the best solution to a bad problem, but at least there is an ultimate fail-safe
    to bail you out. If you find yourself in this situation, you can still deploy
    the update immediately and users that have not installed the buggy version will
    be spared.
  prefs: []
  type: TYPE_NORMAL
- en: Service worker events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two types of service worker events: core and functional. Core messages
    are fundamental to what makes a service worker a service worker. Functional events
    can be thought of as extensions to the central service worker backbone:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Core Events**:'
  prefs: []
  type: TYPE_NORMAL
- en: Install
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Activate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Functional Events**:'
  prefs: []
  type: TYPE_NORMAL
- en: '`fetch`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sync`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`push`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these events can be used to trigger processing. The install and activate
    events are part of the life cycle. In [Chapter 7](part0152.html#4GULG0-f12cdcca08b54960b3d271452dc7667d), *Service
    Worker Caching Patterns*, we will dive into different caching patterns. The install
    and activate events are very useful to manage pre-caching assets and cleaning
    up your cache model.
  prefs: []
  type: TYPE_NORMAL
- en: When a new service worker is registered, the install event immediately triggers.
    The activate event triggers when the service worker becomes active. This means
    that any existing service worker is replaced with the new service worker.
  prefs: []
  type: TYPE_NORMAL
- en: The message event triggers when a message is sent from the client using the
    `postMessage` method.
  prefs: []
  type: TYPE_NORMAL
- en: Functional events are triggered in response to external actions. We have already
    looked at push and background sync. In Chapter 6, *Mastering the Cache API – Managing
    Web Assets in a Podcast Application*, we will review how the Fetch API works and
    start down the path of caching strategies.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The service worker life cycle looks simple until you start working with service
    workers. Understanding how the life cycle executes is helpful so that you can
    understand what the state of your service worker is.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker life cycle is designed to help us avoid situations where
    you upgrade and could potentially break the application. A new service worker
    can be registered, but wait for any existing clients to close. When safe, you
    could use the `skipWaiting` method to allow a new service worker to immediately
    take control.
  prefs: []
  type: TYPE_NORMAL
- en: More complex applications may also have multiple service workers with different
    scopes. This allows larger applications to silo control across the different sub
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a foundation in how to use the service worker and the service
    worker life cycle, in the next chapter, you will see how to use the Fetch and
    Cache APIs to make the Podstr app work offline and save episodes to listen to
    anywhere, anytime.
  prefs: []
  type: TYPE_NORMAL
