<html><head></head><body>
		<div><h1 id="_idParaDest-212" class="chapter-number"><a id="_idTextAnchor269"/>14</h1>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor270"/>The Time-Traveler’s Dilemma – State-Driven End to End User Journeys</h1>
			<p>This chapter addresses a different but common type of test automation – navigating through a survey, page by page, to reach a common endpoint. The challenge here is that decisions made by a user along the way can change the order of the pages displayed downstream – that’s if they appear at all. In this case, we need a fluid user journey that can take many branches to get to a common endpoint, as well as report if a path ended with an error page. It is inefficient to try to create an expanding path of pages for end-to-end automation. The amount of <code>if</code>/<code>then</code> branches or <code>select</code>/<code>case</code> options would be infinite and complex. To solve this, we will explore ways to identify each page by its URL and look at ways to decouple page paths, allowing tests to handle sequential pages in any order with minimal maintenance. Imagine this approach as a ball bouncing randomly through multiple pegs of a giant Pachinko game.</p>
			<p>This chapter covers the following main topics:</p>
			<ul>
				<li>Dividing by sections</li>
				<li>The happy path</li>
				<li>Extracting page name from the current URL with <code>getPageName()</code></li>
				<li>A page processing loop</li>
				<li>Common exit points</li>
			</ul>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor271"/>Technical requirements</h1>
			<p>All test examples can be found at this GitHub repository: <a href="https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO">https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO</a>.</p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor272"/>Divide and conquer!</h1>
			<p>In this approach, we will be considering a non-deterministic way to navigate from our start point to our endpoint. We <a id="_idIndexMarker547"/>will not be working on the traditional assumption that one page follows another. Instead, our script will pass through every potential page repeatedly and interact only if the current page matches one of the page classes. Then, based on high-level flow requirements, we can make different choices and even enter varied and unique data. We might even find a bug along the way!</p>
			<p>In this small example, we will automate the Halloween Party feature of the Candymapper website. This provides customers with a limited set of options to plan a themed party. Party guests use the same site to attend, or avoid, these spooktacular events. The following paths are included for customers and guests:</p>
			<ul>
				<li>Customers can choose to host a zombie theme party</li>
				<li>Customers can choose to host a ghost theme party</li>
				<li>Guests can choose to attend a Zombieton party</li>
				<li>Attend a Ghostville party</li>
				<li>Scared guests can exit back to the <strong class="bold">Host or Attend</strong> choice page</li>
			</ul>
			<p>At least one of these paths will go awry on the <a href="http://www.Candymapper.com">www.Candymapper.com</a> production website. This journey is fixed on the new release of the website at <a href="http://www.CandymapperR2.com">www.CandymapperR2.com</a>, as well as the order of the pages and new options for attending guests to bring friends.</p>
			<p>In the first four of these paths, we will end at the common <strong class="bold">Party Countdown</strong> timer page. In the last path, we will end up back at the <strong class="bold">Halloween Party</strong> Host or Attend page. The pages we will encounter include these actions:</p>
			<ul>
				<li><strong class="bold">Main page</strong>: clear the popup, and click <strong class="bold">Halloween Party</strong> in the page header.</li>
				<li><strong class="bold">Halloween Party page</strong>: a choice to host or attend a party</li>
				<li><strong class="bold">Host party page</strong>: a location address and “a <strong class="bold">Find Out More</strong>” button (Guest Path Only)</li>
				<li><strong class="bold">Party location</strong>: a page with a choice of Zombieton or Ghostville</li>
				<li><strong class="bold">Attend Party page</strong>: with two location choices and a <strong class="bold">Scared</strong> return button</li>
				<li><strong class="bold">Party Location choice page</strong>: Zombieton or Ghostville:<ul><li>A guest list (dev only)</li><li>An email field with “a <strong class="bold">Remind Me</strong>” button (dev only)</li></ul></li>
				<li><strong class="bold">Party Time Countdown page</strong>: the final destination</li>
			</ul>
			<p>The core of this test is the <code>PartyPath()</code> driver, which takes a single string that can be parsed to make decision point changes at multiple milestones. This function is a giant loop that passes through every known page repeatedly. For each page, we will create an object model and a <code>build()</code> method. This method executes only if the current page matches the class page type. It returns <code>true</code> if all actions are successful. If the current page is not this page, it is a <code>null</code> function and returns <code>false</code>. This method will reference a test data model that is<a id="_idIndexMarker548"/> preconfigured with happy path data, which can be overridden from the <code>Switchboard</code> object. This will allow choices to be modified in the page flow from beginning to end.</p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor273"/>Simplifying the complexities of a dynamic journey</h1>
			<p>In a real-world application, we might be navigating through multiple pages of job applications with different data requirements on each one. Some decision points might include adding a current<a id="_idIndexMarker549"/> address, military status, prior employers’ contact information, and personal references. The application process flow might include additional pages for someone who is under 21 or a driver who requires proof of a specialized license to drive a truck. The multiple paths might ask increasingly more information from someone who is single, married, divorced, or widowed with dependents.</p>
			<p>The challenge is that no one can predict the next page in the user journey that eventually leads to the final successful page destination. However, each of those milestones can be described with high-level terms that indicate what to do at each decision point.</p>
			<p>What if we had a dictionary of terms that could be passed to the tests in almost any order, describing the type of applicant applying for the real-world job?</p>
			<ul>
				<li><code>Happy Path</code>: Single, civilian, over 21, no dependents, and no job history or references</li>
				<li><code>married dependents cdl</code>: This <a id="_idIndexMarker550"/>path includes the spouse, children, and CDL license information</li>
				<li><code>military underage cu dd</code>: Uses company-known acronyms for <strong class="bold">Credit Union</strong> and <strong class="bold">Direct Deposit</strong></li>
			</ul>
			<p>For the Halloween Party example, these are the paths that we will follow:</p>
			<ul>
				<li><code>Happy Path</code>: Host a zombie-themed party, with a countdown timer as the final destination</li>
				<li><code>Attend</code>/ <code>""Attend zombie"":</code>  Attends a party with a decision point for a zombie theme over the default ghost theme</li>
				<li><code>Scared</code>: Begins the path to attend a party but returns to the main choice Host or Attend choice page</li>
			</ul>
			<p>The secret to this approach is a path generator, <code>partyPath()</code>. This is a loop that repeatedly executes every page <code>build()</code> method in the Page Object model until the final page is reached. Each page determines whether the current page is the one to process. Then, the test data is used to interact with the values on that page. Every field and list population method will be executed on their respective object. If there is no data provided for a particular input field, the interaction is executed.</p>
			<p>There will be four reasons to exit the infinite loop:</p>
			<ul>
				<li>The final Party Countdown page is reached (<code>Happy Path</code>)</li>
				<li>An unknown page is encountered</li>
				<li>The same page persists after two loop attempts</li>
				<li>The scared journey encounters the Host or Attend page</li>
			</ul>
			<p>Ultimately, the <code>build()</code> method will always attempt to explicitly move to the next page. In most cases, this would be a <code>Page</code> class, from which all other pages extend. In other cases, moving to the next page will be implicit by simply entering the final required field where no <code>clickIfExists()</code> feature mentioned in earlier chapters will come into play. The goal is always to try to reach the end of the process, not find bugs.</p>
			<p>It is expected in some cases that a page will not move on, expecting more data from the user after a selection has been made. While this might be handled within the same path, it could be a path detected on a second pass of the same page. So, if the navigation does not move forward after<a id="_idIndexMarker551"/> two loop attempts, the test exits with the user path incomplete, with a detailed error of the problem in the Allure report.</p>
			<p>The first component we need to add is to determine which page we are currently on. While this is different from project to project, we often find that a unique identifier can be found in its URL. Let us begin by extracting a unique identifier from the last segment of the page URLs:</p>
			<ul>
				<li><a href="https://candymapperr2.com/halloween-party">https://candymapperr2.com/halloween-party</a></li>
				<li><a href="https://candymapperr2.com/party-location-1">https://candymapperr2.com/party-location-1</a></li>
				<li><a href="https://candymapperr2.com/party-time">https://candymapperr2.com/party-time</a></li>
			</ul>
			<p>To capture the URL that the framework has navigated, the <code>getPageName()</code> function will give us a description at the end of the URL. The following function would return <code>halloween-party</code>, <code>party-location-1</code>, and <code>party-time</code> from the aforementioned URLs, respectively.</p>
			<pre class="source-code">
/**
 * Gets last segment of current URL after splitting by "/".
 * @returns {Promise&lt;string&gt;} The last URL segment.
 */
export async function getPageName(): Promise&lt;string&gt; {
  const currentURL = await browser.getUrl();
  const urlSegments = currentURL.split('/');
  return urlSegments[urlSegments.length - 1];
}</pre>			<p>This will be executed in the main <code>partyPath()</code> loop and stored in the automation Switchboard object’s <code>page</code> key. Note that we use only the ending portion of the URL, as this allows us to have<a id="_idIndexMarker552"/> similar functionality in different environments:</p>
			<ul>
				<li><a href="https://candymapper.com/party-time">https://candymapper.com/party-time</a></li>
				<li><a href="https://candymapperr2.com/party-time">https://candymapperr2.com/party-time</a></li>
			</ul>
			<p>Each page class includes the <code>pages</code> object model that might be on the page:</p>
			<pre class="source-code">
import Page from './page.tjs';
import * as helpers from "../../helpers/helpers.tjs";
/**
 * sub page with selectors for a specific page
 */
class HalloweenPartyPage extends Page {
    /**
     * define selectors using getter methods
     */
    public get hostParty () {
        return $(`//a[contains(normalize-space(),'ost')]`);
    }
    public get attendParty () {
        return $(`//a[contains(normalize-space(),'ttend')]`);
    }</pre>			<p>Note that the generic locators use <code>normalize-space</code> and also skip the first letter in case capitalization changes. This makes them more robust and less likely to become stale, even if the text changes from release to release.</p>
			<p>Next, we have the <code>build()</code> method that is common for all pages. This will check first whether the<a id="_idIndexMarker553"/> identifier in the URL string matches the page and immediately returns <code>false</code> if it is not a match:</p>
			<pre class="source-code">
public async build () {
   // Is this the page to process?
   if (await ASB.get("page") !== "attend-a-party") {
      return false // Not the right page
   }
   if (ASB.get("hostorattend") === `attend`){
     return await helpers.clickAdv(
         await this.attendParty);
   }
   return helpers.clickAdv(await this.hostParty);
}
export default new HalloweenPartyPage();</pre>			<p>This path example by default will host a party. The <code>HostOrAttend</code> milestone in the switchboard can be switched to make it a user journey that attends a party instead. After the click, the next page that appears will be different, depending on which button we click, as well as which environment we run this test in. So, it is vitally important where we disassociate the expected page in the user journey, as it may not always be the same. However, we need to start somewhere and that is the happy path.</p>
			<p>The last feature we would introduce is a <code>beforeEach()</code> function which will help us reduce our code significantly when writing the tests. Since we have multiple test cases and we are writing the <code>loginPage.open(``)</code> each time. This can be simplified by placing the function in a <code>beforeEach()</code> function. This refactoring is performing the exact same <a id="_idIndexMarker554"/>process, but with less lines of code:</p>
			<pre class="source-code">
describe("Ch14: State-drive Automation - Host a Party (Default in Ghostville)",  () =&gt; {
  it("should loop around until the final page is found", async () =&gt; {
    await LoginPage.open(``);
    await stateDrivenUtils.partyPath("Host");
  });
});
describe("Ch14: State-drive Automation - Host a Party (Default in Ghostville)",  () =&gt; {
  it("should loop around until the final page is found", async () =&gt; {
    await LoginPage.open(``);
   await stateDrivenUtils.partyPath("Host");
  });
});</pre>			<p>In this refactored version we move the await <code>LoginPage.open(``)</code>  into the <code>beforeEach(async ()</code> function. This code will now execute before every test case.</p>
			<pre class="source-code">
beforeEach(async () =&gt; {
  await LoginPage.open(``);
});
describe("Ch14: State-drive Automation - Host a Party (Default in Ghostville)",  () =&gt; {
  it("should loop around until the final page is found", async () =&gt; {
    await stateDrivenUtils.partyPath("Host");
  });
});
describe("Ch14: State-drive Automation - Host a Party (Default in Ghostville)",  () =&gt; {
  it("should loop around until the final page is found", async () =&gt; {
    await stateDrivenUtils.partyPath("Host");
  });
});</pre>			<p>Keep in mind this works<a id="_idIndexMarker555"/> because we are not building a test that moves from one page to another specific page. We are simply populating whatever page is currently active, attempting to move to the next in a loop. Let’s take a look at our state-driven flow driver, <code>pathyPath(testData)</code> – which will navigate through the milestone decision points of our website.</p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor274"/>The happy path</h1>
			<p>If the <code>testData</code> argument is<a id="_idIndexMarker556"/> empty, the default Happy Path will be performed. This is configured in a <code>userData.json</code> file in the <code>shared-data</code> folder. The two milestones include <code>HostOrAttend</code> and <code>location</code>:</p>
			<pre class="source-code">
}
  "journeyData": {
    "_hostOrAttend_comment": "'host' (default Happy Path), 'attend' or 'scared' ",
    "hostOrAttend: "host",
    "_location_comment": "'zombieton' (default Happy Path) or 'ghostville' ",
    "location": "zombieton",
  }
}</pre>			<p class="callout-heading">Rule of thumb – documenting JSON files</p>
			<p class="callout">No developer worth their salt would ever design a data file without some documentation close at hand. However, JSON files do not allow for comments, as we can do in JavaScript files with double forward slashes (<code>//</code>). The workaround is to add a matching key, beginning with an underscore and ending with the word “<code>comment</code>”. Each key can now be documented to ensure others on the team can understand the intent behind the design.</p>
			<p>This file is first extracted into<a id="_idIndexMarker557"/> the Switchboard object. Then, any overriding values are parsed out of the <code>testData</code> argument or from a <code>JOURNEY</code> system variable:</p>
			<pre class="source-code">
  public parseTestData(testData: string = '') {
    if (process.env.JOURNEY !== undefined) {
      testData = process.env.JOURNEY;
    }</pre>			<p>At this point, we must plan for the future. In our final chapter, we will drive these test cases from Jenkins using the <code>JOURNEY</code> system variable. If this variable is populated, it will supersede the <code>testData</code> argument.</p>
			<p>When we build this driver, we should have a list of known company terms that can be used to adjust the milestone decision points.</p>
			<p>In our example, we have <code>host</code> and <code>attend</code> for the path verbs, and <code>zombie</code> and <code>ghost</code> and <code>scared</code> for<a id="_idIndexMarker558"/> decision points:</p>
			<pre class="source-code">
  if (testData != "") {
      testData = " " + testData.toLowerCase(); // Add space to make sure we match whole words and convert to lowercase once
// Overriding default values
      if (testData.includes(" host")) {
        ASB.set("hostOrAttend", "host");
      }
      if (testData.includes(" attend")) {
        ASB.set("hostOrAttend", "attend");
      }
      if (testData.includes(" zombie")) {
        ASB.set("location", "zombieton");
      }
      if (testData.includes(" ghost")) {
        ASB.set("location", "ghostville");
      }
      if (testData.includes(" scared")) {
        ASB.set("location", "scared");
      }</pre>			<p>Next, the default data values are parsed into the ASB Switchboard:</p>
			<pre class="source-code">
    parseToASB("path/to/userdata.json")</pre>			<p>Then, any overriding <code>key:value</code> data in the <code>testData</code> string is parsed into the ASB object:</p>
			<pre class="source-code">
    parseToASB(testData)</pre>			<p>Inside the test data string, we will allow the test to assign specific values to keys in our switchboard. For example, we might want to set a zip code to <code>12345</code>. In this case, we will need a regular expression to parse values that are connected with an equal sign.  Strings with and without<a id="_idIndexMarker559"/> spaces can <code>be address=""123 main""</code> as well as <code>zip=12345</code>:</p>
			<pre class="source-code">
export function parseToASB(testData: string) {
  const regex = /(\w+)=("([^"]*)"|\b\w+\b)/g;
  let match;
  while ((match = regex.exec(testData)) !== null) {
    let key = match[1];
    let value = match[2];
    // Remove quotes if present
    if (value.startsWith('"') &amp;&amp; value.endsWith('"')) {
      value = value.slice(1, -1);
    }
    let keyLower = key.toLowerCase();
    let oldValue = ASB.get(keyLower);
    // Always save value as a string
    ASB.set(keyLower, value);
    if (oldValue !== undefined) {
      console.log(`ASB(«${keyLower}") updated from "${oldValue}" to "${ASB.get(keyLower)}"`);
    } else {
      console.log(`ASB(«${keyLower}") set to "${ASB.get(keyLower)}"`);
    }
  }
}
import fs from 'fs';
import xml2js from 'xml2js';
export async function parseXMLFileToASB(filePath: string) {
  const data = fs.readFileSync(filePath);
  const result = await xml2js.parseStringPromise(data);
  for (let key in result) {
    let newValue = result[key];
    let oldValue = ASB.get(key.toLowerCase());
    // Always save value as a string
    ASB.set(key.toLowerCase(), newValue);
    if (oldValue !== newValue) {
      console.log(`ASB(«${key.toLowerCase()}") updated from "${oldValue}" to "${newValue}"`);
    }
  }
}</pre>			<p>While the <code>testData</code> string argument tells us what will change at each milestone point, this is first transferred into the ASB switchboard object that all pages will reference when they execute. A data file will contain the default values that are populated into the switchboard, and then <code>testData</code> is parsed to customize these values. In preparation for our final chapter, this function also gets data from the <code>JOURNEY</code> system variable that will be <a id="_idIndexMarker560"/>sent from Jenkins:</p>
			<pre class="source-code">
import { ASB } from "../../helpers/globalObjects";
import candymapperPage from "../pageObjects/candymapper.page";
import halloweenAttendPartyPage from "../pageObjects/halloweenAttendParty.page";
import halloweenPartyPage from "../pageObjects/halloweenParty.page";
import halloweenPartyLocationPage from "../pageObjects/halloweenPartyLocation.page";
import halloweenPartyThemePage from "../pageObjects/halloweenPartyTheme.page";
import halloweenPartyTimerPage from "../pageObjects/halloweenPartyTimer.page";
import * as helpers from "../../helpers/helpers";
import AllureReporter from "@wdio/allure-reporter";
import Page from "../pageObjects/page";
class StateDrivenUtils extends Page {</pre>			<h2 id="_idParaDest-218"><a id="_idTextAnchor275"/>The big driver loop</h2>
			<p>The <code>partyPath()</code> method is actually a utility, rather than a test, so we will store it in a <code>Utilities</code> folder in the <a id="_idIndexMarker561"/>project root folder:</p>
			<pre class="source-code">
export async function partyPath (testData) {
    let complete: Boolean = false;
    let lastPage: string = ""
    let retry = 2
   this.parseTestData(testData);  // Parse the known milestone verbs                                   // to the switchboard
    helpers.parseToASB(testData);   // Parse the key=value data to set                                     // the switchboard</pre>			<p>The next step is to navigate the start of the Halloween Party path. This will require an <code>is a</code> loop that processes every page repeatedly, seeking one of four exit points:</p>
			<pre class="source-code">
    while (complete === false) { // Loop until final page
      //Get Page Name
        let pageName = await browser.getUrl();
        pageName = extractPathFromUrl(pageName)
        ASB.set("page", pageName);</pre>			<p>This puts the name of the current page into the Switchboard. This object will be read in every page’s <code>build()</code> method. Next, we will call every known page, using logical <code>OR</code>, to determine whether any were successfully identified:</p>
			<pre class="source-code">
   // Pass through every known page
knownPage =
        await halloweenLocationPage.build() ||
        await halloweenAttendPartyPage.build() ||
   await halloweenHostPartyPage.build() ||
   await halloweenPartyPage.build() ||
// Add new pages along the journey here.</pre>			<p>Note that these pages do not need to be in any particular order. In fact, our designs have placed the first processing page list last and others in roughly reverse order. This tends to ensure only <a id="_idIndexMarker562"/>one page gets parsed per loop. Having multiple pages executing per loop is just as acceptable.</p>
			<p class="callout-heading">Rule of thumb – refactoring</p>
			<p class="callout">In this small example, we are using only six pages. Real-world projects may have 50 to 100 web pages to navigate. It is always recommended to reduce code to smaller, more manageable units. In this case, the longer the lists of pages, the more they should be refactored into their own function.</p>
			<p>We now add the first of the four exit points. Note that in the preceding list of pages, one is missing – the final countdown page. This is the success page where our journey ends. Nothing else matters at this point:</p>
			<pre class="source-code">
// Exit Point #1: Success reached the timer page
   if (await halloweenPartyTimerPage.build()) {
      knownPage = true; // Skip Exit point 2
      console.log("Success: Reached the timer page")
      complete = true; // Exit the loop
 break;
   } // End of all paths except unknown page</pre>			<p>If this page is processed, we report the successful end of the journey. It also sets out the <code>knownPage</code> flag as <code>true</code> for any additional reporting or cleanup at the end of the function. Then, we break out.</p>
			<p>Our job here is done, unless there is something unknown lurking out there?</p>
			<pre class="source-code">
// Exit Point #2: Unknown page encountered
   if (knownPage === false) {
     //None of the build methods returned true
     AllureReporter.addAttachment(`Unknown Page detected: ${pageName}`, "", "text/plain");
    console.log(`Unknown Page detected: ${pageName} - Exiting Journey`);
    expect(pageName).toBe("a known page");
    break;
}</pre>			<p>In this case, no page returned <code>true</code>. We output the name of the unknown page. We also use a clever <code>expect</code> to<a id="_idIndexMarker563"/> set the test to a failed status, while further documenting the issue at hand, the URL of the new page. In our example, the production website <code>Candymapper.com</code> will generate an <code>Error 404</code> page when a guest is too scared to go to a party and expects to return. This page is never expected, but if we can screen-capture it.</p>
			<p>Next, we need to handle a situation where a page just did not move forward from the last one:</p>
			<pre class="source-code">
// Exit Point #3: Page did not change
if (lastPage === pageName) {
  retry--; // Give two additional attempts
  if (retry === 0) {
    console.log(`Page did not change: ${lastPage} - Exiting Journey`);
    expect("Page did not move on from").toBe(lastPage);
  } else {
     // Page moved on, reset retry for next page
     retry = 2;
  }
}</pre>			<p>As superheroes, we are always open to second chances. In this case, a page could have two or three states itself. A point of sale page might add one product if the cart is empty and a different item if the <a id="_idIndexMarker564"/>cart has one item, before moving on. Calling such a method twice could be required and offer flexibility.</p>
			<p>Lastly, there could be a journey that expects an alternative page as its final destination. This is rare but presented as an option. This path is one where we return to a prior step in the process. This works because the page was identified and processed as the first step in the loop, moving to the next page before reaching this point:</p>
			<pre class="source-code">
// Exit Point #4: We were scared and went back - Halloween Party Home page reached - only works in dev, prod has an intentional Error 404 issue.
if (ASB.get("page") === "halloween-party") {
   console.log("Halloween Party Home page reached")
   complete = true;
}</pre>			<p>Is that all the exit points? We are certain there are other ways journeys must end prematurely. We can think of one more example – an infinite loop journey. This would require tracking an array of all the URLs visited. It would be triggered when a page has been visited for the third time. We have given you all the tips and tricks to pull this off. Now, it is time to work this one out on your own.</p>
			<p>Our final step before cycling back again is to set the current page name to the last page name:</p>
			<pre class="source-code">
      lastPage = ASB.get("page"); // Save the last page name
    }</pre>			<p>This ensures that exit point #3 works correctly when determining whether we are stuck on the same page.</p>
			<p>Next, the test data file object is<a id="_idIndexMarker565"/> used to determine what fields are populated. If the test data object does not contain the data for a particular field, a warning is added to our results, but the test continues.</p>
			<p>Finally, the method to move on to the next page is performed. Note that we will use the <code>ClickIfExits()</code> method to ensure our engine remains robust, even if the element does not exist in future test environments.</p>
			<p>In the loop, we check to see whether the page has moved on with an increment counter, starting at 2. If the page did not move on in the first loop, we decrement the loop counter. If the loop counter reaches 0, we have failed to successfully move on, and we exit. If successive loops do result in a new page URL, the counter is reset to perform two additional loops.</p>
			<p>Some pages may have code that can resolve issues generated by incomplete data. This may not have been detected in the first execution of the <code>build</code> method for the page; thus, the build method must be executed at least twice before the test user journey is abandoned.</p>
			<p>Once we have completed this process for each page, we can begin to add milestones, based on the values passed from the <code>JOURNEY</code> user variable. In this example, we will have a path that plans a zombie party by default but will switch to a user attending a party, by passing <code>attend</code> in the <code>JOURNEY</code> string. This, in turn, will be injected into the test data object and read by the proper page.</p>
			<p>If we encounter a page that is new, the test will stop. We will report the URL of the page to Allure and provide a screen capture of the results. Our reporting automatically tells us the path that led us to that new endpoint.</p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor276"/>It’s all in the details</h2>
			<p>Similarly, we could detect the string <code>error</code> in the URL on our page report with a screen capture, or we could capture all the text on the screen this way – <code>const allText = </code><code>await $('body').getText();</code>.</p>
			<p>Another way to capture<a id="_idIndexMarker566"/> the scree text would be to send <em class="italic">Ctrl-A / Ctrl-V</em> to the browser and send the clipboard to the Allure report:</p>
			<pre class="source-code">
import { clipboard } from 'electron';
const operatingSystem = process.platform;
let selectAllKeys: string[];
let copyKeys: string[];
if (operatingSystem === 'darwin') {
  selectAllKeys = ['Command', 'a'];
  copyKeys = ['Command', 'c'];
} else {
  selectAllKeys = ['Control', 'a'];
  copyKeys = ['Control', 'c'];
}
await browser.keys(selectAllKeys);
await browser.keys(copyKeys);
const allText = clipboard.readText();</pre>			<p>This makes it more likely we will capture only the visible text of the browser.</p>
			<p>This loop also provides the opportunity to interact with any known page, regardless of the order it appears in the path. Consider this path in the candymapperR2 website hosting a party:</p>
			<ol>
				<li>Host a Party</li>
				<li>Party Venue Address Confirmed</li>
				<li>Party Theme</li>
				<li>Party Countdown</li>
			</ol>
			<p>And consider the path to attend a party:</p>
			<ol>
				<li>Attend a Party</li>
				<li>Choose a Party Venue or Return</li>
				<li>Party Venue Location Address</li>
				<li>Party Countdown</li>
			</ol>
			<p>Note that these two paths <a id="_idIndexMarker567"/>encounter the same <strong class="bold">Party Venue Location Address</strong> page but from different pages. In addition, the paths of these two journeys are different from the production Candymapper website. Thus, we can have the same test case run in two environments with dissimilar paths and still complete its goal.</p>
			<p>Our final path would be to set our final expected page. In this example, the path returns us to the <code>Plan</code> or <code>Attend</code> page indicating the user journey; although it did not end at the common endpoint, it was still a success.</p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor277"/>Changing decision points</h1>
			<p>The way we pass the <a id="_idIndexMarker568"/>string that customizes a path is through a single environmental variable, like so:</p>
			<pre class="source-code">
Set JOURNEY=""; yarn ch15</pre>			<p>This way, we can create test several paths. In this example, the user does not attend the party and instead clicks the <strong class="bold">I’m </strong><strong class="bold">scared</strong> button:</p>
			<pre class="source-code">
Set JOURNEY="attend scared"; yarn ch15</pre>			<p>With this example, the user takes the path to host the party with a zombie theme:</p>
			<pre class="source-code">
Set JOURNEY="Host ZOMBIE"; yarn ch15</pre>			<p>A single environmental value can modify multiple decision points from the Happy Path baseline. While an empty string by default will create a Happy Path, the best practice is to assign the string so that the path is shown in the results, with the parsing being case-insensitive.</p>
			<pre class="source-code">
let journey: string = " " + (process.env.JOURNEY || "Host").toLowerCase();
if (journey===" ")) {
    journey = " host"; //Default Happy Path
}</pre>			<p>Note that there is a space<a id="_idIndexMarker569"/> prepended to the journey variable. The reason for this is to make it less likely to match a similar string in the path. We have a <code>host</code> command and a <code>ghost</code> party. Writing this line of code could potentially take the <code>host</code> command from the <code>ghost</code> string:</p>
			<pre class="source-code">
Set JOURNEY="Attend Ghost"; yarn ch15
if (journey.includes(" host").toLowerCase()) {
// Host path being taken in error.
}</pre>			<p>This is resolved, as every command that is acted upon always has a prepended space. Now, there is less chance of an incorrect path match. For our example, we will go one step further, making <code>Host</code> the default Happy Path and <code>Attend</code> the deviation from the path:</p>
			<pre class="source-code">
if (journey.includes(" attend").toLowerCase()) {
// Attend a party path, case insensitively
Helpers.click(attend)
} else {
    // The JOURNEY variable contains "host" Happy Path
Helpers.click(host)
}</pre>			<p>This completes the first method to choose a decision point on the first page. The function exits and loops around. The next page could be next, but it does not have to be in sequential order. It could be further down the list inside the loop.  All the following pages will not match <a id="_idIndexMarker570"/>the URL, and the <code>build()</code> method will simply return immediately as a null function. The next page could be earlier in the loop. It would have executed as a null function before this page and now executes as the loop starts from the top again.</p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor278"/>Wash, rinse, repeat</h1>
			<p>The same principle applies to modifying the type of data in the page classes. As an example, the custom <code>date</code> tokens could be passed like this:</p>
			<pre class="source-code">
Set JOURNEY="host &lt;today+7&gt;"; yarn ch15
const match = journey.match(/(&lt;.+&gt;)/);
const dateToken = match ? match[0] : "";
Helpers.setValueIfExists(dateField, dateToken);</pre>			<p>Now, we have a date token extracted from the journey value. The token is passed to <code>dateField</code>, if it exists, and set to next week’s date. If there is no token, the date is set to an empty string, which the method will return immediately as there is nothing to do.</p>
			<p>At this point, we have covered all the processes of a non-deterministic engine. New pages will be reported in the results and must be added to extend the path coverage. If a page is never encountered in a particular path, it does not stop the test. If an error is encountered, it is reported. If the path gets stuck, it is also reported. The data and the paths can be customized. These build methods can be called from other test cases.</p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor279"/>Why not generate these Artifacts with API calls?</h1>
			<p>Using API calls for a task does <a id="_idIndexMarker571"/>mean quicker and more stable testing, as it directly communicates with an application. It can be implemented earlier in the development process. This could lead to early detection of issues, making the development <a id="_idIndexMarker572"/>process more flexible and agile.</p>
			<p>Conversely, using an automated GUI could provide a richer understanding of the user experience, as it can simulate the exact paths a user might take, including interactions with visual elements that API tests might overlook. This approach might be more intuitive and can encompass a broader analysis, including the appearance and layout, which are crucial for user satisfaction.</p>
			<p>In fact, there is no reason to support once approach over another. The GUI approach confirms the system works correctly for the user. The API approaches generate the artifacts with greater speed. We can implement the differences in the approaches by  adding another keyword value to the journey parsing code:</p>
			<pre class="source-code">
Set JOURNEY="military references api"; yarn job-app-engine
if (journey.toLowerCase().includes(" api)) {
// API pat<a id="_idTextAnchor280"/>h
} else {
// GUI path
}</pre>			<p>In this example, the default GUI approach is overridden wit<a id="_idTextAnchor281"/>h an API path in the same <code>build()</code> methods.</p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor282"/>Summary</h1>
			<p>In this chapter, we delved into a sophisticated approach to test automation, reminiscent of a superhero strategizing for dynamic and complex missions with multiple potential outcomes based on choices made. Our method involved a loop that continuously navigates through each page, engaging only upon recognizing a known resource. The journey is non-deterministic shaped by high-level objectives and occasionally encountering unexpected obstacles like dead ends or logic loops.</p>
			<p>This approach is flexible, allowing for the adjustment of user paths based on various variables and can be adapted to different environments, highlighting its robustness and versatility. It also aids in data generation for manual testers, significantly reducing the time and effort needed to create data records for testing when paired with tools like Jenkins, enhancing the efficiency of the testing process overall.</p>
			<p>In the final chapter, this approach will have additional advantages, making manual testers more efficient. The worst idea is to assume automation replaces “costly” manual testers. We should aways strive to augment their efforts. Manual testers could reduce a lot of setup time creating complex test artifacts when they only need to validate the results. But do we want to have them install a coding tool and teach them how to run a script like this? This is where we employ our final magical item and let a CI/CD tool provide an effortless way to do the heavy lifting. Something like a mystic sentient cloak of levitation perhaps?</p>
		</div>
	</body></html>