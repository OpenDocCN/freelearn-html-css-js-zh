<html><head></head><body>
		<div id="_idContainer124">
			<h1 id="_idParaDest-212" class="chapter-number"><a id="_idTextAnchor269"/>14</h1>
			<h1 id="_idParaDest-213"><a id="_idTextAnchor270"/>The Time-Traveler’s Dilemma – State-Driven End to End User Journeys</h1>
			<p>This chapter addresses a different but common type of test automation – navigating through a survey, page by page, to reach a common endpoint. The challenge here is that decisions made by a user along the way can change the order of the pages displayed downstream – that’s if they appear at all. In this case, we need a fluid user journey that can take many branches to get to a common endpoint, as well as report if a path ended with an error page. It is inefficient to try to create an expanding path of pages for end-to-end automation. The amount of <strong class="source-inline">if</strong>/<strong class="source-inline">then</strong> branches or <strong class="source-inline">select</strong>/<strong class="source-inline">case</strong> options would be infinite and complex. To solve this, we will explore ways to identify each page by its URL and look at ways to decouple page paths, allowing tests to handle sequential pages in any order with minimal maintenance. Imagine this approach as a ball bouncing randomly through multiple pegs of a giant <span class="No-Break">Pachinko game.</span></p>
			<p>This chapter covers the following <span class="No-Break">main topics:</span></p>
			<ul>
				<li>Dividing <span class="No-Break">by sections</span></li>
				<li>The <span class="No-Break">happy path</span></li>
				<li>Extracting page name from the current URL <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">getPageName()</strong></span></li>
				<li>A page <span class="No-Break">processing loop</span></li>
				<li>Common <span class="No-Break">exit points</span></li>
			</ul>
			<h1 id="_idParaDest-214"><a id="_idTextAnchor271"/>Technical requirements</h1>
			<p>All test examples can be found at this GitHub <span class="No-Break">repository: </span><a href="https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO"><span class="No-Break">https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-215"><a id="_idTextAnchor272"/>Divide and conquer!</h1>
			<p>In this approach, we will be considering a non-deterministic way to navigate from our start point to our endpoint. We <a id="_idIndexMarker547"/>will not be working on the traditional assumption that one page follows another. Instead, our script will pass through every potential page repeatedly and interact only if the current page matches one of the page classes. Then, based on high-level flow requirements, we can make different choices and even enter varied and unique data. We might even find a bug along <span class="No-Break">the way!</span></p>
			<p>In this small example, we will automate the Halloween Party feature of the Candymapper website. This provides customers with a limited set of options to plan a themed party. Party guests use the same site to attend, or avoid, these spooktacular events. The following paths are included for customers <span class="No-Break">and guests:</span></p>
			<ul>
				<li>Customers can choose to host a zombie <span class="No-Break">theme party</span></li>
				<li>Customers can choose to host a ghost <span class="No-Break">theme party</span></li>
				<li>Guests can choose to attend a <span class="No-Break">Zombieton party</span></li>
				<li>Attend a <span class="No-Break">Ghostville party</span></li>
				<li>Scared guests can exit back to the <strong class="bold">Host or Attend</strong> <span class="No-Break">choice page</span></li>
			</ul>
			<p>At least one of these paths will go awry on the <a href="http://www.Candymapper.com">www.Candymapper.com</a> production website. This journey is fixed on the new release of the website at <a href="http://www.CandymapperR2.com">www.CandymapperR2.com</a>, as well as the order of the pages and new options for attending guests to <span class="No-Break">bring friends.</span></p>
			<p>In the first four of these paths, we will end at the common <strong class="bold">Party Countdown</strong> timer page. In the last path, we will end up back at the <strong class="bold">Halloween Party</strong> Host or Attend page. The pages we will encounter include <span class="No-Break">these actions:</span></p>
			<ul>
				<li><strong class="bold">Main page</strong>: clear the popup, and click <strong class="bold">Halloween Party</strong> in the <span class="No-Break">page header.</span></li>
				<li><strong class="bold">Halloween Party page</strong>: a choice to host or attend <span class="No-Break">a party</span></li>
				<li><strong class="bold">Host party page</strong>: a location address and “a <strong class="bold">Find Out More</strong>” button (Guest <span class="No-Break">Path Only)</span></li>
				<li><strong class="bold">Party location</strong>: a page with a choice of Zombieton <span class="No-Break">or Ghostville</span></li>
				<li><strong class="bold">Attend Party page</strong>: with two location choices and a <strong class="bold">Scared</strong> <span class="No-Break">return button</span></li>
				<li><strong class="bold">Party Location choice page</strong>: Zombieton <span class="No-Break">or Ghostville:</span><ul><li>A guest list (<span class="No-Break">dev only)</span></li><li>An email field with “a <strong class="bold">Remind Me</strong>” button (<span class="No-Break">dev only)</span></li></ul></li>
				<li><strong class="bold">Party Time Countdown page</strong>: the <span class="No-Break">final destination</span></li>
			</ul>
			<p>The core of this test is the <strong class="source-inline">PartyPath()</strong> driver, which takes a single string that can be parsed to make decision point changes at multiple milestones. This function is a giant loop that passes through every known page repeatedly. For each page, we will create an object model and a <strong class="source-inline">build()</strong> method. This method executes only if the current page matches the class page type. It returns <strong class="source-inline">true</strong> if all actions are successful. If the current page is not this page, it is a <strong class="source-inline">null</strong> function and returns <strong class="source-inline">false</strong>. This method will reference a test data model that is<a id="_idIndexMarker548"/> preconfigured with happy path data, which can be overridden from the <strong class="source-inline">Switchboard</strong> object. This will allow choices to be modified in the page flow from beginning <span class="No-Break">to end.</span></p>
			<h1 id="_idParaDest-216"><a id="_idTextAnchor273"/>Simplifying the complexities of a dynamic journey</h1>
			<p>In a real-world application, we might be navigating through multiple pages of job applications with different data requirements on each one. Some decision points might include adding a current<a id="_idIndexMarker549"/> address, military status, prior employers’ contact information, and personal references. The application process flow might include additional pages for someone who is under 21 or a driver who requires proof of a specialized license to drive a truck. The multiple paths might ask increasingly more information from someone who is single, married, divorced, or widowed <span class="No-Break">with dependents.</span></p>
			<p>The challenge is that no one can predict the next page in the user journey that eventually leads to the final successful page destination. However, each of those milestones can be described with high-level terms that indicate what to do at each <span class="No-Break">decision point.</span></p>
			<p>What if we had a dictionary of terms that could be passed to the tests in almost any order, describing the type of applicant applying for the <span class="No-Break">real-world job?</span></p>
			<ul>
				<li><strong class="source-inline">Happy Path</strong>: Single, civilian, over 21, no dependents, and no job history <span class="No-Break">or references</span></li>
				<li><strong class="source-inline">married dependents cdl</strong>: This <a id="_idIndexMarker550"/>path includes the spouse, children, and CDL <span class="No-Break">license information</span></li>
				<li><strong class="source-inline">military underage cu dd</strong>: Uses company-known acronyms for <strong class="bold">Credit Union</strong> and <span class="No-Break"><strong class="bold">Direct Deposit</strong></span></li>
			</ul>
			<p>For the Halloween Party example, these are the paths that we <span class="No-Break">will follow:</span></p>
			<ul>
				<li><strong class="source-inline">Happy Path</strong>: Host a zombie-themed party, with a countdown timer as the <span class="No-Break">final destination</span></li>
				<li><strong class="source-inline">Attend</strong>/ <strong class="source-inline">""Attend zombie"":</strong>  Attends a party with a decision point for a zombie theme over the default <span class="No-Break">ghost theme</span></li>
				<li><strong class="source-inline">Scared</strong>: Begins the path to attend a party but returns to the main choice Host or Attend <span class="No-Break">choice page</span></li>
			</ul>
			<p>The secret to this approach is a path generator, <strong class="source-inline">partyPath()</strong>. This is a loop that repeatedly executes every page <strong class="source-inline">build()</strong> method in the Page Object model until the final page is reached. Each page determines whether the current page is the one to process. Then, the test data is used to interact with the values on that page. Every field and list population method will be executed on their respective object. If there is no data provided for a particular input field, the interaction <span class="No-Break">is executed.</span></p>
			<p>There will be four reasons to exit the <span class="No-Break">infinite loop:</span></p>
			<ul>
				<li>The final Party Countdown page is reached (<span class="No-Break"><strong class="source-inline">Happy Path</strong></span><span class="No-Break">)</span></li>
				<li>An unknown page <span class="No-Break">is encountered</span></li>
				<li>The same page persists after two <span class="No-Break">loop attempts</span></li>
				<li>The scared journey encounters the Host or <span class="No-Break">Attend page</span></li>
			</ul>
			<p>Ultimately, the <strong class="source-inline">build()</strong> method will always attempt to explicitly move to the next page. In most cases, this would be a <strong class="bold">Next</strong> button, which is likely to be common to all pages and declared in the <strong class="source-inline">Page</strong> class, from which all other pages extend. In other cases, moving to the next page will be implicit by simply entering the final required field where no <strong class="bold">Next</strong> button exists. In this case, the <strong class="source-inline">clickIfExists()</strong> feature mentioned in earlier chapters will come into play. The goal is always to try to reach the end of the process, not <span class="No-Break">find bugs.</span></p>
			<p>It is expected in some cases that a page will not move on, expecting more data from the user after a selection has been made. While this might be handled within the same path, it could be a path detected on a second pass of the same page. So, if the navigation does not move forward after<a id="_idIndexMarker551"/> two loop attempts, the test exits with the user path incomplete, with a detailed error of the problem in the <span class="No-Break">Allure report.</span></p>
			<p>The first component we need to add is to determine which page we are currently on. While this is different from project to project, we often find that a unique identifier can be found in its URL. Let us begin by extracting a unique identifier from the last segment of the <span class="No-Break">page URLs:</span></p>
			<ul>
				<li><a href="https://candymapperr2.com/halloween-party"><span class="No-Break">https://candymapperr2.com/halloween-party</span></a></li>
				<li><a href="https://candymapperr2.com/party-location-1"><span class="No-Break">https://candymapperr2.com/party-location-1</span></a></li>
				<li><a href="https://candymapperr2.com/party-time"><span class="No-Break">https://candymapperr2.com/party-time</span></a></li>
			</ul>
			<p>To capture the URL that the framework has navigated, the <strong class="source-inline">getPageName()</strong> function will give us a description at the end of the URL. The following function would return <strong class="source-inline">halloween-party</strong>, <strong class="source-inline">party-location-1</strong>, and <strong class="source-inline">party-time</strong> from the aforementioned <span class="No-Break">URLs, respectively.</span></p>
			<pre class="source-code">
/**
 * Gets last segment of current URL after splitting by "/".
 * @returns {Promise&lt;string&gt;} The last URL segment.
 */
export async function getPageName(): Promise&lt;string&gt; {
  const currentURL = await browser.getUrl();
  const urlSegments = currentURL.split('/');
  return urlSegments[urlSegments.length - 1];
}</pre>			<p>This will be executed in the main <strong class="source-inline">partyPath()</strong> loop and stored in the automation Switchboard object’s <strong class="source-inline">page</strong> key. Note that we use only the ending portion of the URL, as this allows us to have<a id="_idIndexMarker552"/> similar functionality in <span class="No-Break">different environments:</span></p>
			<ul>
				<li><a href="https://candymapper.com/party-time"><span class="No-Break">https://candymapper.com/party-time</span></a></li>
				<li><a href="https://candymapperr2.com/party-time"><span class="No-Break">https://candymapperr2.com/party-time</span></a></li>
			</ul>
			<p>Each page class includes the <strong class="source-inline">pages</strong> object model that might be on <span class="No-Break">the page:</span></p>
			<pre class="source-code">
import Page from './page.tjs';
import * as helpers from "../../helpers/helpers.tjs";
/**
 * sub page with selectors for a specific page
 */
class HalloweenPartyPage extends Page {
    /**
     * define selectors using getter methods
     */
    public get hostParty () {
        return $(`//a[contains(normalize-space(),'ost')]`);
    }
    public get attendParty () {
        return $(`//a[contains(normalize-space(),'ttend')]`);
    }</pre>			<p>Note that the generic locators use <strong class="source-inline">normalize-space</strong> and also skip the first letter in case capitalization changes. This makes them more robust and less likely to become stale, even if the text changes from release <span class="No-Break">to release.</span></p>
			<p>Next, we have the <strong class="source-inline">build()</strong> method that is common for all pages. This will check first whether the<a id="_idIndexMarker553"/> identifier in the URL string matches the page and immediately returns <strong class="source-inline">false</strong> if it is not <span class="No-Break">a match:</span></p>
			<pre class="source-code">
public async build () {
   // Is this the page to process?
   if (await ASB.get("page") !== "attend-a-party") {
      return false // Not the right page
   }
   if (ASB.get("hostorattend") === `attend`){
     return await helpers.clickAdv(
         await this.attendParty);
   }
   return helpers.clickAdv(await this.hostParty);
}
export default new HalloweenPartyPage();</pre>			<p>This path example by default will host a party. The <strong class="source-inline">HostOrAttend</strong> milestone in the switchboard can be switched to make it a user journey that attends a party instead. After the click, the next page that appears will be different, depending on which button we click, as well as which environment we run this test in. So, it is vitally important where we disassociate the expected page in the user journey, as it may not always be the same. However, we need to start somewhere and that is the <span class="No-Break">happy path.</span></p>
			<p>The last feature we would introduce is a <strong class="source-inline">beforeEach()</strong> function which will help us reduce our code significantly when writing the tests. Since we have multiple test cases and we are writing the <strong class="source-inline">loginPage.open(``)</strong> each time. This can be simplified by placing the function in a <strong class="source-inline">beforeEach()</strong> function. This refactoring is performing the exact same <a id="_idIndexMarker554"/>process, but with less lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
describe("Ch14: State-drive Automation - Host a Party (Default in Ghostville)",  () =&gt; {
  it("should loop around until the final page is found", async () =&gt; {
    await LoginPage.open(``);
    await stateDrivenUtils.partyPath("Host");
  });
});
describe("Ch14: State-drive Automation - Host a Party (Default in Ghostville)",  () =&gt; {
  it("should loop around until the final page is found", async () =&gt; {
    await LoginPage.open(``);
   await stateDrivenUtils.partyPath("Host");
  });
});</pre>			<p>In this refactored version we move the await <strong class="source-inline">LoginPage.open(``)</strong>  into the <strong class="source-inline">beforeEach(async ()</strong> function. This code will now execute before every <span class="No-Break">test case.</span></p>
			<pre class="source-code">
beforeEach(async () =&gt; {
  await LoginPage.open(``);
});
describe("Ch14: State-drive Automation - Host a Party (Default in Ghostville)",  () =&gt; {
  it("should loop around until the final page is found", async () =&gt; {
    await stateDrivenUtils.partyPath("Host");
  });
});
describe("Ch14: State-drive Automation - Host a Party (Default in Ghostville)",  () =&gt; {
  it("should loop around until the final page is found", async () =&gt; {
    await stateDrivenUtils.partyPath("Host");
  });
});</pre>			<p>Keep in mind this works<a id="_idIndexMarker555"/> because we are not building a test that moves from one page to another specific page. We are simply populating whatever page is currently active, attempting to move to the next in a loop. Let’s take a look at our state-driven flow driver, <strong class="source-inline">pathyPath(testData)</strong> – which will navigate through the milestone decision points of <span class="No-Break">our website.</span></p>
			<h1 id="_idParaDest-217"><a id="_idTextAnchor274"/>The happy path</h1>
			<p>If the <strong class="source-inline">testData</strong> argument is<a id="_idIndexMarker556"/> empty, the default Happy Path will be performed. This is configured in a <strong class="source-inline">userData.json</strong> file in the <strong class="source-inline">shared-data</strong> folder. The two milestones include <strong class="source-inline">HostOrAttend</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">location</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
}
  "journeyData": {
    "_hostOrAttend_comment": "'host' (default Happy Path), 'attend' or 'scared' ",
    "hostOrAttend: "host",
    "_location_comment": "'zombieton' (default Happy Path) or 'ghostville' ",
    "location": "zombieton",
  }
}</pre>			<p class="callout-heading">Rule of thumb – documenting JSON files</p>
			<p class="callout">No developer worth their salt would ever design a data file without some documentation close at hand. However, JSON files do not allow for comments, as we can do in JavaScript files with double forward slashes (<strong class="source-inline">//</strong>). The workaround is to add a matching key, beginning with an underscore and ending with the word “<strong class="source-inline">comment</strong>”. Each key can now be documented to ensure others on the team can understand the intent behind <span class="No-Break">the design.</span></p>
			<p>This file is first extracted into<a id="_idIndexMarker557"/> the Switchboard object. Then, any overriding values are parsed out of the <strong class="source-inline">testData</strong> argument or from a <strong class="source-inline">JOURNEY</strong> <span class="No-Break">system variable:</span></p>
			<pre class="source-code">
  public parseTestData(testData: string = '') {
    if (process.env.JOURNEY !== undefined) {
      testData = process.env.JOURNEY;
    }</pre>			<p>At this point, we must plan for the future. In our final chapter, we will drive these test cases from Jenkins using the <strong class="source-inline">JOURNEY</strong> system variable. If this variable is populated, it will supersede the <span class="No-Break"><strong class="source-inline">testData</strong></span><span class="No-Break"> argument.</span></p>
			<p>When we build this driver, we should have a list of known company terms that can be used to adjust the milestone <span class="No-Break">decision points.</span></p>
			<p>In our example, we have <strong class="source-inline">host</strong> and <strong class="source-inline">attend</strong> for the path verbs, and <strong class="source-inline">zombie</strong> and <strong class="source-inline">ghost</strong> and <strong class="source-inline">scared</strong> for<a id="_idIndexMarker558"/> <span class="No-Break">decision points:</span></p>
			<pre class="source-code">
  if (testData != "") {
      testData = " " + testData.toLowerCase(); // Add space to make sure we match whole words and convert to lowercase once
// Overriding default values
      if (testData.includes(" host")) {
        ASB.set("hostOrAttend", "host");
      }
      if (testData.includes(" attend")) {
        ASB.set("hostOrAttend", "attend");
      }
      if (testData.includes(" zombie")) {
        ASB.set("location", "zombieton");
      }
      if (testData.includes(" ghost")) {
        ASB.set("location", "ghostville");
      }
      if (testData.includes(" scared")) {
        ASB.set("location", "scared");
      }</pre>			<p>Next, the default data values are parsed into the <span class="No-Break">ASB Switchboard:</span></p>
			<pre class="source-code">
    parseToASB("path/to/userdata.json")</pre>			<p>Then, any overriding <strong class="source-inline">key:value</strong> data in the <strong class="source-inline">testData</strong> string is parsed into the <span class="No-Break">ASB object:</span></p>
			<pre class="source-code">
    parseToASB(testData)</pre>			<p>Inside the test data string, we will allow the test to assign specific values to keys in our switchboard. For example, we might want to set a zip code to <strong class="source-inline">12345</strong>. In this case, we will need a regular expression to parse values that are connected with an equal sign.  Strings with and without<a id="_idIndexMarker559"/> spaces can <strong class="source-inline">be address=""123 main""</strong> as well <span class="No-Break">as </span><span class="No-Break"><strong class="source-inline">zip=12345</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
export function parseToASB(testData: string) {
  const regex = /(\w+)=("([^"]*)"|\b\w+\b)/g;
  let match;
  while ((match = regex.exec(testData)) !== null) {
    let key = match[1];
    let value = match[2];
    // Remove quotes if present
    if (value.startsWith('"') &amp;&amp; value.endsWith('"')) {
      value = value.slice(1, -1);
    }
    let keyLower = key.toLowerCase();
    let oldValue = ASB.get(keyLower);
    // Always save value as a string
    ASB.set(keyLower, value);
    if (oldValue !== undefined) {
      console.log(`ASB(«${keyLower}") updated from "${oldValue}" to "${ASB.get(keyLower)}"`);
    } else {
      console.log(`ASB(«${keyLower}") set to "${ASB.get(keyLower)}"`);
    }
  }
}
import fs from 'fs';
import xml2js from 'xml2js';
export async function parseXMLFileToASB(filePath: string) {
  const data = fs.readFileSync(filePath);
  const result = await xml2js.parseStringPromise(data);
  for (let key in result) {
    let newValue = result[key];
    let oldValue = ASB.get(key.toLowerCase());
    // Always save value as a string
    ASB.set(key.toLowerCase(), newValue);
    if (oldValue !== newValue) {
      console.log(`ASB(«${key.toLowerCase()}") updated from "${oldValue}" to "${newValue}"`);
    }
  }
}</pre>			<p>While the <strong class="source-inline">testData</strong> string argument tells us what will change at each milestone point, this is first transferred into the ASB switchboard object that all pages will reference when they execute. A data file will contain the default values that are populated into the switchboard, and then <strong class="source-inline">testData</strong> is parsed to customize these values. In preparation for our final chapter, this function also gets data from the <strong class="source-inline">JOURNEY</strong> system variable that will be <a id="_idIndexMarker560"/>sent <span class="No-Break">from Jenkins:</span></p>
			<pre class="source-code">
import { ASB } from "../../helpers/globalObjects";
import candymapperPage from "../pageObjects/candymapper.page";
import halloweenAttendPartyPage from "../pageObjects/halloweenAttendParty.page";
import halloweenPartyPage from "../pageObjects/halloweenParty.page";
import halloweenPartyLocationPage from "../pageObjects/halloweenPartyLocation.page";
import halloweenPartyThemePage from "../pageObjects/halloweenPartyTheme.page";
import halloweenPartyTimerPage from "../pageObjects/halloweenPartyTimer.page";
import * as helpers from "../../helpers/helpers";
import AllureReporter from "@wdio/allure-reporter";
import Page from "../pageObjects/page";
class StateDrivenUtils extends Page {</pre>			<h2 id="_idParaDest-218"><a id="_idTextAnchor275"/>The big driver loop</h2>
			<p>The <strong class="source-inline">partyPath()</strong> method is actually a utility, rather than a test, so we will store it in a <strong class="source-inline">Utilities</strong> folder in the <a id="_idIndexMarker561"/>project <span class="No-Break">root folder:</span></p>
			<pre class="source-code">
export async function partyPath (testData) {
    let complete: Boolean = false;
    let lastPage: string = ""
    let retry = 2
   this.parseTestData(testData);  // Parse the known milestone verbs                                   // to the switchboard
    helpers.parseToASB(testData);   // Parse the key=value data to set                                     // the switchboard</pre>			<p>The next step is to navigate the start of the Halloween Party path. This will require an <strong class="source-inline">is a</strong> loop that processes every page repeatedly, seeking one of four <span class="No-Break">exit points:</span></p>
			<pre class="source-code">
    while (complete === false) { // Loop until final page
      //Get Page Name
        let pageName = await browser.getUrl();
        pageName = extractPathFromUrl(pageName)
        ASB.set("page", pageName);</pre>			<p>This puts the name of the current page into the Switchboard. This object will be read in every page’s <strong class="source-inline">build()</strong> method. Next, we will call every known page, using logical <strong class="source-inline">OR</strong>, to determine whether any were <span class="No-Break">successfully identified:</span></p>
			<pre class="source-code">
   // Pass through every known page
knownPage =
        await halloweenLocationPage.build() ||
        await halloweenAttendPartyPage.build() ||
   await halloweenHostPartyPage.build() ||
   await halloweenPartyPage.build() ||
// Add new pages along the journey here.</pre>			<p>Note that these pages do not need to be in any particular order. In fact, our designs have placed the first processing page list last and others in roughly reverse order. This tends to ensure only <a id="_idIndexMarker562"/>one page gets parsed per loop. Having multiple pages executing per loop is just <span class="No-Break">as acceptable.</span></p>
			<p class="callout-heading">Rule of thumb – refactoring</p>
			<p class="callout">In this small example, we are using only six pages. Real-world projects may have 50 to 100 web pages to navigate. It is always recommended to reduce code to smaller, more manageable units. In this case, the longer the lists of pages, the more they should be refactored into their <span class="No-Break">own function.</span></p>
			<p>We now add the first of the four exit points. Note that in the preceding list of pages, one is missing – the final countdown page. This is the success page where our journey ends. Nothing else matters at <span class="No-Break">this point:</span></p>
			<pre class="source-code">
// Exit Point #1: Success reached the timer page
   if (await halloweenPartyTimerPage.build()) {
      knownPage = true; // Skip Exit point 2
      console.log("Success: Reached the timer page")
      complete = true; // Exit the loop
 break;
   } // End of all paths except unknown page</pre>			<p>If this page is processed, we report the successful end of the journey. It also sets out the <strong class="source-inline">knownPage</strong> flag as <strong class="source-inline">true</strong> for any additional reporting or cleanup at the end of the function. Then, we <span class="No-Break">break out.</span></p>
			<p>Our job here is done, unless there is something unknown lurking <span class="No-Break">out there?</span></p>
			<pre class="source-code">
// Exit Point #2: Unknown page encountered
   if (knownPage === false) {
     //None of the build methods returned true
     AllureReporter.addAttachment(`Unknown Page detected: ${pageName}`, "", "text/plain");
    console.log(`Unknown Page detected: ${pageName} - Exiting Journey`);
    expect(pageName).toBe("a known page");
    break;
}</pre>			<p>In this case, no page returned <strong class="source-inline">true</strong>. We output the name of the unknown page. We also use a clever <strong class="source-inline">expect</strong> to<a id="_idIndexMarker563"/> set the test to a failed status, while further documenting the issue at hand, the URL of the new page. In our example, the production website <strong class="source-inline">Candymapper.com</strong> will generate an <strong class="source-inline">Error 404</strong> page when a guest is too scared to go to a party and expects to return. This page is never expected, but if we can <span class="No-Break">screen-capture it.</span></p>
			<p>Next, we need to handle a situation where a page just did not move forward from the <span class="No-Break">last one:</span></p>
			<pre class="source-code">
// Exit Point #3: Page did not change
if (lastPage === pageName) {
  retry--; // Give two additional attempts
  if (retry === 0) {
    console.log(`Page did not change: ${lastPage} - Exiting Journey`);
    expect("Page did not move on from").toBe(lastPage);
  } else {
     // Page moved on, reset retry for next page
     retry = 2;
  }
}</pre>			<p>As superheroes, we are always open to second chances. In this case, a page could have two or three states itself. A point of sale page might add one product if the cart is empty and a different item if the <a id="_idIndexMarker564"/>cart has one item, before moving on. Calling such a method twice could be required and <span class="No-Break">offer flexibility.</span></p>
			<p>Lastly, there could be a journey that expects an alternative page as its final destination. This is rare but presented as an option. This path is one where we return to a prior step in the process. This works because the page was identified and processed as the first step in the loop, moving to the next page before reaching <span class="No-Break">this point:</span></p>
			<pre class="source-code">
// Exit Point #4: We were scared and went back - Halloween Party Home page reached - only works in dev, prod has an intentional Error 404 issue.
if (ASB.get("page") === "halloween-party") {
   console.log("Halloween Party Home page reached")
   complete = true;
}</pre>			<p>Is that all the exit points? We are certain there are other ways journeys must end prematurely. We can think of one more example – an infinite loop journey. This would require tracking an array of all the URLs visited. It would be triggered when a page has been visited for the third time. We have given you all the tips and tricks to pull this off. Now, it is time to work this one out on <span class="No-Break">your own.</span></p>
			<p>Our final step before cycling back again is to set the current page name to the last <span class="No-Break">page name:</span></p>
			<pre class="source-code">
      lastPage = ASB.get("page"); // Save the last page name
    }</pre>			<p>This ensures that exit point #3 works correctly when determining whether we are stuck on the <span class="No-Break">same page.</span></p>
			<p>Next, the test data file object is<a id="_idIndexMarker565"/> used to determine what fields are populated. If the test data object does not contain the data for a particular field, a warning is added to our results, but the <span class="No-Break">test continues.</span></p>
			<p>Finally, the method to move on to the next page is performed. Note that we will use the <strong class="source-inline">ClickIfExits()</strong> method to ensure our engine remains robust, even if the element does not exist in future <span class="No-Break">test environments.</span></p>
			<p>In the loop, we check to see whether the page has moved on with an increment counter, starting at 2. If the page did not move on in the first loop, we decrement the loop counter. If the loop counter reaches 0, we have failed to successfully move on, and we exit. If successive loops do result in a new page URL, the counter is reset to perform two <span class="No-Break">additional loops.</span></p>
			<p>Some pages may have code that can resolve issues generated by incomplete data. This may not have been detected in the first execution of the <strong class="source-inline">build</strong> method for the page; thus, the build method must be executed at least twice before the test user journey <span class="No-Break">is abandoned.</span></p>
			<p>Once we have completed this process for each page, we can begin to add milestones, based on the values passed from the <strong class="source-inline">JOURNEY</strong> user variable. In this example, we will have a path that plans a zombie party by default but will switch to a user attending a party, by passing <strong class="source-inline">attend</strong> in the <strong class="source-inline">JOURNEY</strong> string. This, in turn, will be injected into the test data object and read by the <span class="No-Break">proper page.</span></p>
			<p>If we encounter a page that is new, the test will stop. We will report the URL of the page to Allure and provide a screen capture of the results. Our reporting automatically tells us the path that led us to that <span class="No-Break">new endpoint.</span></p>
			<h2 id="_idParaDest-219"><a id="_idTextAnchor276"/>It’s all in the details</h2>
			<p>Similarly, we could detect the string <strong class="source-inline">error</strong> in the URL on our page report with a screen capture, or we could capture all the text on the screen this way – <strong class="source-inline">const allText = </strong><span class="No-Break"><strong class="source-inline">await $('body').getText();</strong></span><span class="No-Break">.</span></p>
			<p>Another way to capture<a id="_idIndexMarker566"/> the scree text would be to send <em class="italic">Ctrl-A / Ctrl-V</em> to the browser and send the clipboard to the <span class="No-Break">Allure report:</span></p>
			<pre class="source-code">
import { clipboard } from 'electron';
const operatingSystem = process.platform;
let selectAllKeys: string[];
let copyKeys: string[];
if (operatingSystem === 'darwin') {
  selectAllKeys = ['Command', 'a'];
  copyKeys = ['Command', 'c'];
} else {
  selectAllKeys = ['Control', 'a'];
  copyKeys = ['Control', 'c'];
}
await browser.keys(selectAllKeys);
await browser.keys(copyKeys);
const allText = clipboard.readText();</pre>			<p>This makes it more likely we will capture only the visible text of <span class="No-Break">the browser.</span></p>
			<p>This loop also provides the opportunity to interact with any known page, regardless of the order it appears in the path. Consider this path in the candymapperR2 website hosting <span class="No-Break">a party:</span></p>
			<ol>
				<li>Host <span class="No-Break">a Party</span></li>
				<li>Party Venue <span class="No-Break">Address Confirmed</span></li>
				<li><span class="No-Break">Party Theme</span></li>
				<li><span class="No-Break">Party Countdown</span></li>
			</ol>
			<p>And consider the path to attend <span class="No-Break">a party:</span></p>
			<ol>
				<li>Attend <span class="No-Break">a Party</span></li>
				<li>Choose a Party Venue <span class="No-Break">or Return</span></li>
				<li>Party Venue <span class="No-Break">Location Address</span></li>
				<li><span class="No-Break">Party Countdown</span></li>
			</ol>
			<p>Note that these two paths <a id="_idIndexMarker567"/>encounter the same <strong class="bold">Party Venue Location Address</strong> page but from different pages. In addition, the paths of these two journeys are different from the production Candymapper website. Thus, we can have the same test case run in two environments with dissimilar paths and still complete <span class="No-Break">its goal.</span></p>
			<p>Our final path would be to set our final expected page. In this example, the path returns us to the <strong class="source-inline">Plan</strong> or <strong class="source-inline">Attend</strong> page indicating the user journey; although it did not end at the common endpoint, it was still <span class="No-Break">a success.</span></p>
			<h1 id="_idParaDest-220"><a id="_idTextAnchor277"/>Changing decision points</h1>
			<p>The way we pass the <a id="_idIndexMarker568"/>string that customizes a path is through a single environmental variable, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
Set JOURNEY=""; yarn ch15</pre>			<p>This way, we can create test several paths. In this example, the user does not attend the party and instead clicks the <strong class="bold">I’m </strong><span class="No-Break"><strong class="bold">scared</strong></span><span class="No-Break"> button:</span></p>
			<pre class="source-code">
Set JOURNEY="attend scared"; yarn ch15</pre>			<p>With this example, the user takes the path to host the party with a <span class="No-Break">zombie theme:</span></p>
			<pre class="source-code">
Set JOURNEY="Host ZOMBIE"; yarn ch15</pre>			<p>A single environmental value can modify multiple decision points from the Happy Path baseline. While an empty string by default will create a Happy Path, the best practice is to assign the string so that the path is shown in the results, with the parsing <span class="No-Break">being case-insensitive.</span></p>
			<pre class="source-code">
let journey: string = " " + (process.env.JOURNEY || "Host").toLowerCase();
if (journey===" ")) {
    journey = " host"; //Default Happy Path
}</pre>			<p>Note that there is a space<a id="_idIndexMarker569"/> prepended to the journey variable. The reason for this is to make it less likely to match a similar string in the path. We have a <strong class="source-inline">host</strong> command and a <strong class="source-inline">ghost</strong> party. Writing this line of code could potentially take the <strong class="source-inline">host</strong> command from the <span class="No-Break"><strong class="source-inline">ghost</strong></span><span class="No-Break"> string:</span></p>
			<pre class="source-code">
Set JOURNEY="Attend Ghost"; yarn ch15
if (journey.includes(" host").toLowerCase()) {
// Host path being taken in error.
}</pre>			<p>This is resolved, as every command that is acted upon always has a prepended space. Now, there is less chance of an incorrect path match. For our example, we will go one step further, making <strong class="source-inline">Host</strong> the default Happy Path and <strong class="source-inline">Attend</strong> the deviation from <span class="No-Break">the path:</span></p>
			<pre class="source-code">
if (journey.includes(" attend").toLowerCase()) {
// Attend a party path, case insensitively
Helpers.click(attend)
} else {
    // The JOURNEY variable contains "host" Happy Path
Helpers.click(host)
}</pre>			<p>This completes the first method to choose a decision point on the first page. The function exits and loops around. The next page could be next, but it does not have to be in sequential order. It could be further down the list inside the loop.  All the following pages will not match <a id="_idIndexMarker570"/>the URL, and the <strong class="source-inline">build()</strong> method will simply return immediately as a null function. The next page could be earlier in the loop. It would have executed as a null function before this page and now executes as the loop starts from the <span class="No-Break">top again.</span></p>
			<h1 id="_idParaDest-221"><a id="_idTextAnchor278"/>Wash, rinse, repeat</h1>
			<p>The same principle applies to modifying the type of data in the page classes. As an example, the custom <strong class="source-inline">date</strong> tokens could be passed <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Set JOURNEY="host &lt;today+7&gt;"; yarn ch15
const match = journey.match(/(&lt;.+&gt;)/);
const dateToken = match ? match[0] : "";
Helpers.setValueIfExists(dateField, dateToken);</pre>			<p>Now, we have a date token extracted from the journey value. The token is passed to <strong class="source-inline">dateField</strong>, if it exists, and set to next week’s date. If there is no token, the date is set to an empty string, which the method will return immediately as there is nothing <span class="No-Break">to do.</span></p>
			<p>At this point, we have covered all the processes of a non-deterministic engine. New pages will be reported in the results and must be added to extend the path coverage. If a page is never encountered in a particular path, it does not stop the test. If an error is encountered, it is reported. If the path gets stuck, it is also reported. The data and the paths can be customized. These build methods can be called from other <span class="No-Break">test cases.</span></p>
			<h1 id="_idParaDest-222"><a id="_idTextAnchor279"/>Why not generate these Artifacts with API calls?</h1>
			<p>Using API calls for a task does <a id="_idIndexMarker571"/>mean quicker and more stable testing, as it directly communicates with an application. It can be implemented earlier in the development process. This could lead to early detection of issues, making the development <a id="_idIndexMarker572"/>process more flexible <span class="No-Break">and agile.</span></p>
			<p>Conversely, using an automated GUI could provide a richer understanding of the user experience, as it can simulate the exact paths a user might take, including interactions with visual elements that API tests might overlook. This approach might be more intuitive and can encompass a broader analysis, including the appearance and layout, which are crucial for <span class="No-Break">user satisfaction.</span></p>
			<p>In fact, there is no reason to support once approach over another. The GUI approach confirms the system works correctly for the user. The API approaches generate the artifacts with greater speed. We can implement the differences in the approaches by  adding another keyword value to the journey <span class="No-Break">parsing code:</span></p>
			<pre class="source-code">
Set JOURNEY="military references api"; yarn job-app-engine
if (journey.toLowerCase().includes(" api)) {
// API pat<a id="_idTextAnchor280"/>h
} else {
// GUI path
}</pre>			<p>In this example, the default GUI approach is overridden wit<a id="_idTextAnchor281"/>h an API path in the same <span class="No-Break"><strong class="source-inline">build()</strong></span><span class="No-Break"> methods.</span></p>
			<h1 id="_idParaDest-223"><a id="_idTextAnchor282"/>Summary</h1>
			<p>In this chapter, we delved into a sophisticated approach to test automation, reminiscent of a superhero strategizing for dynamic and complex missions with multiple potential outcomes based on choices made. Our method involved a loop that continuously navigates through each page, engaging only upon recognizing a known resource. The journey is non-deterministic shaped by high-level objectives and occasionally encountering unexpected obstacles like dead ends or <span class="No-Break">logic loops.</span></p>
			<p>This approach is flexible, allowing for the adjustment of user paths based on various variables and can be adapted to different environments, highlighting its robustness and versatility. It also aids in data generation for manual testers, significantly reducing the time and effort needed to create data records for testing when paired with tools like Jenkins, enhancing the efficiency of the testing <span class="No-Break">process overall.</span></p>
			<p>In the final chapter, this approach will have additional advantages, making manual testers more efficient. The worst idea is to assume automation replaces “costly” manual testers. We should aways strive to augment their efforts. Manual testers could reduce a lot of setup time creating complex test artifacts when they only need to validate the results. But do we want to have them install a coding tool and teach them how to run a script like this? This is where we employ our final magical item and let a CI/CD tool provide an effortless way to do the heavy lifting. Something like a mystic sentient cloak of <span class="No-Break">levitation perhaps?</span></p>
		</div>
	</body></html>