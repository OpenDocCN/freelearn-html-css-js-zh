- en: Chapter 2. The Ember.Object Model
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Working with classes and instances
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with computed properties
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Ember observers in Ember.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with bindings
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mixins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using enumerables with arrays
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ember.Object** is the base class for almost every other Ember object. Routes,
    models, views, and components all inherit from Ember.Object. It''s used everywhere
    so it''s important to understand how it works and how it can be used in our application.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Standard JavaScript objects aren't used often in Ember. Ember's object model
    builds on JavaScript objects and adds important features such as observers, mixins,
    computed properties, and initializers. Many of these features are aligned to be
    in the new **ECMAScript** standard.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Working with classes and instances
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and extending classes is a major feature of the Ember object model.
    In this recipe, we'll take a look at how creating and extending objects works.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a very simple `Ember` class using `extend()`:'
  id: totrans-14
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-15
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This defines a new `Light` class with a property called `isOn`. `Light` inherits
    properties and behavior from the Ember object, such as initializers, mixins, and
    computed properties.
  id: totrans-16
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  id: totrans-17
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ember Twiddle tip**'
  id: totrans-18
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At any point of time, you might need to test out small snippets of the Ember
    code. An easy way to do this is to use a website called **Ember Twiddle**. From
    this website, you can create an Ember application and run it in the browser as
    if you were using the Ember CLI. You can even save and share it. It has similar
    tools such as JSFiddle but only for Ember. Check it out at [http://ember-twiddle.com](http://ember-twiddle.com).
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have defined a class, you''ll need to be able to create an instance
    of it. You can do this using the `create()` method. We''ll go ahead and create
    an instance of `Light`:'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Accessing properties within the bulb instance
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can access the properties of the `bulb` object using the `set` and `get`
    accessor methods. Let''s go ahead and get the `isOn` property of the `Light` class:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The preceding code will get the `isOn` property from the `bulb` instance.
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To change the `isOn` property, we can use the `set` accessor method:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `isOn` property will now be set to `true` instead of `false`.
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initializing the Ember object
  id: totrans-29
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `init` method is invoked whenever a new instance is created. This is a great
    place to put in any code that you may need for the new instance.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we''ll add an alert message that displays the default setting
    for the `isOn` property:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: As soon as the `Light.create` line of code is executed, the instance will be
    created and **The isON property is defaulted to false** message will pop up on
    the screen.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Subclass**'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Be aware that you can create subclasses of your objects in Ember. You can override
    methods and access the parent class using the `_super()` keyword method. This
    is done by creating a new object that uses the Ember `extend` method on the parent
    class.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，你可以在Ember中创建你对象的子类。你可以重写方法并使用`_super()`关键字方法访问父类。这是通过创建一个新的对象来完成的，该对象使用父类的Ember
    `extend`方法。
- en: Another important thing is if you're subclassing a framework class such as `Ember.Component`
    and you override the `init` method, you'll need to make sure that you call `this._super()`.
    If not, the component might not work properly.
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 另一个重要的事情是，如果你正在子类化一个框架类，例如`Ember.Component`，并且你重写了`init`方法，你需要确保调用`this._super()`。如果不这样做，组件可能无法正常工作。
- en: Reopening classes
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 重新打开类
- en: At any time, you can reopen a class and define new properties or methods in
    it. For this, use the `reopen` method.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何时候，你都可以重新打开一个类并在其中定义新的属性或方法。为此，请使用`reopen`方法。
- en: 'In our previous example, we had an `isON` property. Let''s reopen the same
    class and add a `color` property:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的示例中，我们有一个`isON`属性。让我们重新打开同一个类并添加一个`color`属性：
- en: 'To add the `color` property, we need to use the `reopen()` method:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加`color`属性，我们需要使用`reopen()`方法：
- en: '[PRE5]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If needed, you can add static methods or properties using `reopenClass`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，你可以使用`reopenClass`添加静态方法或属性：
- en: '[PRE6]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can now access the static property `Light.wattage`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你现在可以访问静态属性`Light.wattage`。
- en: How it works...
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the previous examples, we created an Ember object using `extend`. This tells
    Ember to create a new `Ember` class. The `extend` method uses inheritance in the
    Ember.js framework. The `Light` object inherits all the methods and bindings of
    the Ember object.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们使用`extend`创建了Ember对象。这告诉Ember创建一个新的`Ember`类。`extend`方法在Ember.js框架中使用继承。`Light`对象继承了Ember对象的所有方法和绑定。
- en: The `create` method also inherits from the Ember object class and returns a
    new instance of this class. The `bulb` object is a new instance of the Ember object
    that we created.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`create`方法也继承自Ember对象类，并返回该类的新实例。`bulb`对象是我们创建的Ember对象的新实例。'
- en: There's more...
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: To use the previous examples, we can create our own module and import it to
    our project.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用前面的示例，我们可以创建自己的模块并将其导入到我们的项目中。
- en: 'To do this, create a new file in the `app` folder called `MyObject.js`:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要这样做，在`app`文件夹中创建一个名为`MyObject.js`的新文件：
- en: '[PRE7]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This is a module that we can now import to any file in our Ember application.
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个我们可以现在导入到我们的Ember应用程序中任何文件的模块。
- en: 'In the `app` folder, edit the `app.js` file. You''ll need to add the following
    line at the top of the file:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`app`文件夹中，编辑`app.js`文件。你需要在文件顶部添加以下行：
- en: '[PRE8]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the bottom, before the export, add this line:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在导出之前，添加以下行：
- en: '[PRE9]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will execute the `myObject` function that we created in the `myObject.js`
    file. After running `ember server`, you'll see the `isOn` property defaulted to
    a `false` popup message.
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将执行我们在`myObject.js`文件中创建的`myObject`函数。在运行`ember server`之后，你会看到`isOn`属性默认显示为`false`的弹出消息。
- en: Working with computed properties
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用计算属性
- en: In this recipe, we'll take a look at computed properties and how they can be
    used to display data, even if that data changes as the application is running.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看计算属性以及它们如何用于显示数据，即使这些数据在应用程序运行时发生变化。
- en: How to do it...
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s create a new Ember.Object and add a computed property to it:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的Ember.Object并给它添加一个计算属性：
- en: 'Let''s begin by creating a new `description` computed property. This property
    will reflect the status of the `isOn` and `color` properties:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们首先创建一个新的`description`计算属性。这个属性将反映`isOn`和`color`属性的状态：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We can now create a new `Light` object and get the computed property `description`:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以创建一个新的`Light`对象并获取计算属性`description`：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The preceding example creates a computed property that depends on the `isOn`
    and `color` properties. When the `description` function is called, it returns
    a string describing the state of the light.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的示例创建了一个依赖于`isOn`和`color`属性的计算属性。当调用`description`函数时，它返回一个描述灯的状态的字符串。
- en: Computed properties will observe changes and dynamically update whenever they
    occur.
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 计算属性将观察变化，并在它们发生时动态更新。
- en: 'To see this in action, we can change the preceding example and set the `isOn`
    property to `false`. Use the following code to accomplish this:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要看到这个功能的效果，我们可以修改前面的示例并将`isOn`属性设置为`false`。使用以下代码来完成此操作：
- en: '[PRE12]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The description has been automatically updated and will now display `The yellow
    light is set to true`.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 描述已经自动更新，现在将显示`The yellow light is set to true`。
- en: Chaining the Light object
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 连接 Light 对象
- en: Ember provides you with a nice feature that allows computed properties to be
    present in other computed properties. In the previous example, we created a `description`
    property that outputted some basic information about the `Light` object.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 提供了一个很好的功能，允许计算属性存在于其他计算属性中。在先前的例子中，我们创建了一个 `description` 属性，该属性输出了有关
    `Light` 对象的一些基本信息。
- en: 'Let''s add another property that gives a full description:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们添加另一个属性，该属性提供完整的描述：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `fullDescription` function returns a string that concatenates the output
    from the description with a new string that displays `age`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`fullDescription` 函数返回一个字符串，该字符串将描述的输出与显示 `age` 的新字符串连接起来：'
- en: '[PRE14]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In this example, during the instantiation of the `Light` object, we set the
    `age` to `22`. We could have overwritten any property if necessary.
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，在 `Light` 对象实例化期间，我们将 `age` 设置为 `22`。如果需要，我们可以覆盖任何属性。
- en: Alias
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 别名
- en: The `Ember.computed.alias` method allows us to create a property that is an
    alias for another property or object.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.computed.alias` 方法允许我们创建一个属性，该属性是另一个属性或对象的别名。'
- en: 'Any call to `get` or `set` will behave as if the changes were made to the original
    property:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `get` 或 `set` 的任何调用都将表现得像是更改了原始属性：
- en: '[PRE15]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `aliasDescription` alias will display the same text as `fullDescription`
    as it's just an alias of this object. If we made any changes to any properties
    in the `Light` object later, the alias would also observe these changes and be
    computed properly. We'll discuss more about this in the *Working with bindings*
    recipe.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`aliasDescription` 别名将显示与 `fullDescription` 相同的文本，因为它只是这个对象的别名。如果我们稍后对 `Light`
    对象中的任何属性进行了更改，别名也会观察这些更改并正确计算。我们将在 *使用绑定* 的配方中进一步讨论这一点。'
- en: How it works...
  id: totrans-84
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Computed properties are built on top of the observer pattern. Whenever an observation
    shows a state change, it recomputes the output. If no changes occur, then the
    result is cached.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性建立在观察者模式之上。每当观察显示状态变化时，它都会重新计算输出。如果没有变化发生，则结果将被缓存。
- en: In other words, computed properties are functions that get updated whenever
    any of their dependent values change. You can use them in much the same way that
    you would use a static property. They are common and useful throughout Ember and
    its codebase.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，计算属性是当它们的依赖值中的任何一个发生变化时都会更新的函数。您可以使用它们的方式与您使用静态属性的方式几乎相同。它们在 Ember 及其代码库中很常见且很有用。
- en: Keep in mind that a computed property will only update if it is in a template
    or function that is being used. If the function or template is not being called,
    nothing will occur. This will help with performance.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，计算属性只有在它位于模板或正在使用的函数中时才会更新。如果函数或模板没有被调用，则不会发生任何事情。这将有助于提高性能。
- en: Working with Ember observers in Ember.js
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Ember.js 中使用 Ember 观察者
- en: Observers are fundamental to the Ember object model. In the next recipe, we'll
    take our light example, add an observer, and see how it operates.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者是 Ember 对象模型的基础。在下一个配方中，我们将使用我们的灯示例，添加一个观察者，并查看它是如何运行的。
- en: How to do it...
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To begin, we''ll add a new observer called `isOnChanged`. This will only trigger
    when the `isOn` property changes:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将添加一个名为 `isOnChanged` 的新观察者。它只会在 `isOn` 属性更改时触发：
- en: '[PRE16]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '`Ember.observer` `isOnChanged` monitors the `isOn` property. If any changes
    occur to this property, `isOnChanged` is invoked.'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Ember.observer` `isOnChanged` 监视 `isOn` 属性。如果此属性发生任何更改，`isOnChanged` 将被调用。'
- en: Note
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Computed properties versus observers**'
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**计算属性与观察者**'
- en: At first glance, it might seem that observers are the same as computed properties.
    In fact, they are very different. Computed properties can use `get` and `set`
    methods and can be used in templates. Observers, on the other hand, just monitor
    property changes and cannot be used in templates or be accessed like properties.
    They don't return any values as well. With this said, be careful not to overuse
    observers. In many instances, a computed property is a more appropriate solution.
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 初看之下，观察者可能看起来与计算属性相同。实际上，它们非常不同。计算属性可以使用 `get` 和 `set` 方法，并且可以在模板中使用。另一方面，观察者只是监视属性变化，不能在模板中使用或像属性一样访问。它们也不返回任何值。因此，请注意不要过度使用观察者。在许多情况下，计算属性是更合适的解决方案。
- en: 'Additionally, if needed, you can add multiple properties to the observer. Just
    use the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，如果需要，您可以为观察者添加多个属性。只需使用以下代码：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `isAnything` observer is invoked whenever the `isOn` or `color` properties
    change. The observer will fire twice as each property has changed.
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`isOn`或`color`属性变化时，`isAnything`观察者会被调用。观察者会触发两次，因为每个属性都发生了变化。
- en: Synchronous issues with the Light object and observers
  id: totrans-100
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与Light对象和观察者的同步问题
- en: It's very easy to get observers out of sync. If, for example, a property that
    it observes changes, it will be invoked as expected. After being invoked, it might
    manipulate a property that hasn't been updated yet. This can cause synchronization
    issues as everything happens at the same time.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 观察者很容易变得不同步。例如，如果它观察的属性发生变化，它将按预期被调用。调用后，它可能会操作一个尚未更新的属性。由于所有事情都同时发生，这可能导致同步问题。
- en: 'The following example shows this behavior:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下示例展示了这种行为：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When `isOn` is changed it's not clear if `fullDescription`, a computed property,
    has been updated yet or not. As observers work synchronously, it's difficult to
    tell what has been fired and changed. This can lead to unexpected behavior.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`isOn`发生变化时，不清楚计算属性`fullDescription`是否已经更新。由于观察者同步工作，很难判断已经触发和改变的内容。这可能导致意外的行为。
- en: 'To counter this, it''s best to use the `Ember.run.once` method. This method
    is a part of the Ember `run` loop, which is Ember''s way of managing how code
    gets executed. Reopen the `Light` object and you will see the following:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了解决这个问题，最好使用`Ember.run.once`方法。这是Ember `run`循环的一部分，是Ember管理代码执行的方式。重新打开`Light`对象，你会看到以下内容：
- en: '[PRE19]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The `checkIsOn` observer calls the `checkChanged` observer using `Ember.run.once`.
    This method gets run only once per `run` loop. Normally, `checkChanged` would
    get fired twice; however, as it's being called using `Ember.run.once`, it outputs
    only once.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`checkIsOn`观察者使用`Ember.run.once`调用`checkChanged`观察者。此方法在每个`run`循环中只运行一次。通常，`checkChanged`会被触发两次；然而，由于它是通过`Ember.run.once`调用的，它只输出一次。'
- en: How it works...
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ember observers are mixins from the `Ember.Observable` class. They work by monitoring
    property changes. When any change occurs, they are triggered. Keep in mind that
    these are not the same as computed properties and cannot be used in templates
    or with getters or setters.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Ember观察者是来自`Ember.Observable`类的混入。它们通过监控属性变化来工作。当任何变化发生时，它们会被触发。请注意，这些与计算属性不同，不能在模板中使用，也不能与获取器或设置器一起使用。
- en: Working with bindings
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与绑定一起工作
- en: Most frameworks include some sort of binding implementation. Ember is no exception
    and has bindings that can be used with any object. The following recipes explain
    how to use them as well as one-way and two-way binding.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数框架都包含某种绑定实现。Ember也不例外，它有可以与任何对象一起使用的绑定。以下食谱解释了如何使用它们以及单向和双向绑定。
- en: How to do it...
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: In this example, there is a teacher and student Ember object. Each has its own
    set of properties and they both have homeroom. We can share the homeroom by setting
    an alias for the teacher object.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，有一个教师和学生Ember对象。每个都有自己的属性集，并且它们都有homeroom。我们可以通过为教师对象设置别名来共享homeroom。
- en: 'Let''s begin by creating a teacher and student `Ember.Object`:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从创建一个教师和学生`Ember.Object`开始：
- en: '[PRE20]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The student `homeroom` is `Ember.computed.alias`, which will bind the `homeroom`
    property to `teacher.homeroom`.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 学生`homeroom`是`Ember.computed.alias`，它将`homeroom`属性绑定到`teacher.homeroom`。
- en: 'Next, we''ll instantiate the `teacher` and `student` objects:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将实例化`teacher`和`student`对象：
- en: '[PRE21]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `joey` object has the `homeroom` property set to `avery`, which is the `teacher`
    object that we just created.
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`joey`对象将`homeroom`属性设置为`avery`，这是我们刚刚创建的`teacher`对象。'
- en: 'We can now use `console.log` to output our findings:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在可以使用`console.log`来输出我们的发现：
- en: '[PRE22]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, whenever the `avery` object changes its `homeroom`, the student
    `joey` `homeroom` changes as well. This is because the homeroom for joey is an
    alias for the teacher, `avery`.
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如你所见，每当`avery`对象更改其`homeroom`时，学生`joey`的`homeroom`也会改变。这是因为joey的homeroom是教师`avery`的别名。
- en: 'You do not always have to access properties that reference other objects. You
    can bind to anything:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你并不总是需要访问引用其他对象的属性。你可以绑定到任何东西：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The alias points to `name`; therefore, when printing to the console, it shows
    `Erik Hanchett` for both.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 别名指向`name`；因此，当打印到控制台时，它显示`Erik Hanchett`。
- en: Note
  id: totrans-126
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Ember has a class called `Ember.Binding`. This is a public class that has very
    similar behavior and functionality as `Ember.computed.alias` and `Ember.computed.oneWay`.
    You should use `Ember.computed.alias` and not `Ember.Binding`. Computed aliases
    are the preferred method of binding in Ember. `Ember.Binding` is still around
    and will probably be deprecated at some point.
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One-way binding
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ember defaults to something called two-way binding. What this means is that
    when properties are changed in the UI, this is updated back in the controller
    or component. On the other hand, one-way binding propagates changes in one direction
    only.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let's say that we have a `User` object with a `firstName`, `lastName`,
    and `nickName` property. We can use `Ember.computed.oneWay` to create a one-way
    binding for the `firstName` property.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we try to make a change to it. Create a new user
    object with these properties. Instantiate the object and try changing the properties:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: You can see that `nickName` does not change even though user has been updated.
    You can think of one-way binding like using `Ember.computed.alias`. However, it
    allows you to get values only and not set them. The upstream properties don't
    get changed when using `Ember.computed.oneWay`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ember bindings are used in many parts of the Ember framework. They are derived
    from the `Ember.computed` namespace. In this namespace is the computed alias method.
    A computed alias specifies the path to another object by creating a two-way binding.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Binding objects don't update immediately. Ember waits until all the application
    code has finished running before synchronizing all the changes. This prevents
    unneeded overhead of syncing bindings when values are being updated.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: One-way binding works by information being propagated only one way. Information
    does not get updated in the upstream properties.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Using mixins
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixins are a great way of reusing and sharing code in Ember. The following recipes
    go over some basic operations on how to use them in your code.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll create a common mixin object.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an Ember mixin object that has a couple of properties and a function:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This mixin can be added to any object. For the sake of simplicity, all this
    mixin does is display some text and set the `isEditing` property to `true` if
    the `edit` function is invoked.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s see what it looks like when we add this object to an object:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `extend` method present in `Ember.Object` allows for one or more optional
    arguments of the `Ember.Mixin` type. In this example, we added the common mixin
    to the new `Ember.Object` object. We then instantiated this Ember object using
    `create`.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All that''s left is to output the contents. Use `console.log` to display each
    property:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This is what the output will look like. As you can see, we can access any of
    the mixin properties or methods as if the mixin was included in the Ember object
    itself. This is a convenient way of reusing code in your applications.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s create another mixin:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now let''s see how this looks if we add it to an Ember object:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Now, we can have access to both the common and `secondMixin` in our object.
    We can use `console.log` to output `secondProperty`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Mixins with the Ember CLI
  id: totrans-157
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mixins work very well with the Ember CLI. To start, use the mixin generator
    to create one.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you''re in the application directory, and then type the following
    command:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `generator` command creates an `app/mixins` folder and the `common.js` file.
    The `common.js` file is where we will put the code for the mixin.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ll use the mixin from the previous example and add it to this file:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This mixin is exactly the same as the previous example; however, now it's in
    a module that we can import anywhere, including components or controllers.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For now, we'll import it to our `app.js` file in the `app` folders directory.
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we''ll need to add the `import` statement to the top of the file:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This allows us to use the common mixin anywhere in the `app.js` file.
  id: totrans-168
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ll add the following code to the bottom of the `app/app.js` file:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: As you can see, all the properties and methods in the common mixin are available
    to the object.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we were to add the common mixin to a component, it might look like following
    code. Add this code to the `common-example.js` file:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As always, we must first import the mixin to our component. The path is always
    relative to the directory you're in, therefore, we must use `../mixins/common`
    to find it.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the component, I added a simple action called `pressed` that triggers the
    mixin `edit` method. If the action gets triggered, we would see the `Starting
    to edit message` in the console. Look for more examples of components in [Chapter
    6](part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb "Chapter 6. Ember
    Components"), *Ember Components*.
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Ember.Mixin` class allows the creation of mixins whose properties and methods
    can be added to other classes. They can't be instantiated but they can be added
    or *mixed in*.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: A mixin in computer science is a class that lends or copies it's behavior to
    a borrowing class using composition instead of inheritance. It encourages code
    reuse and avoids ambiguity that multiple inheritance can cause.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Using enumerables with arrays
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Ember.Enumerable` methods are very important when dealing with arrays.
    In these recipes, we'll look at some common use cases.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use enumerables, we must first take a look at the standard
    JavaScript array methods and their equivalents using observable enumerables:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '| Standard method | Observable equivalent |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `unshift` | `unshiftObject` |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| `shift` | `shiftObject` |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| `reverse` | `reverseObjects` |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: '| `push` | `pushObject` |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
- en: '| `pop` | `popObject` |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `pop` | `popObject` |'
- en: We'll be using some of these methods in our examples, so keep in mind what the
    standard and observable equivalents are.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在示例中使用一些这些方法，所以请记住它们的标准和可观察的等效方法。
- en: 'The `Ember.Enumerable` class has several methods that we can use in our Ember
    applications. Here is the list of the more common methods and what they do:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.Enumerable`类有几个我们可以在我们的Ember应用程序中使用的方法。以下是更常见的方法列表以及它们的作用：'
- en: '| Enumerable method | Definition |'
  id: totrans-192
  prefs: []
  type: TYPE_TB
  zh: '| 枚举方法 | 定义 |'
- en: '| --- | --- |'
  id: totrans-193
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `forEach` | This iterates through the enumerable, calling the passed function
    on each item |'
  id: totrans-194
  prefs: []
  type: TYPE_TB
  zh: '| `forEach` | 这遍历枚举，对每个项调用传递的函数 |'
- en: '| `firstObject` | This returns the first object in a collection |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| `firstObject` | 这返回集合中的第一个对象 |'
- en: '| `lastObject` | This returns the last object in a collection |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| `lastObject` | 这返回集合中的最后一个对象 |'
- en: '| `map()` | This maps all the items in the enumeration to another value, similar
    to map in JavaScript 1.6 |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `map()` | 这会将枚举中的所有项映射到另一个值，类似于JavaScript 1.6中的map |'
- en: '| `mapBy()` | Similar to map, this returns the value of the named property
    on all items on the enumeration |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `mapBy()` | 与map类似，这返回枚举中所有项的命名属性的值 |'
- en: '| `filter` | This returns an array with all of the items in the enumeration
    that the passed function returns true |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `filter` | 这返回一个数组，包含枚举中传递的函数返回true的所有项 |'
- en: '| `find` | This returns the first item in the array that the method returns
    true |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `find` | 这返回方法返回的第一个数组项 |'
- en: '| `findby` | This returns the first item with a property that matches the passed
    value |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `findby` | 这返回第一个具有与传递的值匹配的属性的项 |'
- en: '| `every` | This returns true only if the passed function returns true for
    every item in the enumeration |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `every` | 这仅在传递的函数对枚举中的每个项返回true时才返回true |'
- en: '| `any` | This returns true only if the passed function returns true for any
    item in the enumeration |'
  id: totrans-203
  prefs: []
  type: TYPE_TB
  zh: '| `any` | 这仅在传递的函数对枚举中的任何项返回true时才返回true |'
- en: Many of these methods are similar to their JavaScript counterparts. If you know
    how to use the JavaScript method, you should be able to use the Ember equivalent
    as well.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 许多这些方法与它们的JavaScript对应方法类似。如果您知道如何使用JavaScript方法，您应该能够使用Ember的等效方法。
- en: How to do it...
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: '`Ember.Enumerables` adds all the nice features of Ember objects to enumerables.
    We''ll take a look at several examples on how to do this. The contents for all
    these recipes are in the `chapter2/example6` folder in the `app.js` file.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.Enumerables`将Ember对象的全部良好特性添加到枚举中。我们将查看几个示例，说明如何做到这一点。所有这些食谱的内容都在`app.js`文件中的`chapter2/example6`文件夹中。'
- en: Using forEach with an array
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数组中的forEach
- en: A very common use case for an enumerable is iterating over an array with `forEach`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举的一个非常常见的用例是使用`forEach`遍历数组。
- en: 'Create an array of students:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个学生数组：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Use the `forEach` enumerable to iterate over the array:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach`枚举遍历数组：
- en: '[PRE37]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The console output will show each student''s name in the array:'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 控制台输出将显示数组中的每个学生的姓名：
- en: '[PRE38]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Tip
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: '**Template literals**'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**模板字面量**'
- en: Ember is compatible with the latest in ECMAScript 2015\. One neat new feature
    is called template literals or template strings. Template literals are string
    literals that can stretch across multiple lines and include interpolated expressions.
    You can do string interpolation by surrounding variables in your strings, like
    this `${}`. Each variable will be displayed in the string as shown in the preceding
    `forEach` example.
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember与最新的ECMAScript 2015兼容。一个很酷的新特性被称为模板字面量或模板字符串。模板字面量是可以在多行中扩展并包含插值表达式的字符串字面量。您可以通过在字符串中包围变量来进行字符串插值，如下所示`${}`。每个变量将按前一个`forEach`示例中所示的方式显示在字符串中。
- en: Using map with an array
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用数组中的map
- en: The `map` method takes an array, maps each item, and returns a new modified
    array. Let's say that we want to make the student names all in uppercase. We can
    do this using `map`.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`map`方法接受一个数组，映射每个项，并返回一个新的修改后的数组。假设我们想将学生姓名全部转换为大写。我们可以使用`map`来实现这一点。'
- en: 'Create a list of `students`:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`students`列表：
- en: '[PRE39]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first letter is capitalized; however, we want all the letters in uppercase.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 第一个字母需要大写；然而，我们希望所有的字母都大写。
- en: 'Use `map` to convert every item to uppercase:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`map`将每个项目转换为大写：
- en: '[PRE40]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Every item in the array has been converted to uppercase. The new `upperCaseStudent`
    array has all the new values.
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 数组中的每个项目都已转换为大写。新的`upperCaseStudent`数组包含所有新值。
- en: 'Use the `forEach` enumerable to iterate through every item in the array and
    display its contents:'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`forEach`枚举遍历数组中的每个项目并显示其内容：
- en: '[PRE41]'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The output displays each name in the new `upperCaseStudent` array:'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-229
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Using mapBy with an array
  id: totrans-230
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mapBy` enumerable can be used if your array is comprised of objects. From
    each object, we can extract its named properties and return a new array.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a teacher and student object:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Each object has one property called `name`:'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next we'll instantiate each object.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Each object is put into a `people` array:'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use `mapBy` to create a new array.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: This new array returned has the values from the `name` property from both objects.
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finding the first and last objects in an array
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If necessary, we have an easy way to grab the first and last objects in an array.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by creating a student array:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This array has six different students.
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s grab the last object in the array:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will display `Susan`, the last object in the array.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s retrieve the first object in the array:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will display `Erik`, the first item in the array.
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can push objects on the array as well:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The student `Jeff` has now been added to the list:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Fun with filters
  id: totrans-256
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very common practice is to take an array and return a filtered list of items.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, create an array of numbers:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Take the `array` and `filter` it, returning only those numbers over `10`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Use `console.log` to display the new array:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: This new array has numbers only greater then 10 in it.
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using filterBy with a collection of objects
  id: totrans-265
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With `filterBy`, you can take a collection of objects and filter it by some
    property.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `student` object that has a `name` and `grade`:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Add the students to a new array:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Use `filterBy` to show the students who are seniors:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This returns an array of students who are seniors.
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can double-check the output using `forEach`:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Using find to get the first match
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `find` enumerable works very similarly to `filter` except that it stops
    after finding the first match.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array of numbers:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Use `array.find` to retrieve the first number in the list that is over `10`:'
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'We''ll then check the output of the new array:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: The answer is `25` as it's the first number in the list that is over 10.
  id: totrans-284
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using findBy with collections
  id: totrans-285
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `findBy` enumerable works very similarly to `filterBy` except that it stops
    after finding the first match.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `student` object:'
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-288
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Next, create an array of students:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Use `findBy` to match only the properties that have `grade` of `senior`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'This will return the first student who is a senior:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '`Jen Smith` is the first student who matches this criteria so it is returned
    to the `newStudent` array.'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Learning with the every enumerable
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `every` enumerable will return `true` only if every item matches a certain
    condition.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating an array of numbers:'
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Use the `every` enumerable to check whether every item in the array is greater
    than `10`:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This returns `true` because every item in the array is over `10`
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using any to find at least one match
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `any` enumerable will return `true` if at least one item matches a certain
    condition.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, create a list of numbers:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次创建一个数字列表：
- en: '[PRE67]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Use the `any` enumerable to check whether any of these numbers in this array
    are over `10`:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `any` 可枚举来检查这个数组中的这些数字是否超过 `10`：
- en: '[PRE68]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: This will return `true` because at least one number is above `10`.
  id: totrans-309
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将返回 `true`，因为至少有一个数字超过了 `10`。
- en: How it works...
  id: totrans-310
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Ember.Enumerable` mixin is Ember's implementation of the array API defined
    up to JavaScript 1.8\. It's applied automatically on page load so any method is
    available. In order for Ember to be able to observe changes in an enumerable,
    you must use `Ember.Enumerable`.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ember.Enumerable` 混合是 Ember 对 JavaScript 1.8 之前定义的数组 API 的实现。它在页面加载时自动应用，因此任何方法都是可用的。为了使
    Ember 能够观察可枚举的变化，你必须使用 `Ember.Enumerable`。'
- en: The enumerable API follows ECMAScript specifications as much as possible so
    it minimizes incompatibilities with the other libraries. It uses native browser
    implementations in arrays where available.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 可枚举 API 尽可能遵循 ECMAScript 规范，以最小化与其他库的不兼容性。在可用的情况下，它使用原生的浏览器实现。
