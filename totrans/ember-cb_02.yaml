- en: Chapter 2. The Ember.Object Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Working with classes and instances
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with computed properties
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with Ember observers in Ember.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with bindings
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using enumerables with arrays
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Ember.Object** is the base class for almost every other Ember object. Routes,
    models, views, and components all inherit from Ember.Object. It''s used everywhere
    so it''s important to understand how it works and how it can be used in our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Standard JavaScript objects aren't used often in Ember. Ember's object model
    builds on JavaScript objects and adds important features such as observers, mixins,
    computed properties, and initializers. Many of these features are aligned to be
    in the new **ECMAScript** standard.
  prefs: []
  type: TYPE_NORMAL
- en: Working with classes and instances
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating and extending classes is a major feature of the Ember object model.
    In this recipe, we'll take a look at how creating and extending objects works.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a very simple `Ember` class using `extend()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This defines a new `Light` class with a property called `isOn`. `Light` inherits
    properties and behavior from the Ember object, such as initializers, mixins, and
    computed properties.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Ember Twiddle tip**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At any point of time, you might need to test out small snippets of the Ember
    code. An easy way to do this is to use a website called **Ember Twiddle**. From
    this website, you can create an Ember application and run it in the browser as
    if you were using the Ember CLI. You can even save and share it. It has similar
    tools such as JSFiddle but only for Ember. Check it out at [http://ember-twiddle.com](http://ember-twiddle.com).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Once you have defined a class, you''ll need to be able to create an instance
    of it. You can do this using the `create()` method. We''ll go ahead and create
    an instance of `Light`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Accessing properties within the bulb instance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We can access the properties of the `bulb` object using the `set` and `get`
    accessor methods. Let''s go ahead and get the `isOn` property of the `Light` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code will get the `isOn` property from the `bulb` instance.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To change the `isOn` property, we can use the `set` accessor method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `isOn` property will now be set to `true` instead of `false`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Initializing the Ember object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `init` method is invoked whenever a new instance is created. This is a great
    place to put in any code that you may need for the new instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our example, we''ll add an alert message that displays the default setting
    for the `isOn` property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As soon as the `Light.create` line of code is executed, the instance will be
    created and **The isON property is defaulted to false** message will pop up on
    the screen.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Subclass**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Be aware that you can create subclasses of your objects in Ember. You can override
    methods and access the parent class using the `_super()` keyword method. This
    is done by creating a new object that uses the Ember `extend` method on the parent
    class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Another important thing is if you're subclassing a framework class such as `Ember.Component`
    and you override the `init` method, you'll need to make sure that you call `this._super()`.
    If not, the component might not work properly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Reopening classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At any time, you can reopen a class and define new properties or methods in
    it. For this, use the `reopen` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our previous example, we had an `isON` property. Let''s reopen the same
    class and add a `color` property:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add the `color` property, we need to use the `reopen()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If needed, you can add static methods or properties using `reopenClass`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can now access the static property `Light.wattage`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous examples, we created an Ember object using `extend`. This tells
    Ember to create a new `Ember` class. The `extend` method uses inheritance in the
    Ember.js framework. The `Light` object inherits all the methods and bindings of
    the Ember object.
  prefs: []
  type: TYPE_NORMAL
- en: The `create` method also inherits from the Ember object class and returns a
    new instance of this class. The `bulb` object is a new instance of the Ember object
    that we created.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the previous examples, we can create our own module and import it to
    our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, create a new file in the `app` folder called `MyObject.js`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a module that we can now import to any file in our Ember application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `app` folder, edit the `app.js` file. You''ll need to add the following
    line at the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the bottom, before the export, add this line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will execute the `myObject` function that we created in the `myObject.js`
    file. After running `ember server`, you'll see the `isOn` property defaulted to
    a `false` popup message.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with computed properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we'll take a look at computed properties and how they can be
    used to display data, even if that data changes as the application is running.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a new Ember.Object and add a computed property to it:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a new `description` computed property. This property
    will reflect the status of the `isOn` and `color` properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now create a new `Light` object and get the computed property `description`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding example creates a computed property that depends on the `isOn`
    and `color` properties. When the `description` function is called, it returns
    a string describing the state of the light.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Computed properties will observe changes and dynamically update whenever they
    occur.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To see this in action, we can change the preceding example and set the `isOn`
    property to `false`. Use the following code to accomplish this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The description has been automatically updated and will now display `The yellow
    light is set to true`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Chaining the Light object
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ember provides you with a nice feature that allows computed properties to be
    present in other computed properties. In the previous example, we created a `description`
    property that outputted some basic information about the `Light` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add another property that gives a full description:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The `fullDescription` function returns a string that concatenates the output
    from the description with a new string that displays `age`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, during the instantiation of the `Light` object, we set the
    `age` to `22`. We could have overwritten any property if necessary.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Alias
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Ember.computed.alias` method allows us to create a property that is an
    alias for another property or object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any call to `get` or `set` will behave as if the changes were made to the original
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `aliasDescription` alias will display the same text as `fullDescription`
    as it's just an alias of this object. If we made any changes to any properties
    in the `Light` object later, the alias would also observe these changes and be
    computed properly. We'll discuss more about this in the *Working with bindings*
    recipe.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Computed properties are built on top of the observer pattern. Whenever an observation
    shows a state change, it recomputes the output. If no changes occur, then the
    result is cached.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, computed properties are functions that get updated whenever
    any of their dependent values change. You can use them in much the same way that
    you would use a static property. They are common and useful throughout Ember and
    its codebase.
  prefs: []
  type: TYPE_NORMAL
- en: Keep in mind that a computed property will only update if it is in a template
    or function that is being used. If the function or template is not being called,
    nothing will occur. This will help with performance.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Ember observers in Ember.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Observers are fundamental to the Ember object model. In the next recipe, we'll
    take our light example, add an observer, and see how it operates.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To begin, we''ll add a new observer called `isOnChanged`. This will only trigger
    when the `isOn` property changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Ember.observer` `isOnChanged` monitors the `isOn` property. If any changes
    occur to this property, `isOnChanged` is invoked.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Computed properties versus observers**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: At first glance, it might seem that observers are the same as computed properties.
    In fact, they are very different. Computed properties can use `get` and `set`
    methods and can be used in templates. Observers, on the other hand, just monitor
    property changes and cannot be used in templates or be accessed like properties.
    They don't return any values as well. With this said, be careful not to overuse
    observers. In many instances, a computed property is a more appropriate solution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Additionally, if needed, you can add multiple properties to the observer. Just
    use the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `isAnything` observer is invoked whenever the `isOn` or `color` properties
    change. The observer will fire twice as each property has changed.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Synchronous issues with the Light object and observers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's very easy to get observers out of sync. If, for example, a property that
    it observes changes, it will be invoked as expected. After being invoked, it might
    manipulate a property that hasn't been updated yet. This can cause synchronization
    issues as everything happens at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows this behavior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When `isOn` is changed it's not clear if `fullDescription`, a computed property,
    has been updated yet or not. As observers work synchronously, it's difficult to
    tell what has been fired and changed. This can lead to unexpected behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To counter this, it''s best to use the `Ember.run.once` method. This method
    is a part of the Ember `run` loop, which is Ember''s way of managing how code
    gets executed. Reopen the `Light` object and you will see the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `checkIsOn` observer calls the `checkChanged` observer using `Ember.run.once`.
    This method gets run only once per `run` loop. Normally, `checkChanged` would
    get fired twice; however, as it's being called using `Ember.run.once`, it outputs
    only once.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ember observers are mixins from the `Ember.Observable` class. They work by monitoring
    property changes. When any change occurs, they are triggered. Keep in mind that
    these are not the same as computed properties and cannot be used in templates
    or with getters or setters.
  prefs: []
  type: TYPE_NORMAL
- en: Working with bindings
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most frameworks include some sort of binding implementation. Ember is no exception
    and has bindings that can be used with any object. The following recipes explain
    how to use them as well as one-way and two-way binding.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, there is a teacher and student Ember object. Each has its own
    set of properties and they both have homeroom. We can share the homeroom by setting
    an alias for the teacher object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by creating a teacher and student `Ember.Object`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The student `homeroom` is `Ember.computed.alias`, which will bind the `homeroom`
    property to `teacher.homeroom`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we''ll instantiate the `teacher` and `student` objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `joey` object has the `homeroom` property set to `avery`, which is the `teacher`
    object that we just created.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can now use `console.log` to output our findings:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, whenever the `avery` object changes its `homeroom`, the student
    `joey` `homeroom` changes as well. This is because the homeroom for joey is an
    alias for the teacher, `avery`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You do not always have to access properties that reference other objects. You
    can bind to anything:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The alias points to `name`; therefore, when printing to the console, it shows
    `Erik Hanchett` for both.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Ember has a class called `Ember.Binding`. This is a public class that has very
    similar behavior and functionality as `Ember.computed.alias` and `Ember.computed.oneWay`.
    You should use `Ember.computed.alias` and not `Ember.Binding`. Computed aliases
    are the preferred method of binding in Ember. `Ember.Binding` is still around
    and will probably be deprecated at some point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: One-way binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Ember defaults to something called two-way binding. What this means is that
    when properties are changed in the UI, this is updated back in the controller
    or component. On the other hand, one-way binding propagates changes in one direction
    only.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, let's say that we have a `User` object with a `firstName`, `lastName`,
    and `nickName` property. We can use `Ember.computed.oneWay` to create a one-way
    binding for the `firstName` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see what happens when we try to make a change to it. Create a new user
    object with these properties. Instantiate the object and try changing the properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: You can see that `nickName` does not change even though user has been updated.
    You can think of one-way binding like using `Ember.computed.alias`. However, it
    allows you to get values only and not set them. The upstream properties don't
    get changed when using `Ember.computed.oneWay`.
  prefs: []
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ember bindings are used in many parts of the Ember framework. They are derived
    from the `Ember.computed` namespace. In this namespace is the computed alias method.
    A computed alias specifies the path to another object by creating a two-way binding.
  prefs: []
  type: TYPE_NORMAL
- en: Binding objects don't update immediately. Ember waits until all the application
    code has finished running before synchronizing all the changes. This prevents
    unneeded overhead of syncing bindings when values are being updated.
  prefs: []
  type: TYPE_NORMAL
- en: One-way binding works by information being propagated only one way. Information
    does not get updated in the upstream properties.
  prefs: []
  type: TYPE_NORMAL
- en: Using mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mixins are a great way of reusing and sharing code in Ember. The following recipes
    go over some basic operations on how to use them in your code.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we'll create a common mixin object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an Ember mixin object that has a couple of properties and a function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This mixin can be added to any object. For the sake of simplicity, all this
    mixin does is display some text and set the `isEditing` property to `true` if
    the `edit` function is invoked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s see what it looks like when we add this object to an object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `extend` method present in `Ember.Object` allows for one or more optional
    arguments of the `Ember.Mixin` type. In this example, we added the common mixin
    to the new `Ember.Object` object. We then instantiated this Ember object using
    `create`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'All that''s left is to output the contents. Use `console.log` to display each
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is what the output will look like. As you can see, we can access any of
    the mixin properties or methods as if the mixin was included in the Ember object
    itself. This is a convenient way of reusing code in your applications.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s create another mixin:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s see how this looks if we add it to an Ember object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can have access to both the common and `secondMixin` in our object.
    We can use `console.log` to output `secondProperty`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Mixins with the Ember CLI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mixins work very well with the Ember CLI. To start, use the mixin generator
    to create one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that you''re in the application directory, and then type the following
    command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `generator` command creates an `app/mixins` folder and the `common.js` file.
    The `common.js` file is where we will put the code for the mixin.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ll use the mixin from the previous example and add it to this file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This mixin is exactly the same as the previous example; however, now it's in
    a module that we can import anywhere, including components or controllers.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For now, we'll import it to our `app.js` file in the `app` folders directory.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, we''ll need to add the `import` statement to the top of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This allows us to use the common mixin anywhere in the `app.js` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''ll add the following code to the bottom of the `app/app.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you can see, all the properties and methods in the common mixin are available
    to the object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If we were to add the common mixin to a component, it might look like following
    code. Add this code to the `common-example.js` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As always, we must first import the mixin to our component. The path is always
    relative to the directory you're in, therefore, we must use `../mixins/common`
    to find it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the component, I added a simple action called `pressed` that triggers the
    mixin `edit` method. If the action gets triggered, we would see the `Starting
    to edit message` in the console. Look for more examples of components in [Chapter
    6](part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb "Chapter 6. Ember
    Components"), *Ember Components*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Ember.Mixin` class allows the creation of mixins whose properties and methods
    can be added to other classes. They can't be instantiated but they can be added
    or *mixed in*.
  prefs: []
  type: TYPE_NORMAL
- en: A mixin in computer science is a class that lends or copies it's behavior to
    a borrowing class using composition instead of inheritance. It encourages code
    reuse and avoids ambiguity that multiple inheritance can cause.
  prefs: []
  type: TYPE_NORMAL
- en: Using enumerables with arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `Ember.Enumerable` methods are very important when dealing with arrays.
    In these recipes, we'll look at some common use cases.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To understand how to use enumerables, we must first take a look at the standard
    JavaScript array methods and their equivalents using observable enumerables:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Standard method | Observable equivalent |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `unshift` | `unshiftObject` |'
  prefs: []
  type: TYPE_TB
- en: '| `shift` | `shiftObject` |'
  prefs: []
  type: TYPE_TB
- en: '| `reverse` | `reverseObjects` |'
  prefs: []
  type: TYPE_TB
- en: '| `push` | `pushObject` |'
  prefs: []
  type: TYPE_TB
- en: '| `pop` | `popObject` |'
  prefs: []
  type: TYPE_TB
- en: We'll be using some of these methods in our examples, so keep in mind what the
    standard and observable equivalents are.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Ember.Enumerable` class has several methods that we can use in our Ember
    applications. Here is the list of the more common methods and what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Enumerable method | Definition |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `forEach` | This iterates through the enumerable, calling the passed function
    on each item |'
  prefs: []
  type: TYPE_TB
- en: '| `firstObject` | This returns the first object in a collection |'
  prefs: []
  type: TYPE_TB
- en: '| `lastObject` | This returns the last object in a collection |'
  prefs: []
  type: TYPE_TB
- en: '| `map()` | This maps all the items in the enumeration to another value, similar
    to map in JavaScript 1.6 |'
  prefs: []
  type: TYPE_TB
- en: '| `mapBy()` | Similar to map, this returns the value of the named property
    on all items on the enumeration |'
  prefs: []
  type: TYPE_TB
- en: '| `filter` | This returns an array with all of the items in the enumeration
    that the passed function returns true |'
  prefs: []
  type: TYPE_TB
- en: '| `find` | This returns the first item in the array that the method returns
    true |'
  prefs: []
  type: TYPE_TB
- en: '| `findby` | This returns the first item with a property that matches the passed
    value |'
  prefs: []
  type: TYPE_TB
- en: '| `every` | This returns true only if the passed function returns true for
    every item in the enumeration |'
  prefs: []
  type: TYPE_TB
- en: '| `any` | This returns true only if the passed function returns true for any
    item in the enumeration |'
  prefs: []
  type: TYPE_TB
- en: Many of these methods are similar to their JavaScript counterparts. If you know
    how to use the JavaScript method, you should be able to use the Ember equivalent
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Ember.Enumerables` adds all the nice features of Ember objects to enumerables.
    We''ll take a look at several examples on how to do this. The contents for all
    these recipes are in the `chapter2/example6` folder in the `app.js` file.'
  prefs: []
  type: TYPE_NORMAL
- en: Using forEach with an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very common use case for an enumerable is iterating over an array with `forEach`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array of students:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `forEach` enumerable to iterate over the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The console output will show each student''s name in the array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Template literals**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Ember is compatible with the latest in ECMAScript 2015\. One neat new feature
    is called template literals or template strings. Template literals are string
    literals that can stretch across multiple lines and include interpolated expressions.
    You can do string interpolation by surrounding variables in your strings, like
    this `${}`. Each variable will be displayed in the string as shown in the preceding
    `forEach` example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using map with an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `map` method takes an array, maps each item, and returns a new modified
    array. Let's say that we want to make the student names all in uppercase. We can
    do this using `map`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a list of `students`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first letter is capitalized; however, we want all the letters in uppercase.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use `map` to convert every item to uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Every item in the array has been converted to uppercase. The new `upperCaseStudent`
    array has all the new values.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Use the `forEach` enumerable to iterate through every item in the array and
    display its contents:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output displays each name in the new `upperCaseStudent` array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using mapBy with an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `mapBy` enumerable can be used if your array is comprised of objects. From
    each object, we can extract its named properties and return a new array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a teacher and student object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each object has one property called `name`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Next we'll instantiate each object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Each object is put into a `people` array:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We can use `mapBy` to create a new array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This new array returned has the values from the `name` property from both objects.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Finding the first and last objects in an array
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If necessary, we have an easy way to grab the first and last objects in an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll begin by creating a student array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This array has six different students.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s grab the last object in the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will display `Susan`, the last object in the array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s retrieve the first object in the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will display `Erik`, the first item in the array.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can push objects on the array as well:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The student `Jeff` has now been added to the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Fun with filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A very common practice is to take an array and return a filtered list of items.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, create an array of numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Take the `array` and `filter` it, returning only those numbers over `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `console.log` to display the new array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This new array has numbers only greater then 10 in it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using filterBy with a collection of objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With `filterBy`, you can take a collection of objects and filter it by some
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `student` object that has a `name` and `grade`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the students to a new array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `filterBy` to show the students who are seniors:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This returns an array of students who are seniors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can double-check the output using `forEach`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Using find to get the first match
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `find` enumerable works very similarly to `filter` except that it stops
    after finding the first match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an array of numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `array.find` to retrieve the first number in the list that is over `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We''ll then check the output of the new array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The answer is `25` as it's the first number in the list that is over 10.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using findBy with collections
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `findBy` enumerable works very similarly to `filterBy` except that it stops
    after finding the first match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new `student` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, create an array of students:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use `findBy` to match only the properties that have `grade` of `senior`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will return the first student who is a senior:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`Jen Smith` is the first student who matches this criteria so it is returned
    to the `newStudent` array.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Learning with the every enumerable
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `every` enumerable will return `true` only if every item matches a certain
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Begin by creating an array of numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `every` enumerable to check whether every item in the array is greater
    than `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This returns `true` because every item in the array is over `10`
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using any to find at least one match
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `any` enumerable will return `true` if at least one item matches a certain
    condition.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, create a list of numbers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Use the `any` enumerable to check whether any of these numbers in this array
    are over `10`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will return `true` because at least one number is above `10`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Ember.Enumerable` mixin is Ember's implementation of the array API defined
    up to JavaScript 1.8\. It's applied automatically on page load so any method is
    available. In order for Ember to be able to observe changes in an enumerable,
    you must use `Ember.Enumerable`.
  prefs: []
  type: TYPE_NORMAL
- en: The enumerable API follows ECMAScript specifications as much as possible so
    it minimizes incompatibilities with the other libraries. It uses native browser
    implementations in arrays where available.
  prefs: []
  type: TYPE_NORMAL
