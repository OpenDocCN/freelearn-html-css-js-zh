- en: Introducing Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vuex is a library that we can use with Vue.js to manage different states in
    an application. If you are building a small application that does not require
    much data exchange between its components, you are better off not using this library.
    However, as your application grows, complexities crawl along with it. There will
    be several components in the application, and, most obviously, you will need to
    exchange data from one component to another or share the same data across multiple
    components. That is when Vuex comes to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: Vue.js also provides an `emit` method to pass data between different components,
    which we used in previous chapters. As your application grows, you might also
    want to update data across several components when your data gets updated.
  prefs: []
  type: TYPE_NORMAL
- en: So, Vuex provides a centralized place to store all the pieces of data in our
    application. Whenever data changes, this new set of data will be stored in this
    centralized place. Also, all of the components that want to use that data will
    be fetched from the store. This means that we have a single source to store all
    the data, and all the components that we build will be able to access that data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first get acquainted with some of the terminology that come with Vuex:'
  prefs: []
  type: TYPE_NORMAL
- en: '**State**: This is an object that contains the data. Vuex uses a single state
    tree, which means that it is a single object that contains all the pieces of data
    for the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Getters**: It is used to fetch data from the state tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**mutations**: They are the methods that change the data in the state tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Actions**: They are the functions that perform mutations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will discuss each of these in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Traditional multi-web page application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In traditional multi web page application, when we build a web application and
    open a website by navigating to the browser, it requests the web server to fetch
    that page and serve it to the browser. When we click on a button on the same website,
    it again requests the web server to fetch another page and again serve it. This
    process happens for every single interaction we do on the website. So, basically,
    the website gets reloaded on every single interaction, which consumes a lot of
    time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample diagram that explains how a multi-page application
    works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/358fe12c-59b3-4c01-840a-49d48a1c85b9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: When a request is sent from the browser, the request is sent to the server.
    The server then returns the HTML content and serves a whole new whole page.
  prefs: []
  type: TYPE_NORMAL
- en: '**Multi Page Applications **(**MPA**) can provide several benefits as well.
    It''s not a matter of whether to choose MPA or a **Single Page Application** (**SPA**),
    but it all depends on the content of your application. If your application contains
    a lot of user interaction, you should go for an SPA; however, if the only purpose
    of your application is to serve the users with the content, you can go with an
    MPA. We will explore more about SPAs and MPAs later in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to SPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Contrary to the traditional MPAs, SPAs are designed specifically for web-based applications.
    The SPA fetches all the data when you first load the website in the browser. Once
    all the data is fetched, you don't need to fetch any more data. When any other
    interactions are done, that data is fetched over the internet, without having
    to send a request to the server and without reloading the page. This means that
    SPAs are much faster than the traditional MPAs. However, since SPAs fetch everything
    at once on the first load, the first page load time could be slow. Some applications
    that have SPA integration are Gmail, Facebook, GitHub, Trello, and so on. SPAs
    are all about making the user experience better by putting the content on one
    single page and not making the users wait for the information they want.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sample diagram of how SPAs work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ff9dc3a1-41a1-45fd-a694-0fd9084e8584.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The website has all the content that it needs on the first page-load. When a
    user clicks on something, it just fetches the information for that particular
    area and refreshes only that part of the web page.
  prefs: []
  type: TYPE_NORMAL
- en: SPA versus MPA
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: SPA and MPA serve different purposes. You may want to use one over the other,
    depending on your needs. Before you start your application, ensure that you are
    clear about the kind of application that you want to build.
  prefs: []
  type: TYPE_NORMAL
- en: Pros of using MPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MPAs are the best approach if you want to make your application SEO friendly.
    Google can crawl different pages of your application by searching the keywords
    that you assign on each page, which is not possible in an SPA since it has only
    a single page.
  prefs: []
  type: TYPE_NORMAL
- en: Cons of using MPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a few cons of using MPAs:'
  prefs: []
  type: TYPE_NORMAL
- en: The development work for an MPA is much greater than for an SPA because the
    frontend and backend are tightly coupled.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MPAs have tightly coupled frontend and backend, which makes it harder to separate
    the work between frontend and backend developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pros of using SPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'SPAs provides a lot of benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced server response tim**e: SPAs fetch all the data needed on the first
    load of the website. With such an application, the server does not need to reload
    the resources on the website. If new data needs to be fetched, it only fetches
    the updated piece of information from the server, unlike multi-page apps, decreasing
    the server response time significantly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better user interaction**: The decrease in server response time ultimately
    improves the user experience. With every interaction, the user gets a more quickly
    rendered page, which means *happy customers*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility to change the UI**: SPAs do not have a coupled frontend and backend.
    This means that we can change the frontend and completely rewrite it without having
    to worry about breaking anything on the server side.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Data caching**: SPAs cache the data in the local storage. It only makes a
    single request the first time and saves the data. This makes the application available
    even when the internet is cut off.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cons of using  SPAs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are few downsides of using SPAs as well:'
  prefs: []
  type: TYPE_NORMAL
- en: SPAs are not SEO friendly. Since everything is done on a single page, the crawlability
    is very low.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You cannot share a particular piece of information with others since there is
    the only one link to the page.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security concerns are much greater with SPAs than in MPAs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Vuex is a state management library that is specifically designed to work with
    applications built with Vue.js. It is centralized state management for Vuex.
  prefs: []
  type: TYPE_NORMAL
- en: Core concepts of Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We got a glimpse of these core concepts in the introduction. Now, let''s dive
    into a little bit more detail on each of these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ed51d06e-04d0-4f06-beee-3a3f7d86ae7f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding diagram is a simple diagram that explains how Vuex works. Initially,
    everything is stored in a state, which is the single source of truth. Every view
    component fetches data from this state. Whenever something needs to be changed,
    actions perform mutations on the data and store it back in the state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4523972-cb5b-4dd8-8639-4bc547976d96.png)'
  prefs: []
  type: TYPE_IMG
- en: When we open our application in the browser, all the Vue components will be
    loaded. When we click on a button to fetch certain information from a component,
    that component dispatches an action that performs mutations on the data. When
    the mutation is successfully done, the state object is updated and new values
    are used. Then, we can use the new state for our components and display it in
    the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple Vuex application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will start a fresh new application to learn the basics of Vuex. Let's get
    started.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a new application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet will ask you few questions about the application
    setup. You can choose what you want to keep. I will go with the following configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/433b4667-cdfc-434e-ae05-d12d2a43efec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the installation, navigate to the project directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The next thing to do is to run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'After that, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command will spin up your server and open a port in `localhost:8080`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to install `vuex`. To do that, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting up Vuex
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's create a `store` folder to manage the `vuex` in our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a store file
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the `src` directory, create a `store` folder and `store.js` file. Then,
    add the following to the `store.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, the line `Vue.use(Vuex)` imports the Vuex library.
    Without this, we will not be able to use any of the `vuex` functionalities. Now,
    let's build a store object.
  prefs: []
  type: TYPE_NORMAL
- en: State
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the same `store.js` file, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we set the default state for a variable called `count`
    as `0` and exported a Vuex state through the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we will need to modify `src/main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code imports the store file that we just created, and we can access
    this variable in our vue components.
  prefs: []
  type: TYPE_NORMAL
- en: Let's move on to creating a component that will fetch this store data. A default
    component is created when we create a new application with Vue. If we look into
    the `src/components` directory, we will find a file called `HelloWorld.vue`. Let's
    use the same component, `HelloWorld.vue`, or you can create a new one. Let's modify
    this file to access the `count`, which we defined in the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `src/components/HelloWorld.vue`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is the final folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1eef5543-52e1-4b33-9e48-a7efbc92001a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding screenshot should print the default value of count in the `HelloWorld.vue`
    component. If you navigate to `http://localhost:8080/#/`, you should see the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/964f5d82-853f-466c-a069-799ed8e9f367.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we accessed the count variable in the store directly
    using the `$` operator, which is not the preferred way of doing it. We have learned
    the fundamentals of using the state. Now, the proper way to access the variables
    is by using getters.
  prefs: []
  type: TYPE_NORMAL
- en: Getters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A `getter` is a function that is used to access the objects from the store.
    Let's create a `getter` method to fetch the count that we have in our store.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `store.js`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we added a method called `fetchCount`, which returns
    the current value of `count`. Now, to access this in our vue component—`HelloWorld.vue`,
    we will need to update the content with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We have to import a module called `mapGetters` from Vuex, which is used to
    import the `fetchCount` method that we create as a `getter` method in `store.js`.
    Now, check the number by reloading the browser; this should also print the count
    as `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/092909d8-925c-4beb-a34f-525086a77929.png)'
  prefs: []
  type: TYPE_IMG
- en: mutations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to `mutations`. `mutations` are methods that perform modifications
    to the state of the store. We will define the `mutations` just as we defined `getters`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `store.js`, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We added two different `mutation` functions in the preceding code. The `increment`
    method increments the count by 1, whereas the `decrement` method decreases the
    count by 1\. This is where we introduce actions.
  prefs: []
  type: TYPE_NORMAL
- en: Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Actions are the methods that dispatch mutation functions. Actions perform `mutations`.
    Since `actions` are asynchronous and `mutations` are synchronous, it''s always
    a good practice to use `actions` to mutate the state. Now, just like `getters`
    and `mutations`, let''s define the `actions` as well. In the same file, that is, `store.js`,
    add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we added two different functions for incrementing and
    decrementing. Since these methods commit the `mutations`, we will need to pass
    a parameter to make the `commit` method available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we need to use the previously defined `actions` and make them available
    in our vue component, in `HelloWorld.vue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To invoke these actions, let''s create two buttons. In `HelloWorld.vue`, let''s
    add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding lines of code add two buttons, which, when clicked, call a method
    to increment or decrement the count. Let''s also import Bootstrap for CSS. In
    `index.html`, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s it. Now, if you reload the browser, you should be able to see the following
    result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/02e6929a-410b-4b2e-a264-0f595157d624.png)'
  prefs: []
  type: TYPE_IMG
- en: The count should increase or decrease when you click on the relevant button.
    This gives you a basic idea about how to implement Vuex in an application.
  prefs: []
  type: TYPE_NORMAL
- en: Installing and using Vuex in a movie application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered the basics of Vuex—how it works in an application and the core concepts.
    We covered how to create a store and mutations and how to use actions to dispatch
    them, and also discussed how to use getters to fetch information from the store.
  prefs: []
  type: TYPE_NORMAL
- en: 'We built an application in the previous chapters for a movie listing page.
    We will use the same application for Vuex. We will be doing the following actions:'
  prefs: []
  type: TYPE_NORMAL
- en: We will define a store where all the movies will be stored
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When a new movie is added, we will automatically display that to the movie listing
    page without reloading the page
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s open the application and run the frontend and backend servers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, run the `mongo` server with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The movie listing page should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2e905eea-dc88-42f3-8715-2cdf705c9317.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s start by installing `vuex`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Check your `package.json` file; `vuex` should be listed on the dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's create a file, where we will be able to put all our `getters`, `mutations`,
    and `actions` that we will define as we go forward.
  prefs: []
  type: TYPE_NORMAL
- en: Defining a store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a folder named `store` inside the `src` directory, and a new
    file called `store.js` inside the `store` directory, and add the following lines
    of code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Just like we did in the preceding sample application, let's add a `state` variable
    to store the current state of the application for movies listing page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `store.js`, add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This means that the initial state of the application will have an empty movie
    listing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we need to import this `store` into `main.js` so that it is accessible
    throughout the components. Add the following lines of code in `src/main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need to fetch the movies when we open the location `http://localhost:8081/`
    in the browser. Here is what we will do:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify `Home.vue` to call the action that fetches the movies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an action that will fetch all the movies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a mutation to store the fetched movies in the movies store
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a getter method to fetch the movies from the state to display on the
    home page
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Modifying Home.vue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start this section by modifying our `Home.vue` component. Update the
    `script` part of the file with the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, in the `mounted()` method, we have dispatched an action
    called `fetchMovies`, which we will define in our action.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the movies are fetched successfully, we will use the `computed` method,
    which will be mapped to the `movies` variable, which we will use in our template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Creating an action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s move on to add an action to the `store.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we have moved the `axios` part from the component. When
    we get a successful response, we will commit a mutation called `MOVIES`, which
    then mutates the value of the `movies` in the state.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a mutation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s go on and add a mutation as well. In `store.js`, replace the contents
    with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The preceding `mutations` mutate the state of the movies of the application.
  prefs: []
  type: TYPE_NORMAL
- en: We now have the `action` and the `mutation`. Now, the last part is to add a
    `getter` method, which gets the value of the `movies` from the state.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a getter
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s add the `getter` method in `store.js` that we created to manage the
    state of our application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: That's it. When we navigate to `http://localhost:8081/movies/add`, we should
    have a functional Vuex implementation that fetches the movies to the home page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to implement the store when we add a movie to the application.
    We will follow the same process as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: Modify `AddMovie.vue` to call the action to create the movie
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an `action` that calls the POST API to create movies
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `mutation` to `store` the added new movie to the `movies` store
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the `script` contents in `AddMovie.vue` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, add the `action` and `mutations` to the `store.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, run the following command to build our static files for Vue components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, when we log in and add a movie with the admin user, the movie should be
    added to the database and also be listed on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: Using Vuex in a small application such as this is overkill. The best use of
    Vuex is in large-scale applications where data needs to be transferred and shared
    among several components. This gives you an idea of how Vuex works and how to
    implement it.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we discussed what Vuex is—the core concepts of Vuex state,
    getters, mutations, actions, and how to use them in an application. We discussed
    how to structure our application to implement Vuex and the benefits it adds when
    the application grows larger.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will cover how to write unit tests and integration for
    Vue.js and Node.js application.
  prefs: []
  type: TYPE_NORMAL
