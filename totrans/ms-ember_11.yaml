- en: Chapter 11. Building Real-time Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Up until now, the applications we created did not require any real-time capabilities.
    However, today''s modern applications strive to offer the best user experience
    through reduced page reloads, efficient data transfers, and improved performances.
    In addition, these applications might also need to send data and receive updates
    to and from the server as quickly as possible. There are a number of web technologies
    that can be used to accomplish this need:'
  prefs: []
  type: TYPE_NORMAL
- en: Adobe Flash sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JSONP polling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHR long polling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: XHR multipart streaming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: ActiveX HTMLFile
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web sockets
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Server-sent events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebRTC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to use the **Socket.io** ([http://socket.io](http://socket.io))
    library, which enables bidirectional communication between web clients and servers.
    It does this by providing a similar API between the mechanisms just mentioned,
    excepting the last two. Additionally, it selects the best mechanism to use depending
    on a number of factors, such as browser support, among others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before diving into using Socket.io, it''s worth noting that server-sent events
    are a good option if the client app is meant to constantly receive updates from
    the backend while performing little or no pushes. Facebook newsfeeds and Twitter
    timelines are good examples of use cases that can benefit from this technology.
    The following resources can aid in the development of such an application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Sse client library** available at [https://github.com/segmentio/sse](https://github.com/segmentio/sse)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Sse Node.js library** available at [https://github.com/segmentio/sse-stream](https://github.com/segmentio/sse-stream)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebRTC** is a good choice for applications that require peer-to-peer communication,
    such as audio and video streaming.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Socket.io
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To aid in mastering Socket.io, we will explore the bundled chapter sample that
    is a simple IRC-style chat application and the backend of which is built in Node.js,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up Socket.io](img/00020.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'The only prerequisite is Node.js, which can be downloaded from [http://nodejs.org/download](http://nodejs.org/download).
    The following tests can then be performed to verify the installation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, boot the application with the following commands in order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The backend uses the **Express.io** ([http://express.io](http://express.io))
    library, which integrates the popular Express.js ([http://expressjs.com](http://expressjs.com))
    web application framework with Socket.io to reduce the setup boilerplate code
    to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Express.io ships with the Socket.io client library and serves it at `/socket.io/socket.io.js`
    when started. We therefore only need to load it together with the rest of the
    application files as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The client library can, of course, alternatively be downloaded from [http://socket.io/download/](http://socket.io/download/)
    and served likewise. The client library is usually initialized by invoking the
    `connect` method on the exposed `io` global variable, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Note that there are other Socket.io libraries implemented in other languages
    that can be used instead of the official Node.js library.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting the user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When the application is loaded at `http://localhost:3000`, the user is required
    to specify the handle to use before joining the chat by submitting the desired
    nick in the `/join <desired nick>` format. The `App.MessageField` view delegates
    this event to the `index` controller `chat` action as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is something that we learned in [Chapter 6](part0069_split_000.html#page
    "Chapter 6. Views and Event Management"), *Views and Event Management*, under
    the *Emitting actions from views* section. As we shall see later, the rest of
    the application''s visibility is obscured until the user connects successfully
    for the first time. In the `chat` action of the corresponding controller, `App.IndexController`,
    we first make sure that the submitted message is not empty:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We then check to see if the user intends to join the chat:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, if the user is already connected, we notify them through a tooltip.
    This tooltip is displayed via the `tip` action, which takes the message to be
    displayed as its only argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If a nick is matched, we pass it the `join` action, which first subscribes
    to three server updates. The first update is triggered when a new user joins the
    chat, and it adds this particular user to the controller''s `nicks` array to be
    displayed on the user, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The next handler, on the other hand, removes a disconnected user from the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We also subscribe to incoming messages and store them in the controller''s
    `messages` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The Socket.io `.on` instance method is used to perform pull operations by subscribing
    to events emitted from the backend, as shown in the preceding three handlers.
    The `.emit` method, on the other hand, is used to push data to the backend. In
    this case, we notify the server that a new user wishes to join the chat as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding call sends a `ready` event to the backend alongside the nick.
    In the same way, the backend also sets up event handlers, the first of which listens
    to the `ready` event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The listener first checks to see if the nick has been taken by an existing
    user and whether an existing user has taken the nick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'If it has indeed been taken, we notify the user of this failure through another
    update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'All that the client app needs to do is display the notice via the tooltip:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if the nick is not taken, we first store the nick in `session` for
    later reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In a group chat application, we expect users already logged in to the chat
    to be notified when others join, as demonstrated by loading the app on different
    tabs. Therefore, when the user connects, we first add an appropriate message to
    the message store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We then *broadcast* this event to the other logged-in users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Socket.io provides a means of sending events to all active connections, except
    the current connection, via the `.broadcast` method. The preceding broadcast events
    result in the user being added to the nick listing to the right-hand side of the
    client application, along with the accompanying join notice:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'We finally notify the connecting user of the successful connection using the
    `respond` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition, we send them a list of the currently logged-in users, as well
    as the five most recent messages. Once connected, we clear the message field and
    populate the `users` and `nicks` collections as:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'When messages stream in, we make the bottom of the message list visible to
    the viewport by use of an observer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'What this does is trigger the controller''s `scrollToBottom` action once in
    a window of 200 milliseconds, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the user connects, the rest of the application visibility is enabled,
    thanks to bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the message container element acquires the `show` property, thereby
    resetting the opacity to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Subsequent messages are relayed to the server and broadcasted to the other
    users via the chat action discussed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, on the backend, we subscribe to this event and relay the message to
    the other users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'You will notice that we define a `message-date` component that displays a message''s
    date formatted with the aid of the Moment.js library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In line with a better real-time experience, the component updates the formatted
    date every 15 seconds to illustrate aging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when the user disconnects, we remove their handle from the `nicks`
    collection and notify the rest of the users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You will notice that we referenced the saved user's handle from `session`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a few improvements that can be made to the application, such as multichannel,
    emoticon, and user-avatar support, among others.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This was a short introduction to building Ember.js applications that integrate
    with aiding real-time web technologies. It demonstrated how easy it is to use
    the third-party library without spending too much time making trivial choices.
    We learned how to initialize the Socket.io library and subscribe and emit updates
    to and from the server. In the next chapter, we will learn how to componentize
    our applications into reusable components.
  prefs: []
  type: TYPE_NORMAL
