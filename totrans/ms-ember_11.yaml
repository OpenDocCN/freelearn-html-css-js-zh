- en: Chapter 11. Building Real-time Applications
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。构建实时应用程序
- en: 'Up until now, the applications we created did not require any real-time capabilities.
    However, today''s modern applications strive to offer the best user experience
    through reduced page reloads, efficient data transfers, and improved performances.
    In addition, these applications might also need to send data and receive updates
    to and from the server as quickly as possible. There are a number of web technologies
    that can be used to accomplish this need:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们创建的应用程序并不需要任何实时功能。然而，现代应用程序力求通过减少页面刷新、高效的数据传输和改进的性能来提供最佳的用户体验。此外，这些应用程序可能还需要尽可能快地与服务器发送和接收数据。有几种网络技术可以用来满足这一需求：
- en: Adobe Flash sockets
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Adobe Flash sockets
- en: JSONP polling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JSONP轮询
- en: XHR long polling
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHR长轮询
- en: XHR multipart streaming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: XHR多部分流
- en: ActiveX HTMLFile
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ActiveX HTMLFile
- en: Web sockets
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Web sockets
- en: Server-sent events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器发送事件
- en: WebRTC
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebRTC
- en: In this chapter, we will learn how to use the **Socket.io** ([http://socket.io](http://socket.io))
    library, which enables bidirectional communication between web clients and servers.
    It does this by providing a similar API between the mechanisms just mentioned,
    excepting the last two. Additionally, it selects the best mechanism to use depending
    on a number of factors, such as browser support, among others.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习如何使用**Socket.io**([http://socket.io](http://socket.io))库，该库使Web客户端和服务器之间的双向通信成为可能。它通过提供与上述机制类似的API来实现这一点，除了最后两个。此外，它根据多个因素（如浏览器支持等）选择最佳机制来使用。
- en: 'Before diving into using Socket.io, it''s worth noting that server-sent events
    are a good option if the client app is meant to constantly receive updates from
    the backend while performing little or no pushes. Facebook newsfeeds and Twitter
    timelines are good examples of use cases that can benefit from this technology.
    The following resources can aid in the development of such an application:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入使用Socket.io之前，值得注意的是，如果客户端应用程序旨在从后端持续接收更新而几乎不进行推送，那么服务器发送事件是一个不错的选择。Facebook新闻源和Twitter时间线是这种技术可以带来好处的用例的好例子。以下资源可以帮助开发此类应用程序：
- en: '**Sse client library** available at [https://github.com/segmentio/sse](https://github.com/segmentio/sse)'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sse客户端库**可在[https://github.com/segmentio/sse](https://github.com/segmentio/sse)找到'
- en: '**Sse Node.js library** available at [https://github.com/segmentio/sse-stream](https://github.com/segmentio/sse-stream)'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sse Node.js库**可在[https://github.com/segmentio/sse-stream](https://github.com/segmentio/sse-stream)找到'
- en: '**WebRTC** is a good choice for applications that require peer-to-peer communication,
    such as audio and video streaming.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebRTC**是适用于需要点对点通信的应用程序的良好选择，例如音频和视频流。'
- en: Setting up Socket.io
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 Socket.io
- en: 'To aid in mastering Socket.io, we will explore the bundled chapter sample that
    is a simple IRC-style chat application and the backend of which is built in Node.js,
    as shown in the following screenshot:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助掌握 Socket.io，我们将探索捆绑的章节示例，这是一个简单的IRC风格的聊天应用程序，其后端是用Node.js构建的，如下截图所示：
- en: '![Setting up Socket.io](img/00020.jpeg)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Socket.io](img/00020.jpeg)'
- en: 'The only prerequisite is Node.js, which can be downloaded from [http://nodejs.org/download](http://nodejs.org/download).
    The following tests can then be performed to verify the installation:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的前提是Node.js，可以从[http://nodejs.org/download](http://nodejs.org/download)下载。然后可以执行以下测试以验证安装：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, boot the application with the following commands in order:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令启动应用程序：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The backend uses the **Express.io** ([http://express.io](http://express.io))
    library, which integrates the popular Express.js ([http://expressjs.com](http://expressjs.com))
    web application framework with Socket.io to reduce the setup boilerplate code
    to the following:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 后端使用**Express.io**([http://express.io](http://express.io))库，该库将流行的Express.js([http://expressjs.com](http://expressjs.com))
    Web应用程序框架与Socket.io集成，以减少设置样板代码到以下内容：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Express.io ships with the Socket.io client library and serves it at `/socket.io/socket.io.js`
    when started. We therefore only need to load it together with the rest of the
    application files as:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Express.io随附Socket.io客户端库，并在启动时在`/socket.io/socket.io.js`上提供服务。因此，我们只需要将其与其他应用程序文件一起加载，如下所示：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The client library can, of course, alternatively be downloaded from [http://socket.io/download/](http://socket.io/download/)
    and served likewise. The client library is usually initialized by invoking the
    `connect` method on the exposed `io` global variable, as shown in the following
    code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端库当然也可以从[http://socket.io/download/](http://socket.io/download/)下载并相应地提供。客户端库通常通过在公开的`io`全局变量上调用`connect`方法来初始化，如下面的代码所示：
- en: '[PRE4]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note that there are other Socket.io libraries implemented in other languages
    that can be used instead of the official Node.js library.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，还有其他用其他语言实现的Socket.io库可以用作官方Node.js库的替代品。
- en: Connecting the user
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接用户
- en: 'When the application is loaded at `http://localhost:3000`, the user is required
    to specify the handle to use before joining the chat by submitting the desired
    nick in the `/join <desired nick>` format. The `App.MessageField` view delegates
    this event to the `index` controller `chat` action as:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序在`http://localhost:3000`加载时，用户在通过`/join <desired nick>`格式提交期望的昵称之前，需要指定要使用的处理程序。`App.MessageField`视图将此事件委派给`index`控制器的`chat`操作，如下所示：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'This is something that we learned in [Chapter 6](part0069_split_000.html#page
    "Chapter 6. Views and Event Management"), *Views and Event Management*, under
    the *Emitting actions from views* section. As we shall see later, the rest of
    the application''s visibility is obscured until the user connects successfully
    for the first time. In the `chat` action of the corresponding controller, `App.IndexController`,
    we first make sure that the submitted message is not empty:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们从[第6章](part0069_split_000.html#page "第6章。视图和事件管理")中学习到的内容，即*视图和事件管理*部分下的*从视图中发出操作*。正如我们稍后将看到的，应用程序的其他可见性直到用户第一次成功连接才会被隐藏。在相应的控制器`chat`操作`App.IndexController`中，我们首先确保提交的消息不为空：
- en: '[PRE6]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We then check to see if the user intends to join the chat:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后检查用户是否意图加入聊天：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Of course, if the user is already connected, we notify them through a tooltip.
    This tooltip is displayed via the `tip` action, which takes the message to be
    displayed as its only argument:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果用户已经连接，我们将通过工具提示通知他们。这个工具提示是通过`tip`操作显示的，该操作将显示的消息作为其唯一参数：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'If a nick is matched, we pass it the `join` action, which first subscribes
    to three server updates. The first update is triggered when a new user joins the
    chat, and it adds this particular user to the controller''s `nicks` array to be
    displayed on the user, as shown in the following code:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 如果匹配到昵称，我们将其传递给`join`操作，该操作首先订阅三个服务器更新。第一个更新是在新用户加入聊天时触发的，并将此特定用户添加到控制器的`nicks`数组中，以便在用户界面上显示，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The next handler, on the other hand, removes a disconnected user from the collection:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个处理器，另一方面，从集合中移除断开连接的用户：
- en: '[PRE10]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We also subscribe to incoming messages and store them in the controller''s
    `messages` property:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还订阅传入的消息并将它们存储在控制器的`messages`属性中：
- en: '[PRE11]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The Socket.io `.on` instance method is used to perform pull operations by subscribing
    to events emitted from the backend, as shown in the preceding three handlers.
    The `.emit` method, on the other hand, is used to push data to the backend. In
    this case, we notify the server that a new user wishes to join the chat as:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io的`.on`实例方法用于通过订阅后端发出的事件来执行拉取操作，如前三个处理器所示。另一方面，`.emit`方法用于将数据推送到后端。在这种情况下，我们通知服务器有新用户希望加入聊天，如下所示：
- en: '[PRE12]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The preceding call sends a `ready` event to the backend alongside the nick.
    In the same way, the backend also sets up event handlers, the first of which listens
    to the `ready` event:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个调用将一个`ready`事件和昵称一起发送到后端。同样地，后端也设置了事件处理器，其中第一个处理器监听`ready`事件：
- en: '[PRE13]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The listener first checks to see if the nick has been taken by an existing
    user and whether an existing user has taken the nick:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 监听器首先检查昵称是否被现有用户占用，以及现有用户是否占用了该昵称：
- en: '[PRE14]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'If it has indeed been taken, we notify the user of this failure through another
    update:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果确实已被占用，我们将通过另一个更新通知用户此失败：
- en: '[PRE15]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'All that the client app needs to do is display the notice via the tooltip:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 客户端应用程序需要做的只是通过工具提示显示通知：
- en: '[PRE16]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'However, if the nick is not taken, we first store the nick in `session` for
    later reference:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果昵称未被占用，我们首先将昵称存储在`session`中以供以后参考：
- en: '[PRE17]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'In a group chat application, we expect users already logged in to the chat
    to be notified when others join, as demonstrated by loading the app on different
    tabs. Therefore, when the user connects, we first add an appropriate message to
    the message store:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在群聊应用程序中，我们期望已登录到聊天的用户在其他人加入时收到通知，正如在不同的标签页上加载应用程序所展示的那样。因此，当用户连接时，我们首先将适当的消息添加到消息存储中：
- en: '[PRE18]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We then *broadcast* this event to the other logged-in users:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们*广播*此事件给其他已登录用户：
- en: '[PRE19]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Socket.io provides a means of sending events to all active connections, except
    the current connection, via the `.broadcast` method. The preceding broadcast events
    result in the user being added to the nick listing to the right-hand side of the
    client application, along with the accompanying join notice:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Socket.io提供了通过`.broadcast`方法向所有活动连接发送事件（除了当前连接）的途径。前面的广播事件导致用户被添加到客户端应用程序右侧的昵称列表中，并伴随加入通知：
- en: '[PRE20]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We finally notify the connecting user of the successful connection using the
    `respond` method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最终使用`respond`方法通知连接用户连接成功：
- en: '[PRE21]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In addition, we send them a list of the currently logged-in users, as well
    as the five most recent messages. Once connected, we clear the message field and
    populate the `users` and `nicks` collections as:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还向他们发送当前登录用户的列表以及最近的五条消息。一旦连接，我们清除消息字段并填充`users`和`nicks`集合，如下所示：
- en: '[PRE22]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'When messages stream in, we make the bottom of the message list visible to
    the viewport by use of an observer:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 当消息流进来时，我们通过使用观察者使消息列表的底部可见于视口：
- en: '[PRE23]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'What this does is trigger the controller''s `scrollToBottom` action once in
    a window of 200 milliseconds, as shown:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这所做的就是触发控制器的`scrollToBottom`动作，在200毫秒的窗口中显示，如下所示：
- en: '[PRE24]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Once the user connects, the rest of the application visibility is enabled,
    thanks to bindings:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦用户连接，应用程序的其余部分可见性由绑定实现：
- en: '[PRE25]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this case, the message container element acquires the `show` property, thereby
    resetting the opacity to `1`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，消息容器元素获取了`show`属性，从而将不透明度重置为`1`：
- en: '[PRE26]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Subsequent messages are relayed to the server and broadcasted to the other
    users via the chat action discussed:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 后续消息通过聊天操作转发到服务器并广播给其他用户：
- en: '[PRE27]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Again, on the backend, we subscribe to this event and relay the message to
    the other users:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 再次，在后台，我们订阅此事件并将消息转发给其他用户：
- en: '[PRE28]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'You will notice that we define a `message-date` component that displays a message''s
    date formatted with the aid of the Moment.js library:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们定义了一个`message-date`组件，该组件使用Moment.js库格式化显示消息的日期：
- en: '[PRE29]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In line with a better real-time experience, the component updates the formatted
    date every 15 seconds to illustrate aging.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 为了提供更好的实时体验，该组件每15秒更新一次格式化日期以展示老化效果：
- en: 'Finally, when the user disconnects, we remove their handle from the `nicks`
    collection and notify the rest of the users:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当用户断开连接时，我们从`nicks`集合中删除他们的句柄并通知其他用户：
- en: '[PRE30]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: You will notice that we referenced the saved user's handle from `session`.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到我们从`session`中引用了保存的用户句柄：
- en: There are a few improvements that can be made to the application, such as multichannel,
    emoticon, and user-avatar support, among others.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 可以对应用程序进行一些改进，例如多频道、表情符号和用户头像支持等。
- en: Summary
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This was a short introduction to building Ember.js applications that integrate
    with aiding real-time web technologies. It demonstrated how easy it is to use
    the third-party library without spending too much time making trivial choices.
    We learned how to initialize the Socket.io library and subscribe and emit updates
    to and from the server. In the next chapter, we will learn how to componentize
    our applications into reusable components.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是对构建与实时网络技术集成的Ember.js应用程序的简要介绍。它展示了在不花费太多时间进行琐碎选择的情况下使用第三方库是多么容易。我们学习了如何初始化Socket.io库，并订阅和从服务器接收和发送更新。在下一章中，我们将学习如何将我们的应用程序组件化成可重用的组件。
