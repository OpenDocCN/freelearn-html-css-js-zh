- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Points and Sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we discussed the most important concepts, objects,
    and APIs that Three.js has to offer. In this chapter, we’ll look into the only
    concepts we’ve skipped until now: points and sprites. With `THREE.Points` (sometimes
    also called sprites), it is very easy to create many small rectangles that always
    face the camera and you can use to simulate rain, snow, smoke, and other interesting
    effects. For instance, you can render individual geometries as a set of points
    and control these points separately. In this chapter, we’ll explore the various
    point- and sprite-related features provided by Three.js.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To be more specific, we’ll look at the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating and styling particles using `THREE.SpriteMaterial` and `THREE.PointsMaterial`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `THREE.Points` to create a group of points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the canvas to style each point individually
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a texture to style the individual points
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Animating `THREE.Points` objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a `THREE.Points` object from existing geometries
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A quick note on some of the names used in this chapter
  prefs: []
  type: TYPE_NORMAL
- en: In newer versions of Three.js, the names of the objects related to points have
    changed several times. The `THREE.Points` object was previously named `THREE.PointCloud`
    and, in even older versions, it was called `THREE.ParticleSystem`. `THREE.Sprite`
    used to be called `THREE.Particle`, and the materials have also undergone several
    name changes. So, if you see online examples using these old names, remember that
    they are talking about the same concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by exploring what a particle is and how you can create one.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding points and sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we do with most new concepts, we’ll start with an example. In the sources
    for this chapter, you’ll find an example called `sprite.html`. Upon opening this
    example, you’ll see a minimalistic scene, containing a simple colored square:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1 – A single rendered sprite](img/Figure_7.01_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.1 – A single rendered sprite
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use your mouse to rotate around this scene. One thing you’ll notice
    is that no matter how you look at the square, it will always look the same. For
    instance, the following screenshot shows a view of the same scene from a different
    position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2 – A single rendered sprite will always be facing the camera](img/Figure_7.02_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.2 – A single rendered sprite will always be facing the camera
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, the sprite is still angled toward the camera, and you can’t
    look behind it. You can think of a sprite as a 2D plane that always faces the
    camera. If you create a sprite without any properties, they are rendered as small,
    white, two-dimensional squares. To create a sprite, we only need to provide a
    material:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You can configure how the sprite appears using `THREE.SpriteMaterial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color`: This is the color of the sprite. The default color is white.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizeAttenuation`: If this is set to `false`, the sprite will have the same
    size, regardless of how far from the camera it is positioned. If this is set to
    `true`, the size is based on the distance from the camera. The default value is
    `true`. Note that this only has an effect when using `THREE.PerspectiveCamera`.
    For `THREE.OrthographicCamera`, it always acts if set to `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`: With this property, you can apply a texture to the sprite. You can,
    for instance, make them look like snowflakes. This property isn’t shown in this
    example but is explained in the *Styling particles using textures* section in
    this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opacity`: This, together with the `transparent` property, sets the opacity
    of the sprite. The default value is `1` (fully opaque).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transparent`: If this is set to `true`, the sprite will be rendered with the
    opacity set by the `opacity` property. The default value is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blending`: This is the blend mode to use when rendering the sprite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that `THREE.SpriteMaterial` extends from the base `THREE.Material` object,
    so all the properties from that object also can be used on `THREE.SpriteMaterial`.
  prefs: []
  type: TYPE_NORMAL
- en: Before we move on to more interesting `THREE.Points` objects, let’s look a bit
    closer at the `THREE.Sprite` object. A `THREE.Sprite` object extends from the
    `THREE.Object3D` object just as `THREE.Mesh` does. This means that most of the
    properties and functions you know from `THREE.Mesh` can be used on `THREE.Sprite`.
    You can set its position using the `position` attribute, scale it using the `scale`
    property, and move it along its axes using the `translate` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `THREE.Sprite`, you can very easily create a set of objects and move them
    around the scene. This works well when you’re working with a small number of objects,
    but you’ll quickly run into performance issues when you want to work with a high
    number of `THREE.Sprite` objects. This is because each of the objects needs to
    be managed separately by Three.js. Three.js provides an alternative way of handling
    a large number of sprites using a `THREE.Points` object. With `THREE.Points`,
    Three.js doesn’t have to manage many individual `THREE.Sprite` objects, just the
    `THREE.Points` instance. This will allow Three.js to optimize how it draws the
    sprites and will result in better performance. The following screenshot shows
    several sprites rendered with the `THREE.Points` object:'
  prefs: []
  type: TYPE_NORMAL
- en: "![Figure 7.3 – Multiple points rendered from \uFEFFTHREE.BufferGeometry](img/Figure_7.03_B18726.jpg)"
  prefs: []
  type: TYPE_IMG
- en: Figure 7.3 – Multiple points rendered from THREE.BufferGeometry
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a `THREE.Points` object, we need to provide it with `THREE.BufferGeometry`.
    For the previous screenshot, we can create a `THREE.BufferGeometry` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see from this code fragment, first, we create an array of `THREE.Vector3`
    objects – one for each position where we want to create a sprite. Additionally,
    we set the `color` attribute on `THREE.BufferGeometry`, which is used to color
    each sprite. With `THREE.BufferGeometry` and an instance of `THREE.PointsMaterial`,
    we can create the `THREE.Points` object. The properties of `THREE.PointsMaterial`
    are pretty much the same as they are for `THREE.SpriteMaterial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`color`: This is the color of the point. The default color is `0xffffff`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sizeAttenuation` If this is set to `false`, all the points will have the same
    size, regardless of how far from the camera they are positioned. If this is set
    to `true`, the size is based on the distance from the camera. The default value
    is `true`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`map`: With this property, you can apply a texture to the point. You can, for
    instance, make them look like snowflakes. This property isn’t shown in this example
    but is explained in the *Styling particles using textures* section later in this
    chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`opacity`: This, together with the `transparent` property, sets the opacity
    of the sprites. The default value is `1` (no opacity).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`transparent`: If this is set to `true`, the sprites will be rendered with
    the opacity set by the `opacity` property. The default value is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`blending`: This is the blend mode to use when rendering the sprites.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`vertexColors`: Normally, all the points in `THREE.Points` have the same color.
    If this property is set to `true` and the color’s buffer attribute has been set
    on the geometry, each point will take the color from that array. The default value
    is `false`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As always, you can play around with these properties using the menu on the right
    in each of the examples.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we’ve only rendered the particles as small squares, which is the default
    behavior. There are, however, two additional ways you can style particles, which
    we’ll show in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Styling particles using textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we’ll look at the following two ways of changing what the
    sprite looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: Use an HTML canvas to draw an image and show that for each sprite
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Load an external image file to define what each sprite looks like
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start by drawing the image ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing an image on the canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the attributes for `THREE.PointsMaterial`, we mentioned the `map` property.
    With the `map` property, we can load a texture for the individual points. With
    Three.js, this texture can also be the output from an HTML5 canvas. Before we
    look at the code, let’s look at an example (`canvastexture.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4 – Creating sprites using a canvas-based texture](img/Figure_7.04_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.4 – Creating sprites using a canvas-based texture
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you can see that we’ve got a large set of Pac-Man-like ghosts on the
    screen. This uses the same approach that we saw in the *Understanding points and
    sprites* section earlier. This time, though, we aren’t showing a simple square
    but an image. To create this texture, we can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, first, we create an HTML canvas, on which we start drawing using
    the various `ctx.` functions. In the end, we convert this canvas into a `THREE.Texture`
    by calling `new THREE.Texture(canvas)`, which results in a `texture` we can use
    for our sprites. Remember to set `texture.needsUpdate` to `true`, which triggers
    Three.js to load the actual canvas data into the texture.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve got a texture, we can use it to create a `THREE.PointsMaterial`,
    just like we did in the *Understanding points and* *sprites* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we create `15000` points for this example and position them
    randomly in the specified range. What you might notice is that even if you turn
    on `transparency`, some sprites seem to overlap other sprites. This is because
    Three.js doesn’t sort sprites based on their z-index, so during rendering, it
    can’t correctly determine which one is before another one. There are two ways
    you can work around this: you can turn off `depthWrite`, or you can play around
    with the `alphaTest` property (starting with 0.5 is a good starting point).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you zoom out, you will see the 15,000 individual sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5 – Showing 15,000 sprites all at once](img/Figure_7.05_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.5 – Showing 15,000 sprites all at once
  prefs: []
  type: TYPE_NORMAL
- en: 'The amazing thing is that even with 1 million points, everything is still rendered
    very smoothly (of course, this depends on the hardware you’re running these examples
    on):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6 – Showing 1 million sprites all at once](img/Figure_7.06_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.6 – Showing 1 million sprites all at once
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll load some textures from external images and use those
    instead of drawing the texture ourselves.
  prefs: []
  type: TYPE_NORMAL
- en: Using textures to style particles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the example shown in the *Drawing an image on the canvas* section, we saw
    how to style `THREE.Points` using an HTML canvas. Since you can draw anything
    you want and even load external images, you can use this approach to add all kinds
    of styles to the particle system. There is, however, a more direct way to use
    an image to style your particles: you can use the `THREE.TextureLoader().load()`
    function to load an image as a `THREE.Texture` object. This `THREE.Texture` object
    can then be assigned to the `map` property of a material.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, we’ll show you two examples and explain how to create them.
    Both these examples use an image as a texture for your particles. In the first
    example, we’ll create a simulation of rain (`rain.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7 – Simulating rain falling down](img/Figure_7.07_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.7 – Simulating rain falling down
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is get a texture that will represent our raindrop.
    You can find a couple of examples in the `assets/textures/particles` folder. In
    the upcoming chapters, we will explain all the details and requirements for textures.
    For now, all you need to know is that the texture should be square and preferably
    a power of 2 (for example, 64 x 64, 128 x 128, or 256 x 256). For this example,
    we’ll use this texture:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8 – Raindrop texture](img/Figure_7.08_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.8 – Raindrop texture
  prefs: []
  type: TYPE_NORMAL
- en: 'This texture is a simple transparent image and shows the shape and color of
    a raindrop. Before we can use this texture in `THREE.PointsMaterial`, we need
    to load it. This can be done with the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With this line of code, Three.js will load the texture, and we can use it in
    our material. For this example, we defined the material as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this chapter, we’ve discussed all of these properties. The main thing to
    understand here is that the `map` property points to the texture we loaded with
    the `THREE.TextureLoader.load` function. Note that we used the `alphaTest` property
    again to make sure there are no weird artifacts when two sprites are moving in
    front of one another.
  prefs: []
  type: TYPE_NORMAL
- en: 'That takes care of styling the `THREE.Points` object. What you’ll also see
    when you open this example is that the points themselves are moving. Doing this
    is very simple. Each point is represented as a vertex that makes up the geometry
    that was used to create the `THREE.Points` object. Let’s look at how we can add
    the points for this `THREE.Points` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This isn’t that different than the previous examples we saw in this chapter.
    Here, we added another property to each particle called `velocity`. This property
    consists of two values: `velocityX` and `velocityY`. The first one defines how
    a particle (a raindrop) moves horizontally, while the second one defines how fast
    the raindrop falls. Now that each raindrop has its own speed, we can move the
    individual particles inside the render loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this piece of code, we get all the vertices (particles) from the geometry
    that was used to create `THREE.Points`. For each of the particles, we take `velocityX`
    and `velocityY` and use them to change the current position of the particle. Then,
    we make sure the particles stay within the range we’ve defined. If the `v.y` position
    drops below `0`, we add the raindrop back to the top, and if the `v.x` position
    reaches any of the edges, we make it bounce back by inverting the horizontal velocity.
    Finally, we need to tell Three.js we’ve changed some things in `bufferGeometry`
    so that it knows the correct values next time we’re rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at another example. This time, we won’t make rain; instead, we’ll
    make snow. Additionally, we won’t be using just a single texture – we’ll use three
    separate images (taken from the Three.js examples). Let’s start by looking at
    the result first (`snow.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9 – Snowy scene based on multiple textures](img/Figure_7.09_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.9 – Snowy scene based on multiple textures
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding screenshot, if you look closely, you can see that instead
    of using just a single image as a texture, we’ve used multiple images that have
    transparent backgrounds. You might be wondering how we did this. As you probably
    remember, we can only have a single material for a `THREE.Points` object. If we
    want to have multiple materials, we just have to make multiple `THREE.Points`
    instances, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this code fragment, you can see that we create three different `THREE.Points`
    instances, each with its own materials. To move the snowflakes around, we use
    the same approach as for the rain, so we don’t show the details of `createPoint`
    and the render loop here. One thing to note here is that it is possible to have
    a single `THREE.Points` instance, where the individual sprites have different
    textures. However, this would require a custom `fragment-shader` and your own
    instance of `THREE.ShaderMaterial`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we move on to the next section, note that using `THREE.Points` is a
    great way to add visual effects to an existing scene. For instance, the snow we
    saw in the previous example can quickly turn a standard scene into a snowy one:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10 – THREE.Points together with a cube map](img/Figure_7.10_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.10 – THREE.Points together with a cube map
  prefs: []
  type: TYPE_NORMAL
- en: Another way we can use sprites is to create a simple 2D **heads-up display**
    (**HUD**) on top of an existing scene. We’ll explore how to do this in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with sprite maps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'At the beginning of this chapter, we used a `THREE.Sprite` object to render
    single points. These sprites were positioned somewhere in the 3D world, and their
    size was based on the distance from the camera (this is also sometimes called
    `THREE.Sprite` object: we’ll show you how you can use `THREE.Sprite` to create
    a layer similar to a HUD for your 3D content using an extra `THREE.OrthographicCamera`
    instance and an additional `THREE.Scene`. We will also show you how to select
    the image for a `THREE.Sprite` object using a sprite map.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, we’re going to create a simple `THREE.Sprite` object that moves
    from left to right over the screen. In the background, we’ll render a 3D scene
    with a camera, which you can move to illustrate that the `THREE.Sprite` object
    moves independently of the camera. The following screenshot shows what we’ll be
    creating for the first example (`spritemap.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11 – Using two scenes and cameras to create a HUD](img/Figure_7.11_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.11 – Using two scenes and cameras to create a HUD
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open this example in your browser, you’ll see a Pac-Man ghost-like sprite
    moving across the screen that changes color and form whenever it hits the right
    edge. The first thing we’ll do is look at how we can create `THREE.OrthographicCamera`
    and a separate scene to render this `THREE.Sprite`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s look at the construction of the `THREE.Sprite` object and how the
    various shapes the sprite can take are loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `getTexture()` function, we load a texture. However, instead of loading
    five different images for each ghost, we load a single texture that contains all
    the sprites (also called a sprite map). The image we have as a texture looks like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12 – Input sprite sheet](img/Figure_7.12_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.12 – Input sprite sheet
  prefs: []
  type: TYPE_NORMAL
- en: With the `map.offset` and `map.repeat` properties, we can select the correct
    sprite to show on the screen. With the `map.offset` property, we determine the
    offset for the *x a*xis (`u`) and the *y a*xis (`v`) for the texture we loaded.
    The scale for these properties runs from `0` to `1`. In our example, if we want
    to select the third ghost, we must set the `u`-offset (*x a*xis) to `0.4`, and,
    because we’ve only got one row, we don’t need to change the `v`-offset (*y a*xis).
    If we only set this property, the texture shows the third, fourth, and fifth ghosts
    compressed together on screen. To only show one ghost, we need to zoom in. We
    can do this by setting the `map.repeat` property for the `u`-value to `1/5`. This
    means that we zoom in (only for the *x a*xis) to only show 20% of the texture,
    which is exactly one ghost.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to update the `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: First, we render the scene with the normal camera and the two meshes; after
    that, we render the scene containing our sprite. In the render loop, we also switch
    some properties to show the next sprite when it hits the right wall and change
    the sprite’s direction (code not shown).
  prefs: []
  type: TYPE_NORMAL
- en: So far in this chapter, we’ve mainly looked at creating sprites and point clouds
    from scratch. An interesting option, though, is to create `THREE.Points` from
    an existing geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Creating THREE.Points from existing geometry
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you may recall, `THREE.Points` renders each point based on the vertices from
    the supplied `THREE.BufferGeometry`. This means that if we provide a complex geometry
    (for example, a torus knot or a tube), we can create `THREE.Points` based on the
    vertices from that specific geometry. In this final section of this chapter, we’ll
    create a torus knot, like the one we saw in [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101),
    *Exploring Advanced Geometries*, and render it as a `THREE.Points` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'We explained the torus knot in [*Chapter 6*](B18726_06.xhtml#_idTextAnchor101),
    so we won’t go into much detail here. The following screenshot shows the example
    (`points-from-geom.html`):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13 – Torus knot rendered as points with a small animation](img/Figure_7.13_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 7.13 – Torus knot rendered as points with a small animation
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see from the preceding screenshot, every vertex used to generate
    the torus knot is used as a point. We can set this up like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we simply create a geometry and use that as input for the `THREE.Points`
    object. This way, we can render every geometry as a points object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you load external models using a Three.js model loader (for example, a glTF
    model), you’ll often end up with a hierarchy of objects – often grouped in `THREE.Group`
    or `THREE.Object3D` objects. In those cases, you’ll have to convert each geometry
    in each group into a `THREE.Points` object.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That’s a wrap for this chapter. We’ve explained what sprites and points are
    and how you can style these objects with the materials available. In this chapter,
    you saw how you can use `THREE.Sprite` directly, and that if you want to create
    a large number of particles, you should use a `THREE.Points` object. With `THREE.Points`,
    all the elements share the same material, and the only property you can change
    for an individual particle is its color by setting the `vertexColors` property
    of the material to `true` and providing a color value in the `colors` array of
    `THREE.BufferGeometry`, which is used to create `THREE.Points`. We also showed
    how you can easily animate particles by changing their position. This works the
    same for an individual `THREE.Sprite` instance and the vertices from the geometry
    used to create `THREE.Points` objects.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have created meshes based on geometries provided by Three.js. This
    works well for simple models, such as spheres and cubes, but isn’t the best approach
    when you want to create complex 3D models. For those models, you’d usually use
    a 3D modeling application, such as Blender or 3D Studio Max. In the next chapter,
    you’ll learn how you can load and display models created by such 3D modeling applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 3: Particle Clouds, Loading and Animating Models'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this third part, we’ll show you how you can load data from external models
    and how Three.js supports animations. We’ll also dive into the different types
    of textures that are supported by Three.js and how you can use them to enhance
    your models.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this part, there are the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18726_08.xhtml#_idTextAnchor132), *Creating and Loading Advanced
    Meshes and Geometries*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18726_09.xhtml#_idTextAnchor148), *Animations and Moving the
    Camera*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18726_10.xhtml#_idTextAnchor171), *Loading and Working with
    Textures*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
