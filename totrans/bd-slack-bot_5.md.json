["```js\nweather amsterdam tomorrow\n\n```", "```js\n['I', 'have', 'watered', 'the', 'plants']\n```", "```js\n['I', 'watered', 'plants']\n```", "```js\n['We', 'watering', 'plant']\n```", "```js\nnpm install @slack/client natural â€“save\n\n```", "```js\n'use strict';\n\n// import the natural library\nconst natural = require('natural');\n\nconst Bot = require('./Bot');\n\n// initalize the tokenizer\nconst tokenizer = new natural.WordTokenizer();\n\nconst bot = new Bot({\n  token: process.env.SLACK_TOKEN,\n  autoReconnect: true,\n  autoMark: true\n});\n\n// respond to any message that comes through\nbot.respondTo('', (message, channel, user) => {\n\n  let tokenizedMessage = tokenizer.tokenize(message.text);\n\n  bot.send(`Tokenized message: ${JSON.stringify(tokenizedMessage)}`, channel);\n});\n```", "```js\nconst tokenizer = new natural.TreebankWordTokenizer();\n```", "```js\n'use strict';\n\n// import the natural library\nconst natural = require('natural');\n\nconst Bot = require('./Bot');\n\n// initialize the stemmer\nconst stemmer = natural.PorterStemmer;\n\n// attach the stemmer to the prototype of String, enabling\n// us to use it as a native String function\nstemmer.attach();\n\nconst bot = new Bot({\n  token: process.env.SLACK_TOKEN,\n  autoReconnect: true,\n  autoMark: true\n});\n\n// respond to any message that comes through\nbot.respondTo('', (message, channel, user) => {\n  let stemmedMessage = stemmer.stem(message.text);\n\n  bot.send(`Stemmed message: ${JSON.stringify(stemmedMessage)}`, channel);\n});\n```", "```js\n'use strict';\n\n// import the natural library\nconst natural = require('natural');\n\nconst Bot = require('./Bot');\n\n// initialize the stemmer\nconst stemmer = natural.PorterStemmer;\n\n// attach the stemmer to the prototype of String, enabling\n// us to use it as a native String function\nstemmer.attach();\n\nconst bot = new Bot({\n  token: process.env.SLACK_TOKEN,\n  autoReconnect: true,\n  autoMark: true\n});\n\n// respond to any message that comes through\nbot.respondTo('', (message, channel, user) => {\n  let stemmedMessage = message.text.tokenizeAndStem();\n\n  bot.send(`Tokenize and stemmed message: ${JSON.stringify(stemmedMessage)}`, channel);\n});\n```", "```js\nlet distance = natural.LevenshteinDistance('weather', 'heater');\n\nconsole.log('Distance:', distance); // distance of 10\n\nlet distance2 = natural.LevenshteinDistance('weather', 'weather');\n\nconsole.log('Distance2:', distance2); // distance of 0\n```", "```js\nbot.respondTo('', (message, channel, user) => {\n  // grab the command from the message's text\n  let command = message.text.split(' ')[0];\n\n  let distance = natural.LevenshteinDistance('weather', command);\n\n  // our typo tolerance, a higher number means a larger \n  // string distance\n  let tolerance = 2;\n\n  // if the distance between the given command and 'weather' is\n  // only 2 string distance, then that's considered close enough\n  if (distance <= tolerance) {\n    bot.send(`Looks like you were trying to get the weather, ${user.name}!`, channel);\n  }}, true);\n```", "```js\nlet inflector = new natural.NounInflector();\n\nconsole.log(inflector.pluralize('virus'));\nconsole.log(inflector.singularize('octopi'));\n```", "```js\nlet inflector = natural.CountInflector;\n\nconsole.log(inflector.nth(25));\nconsole.log(inflector.nth(42));\nconsole.log(inflector.nth(111)); \n```", "```js\nlet inflector = natural.CountInflector;\n\nbot.respondTo('what day is it', (message, channel) => {\n  let date = new Date();\n\n  // use the ECMAScript Internationalization API to convert \n  // month numbers into names\n  let locale = 'en-us';\n  let month = date.toLocaleString(locale, { month: 'long' });\n  bot.send(`It is the ${inflector.nth(date.getDate())} of ${month}.`, channel);\n}, true);\n```", "```js\nSLACK_TOKEN=[YOUR_SLACK_TOKEN] WEATHER_API_KEY=[YOUR_WEATHER_KEY] nodemon index.js\n\n```", "```js\n'use strict';\n\n// import the natural library\nconst natural = require('natural');\n\nconst request = require('superagent');\n\nconst Bot = require('./Bot');\n\nconst weatherURL = `http://api.openweathermap.org/data/2.5/weather?&units=metric&appid=${process.env.WEATHER_API_KEY}&q=`;\n\n// initialize the stemmer\nconst stemmer = natural.PorterStemmer;\n\n// attach the stemmer to the prototype of String, enabling\n// us to use it as a native String function\nstemmer.attach();\n\nconst bot = new Bot({\n  token: process.env.SLACK_TOKEN,\n  autoReconnect: true,\n  autoMark: true\n});\n\nbot.respondTo('weather', (message, channel, user) => {\n  let args = getArgs(message.text);\n\n  let city = args.join(' ');\n\n  getWeather(city, (error, fullName, description, temperature) => {\n    if (error) {\n      bot.send(error.message, channel);\n      return;\n    }\n\n    bot.send(`The weather for ${fullName} is ${description} with a temperature of ${Math.round(temperature)} celsius.`, channel);\n  });\n}, true);\n\nfunction getWeather(location, callback) {\n  // make an AJAX GET call to the Open Weather Map API\n  request.get(weatherURL + location)\n    .end((err, res) => {\n      if (err) throw err;\n      let data = JSON.parse(res.text);\n\n      if (data.cod === '404') {     \n        return callback(new Error('Sorry, I can\\'t find that location!')); \n      }\n\n      console.log(data);\n\n      let weather = [];\n      data.weather.forEach((feature) => {\n        weather.push(feature.description);\n      });\n\n      let description = weather.join(' and ');\n\n      callback(data.name, description, data.main.temp);\n    });\n}\n\n// Take the message text and return the arguments\nfunction getArgs(msg) {\n  return msg.split(' ').slice(1);\n}\n```", "```js\n{ \n  coord: { lon: 4.89, lat: 52.37 },\n  weather:\n   [ { id: 310,\n       main: 'Drizzle',\n       description: 'light intensity drizzle rain',\n       icon: '09n' } ],\n  base: 'cmc stations',\n  main: { temp: 7, pressure: 1021, humidity: 93, temp_min: 7, temp_max: 7 },\n  wind: { speed: 5.1, deg: 340 },\n  clouds: { all: 75 },\n  dt: 1458500100,\n  sys:\n   { type: 1,\n     id: 5204,\n     message: 0.0103,\n     country: 'NL',\n     sunrise: 1458452421,\n     sunset: 1458496543 },\n  id: 2759794,\n  name: 'Amsterdam',\n  cod: 200 \n}\n```", "```js\nthis.slack.on(CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, () => {\n  let user = this.slack.dataStore.getUserById(this.slack.activeUserId)\n  let team = this.slack.dataStore.getTeamById(this.slack.activeTeamId);\n\n  this.name = user.name;\n this.id = user.id;\n\n  console.log(`Connected to ${team.name} as ${user.name}`);\n});\n```", "```js\nrespondTo(opts, callback, start) {\n  if (!this.id) {\n    // if this.id doesn't exist, wait for slack to connect\n    // before continuing\n    this.slack.on(CLIENT_EVENTS.RTM.RTM_CONNECTION_OPENED, () => {\n      createRegex(this.id, this.keywords);\n    });  \n  } else {\n    createRegex(this.id, this.keywords);\n  }\n\n  function createRegex(id, keywords) {\n    // if opts is an object, treat it as options\n    // otherwise treat it as the keywords string\n    if (opts === Object(opts)) {\n      opts = {\n        mention: opts.mention || false,\n        keywords: opts.keywords || '',\n        start: start || false\n      };\n    } else {\n      opts = {\n        mention: false,\n        keywords: opts,\n        start: start || false\n      };\n    }\n\n    // mention takes priority over start variable\n    if (opts.mention) {         \n      // if 'mention' is truthy, make sure the bot only \n      // responds to mentions of the bot\n      opts.keywords = `<@${id}>:* ${opts.keywords}`;\n    } else {\n      // If 'start' is truthy, prepend the '^' anchor to instruct\n      // the expression to look for matches at the beginning of\n      // the string\n      opts.keywords = start ? '^' + opts.keywords : opts.keywords;\n    }\n\n    // Create a new regular expression, setting the case \n    // insensitive (i) flag\n    // Note: avoid using the global (g) flag\n    let regex = new RegExp(opts.keywords, 'i');\n\n    // Set the regular expression to be the key, with the callback \n    // function as the value\n    keywords.set(regex, callback);\n  }\n}\n```", "```js\nbot.respondTo({ mention: true }, (message, channel, user) => {\n  let args = getArgs(message.text);\n\n  let city = args.join(' ');\n\n  getWeather(city, (error, fullName, description, temperature) => {\n    if (error) {\n      bot.send(error.message, channel);\n      return;\n    }\n\n    bot.send(`The weather for ${fullName} is ${description} with a temperature of ${Math.round(temperature)} celsius.`, channel);\n  });\n});\n```", "```js\nconst classifier = new natural.BayesClassifier();\n\nclassifier.addDocument('is it hot', ['temperature', 'question','hot']);\nclassifier.addDocument('is it cold', ['temperature', 'question' 'cold']);\nclassifier.addDocument('will it rain today', ['conditions', 'question', 'rain']);\nclassifier.addDocument('is it drizzling', ['conditions', 'question', 'rain']);\n\nclassifier.train();\n\nconsole.log(classifier.classify('will it drizzle today'));\nconsole.log(classifier.classify('will it be cold out'));\n```", "```js\nconditions,question,rain\n```", "```js\ntemperature,question,cold\n```", "```js\nconsole.log(classifier.getClassifications('will it drizzle today'));\n```", "```js\n[ { label: 'conditions,question,rain',\n    value: 0.17777777777777773 },\n  { label: 'temperature,question,hot', value: 0.05 },\n  { label: 'temperature,question,cold', value: 0.05 } ]\n```", "```js\nclassifier.save('classifier.json', (err, classifier) => {\n  // the classifier is saved to the classifier.json file!\n});\n```", "```js\nnatural.BayesClassifier.load('classifier.json', null, (err, classifier) => {\n  if (err) {\n    throw err;\n  }\n\n  console.log(classifier.classify('will it drizzle today'));\n});\n```", "```js\nlet settings = {};\n\nbot.respondTo({ mention: true }, (message, channel, user) => {\n  let args = getArgs(message.text);\n\n  if (args[0] === 'set') {\n    let place = args.slice(1).join(' ');\n    settings[user.name] = place\n\n    bot.send(`Okay ${user.name}, I've set ${place} as your default location`, channel);\n    return;\n  }\n\n  if (args.indexOf('in') < 0 && !settings[user.name]) {\n    bot.send(`Looks like you didn\\'t specify a place name, you can set a city by sending \\`@weatherbot set [city name]\\` or by sending \\`@weatherbot ${args.join(' ')} in [city name]\\``, channel);\n    return;\n  }\n\n  // The city is usually preceded by the word 'in'  \n  let city = args.indexOf('in') > 0 ? args.slice(args.indexOf('in') + 1) : settings[user.name];\n\n  let option = classifier.classify(message.text).split(',');\n\n  console.log(option);\n\n  // Set the typing indicator as we're doing an asynchronous request\n  bot.setTypingIndicator(channel);\n\n  getWeather(city, (error, fullName, description, temperature) => {\n    if (error) {\n      bot.send(`Oops, an error occurred, please try again later!`, channel);\n      return;\n    }\n\n    let response = '';\n\n    switch(option[0]) {\n      case 'weather':\n        response = `It is currently ${description} with a temperature of ${Math.round(temperature)} celsius in ${fullName}.`;\n        break;\n\n      case 'conditions':\n        response = `${fullName} is experiencing ${description} right now.`;\n        break;\n\n      case 'temperature':\n        let temp = Math.round(temperature);\n        let flavorText = temp > 25 ? 'hot!' : (temp < 10 ? 'cold!' : 'nice!');  \n\n        response = `It's currently ${temp} degrees celsius in ${fullName}, that's ${flavorText}`;\n    } \n\n    bot.send(response, channel);\n  });\n});\n```", "```js\nlet settings = {};\n\nbot.respondTo({ mention: true }, (message, channel, user) => {\n  let args = getArgs(message.text);\n\n  if (args[0] === 'set') {\n    let place = args.slice(1).join(' ');\n    settings[user.name] = place\n\n    bot.send(`Okay ${user.name}, I've set ${place} as your default location`, channel);\n    return;\n  }\n```", "```js\nif (args.indexOf('in') < 0 && !settings[user.name]) {\n    bot.send(`Looks like you didn\\'t specify a place name, you can set a city by sending \\`@weatherbot set [city name]\\` or by sending \\`@weatherbot ${args.join(' ')} in [city name]\\``, channel);\n    return;\n  }\n\n  // The city is usually preceded by the word 'in'  \n  let city = args.indexOf('in') > 0 ? args.slice(args.indexOf('in') + 1) : settings[user.name];\n```", "```js\nlet option = classifier.classify(message.text).split(',');\n\n  console.log(option);\n\n  // Set the typing indicator as we're doing an \n  // asynchronous request\n  bot.setTypingIndicator(channel);\n```", "```js\nclassifier.addDocument('is it hot outside', ['temperature', 'question', 'hot']);\n```", "```js\ngetWeather(city, (error, fullName, description, temperature) => {\n    if (error) {\n      bot.send(`Oops, an error occurred, please try again later!`, channel);\n      return;\n    }\n\n    let response = '';\n\n    switch(option[0]) {\n      case 'weather':\n        response = `It is currently ${description} with a temperature of ${Math.round(temperature)} celsius in ${fullName}.`;\n        break;\n\n      case 'conditions':\n        response = `${fullName} is experiencing ${description} right now.`;\n        break;\n\n      case 'temperature':\n        let temp = Math.round(temperature);\n        let flavorText = temp > 25 ? 'hot!' : (temp < 10 ? 'cold!' : 'nice!');  \n\n        response = `It's currently ${temp} degrees celsius in ${fullName}, that's ${flavorText}`;\n    } \n\n    bot.send(response, channel);\n  });\n});\n```", "```js\ncallback(null, data.name, condition, data.main.temp, data);\n```", "```js\ngetWeather(city, (error, fullName, description, temperature, data) => {\n```", "```js\ncase 'weather':\n        // rain is an optional variable\n        let rain = data.rain ? `Rainfall in the last 3 hours has been ${data.rain['3h']} mm.` : ''\n\n        let expression = data.clouds.all > 80 ? 'overcast' : (data.clouds.all < 25 ? 'almost completely clear' : 'patchy');\n        // in case of 0 cloud cover\n        expression = data.clouds.all === 0 ? 'clear skies' : expression;\n\n        let clouds = `It's ${expression} with a cloud cover of ${data.clouds.all}%.`;\n\n        response = `It is currently ${description} with a temperature of ${Math.round(temperature)} celsius in ${fullName}. The predicted high for today is ${Math.round(data.main.temp_max)} with a low of ${Math.round(data.main.temp_min)} celsius and ${data.main.humidity}% humidity. ${clouds} ${rain}`;\n        break;\n```"]