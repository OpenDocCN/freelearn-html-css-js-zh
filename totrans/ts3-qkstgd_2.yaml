- en: Onboarding Types with Primitive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Primitive types are all the basic supported categories of value. Each type represents
    a domain of values in which the integrity of the format is enforced. JavaScript
    has a limited set of primitives that can only be inferred by the assignation of
    a value to a variable. For example, a value can be a number, a date, a Boolean,
    a string, and so on. The assignation of a subsequent value of a different model
    to a singular variable is permitted. The side effect is the mutation of the type,
    which increases the complexity of any JavaScript program. TypeScript, however,
    can enforce type immutability, which reduces the risk of a potential wrong value
    that misleads the proper execution of the application. Also, TypeScript provides
    support on which operation can be used, depending on which explicit type is attached
    to a particular value. This chapter illustrates the scoping of a variable, the
    subtlety between an undefined variable and a null variable, and how to make a
    variable optional or required. At the end of this chapter, the reader will be
    in a situation where all the variables will be declared properly, with an accurate
    type supported by TypeScript. The distinction between a primitive and a non-primitive
    type will no longer be a conundrum. The use of `enum` or symbol will be natural
    and the creation of new types will become a habit any time a new domain object
    is introduced in your system.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The difference between `var`, `let`, and `const`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to be strongly typed without specifying the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The difference between var, let, and const
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript has many ways to declare a variable. You can define a variable at
    a function or global scope using one of the three following keywords: `var`, `let`,
    and `const`. Also, you can define a variable with `public`, `private`, or `protected`
    at the class level.'
  prefs: []
  type: TYPE_NORMAL
- en: Declaring with var
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The most basic way to declare a variable is by using the keyword `var`.  It
    is the oldest declaration, but the least-preferred way because of some quirks.
    The main issue with `var` is that it gets declared in the execution context, which
    means inside the function scope or at the global scope. If, by accident a value
    is assigned to a variable not explicitly declared with `var`, then the scope of
    the variable is at the global scope. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A `var` declaration can be made stricter with the strict mode in JavaScript
    so that TypeScript can turn on every file automatically by using `alwaysStrict`
    in its compiler''s options. Otherwise, you must remember that `var`–declared variables
    are created before the execution of the code. Variables without the keyword `var`
    do not exist until the code assigning them is executed. In JavaScript, it''s possible
    to assign a variable without declaring, which is not the case with TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'While TypeScript can protect against an undeclared variable, it does not protect
    a `var` declaration against the side effect of **hoisting**. The issue comes from
    JavaScript, where a declaration with `var` is processed before other pieces of
    code, which brings the variable declaration to the top of the scope (function
    or global). The subtlety is that the declaration is moved up, but not the initialization.
    That being said, TypeScript will not let you use a variable defined under its
    usage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `var` lets you define the variable that overrides the initial declaration
    or initialization more than once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Generally, the use of `var` is a dated way to declare a variable. With TypeScript,
    there is a big incentive to rely on `let` or `const` because you can generate
    an older ECMAScript version that will generate `var` but in a proper and valid
    format.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring with let
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `let` declaration is scope-based. It cannot be declared more than once per
    scope, and it does not hoist the variable. It simplifies the readability of the
    code, and it avoids unexpected errors. Declaring with `let` also doesn''t set
    any values globally. Relying on `let` is the way to declare a variable when you
    expect the variable to be set more than once. In the following code, the variable
    `a` is defined three times. The code is legal, even with several declarations.
    The reason is that each declaration, with `let`, is defined in a different scope
    with curly braces. The first scope is the function scope. The second scope uses
    an unusual syntax, but it reflects how a `while`, `if`, or other scope feature
    works. The third scope is within an `if` statement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, TypeScript ensures that once a declaration is done, the type associated
    with the variable is immutable. This means that a variable defined as a number
    will be a number for the rest of the lifespan of the variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Declaring a variable with `let` in a `switch` case can be tricky. The reason
    is the scoping is not by `case` but for the `switch` that hosts all the cases.
    However, it is possible to conceive a scope by summoning a curly bracket inside
    each `case`. The following code is valid even if two variables `b` are declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'However, adding a subsequent case that also declares a variable `b` fails the
    compilation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The workaround for the default scope from the `switch` is to create an artificial
    scope for each case. The construction of the scope can be done by adding curly
    brackets, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`let` is one of the most-used declarations and should always be used instead
    of `var` when `const` is not a valid option.'
  prefs: []
  type: TYPE_NORMAL
- en: const
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the case where you know that the variable is set once and will not change,
    then using `const` is a better alternative. The reason is that it highlights to
    the reader of the code that the value cannot be set more than once—it is declared
    and initialized. TypeScript respects `let` and `const`, and the code will not
    compile if a variable is defined more than once or if a value is assigned twice
    when the variable is a constant.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conscribing a variable to stay with a single value may look restrictive, but
    in many situations, it is the right thing to do. The declaration of a primitive
    with `const` blocks the access of assigning with the equals sign (`=`), which
    means that it does not allow you to change the reference of the variable. However,
    you can change the content of the variable. For example, an array of primitives
    can add and remove values from the array, but cannot assign a new list of values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code shows that a member can be edited, even if the object is
    declared as a constant. However, the `myObj` is not assignable. It means that
    the reference will always remain the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, TypeScript, with the use of `let` and `const`, ensures that the value
    assigned to a variable is associated with the desired variable, and any faulty
    assignation will cause the compiler returning an error. In the following code,
    two variables are clearly defined at the global scope, as well as the function
    scope. There is no doubt that they are two distinct variables with any collusion
    of value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Enhancing primitives with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript has the same primitive variables as JavaScript. It is possible to
    declare a variable to hold a number, string, Boolean, and a symbol. Also, two
    primitives are available for a situation where no value is available: undefined
    and null. Finally, with these primitives, it''s possible to have an array of each
    of them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'All primitives must use one declaration previously discussed with a unique
    variable name and use the colon followed by the word number. However, when used
    as a parameter of a function, the `declaration` keyword is avoided. There is no
    need to specify the scope of the variable because this one is for the function.
    The same goes for the visibility, which is only visible to the function receiving
    the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Number
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript follows how JavaScript manipulates and carries the primitive type
    of a number by having a single type: number. A number can be an `integer`, a `float`,
    a `double`, negative, positive and even `NaN`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A number cannot directly use a `boolean` value (neither `true`, neither `false`).
    A conversation by parsing the `boolean` is required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are many ways to convert a Boolean to a number. You can use the `Number`
    constructor that takes any value and converts it into a number of `1` for `true`
    and `0` for `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the ternary operator and manually select the desired value, which
    can be beyond `1` and `0`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `+` sign to start an addition to the value, which automatically
    converts the `boolean` value to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A number cannot use a string directly either. Many techniques borrowed from
    JavaScript are available. The first one is using `Number`, and similar to the
    `boolean` case will parse the string into a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The second approach is using the `parseInt` function. The `parse` function
    has a second optional parameter that allows specifying the base. It is important
    to note that this should always be specified to avoid error with octal or hexadecimal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can use the `+` sign to add to the value, which automatically converts
    the string value to a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Converting a string into a number can be tricky if the string is written with
    **numeric separators**. A numeric separator allows writing a number in a human
    way by dividing the digit by an underscore. This increases the readability. For
    example, here are nine million one hundred:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Parsing a string with a numeric separator will fail, but this is also the case
    when using the `Number` approach as well as the `+` sign approach. The result
    is inconsistent and can be from `NaN` to parsing just the value before the first
    underscore. In that case, replacing all underscores and using one of the techniques
    previously mentioned would be the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'A number can be written in a different base. As in JavaScript, TypeScript uses
    the `0x` literal for hexadecimal, `0b` for binary, and `0o` for octal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript is identical to JavaScript for a string. You can define a string
    between single quotes, double quotes, or backquotes. The single quote and double
    quote have the same function of assigning the string between the quotes to the
    variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The backquote, or backtick, has a special name, **string interpolation**, which
    allows injecting code inside the string. This is possible using a special syntax
    with the dollar sign and curly brackets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The last example produces this output: Can invoke the variable function: s
    as well as any code like this addition: 2.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Interpolation goes beyond just injecting other value and can run any TypeScript
    code. The previous example does an addition in the string. Another feature of
    string interpolation is that you can add a line break without having any compilation
    problem. With a single and a double quote, a string must be on the same line or
    be broken in several strings and concatenated with a `+` sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Boolean
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `boolean` type allows the lowercase `true` and `false` only. No number is
    authorized, neither different capitalization of the value. It''s possible to convert
    a numeric value, that is `1` or `0`, by comparing it to `1`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'It is also possible to use the JavaScript `Boolean` construction to have a
    conversion. TypeScript doesn''t remove the quirks that come along with the parsing
    but returns a strongly typed `bool` value of the constructor. Here are some examples
    that barely any work for the case of a string with the value `false`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the last two lines are a TypeScript specific solution where we cast the
    string to type and then back to a `boolean`. It is also one of the only solutions
    that work, other than comparing to the string directly as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preferred solution is to avoid casting to any. Casting opens the door to
    potential unexpected errors in most cases, even if in this particular situation,
    the casted value is controlled in this example, which could not be the case in
    a real scenario. The use of the `boolean` constructor is compelling but must be
    used carefully as the value `false` will result in a `boolean` `true` value. If
    the value is not controlled and part of a string, the safest way is to compare
    to use the `isTrue` function provided in this section of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Null'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The value `Null` can be assigned to a variable when the main value is not available.
    Without the compiler option, `strictNullChecks`, TypeScript allows having null
    or undefined. As a best practice, it''s always better to set the strict null check
    and assign manually which of the variables can have both values. The reason is
    that you can carefully craft each variable and type with the right amount of flexibility
    around what is of the specific type or null or undefined, without having a door
    wide open. Every time a variable can be null, a check to null will be required
    before being able to use the object''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The usage of `null` should be limited in TypeScript in favor of `undefined`.
    The reason will be explained in the *Undefined* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'With `strictNullChecks` activated, the `null` value can only be assigned to
    a type allowing `null` or to a value of type any. To have a type accepting null,
    a union must be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Undefined
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `undefined` can be assigned to a variable when the main value is not available,
    similar to `null`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'However, it has more cases. For example, an optional parameter (that we will
    discuss later in this book) is automatically set to `undefined` when not provided
    by the TypeScript. The reason is that when a property does not exist in JavaScript,
    it is undefined, not null:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'As mentioned, `undefined` is also the value returned if you are using square
    brackets to access an object property that doesn''t exist using a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`undefined` is also the value assigned to a field variable of a class when
    the class has not yet set the initial value from the constructor. This is only
    reproducible if the compiler option `strictPropertyInitialization` is set to `false`,
    which is a bad practice. As a good way to avoid having a field that is not explicitly
    mentioning `undefined` to be undefined because of a lack of initialization, the
    compiler option should always be `true`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'With `strictNullChecks` activated, the undefined value can only be assigned
    to a type allowing `undefined`, a type that is optional, or to a value of type
    any. To have a type accept `undefined`, a union must be used with the primitive
    and undefined. In the case of an optional, a function can use the question mark
    before the colon that specifies the primitive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'An `undefined` can also use the optional notation in a class or an interface
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Like a type in a union with `undefined`, an optional value can be verified
    by comparing against `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Symbol
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `Symbol` allows the creation of a value that is unique. A `Symbol` is different
    than a constant because two constants with the same value are equal, while this
    is not the case with two symbols with the same value. The constant variables work
    like any variable, by comparing the value. Comparisons with `Symbol` work differently.
    Every `Symbol` is unique, hence even with the same value, they are not the same.
    Let''s see some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of `Symbol` can ensure that the value provided is absolutely the one
    desired. It is not able to pass another constant with the same value, neither
    a string with the same value. Only the exact same symbol must be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `Symbol` can be used as an insurance when defining a field to an object.
    With the symbol, you can be sure to define every field once. A `Symbol` is by
    nature immutable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript needs to know about the `Symbol` feature that was introduced in
    ES2015\. Before using the `Symbol` keyword, the `tsconfig.json` must add `lib` to
    the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Non-primitive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is also a more advanced group of variables beyond the primitives. The
    non-primitive group includes `void`, `string literal`, `tuple`, `any`, `unknown`,
    and `never`; we will now discuss these variables.
  prefs: []
  type: TYPE_NORMAL
- en: What is void?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `void` is a special and is used mainly for a function that returns no value.
    With an explicit return to `void`, the function cannot accept a return statement
    with a value that can occur with it; hence, it acts as a guard of potential error
    of returning a value. A `void` function can still have an empty return to leave
    the function before reaching the closing curly bracket. A `void` variable can
    only be assigned to `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This is not useful, but it explains what happens if you return a function without
    a value to a `void` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'It is always a good practice to mark a function with `void` instead of using
    the implicit return value. The implicit return type for a function is a *weak*
    *void* because the function allows the returning of anything. The following function
    doesn''t have a return type and was initially returning nothing. However, in its
    life, the function changed (as you will see next) and now returns three different
    values that are not like the previous ones. The *implicit returns* value is not
    void anymore. Having an explicit return type define a contract and indicate to
    anyone touching the function what is the expected return type and that should
    be respected. In this example code, the function returns a union of a Boolean,
    number, and string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: The reasons to avoid using any type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `any` is a wildcard type that allows not only `any` type but also to change
    the type at will. There are many problems with `any`. The first one is that it
    is hard to follow what type is a variable; we are back to how JavaScript is written:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The use of `any` should be avoided because it can hold a value that is not
    as expected and still it can compile because TypeScript does not know the type
    and cannot perform validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The only reason to use `any` is in two situations. The first one is that you
    are migrating code from JavaScript to TypeScript. Migrating code can take a long
    time and TypeScript is built naturally in a way that you can be in a hybrid mode
    for a while. It means that not only you can turn down some strictness of the compiler
    options, but also that you can create functions, variables, and types that are
    not fully detailed in terms of type by allowing `any`.
  prefs: []
  type: TYPE_NORMAL
- en: The second situation where `any` is potentially acceptable is when you are in
    a situation that you cannot figure out the type in some advanced scenario and
    you must move on. The latter should be a signpost and must have a follow-up because
    we do not want to make it a habit.
  prefs: []
  type: TYPE_NORMAL
- en: Usage of the never type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `never` is a variable that should never be set. This might sound useless
    at first but can be useful in a case where you want to ensure that nothing falls
    into a particular code path. A function rarely returns `never`, but it can happen.
    This is the case if you are having a function that does not allow you to finish
    the method to execute or return any variable; hence, it never fully returns. This
    can be coded using an exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '`Never` occurs when you are writing code and you are writing a condition that
    cannot occur and that TypeScript infers the type by the usage of your code. This
    can happen if you have several conditions and that one englobe another making
    some variable fall into the `never` scenario. It can also happen if you have all
    the variable values covered by condition and have an `else` statement (or default
    with a `switch case`). The value cannot have any other value than *never been
    assigned*, since all values are checked. Here is an illustration of the possibility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'In practice, the `never` type is used for checking whether all values of an
    `enum` or a `union` have conditions that took care of all the values. This allows
    creating a validation when a developer adds a value to the `enum` or the `union`
    but forgets to add a condition. The lack of the condition makes the code fall
    through the exhaustive check. TypeScript is smart enough to verify all cases and
    understand that the code might go in the function that takes a `never` parameter,
    which is not allowed because nothing can be assigned to `never`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: Unknown type to have a stricter any type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript `unknown` type is a new addition to reduce the usage of `any`. When
    a variable is of type `unknown`*,* everything can be set to the variable. However,
    the value `unknown` can only be set to another `unknown` type or `any` type. Here
    is a list of several rules about the `unknown` type:'
  prefs: []
  type: TYPE_NORMAL
- en: An `unknown` type can only be used with the equality operator; no other operator
    will compile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A function that returns `unknown` does not require to return anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An intersection with the `unknown` type is useless because the type on which
    the unknown is intersected will take over. However, when used in a `union`, it
    will always take precedence and override any other type in the union.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A key of on an `unknown` type is always `never`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'One use case of the type `unknown` is that it can be used when you do not know
    a type. Instead of relying on `any`*,* which can accept everything and be passed
    along any code, the use of` unknown` restricts the flow of the variable. Since
    an unknown variable cannot be set to another variable, it forces the developer
    to properly scope down the value to its type and continue further along. Without
    the `unknown` type, `any` would have been the only option. It opens the door wide
    to accept anything and to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the first function can take anything and expect to return a
    string. However, no cast or anything is required because a variable of type` any`
    can return a string. However, with an `unknown`, it must be handled. As mentioned,
    the reason is that the `unknown` type cannot be assigned to types other than` unknown`
    or `any`.
  prefs: []
  type: TYPE_NORMAL
- en: Enforcing a type in a list
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An array can be created in two different ways. The first is using the square
    brackets and by using the `Array` generic object. They are both interchangeable,
    and both of them can be typed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The square- bracket format is more compact, and it allows to specify the type
    before the squared brackets. The `Array` generic object specifies the type between
    the smaller/bigger sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to have an array holding more than one type of a type by combining
    the array type with a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript acts the same as in JavaScript, other than specifying the type for
    the array. You can access the content by using the index position and using all
    the methods available that are automatically typed with the type of the type specified
    for the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: If a position doesn't contain a value, the type returned is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript allows to loop an array and retrieve for each position the element
    strongly typed. The type is optional because TypeScript can infer the type. It
    means that the following code can be written with or without the `number` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Defining a conscribed set of constants with enum
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript has a keyword `enum` that let you specify many possible values as
    a group where only a single item can be selected. Defining an `enum` can be done
    by providing potential keys that would automatically assign a sequential number
    from `0` to the first potential choice of the `enum` and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to specify a value to a key to have fine-grained control. Any
    missing value will be the next sequence value. In the following code example,
    `Sunny` is set to `100`, and `Cloudy` is automatically `101`, `Rainy` is `102`,
    and so on:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to skip, in that case, you can only provide a bigger value and
    the value of the assigned one is sequential. In the following code example, the
    values are `100`, `101`, `200`, and `201`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enum` can also support string or a mix of a string and a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'The `enum` can be accessed by the `enum` or by value. Accessing by the `enum`
    requires using the dot notation from the `enum` directly. The value returned is
    the `enum`. This is the common way to assign an `enum` in TypeScript. It is also
    possible to assign the value. The assignation by value is useful when data come
    from JSON. For example, the value is returned from an Ajax response. It bridges
    non-TypeScript into TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code, accessing the value from the with the square bracket only
    works when the value in the square bracket is the type, not the value.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to `number` and `string`, `enum` supports bitwise values with the
    help of a bit shift operator. It allows to check whether a value contains a single
    or an aggregate of value with an ampersand (`&`). The reason is that with the
    pipe `|` you can create a variable that contains several values. The stacking
    values can also reside inside the `enum` for reusability purposes but is not required:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'A value can hold more than a single value. This is useful if we want to persist
    the existing value intact and you need to use the sign `|=`. To remove a particular
    status, you need to use `&= ~`. Using these operators will swap the value at the
    right position in its binary format without affecting the remaining parts of the
    number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to check whether the variable is of a particular status, you must
    use the triple equals with the ampersand to the value you want to check against.
    The use of a single ampersand for comparison is a mistake. The ampersand returns
    a number, not a `boolean`. The comparison needs to be against the value that we
    want to check. It is possible to check against many values by creating a combined
    value in the comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: The `enum` is a great way to define a set of potential value from a specific
    domain for a variable. It has the convenience of being clear by naming the choices
    at your convenience and letting you decide the value of each entry if needed.
  prefs: []
  type: TYPE_NORMAL
- en: String literal and its difference compared to a string
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `string` is a type that allows any kind of characters. A `string literal`
    is the association of a particular `string` as a type. When a `string` is set
    to a type, it is possible to assign one value and change it later. The only value
    possible to set to a `string literal` is the exact string stamped at the declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'TypeScript compiles the code into plain JavaScript, without types. A `string
    literal` ensures that while writing the code in TypeScript that only a single
    string value can be associated with a variable, and this is compiled into JavaScript
    objects with this mandatory value. The essence of this particularity is that we
    have in both languages the assurance that the value is unique. This becomes handy
    in a situation where you need to condition a type that will not be there once
    compiled. For example, the case of an interface and a piece of code that must
    act differently depending on the interface. Having a shared field (with the name)
    among the interfaces with a unique string literal allow comparison at design time
    and run-time. At design time, TypeScript will be able to narrow down the type
    and hence provide better support for the specified type and at run-time be able
    to conduct the execution flow at the right place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: The code example shows that two interfaces share a type that is a `string literal`.
    To be able to access the unique property of one or the other `interface` in the
    function, a comparison of a discriminator is required. Without the comparison,
    the function that takes both interfaces with the union as a parameter does not
    know which of the two types is passed. However, TypeScript analyzes the two interfaces
    and identifies a common field and allows you to use this before scoping down the
    type. Once TypeScript can find which type is treated, it allows using the specific
    field of the type. In the example, inside the condition, all the movie's `interface`
    fields are available. On the other side, the `else` allows all the book's `interface`
    fields only.
  prefs: []
  type: TYPE_NORMAL
- en: 'A literal string is one type of three possible literals that TypeScript supports.
    TypeScript supports `number` and `boolean` on top of the string. Finally, when
    using `string literal`, always provide the type using the colon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Instead of relying on `let`, which opens the door to many assignations, the
    use of `const` can ensure a single assignation; hence, it will automatically infer
    a `literal` type for the three types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: It is possible to create a literal by omitting the type only if declared with
    `const` because the value cannot change; hence, TypeScript will scope to its most
    narrowed expression. However, a change from `const` to `let` in the future would
    change the type back to `string`. I suggest being as explicit as possible to avoid
    an undesired type of change.
  prefs: []
  type: TYPE_NORMAL
- en: Crafting a typed function
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Functions **are first-class citizens in JavaScript. Since the early versions
    of ECMAScript, functions were the main concept to execute code and create scope.
    TypeScript uses the function the same way but provides additional typing features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A function has a main signature that contains the name of this one, the list
    of parameters, and the return type. Parameters are defined in parentheses, as
    in JavaScript, but each parameter will be followed by its type using the colon
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'A `function` can have several parameters of a different type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'It can also have a parameter that has more than one type using a union:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'A `function` has a single return declaration but that type can use a union
    to allow types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'A function can have a complimentary signature to indicate to the consumer which
    parameters match together and with the return type. Having several function signatures
    for the same body is the concept of an overloaded function. When using an overloaded
    function, all signatures must be written from top to bottom from the most specific
    to the largest one. All the definition requires finishing with a semicolon expect
    the last one. The last signature always has a union that covers all possible types
    for each position. In the following code example, we specify that if the parameter
    is a `boolean`, then the function returns a string. If the parameter is a `Date`,
    then the return type is a `number`. The last signature contains a first parameter
    the union of both possible values (`boolean` and date) as well as a union for
    the return type between `string` and `number`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'A function can be anonymous. Here is an example with the *fat arrow* format
    and one example returning a `Function` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'A `function` can be a `variable` function or a typical function. Here are three
    functions set in a `variable`. The `variable` can be called by using parentheses
    and the required parameter. The code example shows also two ways to return data
    with the *fat arrow* format. If the code returns directly without doing any *several*
    statements, the need for curly brackets and *return* *statement* is not needed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: 'A function can have an optional parameter and a default value parameter. An
    optional parameter is denoted by the use of question mark after the name of the
    parameter. An optional parameter allows avoiding passing a value. `TypeScript`
    automatically sets the parameter to `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '`Optional` is different than having the variable with a union to `undefined`
    because the union requires passing the value or undefined while optional allows
    passing the value, undefined or nothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '`Optional` can only be set after non-optional parameter. The reason is that
    other parameters are required but having `Optional` before or in the middle would
    make it hard to map `which` parameter is `which`. The following code example presents
    a case where the function does not compile because of that rule. However, it''s
    possible to have many optional parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: 'A `function` can be in a class (object-oriented is covered in a future chapter).
    When this happens, the syntax is different. It doesn''t use the keyword `function`.
    Instead, the visibility is provided, which is `public`, `private`, or `protected`.
    `TypeScript` allows avoiding access modifiers, which will result in a `public`
    function. As for a class variable, the omission of the visibility uses `public`
    as default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'The basis remains the same with parameters and a return type that is strongly
    typed. It is also possible to create a variable that holds the function inside
    a class as seen in this chapter. Here are three examples of a `private` function
    defined as a `variable`. The first one is long and very explicit. The second example
    doesn''t define the type at the function level because it is already defined in
    the declaration. The last example doesn''t define the type of the variable and
    the variable is still strongly typed because it infers its signature from the
    initialization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: A `function` in a variable is technically called a **function expression**,
    while the more traditional `function` syntax is named a **function statement**.
    The usage of one or the other is the same in `TypeScript` than with `JavaScript`.
    Because it operates under JavaScript's law, it means that the expression function
    is not hoisted.
  prefs: []
  type: TYPE_NORMAL
- en: How to be strongly typed without specifying the type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript can have a type specified explicitly or you can have the type determined
    by TypeScript. The latter is called an **implicit type** or a type defined by
    inference. The action of inference is conducted by TypeScript depending on how
    a variable is initialized during declaration for the variable or what is returned
    for a function return type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A variable inference is only possible when a value is assigned at the declaration.
    It means that you must set a value when using `var`/`let`/`const`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: In the previous code example, the value `1` is assigned to the variables `x`
    and `y` during the initialization. This is valid even if the colon is not used.
    `TypeScript` will infer the type for both variables. In the case of not specifying
    a value, only `var` or `let` would compile because it allows in a future moment
    the assignation. The value is not specified, which means that the type is falling
    back to `any`. This is true even if the value is set within the scope of the variable
    life.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous code example, the value `1` was assigned to a constant and
    a variable. The type of both of these declarators is different. The constant type
    is not a number, it is a number literal of `1`. It means that the type is `1`
    and only `1` and not any other number. However, the type of the variable declared
    with `let` is `number`. The reason is that with the constant, TypeScript knows
    that it can only be initialized once and that the value cannot change. It scopes
    down the simplest type it can find which is the value of the primitive. On the
    contrary, the variable declared with `let` can change its value during the lifetime
    of the variable. The TypeScript scopes the type every number. This is `true` with
    a `number`, `string`, and `boolean`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: However, a date will stay to the date type regardless of the declarator, the
    same for any class or interface because it is the smaller denominator. In the
    previous code example, both `c1` and `c2` are of the type of an object that must
    have a member named `m1` of a type number. This example illustrates how TypeScript
    can also infer type inside type. `m1` is a number by inference.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inference works with functions as well. However, it has some limitations. The
    first one is that parameter must be explicit. The reason is that you cannot infer
    by usage without having a potential room for error. In the following code, the
    argument `a` is implicit `any`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the return can be implicit. By returning a known type, the return
    type can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case of returning several values, TypeScript creates a union of all
    potential types. In the following code example, there are two return statements.
    TypeScript looks for each value returned and concludes that two different values are
    returned. The return type generated is `number | string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how TypeScript can declare variables and which declarator
    is be the best to use depending on the situation. We saw that TypeScript improves
    JavaScript's primitive type by enforcing the type during the lifetime of the variable.
    We explained how to transform a variable into a multiple type container with the
    concept of the union. TypeScript brings type to functions and we saw how we could
    improve the readability of a function that takes many combinations of arguments
    and return types with the overload function. TypeScript brings a new way to type
    variables with the popular `enum` borrowed from popular languages such as Java
    and C#. Finally, we glimpsed at how TypeScript is smart to infer types in different
    situations that can be advantageous to reduce lengthy definitions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see in detail the differences between many different
    object types and look at how we can manipulate types to have a strongly typed
    code flexible enough to fulfil our needs of defining our business models with
    TypeScript.
  prefs: []
  type: TYPE_NORMAL
