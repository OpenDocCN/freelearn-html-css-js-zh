- en: '14'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Three.js Together with React, TypeScript, and Web-XR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this final chapter, we’ll dive into two additional topics. First, we’ll look
    at how you can combine Three.js with TypeScript and React. The second part of
    this chapter will show some examples of how you can integrate your 3D scenes with
    Web-XR. With Web-XR, you can enhance your scenes to work with VR and AR technologies.
  prefs: []
  type: TYPE_NORMAL
- en: 'More specifically, we’ll show you the following examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using Three.js with TypeScript**: For the first example, we’ll show you how
    you can create a simple project that combines Three.js and TypeScript. We’ll create
    a very simple application, much like the samples we’ve already seen in the previous
    chapters, and show you how you can use TypeScript with Three.js to create your
    scenes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Using Three.js and React with TypeScript**: React is a very popular framework
    for web development and is often used together with TypeScript. For this section,
    we’ll create a simple Three.js project, which uses React.js together with TypeScript.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`React-three-fiber`. With this library, we can configure Three.js declaratively
    using a set of React components. This library provides great integration between
    React and Three.js and makes working with Three.js in a React application straightforward.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three.js and VR**: This section will show you how you can view your 3D scene
    in VR.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Three.js and AR**: This section will explain how you can create a simple
    3D scene where you can add Three.js meshes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s start with the first example of this chapter and integrate Three.js with
    TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Using Three.js with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript provides a typed language that transpiles to JavaScript. This means
    that you can use it to create your site, and it’ll run just like normal JavaScript
    in the browser. There are many different ways of setting up a TypeScript project,
    but the easiest one is provided by Vite ([https://vitejs.dev/](https://vitejs.dev/)).
    Vite provides an integrated build environment and can be seen a bit as an alternative
    to webpack (which we use for the normal chapter samples).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is create a new Vite project. You can do these
    steps yourself, or you can look in the `three-ts` folder and just run `yarn install`
    there to skip this setup. To get an empty TypeScript project with Vite, all we
    have to do is run the following code in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Next change into the directory (`three-ts`) and run `yarn install`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: At this point, we’ve got an empty Vite project, which you can start by running
    `yarn vite`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you point your browser to `http://127.0.0.1:5173/`, you’ll see the start
    page of Vite, and you’ll have a configured TypeScript project in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.1 – Empty TypeScript project with Vite](img/Figure_14.1_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.1 – Empty TypeScript project with Vite
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we must add the Three.js libraries, after which we can add some TypeScript
    to initialize Three.js. To add Three.js, we need to add the following two node
    modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one adds the Three.js library, while the second one adds the `types`
    descriptions for the Three.js library. These `types` are used in the editor to
    get some nice code completion when working with Three.js and TypeScript in your
    IDE (for example, in Visual Studio Code). At this point, we’re ready to add Three.js
    to this project and start developing Three.js applications using TypeScript. To
    add TypeScript, the first thing we need to do is take a quick look at how the
    application is initialized. For this, you can look at the `public.html` file,
    which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, as you can see in the last `script` line, this HTML
    page loads the `src/main/ts` file. Open this file and change its content to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The code here will try to find the main `#app` node. And if it finds the node,
    it’ll pass that node to the `initThreeJsScene` function, which is defined in the
    `threeCanvas.ts` file. This file contains the code to initialize the Three.js
    scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will look familiar to the code from the first couple of chapters where
    we created an initial simple scene. The main change is that, here, we can use
    all the features provided by TypeScript. Vite will handle the transpiling to JavaScript,
    so you don’t need to do anything else to see the results of this in your browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.2 – Simple TypeScript project with Three.js](img/Figure_14.2_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.2 – Simple TypeScript project with Three.js
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve introduced Three.js and TypeScript, let’s go a step further and
    see how we can integrate this with React as well.
  prefs: []
  type: TYPE_NORMAL
- en: Using Three.js and React with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are different ways of creating a React application from scratch (Vite,
    for instance, also supports this), but the most common way is to use the `yarn
    create react-app lts-tf --template TypeScript` command from the command line.
    Just like with Vite, this will create a new project. For this example, we’ve created
    this project in the `lts-tf` directory. Once created, we have to add the Three.js
    libraries just like we did for Vite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This should set up a simple react TypeScript application, add the correct Three.js
    libraries, and install all the other required modules. The next step is to quickly
    check if all this works. Run the `yarn` `start` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Open your browser to `http://localhost:3000` and you’ll see a simple React
    startup screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.3 – Simple TypeScript project with Three.js](img/Figure_14.3_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.3 – Simple TypeScript project with Three.js
  prefs: []
  type: TYPE_NORMAL
- en: 'On this screen, we can see that we need to edit the `app.tsx` file, so we’ll
    update this similar to the plain TypeScript example we saw in the *Using Three.js
    with TypeScript* section, but this time as a React component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, here, we defined a custom component named `ThreeCanvas`, which
    is now loaded as soon as the application starts. The Three.js initialization code
    is provided by the `ThreeCanvas` element, which you can find in the `ThreeCanvas.tsx`
    file. This file, for the most part, is similar to the `initThreeJsScene` function
    we described in the *Using Three.js with TypeScript* section, but we’ll include
    the whole file here for completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In `initThreeJsScene`, you can find the standard code to initialize a simple
    Three.js scene using TypeScript. To connect this Three.js scene to React, we can
    use the code from the `ThreeCanvas` functional React component. What we want to
    do here is initialize the Three.js scene at the moment the `div` element gets
    attached to its parent node. To do this, we can use the `useCallback` function.
    This function will be called once when this node gets attached to its parent,
    and won’t rerun even if one of the parent properties changes. In our case, we
    will also add another `isInitialized` state to make sure that even if we have
    the development server reload parts of the application, we only initialize our
    Three.js scene once.
  prefs: []
  type: TYPE_NORMAL
- en: useRef or useCallback
  prefs: []
  type: TYPE_NORMAL
- en: You might be tempted to use `useRef` here. There is a good explanation at https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node
    regarding why, in this case, you should use `useCallback` instead of `useRef`
    to avoid unnecessary rerenderings.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the preceding setup in place, we can now see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.4 – Three.js with TypeScript and React](img/Figure_14.4_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.4 – Three.js with TypeScript and React
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous example, we created a simple integration between React and
    Three.js. While this works, it feels a bit strange to programmatically describe
    a Three.js scene, since normally, in React, applications are declared declaratively
    using components. We can wrap the existing Three.js components as we did with
    the `ThreeCanvas` component, but this will quickly get complex. Luckily, though,
    all the hard work for this has already been done by the Three.js fibers project:
    `https://docs.pmnd.rs/react-three-fiber/getting-started/introduction`. In the
    next section, we’ll look at how easily Three.js and React can be integrated with
    the help of this project.'
  prefs: []
  type: TYPE_NORMAL
- en: Using Three.js and React with React Three Fiber
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous examples, we set up the integration between React and Three.js
    ourselves. While it works, that approach doesn’t tightly integrate with how React
    works. For a good integration between these frameworks, we can use React Three
    Fiber. We’ll start again by setting up a project.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this, run the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install all the dependencies we need and set up a new React project.
    To start this project in the `lts-r3f` directory, run `yarn start`, which will
    start a server. Open the URL you see on the screen (`http://localhost:3000`);
    you’ll see the following screen, which we’ve seen before and shows an empty React
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.5 – Starting up a simple JavaScript React application](img/Figure_14.5_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.5 – Starting up a simple JavaScript React application
  prefs: []
  type: TYPE_NORMAL
- en: 'As the screen starts to extend this example, we need to edit the `app.jsx`
    file. We’ll create a new component that will contain our Three.js scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we can already see the first of the Three Fiber components – the `Canvas`
    element. The `Canvas` element creates a `Canvas` div and is the parent container
    for all the other Three.js components provided by this library. Since we added
    `Scene` as a child to this `Canvas` component, we can define our complete Three.js
    scene in our custom component. Next, we’ll create this `Scene` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'What we’ve got here is a very simple Three.js scene, which looks similar to
    the ones we saw earlier in this book. This scene contains the following objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<ambientLight>`: An instance of a `Three.AmbientLight` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<directionalLight>`: An instance of a `Three.DirectionalLight` object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<mesh>`: This represents a `Three.Mesh`. As we know, a `Three.Mesh` contains
    a geometry and a material, which are defined as children of this element. In this
    example, we’ve set the rotation on this mesh as well.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<boxGeometry>`: This is similar to `Three.BoxGeometry`, where we pass in the
    constructor arguments through the `args` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<meshStandardMaterial>`: This creates an instance of a `THREE.MeshStandardMaterial`,
    and configures some properties on this material.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, when you open your browser to `localhost:3000`, you’ll see a Three.js
    scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.6 – Three.js scene rendered using React Three Fiber](img/Figure_14.6_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.6 – Three.js scene rendered using React Three Fiber
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we’ve only shown a couple of small elements provided by React
    Three Fiber. All objects provided by Three.js can be configured in the way we
    just showed. Just add them as elements, configure them, and they will be shown
    on the screen. Besides easily showing these elements, all these elements behave
    like normal React components. So, whenever the properties of a parent element
    change, all the elements are rerendered (or updated) as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides the elements provided by React Three Fiber, there are a whole set of
    additional components provided by `@react-three/drei`. You can find those components
    and their descriptions at [https://github.com/pmndrs/drei](https://github.com/pmndrs/drei):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.7 – Additional components from @react-three/drei](img/Figure_14.7_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.7 – Additional components from @react-three/drei
  prefs: []
  type: TYPE_NORMAL
- en: 'For the next example, we’re going to use a couple of the components provided
    by this library, so we need to add this to our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we’ll extend our example to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s explore the code a bit before looking at the result in the browser. First,
    we’ll look at the new elements we added to the component:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<OrbitControls>`: This is provided by the `drei` library. This adds an `THREE.OrbitControls`
    element to the scene. This is the same as `OrbitControls`, which we used in the
    earlier chapters. As you can see here, just adding the element is enough; no additional
    configuration is needed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`<Sky>`: This element provides a nice sky background to the scene.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We’ve also added several standard React Hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we define a `Ref`, which we connect to the mesh (`<mesh ref={mesh}) ..>`).
    We use this so that we can access the Three.js component later on in the render
    loop. We also use `useState` three times to keep track of the `color` and `opacity`
    state values of the material, as well as to see whether the `mesh` property is
    rotating or not. The first of these two Hooks is used in the events we defined
    on the mesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: With these event handlers, we can very easily integrate the mouse with the mesh.
    There’s no need for `RayCaster` objects – just add the event listener and you’re
    done. In this case, when the mouse pointer enters our mesh, we change the `opacity`
    state value and the `isRotation` flag. When the mouse leaves our mesh, we set
    the `opacity` state value back and set the `isRotation` flag to `false` again.
    Finally, when we click on the mesh, we change the color to `yellow`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `color` and `opacity` state values can be directly used in `meshStandardMaterial`
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the opacity and color will automatically update whenever we fire the relevant
    events. For the rotation, we want to use the Three.js render loop. For this, React
    Three Fiber provides an additional hook:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '`useFrame` is called whenever we have a render loop in Three.js. In this case,
    we check the `isRotating` state, and if we should be rotating, we use the previously
    defined `useRef` reference to get access to the underlying Three.js component
    and simply increase its rotation. This is all very easy and convenient. The result
    in the browser looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.8 – A scene using React and React Three Fiber effects](img/Figure_14.8_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.8 – A scene using React and React Three Fiber effects
  prefs: []
  type: TYPE_NORMAL
- en: React Three Fiber and the `drei` library provide pretty much all the functionality
    you also have in the normal Three.js library (and some features that aren’t available
    as well). If you’re working with React and need Three.js integrated, this is a
    great way to use Three.js. Even when you are not necessarily building a React
    application, the declarative way of defining your scene, the components, and the
    interactions offered by React Three Fiber is very intuitive. React Three Fiber
    provides a great alternative for any Three.js visualization you want to create.
  prefs: []
  type: TYPE_NORMAL
- en: In the next two sections, we’ll look at how you can extend your 3D scenes with
    AR and VR capabilities. We’ll start by looking at how to enable VR in your scenes.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js and VR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we look at the required code changes, we’ll add an extension to the
    browser with which we can simulate a VR headset and VR controls. That way, you
    can test your scenes without the need for a physical headset and physical controllers.
    For this, we’ll install the WebXR API simulator This plugin is available for both
    Firefox and Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Firefox plugin**: Download and install it from here: [https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/](https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: '**Chrome plugin**: Download and install it from here: [https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje](https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow the instructions for your specific browser. After you’ve installed it,
    we can test it with this example: [https://immersive-web.github.io/webxr-samples/immersive-vr-session.html](https://immersive-web.github.io/webxr-samples/immersive-vr-session.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open this example, open your developer console, and click on the **WebXR**
    tab. Now, you’ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.9 – Firefox browser with the WebXR API extension](img/Figure_14.9_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.9 – Firefox browser with the WebXR API extension
  prefs: []
  type: TYPE_NORMAL
- en: 'In the extension, you’ll see a virtual headset and some virtual VR controls.
    By clicking on the headset, you can simulate the movement of a real VR headset;
    the same applies to the controls. If you click the **Enter VR** button, you can
    now simply test your VR scenes, without an actual VR headset:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.10 – Simulating a VR headset](img/Figure_14.10_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.10 – Simulating a VR headset
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve got a (virtual) headset to play around with, let’s convert one
    of our previous scenes into a VR scene, where we can track head movement and add
    functionality to some dummy VR controls. For this, we’ve created a copy of the
    “First Person Controls” example from [*Chapter 8*](B18726_08.xhtml#_idTextAnchor132),
    *Creating and Loading Advanced Meshes and Geometries*. You can open this example
    by opening up the `vr.html` example from the `chapter-14` sources:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.11 – Empty VR scene based on example from Chapter 9](img/Figure_14.11_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.11 – Empty VR scene based on example from [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148)
  prefs: []
  type: TYPE_NORMAL
- en: 'To get your scene VR ready, we need to take a couple of steps. The first thing
    we need to do is tell Three.js that we’ll be enabling the Web-XR functionality.
    This can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to add a simple button that we can click to enter VR mode.
    Three.js provides a component out of the box for this, which we can use like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This will create the button you can see at the bottom of the screen in *Figure
    14**.11*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to update our render loop. As you may recall from [*Chapter
    1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D Scene With Three.js*,
    we use `requestAnimationFrame` to control our render loop. When working with VR,
    we need to change this slightly, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used `renderer.setAnimationLoop` instead of `requestAnimationFrame`.
    At this point, our scene has been converted into VR, and once we click the button,
    we enter VR mode and can look around our scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.12 – Entering VR mode and rotating the camera using the browser
    extension](img/Figure_14.12_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.12 – Entering VR mode and rotating the camera using the browser extension
  prefs: []
  type: TYPE_NORMAL
- en: The previous screenshot is shown when you enter VR. You can now easily move
    the camera around by clicking on the VR device in the Web-XR extension and move
    it around. These steps are pretty much all you need to do to convert any Three.js
    scene into a VR scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look closely at *Figure 14**.12*, you might notice that we also show
    some handheld VR devices. We haven’t shown how you can add these yet. For this,
    Three.js also comes with some nice helper components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding code, we ask Three.js to get information about the attached
    controllers, create a model, and add them to the scene. If you use the WebXR API
    emulator, you can move the controls around and they’ll move around on the scene
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Three.js provides lots of examples of how you can use these controls to drag
    objects around, select objects in the scene, and otherwise add interactivity with
    the controls. For this simple example, we’ve added the option to add a cube at
    the position of the first control (the one on the right) whenever you click the
    `select` button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.13 – Adding cubes to the scene in VR](img/Figure_14.13_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.13 – Adding cubes to the scene in VR
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by simply adding event listeners to the controller, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this simple piece of code, you can see that we’ve added two event listeners
    to the controller. When the `selectstart` event is triggered, we add a new cube
    to the location of this controller. And when the `selectend` event is triggered,
    we just log some information to the console. Several other events can be accessed
    through JavaScript. For more information about the APIs that are available when
    you are in a VR session, you can look at the following documentation: [https://developer.mozilla.org/en-US/docs/Web/API/XRSession](https://developer.mozilla.org/en-US/docs/Web/API/XRSession'
  prefs: []
  type: TYPE_NORMAL
- en: )
  prefs: []
  type: TYPE_NORMAL
- en: For the last section, we’ll have a quick look at how you can combine Three.js
    with AR.
  prefs: []
  type: TYPE_NORMAL
- en: Three.js and AR
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While VR using Three.js is well supported on a large range of devices and browsers,
    this isn’t the case for Web-AR. On Android, the support is pretty good, but on
    iOS devices, it doesn’t work that well. Apple is currently working on adding this
    to Safari, so once that’s in, native AR should also work on iOS. A good way to
    check which browsers support this functionality is to check [https://caniuse.com/webxr](https://caniuse.com/webxr),
    which provides an up-to-date overview of all major browser support.
  prefs: []
  type: TYPE_NORMAL
- en: So, to test the native AR example, you either need to view it on an Android
    device, or use the same simulator we used in the *Three.js and* *VR* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a standard scene you can use as a starting point for your AR experiments.
    The first thing we need to do is tell Three.js we want to use XR:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Note that we need to set the `alpha` property to `true`; otherwise, we won’t
    see any passthrough from the camera. Next, just like we did for VR, we need to
    enable AR/VR on the renderer, by calling `rendered.xr.enabled`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To enter AR mode, Three.js also provides a button we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we just need to change `requestAnimationFrame` to `setAnimationLoop`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'And that’s all there is to it. If you open the `ar.html` example and view this
    example through the WebXR plugin (where you need to select the `Samsung Galaxy
    S8+ (AR)` device), you’ll see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 14.14 – Viewing an AR scene in Three.js using a device’s native AR
    functionality](img/Figure_14.14_B18726.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 14.14 – Viewing an AR scene in Three.js using a device’s native AR functionality
  prefs: []
  type: TYPE_NORMAL
- en: In this screenshot, you can see a simulated AR environment, where we can see
    the two objects that we’ve rendered. If you move the simulated phone around, you’ll
    notice that the rendered objects are fixed in their location relative to the position
    of the camera of the phone.
  prefs: []
  type: TYPE_NORMAL
- en: 'The example here is very simple but it shows the basics of how to set up a
    minimal AR scene. Web-XR offers a lot of other functionality related to AR, such
    as detecting planes and hit testing. However, covering that falls a bit outside
    of the scope of this book. For more information on Web-XR and the native AR functionality
    exposed by this API, you can look at the specifications here: [https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals](https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals).'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at a couple of technologies related to Three.js.
    We showed you different ways of integrating Three.js with TypeScript and React,
    and we also showed you how to create some basic AR and VR scenes.
  prefs: []
  type: TYPE_NORMAL
- en: By using the Three.js TypeScript bindings, you can easily access all the Three.js
    functionality from your TypeScript project. And integrating Three.js with React
    is made easy through the React Three Fiber library.
  prefs: []
  type: TYPE_NORMAL
- en: Using VR and AR in Three.js is also very straightforward. By just adding a couple
    of properties to the main renderer, you can quickly convert any scene into a VR
    or AR scene. Remember to use the browser plugin to easily test your scenes without
    needing actual VR and AR devices.
  prefs: []
  type: TYPE_NORMAL
- en: With that, we’ve come to the end of this book. I hope you’ve enjoyed reading
    it and playing around with the examples. Happy experimenting!
  prefs: []
  type: TYPE_NORMAL
