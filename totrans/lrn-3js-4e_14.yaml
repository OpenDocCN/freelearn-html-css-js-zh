- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Three.js Together with React, TypeScript, and Web-XR
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Three.js 与 React、TypeScript 和 Web-XR 一起使用
- en: In this final chapter, we’ll dive into two additional topics. First, we’ll look
    at how you can combine Three.js with TypeScript and React. The second part of
    this chapter will show some examples of how you can integrate your 3D scenes with
    Web-XR. With Web-XR, you can enhance your scenes to work with VR and AR technologies.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后，我们将深入探讨两个额外的主题。首先，我们将探讨如何将Three.js与TypeScript和React结合使用。本章的第二部分将展示一些示例，说明您如何将3D场景与Web-XR集成。使用Web-XR，您可以增强场景以与VR和AR技术一起工作。
- en: 'More specifically, we’ll show you the following examples:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，我们将向您展示以下示例：
- en: '**Using Three.js with TypeScript**: For the first example, we’ll show you how
    you can create a simple project that combines Three.js and TypeScript. We’ll create
    a very simple application, much like the samples we’ve already seen in the previous
    chapters, and show you how you can use TypeScript with Three.js to create your
    scenes.'
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用TypeScript与Three.js**：对于第一个示例，我们将向您展示如何创建一个结合了Three.js和TypeScript的简单项目。我们将创建一个非常简单的应用程序，类似于我们在前几章中已经看到的示例，并展示您如何使用TypeScript与Three.js一起创建场景。'
- en: '**Using Three.js and React with TypeScript**: React is a very popular framework
    for web development and is often used together with TypeScript. For this section,
    we’ll create a simple Three.js project, which uses React.js together with TypeScript.'
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用TypeScript和React与Three.js**：React是一个非常流行的Web开发框架，通常与TypeScript一起使用。在本节中，我们将创建一个简单的Three.js项目，该项目使用React.js和TypeScript。'
- en: '`React-three-fiber`. With this library, we can configure Three.js declaratively
    using a set of React components. This library provides great integration between
    React and Three.js and makes working with Three.js in a React application straightforward.'
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`React-three-fiber`。使用这个库，我们可以使用一组React组件声明性地配置Three.js。这个库提供了React和Three.js之间出色的集成，使得在React应用程序中使用Three.js变得简单直接。'
- en: '**Three.js and VR**: This section will show you how you can view your 3D scene
    in VR.'
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Three.js 和 VR**：本节将向您展示如何以VR方式查看您的3D场景。'
- en: '**Three.js and AR**: This section will explain how you can create a simple
    3D scene where you can add Three.js meshes.'
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Three.js 和 AR**：本节将解释如何创建一个简单的3D场景，您可以在其中添加Three.js网格。'
- en: Let’s start with the first example of this chapter and integrate Three.js with
    TypeScript.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本章的第一个示例开始，将Three.js与TypeScript集成。
- en: Using Three.js with TypeScript
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript与Three.js
- en: TypeScript provides a typed language that transpiles to JavaScript. This means
    that you can use it to create your site, and it’ll run just like normal JavaScript
    in the browser. There are many different ways of setting up a TypeScript project,
    but the easiest one is provided by Vite ([https://vitejs.dev/](https://vitejs.dev/)).
    Vite provides an integrated build environment and can be seen a bit as an alternative
    to webpack (which we use for the normal chapter samples).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript提供了一种类型化的语言，它可以编译成JavaScript。这意味着您可以使用它来创建您的网站，并且它在浏览器中运行得就像正常的JavaScript一样。设置TypeScript项目有许多不同的方法，但最简单的方法是由Vite提供（[https://vitejs.dev/](https://vitejs.dev/)）。Vite提供了一个集成的构建环境，可以看作是webpack（我们用于正常章节示例）的替代品。
- en: 'The first thing we need to do is create a new Vite project. You can do these
    steps yourself, or you can look in the `three-ts` folder and just run `yarn install`
    there to skip this setup. To get an empty TypeScript project with Vite, all we
    have to do is run the following code in the console:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个新的Vite项目。您可以自己执行这些步骤，或者您可以直接在`three-ts`文件夹中运行 `yarn install`
    以跳过此设置。要获取一个空的TypeScript项目，我们只需在控制台中运行以下代码：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next change into the directory (`three-ts`) and run `yarn install`.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，切换到目录（`three-ts`）并运行 `yarn install`。
- en: '[PRE1]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: At this point, we’ve got an empty Vite project, which you can start by running
    `yarn vite`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个空的Vite项目，您可以通过运行 `yarn vite` 来启动它。
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you point your browser to `http://127.0.0.1:5173/`, you’ll see the start
    page of Vite, and you’ll have a configured TypeScript project in place:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将浏览器指向 `http://127.0.0.1:5173/`，您将看到Vite的起始页面，并且您将有一个配置好的TypeScript项目：
- en: '![Figure 14.1 – Empty TypeScript project with Vite](img/Figure_14.1_B18726.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图14.1 – 使用Vite的空TypeScript项目](img/Figure_14.1_B18726.jpg)'
- en: Figure 14.1 – Empty TypeScript project with Vite
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1 – 使用Vite的空TypeScript项目
- en: 'Next, we must add the Three.js libraries, after which we can add some TypeScript
    to initialize Three.js. To add Three.js, we need to add the following two node
    modules:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须添加Three.js库，之后我们可以添加一些TypeScript代码来初始化Three.js。要添加Three.js，我们需要添加以下两个node模块：
- en: '[PRE3]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The first one adds the Three.js library, while the second one adds the `types`
    descriptions for the Three.js library. These `types` are used in the editor to
    get some nice code completion when working with Three.js and TypeScript in your
    IDE (for example, in Visual Studio Code). At this point, we’re ready to add Three.js
    to this project and start developing Three.js applications using TypeScript. To
    add TypeScript, the first thing we need to do is take a quick look at how the
    application is initialized. For this, you can look at the `public.html` file,
    which looks like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个添加了Three.js库，而第二个添加了Three.js库的`types`描述。这些`types`在编辑器中使用，以便在IDE（例如Visual
    Studio Code）中与Three.js和TypeScript一起工作时获得一些不错的代码补全。到目前为止，我们已经准备好将Three.js添加到这个项目中，并开始使用TypeScript开发Three.js应用程序。要添加TypeScript，我们首先需要快速查看应用程序是如何初始化的。为此，你可以查看`public.html`文件，它看起来像这样：
- en: '[PRE4]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In the preceding code, as you can see in the last `script` line, this HTML
    page loads the `src/main/ts` file. Open this file and change its content to this:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，正如你在最后的`script`行中可以看到的，这个HTML页面加载了`src/main/ts`文件。打开此文件并将其内容更改为以下内容：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The code here will try to find the main `#app` node. And if it finds the node,
    it’ll pass that node to the `initThreeJsScene` function, which is defined in the
    `threeCanvas.ts` file. This file contains the code to initialize the Three.js
    scene:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这里编写的代码将尝试找到主要的`#app`节点。如果找到该节点，它将把该节点传递给定义在`threeCanvas.ts`文件中的`initThreeJsScene`函数。此文件包含初始化Three.js场景的代码：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will look familiar to the code from the first couple of chapters where
    we created an initial simple scene. The main change is that, here, we can use
    all the features provided by TypeScript. Vite will handle the transpiling to JavaScript,
    so you don’t need to do anything else to see the results of this in your browser:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 这将看起来与我们在前几章中创建的初始简单场景的代码相似。主要的变化是，在这里，我们可以使用TypeScript提供的所有功能。Vite将处理将JavaScript进行转换，因此你不需要做任何事情就可以在浏览器中看到结果：
- en: '![Figure 14.2 – Simple TypeScript project with Three.js](img/Figure_14.2_B18726.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图14.2 – 带有Three.js的简单TypeScript项目](img/Figure_14.2_B18726.jpg)'
- en: Figure 14.2 – Simple TypeScript project with Three.js
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.2 – 带有Three.js的简单TypeScript项目
- en: Now that we’ve introduced Three.js and TypeScript, let’s go a step further and
    see how we can integrate this with React as well.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了Three.js和TypeScript，让我们更进一步，看看我们如何将它们与React集成。
- en: Using Three.js and React with TypeScript
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用TypeScript和React与Three.js
- en: 'There are different ways of creating a React application from scratch (Vite,
    for instance, also supports this), but the most common way is to use the `yarn
    create react-app lts-tf --template TypeScript` command from the command line.
    Just like with Vite, this will create a new project. For this example, we’ve created
    this project in the `lts-tf` directory. Once created, we have to add the Three.js
    libraries just like we did for Vite:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 从零开始创建React应用程序有不同的方法（例如，Vite也支持这一点），但最常见的方法是使用命令行中的`yarn create react-app lts-tf
    --template TypeScript`命令。就像Vite一样，这将创建一个新的项目。对于这个例子，我们在`lts-tf`目录中创建了此项目。一旦创建，我们必须像为Vite做的那样添加Three.js库：
- en: '[PRE7]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This should set up a simple react TypeScript application, add the correct Three.js
    libraries, and install all the other required modules. The next step is to quickly
    check if all this works. Run the `yarn` `start` command:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该设置一个简单的React TypeScript应用程序，添加正确的Three.js库，并安装所有其他必需的模块。下一步是快速检查这一切是否正常工作。运行`yarn
    start`命令：
- en: '[PRE8]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Open your browser to `http://localhost:3000` and you’ll see a simple React
    startup screen:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 打开你的浏览器到`http://localhost:3000`，你会看到一个简单的React启动屏幕：
- en: '![Figure 14.3 – Simple TypeScript project with Three.js](img/Figure_14.3_B18726.jpg)'
  id: totrans-39
  prefs: []
  type: TYPE_IMG
  zh: '![图14.3 – 带有Three.js的简单TypeScript项目](img/Figure_14.3_B18726.jpg)'
- en: Figure 14.3 – Simple TypeScript project with Three.js
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.3 – 带有Three.js的简单TypeScript项目
- en: 'On this screen, we can see that we need to edit the `app.tsx` file, so we’ll
    update this similar to the plain TypeScript example we saw in the *Using Three.js
    with TypeScript* section, but this time as a React component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕上，我们可以看到我们需要编辑`app.tsx`文件，所以我们将更新它，类似于我们在*使用TypeScript与Three.js*部分看到的纯TypeScript示例，但这次作为一个React组件：
- en: '[PRE9]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'As you can see, here, we defined a custom component named `ThreeCanvas`, which
    is now loaded as soon as the application starts. The Three.js initialization code
    is provided by the `ThreeCanvas` element, which you can find in the `ThreeCanvas.tsx`
    file. This file, for the most part, is similar to the `initThreeJsScene` function
    we described in the *Using Three.js with TypeScript* section, but we’ll include
    the whole file here for completeness:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里我们定义了一个名为 `ThreeCanvas` 的自定义组件，现在它在应用程序启动时立即加载。Three.js 初始化代码由 `ThreeCanvas`
    元素提供，您可以在 `ThreeCanvas.tsx` 文件中找到它。这个文件的大部分内容与我们在 *使用 TypeScript 的 Three.js* 部分中描述的
    `initThreeJsScene` 函数类似，但为了完整性，我们将在这里包含整个文件：
- en: '[PRE10]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In `initThreeJsScene`, you can find the standard code to initialize a simple
    Three.js scene using TypeScript. To connect this Three.js scene to React, we can
    use the code from the `ThreeCanvas` functional React component. What we want to
    do here is initialize the Three.js scene at the moment the `div` element gets
    attached to its parent node. To do this, we can use the `useCallback` function.
    This function will be called once when this node gets attached to its parent,
    and won’t rerun even if one of the parent properties changes. In our case, we
    will also add another `isInitialized` state to make sure that even if we have
    the development server reload parts of the application, we only initialize our
    Three.js scene once.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `initThreeJsScene` 中，您可以找到使用 TypeScript 初始化简单 Three.js 场景的标准代码。为了将这个 Three.js
    场景连接到 React，我们可以使用来自 `ThreeCanvas` 功能 React 组件的代码。我们在这里想要做的是在 `div` 元素附加到其父节点时初始化
    Three.js 场景。为此，我们可以使用 `useCallback` 函数。这个函数将在节点第一次附加到父节点时被调用，即使父节点的一个属性发生变化，它也不会重新运行。在我们的情况下，我们还将添加另一个
    `isInitialized` 状态，以确保即使在开发服务器重新加载应用程序的部分时，我们也只初始化我们的 Three.js 场景一次。
- en: useRef or useCallback
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: useRef 或 useCallback
- en: You might be tempted to use `useRef` here. There is a good explanation at https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node
    regarding why, in this case, you should use `useCallback` instead of `useRef`
    to avoid unnecessary rerenderings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会想在这里使用 `useRef`。在 https://reactjs.org/docs/hooks-faq.html#how-can-i-measure-a-dom-node
    有一个很好的解释，说明了为什么在这种情况下，你应该使用 `useCallback` 而不是 `useRef` 来避免不必要的重新渲染。
- en: 'With the preceding setup in place, we can now see the result:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的设置完成后，我们现在可以看到结果：
- en: '![Figure 14.4 – Three.js with TypeScript and React](img/Figure_14.4_B18726.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图 14.4 – 使用 TypeScript 和 React 的 Three.js](img/Figure_14.4_B18726.jpg)'
- en: Figure 14.4 – Three.js with TypeScript and React
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.4 – 使用 TypeScript 和 React 的 Three.js
- en: 'In the previous example, we created a simple integration between React and
    Three.js. While this works, it feels a bit strange to programmatically describe
    a Three.js scene, since normally, in React, applications are declared declaratively
    using components. We can wrap the existing Three.js components as we did with
    the `ThreeCanvas` component, but this will quickly get complex. Luckily, though,
    all the hard work for this has already been done by the Three.js fibers project:
    `https://docs.pmnd.rs/react-three-fiber/getting-started/introduction`. In the
    next section, we’ll look at how easily Three.js and React can be integrated with
    the help of this project.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们创建了一个简单的 React 和 Three.js 之间的集成。虽然这可行，但用程序描述 Three.js 场景感觉有点奇怪，因为在
    React 中，通常使用组件声明性地声明应用程序。我们可以像处理 `ThreeCanvas` 组件那样包装现有的 Three.js 组件，但这会很快变得复杂。幸运的是，不过，Three.js
    fibers 项目已经为我们完成了所有这些艰苦的工作：`https://docs.pmnd.rs/react-three-fiber/getting-started/introduction`。在下一节中，我们将探讨如何借助这个项目轻松地将
    Three.js 和 React 集成在一起。
- en: Using Three.js and React with React Three Fiber
  id: totrans-52
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 React Three Fiber 与 Three.js 和 React 集成
- en: In the previous examples, we set up the integration between React and Three.js
    ourselves. While it works, that approach doesn’t tightly integrate with how React
    works. For a good integration between these frameworks, we can use React Three
    Fiber. We’ll start again by setting up a project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们自行设置了 React 和 Three.js 之间的集成。虽然这可行，但这种方法并没有紧密地与 React 的工作方式集成。为了这些框架之间良好的集成，我们可以使用
    React Three Fiber。我们将再次从设置项目开始。
- en: 'For this, run the following commands:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，请运行以下命令：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will install all the dependencies we need and set up a new React project.
    To start this project in the `lts-r3f` directory, run `yarn start`, which will
    start a server. Open the URL you see on the screen (`http://localhost:3000`);
    you’ll see the following screen, which we’ve seen before and shows an empty React
    project:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这将安装我们需要的所有依赖项并设置一个新的React项目。要启动`lts-r3f`目录中的此项目，运行`yarn start`，这将启动一个服务器。打开屏幕上显示的URL（`http://localhost:3000`）；你会看到以下屏幕，这是我们之前看到的，显示了一个空的React项目：
- en: '![Figure 14.5 – Starting up a simple JavaScript React application](img/Figure_14.5_B18726.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图14.5 – 启动一个简单的JavaScript React应用程序](img/Figure_14.5_B18726.jpg)'
- en: Figure 14.5 – Starting up a simple JavaScript React application
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5 – 启动一个简单的JavaScript React应用程序
- en: 'As the screen starts to extend this example, we need to edit the `app.jsx`
    file. We’ll create a new component that will contain our Three.js scene:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当屏幕开始扩展这个示例时，我们需要编辑`app.jsx`文件。我们将创建一个新的组件，该组件将包含我们的Three.js场景：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, we can already see the first of the Three Fiber components – the `Canvas`
    element. The `Canvas` element creates a `Canvas` div and is the parent container
    for all the other Three.js components provided by this library. Since we added
    `Scene` as a child to this `Canvas` component, we can define our complete Three.js
    scene in our custom component. Next, we’ll create this `Scene` component:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们已经可以看到Three Fiber组件中的第一个——`Canvas`元素。`Canvas`元素创建一个`Canvas` div，并且是所有由这个库提供的其他Three.js组件的父容器。由于我们将`Scene`作为子组件添加到这个`Canvas`组件中，我们可以在我们的自定义组件中定义完整的Three.js场景。接下来，我们将创建这个`Scene`组件：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'What we’ve got here is a very simple Three.js scene, which looks similar to
    the ones we saw earlier in this book. This scene contains the following objects:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们这里有一个非常简单的Three.js场景，它看起来与我们在本书中之前看到的类似。这个场景包含以下对象：
- en: '`<ambientLight>`: An instance of a `Three.AmbientLight` object.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<ambientLight>`：一个`Three.AmbientLight`对象的实例。'
- en: '`<directionalLight>`: An instance of a `Three.DirectionalLight` object.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<directionalLight>`：一个`Three.DirectionalLight`对象的实例。'
- en: '`<mesh>`: This represents a `Three.Mesh`. As we know, a `Three.Mesh` contains
    a geometry and a material, which are defined as children of this element. In this
    example, we’ve set the rotation on this mesh as well.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<mesh>`：这代表一个`Three.Mesh`。正如我们所知，一个`Three.Mesh`包含一个几何体和一个材质，这些作为此元素的子元素定义。在这个示例中，我们还设置了此网格的旋转。'
- en: '`<boxGeometry>`: This is similar to `Three.BoxGeometry`, where we pass in the
    constructor arguments through the `args` property.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<boxGeometry>`：这与`Three.BoxGeometry`类似，我们通过`args`属性传递构造函数参数。'
- en: '`<meshStandardMaterial>`: This creates an instance of a `THREE.MeshStandardMaterial`,
    and configures some properties on this material.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<meshStandardMaterial>`：这创建了一个`THREE.MeshStandardMaterial`的实例，并在这个材质上配置了一些属性。'
- en: 'Now, when you open your browser to `localhost:3000`, you’ll see a Three.js
    scene:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你打开浏览器到`localhost:3000`时，你会看到一个Three.js场景：
- en: '![Figure 14.6 – Three.js scene rendered using React Three Fiber](img/Figure_14.6_B18726.jpg)'
  id: totrans-70
  prefs: []
  type: TYPE_IMG
  zh: '![图14.6 – 使用React Three Fiber渲染的Three.js场景](img/Figure_14.6_B18726.jpg)'
- en: Figure 14.6 – Three.js scene rendered using React Three Fiber
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.6 – 使用React Three Fiber渲染的Three.js场景
- en: In this example, we’ve only shown a couple of small elements provided by React
    Three Fiber. All objects provided by Three.js can be configured in the way we
    just showed. Just add them as elements, configure them, and they will be shown
    on the screen. Besides easily showing these elements, all these elements behave
    like normal React components. So, whenever the properties of a parent element
    change, all the elements are rerendered (or updated) as well.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们只展示了React Three Fiber提供的一些小元素。所有由Three.js提供的对象都可以按照我们刚刚展示的方式进行配置。只需将它们作为元素添加，配置它们，它们就会在屏幕上显示。除了轻松显示这些元素之外，所有这些元素都表现得像正常的React组件。因此，每当父元素的属性发生变化时，所有元素都会重新渲染（或更新）。
- en: 'Besides the elements provided by React Three Fiber, there are a whole set of
    additional components provided by `@react-three/drei`. You can find those components
    and their descriptions at [https://github.com/pmndrs/drei](https://github.com/pmndrs/drei):'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 除了React Three Fiber提供的元素之外，还有一整套由`@react-three/drei`提供的附加组件。你可以在[https://github.com/pmndrs/drei](https://github.com/pmndrs/drei)找到这些组件及其描述：
- en: '![Figure 14.7 – Additional components from @react-three/drei](img/Figure_14.7_B18726.jpg)'
  id: totrans-74
  prefs: []
  type: TYPE_IMG
  zh: '![图14.7 – 来自@react-three/drei的附加组件](img/Figure_14.7_B18726.jpg)'
- en: Figure 14.7 – Additional components from @react-three/drei
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.7 – 来自@react-three/drei的附加组件
- en: 'For the next example, we’re going to use a couple of the components provided
    by this library, so we need to add this to our project:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于下一个示例，我们将使用这个库提供的一些组件，因此我们需要将以下内容添加到我们的项目中：
- en: '[PRE14]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, we’ll extend our example to this:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将扩展我们的示例到这一点：
- en: '[PRE15]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Let’s explore the code a bit before looking at the result in the browser. First,
    we’ll look at the new elements we added to the component:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看浏览器中的结果之前，让我们先探索一下代码。首先，我们将查看我们添加到组件中的新元素：
- en: '`<OrbitControls>`: This is provided by the `drei` library. This adds an `THREE.OrbitControls`
    element to the scene. This is the same as `OrbitControls`, which we used in the
    earlier chapters. As you can see here, just adding the element is enough; no additional
    configuration is needed.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<OrbitControls>`：这是由`drei`库提供的。这将在场景中添加一个`THREE.OrbitControls`元素。这与我们在早期章节中使用的`OrbitControls`相同。正如你所看到的，只需添加元素就足够了；不需要额外的配置。'
- en: '`<Sky>`: This element provides a nice sky background to the scene.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`<Sky>`：此元素为场景提供了一个漂亮的背景天空。'
- en: 'We’ve also added several standard React Hooks:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还添加了几个标准的React Hooks：
- en: '[PRE16]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we define a `Ref`, which we connect to the mesh (`<mesh ref={mesh}) ..>`).
    We use this so that we can access the Three.js component later on in the render
    loop. We also use `useState` three times to keep track of the `color` and `opacity`
    state values of the material, as well as to see whether the `mesh` property is
    rotating or not. The first of these two Hooks is used in the events we defined
    on the mesh:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`Ref`，我们将其连接到网格（`<mesh ref={mesh}) ..>`）。我们使用这个`Ref`是为了在渲染循环中稍后访问Three.js组件。我们还使用了三次`useState`来跟踪材质的`color`和`opacity`状态值，以及查看`mesh`属性是否正在旋转。这两个Hooks中的第一个用于我们在网格上定义的事件：
- en: '[PRE17]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: With these event handlers, we can very easily integrate the mouse with the mesh.
    There’s no need for `RayCaster` objects – just add the event listener and you’re
    done. In this case, when the mouse pointer enters our mesh, we change the `opacity`
    state value and the `isRotation` flag. When the mouse leaves our mesh, we set
    the `opacity` state value back and set the `isRotation` flag to `false` again.
    Finally, when we click on the mesh, we change the color to `yellow`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些事件处理器，我们可以非常容易地将鼠标与网格集成。不需要`RayCaster`对象——只需添加事件监听器即可完成。在这种情况下，当鼠标指针进入我们的网格时，我们改变`opacity`状态值和`isRotation`标志。当鼠标离开我们的网格时，我们将`opacity`状态值恢复，并将`isRotation`标志再次设置为`false`。最后，当我们点击网格时，我们将颜色更改为`黄色`。
- en: 'The `color` and `opacity` state values can be directly used in `meshStandardMaterial`
    like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`color`和`opacity`状态值可以直接在`meshStandardMaterial`中使用，如下所示：'
- en: '[PRE18]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, the opacity and color will automatically update whenever we fire the relevant
    events. For the rotation, we want to use the Three.js render loop. For this, React
    Three Fiber provides an additional hook:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当触发相关事件时，透明度和颜色将自动更新。对于旋转，我们想使用Three.js渲染循环。为此，React Three Fiber提供了一个额外的钩子：
- en: '[PRE19]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`useFrame` is called whenever we have a render loop in Three.js. In this case,
    we check the `isRotating` state, and if we should be rotating, we use the previously
    defined `useRef` reference to get access to the underlying Three.js component
    and simply increase its rotation. This is all very easy and convenient. The result
    in the browser looks like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`useFrame`在Three.js中每次有渲染循环时都会被调用。在这种情况下，我们检查`isRotating`状态，如果我们应该旋转，我们使用之前定义的`useRef`引用来获取对底层Three.js组件的访问权限，并简单地增加其旋转。这一切都非常简单方便。浏览器中的结果如下所示：'
- en: '![Figure 14.8 – A scene using React and React Three Fiber effects](img/Figure_14.8_B18726.jpg)'
  id: totrans-93
  prefs: []
  type: TYPE_IMG
  zh: '![图14.8 – 使用React和React Three Fiber效果的场景](img/Figure_14.8_B18726.jpg)'
- en: Figure 14.8 – A scene using React and React Three Fiber effects
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.8 – 使用React和React Three Fiber效果的场景
- en: React Three Fiber and the `drei` library provide pretty much all the functionality
    you also have in the normal Three.js library (and some features that aren’t available
    as well). If you’re working with React and need Three.js integrated, this is a
    great way to use Three.js. Even when you are not necessarily building a React
    application, the declarative way of defining your scene, the components, and the
    interactions offered by React Three Fiber is very intuitive. React Three Fiber
    provides a great alternative for any Three.js visualization you want to create.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: React Three Fiber和`drei`库几乎提供了你在正常Three.js库中拥有的所有功能（以及一些不可用的功能）。如果你使用React并且需要集成Three.js，这是使用Three.js的一个很好的方法。即使你并不一定在构建React应用程序，React
    Three Fiber提供的声明式定义场景、组件和交互的方式也非常直观。React Three Fiber为任何你想要创建的Three.js可视化提供了一个很好的替代方案。
- en: In the next two sections, we’ll look at how you can extend your 3D scenes with
    AR and VR capabilities. We’ll start by looking at how to enable VR in your scenes.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的两节中，我们将探讨如何通过AR和VR功能扩展您的3D场景。我们将首先查看如何在场景中启用VR。
- en: Three.js and VR
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Three.js和VR
- en: 'Before we look at the required code changes, we’ll add an extension to the
    browser with which we can simulate a VR headset and VR controls. That way, you
    can test your scenes without the need for a physical headset and physical controllers.
    For this, we’ll install the WebXR API simulator This plugin is available for both
    Firefox and Chrome:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们查看所需的代码更改之前，我们将向浏览器添加一个扩展，以便我们可以模拟VR头戴式设备和VR控制。这样，您可以在不需要物理头戴式设备和物理控制器的情况下测试您的场景。为此，我们将安装WebXR
    API模拟器。此插件适用于Firefox和Chrome：
- en: '**Firefox plugin**: Download and install it from here: [https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/](https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Firefox插件**：从这里下载并安装：[https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/](https://addons.mozilla.org/en-US/firefox/addon/webxr-api-emulator/)'
- en: )
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: '**Chrome plugin**: Download and install it from here: [https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje](https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Chrome插件**：从这里下载并安装：[https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje](https://chrome.google.com/webstore/detail/webxr-api-emulator/mjddjgeghkdijejnciaefnkjmkafnnje)'
- en: )
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: 'Follow the instructions for your specific browser. After you’ve installed it,
    we can test it with this example: [https://immersive-web.github.io/webxr-samples/immersive-vr-session.html](https://immersive-web.github.io/webxr-samples/immersive-vr-session.html).'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 按照您特定浏览器的说明。安装后，我们可以使用此示例进行测试：[https://immersive-web.github.io/webxr-samples/immersive-vr-session.html](https://immersive-web.github.io/webxr-samples/immersive-vr-session.html)。
- en: 'Open this example, open your developer console, and click on the **WebXR**
    tab. Now, you’ll see something like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 打开此示例，打开您的开发者控制台，并点击**WebXR**标签。现在，您将看到如下内容：
- en: '![Figure 14.9 – Firefox browser with the WebXR API extension](img/Figure_14.9_B18726.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图14.9 – 带有WebXR API扩展的Firefox浏览器](img/Figure_14.9_B18726.jpg)'
- en: Figure 14.9 – Firefox browser with the WebXR API extension
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.9 – 带有WebXR API扩展的Firefox浏览器
- en: 'In the extension, you’ll see a virtual headset and some virtual VR controls.
    By clicking on the headset, you can simulate the movement of a real VR headset;
    the same applies to the controls. If you click the **Enter VR** button, you can
    now simply test your VR scenes, without an actual VR headset:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在扩展中，您将看到一个虚拟头戴式设备和一些虚拟VR控制。通过点击头戴式设备，您可以模拟真实VR头戴式设备的运动；同样适用于控制。如果您点击**进入VR**按钮，现在您可以简单地测试您的VR场景，而无需实际的VR头戴式设备：
- en: '![Figure 14.10 – Simulating a VR headset](img/Figure_14.10_B18726.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图14.10 – 模拟VR头戴式设备](img/Figure_14.10_B18726.jpg)'
- en: Figure 14.10 – Simulating a VR headset
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.10 – 模拟VR头戴式设备
- en: 'Now that we’ve got a (virtual) headset to play around with, let’s convert one
    of our previous scenes into a VR scene, where we can track head movement and add
    functionality to some dummy VR controls. For this, we’ve created a copy of the
    “First Person Controls” example from [*Chapter 8*](B18726_08.xhtml#_idTextAnchor132),
    *Creating and Loading Advanced Meshes and Geometries*. You can open this example
    by opening up the `vr.html` example from the `chapter-14` sources:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个（虚拟的）头戴式设备可以玩耍了，让我们将我们之前的一个场景转换成一个VR场景，在那里我们可以跟踪头部运动并为一些虚拟的VR控制添加功能。为此，我们创建了第8章“创建和加载高级网格和几何体”中“First
    Person Controls”示例的副本。您可以通过打开`chapter-14`源中的`vr.html`示例来打开此示例：
- en: '![Figure 14.11 – Empty VR scene based on example from Chapter 9](img/Figure_14.11_B18726.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图14.11 – 基于第9章示例的空VR场景](img/Figure_14.11_B18726.jpg)'
- en: Figure 14.11 – Empty VR scene based on example from [*Chapter 9*](B18726_09.xhtml#_idTextAnchor148)
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.11 – 基于第9章示例的空VR场景
- en: 'To get your scene VR ready, we need to take a couple of steps. The first thing
    we need to do is tell Three.js that we’ll be enabling the Web-XR functionality.
    This can be done like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使您的场景准备好VR，我们需要采取几个步骤。首先，我们需要告诉Three.js我们将启用Web-XR功能。这可以这样完成：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The next step is to add a simple button that we can click to enter VR mode.
    Three.js provides a component out of the box for this, which we can use like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加一个简单的按钮，我们可以点击它进入VR模式。Three.js为此提供了一个现成的组件，我们可以这样使用：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This will create the button you can see at the bottom of the screen in *Figure
    14**.11*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建出在图14.11底部可以看到的按钮。
- en: 'Finally, we need to update our render loop. As you may recall from [*Chapter
    1*](B18726_01.xhtml#_idTextAnchor014), *Creating Your First 3D Scene With Three.js*,
    we use `requestAnimationFrame` to control our render loop. When working with VR,
    we need to change this slightly, like so:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的渲染循环。如您从[*第一章*](B18726_01.xhtml#_idTextAnchor014)，“使用Three.js创建您的第一个3D场景”中可能记得，我们使用`requestAnimationFrame`来控制渲染循环。当与VR一起工作时，我们需要稍作改变，如下所示：
- en: '[PRE22]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Here, we used `renderer.setAnimationLoop` instead of `requestAnimationFrame`.
    At this point, our scene has been converted into VR, and once we click the button,
    we enter VR mode and can look around our scene:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了`renderer.setAnimationLoop`而不是`requestAnimationFrame`。此时，我们的场景已经转换为VR，一旦我们点击按钮，我们就进入VR模式并可以环顾我们的场景：
- en: '![Figure 14.12 – Entering VR mode and rotating the camera using the browser
    extension](img/Figure_14.12_B18726.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图14.12 – 使用浏览器扩展进入VR模式并旋转相机](img/Figure_14.12_B18726.jpg)'
- en: Figure 14.12 – Entering VR mode and rotating the camera using the browser extension
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.12 – 使用浏览器扩展进入VR模式并旋转相机
- en: The previous screenshot is shown when you enter VR. You can now easily move
    the camera around by clicking on the VR device in the Web-XR extension and move
    it around. These steps are pretty much all you need to do to convert any Three.js
    scene into a VR scene.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的截图是在您进入VR时显示的。现在，您可以通过在Web-XR扩展中的VR设备上点击并移动它来轻松地移动相机。这些步骤基本上就是将任何Three.js场景转换为VR场景所需的所有步骤。
- en: 'If you look closely at *Figure 14**.12*, you might notice that we also show
    some handheld VR devices. We haven’t shown how you can add these yet. For this,
    Three.js also comes with some nice helper components:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细观察*图14**.12*，您可能会注意到我们还展示了一些手持VR设备。我们还没有展示如何添加这些设备。为此，Three.js也提供了一些不错的辅助组件：
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: With the preceding code, we ask Three.js to get information about the attached
    controllers, create a model, and add them to the scene. If you use the WebXR API
    emulator, you can move the controls around and they’ll move around on the scene
    as well.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 通过前面的代码，我们要求Three.js获取有关附加控制器的信息，创建一个模型，并将它们添加到场景中。如果您使用WebXR API模拟器，您可以移动控件，它们也会在场景中移动。
- en: 'Three.js provides lots of examples of how you can use these controls to drag
    objects around, select objects in the scene, and otherwise add interactivity with
    the controls. For this simple example, we’ve added the option to add a cube at
    the position of the first control (the one on the right) whenever you click the
    `select` button:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: Three.js提供了大量示例，展示了您如何使用这些控件拖动对象、在场景中选择对象以及通过控件添加其他交互性。对于这个简单的示例，我们添加了在您点击`select`按钮时在第一个控制器的位置（右侧的那个）添加一个立方体的选项：
- en: '![Figure 14.13 – Adding cubes to the scene in VR](img/Figure_14.13_B18726.jpg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![图14.13 – 在VR场景中添加立方体](img/Figure_14.13_B18726.jpg)'
- en: Figure 14.13 – Adding cubes to the scene in VR
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.13 – 在VR场景中添加立方体
- en: 'We can do this by simply adding event listeners to the controller, like this:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过简单地给控制器添加事件监听器来实现这一点，如下所示：
- en: '[PRE24]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In this simple piece of code, you can see that we’ve added two event listeners
    to the controller. When the `selectstart` event is triggered, we add a new cube
    to the location of this controller. And when the `selectend` event is triggered,
    we just log some information to the console. Several other events can be accessed
    through JavaScript. For more information about the APIs that are available when
    you are in a VR session, you can look at the following documentation: [https://developer.mozilla.org/en-US/docs/Web/API/XRSession](https://developer.mozilla.org/en-US/docs/Web/API/XRSession'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在这段简单的代码中，您可以看到我们给控制器添加了两个事件监听器。当`selectstart`事件被触发时，我们在控制器的位置添加一个新的立方体。而当`selectend`事件被触发时，我们只是在控制台记录一些信息。通过JavaScript可以访问其他几个事件。有关在VR会话中可用的API的更多信息，您可以查看以下文档：[https://developer.mozilla.org/en-US/docs/Web/API/XRSession](https://developer.mozilla.org/en-US/docs/Web/API/XRSession)
- en: )
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: )
- en: For the last section, we’ll have a quick look at how you can combine Three.js
    with AR.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最后一部分，我们将快速浏览如何将Three.js与AR结合使用。
- en: Three.js and AR
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Three.js和AR
- en: While VR using Three.js is well supported on a large range of devices and browsers,
    this isn’t the case for Web-AR. On Android, the support is pretty good, but on
    iOS devices, it doesn’t work that well. Apple is currently working on adding this
    to Safari, so once that’s in, native AR should also work on iOS. A good way to
    check which browsers support this functionality is to check [https://caniuse.com/webxr](https://caniuse.com/webxr),
    which provides an up-to-date overview of all major browser support.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在许多设备和浏览器上，Three.js对VR的支持良好，但对于Web-AR来说并非如此。在Android设备上，支持相当不错，但在iOS设备上，效果并不理想。苹果公司目前正在努力将此功能添加到Safari中，因此一旦实现，原生AR也应该在iOS上工作。检查哪些浏览器支持此功能的一个好方法是查看[https://caniuse.com/webxr](https://caniuse.com/webxr)，它提供了所有主要浏览器支持的最新概述。
- en: So, to test the native AR example, you either need to view it on an Android
    device, or use the same simulator we used in the *Three.js and* *VR* section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，要测试原生AR示例，你需要在Android设备上查看，或者使用我们在*Three.js和* *VR* 部分使用的相同模拟器。
- en: 'Let’s create a standard scene you can use as a starting point for your AR experiments.
    The first thing we need to do is tell Three.js we want to use XR:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个标准场景，你可以将其用作AR实验的起点。我们首先需要做的是告诉Three.js我们想要使用XR：
- en: '[PRE25]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Note that we need to set the `alpha` property to `true`; otherwise, we won’t
    see any passthrough from the camera. Next, just like we did for VR, we need to
    enable AR/VR on the renderer, by calling `rendered.xr.enabled`.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们需要将`alpha`属性设置为`true`；否则，我们不会看到任何来自摄像头的透传。接下来，就像我们对VR所做的那样，我们需要通过调用`rendered.xr.enabled`在渲染器上启用AR/VR。
- en: 'To enter AR mode, Three.js also provides a button we can use:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 要进入AR模式，Three.js还提供了一个我们可以使用的按钮：
- en: '[PRE26]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we just need to change `requestAnimationFrame` to `setAnimationLoop`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们只需将`requestAnimationFrame`更改为`setAnimationLoop`：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'And that’s all there is to it. If you open the `ar.html` example and view this
    example through the WebXR plugin (where you need to select the `Samsung Galaxy
    S8+ (AR)` device), you’ll see something like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是全部内容。如果你打开`ar.html`示例并通过WebXR插件（需要选择`Samsung Galaxy S8+ (AR)`设备）查看此示例，你会看到类似这样的内容：
- en: '![Figure 14.14 – Viewing an AR scene in Three.js using a device’s native AR
    functionality](img/Figure_14.14_B18726.jpg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![图14.14 – 使用设备的原生AR功能在Three.js中查看AR场景](img/Figure_14.14_B18726.jpg)'
- en: Figure 14.14 – Viewing an AR scene in Three.js using a device’s native AR functionality
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.14 – 使用设备的原生AR功能在Three.js中查看AR场景
- en: In this screenshot, you can see a simulated AR environment, where we can see
    the two objects that we’ve rendered. If you move the simulated phone around, you’ll
    notice that the rendered objects are fixed in their location relative to the position
    of the camera of the phone.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在此屏幕截图中，你可以看到一个模拟的AR环境，我们可以看到我们渲染的两个对象。如果你移动模拟的手机，你会注意到渲染的对象相对于手机摄像头的位置是固定的。
- en: 'The example here is very simple but it shows the basics of how to set up a
    minimal AR scene. Web-XR offers a lot of other functionality related to AR, such
    as detecting planes and hit testing. However, covering that falls a bit outside
    of the scope of this book. For more information on Web-XR and the native AR functionality
    exposed by this API, you can look at the specifications here: [https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals](https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals).'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 此处的示例非常简单，但它展示了如何设置最小AR场景的基本方法。Web-XR提供了许多与AR相关的其他功能，例如检测平面和碰撞测试。然而，涵盖这些内容略超出了本书的范围。有关Web-XR和此API公开的原生AR功能的信息，你可以查看以下规范：[https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals](https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Fundamentals)。
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at a couple of technologies related to Three.js.
    We showed you different ways of integrating Three.js with TypeScript and React,
    and we also showed you how to create some basic AR and VR scenes.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了与Three.js相关的一些技术。我们向您展示了将Three.js与TypeScript和React集成的不同方法，我们还展示了如何创建一些基本的AR和VR场景。
- en: By using the Three.js TypeScript bindings, you can easily access all the Three.js
    functionality from your TypeScript project. And integrating Three.js with React
    is made easy through the React Three Fiber library.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用Three.js的TypeScript绑定，你可以轻松地从你的TypeScript项目中访问所有Three.js功能。通过React Three
    Fiber库，将Three.js与React集成也变得简单易行。
- en: Using VR and AR in Three.js is also very straightforward. By just adding a couple
    of properties to the main renderer, you can quickly convert any scene into a VR
    or AR scene. Remember to use the browser plugin to easily test your scenes without
    needing actual VR and AR devices.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在Three.js中使用VR和AR也非常简单。只需向主渲染器添加几个属性，您就可以快速将任何场景转换为VR或AR场景。记得使用浏览器插件来轻松测试您的场景，而无需实际VR和AR设备。
- en: With that, we’ve come to the end of this book. I hope you’ve enjoyed reading
    it and playing around with the examples. Happy experimenting!
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有了这些，我们就来到了这本书的结尾。希望您喜欢阅读它并尝试使用示例。祝您实验愉快！
