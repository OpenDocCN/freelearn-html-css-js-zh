["```js\nclass Queue {\n  constructor() {\n    this.handlers = [];\n  }\n  subscribe(handlerFn) {\n    this.handlers.push(handlerFn);\n  }\n  unsubscribe(handlerFn) {\n    this.handlers = this.handlers.filter((handler) =>\n      handler !== handlerFn);\n  }\n  notify(message) {\n    this.handlers.forEach((handler) => {\n      handler(message);\n    });\n  }\n}\n```", "```js\nconst queue = new Queue();\nconst createMessages = [];\nqueue.subscribe((message) => {\n  if (message.type === 'CREATE') {\n    createMessages.push(message);\n  }\n});\nconst updateMessages = [];\nqueue.subscribe((message) => {\n  if (message.type === 'UPDATE') {\n    updateMessages.push(message);\n  }\n});\nconst allMessages = [];\nqueue.subscribe((message) => {\n  allMessages.push(message);\n});\n```", "```js\nqueue.notify({ type: 'CREATE', data: { user: { id: 1 } }\n});\nqueue.notify({ type: 'CREATE', data: { user: { id: 2 } } });\nqueue.notify({ type: 'CREATE', data: { user: { id: 3 } } });\nqueue.notify({ type: 'UPDATE', data: { user: { id: 1, role:\n  'ADMIN' } } });\nqueue.notify({\n  type: 'UPDATE',\n  data: { user: { id: 3, role: 'DEVELOPER' } },\n});\nqueue.notify({ type: 'UPDATE', data: { user: { id: 3, role:\n  'ADMIN' } } });\nconsole.assert(\n  createMessages.length === 3,\n  '%o collects CREATE messages',\n  allMessages\n);\nconsole.assert(\n  updateMessages.length === 3,\n  '%o collects UPDATE messages',\n  allMessages\n);\nconsole.assert(\n  allMessages.length === 6,\n  '%o collects all message',\n  allMessages\n);\n```", "```js\nclass UpdateMessageObserver {\n  constructor() {\n    this.updateMessages = [];\n  }\n  handle(message) {\n    if (message.type === 'UPDATE') {\n      this.updateMessages.push(message);\n    }\n  }\n}\n```", "```js\nclass QueueObserverObjects {\n  constructor() {\n    this.observers = [];\n  }\n  subscribe(observerObj) {\n    this.observers.push(observerObj);\n  }\n  unsubscribe(observerObj) {\n    this.observers = this.observers.filter(\n      (observer) => observer !== observerObj,\n    );\n  }\n  notify(message) {\n    this.observers.forEach((observer) => {\n      observer.handle(message);\n    });\n  }\n}\n```", "```js\nconst queueObserverObjects = new QueueObserverObjects();\nconst updateMessageObserver = new UpdateMessageObserver();\nqueueObserverObjects.subscribe(updateMessageObserver);\nqueueObserverObjects.notify({\n  type: 'CREATE',\n  data: { user: { id: 1 } },\n});\nqueueObserverObjects.notify({\n  type: 'UPDATE',\n  data: { user: { id: 1, role: 'ADMIN' } },\n});\nqueueObserverObjects.notify({\n  type: 'UPDATE',\n  data: { user: { id: 3, role: 'DEVELOPER' } },\n});\nconsole.assert(\n  updateMessageObserver.updateMessages.length === 2,\n  '%o collects update messages',\n  updateMessageObserver.updateMessages,\n);\n```", "```js\nclass Queue {\n  #handlers;\n  constructor() {\n    this.#handlers = [];\n  }\n  subscribe(handlerFn) {\n    this.#handlers.push(handlerFn);\n  }\n  unsubscribe(handlerFn) {\n    this.#handlers = this.#handlers.filter((handler) =>\n      handler !== handlerFn);\n  }\n  notify(message) {\n    this.#handlers.forEach((handler) => {\n      handler(message);\n    });\n  }\n}\n```", "```js\nclass Queue {\n  #handlers;\n  constructor() {\n    this.#handlers = [];\n  }\n  subscribe(handlerFn) {\n    this.#handlers.push(handlerFn);\n    return this;\n  }\n  unsubscribe(handlerFn) {\n    this.#handlers = this.#handlers.filter((handler) =>\n      handler !== handlerFn);\n    return this;\n  }\n  notify(message) {\n    this.#handlers.forEach((handler) => {\n      handler(message);\n    });\n    return this;\n  }\n}\n```", "```js\nconst queue = new Queue();\nconst createMessages = [];\nconst updateMessages = [];\nconst allMessages = [];\nqueue\n  .subscribe((message) => {\n    if (message.type === 'CREATE') {\n      createMessages.push(message);\n    }\n  })\n  .subscribe((message) => {\n    if (message.type === 'UPDATE') {\n      updateMessages.push(message);\n    }\n  })\n  .subscribe((message) => {\n    allMessages.push(message);\n  });\nqueue\n  .notify({ type: 'CREATE', data: { user: { id: 1 } } })\n  .notify({ type: 'CREATE', data: { user: { id: 2 } } })\n  .notify({ type: 'CREATE', data: { user: { id: 3 } } })\n  .notify({ type: 'UPDATE', data: { user: { id: 1, role:\n    'ADMIN' } } })\n  .notify({\n    type: 'UPDATE',\n    data: { user: { id: 3, role: 'DEVELOPER' } },\n  })\n  .notify({ type: 'UPDATE', data: { user: { id: 3, role:\n    'ADMIN' } } });\nconsole.assert(\n  createMessages.length === 3,\n  '%o collects CREATE messages',\n  allMessages\n);\nconsole.assert(\n  updateMessages.length === 3,\n  '%o collects UPDATE messages',\n  allMessages\n);\nconsole.assert(\n  allMessages.length === 6,\n  '%o collects all message',\n  allMessages\n);\n```", "```js\nclass PullRequest {\n  constructor(isDraft = false) {\n    this.state = isDraft ? new DraftState(this) : new\n      OpenState(this);\n  }\n  setState(state) {\n    this.state = state;\n  }\n  open() {\n    this.state.open();\n  }\n  markDraft() {\n    this.state.markDraft();\n  }\n  markReadyForReview() {\n    this.state.markReadyForReview();\n  }\n  close() {\n    this.state.close();\n  }\n  merge() {\n    this.state.merge();\n  }\n}\n```", "```js\nclass DraftState {\n  constructor(pullRequest) {\n    this.pullRequest = pullRequest;\n  }\n  markReadyForReview() {\n    this.pullRequest.setState(new OpenState\n      (this.pullRequest));\n  }\n  close() {\n    this.pullRequest.setState(new ClosedState\n      (this.pullRequest));\n  }\n}\n```", "```js\nclass OpenState {\n  constructor(pullRequest) {\n    this.pullRequest = pullRequest;\n  }\n  markDraft() {\n    this.pullRequest.setState(new DraftState\n      (this.pullRequest));\n  }\n  close() {\n    this.pullRequest.setState(new ClosedState\n      (this.pullRequest));\n  }\n  merge() {\n    this.pullRequest.setState(new MergedState\n      (this.pullRequest));\n  }\n}\n```", "```js\nclass MergedState {\n  constructor(pullRequest) {\n    this.pullRequest = pullRequest;\n  }\n}\n```", "```js\nclass ClosedState {\n  constructor(pullRequest) {\n    this.pullRequest = pullRequest;\n  }\n  open() {\n    this.pullRequest.setState(new OpenState\n      (this.pullRequest));\n  }\n}\n```", "```js\nconst pullRequest1 = new PullRequest(true);\nconsole.assert(pullRequest1.state instanceof DraftState,\n  pullRequest1.state);\npullRequest1.markReadyForReview();\nconsole.assert(pullRequest1.state instanceof OpenState,\n  pullRequest1.state);\n```", "```js\npullRequest1.merge();\nconsole.assert(\n  captureError(() => pullRequest1.open()) instanceof Error,\n  pullRequest1.state\n);\nconsole.assert(\n  captureError(() => pullRequest1.markReadyForReview())\n    instanceof Error,\n  pullRequest1.state\n);\nconsole.assert(\n  captureError(() => pullRequest1.close()) instanceof\n    Error,\n  pullRequest1.state\n);\n```", "```js\nconst pullRequest2 = new PullRequest(false);\nconsole.assert(pullRequest2.state instanceof OpenState,\n  pullRequest2.state);\npullRequest2.close();\nconsole.assert(pullRequest2.state instanceof ClosedState,\n  pullRequest2.state);\nconsole.assert(\n  captureError(() => pullRequest2.markDraft())\n    instanceof Error,\n  pullRequest2.state\n);\npullRequest2.open();\nconsole.assert(pullRequest2.state instanceof OpenState,\n  pullRequest2.state);\n```", "```js\nclass ObjectMerger {\n  constructor(defaultStrategy) {\n    this.strategy = defaultStrategy;\n  }\n  setStrategy(newStrategy) {\n    this.strategy = newStrategy;\n  }\n  combineObjects(obj1, obj2) {\n    return this.strategy.combineObjects(obj1, obj2);\n  }\n}\n```", "```js\nclass PureObjectAssignStrategy {\n  constructor() {}\n  combineObjects(obj1, obj2) {\n    return Object.assign({}, obj1, obj2);\n  }\n}\n```", "```js\nconst objectMerger = new ObjectMerger\n  (new PureObjectAssignStrategy());\n```", "```js\nconst obj1 = {\n  keys: '123',\n};\nconst obj2 = {\n  keys: '456',\n};\nconst defaultMergeStrategyOutput =\n  objectMerger.combineObjects(obj1, obj2);\nconsole.assert(defaultMergeStrategyOutput.keys === '456',\n  '%o has keys = 456');\nconsole.assert(obj1.keys === '123' && obj2.keys === '456',\n  obj1, obj2);\n```", "```js\nclass MutatingObjectAssignStrategy {\n  constructor() {}\n  combineObjects(obj1, obj2) {\n    return Object.assign(obj1, obj2);\n  }\n}\n```", "```js\nobjectMerger.setStrategy(new\n  MutatingObjectAssignStrategy());\nconst mutatingMergedStrategyOutput =\n  objectMerger.combineObjects(obj1, obj2);\nconsole.assert(\n  mutatingMergedStrategyOutput.keys === '456',\n  '%o has keys = 456',\n  mutatingMergedStrategyOutput\n);\nconsole.assert(\n  obj1.keys === '456' && obj2.keys === '456',\n  'Mutates the original object obj1 %o, obj2 %o',\n  obj1,\n  obj2\n);\n```", "```js\nclass ObjectSpreadStrategy {\n  constructor() {}\n  combineObjects(obj1, obj2) {\n    return { ...obj1, ...obj2 };\n  }\n}\n```", "```js\nobjectMerger.setStrategy(new ObjectSpreadStrategy());\nconst newObj1 = { keys: '123' };\nconst newObj2 = { keys: '456', obj1: newObj1 };\nconst objectSpreadStrategyOutput =\n  objectMerger.combineObjects(\n  newObj1,\n  newObj2\n);\nconsole.assert(\n  objectSpreadStrategyOutput.keys === '456',\n  '%o has keys = 456',\n  objectSpreadStrategyOutput\n);\nconsole.assert(\n  newObj1.keys === '123' && newObj2.keys === '456',\n  'Does not mutate the original object newObj1 %o,\n    newObj2 %o',\n  newObj1,\n  newObj2\n);\n```", "```js\nconsole.assert(\n  objectSpreadStrategyOutput.obj1 === newObj1,\n  'Does a shallow clone so objectSpreadStrategyOutput.obj1\n    references newObj1'\n);\n```", "```js\nclass DeepCloneObjectAssignStrategy {\n  constructor() {}\n  combineObjects(obj1, obj2) {\n    return Object.assign(structuredClone(obj1),\n      structuredClone(obj2));\n  }\n}\n```", "```js\nobjectMerger.setStrategy(new DeepCloneObjectAssignStrategy());\nconst deepCloneStrategyOutput = objectMerger.\n  combineObjects(newObj1, newObj2);\nconsole.assert(\n  deepCloneStrategyOutput.keys === '456',\n  '%o has keys = 456',\n  deepCloneStrategyOutput\n);\nconsole.assert(\n  newObj1.keys === '123' && newObj2.keys === '456',\n  'Does not mutate the original object newObj1 %o,\n    newObj2 %o',\n  newObj1,\n  newObj2\n);\nconsole.assert(\n  deepCloneStrategyOutput.obj1 !== newObj1 &&\n    deepCloneStrategyOutput.obj1.keys === newObj1.keys,\n  'Does a shallow clone so deepCloneStrategyOutput.obj1\n    references newObj1'\n);\n```", "```js\nclass IllegalOperationError extends Error {\n  constructor(stateInstance) {\n    this.stateInstance = stateInstance;\n    throw new Error('Illegal operation for State');\n  }\n}\nclass PullRequestBaseState {\n  constructor(pullRequest) {\n    this.pullRequest = pullRequest;\n  }\n  markDraft() {\n    throw new IllegalOperationError(this);\n  }\n  markReadyForReview() {\n    throw new IllegalOperationError(this);\n  }\n  open() {\n    throw new IllegalOperationError(this);\n  }\n  close() {\n    throw new IllegalOperationError(this);\n  }\n  merge() {\n    throw new IllegalOperationError(this);\n  }\n}\n```", "```js\nclass ClosedState extends PullRequestBaseState {\n  open() {\n    this.pullRequest.setState(new OpenState\n      (this.pullRequest));\n  }\n}\nclass DraftState extends PullRequestBaseState {\n  markReadyForReview() {\n    this.pullRequest.setState(new OpenState\n      (this.pullRequest));\n  }\n  close() {\n    this.pullRequest.setState(new ClosedState\n      (this.pullRequest));\n  }\n}\nclass OpenState extends PullRequestBaseState {\n  markDraft() {\n    this.pullRequest.setState(new DraftState\n      (this.pullRequest));\n  }\n  close() {\n    this.pullRequest.setState(new ClosedState\n      (this.pullRequest));\n  }\n  merge() {\n    this.pullRequest.setState(new MergedState\n      (this.pullRequest));\n  }\n}\nclass MergedState extends PullRequestBaseState {}\n```", "```js\nconst pullRequest1 = new PullRequest(true);\nconsole.assert(pullRequest1.state instanceof DraftState,\n  pullRequest1.state);\npullRequest1.markReadyForReview();\nconsole.assert(pullRequest1.state instanceof OpenState,\n  pullRequest1.state);\npullRequest1.merge();\nconsole.assert(\n  captureError(() => pullRequest1.open()) instanceof Error,\n  pullRequest1.state\n);\nconsole.assert(\n  captureError(() => pullRequest1.markReadyForReview())\n    instanceof Error,\n  pullRequest1.state\n);\nconsole.assert(\n  captureError(() => pullRequest1.close()) instanceof\n   Error,\n  pullRequest1.state\n);\nconst pullRequest2 = new PullRequest(false);\nconsole.assert(pullRequest2.state instanceof OpenState,\n  pullRequest2.state);\npullRequest2.close();\nconsole.assert(pullRequest2.state instanceof ClosedState,\n  pullRequest2.state);\nconsole.assert(\n  captureError(() => pullRequest2.markDraft())\n    instanceof Error,\n  pullRequest2.state\n);\npullRequest2.open();\nconsole.assert(pullRequest2.state instanceof OpenState,\n  pullRequest2.state);\n```", "```js\nclass ObjectMerger {\n  constructor(defaultStrategy) {\n    this.strategy = defaultStrategy;\n  }\n  setStrategy(newStrategy) {\n    this.strategy = newStrategy;\n  }\n  combineObjects(obj1, obj2) {\n    return this.strategy(obj1, obj2);\n  }\n}\n```", "```js\nfunction pureObjectAssignStrategy(obj1, obj2) {\n  return Object.assign({}, obj1, obj2);\n}\nfunction mutatingObjectAssignStrategy(obj1, obj2) {\n  return Object.assign(obj1, obj2);\n}\nfunction objectSpreadStrategy(obj1, obj2) {\n  return { ...obj1, ...obj2 };\n}\nfunction deepCloneObjectAssignStrategy(obj1, obj2) {\n  return Object.assign(structuredClone(obj1),\n    structuredClone(obj2));\n}\n```", "```js\nconst objectMerger = new ObjectMerger\n  (pureObjectAssignStrategy);\nconst obj1 = {\n  keys: '123',\n};\nconst obj2 = {\n  keys: '456',\n};\nconst defaultMergeStrategyOutput =\n  objectMerger.combineObjects(obj1, obj2);\nconsole.assert(defaultMergeStrategyOutput.keys === '456',\n  '%o has keys = 456');\nconsole.assert(obj1.keys === '123' && obj2.keys === '456',\n  obj1, obj2);\nobjectMerger.setStrategy(mutatingObjectAssignStrategy);\nconst mutatingMergedStrategyOutput =\n  objectMerger.combineObjects(obj1, obj2);\nconsole.assert(\n  mutatingMergedStrategyOutput.keys === '456',\n  '%o has keys = 456',\n  mutatingMergedStrategyOutput\n);\nconsole.assert(\n  obj1.keys === '456' && obj2.keys === '456',\n  'Mutates the original object obj1 %o, obj2 %o',\n  obj1,\n  obj2\n);\nobjectMerger.setStrategy(objectSpreadStrategy);\nconst newObj1 = { keys: '123' };\nconst newObj2 = { keys: '456', obj1: newObj1 };\nconst objectSpreadStrategyOutput =\n  objectMerger.combineObjects(\n  newObj1,\n  newObj2\n);\nconsole.assert(\n  objectSpreadStrategyOutput.keys === '456',\n  '%o has keys = 456',\n  objectSpreadStrategyOutput\n);\nconsole.assert(\n  newObj1.keys === '123' && newObj2.keys === '456',\n  'Does not mutate the original object newObj1 %o,\n    newObj2 %o',\n  newObj1,\n  newObj2\n);\nconsole.assert(\n  objectSpreadStrategyOutput.obj1 === newObj1,\n  'Does a shallow clone so objectSpreadStrategyOutput.obj1\n    references newObj1'\n);\nobjectMerger.setStrategy(deepCloneObjectAssignStrategy);\nconst deepCloneStrategyOutput = objectMerger.combineObjects\n  (newObj1, newObj2);\nconsole.assert(\n  deepCloneStrategyOutput.keys === '456',\n  '%o has keys = 456',\n  deepCloneStrategyOutput\n);\nconsole.assert(\n  newObj1.keys === '123' && newObj2.keys === '456',\n  'Does not mutate the original object newObj1 %o,\n    newObj2 %o',\n  newObj1,\n  newObj2\n);\nconsole.assert(\n  deepCloneStrategyOutput.obj1 !== newObj1 &&\n    deepCloneStrategyOutput.obj1.keys === newObj1.keys,\n  'Does a shallow clone so deepCloneStrategyOutput.\n    obj1 references newObj1'\n);\n```", "```js\nclass BankAccount {\n  /**\n   *\n   * @param {'CURRENT' | 'SAVINGS'} accountType\n   * @param {String} currency\n   * @param {Number} balance - balance in minor currency\n     unit\n   */\n  constructor(accountType = 'CURRENT', currency = 'USD',\n    balance = 0) {\n    this.accountType = accountType;\n    this.currency = currency;\n    this.balance = balance;\n  }\n  setBalance(balance) {\n    this.balance = balance;\n  }\n  accept(visitor) {\n    visitor.visit(this);\n  }\n}\n```", "```js\nclass InterestVisitor {\n  constructor(interestRate, currency) {\n    this.interestRate = interestRate;\n    this.currency = currency;\n  }\n  /**\n   * @param {BankAccount} bankAccount\n   */\n  visit(bankAccount) {\n    if (\n      bankAccount.currency === this.currency &&\n      bankAccount.accountType === 'SAVINGS'\n    ) {\n      bankAccount.setBalance((bankAccount.balance *\n        this.interestRate) / 100);\n    }\n  }\n}\n```", "```js\nconst accounts = [\n  new BankAccount('SAVINGS', 'GBP', 500),\n  new BankAccount('SAVINGS', 'USD', 500),\n  new BankAccount('CURRENT', 'USD', 10000),\n];\nconst usdInterestVisitor = new InterestVisitor(105, 'USD');\nconst gbpInterestVisitor = new InterestVisitor(110, 'GBP');\n```", "```js\naccounts.forEach((account) => {\n  account.accept(usdInterestVisitor);\n  account.accept(gbpInterestVisitor);\n});\nconsole.assert(\n  accounts[0].balance === 550 &&\n    accounts[1].balance === 525 &&\n    accounts[2].balance === 10000,\n  '%o',\n  accounts\n);\n```", "```js\nimport { SchemaDirectiveVisitor } from 'apollo-server';\nclass CustomDirective extends SchemaDirectiveVisitor {\n  visitFieldDefinition(field) {\n    // we can replace/augment the field's resolver\n       implementation here\n  }\n}\n'@babel/parser' package:\n```", "```js\nimport * as parser from '@babel/parser';\nimport traverse from '@babel/traverse';\nconst ast = parser.parse(`function triple(n) {\n  return n * 3;\n}`);\nconst CustomVisitor = {\n  FunctionDeclaration(path) {\n    console.assert(path.node.id.name === 'triple');\n  },\n};\ntraverse(ast, CustomVisitor);\n```"]