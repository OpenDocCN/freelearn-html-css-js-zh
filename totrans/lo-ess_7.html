<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Using Lo-Dash with Other Libraries"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Using Lo-Dash with Other Libraries</h1></div></div></div><p>The previous chapter showed us what our Lo-Dash code starts to look like as it falls in place within a larger application. Things get factored into a more generic, reusable form, and they're named and structured consistently. Patterns start to emerge, and as your code starts to realize these patterns, it takes the shape of a production-ready system.</p><p>In the spirit of deploying Lo-Dash code to a production environment, this chapter addresses the ecosystem into which our code is tossed when deemed stable. Lo-Dash does a lot, but there are some tasks that this library is simply not well suited for. In other words, it's highly unlikely that Lo-Dash is the only library your application will use.</p><p>The best way to keep our code organized and modular is by using modules. Module technology has gained a lot of attention over the last few years in the JavaScript community, and Lo-Dash is no exception. We can make it work using the same module loaders that applications use. There are also Lo-Dash packages available for Node.js.</p><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Modules</li><li class="listitem" style="list-style-type: disc">jQuery</li><li class="listitem" style="list-style-type: disc">Backbone</li><li class="listitem" style="list-style-type: disc">Node.js</li></ul></div><div class="section" title="Modules"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Modules</h1></div></div></div><p>If you've<a id="id464" class="indexterm"/> done any frontend development in the past few years, you have probably heard of AMD modules, if you haven't already experimented with them. AMD is growing fast, with no shortage of production deployments around the world. This modular movement in frontend development stemmed from a lack of a decent way to organize large-scale projects that have many dependencies. Before modules for the web were a thing, the only tool at our disposal for organizing dependencies was the <code class="literal">&lt;script&gt;</code> element. This is still an accepted way to pull in JavaScript code—except when there are hundreds of modules.</p><p>Modularity, especially<a id="id465" class="indexterm"/> frontend web development modularity, is a large topic—too large for this book (let alone for this chapter) to properly address. So let's strip the topic down to the relevant parts for us, the Lo-Dash programmers. It's good programming practice to divide our code into modules that serve a single purpose. This provides a good separation of concerns and allows our components to evolve more easily and independently of one another.</p><p>In this section, we'll<a id="id466" class="indexterm"/> take a look at <span class="strong"><strong>RequireJS</strong></span>, one of the leading AMD module loader technologies available. Lo-Dash has builds that help us utilize this technology and construct modules of our own. With that said, let's get into some of the practical nitty-gritty.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note46"/>Note</h3><p><span class="strong"><strong>AMD</strong></span> stands for <span class="strong"><strong>asynchronous module definition</strong></span>, a simple pattern followed by many JavaScript components. It's<a id="id467" class="indexterm"/> not a recognized specification, although something is brewing in the upcoming ES6 specification. There's a related pattern called UMD, which aims to be more universal than AMD and has some questionable fallback modes. My advice is to stick to something that's easy to use, such as RequireJS, until there's an adopted standard that's widely supported.</p></div></div><div class="section" title="Organizing your code with modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec98"/>Organizing your code with modules</h2></div></div></div><p>Let's <a id="id468" class="indexterm"/>see what a basic module looks like. The idea is <a id="id469" class="indexterm"/>that a definition function returns the component that the module defines. The component could be a function, an object, a string, or any value for that matter. If you're developing a Lo-Dash application, your modules are likely to return functions.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note47"/>Note</h3><p>Since RequireJS makes XHR requests, it's a lot easier to serve your JavaScript modules with a simple static web server. The code that is shipped with this book has a <code class="literal">Gruntfile</code>, which lets you run a simple web server. However, you'll need Node.js installed. There are plenty of resources all over the Internet that can be used to install Node on any platform. Once Node is available, you can install Grunt with the following command:</p><div class="informalexample"><pre class="programlisting">npm install -g grunt-cli grunt-contrib-connect</pre></div><p>This will make the <code class="literal">grunt</code> command available on your system. From within the root code directory, where the <code class="literal">Gruntfile.js</code> file is located, run the following command:</p><div class="informalexample"><pre class="programlisting">grunt connect</pre></div><p>You'll see some output about the server running forever. Pressing <span class="emphasis"><em>Ctrl</em></span> + <span class="emphasis"><em>C</em></span> will stop it. And that's it! You can navigate to <code class="literal">http://0.0.0.0:8000/chapter7.html</code> to run the examples from this chapter.</p></div></div><p>Consider the following code:</p><div class="informalexample"><pre class="programlisting">define([], function() {
    return function(coll, filter) {
        return _(coll)
            .filter(filter)
            .reduce(function(result, item) {
                return result + item.age;
            }, 0) / _.size(coll);
    };
});</pre></div><p>You<a id="id470" class="indexterm"/> can see that the <code class="literal">define()</code> function takes two<a id="id471" class="indexterm"/> arguments. The first is an array of modules that we're<a id="id472" class="indexterm"/> dependent on and the second is a function that returns the component this module defines. In this case, our module doesn't have any external dependencies and it returns an anonymous function. This function takes a <code class="literal">coll</code> and a <code class="literal">filter</code> argument. Then we use the Lo-Dash constructor to wrap the collection and we reduce it to the average value. Next, let's take a look at how this module gets used:</p><div class="informalexample"><pre class="programlisting">var collection = [
    { name: 'Frederick', age: 37 },
    { name: 'Tasha', age: 45 },
    { name: 'Lisa', age: 33 },
    { name: 'Michael', age: 41 }
];

require([ 'modules/average-age' ], function(averageAge) {
    averageAge(collection);
    // → 39
});</pre></div><p>You can see here that our call to the <code class="literal">require()</code> function passes an array of module dependencies. In this case, we're dependent on the <code class="literal">average-age</code> module. The function callback is triggered when this module is loaded, evaluated, and ready to use. The <code class="literal">averageAge</code> argument is the value returned by the module. In this case, it's the function we defined earlier, and we show how it can be applied to a collection.</p></div><div class="section" title="Requiring Lo-Dash"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec99"/>Requiring Lo-Dash</h2></div></div></div><p>The downside to our <code class="literal">average-age</code> module is that it doesn't define any explicit dependencies. Yet, it <a id="id473" class="indexterm"/>clearly depends on Lo-Dash being available. So how does this code even work? Where does the <code class="literal">_</code> variable get defined? Well, the<a id="id474" class="indexterm"/> only reason the preceding example runs is because we've included Lo-Dash on the page using the standard <code class="literal">&lt;script&gt;</code> tag. This adds the <code class="literal">_</code> symbol to the global namespace.</p><p>This goes against one of the grounding principles of modules—there shouldn't be a need for global variables. What we end up with are implicit dependencies, as is the case in the previous code. This means our modules that use this implicit dependency aren't as portable as they could be. If that <code class="literal">&lt;script&gt;</code> tag goes away, our module stops working. Thankfully, we can define our modules that depend on Lo-Dash as having this dependency explicitly, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">define([ 'lodash' ], function(_) {
    return function(coll) {
        return _(coll)
            .sortBy(function(item) {
                return item.first + '' + item.last;
            });
    };
});</pre></div><p>Here, you can see that instead of passing an empty array as the first argument to <code class="literal">define()</code>, we have a string that points to the Lo-Dash module. Now the <code class="literal">_</code> symbol is an argument within our <code class="literal">define()</code> function instead of being referenced globally. Let's see this module being put to use now:</p><div class="informalexample"><pre class="programlisting">var collection = [
    { first: 'Georgia', last: 'Todd' },
    { first: 'Andrea', last: 'Gretchen' },
    { first: 'Ruben', last: 'Green' },
    { first: 'Johnny', last: 'Tucker' }
];

require([ 'modules/sort-name' ], function(sortName) {
    sortName(collection).value();
    // →
    // [
    //   { first: "Andrea", last: "Gretchen" },
    //   { first: "Georgia", last: "Todd" },
    //   { first: "Johnny", last: "Tucker" },
    //   { first: "Ruben", last: "Green" }
    // ]
});</pre></div><p>Here, we require our <code class="literal">sort-name</code> module as a dependency and the <code class="literal">sortName()</code> function is an <a id="id475" class="indexterm"/>argument to the <code class="literal">require()</code> callback function. The function sorts an input collection by name and returns a wrapper instance. This is illustrated here, by calling <code class="literal">sortBy()</code> followed by <code class="literal">value()</code>. This is actually a good thing because it means that the returned wrapper instance can be extended before it is evaluated and unwrapped.</p><p>You'll also <a id="id476" class="indexterm"/>notice that we're indirectly depending on Lo-Dash here because<a id="id477" class="indexterm"/> we depend on <code class="literal">sort-name</code>. We can call the <code class="literal">value()</code> function<a id="id478" class="indexterm"/> and extend the returned wrapper without an explicit reference to the <code class="literal">_</code> symbol. This means that, should the <code class="literal">sort-name</code> module no longer rely on Lo-Dash at some point in the future, our function will still work, although we might have to remove the <code class="literal">value()</code> invocation.</p><p>There's another step involved with getting Lo-Dash to work with RequireJS. Let's take a look at the <code class="literal">main.js</code> configuration file that helps RequireJS figure out where to find modules and what they expose:</p><div class="informalexample"><pre class="programlisting">require.config({
    paths: {
        lodash: 'lib/lodash'
    },
    shim: {
        lodash: { exports: '_' }
    }
});</pre></div><p>Our code referenced <code class="literal">lodash</code> as a dependency. This path configuration tells RequireJS where to find that module. The <code class="literal">shim</code> configuration section is for modules that aren't defined as AMD modules. Since this is the case with Lo-Dash, we have to add a shim that tells RequireJS what's actually returned when something requires the concerned module.</p></div><div class="section" title="Working with Lo-Dash AMD modules"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec100"/>Working with Lo-Dash AMD modules</h2></div></div></div><p>It turns<a id="id479" class="indexterm"/> out that there's a better way to <a id="id480" class="indexterm"/>use Lo-Dash in the form of AMD modules. Lo-Dash has specific AMD builds available for download and these don't require a shim. Another benefit of obtaining Lo-Dash components this way is that we don't have to pull down the entire library if we depend on only a handful of functions. For example, let's see how we can depend on function categories:</p><div class="informalexample"><pre class="programlisting">function Person(first, last) {
    this.first = first;
    this.last = last;
}

Person.prototype.name = function() {
    return this.first + '' + this.last;
}

var collection = [
    new Person('Douglas', 'Wright'),
    new Person('Tracy', 'Wilson'),
    new Person('Ken', 'Phelps'),
    new Person('Meredith', 'Simmons')
];

require([ 'lib/lodash-amd/collection' ], function(_) {
    _.invoke(collection, 'name');
    // →
    // [
    //   "Douglas Wright",
    //   "Tracy Wilson",
    //   "Ken Phelps",
    //   "Meredith Simmons"
    // ]
});</pre></div><p>We're <a id="id481" class="indexterm"/>using the AMD build of Lo-Dash in<a id="id482" class="indexterm"/> this example. This is made apparent by the module path that we require. The <code class="literal">collection</code> module is defined as an AMD module <a id="id483" class="indexterm"/>and contains all the collection-related functions. You can see that we're using the <code class="literal">_</code> symbol as the function argument. This means the code that uses the collection functions can be written just as if it is using any Lo-Dash module. For instance, if we were to require the full Lo-Dash API instead of just the collection functions, none of the code would need to change. Instead, we're only requiring a subset of Lo-Dash, thus saving the network delivery cost.</p><p>The code is<a id="id484" class="indexterm"/> using the <code class="literal">invoke()</code> function on our collection to call the <code class="literal">name()</code> method on each item while collecting the results. However, that's only one function. There's still a lot in the collections category that we require and are not using at all. Let's see how we can use more fine-grained Lo-Dash function dependencies:</p><div class="informalexample"><pre class="programlisting">var collection = [
    { name: 'Susan', age: 57, enabled: false },
    { name: 'Marcus', age: 45, enabled: true },
    { name: 'Ray', age: 25, enabled: false },
    { name: 'Dora', age: 19, enabled: true }
];

require([
    'lib/lodash-amd/collection/filter',
    'lib/lodash-amd/function/partial'
], function(filter, partial) {
    function valid(age, item) {
        return item.enabled &amp;&amp; item.age &gt;= age;
    }

    filter(collection, partial(valid, 25));
    // → [ { age: 45, enabled: true, name: "Marcus" } ]

});</pre></div><p>As you can see when you drill into the categories, there's a specific module for any given function you'd like to include. The preceding code is using two Lo-Dash functions. The <code class="literal">filter()</code> function comes from the collection category and the <code class="literal">partial()</code> function comes from <a id="id485" class="indexterm"/>the function category. Both <a id="id486" class="indexterm"/>functions are passed directly as callback arguments. Since both of these function modules are themselves defined as AMD modules, they require only the internal dependencies needed to work. This means that we're only requiring what we need, which might only be one or two functions in certain contexts, such as our preceding example.</p><p>The downside to this level of granularity is that if you're unsure of what you need, you'll constantly have to modify your list of model dependencies. Lo-Dash has a lot to offer, and it's a good idea to utilize Lo-Dash functions wherever you can. For example, if you're wrapping values and chaining together function calls, it's tough to know in advance which functions you're going to require. So it's probably a good idea to obtain the whole API so that there's no possibility of something you want to use not being there. Consider the following code:</p><div class="informalexample"><pre class="programlisting">var collection = [
    { name: 'Allan', age: 29, enabled: false },
    { name: 'Edward', age: 43, enabled: false },
    { name: 'Evelyn', age: 39, enabled: true },
    { name: 'Denise', age: 34, enabled: true }
];

require([ 'lib/lodash-amd/main' ], function(_) {
    _(collection)
        .filter('enabled')
        .sortBy('age')
        .reverse()
        .map('name')
        .value();
    // → [ "Evelyn", "Denise" ]
});</pre></div><p>This is similar to our first example, where we required the entire Lo-Dash API. The difference here is that this is the AMD build, so we require the <code class="literal">main</code> Lo-Dash module, which includes everything we'll need. The other difference is that with this approach, there's no <a id="id487" class="indexterm"/>need to set up paths or shims <a id="id488" class="indexterm"/>within the main RequireJS configuration file.</p></div></div></div>
<div class="section" title="jQuery"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec51"/>jQuery</h1></div></div></div><p>jQuery is<a id="id489" class="indexterm"/> undoubtedly one of the most successful and widely used technologies of all time. And it came into being because of browser inconsistencies; John Resig decided to do something about it. Rather than having the application developers maintain their own code that deals with all the mundane cross-browser issues, why not let jQuery handle that stuff for them?</p><p>jQuery has evolved over the years, thanks to thousands and thousands of users and contributing developers wanting to make frontend development less intimidating. Over time, it has changed certain aspects of itself and added new features to keep up with the changing environments in which it resides.</p><p>It's safe to say that jQuery has changed the way frontend development is done and will continue to do so because of its mass adoption. Several web standards that exist today are rooted in jQuery. Lo-Dash is similar to jQuery in a lot of ways. While it's not nearly as mature as jQuery, it's being rapidly adopted. Like jQuery, Lo-Dash originated from an effort to fix cross-browser issues and performance issues present in Underscore.js. The development effort of Lo-Dash has expanded much beyond a simple drop-in replacement for Underscore.js and will certainly influence future JavaScript specifications.</p><p>So jQuery and Lo-Dash are similar in their effectiveness. Where they differ is in the specific problems they solve for programmers. Let's take a closer look at those and see whether there is a way in which the two libraries can complement one another.</p><div class="section" title="Challenges faced by Lo-Dash"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec101"/>Challenges faced by Lo-Dash</h2></div></div></div><p>Lo-Dash<a id="id490" class="indexterm"/> is a low-level framework that augments JavaScript at the language level. Low-level is a relative term. It's not that Lo-Dash doesn't have any abstractions; it has plenty. It's just that there's a lot more to frontend development than just JavaScript. Lo-Dash isn't good at any of those other things, nor is it intended to be.</p><p>While you can use Lo-Dash to write better code, that's only half the battle. Standalone JavaScript code doesn't get you very far. If you're developing an application, at some point, you're going to eventually touch the DOM. You're going to make API calls that load your application data and change the state of the server-side resources. You're also going to deal with the asynchronous nature of these calls and user events, while taking care to perform well and prevent leaks.</p><p>Frontend<a id="id491" class="indexterm"/> development is a complicated endeavor but Lo-Dash is great for all things in JavaScript. Writing concise, readable code that performs well is where Lo-Dash shines. This generally means the core of your frontend code. For everything else, there are other libraries, such as jQuery.</p></div><div class="section" title="Challenges faced by jQuery"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec102"/>Challenges faced by jQuery</h2></div></div></div><p>One of the <a id="id492" class="indexterm"/>reasons jQuery is so attractive to programmers is its low barrier to entry. Anyone building a website can immediately learn and benefit from jQuery, often in a day or two. At the same time, it's powerful enough to scale from a basic site to a powerful web application. DOM traversal and manipulation are one thing jQuery excels at, but it's also capable of dealing with complicated Ajax calls, DOM events, and asynchronous callbacks.</p><p>These are all the areas Lo-Dash lacks any support in. Again, this is intentional. The two libraries serve different purposes. However, they're also complementary and often sit side by side in the same application, carrying out their roles. What jQuery doesn't have is a set of tools to aid the programmer inside all of these callback functions that run in response to Ajax requests, user events, and so on. This is not what it's meant for. You're free to use any library you like to enhance the core application business logic, and Lo-Dash is one such choice.</p><p>The focused nature of both Lo-Dash and jQuery leaves us with a clear separation of concerns. jQuery lets the Lo-Dash programmer worry about creating high-quality functional code. We've already seen how to utilize RequireJS with Lo-Dash in an effort to produce modular components. Let's now look at how we can use Lo-Dash alongside jQuery.</p></div><div class="section" title="Using jQuery instances as collections"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec103"/>Using jQuery instances as collections</h2></div></div></div><p>Perhaps, the <a id="id493" class="indexterm"/>most common use case of jQuery is <a id="id494" class="indexterm"/>querying the DOM for elements. The result is a jQuery object that closely resembles an array. We can exercise our Lo-Dash know-how to treat these instances as collections. For example, let's compare the jQuery <code class="literal">map()</code> function to the Lo-Dash <code class="literal">map()</code> function:</p><div class="informalexample"><pre class="programlisting">var i = 1000;
console.time('$');
while (i--) {
    $('li').map(function() {
        return $(this).html();
    });
}
console.timeEnd('$');
i = 1000;
console.time('_');
while (i--) {
    _.map($('li'), function(item) {
        return $(item).html();
    });
}
console.timeEnd('_');
// → 
// $: 64.127ms
// _: 27.434ms</pre></div><p>The mapped output of both approaches is exactly the same. Even the code differences are subtle at best. The difference is only in the looping performance—the Lo-Dash <code class="literal">map()</code> function will always have an edge over the jQuery <code class="literal">map()</code> function due to the differences in implementation.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note50"/>Note</h3><p>The following chapter goes into greater detail on why iterative Lo-Dash functions perform the way they do.</p></div></div><p>The <a id="id495" class="indexterm"/>performance gain isn't all that great. What's a few <a id="id496" class="indexterm"/>milliseconds here and there? The preceding example only finds a handful of elements, and the test is repeated 1,000 times. In production, you're probably going to be dealing with larger query results, iterated more than 1,000 times, and over time, the milliseconds start to add up.</p><p>Is there anything fundamentally wrong with the performance of jQuery <code class="literal">map()</code>? Absolutely not. If it works, use it. This change itself isn't going to pleasantly surprise your users. On the other hand, if you're a Lo-Dash programmer, you're going to use it for what it's good at. Lo-Dash is very good at iterating over collections. jQuery is very good at querying the DOM, and it still takes up this responsibility. So what's the code cost of implementing this improvement? Essentially zero.</p></div><div class="section" title="Binding functions"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec104"/>Binding functions</h2></div></div></div><p>In <a id="id497" class="indexterm"/>the previous section, we looked at an area where Lo-Dash<a id="id498" class="indexterm"/> and jQuery overlap. We chose the Lo-Dash approach because it made sense to do so, both from a responsibility perspective (iterating over collections) and a cost-to-implement perspective (the code looks nearly identical). Another area of overlap is function binding. jQuery has tools available to bind functions to a given context, but Lo-Dash has better functional tools. Let's compare the two approaches again:</p><div class="informalexample"><pre class="programlisting">function boundFunction(result, item) {
    return result + this.multiplier * item;
}

var scope = { multiplier: 10 },
    collection = _.range(1, 1000),
    jQueryBound = $.proxy(boundFunction, scope),
    lodashBound = _.bind(boundFunction, scope);

console.time('$');
console.log(_.reduce(collection, jQueryBound));
console.timeEnd('$');

console.time('_');
console.log(_.reduce(collection, lodashBound));
console.timeEnd('_');
// → 
// 4994991
// $: 3.214ms
// 4994991
// _: 0.567ms</pre></div><p>Both <a id="id499" class="indexterm"/>approaches reduce the collection to the same result. The code is<a id="id500" class="indexterm"/> basically identical; the only difference is the way the callback passed to <code class="literal">reduce()</code> is bound. The context we're binding the functions to<a id="id501" class="indexterm"/> is a plain object with a <code class="literal">multiplier</code> property that's looked up when the callback is run. It's looked up by referencing <code class="literal">this</code>, which is why we have to bind the context before passing the callback to the <code class="literal">reduce()</code> function.</p><p>The first approach uses the <code class="literal">proxy()</code> jQuery function while the second approach uses the Lo-Dash <code class="literal">bind()</code> function. As with the preceding example of <code class="literal">map()</code>, the performance edge goes to Lo-Dash, there's no cost to implement it, and it's something that Lo-Dash was designed to do well. So if you're passing callbacks to jQuery event functions, <code class="literal">bind()</code> is just as viable as <code class="literal">proxy()</code> and is within the scope of something Lo-Dash is good at.</p></div><div class="section" title="Working with jQuery deferred instances"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec105"/>Working with jQuery deferred instances</h2></div></div></div><p>We've <a id="id502" class="indexterm"/>seen how Lo-Dash can aid in <a id="id503" class="indexterm"/>iterating over DOM elements after they've been queried by jQuery. We've also seen how Lo-Dash can improve function bindings in our jQuery code. Let's turn things around and see where jQuery can help our Lo-Dash code:</p><div class="informalexample"><pre class="programlisting">function query(coll, filter, sort) {
    var deferred = $.Deferred(),
        _coll = _(coll).filter(filter);

    if (sort) {
        _coll.sortBy(_.isBoolean(sort) ? undefined : sort);
    }

    if (_.size(coll) &gt; 5000) {
        _.defer(function() {
            deferred.resolve(_coll.value());
        });
    } else {
       deferred.resolve(_coll.value());
    }

    return deferred.promise();
}

var collection = _.map(_.range(_.random(10000)), function(item) {
    return {
        id: item,
        enabled: !!_.random()
    };
}), resultSize;

console.log('Collection size: ' + _.size(collection));
query(collection, 'enabled', true).done(function(result) {
    resultSize = _.size(result);
    console.log('Result size: ' + resultSize);
});

if (!resultSize) {
    console.log('Awaiting results...');
}
// → 
// Collection size: 9071
// Awaiting results...
// Result size: 4635</pre></div><p>Here <a id="id504" class="indexterm"/>we're utilizing the <code class="literal">Deferred</code> jQuery <a id="id505" class="indexterm"/>object. This is something that's returned by a function that does something asynchronously. Once the caller has possession of the deferred instance, it serves as a channel between the caller and the function. When the function is done with its asynchronous work, it notifies the caller and a callback function is run. There's a whole bunch of tricks we can perform with deferred instances, but we'll keep it straightforward here.</p><p>The job of the <code class="literal">query()</code> function<a id="id506" class="indexterm"/> we've implemented is to wrap the collection in a Lo-Dash wrapper and filter it using the <code class="literal">filter</code> argument. If the <code class="literal">sort</code> argument was provided, we sort the collection as well. The asynchronous work happens when we check the size of the collection. Note that we haven't actually executed any of the chained function calls yet, because we haven't called <code class="literal">value()</code>. If the collection contains more than 5,000 items, we use the Lo-Dash <code class="literal">defer()</code> function to clear the JavaScript call stack before executing <code class="literal">value()</code>. If the collection contains less items, we execute the filter immediately.</p><p>The result <a id="id507" class="indexterm"/>of calling <code class="literal">value()</code> is passed to<a id="id508" class="indexterm"/> the caller through the jQuery deferred <a id="id509" class="indexterm"/>instance, using the <code class="literal">resolve()</code> function. What's nice about this function is that it's always asynchronous to the caller. Even when we have smaller collections, it's still treated as asynchronous. The output illustrates when our randomized collection has more than 5,000 items, and the filter is deferred. When we see the <code class="literal">awaiting results</code> message, it means that the control had returned to the caller before the query was executed. This is the idea; since the collection is large, we let other things happen first in case the filter takes a while to complete.</p></div></div>
<div class="section" title="Backbone"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Backbone</h1></div></div></div><p>Unlike jQuery, Backbone is a library that's concerned with creating higher-level abstractions<a id="id510" class="indexterm"/> for the application. Things such as models, collections, and views are concepts that the Backbone programmer extends to provide seamless integration with the API data.</p><p>Backbone recognizes its own strengths and utilizes other libraries such as jQuery and Underscore to implement certain things such as fetching and saving data. This is a job well suited for jQuery as is rendering views in the DOM. For lower-level tasks, Backbone utilizes Underscore's capabilities. Because Backbone leverages these libraries, it's able to maintain a small code footprint. Moreover, since it follows simple patterns, it more or less stays out of the developer's way, letting them adapt the library to specific use cases.</p><p>There's an entire ecosystem surrounding Backbone, and Lo-Dash is a part of this ecosystem. Since it was originally conceived as a drop-in replacement for Underscore, Lo-Dash integrates closely with Backbone. In this section, we'll look at replacing Underscore in a Backbone application and extending Backbone's capabilities with functionality not found in Underscore.</p><div class="section" title="Replacing Underscore.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec106"/>Replacing Underscore.js</h2></div></div></div><p>Backbone <a id="id511" class="indexterm"/>requires<a id="id512" class="indexterm"/> both jQuery and Underscore. Since it's wrapped as a UMD function, if we were to define Lo-Dash as an AMD module, it's quite simple to replace. Let's take a look at a RequireJS configuration that replaces Underscore with Lo-Dash:</p><div class="informalexample"><pre class="programlisting">require.config({
    paths: {
        jquery: 'lib/jquery.min',
        underscore: 'lib/lodash.backbone.min'
    },
    shim: {
        underscore: { exports: '_' }
    }
});</pre></div><p>When the Backbone module loads, it looks for the <code class="literal">jquery</code> and the <code class="literal">underscore</code> modules, both of which we've provided here. You'll notice that the <code class="literal">underscore</code> module points to <code class="literal">lodash.backbone.min</code>. This is a special Lo-Dash build that contains only the functions required by Backbone. In other words, it doesn't have any extra stuff that Backbone doesn't use internally. Now let's define a simple model:</p><div class="informalexample"><pre class="programlisting">define([
    'underscore',
    'lib/backbone'
], function(_, Backbone) {
    return Backbone.Model.extend({
        parse: function(data) {
            return _.extend({
                name: data.first + '' + data.last
            }, data);
        }
    });
});</pre></div><p>You can see that we require <code class="literal">underscore</code>, which is actually Lo-Dash, so we can use the <code class="literal">extend()</code> function. The <a id="id513" class="indexterm"/>Backbone model will also use Lo-Dash internally since it has the same Underscore requirement. Now let's use this model:</p><div class="informalexample"><pre class="programlisting">require([ 'modules/backbone-model' ], function(Model) {
    new Model({
        first: 'Lance',
        last: 'Newman'
    }, { parse: true }).toJSON();
    // → {name: "Lance Newman", first: "Lance", last: "Newman"}
});</pre></div><p>The main reason you would drop Lo-Dash into Backbone like this is the improvement in speed and consistency Lo-Dash has over Underscore.</p></div><div class="section" title="Full-featured Lo-Dash and Backbone"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec107"/>Full-featured Lo-Dash and Backbone</h2></div></div></div><p>As our<a id="id514" class="indexterm"/> application grows in sophistication, we'll probably<a id="id515" class="indexterm"/> want more Lo-Dash functionality, despite this not being a strict requirement for Backbone. The alternative would be to replace Underscore with a full version of Lo-Dash. For this, we can use the AMD build of Lo-Dash. Here's a modified version of the RequireJS configuration:</p><div class="informalexample"><pre class="programlisting">require.config({
    paths: {
        jquery: 'lib/jquery.min',
        underscore: 'lib/lodash-amd/main'
    }
});</pre></div><p>This is similar to the previous configuration, except that it doesn't require a shim to export the <code class="literal">_</code> symbol and it points to the <code class="literal">main</code> Lo-Dash module. Let's redefine our model using this approach:</p><div class="informalexample"><pre class="programlisting">define([
    'lib/lodash-amd/object/assign',
    'lib/backbone'
], function(assign, Backbone) {
    return Backbone.Model.extend({
        parse: function(data) {
            return assign({
                name: data.first + '' + data.last
            }, data);
        }
    });
});</pre></div><p>In this version of our model definition, we do not require Underscore. In fact, we only require one specific Lo-Dash function—<code class="literal">assign()</code>—in addition to Backbone. Mind you, Backbone will still load the entire Lo-Dash API.</p></div><div class="section" title="Enhancing collections and models"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec108"/>Enhancing collections and models</h2></div></div></div><p>If we<a id="id516" class="indexterm"/> require the full version of Lo-Dash, we can extend<a id="id517" class="indexterm"/> the capabilities of Backbone collections fairly <a id="id518" class="indexterm"/>easily. Let's <a id="id519" class="indexterm"/>define an extension module that extends Backbone collections with methods not found in Underscore:</p><div class="informalexample"><pre class="programlisting">define([
    'lib/backbone',
    'lib/lodash-amd/array/slice',
    'lib/lodash-amd/array/takeRight',
    'lib/lodash-amd/array/dropWhile'
], function(Backbone, slice, takeRight, dropWhile) {

    function extendCollection(func, name) {
        Backbone.Collection.prototype[name] = function() {
            var args = slice(arguments);
            args.unshift(this.models);
            return func.apply(null, args);
        }
    }

    extendCollection(takeRight, 'takeRight');
    extendCollection(dropWhile, 'dropWhile');

    return Backbone;
});</pre></div><p>This<a id="id520" class="indexterm"/> module, whenever <a id="id521" class="indexterm"/>required, will <a id="id522" class="indexterm"/>extend the <code class="literal">Backbone.Collection</code> prototype<a id="id523" class="indexterm"/> with two new methods, <code class="literal">takeRight()</code> and <code class="literal">dropWhile()</code>. Note that it returns Backbone, so whenever we require Backbone, we can just use this module and get the extended version as a result. Let's see this extended collection in use:</p><div class="informalexample"><pre class="programlisting">require([
    'lib/lodash-amd/collection',
    'modules/backbone-extensions'
], function(_, Backbone) {

    function name(model) {
        return model.get('name');
    }

    var collection = new Backbone.Collection([
        { name: 'Frank' },
        { name: 'Darryl' },
        { name: 'Stacey' },
        { name: 'Robin' }
    ], { comparator: name });

    _.map(collection.takeRight(2), name );
    // → [ "Robin", "Stacey" ]

    _.map(collection.dropWhile(function(model, index, coll) {
        return index &lt; (coll.length - 2);
    }), name);
    // → [ "Robin", "Stacey" ]

});</pre></div><p>As you can see, the collection now has a <code class="literal">takeRight()</code> and a <code class="literal">dropWhile()</code> method—something that's easy to add since the functions are already implemented by Lo-Dash. We<a id="id524" class="indexterm"/> just <a id="id525" class="indexterm"/>need to glue the parts together, the same <a id="id526" class="indexterm"/>way as Backbone does <a id="id527" class="indexterm"/>with Underscore functions.</p></div></div>
<div class="section" title="Node.js"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Node.js</h1></div></div></div><p>In the closing <a id="id528" class="indexterm"/>section of this chapter, we'll turn our attention to writing Lo-Dash code for the backend. This of course means installing Lo-Dash as a Node.js package.</p><div class="section" title="Installing the Lo-Dash package"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec109"/>Installing the Lo-Dash package</h2></div></div></div><p>Assuming<a id="id529" class="indexterm"/> you already have Node installed, since you<a id="id530" class="indexterm"/> had to do so in order to run the <code class="literal">grunt</code> command in the RequireJS examples, you should have an <code class="literal">npm</code> command on your system. If that's the case, installation is incredibly easy:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>npm install -g lodash</strong></span>
</pre></div><p>This will install Lo-Dash globally, meaning it's accessible to any other Node project that wishes to use it. This is probably a good idea since Lo-Dash is a library after all. To verify that the installation was a success, you can run the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>node -e "require('lodash');"</strong></span>
</pre></div><p>If you see a long error message, it means that something went wrong at the time of installation. If it exists silently, you're all set.</p></div><div class="section" title="Creating a simple command"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec110"/>Creating a simple command</h2></div></div></div><p>To get<a id="id531" class="indexterm"/> our hands dirty with Node.js along with Lo-Dash <a id="id532" class="indexterm"/>development, let's create a simple command that sorts a comma-separated input:</p><div class="informalexample"><pre class="programlisting">var _ = require('lodash'),
    args = _(process.argv),
    input;

if (args.size() &lt; 3) {
    console.error('Missing input');
    process.exit(1);
} else if (args.contains('-h')) {
    console.info('Sorts the comma-separated input');
    console.info('Use "-d" for descending order');
    process.exit(0);
}

input = _(process.argv[2].replace(/\s?(,)\s?/g, '$1').split(','))
    .sortBy();

if (args.contains('-d')) {
    input.reverse();
}

console.log(input.join(', '));</pre></div><p>The <code class="literal">args</code> variable is<a id="id533" class="indexterm"/> a Lo-Dash wrapper that contains the <a id="id534" class="indexterm"/>command arguments as a value. We'll call <code class="literal">size()</code> and <code class="literal">contains()</code> on this wrapper to validate the input. A second wrapper is created and stored in the <code class="literal">input</code> variable. This is the comma-separated list, where we're splitting the string and removing any excess whitespaces. Then we call <code class="literal">sortBy()</code> to sort the list and optionally reverse the order if the <code class="literal">-d</code> flag was set. The string is then joined back together. Calling <code class="literal">join()</code> will actually execute the function call chain, and this is the output of the command.</p></div><div class="section" title="Custom Lo-Dash builds"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec111"/>Custom Lo-Dash builds</h2></div></div></div><p>Another <a id="id535" class="indexterm"/>good reason to have Node.js installed is that you<a id="id536" class="indexterm"/> can install the <code class="literal">lodash-cli</code> package, which is the Lo-Dash build system. Using this tool, you can create custom builds on the fly and at a granular level. Right down to the function, you can specify what's included or what's excluded using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>lodash modularize include=function</strong></span>
</pre></div><p>This will run an AMD build of Lo-Dash for us, only including what's necessary for functions in the <code class="literal">function</code> category.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Summary</h1></div></div></div><p>This chapter focused on using Lo-Dash in the broader context of frontend development. Achieving modularity is made easier with technologies such as RequireJS. We looked at several ways to do this, and Lo-Dash has built-in support for these types on environments. We learned that Lo-Dash is a very focused library, helping the developer to write clean and efficient code while ignoring other things. The things that Lo-Dash isn't good at are nicely covered by other stable libraries such as jQuery and Backbone. We also wrote some Lo-Dash code that directly helps these libraries, both from a performance perspective and a functionality perspective.</p><p>We closed the chapter with a look at Node.js, and how it's possible to write Lo-Dash code for applications that run outside the browser. There's also a Node package that is used to build Lo-Dash and you can customize these builds to include whatever you like. Now that we've covered much ground on what you can do as a Lo-Dash programmer from the outside, let's take a look at the inside of Lo-Dash. Knowing how and why certain things are designed will better inform your decisions, in the interest of better performance.</p></div></body></html>