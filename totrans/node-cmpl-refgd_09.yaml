- en: Dynamic Client/Server Interaction with Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The original design model of the web is similar to the way that mainframes worked
    in the 1970s. Both old-school dumb terminals, such as the IBM 3270, and web browsers,
    follow a request-response paradigm. The user sends a request and the far-off computer
    sends a response screen. While web browsers can show more complex information
    than old-school dumb terminals, the interaction pattern in both cases is a back
    and forth of user requests, each resulting in a screen of data sent by the server
    screen after screen or, in the case of web browsers, page after page.
  prefs: []
  type: TYPE_NORMAL
- en: 'In case you''re wondering what this history lesson is about, that request-response
    paradigm is evident in the Node.js HTTP Server API, as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The paradigm couldn't be more explicit than this. The `request` and the `response`
    are right there.
  prefs: []
  type: TYPE_NORMAL
- en: The first web browsers were an advancement over text-based user interfaces,
    with HTML mixing images, and text with varying colors, fonts, and sizes. As CSS
    came along, HTML improved, iframes allowed embedded media of all kinds, and JavaScript
    improved, so we have a quite different paradigm. The web browser is still sending
    requests and receiving a page of data, but that data can be quite complex and,
    more importantly, JavaScript adds interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: One new technique is keeping an open connection to the server for continual
    data exchange between server and client. This change in the web application model
    is called, by some, the real-time web. In some cases, websites keep an open connection
    to the web browser, with real-time updates to web pages being one goal.
  prefs: []
  type: TYPE_NORMAL
- en: Some observe that traditional web applications can untruthfully display their
    data; that is, if two people are looking at a page, and one person edits that
    page, that person's browser will update with the correct copy of the page, while
    the other browser is not updated. The two browsers show different versions of
    the page, one of which is untruthful. The second browser can even show a page
    that no longer exists, if the user at the first browser deletes that page. Some
    think it would be better if the other person's browser is refreshed to show the
    new content as soon as the page is edited.
  prefs: []
  type: TYPE_NORMAL
- en: This is one possible role of the real-time web; pages that update themselves
    as page content changes. All kinds of systems support real-time interactivity
    between folks on the same website. Whether it's seeing Facebook comments pop up
    as they're written, or collaboratively edited documents, there's a new interactivity
    paradigm on the web.
  prefs: []
  type: TYPE_NORMAL
- en: We're about to implement this behavior in the Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: One of the original purposes for inventing Node.js was to support the real-time
    web. The **Comet** application architecture (Comet is related to AJAX, and both
    happen to be names of household cleaning products) involves holding the HTTP connection
    open for a long time, with data flowing back and forth between browser and server
    over that channel. The term Comet was introduced by Alex Russell in his blog in
    2006 ([http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/](http://infrequently.org/2006/03/comet-low-latency-data-for-the-browser/))
    as a general term for the architectural pattern to implement this real-time, two-way
    data exchange between client and server. That blog post called for the development
    of a programming platform very similar to Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the task, we'll lean on the `Socket.IO` library ([http://socket.io/](http://socket.io/)).
    This library simplifies two-way communication between the browser and server,
    and can support a variety of protocols with fallback to old-school web browsers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Real-time communications in modern web browsers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Socket.IO` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating `Socket.IO` with an Express application to support real-time communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: User experience for real-time communication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Socket.IO
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The aim of `Socket.IO` is to make real-time apps possible in every browser and
    mobile device*. *It supports several transport protocols, choosing the best one
    for the specific browser.
  prefs: []
  type: TYPE_NORMAL
- en: If you were to implement your application with WebSockets, it would be limited
    to the modern browsers supporting that protocol. Because `Socket.IO` falls back
    on so many alternate protocols (WebSockets, Flash, XHR, and JSONP), it supports
    a wide range of web browsers, including some old crufty browsers.
  prefs: []
  type: TYPE_NORMAL
- en: As the application author, you don't have to worry about the specific protocol
    `Socket.IO` uses in a given browser. Instead, you can implement the business logic
    and the library takes care of the details for you.
  prefs: []
  type: TYPE_NORMAL
- en: '`Socket.IO` requires that a client library make its way into the browser. That
    library is provided, and is easy to instantiate. You''ll be writing code on both
    the browser side and server side using similar `Socket.IO` APIs at each end.'
  prefs: []
  type: TYPE_NORMAL
- en: The model that `Socket.IO` provides is similar to the `EventEmitter` object.
    The programmer uses the `.on` method to listen for events and the `.emit` method
    to send them. The emitted events are sent between the browser and the server with the
    `Socket.IO` library taking care of sending them back and forth.
  prefs: []
  type: TYPE_NORMAL
- en: Information about `Socket.IO` is available at [https://socket.io/](https://socket.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Initializing Socket.IO with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Socket.IO` works by wrapping itself around an HTTP Server object. Think back
    to [Chapter 4](2e4fd521-22f2-4df0-810c-54c972ed8e6e.xhtml), *HTTP Servers and
    Clients*, where we wrote a module that hooked into HTTP Server methods so that
    we could spy on HTTP transactions. The HTTP Sniffer attaches a listener to every
    HTTP event to print out the events. But what if you used that idea to do real
    work? Socket.IO uses a similar concept, listening to HTTP requests and responding
    to specific ones by using the Socket.IO protocol to communicate with client code
    in the browser.'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, let's first make a duplicate of the code from the previous chapter. If
    you created a directory named `chap08` for that code, create a new directory named
    `chap09` and copy the source tree there.
  prefs: []
  type: TYPE_NORMAL
- en: We won't make changes to the user authentication microservice, but we will use
    it for user authentication, of course.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Notes source directory, install these new modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: We will incorporate user authentication with the `passport` module, used in
    Chapter 8, *Multiuser Authentication the Microservice Way*, into some of the real-time
    interactions we'll implement.
  prefs: []
  type: TYPE_NORMAL
- en: To initialize `Socket.IO`, we must do some major surgery on how the Notes application
    is started. So far, we used the `bin/www.mjs` script along with `app.mjs`, with
    each script hosting different steps of launching Notes. `Socket.IO` initialization
    requires that these steps occur in a different order to what we've been doing.
    Therefore, we must merge these two scripts into one. What we'll do is copy the
    content of the `bin/www.mjs` script into appropriate sections of `app.mjs`, and
    from there, we'll use `app.mjs` to launch Notes.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the beginning of `app.mjs`, add this to the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `passport.socketio` module integrates `Socket.IO` with PassportJS-based
    user authentication. We'll configure this support shortly. The configuration for
    session management is now shared between `Socket.IO`, Express, and Passport. These
    lines centralize that configuration to one place in `app.mjs`, so we can change
    it once to affect every place it's needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this to initialize the HTTP Server object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This moves the `export default app` line from the bottom of the file to this
    location. Doesn't this location make more sense?
  prefs: []
  type: TYPE_NORMAL
- en: The `io` object is our entry point into the `Socket.IO` API. We need to pass
    this object to any code that needs to use that API. It won't be enough to simply
    require the `socket.io` module in other modules because the `io` object is what
    wraps the `server` object. Instead, we'll be passing the `io` object into whatever
    modules are to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `io.use` function installs in `Socket.IO` functions similar to Express
    middleware. In this case, we integrate Passport authentication into `Socket.IO`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This code is copied from `bin/www.mjs`, and sets up the port to listen to.
    It relies on three functions that will also be copied into `app.mjs` from `bin/www.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This changes the configuration of Express session support to match the configuration
    variables we set up earlier. It's the same variables used when setting up the
    `Socket.IO` session integration, meaning they're both on the same page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this to initialize `Socket.IO` code in the router modules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This is where we pass the `io` object into modules that must use it. This is
    so that the Notes application can send messages to the web browsers about changes
    in Notes. What that means will be clearer in a second. What's required is analogous
    to the Express router functions, and therefore the code to send/receive messages
    from `Socket.IO` clients will also be located in the router modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We haven''t written either of these functions yet (have patience). To support
    this, we need to make a change in an `import` statement at the top:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Each router module will export a function named `socketio`, which we'll have
    to rename as shown here. This function is what will receive the `io` object, and
    handle any `Socket.IO`-based communications. We haven't written these functions
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, at the end of `app.mjs`, we''ll copy in the remaining code from `bin/www.mjs`
    so the HTTP Server starts listening on our selected port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in `package.json`, we must start `app.mjs` rather than `bin/www.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you can delete `bin/www.mjs` if you like. You can also try starting
    the server, but it'll fail because the `indexSocketio` function does not exist
    yet.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time updates on the Notes homepage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The goal we're working towards is for the Notes home page to automatically update
    the list of notes, as notes are edited or deleted. What we've done so far is to
    restructure the application startup so that `Socket.IO` is initialized in the
    Notes application. There's no change of behavior yet, except that it will crash
    due to a missing function.
  prefs: []
  type: TYPE_NORMAL
- en: The approach is for the Notes model classes to send messages whenever a note
    is created, updated, or deleted. In the router classes, we'll listen to those
    messages, then send a list of note titles to all browsers attached to the Notes
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Where the Notes model so far has been a passive repository of documents, it
    now needs to emit events to any interested parties. This is the listener pattern
    and, in theory, there will be code that is interested in knowing when notes are
    created, edited, or destroyed. At the moment, we'll use that knowledge to update
    the Notes home page, but there are many potential other uses of that knowledge.
  prefs: []
  type: TYPE_NORMAL
- en: The Notes model as an EventEmitter class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `EventEmitter` is the class that implements listener support. Let''s create
    a new module, `models/notes-events.mjs`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This module maintains the listeners to Notes-related events for us. We've created
    a subclass of `EventEmitter` because it already knows how to manage the listeners.
    An instance of that object is exported as the default export.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now update `models/notes.mjs` to use `notes-events` to emit events. Because
    we have a single module, `notes.mjs`, to dispatch calls to the individual Notes
    models, this module provides a key point at which we can intercept the operations
    and send events. Otherwise, we'd have to integrate the event-sending code into
    every Notes model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We need to `import` this module for use here, but also export it so that other
    modules can also emit Notes events. By doing this, another module that imports
    Notes can call `notes.events.function` to use the `notes-events` module.
  prefs: []
  type: TYPE_NORMAL
- en: This technique is called **re-exporting**. Sometimes, you need to export a function
    from module *A* that is actually defined in module *B*. Module *A* therefore imports
    the function from module *B*, adding it to its exports.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then we do a little rewriting of these functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The contract for the Notes model functions is that they return a `Promise,`
    and therefore our caller will be using `await` to resolve the `Promise.` There
    are three steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Call the corresponding function in the current `model` class, and `await` its
    result
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Send the corresponding message to our listeners
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Return the value, and because this is an `async` function, the value will be
    received as a `Promise` that fulfills the contract for these functions
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Real-time changes in the Notes home page
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Notes model now sends events as Notes are created, updated, or destroyed.
    For this to be useful, the events must be displayed to our users. Making the events
    visible to our users means the controller and view portions of the application
    must consume those events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start making changes to `routes/index.mjs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to reuse part of the original routing function, to use it in another
    function. Therefore, we''ve pulled code that used to be in this block into a new
    function, `getKeyTitlesList`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This portion of the original routing function is now its own function. It generates
    an array of items containing the `key` and `title` for all existing Notes, using
    `Promise.all` to manage the process of reading everything.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here is the `socketio` function we discussed while modifying `app.mjs`. We receive
    the `io` object, then use it to emit a `notestitles` event to all connected browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The `io.of('/namespace')` method restricts whatever follows to the given namespace.
    In this case, we're emitting a `notestitle` message to the `/home` namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The `io.of` method defines what `Socket.IO` calls a namespace. Namespaces limit
    the scope of messages sent through `Socket.IO`. The default namespace is `/`,
    and namespaces look like pathnames, in that they're a series of slash-separated
    names. An event emitted into a namespace is delivered to any socket listening
    to that namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The code, in this case, is fairly straightforward. It listens to the events
    we just implemented, `notecreated`, `noteupdate`, and `notedestroy`. For each
    of these events, it emits an event, `notetitles`, containing the list of note
    keys and titles.
  prefs: []
  type: TYPE_NORMAL
- en: That's it!
  prefs: []
  type: TYPE_NORMAL
- en: As Notes are created, updated, and destroyed, we ensure that the homepage will
    be refreshed to match. The homepage template, `views/index.hbs`, will require
    code to receive that event and rewrite the page to match.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the homepage and layout templates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Socket.IO` runs on both client and server, with the two communicating back
    and forth over the HTTP connection. This requires loading the client JavaScript
    library into the client browser. Each page of the Notes application in which we
    seek to implement `Socket.IO` services must load the client library and have custom
    client code for our application.'
  prefs: []
  type: TYPE_NORMAL
- en: Each page in Notes will require a different `Socket.IO` client implementation,
    since each page has different requirements. This affects how we load JavaScript
    code in Notes.
  prefs: []
  type: TYPE_NORMAL
- en: Initially, we simply put JavaScript code at the bottom of `layout.hbs`, because
    every page required the same set of JavaScript modules. But now we've identified
    the need for a different set of JavaScript on each page. Furthermore, some of
    the JavaScript needs to be loaded following the JavaScript currently loaded at
    the bottom of `layout.hbs`. Specifically, jQuery is loaded currently in `layout.hbs`,
    but we want to use jQuery in the `Socket.IO` clients to perform DOM manipulations
    on each page. Therefore, some template refactoring is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file, `partials/footerjs.hbs`, containing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This had been at the bottom of `views/layout.hbs`. We now need to modify that
    file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, at the bottom of every template (`error.hbs`, `index.hbs`, `login.hbs`,
    `notedestroy.hbs`, `noteedit.hbs`, and `noteview.hbs`), add this line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: So far, this hasn't changed what will be loaded in the pages, because `footerjs`
    contains exactly what was already at the bottom of `layout.hbs`. But it gives
    us the freedom to load `Socket.IO` client code after the scripts in `footerjs`
    are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `views/index.hbs` add this at the bottom, after the `footerjs` partial:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The first line is where we load the `Socket.IO` client library. You'll notice
    that we never set up any Express route to handle the `/socket.io` URL. Instead,
    the `Socket.IO` library did that for us.
  prefs: []
  type: TYPE_NORMAL
- en: Because we've already loaded jQuery (to support Bootstrap), we can easily ensure
    that this code is executed once the page is fully loaded using `$(document).ready`.
  prefs: []
  type: TYPE_NORMAL
- en: This code first connects a `socket` object to the `/home` namespace. That namespace
    is being used for events related to the Notes homepage. We then listen for the
    `notetitles` events, for which some jQuery DOM manipulation erases the current
    list of Notes and renders a new list on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: That's it. Our code in `routes/index.mjs` listened to various events from the
    Notes model, and, in response, sent a `notetitles` event to the browser. The browser
    code takes that list of note information and redraws the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that our browser-side JavaScript is not using ES-2015/2016/2017
    features. This code would, of course, be cleaner if we were to do so. How can
    we know whether our visitors use a browser modern enough for those language features? 
    We could use Babel to transpile ES-2015/2016/2017 code into ES5 code capable of
    running on any browser. However, it may be a useful trade-off to still write ES5
    code in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Running Notes with real-time homepage updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have enough implemented to run the application and see some real-time
    action.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you did earlier, start the user information microservice in one window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in another window, start the Notes application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, in a browser window, go to `http://localhost:3000` and log in to the Notes
    application. To see the real-time effects, open multiple browser windows. If you
    can use Notes from multiple computers, then do that as well.
  prefs: []
  type: TYPE_NORMAL
- en: In one browser window, start creating and deleting notes, while leaving the
    other browser windows viewing the home page. Create a note, and it should show
    up immediately on the home page in the other browser windows. Delete a note and it
    should disappear immediately as well.
  prefs: []
  type: TYPE_NORMAL
- en: Real-time action while viewing notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s cool how we can now see real-time changes in a part of the Notes application.
    Let''s turn to the `/notes/view` page to see what we can do. What comes to mind
    is this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the note if someone else edits it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Redirect the viewer to the home page if someone else deletes the note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allow users to leave comments on the note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the first two features, we can rely on the existing events coming from the
    Notes model. The third feature will require a messaging subsystem, so we'll get
    to that later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `routes/notes.mjs`, add this to the end of the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'At the top of `app.mjs,` make this change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Uncomment that line of code in `app.mjs` because we''ve now implemented the
    function we said we''d get to later:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This sets up the Notes application to send `noteupdate` and `notedestroy` messages
    when notes are updated or destroyed. The destination is the `/view` namespace.
    We'll need to make a corresponding modification to the note view template so it
    does the right thing. This means any browser viewing any note in the application
    will connect to this namespace. Every such browser will receive events about any
    note being changed, even those notes that are not being viewed. This means that
    the client code will have to check the key, and only take action if the event
    refers to the note being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the note view template for real-time action
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we did earlier, in order to make these events visible to the user, we must
    not only add client code to the template, `views/noteview.hbs`; we need a couple
    of small changes to the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We connect to the `/view` namespace where the messages are sent. As `noteupdate`
    or `notedestroy` messages arrive, we check the key to see whether it matches the
    key for the note being displayed.
  prefs: []
  type: TYPE_NORMAL
- en: A technique is used here that's important to understand. We have mixed JavaScript
    executed on the server, with JavaScript executed in the browser. We must compare
    the `notekey` received by the client code against the `notekey` for the note being
    viewed by this page. The latter `notekey` value is known on the server, while
    the former is known in the client.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that code within the `{{ .. }}` delimiters is interpreted by the Handlebars
    template engine on the server. Consider the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This comparison is between the `notekey` value in the browser, which arrived inside
    the message from the server, and the `notekey` variable on the server. That variable
    contains the key of the note being displayed. Therefore, in this case, we are
    able to ensure these code snippets are executed only for the note being shown
    on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: For the `noteupdate` event, we take the new note content and display it on the
    screen. For this to work, we had to add `id=` attributes to the HTML so we could
    use jQuery selectors in manipulating the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: For the `notedestroy` event, we simply redirect the browser window back to the
    home page. The note being viewed has been deleted, and there's no point the user
    continuing to look at a note that no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: Running Notes with real-time updates while viewing a note
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, you can now rerun the Notes application and try this out.
  prefs: []
  type: TYPE_NORMAL
- en: Launch the user authentication server and the Notes application as before. Then,
    in the browser, open multiple windows on the Notes application. This time, have
    one viewing the home page, and two viewing a note. In one of those windows, edit
    the note to make a change, and see the text change on both the home page and the
    page viewing the note.
  prefs: []
  type: TYPE_NORMAL
- en: Then delete the note, and watch it disappear from the home page, and the browser
    window that had viewed the note is now on the home page.
  prefs: []
  type: TYPE_NORMAL
- en: Inter-user chat and commenting for Notes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is cool! We now have real-time updates in Notes as we edit delete or create
    notes. Let's now take it to the next level and implement something akin to inter-user
    chatting.
  prefs: []
  type: TYPE_NORMAL
- en: It's possible to pivot our Notes application concept and take it in the direction
    of a social network. In the majority of such networks, users post things (notes,
    pictures, videos, and so on), and other users comment on those things. Done well,
    these basic elements can develop a large community of people sharing notes with
    each other. While the Notes application is kind of a toy, it's not too terribly
    far from being a basic social network. Commenting the way we will do now is a
    tiny step in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: On each note page, we'll have an area to display messages from Notes users.
    Each message will show the username, a timestamp, and their message. We'll also
    need a method for users to post a message, and we'll also allow users to delete
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Each of those operations will be performed without refreshing the screen. Instead,
    code running inside the web page will send commands to/from the server and take
    actions dynamically.
  prefs: []
  type: TYPE_NORMAL
- en: Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: Data model for storing messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to start by implementing a data model for storing messages. The basic fields
    required are a unique ID, the username of the person sending the message, the
    namespace the message is sent to, their message, and finally a timestamp for when
    the message was sent. As messages are received or deleted, events must be emitted
    from the model so we can do the right thing on the web page.
  prefs: []
  type: TYPE_NORMAL
- en: This model implementation will be written for `Sequelize`. If you prefer a different
    storage solution, you can , by all means, re-implement the same API on other data
    storage systems.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new file, `models/messages-sequelize.mjs`, containing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets up the modules being used and also initializes the `EventEmitter`
    interface. We''re also exporting the `EventEmitter` as `emitter` so other modules
    can use it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This defines our message schema in the database. We'll use the same database
    that we used for Notes, but the messages will be stored in their own table.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `id` field won''t be supplied by the caller; instead, it will be autogenerated.
    Because it is an `autoIncrement` field, each message that''s added will be assigned a
    new `id` number by the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'This is to be called when a user posts a new comment/message. We first store
    it in the database, and then we emit an event saying the message was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This is to be called when a user requests that a message should be deleted.
    With `Sequelize`, we must first find the message and then delete it by calling
    its `destroy` method. Once that''s done, we emit a message saying the message
    was destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: While this is meant to be called when viewing a note, it is generalized to work
    for any Socket.IO namespace. It finds the most recent 20 messages associated with
    the given namespace and returns a cleaned-up list to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Adding messages to the Notes router
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we can store messages in the database, let's integrate this into the
    Notes router module.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `routes/notes.mjs`, add this to the `import` statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If you wish to implement a different data storage model for messages, you''ll
    need to change this `import` statement. You should consider using an environment
    variable to specify the module name, as we''ve done elsewhere:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This pair of routes, `/notes/make-comment` and `/notes/del-message`, is used
    to post a new comment or delete an existing one. Each calls the corresponding
    data model function and then sends an appropriate response back to the caller.
  prefs: []
  type: TYPE_NORMAL
- en: Remember that `postMessage` stores a message in the database, and then it turns
    around and emits that message to other browsers. Likewise, `destroyMessage` deletes
    the message from the database, then emits a message to other browsers saying that
    the message has been deleted. Finally, the results from `recentMessages` will
    reflect the current set of messages in the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both of these will be called by AJAX code in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This is the Socket.IO glue code, which we will add to the code we looked at
    earlier.
  prefs: []
  type: TYPE_NORMAL
- en: The `getnotemessages` message from the browser requests the list of messages
    for the given Note. This calls the `recentMessages` function in the model. This
    uses a feature of Socket.IO where the client can pass a callback function, and
    server-side Socket.IO code can invoke that callback, giving it some data.
  prefs: []
  type: TYPE_NORMAL
- en: We also listen to the `newmessage` and `destroymessage` messages emitted by
    the messages model, sending corresponding messages to the browser. These are sent
    using the method described earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the note view template for messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to dive back into `views/noteview.hbs` with more changes so that we
    can view, create, and delete messages. This time, we will add a lot of code, including
    using a Bootstrap modal popup to get the message, several AJAX calls to communicate
    with the server, and, of course, more Socket.IO stuff.
  prefs: []
  type: TYPE_NORMAL
- en: Using a Modal window to compose messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Bootstrap framework has a Modal component that serves a similar purpose to
    Modal dialogs in desktop applications. You pop up the Modal, it prevents interaction
    with other parts of the web page, you enter stuff into fields in the Modal, and
    then click a button to make it close.
  prefs: []
  type: TYPE_NORMAL
- en: 'This new segment of code replaces the existing segment defining the Edit and Delete
    buttons, in `views/noteview.hbs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This adds support for posting comments on a note. The user will see a Modal
    pop-up window in which they write their comment. We'll show the code for the Modal
    later.
  prefs: []
  type: TYPE_NORMAL
- en: We added a new button labeled Comment that the user will click to start the
    process of posting a message. This button is connected to the Modal by way of
    the element ID specified in the `data-target` attribute. The ID will match the
    outermost `div` wrapping the Modal. This structure of `div` elements and class
    names are from the Bootstrap website at [http://getbootstrap.com/docs/4.0/components/modal/](http://getbootstrap.com/docs/4.0/components/modal/).
  prefs: []
  type: TYPE_NORMAL
- en: Let's add the code for the Modal at the bottom of `views/noteview.hbs`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The key portion of this is the HTML form contained within the `div.modal-body`
    element. It's a straightforward, normal Bootstrap, augmented form with a normal
    Submit button at the bottom. A few hidden `input` elements are used to pass extra
    information inside the request.
  prefs: []
  type: TYPE_NORMAL
- en: With the HTML set up this way, Bootstrap will ensure that this Modal is triggered
    when the user clicks on the Comment button. The user can close the Modal by clicking
    on the Close button. Otherwise, it's up to us to implement code to handle the
    form submission using AJAX so that it doesn't cause the page to reload.
  prefs: []
  type: TYPE_NORMAL
- en: Sending, displaying, and deleting messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that these code snippets are wrapped with `{{#if}}` statements, so that
    certain user interface elements are displayed only to sufficiently privileged
    users. A user that isn't logged in certainly shouldn't be able to post a message.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have a lot of Socket.IO code to add:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: There's another code section to handle the `noteupdate` and `notedestroy` messages.
    This new section has to do with messages that manage the comments.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to handle the form submission for posting a new comment, get the recent
    messages when first viewing a note, listen for events from the server about new
    messages or deleted messages, render the messages on the screen, and handle requests
    to delete a message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The code within `$('form#submit-comment').submit` handles the form submission
    for the comment form. Because we already have jQuery available, we can use its
    AJAX support to POST a request to the server without causing a page reload.
  prefs: []
  type: TYPE_NORMAL
- en: Using `event.preventDefault`, we ensure that the default action does not occur.
    For the FORM submission, that means the browser page does not reload. What happens
    is an HTTP POST is sent to `/notes/make-comment` with a data payload consisting
    of the values of the form's `input` elements. Included in those values are three
    hidden inputs, `from`, `namespace`, and `key`, providing useful identification
    data.
  prefs: []
  type: TYPE_NORMAL
- en: If you refer to the `/notes/make-comment` route definition, this calls `messagesModel.postMessage`
    to store the message in the database. That function then posts an event, `newmessage`,
    which our server-side code forwards to any browser that's connected to the namespace.
    Shortly after that, a `newmessage` event will arrive in browsers.
  prefs: []
  type: TYPE_NORMAL
- en: The `newmessage` event adds a message block, using the `formatMessage` function.
    The HTML for the message is `prepend`ed to `#noteMessages`.
  prefs: []
  type: TYPE_NORMAL
- en: When the page is first loaded, we want to retrieve the current messages. This
    is kicked off with `io('/view').emit('getnotemessages', ..`. This function, as
    the name implies, sends a `getnotemessages` message to the server. We showed the
    implementation of the server-side handler for this message earlier, in `routes/notes.mjs`.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, we said that Socket.IO supports the provision of a callback
    function that is called by the server in response to an event. You simply pass
    a function as the last parameter to a `.emit` call. That function is made available
    at the other end of the communication, to be called when appropriate. To make
    this clear, we have a callback function on the browser being invoked by server-side
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the server-side calls our callback function with a list of messages.
    The message list arrives in the client-side callback function, which displays
    them in the `#noteMessages` area. It uses jQuery DOM manipulation to erase any
    existing messages, then renders each message into the messages area using the
    `formatMessage` function.
  prefs: []
  type: TYPE_NORMAL
- en: The message display template, in `formatMessage`, is straightforward. It uses
    a Bootstrap `card` to give a nice visual effect. And, there is a button for deleting
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: In `formatMessage` we created a Delete button for each message. Those buttons
    need an event handler, and the event handler is set up using the `connectMsgDelButton`
    function. In this case, we send an HTTP POST request to `/notes/del-message`.
    We again use the jQuery AJAX support to post that HTTP request.
  prefs: []
  type: TYPE_NORMAL
- en: The `/notes/del-message` route in turn calls `messagesModel.destroyMessage`
    to do the deed. That function then emits an event, `destroymessage`, which gets
    sent back to the browser. As you see here, the `destroymessage` event handler
    causes the corresponding message to be removed using jQuery DOM manipulation.
    We were careful to add an `id=` attribute to every message to make removal easy.
  prefs: []
  type: TYPE_NORMAL
- en: Since the flip side of destruction is creation, we need to have the `newmessage`
    event handler sitting next to the `destroymessage` event handler. It also uses
    jQuery DOM manipulation to insert the new message into the `#noteMessages` area.
  prefs: []
  type: TYPE_NORMAL
- en: Running Notes and passing messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: That was a lot of code, but we now have the ability to compose messages, display
    them on the screen, and delete them, all with no page reloads.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can run the application as we did earlier, first starting the user authentication
    server in one command-line window and the Notes application in another:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e3ac8ba6-abbb-4615-8d9a-9af3c4f8a538.png)'
  prefs: []
  type: TYPE_IMG
- en: 'While entering a message, the Modal looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a33f878-6dae-46fd-8e49-c12b911d91e5.png)'
  prefs: []
  type: TYPE_IMG
- en: Try this with multiple browser windows viewing the same note or different notes.
    This way, you can verify that notes show up only on the corresponding note window.
  prefs: []
  type: TYPE_NORMAL
- en: Other applications of Modal windows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We used a Modal and some AJAX code to avoid one page reload due to a form submission.
    In the Notes application, as it stands, a similar technique could be used when
    creating a new note, editing existing notes, and deleting existing notes. In each
    case, we would use a Modal, some AJAX code to handle the form submission, and
    some jQuery code to update the page without causing a reload.
  prefs: []
  type: TYPE_NORMAL
- en: But wait, that's not all. Consider the sort of dynamic real-time user interface
    wizardry on the popular social networks. Imagine what events and/or AJAX calls
    are required.
  prefs: []
  type: TYPE_NORMAL
- en: When you click on an image in Twitter, it pops up, you guessed it, a Modal window
    to show a larger version of the image. The Twitter Compose new Tweet window is
    also a Modal window. Facebook uses many different Modal windows, such as when
    sharing a post, reporting a spam post, or while doing a lot of other things Facebook's
    designers deem to require a pop-up window.
  prefs: []
  type: TYPE_NORMAL
- en: Socket.IO, as we've seen, gives us a rich foundation of events passing between
    server and client that can build multiuser, multichannel communication experiences
    for your users.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we came a long way in this chapter, maybe Facebook doesn't have anything
    to fear from the baby steps we took toward converting the Notes application into
    a social network. This chapter gave us the opportunity to explore some really
    cool technology for pseudo real-time communication between browser sessions.
  prefs: []
  type: TYPE_NORMAL
- en: Look up the technical definition for the phrase *real time* and you'll see the
    real-time web is not truly real time. The actual meaning of real time involves
    software with strict time boundaries that must respond to events within a specified
    time constraint. Real-time software is typically used in embedded systems to respond
    to button presses, for applications as diverse as junk food dispensers and medical
    devices in intensive care units. Eat too much junk food and you could end up in
    intensive care, and be served by real-time software in both cases. Try and remember
    the distinction between different meanings for this phrase.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you learned about using Socket.IO for pseudo real-time web
    experiences, using the `EventEmitter` class to send messages between parts of
    an application, jQuery, AJAX, and other browser-side JavaScript technologies,
    while avoiding page reloads while making AJAX calls.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look into Node.js application deployment on real
    servers. Running code on our laptop is cool, but to hit the big time, the application
    needs to be properly deployed.
  prefs: []
  type: TYPE_NORMAL
