<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Practical – an E-mail Client</h1></div></div></div><p>Our past two applications have been fairly straightforward examples, but ones that are useful to illustrate how to create a strong foundation for a future, more extensive product. In this chapter, we'll build a<a id="id325" class="indexterm"/> fully featured webmail client that will provide a tailored experience for users of both desktop browsers and smaller devices such as tablets.</p><p>Everyone knows the traditional e-mail interface, but we'll try and at the same time show how Ext JS technologies can be used to make short work of building such an application. Here's the breakdown of what we'll be doing in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Establishing essential requirements for the application</li><li class="listitem" style="list-style-type: disc">Coming up with an ideal user interface for each form factor</li><li class="listitem" style="list-style-type: disc">Analyzing the issues that may arise on a smaller screen</li><li class="listitem" style="list-style-type: disc">Designing the view and controller structure to present and orchestrate it all</li><li class="listitem" style="list-style-type: disc">Evaluating the design of our application</li></ul></div><p>Along the way we'll reinforce our knowledge of routing and view models, as well as undertaking constant re-evaluation of our work to ensure the quality of the code.</p><p>We'll also take a little more time to finish the design of this application, dipping our toe in the water of Ext JS theming. While we won't be building a full replacement theme, we'll touch on some of the places where the theming system should be used in order to improve the maintainability of your application.</p><div><div><div><div><h1 class="title"><a id="ch07lvl1sec68"/>Form factors</h1></div></div></div><p>This <a id="id326" class="indexterm"/>application will adapt to a variety of devices, from desktop browsers to tablets and mobile phones. The size of these devices is often called the "form factor" and Ext JS provides several mechanisms that allow you to customize the user experience depending on the form factor of the device being used.</p><p>In this chapter, we'll focus on <code class="literal">responsiveConfig</code>, an option available when you include the <code class="literal">Ext.mixin.Responsive</code> class in your views. In a standard desktop application, we might have two components side by side in the viewport, since desktop screen sizes are generally <a id="id327" class="indexterm"/>wider than they are tall. On a mobile phone, users will often be in portrait orientation, so this is no longer true; the screen is taller than it is wide. In this case, we can use <code class="literal">responsiveConfig</code> to override the original side-by-side configuration and use different layouts, items, and component widths—in fact any aspect of the original viewport configuration—and change the appearance and behavior of the application for a taller screen.</p><p>This one feature provides us with an exceptionally powerful means to deliver an experience that is tailored to a particular form factor. In this chapter, we'll see some practical examples of <a id="id328" class="indexterm"/>implementing <code class="literal">responsiveConfig</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec69"/>Application design</h1></div></div></div><p>What <a id="id329" class="indexterm"/>features <a id="id330" class="indexterm"/>do we expect from an e-mail client? At a minimum:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Login</strong>: This helps to gain access to your own account</li><li class="listitem" style="list-style-type: disc"><strong>Inbox</strong>: This is a list of our e-mails</li><li class="listitem" style="list-style-type: disc"><strong>Sent</strong>: This is a list of e-mails we've sent in the past</li><li class="listitem" style="list-style-type: disc"><strong>Archive</strong>: This is a list of e-mails we've disposed of</li><li class="listitem" style="list-style-type: disc"><strong>Composer</strong>: This helps to write e-mails</li><li class="listitem" style="list-style-type: disc"><strong>Search</strong>: This helps to find archived e-mails</li></ul></div><p>The final version of the app looks something like this:</p><div><img src="img/5308OT_07_01.jpg" alt="Application design"/><div><p>The thread view on the left and messages from the selected thread on the right</p></div></div><p>What<a id="id331" class="indexterm"/> do <a id="id332" class="indexterm"/>we need to do to get to this point? Let's sketch out a design:</p><div><img src="img/5308OT_07_02.jpg" alt="Application design"/></div><p>The login page<a id="id333" class="indexterm"/> is pretty standard. We'll want to validate user input, check the e-mail address, and ensure the password isn't blank, but there really isn't anything out of the ordinary here:</p><div><img src="img/5308OT_07_03.jpg" alt="Application design"/></div><p>Here's the main interface<a id="id334" class="indexterm"/> for the application. We'll be implementing threaded e-mail; we have a list of threads on the left with an excerpt of the most recent message showing as the description of the thread. The date of the last message is shown on the left-hand side of each thread. On the right-hand side, we show the selected message thread, most recent message last. Each message has its received date on its left. The thread has a <strong>Reply</strong> button and a dropdown to allow the thread to be tagged, more on this shortly.</p><p>At the top of the screen we have a logo (from left to right), an icon for the <strong>Contacts</strong> section, a <strong>search</strong> bar, a button to create a new e-mail, and finally, a dropdown to filter threads by tag.</p><p>The <strong>search</strong> bar will cause matching message threads to appear below (in the same style as the <strong>Inbox</strong> view).</p><p>Rather than having separate screens for archived e-mail, sent e-mail, and so on, we make the assumption that <strong>Inbox</strong> threads are just untagged threads. When they are tagged—either automatically as "sent" or by some other arbitrary tag such as "home" or "work"—then they are removed from the <strong>Inbox</strong> view, as shown in the following screenshot. This concept is<a id="id335" class="indexterm"/> found in many e-mail clients, for example, Gmail.</p><div><img src="img/5308OT_07_04.jpg" alt="Application design"/></div><p>When composing new e-mails, it takes place in the right-hand position. As there is no selected thread at this time, the space is clear to be occupied by a panel that contains a combo box to choose a recipient for the e-mail, a basic HTML editor for the e-mail itself, and a <strong>Send</strong> button.</p><p>Replying to an e-mail works in a similar way; the composer panel appears under the messages and allows the user to write a response.</p><p>A couple more items to note are that the user will start off with a number of default tags:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Draft</li><li class="listitem" style="list-style-type: disc">Archive</li><li class="listitem" style="list-style-type: disc">Spam</li><li class="listitem" style="list-style-type: disc">Work</li><li class="listitem" style="list-style-type: disc">Home</li></ul></div><p>When selecting a tag for a thread, the user can easily add another by typing in the combo box.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec70"/>I require to admire</h1></div></div></div><p>As <a id="id336" class="indexterm"/>architects<a id="id337" class="indexterm"/> of a product, we always need to consider how to make our product exemplary, how to make sure the user experience is a good one, how to exceed the expectations of our stakeholders. The starting step is to work out in exacting detail the facets on the product we'd like to build.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec76"/>Technically speaking</h2></div></div></div><p>How do the <a id="id338" class="indexterm"/>requirements we've spelled out translate into the underlying tech?</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We want to display a login form with a "remember me" feature, so we need some kind of persistent storage</li><li class="listitem" style="list-style-type: disc">We want to display thread data in a custom format</li><li class="listitem" style="list-style-type: disc">We want to display full message threads in a custom format</li><li class="listitem" style="list-style-type: disc">We want a basic HTML editor for message bodies</li><li class="listitem" style="list-style-type: disc">We need an autocomplete box for recipients</li><li class="listitem" style="list-style-type: disc">We need to display search results in the same format as message threads</li><li class="listitem" style="list-style-type: disc">We need an autocomplete box for tags to be used in various locations</li></ul></div><p>Let's translate each of these into <a id="id339" class="indexterm"/>Ext JS features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can use cookies or local storage to hold login information between systems (either using native browser methods or an Ext JS-powered session class)</li><li class="listitem" style="list-style-type: disc">We can use an Ext JS DataView to create a templated view of thread data</li><li class="listitem" style="list-style-type: disc">We can use an Ext JS DataView to create a templated view of message data</li><li class="listitem" style="list-style-type: disc">Ext JS provides an HTML editor widget</li><li class="listitem" style="list-style-type: disc">The Ext JS combo box can be powered by a store that retrieves remote contact data</li><li class="listitem" style="list-style-type: disc">We can reuse the message thread DataView with a different store</li><li class="listitem" style="list-style-type: disc">We can use the <code class="literal">editable:true</code> option of the Ext JS combo box in cases where we need to add new tags</li></ul></div><p>There are a couple of gray areas there that we'll review later, but it does look like Ext JS can provide all of the features we're going to need to build this application.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec71"/>Responding to the situation</h1></div></div></div><p>There's another requirement<a id="id340" class="indexterm"/> in this project: a responsive design <a id="id341" class="indexterm"/>that works on devices with smaller screens. Well, it turns out that the UI we've come up with already looks pretty good on a tablet, with one caveat. You have to be holding the device in landscape mode. This is a problem that you don't really have to consider on the desktop, but it becomes critical with mobile devices.</p><p>From an architectural standpoint, we need to understand how the layout of the application will differ between screen sizes in order to decide how to assemble the application. In the designs so far, there are two panes side by side; there simply won't be enough screen space to allow for this on a portrait phone or tablet.</p><p>Instead, we'll hide or show the "left" and "right" panes depending on user actions. If they click on a thread of messages or the <strong>New Message</strong> button, the threads will be hidden and the correct right-hand pane will appear.</p><p>The only other issue with a portrait screen is the application header; there are too many components in there to fit in the width of a smaller screen. Instead, we'll show a menu button when in portrait mode that hides some controls when toggled and shows others. This gives us a second level of menu that's only shown when the user needs it. Here's a mockup of some of these ideas:</p><div><img src="img/5308OT_07_07.jpg" alt="Responding to the situation"/></div><p>When clicking <a id="id342" class="indexterm"/>on one of the messages in the left screenshot, the list is replaced by the message thread seen in the right-hand side screenshot.</p><p>In an HTML-based responsive website, CSS media queries can be used to style the page in a fashion appropriate for any screen and orientation. While we can obviously still make use of CSS alongside Ext JS to do customization, our requirements are more complex; can Ext JS provide any extra features to assist?</p><p>The <code class="literal">responsive</code> plugin allows developers to tailor any component configuration based on a set of rules relating to the current device screen. Here are a few example scenarios in a theoretical responsive application:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If the screen is less than 500 pixels wide, collapse the sidebar panel by default</li><li class="listitem" style="list-style-type: disc">If the screen is in landscape mode, show a new column of data</li><li class="listitem" style="list-style-type: disc">If the device is an iOS tablet, apply a different CSS class</li></ul></div><p>In the<a id="id343" class="indexterm"/> webmail application, we've already mentioned showing and hiding header items. This can be done something like this:</p><div><pre class="programlisting">{ 
    xtype: 'button', text: 'My Button',
    plugins: ['responsive'],
    responsiveConfig: {
        'portrait': { hidden: true } 
    }
}</pre></div><p>There's a built-in rule called "portrait" that allows you to specify a configuration object that will only be applied when the rule is in effect. As architects, we must carefully consider the best way of making use of this feature without ending up with lots of messy configuration.</p><p>In the desktop version of the application we have two panes side by side. For this, we can use the <code class="literal">hbox</code> layout. However, for the portrait orientation, we'd like to be able to switch between one pane and another. This seems like a good use of the card layout. We'll also have to consider how to trigger the switch of the panes and have this code run in portrait orientation only.</p><p>The important takeaway is that the responsive plugin—in a similar fashion to view models—allows you to avoid writing lots of glue code that responds to the state of the application environment, and instead lets us declare our intentions at configuration time. After this, Ext JS takes care of most of the rest.</p><p>This is another example in which analyzing the requirements with a strong understanding of the available technology can result in a simpler architecture and a clearer code base.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec72"/>Input required</h1></div></div></div><p>In previous<a id="id344" class="indexterm"/> chapters, we've gone into detail about the API we're going to be communicating with. There's no denying that it's one of the key parts of any application design; in fact many projects can live or die based on the quality of the API they're integrating with, but we've discussed this in the past two chapters and we've still got a lot to cover. From here on, we're generally going to assume that we're working with a well-designed RESTful API that works well with Ext JS. This'll give us some room to concentrate on some new ideas.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>That's not to say you can skip over the API when designing your application. It is very rare you'll be working with a perfect backend, so keep analyzing whether the server is providing the endpoints you need.</p></div></div><p>We'll move <a id="id345" class="indexterm"/>on to looking at the rest of the application, but in a different way to previous chapters; once the data's been pulled down from the server, we'll try and consider how it's going to move through our app. We'll also look at two other facets of the design in more detail: routing and events. Why this change in direction compared to previous chapters?</p><p>As our applications become more complicated, we have to continually think about how to keep that complexity under control. These three features: view models, events, and routing, all allow a "fire and forget" attitude, wire up some basic configuration, trigger an action at the source, and this bit of code is done. Somewhere else in the application will subscribe to this action—be it a view model binding, a routing change or the firing of an event—and consume it accordingly.</p><p>We'll first identify our views and controllers as we have in the past and look at how this will inform the routing, view models and events that will power the functionality of our application.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec73"/>A view to a thrill</h1></div></div></div><p>Let's break <a id="id346" class="indexterm"/>down the major <a id="id347" class="indexterm"/>views that will make up the main screen of the application:</p><div><img src="img/5308OT_07_05.jpg" alt="A view to a thrill"/><div><p>1: header view, 2: thread view, 3: message view, and 4: composer view; main view encompasses views 1 - 4</p></div></div><p>The login view<a id="id348" class="indexterm"/> is the simplest; a self-contained view, view controller, and a view model to bind with the values of the login form. It's not shown in the preceding mockup because it's the only one on the screen at the time, almost standalone.</p><p>There's a caveat to this. For the first time, we'll be using an over-arching controller to deal with the interactions between views. In the previous chapter, this was left to the "main" view controller, since the "main" view was the container for every part of our application. Here, the login view and the rest of the application are effectively independent from each other and so it makes sense to have a "third party" helping them to work together.</p><p>We'll call this top-level controller our "root" controller. It's not a view controller, but a completely self-contained class that is responsible for showing the login view and reacting to a successful login. To formalize this:</p><div><pre class="programlisting">Postcard.controller.RootController: extends Ext.app.Controller
- onLaunch -&gt; check for valid login
- onLoginSuccess -&gt; show main view</pre></div><p>The login view controller<a id="id349" class="indexterm"/> is responsible for processing a login attempt and after doing so, it will fire off the appropriate actions. Along with its view and view model, it looks like this:</p><div><pre class="programlisting">Postcard.view.login.Login: extends Ext.window.Window
- items[]
    - e-mail: extends Ext.form.Text
    - password: extends Ext.form.Text
    - rememberMe: extends Ext.form.Checkbox
    - submit: extends Ext.Button

Postcard.view.login.LoginModel: extends Ext.app.ViewModel
- e-mail
- password
- rememberMe

Postcard.view.login.LoginController: extends Ext.app.ViewController
- onLoginClick
</pre></div><p>Assuming the <code class="literal">onLoginClick</code> method is successful, we'll move on to the main screen of the application.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec77"/>Mainly harmless</h2></div></div></div><p>As in previous chapters, the main view<a id="id350" class="indexterm"/> is the viewport that contains the other views in the application, such as the application header and the list of threads. According to our design, the view should look like this:</p><div><pre class="programlisting">Postcard.view.main.Main: extends Ext.Panel
- items[]
    - app-header: extends Ext.Container
    - threads: extends Ext.DataView
    - container: extends Ext.Container
        - items[]
            - messages: Ext.Container
            - composer: Ext.form.Panel
</pre></div><p>A couple of things to note here, the primary views that make up our application are mentioned here: header, threads, messages and, composer. We're also doing a bit of forward <a id="id351" class="indexterm"/>thinking regarding our design, in that the composer and messages views are enclosed in a separate container.</p><p>This will allow us to more easily work with the Ext JS layout system, having the threads view and this anonymous container in an <code class="literal">hbox</code> arrangement. The view model looks like this:</p><div><pre class="programlisting">Postcard.view.main.MainModel: extends Ext.app.ViewModel
- currentTag
- searchTerm</pre></div><p>It's just convenient for a few pieces of state that need to be shared between the views contained in the main view. The view controller looks like this:</p><div><pre class="programlisting">Postcard.view.main.MainController: extends Ext.app.ViewController
- onLogout
- onHome
- onShowThread
- onNewThread
- onNewMessage</pre></div><p>The first method (<code class="literal">onLogout</code>) will handle clicks on a logout button. The next four methods on the main view controller will be triggered by routing, and will be responsible for setting changes in the state of the application.</p><p>Remember that the main view and its associated classes don't really have any functionality of their own; they're responsible for orchestrating all of the other application parts contained within.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec78"/>Full steam ahead</h2></div></div></div><p>The first child view of the main viewport is the <a id="id352" class="indexterm"/>header view, containing a number of components that are available anywhere in the application as follows:</p><div><pre class="programlisting">Postcard.view.header.Header: Ext.Toolbar
- items[]
    - homebutton: extends Ext.Button
    - searchfield: extends Ext.form.TextField
    - tagfilter: extends Ext.form.ComboBox
    - newmessagebutton: extends Ext.Button
    - menubutton: extends Ext.Button
</pre></div><p>There's actually a surprising amount happening here. We also have to bear in mind that this is the target for one of our portrait orientation pieces of functionality, so there will be some usage of the responsive plugin in our implementation, as shown in the following code:</p><div><pre class="programlisting">Postcard.view.header.HeaderController: extends Ext.app.ViewController
- onHomeClick
- onNewMessageClick</pre></div><p>These methods are <a id="id353" class="indexterm"/>event listeners that will in turn trigger further functionality. You might wonder why we don't have handlers to toggle the menu open and closed or to choose an item from the combo box. Think about data binding. If we bind the state of the menu button and the combo box to a view model, other components can bind to the values in the view model and will receive updates without us having to write any glue code. To this end, the header view model will look like:</p><div><pre class="programlisting">Postcard.view.header.HeaderModel: extends Ext.app.ViewModel
- tags</pre></div><p>Nothing more than a store to populate the tag filter combo box. We'll talk about this use of data binding further when we come to implement the header.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec79"/>Threading our way</h2></div></div></div><p>A thread is <a id="id354" class="indexterm"/>just a fancy way of saying "a collection of e-mail messages". We're going to use <a id="id355" class="indexterm"/>
<code class="literal">Ext.DataView</code> for this:</p><div><pre class="programlisting">Postcard.view.threads.Threads: extends Ext.DataView
- stripHtml</pre></div><p>We're going to support HTML e-mails in this application, but to prevent the thread view from looking messy, we'll strip out this HTML before presenting it to the user. Other than this, it's a normal implementation of DataView.</p><div><pre class="programlisting">Postbox.view.threads.ThreadsModel: extends Ext.app.ViewModel
- threads</pre></div><p>The view model contains the thread store that powers the view as follows:</p><div><pre class="programlisting">Postcard.view.threads.ThreadsController: extends
Ext.app.ViewController
- onThreadClick</pre></div><p>There's only a single method here, one that is triggered by the <code class="literal">itemclick</code> event on the thread DataView. It'll be responsible for redirecting the user to a list of messages in this thread.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec80"/>Send me a message</h2></div></div></div><p>The message view<a id="id356" class="indexterm"/> is responsible for showing the messages that make up a thread. As such, it's mainly based on DataView. It's a little more complicated than this though because DataView doesn't inherit from <code class="literal">Ext.Panel</code>; it can't have its own child items or docked toolbar.</p><p>In this case, we need to have some tools at the bottom of the message list in order to change the thread tag and send a reply. Therefore, we wrap the DataView in a panel:</p><div><pre class="programlisting">Postcard.view.messages.Messages: extends Ext.Panel
- items[]
    - panel: extends Ext.Panel
        - items[]
            - messagelist: extends Ext.DataView
        - bbar[]
            - tagpicker: extends Ext.form.ComboBox
            - reply: extends Ext.Button</pre></div><p>In the view model, we need two stores: one for the messages in the thread, and one for the tags that are available to choose from.</p><div><pre class="programlisting">Postcode.view.messages.MessagesModel: extends Ext.app.ViewModel
- messages
- threads</pre></div><p>The view controller has a couple of event handlers to manage the user's interactions with the message view:</p><div><pre class="programlisting">Postcard.view.messages.MessagesController: extends Ext.app.ViewController
- onReplyClick
- onNewThread
- onShwThread
- onTagChange</pre></div><p>There's now only one missing piece to this application—how do we write new messages?</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec81"/>Stay composed</h2></div></div></div><p>The composer view<a id="id357" class="indexterm"/> is responsible for writing new messages and writing replies. It needs several UI components to accomplish this:</p><div><pre class="programlisting">Postcard.view.composer.Composer: extends Ext.form.Panel
- items[]
    - recipients: extends Ext.form.ComboBox
    - subject: extends Ext.form.TextField
    - message: extends Ext.form.HtmlEditor
</pre></div><p>Recipients and subject won't be used if the composer is replying to an existing thread. It will only be used when creating a new thread:</p><div><pre class="programlisting">Postcard.view.Composer.ComposerModel: extends Ext.app.ViewModel
- items[]
    - contacts
    - newMessage
</pre></div><p>We have <a id="id358" class="indexterm"/>a store of contacts to power the recipients' field, and an object to store the form values as the user enters them:</p><div><pre class="programlisting">Postcard.view.composer.ComposerController: extends
Ext.app.ViewController
- onSendClick</pre></div><p>The view controller will be responsible for saving the message to the server, which in turn would send it to the designated recipients.</p><p>We don't exactly have an address book in this application; instead, any previously used e-mail addresses are just saved and are available to pick in future messages.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec82"/>Design overview</h2></div></div></div><p>We <a id="id359" class="indexterm"/>skipped over a lot of the data layer design this time around because it was very "boilerplate" in nature and we'd discussed such things in previous chapters. Why go through the class design process for the views and their associated view controllers and view models then? We've done this in previous chapters as well.</p><p>Clearly, every application is different. Breaking it down in this way helps us flesh out the code we're going to write without actually writing any code. This is important, because we'll avoid thinking too hard about the details of the implementation and have a better understanding of the shape of the larger pieces in the puzzle.</p><p>The next step is to revisit routes, events, and data flow and see how these large pieces will work together.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec74"/>Application state</h1></div></div></div><p>First <a id="id360" class="indexterm"/>up is routing. We said in <a class="link" href="ch06.html" title="Chapter 6. Practical – Monitoring Dashboard">Chapter 6</a>, <em>Practical – Monitoring Dashboard</em>, that the route is a way of keeping part of the application's state in the URL. Another way of looking at this is that as the application changes through its various states, you are walking through the screens that the user would see as they interact with the interface.</p><p>By working <a id="id361" class="indexterm"/>out the various<a id="id362" class="indexterm"/> high-level states of our application, we can better visualize the user flow and establish the routes that we can employ in our code.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec83"/>Home screen/initial load</h2></div></div></div><p>This is <a id="id363" class="indexterm"/>displayed straight after login and represents the default state of the main screen of the application before the user interacts with it. It looks as follows:</p><div><pre class="programlisting"> Route: /#home</pre></div><p>The views will have the following state:</p><div><pre class="programlisting">view.threads.Main.activeItem = 'threads'</pre></div><p>If we're in portrait view, we'll use a card layout.</p><div><div><h3 class="title"><a id="note15"/>Note</h3><p>"Card" is one of the build-Ext JS layouts, which allows you to easily switch out one component for another. It's also the basis for the <code class="literal">Ext.TabPanel</code> component.</p></div></div><p>This means that the home state of the application needs to have the thread view as the active item:</p><div><pre class="programlisting">view.main.Main.rightPane.hidden = true</pre></div><p>In the initial state on a normal device, the user has neither selected a message nor has chosen to compose a new message. Therefore, there's nothing showing in the right-hand pane.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec84"/>New thread</h2></div></div></div><p>The route that handles requests for a <a id="id364" class="indexterm"/>new thread is displayed in the following command:</p><div><pre class="programlisting">Route: thread/new</pre></div><p>When the user presses the new message button, they are shown the composer view. The overall state changes as follows:</p><div><pre class="programlisting">view.main.Main.activeItem = 'rightPane'
view.composer.Composer.hidden = false
view.messages.Messages.hidden = true</pre></div><p>Remember <a id="id365" class="indexterm"/>that changing route doesn't mean that the state reverts to the initial state and then changes; we need to reset all things that could potentially have been shown by another route. In this case, if the user previously selected a thread, then the messages view would be showing, and we need to hide it when creating a new message.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec85"/>Show thread</h2></div></div></div><p>The route to handle <a id="id366" class="indexterm"/>requests for a specific message thread is as follows:</p><div><pre class="programlisting">Route: thread/:id/messages</pre></div><p>It's triggered when the user selects a thread as follows:</p><div><pre class="programlisting">view.main.Main.activeItem = 'rightPane'
view.messages.Messages.hidden = false
view.composer.Composer.hidden = true
view.main.MainModel.currentThreadId = :id</pre></div><p>Pretty much the opposite of a new message in which the messages are shown and the composer is hidden. The thread that was selected needs to be made available to the components that require it, in this case, the message view, so it can load the required messages.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec86"/>New message/reply</h2></div></div></div><p>The <a id="id367" class="indexterm"/>route to handle requests for a new message thread is as follows:</p><div><pre class="programlisting">Route: thread/:id/messages/new</pre></div><p>This is the final route in our application, and is used when a thread has been selected and then the user clicks on the "reply" button.</p><div><pre class="programlisting">view.main.Main.activeItem = 'rightPane'
view.messages.Messages.hidden = false
view.composer.Composer.hidden = false
view.main.MainModel.currentThreadId = :id</pre></div><p>Similar to the "show thread" route, except that the composer is shown as well as the messages view.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec87"/>Routing overview</h2></div></div></div><p>Examining<a id="id368" class="indexterm"/> the paths a user can take through your application can be a very valuable way of making sure nothing is missing from your design. It also gives the site the benefit of understanding the state of your application at various points on the path and allows you to translate this into routes to restore that state.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec75"/>A binding agreement</h1></div></div></div><p>Some <a id="id369" class="indexterm"/>of the state <a id="id370" class="indexterm"/>of the application is held in the URL, but other transient state is held in view models. We're going to look at an example of how data flows through this application in order to better understand how powerful data binding can be.</p><p>In portrait mode, our application has a menu button that toggles the visibility of various other components. The pseudocode for this could be:</p><div><pre class="programlisting">if menu_button_is_pressed
   this.find('searchfield').show()
   this.find('newmessagebutton').hide()
   this.find('logo').hide()
else 
   this.find('searchfield').hide()
   this.find('newmessagebutton').show()
   this.find('logo').show()
end</pre></div><p>Code like this isn't complicated, but it's lengthy and error prone, a chore to write. Instead, we can use data binding to avoid this type of code and set up the behavior during configuration, something like this:</p><div><pre class="programlisting">[
    {
   	      xtype: 'button', reference: 'menubutton',
   	      enableToggle: true
   	},
    {
         xtype: 'searchfield', 
         bind: { 
               hidden: '{menubutton.pressed}'
         }
    }
]</pre></div><p>There are a couple of things to understand here: firstly that a button will "publish" the state of its <code class="literal">pressed</code> value. Whenever <code class="literal">pressed</code> changes, either programmatically or because the user clicked on the button, the value will be pushed to the view model for this button. Secondly, if a component has its <code class="literal">reference</code> set, this will be available to access its published values in the view model.</p><p>Combine both of these and the bind configuration on the search field becomes clear; bind the value of <code class="literal">hidden</code> on the search field to the value of <code class="literal">pressed</code> on the menu button. If <code class="literal">pressed</code> is <code class="literal">true</code>, the search field will be hidden.</p><p>While we've <a id="id371" class="indexterm"/>covered data binding and view models in some detail in previous chapters, this is the first time we've looked at this particular approach. It's not even necessary to specify any configuration on the view model itself as long as one is available somewhere in the component hierarchy, this will work.</p><p>This is another weapon in the armory of tools that allow us to simplify our code. Using this kind of declarative approach, where we specify what we'd like to happen, but don't have to say how it happens, we can avoid writing methods like the pseudocode earlier and use a standardized approach that Ext JS provides.</p><p>The tricky part is fully embracing data binding and the view model concept. By thinking up-front about the dependencies between components and channeling data through view models, powerful interactions can be created with very little code.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec76"/>An eventful application</h1></div></div></div><p>An<a id="id372" class="indexterm"/> interesting<a id="id373" class="indexterm"/> observation about both routing and data binding is that they are built around events. When a route changes, an event is fired and a controller listens to it, setting the application's state accordingly. When a property is data bound, Ext JS publishes its changes and other properties listen for these changes.</p><p>We're also familiar with events, such as <code class="literal">click</code>, <code class="literal">select</code>, <code class="literal">show</code>, and so on, that are fired from the various Ext JS components. It would seem that as events are being used everywhere in an Ext JS application, we might as well make use of them ourselves!</p><p>We can use <code class="literal">fireEvent</code> from every <code class="literal">Observable</code> class in Ext JS. This allows you to fire a custom event from pretty much anywhere in our application. In previous versions of Ext JS, you needed to define events beforehand using an <code class="literal">addEvent</code> method, but this is no longer the case. However, what <a id="id374" class="indexterm"/>use is this? Does it offer a real-world advantage? Let's look at some bad code to demonstrate:</p><div><pre class="programlisting">// Theoretical "messages" view controller
message.save({
    success: function(response) {
          var viewport = Ext.ComponentQuery.query('viewport')[0];
          
          // Refresh the list of records after adding this one.
          viewport.down('list').getStore().reload();

          viewport.showMessage(response.message);

          this.lookupReference('editor').hide();
   },
   scope: this
});</pre></div><p>We save a message record. Then, in the callback, reload a list store, show a message in the viewport, and hide an editor component.</p><p>That's three separate things, only one of which—hiding the editor—is probably in the right place. The others should be handled by their own view controllers. This code would be much better:</p><div><pre class="programlisting">message.save({
    success: function(response) {
          this.fireEvent('messagesaved', response.message.id);
   },
   scope: this
});</pre></div><p>Now, any code anywhere in the application can listen for a <code class="literal">messagesaved</code> event and proceed accordingly. The key benefit this brings is that this example message view controller doesn't have to know anything about any other views, controllers, or even anything about the rest of the application.</p><p>This makes the messages view and view controller much more resistant to any changes in the rest of the system and much easier to test. In theory, it could be pulled out of the application and tested standalone.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec88"/>Events and you</h2></div></div></div><p>Let's go back to our webmail application. There's no point in adding events—or indeed anything—to our code base unless we're going to use them. A lot of places where we could use custom events will be rendered unnecessary by data binding and rendered unnecessary by routing.</p><p>There is <a id="id375" class="indexterm"/>one place that a custom event will be useful: when creating a reply. The composer controller is responsible for this, but when the reply's been saved we also need to refresh the messages view so that we can see the reply. This is a perfect place to make use of a custom event. We'll see how this is implemented shortly.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec77"/>Coding – it's been a long time</h1></div></div></div><p>We've spent a lot of<a id="id376" class="indexterm"/> time examining this proposed application and thinking about the techniques we can use to create it in an elegant way. Now, it's time to start building it.</p><p>We<a id="id377" class="indexterm"/> mentioned that the data layer for this application is very straightforward with lots of boilerplate code and nothing that is unexpected based on the knowledge we've gained in previous chapters. Let's jump straight in:</p><div><pre class="programlisting">// app/model/BaseModel.js
Ext.define('Postcard.model.BaseModel', {
    extend: 'Ext.data.Model',
    schema: {
        namespace: 'Postcard.model',
        urlPrefix: 'http://localhost:3000',
        proxy: {
            type: 'rest',
            url: '{prefix}/{entityName:uncapitalize}'
        }
    },
});

// app/model/Contact.js
Ext.define('Postcard.model.Contact', {
    extend: 'Postcard.model.BaseModel',
    fields: [
        { name: 'e-mail' }
    ]
});

// app/model/Message.js
Ext.define('Postcard.model.Message', {
    extend: 'Postcard.model.BaseModel',
    fields: [
        { name: 'id' },
        { name: 'people' },
        { name: 'subject' },
        { name: 'body' },
        { name: 'date', type: 'date' },
        { name: 'tag' }
    ]
});

// app/model/Tag.js
Ext.define('Postcard.model.Tag', {
    extend: 'Postcard.model.BaseModel',
    fields: [
        { name: 'name' }
    ]
});

// app/model/Thread.js
Ext.define('Postcard.model.Thread', {
    extend: 'Postcard.model.BaseModel',
    fields: [
        { name: 'id' },
        { name: 'people' },
        { name: 'subject' },
        { name: 'lastMessageOn', type: 'date' },
        { name: 'lastMessageSnippet' }
    ]
});</pre></div><p>Four<a id="id378" class="indexterm"/> models: <code class="literal">Contact</code>, <code class="literal">Tag</code>, <code class="literal">Message</code>, and <code class="literal">Thread</code>, all extend a <code class="literal">BaseModel</code> class that contains our data schema. Note that the <code class="literal">BaseModel</code> class specifies a rest proxy, so we know what to expect from the load and save behavior on <a id="id379" class="indexterm"/>our models. This is completely standard and very familiar from our previous example applications. The stores are correspondingly straightforward:</p><div><pre class="programlisting">// app/store/Contacts.js
Ext.define('Postcard.store.Contacts', {
    extend: 'Ext.data.Store',
    model: 'Postcard.model.Contact',
    alias: 'store.contacts',
    autoLoad: true
});

// app/store/Tags.js
Ext.define('Postcard.store.Tags', {
    extend: 'Ext.data.Store',
    model: 'Postcard.model.Tag',
    alias: 'store.tags',
    autoLoad: true
});

// app/store/Messages.js
Ext.define('Postcard.store.Messages', {
    extend: 'Ext.data.Store',
    model: 'Postcard.model.Message',
    alias: 'store.messages'
});

// app/store/Threads.js
Ext.define('Postcard.store.Threads', {
    extend: 'Ext.data.Store',
    autoLoad: true,
    model: 'Postcard.model.Thread',
    alias: 'store.threads'
});</pre></div><p>There is <a id="id380" class="indexterm"/>one<a id="id381" class="indexterm"/> store for each model class; everything apart from messages will load automatically because we need them across the application and they don't require any parameters to be passed to them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec78"/>It's under control</h1></div></div></div><p>The data<a id="id382" class="indexterm"/> fundamentals are in place, so let's look at a feature we'll be using for the first time in this <a id="id383" class="indexterm"/>application: the <code class="literal">Controller</code>. Not a view controller this time, but the over-arching application controller we talked about in our design:</p><div><pre class="programlisting">// app/controller/Root.js
Ext.define('Postcard.controller.Root', {
    extend: 'Ext.app.Controller',

    routes: {
        'home': 'onHome',
        '': 'checkLogin'
    },

    onLaunch: function() {
        this.checkLogin();
    },

    checkLogin: function() {
        if(!window.localStorage.getItem('loggedin')) {
            this.loginWindow = Ext.create('Postcard.view.login.Login');
        } else {
            Ext.create('Postcard.view.main.Main');
        }
    },

    onHome: function() {
        if(this.loginWindow) {
            this.loginWindow.destroy();
        }

        this.checkLogin();
    }
});</pre></div><p>In previous examples, <code class="literal">app/Application.js</code> has been responsible for creating the viewport that represents the main view of the application. In this case, the root controller takes on this role. We override its <code class="literal">onLaunch</code> method to detect whether the user is logged in, regardless of the route they are on. It also specifies the default URL for the application (just an empty string) and again checks for a valid login.</p><p>When a valid login is detected, the main view is shown, otherwise the login is shown. This is a super-simple mechanism to create a crude login system.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec79"/>Login view</h1></div></div></div><p>The <a id="id384" class="indexterm"/>login view<a id="id385" class="indexterm"/> is a window centered in the screen that contains a number of fields. Their values are bound to a login object on the view model, as shown in the following code:</p><div><pre class="programlisting">Ext.define('Postcard.view.login.Login',{
    extend: 'Ext.window.Window',
    xtype: 'login-window',

    title: 'Login to Postcard',
    closable: false,
    autoShow: true,
    
    controller: 'login',
    viewModel: 'login',
    items: [{
        xtype: 'textfield',
        name: 'e-mail',
        bind: '{login.e-mail}',
        fieldLabel: 'E-mail',
        allowBlank: false
    }, {
        xtype: 'textfield',
        bind: '{login.password}',
        inputType: 'password',
        fieldLabel: 'Password',
        allowBlank: false
    }, {
        xtype: 'checkbox',
        bind: '{login.rememberMe}',
        fieldLabel: 'Remember Me?'
    }],

    buttons: [{ text: 'Login' }]
});</pre></div><p>Note the <code class="literal">controller</code> and <code class="literal">ViewModel</code> configuration options and the prefix of the bind values that links to the login object on the view model. Speaking of which:</p><div><pre class="programlisting">Ext.define('Postcard.view.login.LoginModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.login',
    data: {
        login: {}
    }
});</pre></div><p>Nothing<a id="id386" class="indexterm"/> is<a id="id387" class="indexterm"/> happening here other than defining this login object. Let's move on to the view controller:</p><div><pre class="programlisting">Ext.define('Postcard.view.login.LoginController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.login',

    listen: {
        component: {
            'button': {
                click: function() {
                    window.localStorage.setItem('loggedin', true);
                    this.redirectTo('home');
                }
            }
        }
    }
});</pre></div><p>The view controller does nothing more than listen for the <code class="literal">click</code> event on the login form's button and then fake a successful login. For simplicity, this application doesn't do any validation of user details, so we just instantly fire a redirect to the home route.</p><p>We saw earlier that the root controller handles the home token, which removes the login view and creates the main view. Let's move on and take a look at that now.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec80"/>Main force</h1></div></div></div><p>Looking back at our design, the <a id="id388" class="indexterm"/>main view<a id="id389" class="indexterm"/> is the container for the rest of the UI in our application. It looks like this:</p><div><pre class="programlisting">// app/view/main/Main.js
Ext.define('Postcard.view.main.Main', {
    extend: 'Ext.Panel',
    xtype: 'app-main',
    plugins: ['viewport', 'responsive'],
    controller: 'main',
    viewModel: 'main',
    session: true,

    responsiveConfig: {
        'tall': {
            layout: {
                type: 'card'
            }
        },

        'wide': {
            layout: {
                type: 'hbox',
                align: 'stretch'
            }
        }
    },

    dockedItems: [
        { xtype: 'app-header' },
        { 
            dock: 'bottom', xtype: 'button', cls: 'logout', 
            overCls: '', focusCls: '', text: 'Logout'
        }
    ],

    items: [
        { xtype: 'threads', flex: 1 },
        {
            xtype: 'container',
            flex: 1,
            defaults: { hidden: true },
            items: [
                { xtype: 'messages' },
                { xtype: 'composer' }
            ]
        }
    ],

    isCard: function() {
        return this.getLayout().type === 'card';
    }
});</pre></div><p>There's a <a id="id390" class="indexterm"/>lot going on here, but only a couple of new concepts. Note that we have added a couple of plugins to this class: <code class="literal">viewport</code> and <code class="literal">responsive</code>. As we didn't let our application auto create a view as a <code class="literal">viewport</code>, adding the <code class="literal">viewport</code> plugin will do just that. The <code class="literal">responsive</code> plugin allows you to use the <code class="literal">responsiveConfig</code> option, which we discussed earlier in the chapter.</p><p>In this<a id="id391" class="indexterm"/> instance, on screens that are tall, that is, higher than they are wide, such as portrait screens, we use a card layout. On screens that are wide, that is, wider than they are high, we use an <code class="literal">hbox</code> layout because there's a lot more horizontal space. This simple declarative way of setting up a responsive view has allowed us to make very distinct changes to our application with only a few lines of configuration.</p><p>We've added a utility method to this view to help with manipulating our responsive setup; the <code class="literal">isCard</code> view will let us neatly determine whether this view is using a <code class="literal">card</code> layout or <code class="literal">hbox</code> layout.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>Syntactic sugar is an alternative way of writing something that makes it easier to read or allows it to better express its intent. The <code class="literal">isCard</code> method is an example of this, not strictly necessary, but it makes the calling code shorter and easier to understand.</p></div></div><p>The rest of this configuration should be very familiar: two <code class="literal">dockedItems</code>, one is the application header view and another supplying a logout button, and the three other views of this application in the items array.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec89"/>Main ViewModel</h2></div></div></div><p>On first glance, the code for this will look pretty standard, but when you look back at the code for the main view itself, you notice that <code class="literal">currentTag</code> or <code class="literal">searchTerm</code> is not going to be used anywhere. So, why define them if they're not going to be used? Refer to <code class="literal">ViewModel</code>
<a id="id392" class="indexterm"/> in the following code:</p><div><pre class="programlisting">// app/view/main/MainModel.js
Ext.define('Postcard.view.main.MainModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.main',

    data: {
        currentTag: 'Inbox',
        searchTerm: null
    }
});</pre></div><p>In Ext JS, we have the concept of parent and child view models. The main view model, configured on the main view, will become available to all child components of the main view. This means that subviews can get data on the main view and also pass information back up to it. This is a fantastic way of passing data between two child components.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec90"/>Main ViewController</h2></div></div></div><p>Refer to<a id="id393" class="indexterm"/> <code class="literal">ViewController</code> in the following code:</p><div><pre class="programlisting">// app/view/main/MainController.js
Ext.define('Postcard.view.main.MainController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.main',

    routes: {
        'thread/new': 'showRightPane',
        'thread/:id/messages': 'showRightPane',
        'thread/:id/messages/new': 'showRightPane'
    },

    listen: {
        component: {
            'button[cls="logout"]': {
                click: function() {
                    window.localStorage.removeItem('loggedin');
                    window.location = '/';
                }
            }
        }
    },

    showRightPane: function(id) {
        if(this.getView().isCard()) {
            this.getView().setActiveItem(1);
        }
    }
});</pre></div><p>The most<a id="id394" class="indexterm"/> interesting thing happening in here is the route handlers; we're giving several routes to the <code class="literal">showRightPane</code> handler. Looking back at our examination of user flow and routes in our application, many of the routes need us to ensure that the right-hand panel is in view. This only applies to the responsive portrait view, so we only change the active panel if the portrait view's card layout is available.</p><p>The interesting part is that we've got route handlers that only do part of what we'd expect. Where are the bits that pass IDs and show subviews? Don't worry, we'll revisit this shortly.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec81"/>The head of the family</h1></div></div></div><p>Refer<a id="id395" class="indexterm"/> to the<a id="id396" class="indexterm"/> <code class="literal">Header.js</code> file:</p><div><pre class="programlisting">// app/view/header/Header.js
Ext.define('Postcard.view.header.Header', {
    extend: 'Ext.Toolbar',
    requires: ['Postcard.view.header.HomeButton'],
    xtype: 'app-header',
    height: 60,
    controller: 'header',
    viewModel: 'header',
    session: true,
    items: [
        { 
            xtype: 'home-button', cls: 'title', html: 'Postcard',
            bind: { hidden: '{menuButton.pressed}' }
        },
        {
            xtype: 'tbspacer',
            bind: { hidden: '{menuButton.pressed}' } },
        { 
            xtype: 'textfield', flex: 1,
            cls: 'search-box', emptyText: 'Search', 
            bind: '{searchTerm}',
            plugins: ['responsive'],
            responsiveConfig: {
                'tall': { 
                    hidden: true,
                    bind: { hidden: '{!menuButton.pressed}' }
                }, 
                'wide': { hidden: false } 
            }
        },
        { 
            xtype: 'tbfill',
            bind: { hidden: '{menuButton.pressed}' }
        },
        { 
            xtype: 'combobox', flex: 1, editable: false,
            displayField: 'name', idField: 'name', 
            queryMode: 'local', forceSelection: true,
            bind: {
                store: '{tags}', value: '{currentTag}'
            },
            plugins: ['responsive'],
            responsiveConfig: {
                'tall': {
                    hidden: true,
                    bind: { hidden: '{!menuButton.pressed}' }
                }, 
                'wide': { hidden: false } 
            }
        },
        { 
            xtype: 'button', cls: 'new-message',
            text: 'New Message',
            bind: { 
                hidden: '{menuButton.pressed}'
            }
        },
        { 
            text: 'Menu', reference: 'menuButton',
            width: 30, enableToggle: true,
            plugins: ['responsive'],

            responsiveConfig: {
                'tall': { hidden: false }, 
                'wide': { hidden: true } 
            }
        }
    ]
});</pre></div><p>Wow! That's <a id="id397" class="indexterm"/>actually a lot of code for a header bar! Look back at<a id="id398" class="indexterm"/> our original class design for this view and we did say there was "a surprising amount happening", so we weren't wrong.</p><p>In the section, <em>A binding agreement</em> we discussed a cut-down example of what is happening in this class. The <code class="literal">reference</code> option on the menu button is used to allow the other header components to bind to the menu's pressed value; look at the previous code and you'll see this approach used in various places to show or hide components when the menu button is toggled.</p><p>We're not only using the responsive plugin again mostly to set the initial hidden state of the header components, but also using it to make sure the hidden config is only bound when the viewport is tall. This avoids issues with initial visibility of other components when the menu button isn't even in use. This kind of conditional binding opens up some exciting possibilities.</p><p>A couple more things of note: we mentioned the main view model had some values that seemed unused. Well, here they are, bound to the values of the tag filter combo and the search text field. When these values change, they'll be passed up to the main view model and available for use by other components.</p><p>There's a final item of note: a mysterious home-button component. The code for this looks like this:</p><div><pre class="programlisting">Ext.define('Postcard.view.header.HomeButton', {
    extend: 'Ext.Container',
    xtype: 'home-button',

    afterRender: function() {
        this.callParent(arguments);
        this.getEl().on('click', function() {
            this.fireEvent('click');
        }, this);
    }
});</pre></div><p>We're using<a id="id399" class="indexterm"/> this as a fake button, extending the simple <a id="id400" class="indexterm"/>container to fire a <code class="literal">click</code> event. This allows you to get a lightweight, unstyled, and clickable component to use as a home button.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec91"/>Header ViewModel</h2></div></div></div><p>Refer to <a id="id401" class="indexterm"/>
<code class="literal">ViewModel</code> in the following code:</p><div><pre class="programlisting">Ext.define('Postcard.view.header.HeaderModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.header',
    stores: {
        tags: {
            type: 'tags',
            session: true
        }
    }
});</pre></div><p>This <code class="literal">ViewModel</code> class supplies the tags to populate the tag filter combo. We use a session to make sure that we're using the same tag instances across the application.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec92"/>Header ViewController</h2></div></div></div><p>Refer to<a id="id402" class="indexterm"/> <code class="literal">ViewController</code> in the following code:</p><div><pre class="programlisting">// app/view/header/HeaderController.js
Ext.define('Postcard.view.header.HeaderController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.header',
    listen: {
        component: {
            'button[cls="new-message"]': {
                click: function() {
                    this.redirectTo('thread/new');
                }
            },

            'home-button': {
                click: function() {
                    this.redirectTo('home');
                }
            }
        },

        controller: {
            '*': {
                tagadded: function() {
                    this.getViewModel().get('tags').reload();
                }
            }
        }
    }
});</pre></div><p>There are two <a id="id403" class="indexterm"/>component event listeners, one on the new message button and one on the home button. Both redirect to routes that will be consumed by other controllers.</p><p>There's also a controller listener that waits for a <code class="literal">tagadded</code> event and refreshes the tag store on <code class="literal">ViewModel</code>. This is great because we don't have to worry about where this event comes from or which component issued it; we just consume it in isolation and perform the action we're interested in.</p><p>The reverse applies too, meaning the issuer of the <code class="literal">tagadded</code> event doesn't need to work out how to refresh the tag filter combo; instead, it can just declare that a tag was added and rest easy.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec82"/>Unravel the thread</h1></div></div></div><p>A <a id="id404" class="indexterm"/>thread<a id="id405" class="indexterm"/> is a collection of e-mail messages, and the thread view makes up the left-hand pane of our application. It looks something like this:</p><div><pre class="programlisting">// app/view/threads/Threads.js
Ext.define('Postcard.view.threads.Threads', {
    extend: 'Ext.DataView',
    xtype: 'threads',
    cls: 'thread-view',
    viewModel: 'threads',
    controller: 'threads',
    border: true,
    deferEmptyText: false,
    emptyText: 'No messages',
    autoScroll: true,
    itemSelector: '.thread',
    bind: '{threads}'
    tpl: new Ext.XTemplate('&lt;tpl for="."&gt;',
        '&lt;div class="thread"&gt;',
            '&lt;div class="date"&gt;{lastMessageOn:date("H:m")}&lt;/div&gt;',
            '&lt;div class="details"&gt;',
                '&lt;div class="header"&gt;{people} - {subject}&lt;/div&gt;',
                '&lt;div class="body"&gt;{[this.stripHtml(values.lastMessageSnippet)]}&lt;/div&gt;',
            '&lt;/div&gt;',
        '&lt;/div&gt;',
    '&lt;/tpl&gt;', {
        stripHtml: function(html) {
            var div = document.createElement('div');
            div.innerHTML = html;
            return div.textContent || div.innerText || '';
        }
    })
});</pre></div><p>We knew from our design work that we would use a DataView for this class and its implementation turns out to be fairly straightforward. We're binding its store to the threads store on the view model itself also called as threads.</p><p>Look back at the design and you'll see that we anticipated a method to strip HTML from the message body <a id="id406" class="indexterm"/>and here it is; a little bit of trickery that uses a temporary DOM element to let the browser do the work for us.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec93"/>Thread ViewModel</h2></div></div></div><p>Refer to<a id="id407" class="indexterm"/> <code class="literal">ViewModel</code> in the following code:</p><div><pre class="programlisting">// app/view/threads/ThreadsModel.js
Ext.define('Postbox.view.threads.ThreadsModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.threads',
    stores: {
        threads: {
            type: 'threads',
            remoteFilter: true,
            filters: [
                {
                    property: 'tag',
                    value: '{currentTag}'
                },
                {
                    property: 'searchTerm',
                    value: '%{searchTerm}%'
                }
            ]
        }
    }
});</pre></div><p>This is actually the most complicated view model in the whole application and most of this complexity should be familiar from <a class="link" href="ch06.html" title="Chapter 6. Practical – Monitoring Dashboard">Chapter 6</a>, <em>Practical – Monitoring Dashboard</em>. The filter array, along with the <code class="literal">remoteFilter</code> setting, will be responsible for sending a JSON object containing a filter definition through to the server. In this case, we see that we are consuming values from the main view model as broadcast up by the tag picker combo and search field in the header.</p><p>We talked about this before, but it's worth highlighting again. The data flows from the header view to the main view model and then into the thread view. This is an incredibly simple way of communicating between parts of an application without these parts needing to be aware of each other.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec94"/>Thread ViewController</h2></div></div></div><p>Refer to <a id="id408" class="indexterm"/>
<code class="literal">ViewController</code> in the following code:</p><div><pre class="programlisting">// app/view/threads/ThreadController.js
Ext.define('Postcard.view.threads.ThreadsController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.threads',

    listen: {
        component: {
            'threads': {
                itemclick: function(dataview, record) {
                    this.redirectTo('thread/' + record.getId() + '/' + 'messages');
                }
            }
        },

        controller: {
            '*': {
                threadschanged: function() {
                    this.getViewModel().get('threads').reload();
                }
            }
        }
    }
});</pre></div><p>More of these event listeners, and so on. We knew they'd come in handy, but they're everywhere! In the thread view controller, we listen for the DataView's <code class="literal">itemclick</code> event and simply redirect the application off so that another controller's route can take care of it. Fire and forget.</p><p>In turn, we listen for a <a id="id409" class="indexterm"/>
<code class="literal">threadschanged</code> event, which is issued when a thread is added. This allows you to refresh the DataView's store in the view model to see the effects of the added thread. We don't know or care where <code class="literal">threadschanged</code> came from.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec83"/>I am the best message</h1></div></div></div><p>Refer to the<a id="id410" class="indexterm"/> <code class="literal">Messages.js</code> file<a id="id411" class="indexterm"/> in the following code:</p><div><pre class="programlisting">// app/view/messages/Messages.js
Ext.define('Postcard.view.messages.Messages', {
    extend: 'Ext.Panel',
    xtype: 'messages',
    controller: 'messages',
    viewModel: 'messages',
    autoScroll: true,
    session: true,
    bbar: [
        {
            xtype: 'combobox', displayField: 'name',
            idField: 'name',
            reference: 'tagPicker',
            queryMode: 'local', value: 'Inbox',
            bind: { store: '{tags}' }
        },
        {
            text: 'Set Tag',
            itemId: 'setTag'
        },
        '-&gt;',
        {
            text: 'Reply',
            itemId: 'reply',
            reference: 'replyButton'
        }
    ],
    items: [{
        xtype: 'dataview',
        bind: '{messages}',
        flex: 1,
        cls: 'message-view',
        tpl: new Ext.XTemplate('&lt;tpl for="."&gt;',
            '&lt;div class="message"&gt;',
                '&lt;div class="date"&gt;{date:date("H:m")}&lt;/div&gt;',
                '&lt;div class="details"&gt;',
                    '&lt;tpl if="xindex == 1"&gt;',
                    '&lt;div class="header"&gt;{people} - {subject}&lt;/div&gt;',
                    '&lt;/tpl&gt;',
                    '&lt;div class="body"&gt;{body}&lt;/div&gt;',
                '&lt;/div&gt;',
            '&lt;/div&gt;',
        '&lt;/tpl&gt;'),
        itemSelector: '.message'
    
});</pre></div><p>In an ideal <a id="id412" class="indexterm"/>situation, the code should flow out of your team as the culmination of the design process. Any difficult classes or methods should have been part of a code spike. Your data layer would have been designed on top of your backend API. User interface has been described in wireframes, user stories provide routing, and so on.</p><p>This is what we're <a id="id413" class="indexterm"/>seeing now. As seasoned Ext JS developers, we know how to configure a combo box and a store. This book is not here to help with that. We're going to continue to focus on the design and the decisions that make your code simple.</p><p>Look at the previous class. The design of the messages view with its DataView nested inside a panel allows you to use a <code class="literal">bbar</code>; we knew about this before we even wrote a line of code. This is the crux of a good design. With developers who understand the technology they are working with, implementations become easy and predictable because it's all been thought about in advance.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec95"/>Messages ViewModel</h2></div></div></div><p>Refer to <a id="id414" class="indexterm"/>
<code class="literal">ViewModel</code> in the following code:</p><div><pre class="programlisting">// app/view/messages/MessagesModel.js
Ext.define('Postcode.view.messages.MessagesModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.messages',
    stores: {
        messages: {
            type: 'messages'
        },

        tags: {
            type: 'tags',
            session: true
        }
    }
});</pre></div><p>See! With an up-front design, you can pass the documentation over to a developer and have them create<a id="id415" class="indexterm"/> the messages view model. There's little scope for error because the shape of the class has already been decided.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec96"/>Messages ViewController</h2></div></div></div><p>Having said that, there <a id="id416" class="indexterm"/>are times when the code is lengthy, so a breakdown of what's happening really helps as shown here:</p><div><pre class="programlisting">// app/view/messages/MessagesController.js
Ext.define('Postcard.view.messages.MessagesController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.messages',

    listen: {
        component: {
            '#reply': {
                click: 'onReplyClick'
            },

            '#setTag': {
                click: 'onTagChange'
            }
        }
    },

    routes: {
        'thread/:id/messages': 'onShowThread',
        'thread/new': 'onNewThread'
    },

    onShowThread:function(id) {
        this.getViewModel().get('messages').load({
            params: {
                parentId: id
            },
            callback: function(records) {
                this.getView().show();
            },
            scope: this
        });
    },

    onNewThread: function() {
        this.getView().hide();
    },

    onReplyClick: function() {
        this.redirectTo(window.location.hash + '/new');
    },

    onTagChange: function() {
        var tagPicker = this.lookupReference('tagPicker'),
            newTag = tagPicker.getValue(),
            viewModel = this.getViewModel(),
            threadParent = viewModel.get('messages').getAt(0);

        threadParent.set('tag', newTag);
        threadParent.save({
            callback: function() {
                this.getViewModel().get('tags').reload();
                this.fireEvent('tagadded');
                this.fireEvent('threadschanged');
            },
            scope: this
        });
    }
});</pre></div><p>As usual, we <a id="id417" class="indexterm"/>have our event listeners. Let's look at the component ones; firstly the one that handles the reply button's <code class="literal">click</code> event as it's straightforward. It just redirects to a route that will take care of setting up the application to reply to a thread.</p><p>Next, there's the <code class="literal">onTagChange</code> method that handles a click on the "set tag" button. This will get the selected value from the tag combo box and set it as the tag for the first message in the thread. Then, it saves that message to the server.</p><p>Note the<a id="id418" class="indexterm"/> callback for this save request (it fires off two events that we've seen before). One (<code class="literal">threadschanged</code>) notifies the application that threads have changed in some way; in this case, it's a thread's tag that has changed, so a thread list may need to be refreshed. The other (<code class="literal">tagadded</code>) signifies that there may be a new tag and any interested classes should refresh their tag data accordingly.</p><p>The next two handlers are for routes, but there's something to note here. These routes have already been handled by the main view controller! This is a powerful feature; we can handle routes in multiple locations so that the classes that are interested in this route can do their own thing. This avoids us having to do all of the work in the main view controller, for example, the messages view controller can take care of loading the messages rather than doing so in the main view controller.</p><p>Compare using routes in this way to using events. They're very similar; we can redirect to a route, fire this redirect and forget about it, or else, where in the application a controller will handle this route. With routes, you get the added benefit of keeping state in the URL, thus enabling bookmark support. With events, you can send complex data in the event arguments. Both have their strengths.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec84"/>A composed finish</h1></div></div></div><p>Now, we<a id="id419" class="indexterm"/> come to the view that allows you to actually <a id="id420" class="indexterm"/>send e-mails, a pretty important part of this application!</p><div><pre class="programlisting">// app/view/composer/Composer.js
Ext.define('Postcard.view.composer.Composer', {
    extend: 'Ext.form.Panel',
    xtype: 'composer',
    cls: 'composer',
    viewModel: 'composer',
    controller: 'composer',
    session: true,
    items: [
        { xtype: 'hiddenfield', bind: '{newMessage.parentId}' },
        {
            fieldLabel: 'To', xtype: 'combo', width: '100%',
            valueField: 'e-mail',
            displayField: 'e-mail',
            queryMode: 'local',
            bind: {
                hidden: '{newMessage.parentId}',
                store: '{contacts}',
                value: '{newMessage.people}'
            }
        },
        {
            xtype: 'textfield', fieldLabel: 'Subject',
            cls: 'subject', emptyText: 'Subject',
            bind: {
                value: '{newMessage.subject}',
                hidden: '{newMessage.parentId}'
            },
            width: '100%'
        },
        {
            xtype: 'htmleditor',
            bind: { value: '{newMessage.body}' }
        }
    ],
    bbar: [
        '-&gt;',
        { xtype: 'button', text: 'Send' }
    ]
});</pre></div><p>Another <a id="id421" class="indexterm"/>straightforward component definition, with the values of the form fields being bound to the <code class="literal">newMessage</code> object in the view model <a id="id422" class="indexterm"/>for later use. There's another view model trick here, that is, if this <code class="literal">newMessage</code> object has a <code class="literal">parentId</code> value, we know that we're replying to an existing thread. This means that we can hide the subject and recipient form fields, so we bind the <code class="literal">parentId</code> to their hidden value, making this step automatic as follows:</p><div><pre class="programlisting">// app/view/composer/ComposerModel.js
Ext.define('Postcard.view.Composer.ComposerModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.composer',
    stores: {
        contacts: {
            type: 'contacts'
        }
    },

    data: {
        newMessage: {}
    }
});</pre></div><p>We have the contacts <a id="id423" class="indexterm"/>store that corresponds to <a id="id424" class="indexterm"/>the one in the view that was bound to the recipient's combo and then an empty definition for the <code class="literal">newMessage</code> object discussed previously.</p><div><pre class="programlisting">// app/view/composer/ComposerController.js
Ext.define('Postcard.view.composer.ComposerController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.composer',
    listen: {
        component: {
            'button': {
                click: 'onSendClick'
            }
        }
    },

    routes: {
        'thread/:id/messages': 'hideComposer',
        'thread/:id/messages/new': 'showComposer',
        'thread/new': 'showComposer'
    },

    hideComposer: function() {
        this.getView().hide();
    },

    showComposer: function(parentId) {
        this.getViewModel().set('newMessage.parentId', parentId);
        this.getView().show();
    },

    onSendClick: function() {
        var session = this.getSession(),
            data = this.getViewModel().get('newMessage');

        session.createRecord('Postcard.model.Message', {
            people: data.people,
            subject: data.subject,
            body: data.body,
            parentId: data.parentId
        });

        var batch = session.getSaveBatch().start();

        batch.on('complete', this.onSaveComplete, this);
    },

    onSaveComplete: function(batch, operation) {
        var record = operation.getRecords()[0],
            id = record.getId(),
            parentId = record.get('parentId');

        this.redirectTo('thread/' + (parentId || id) + '/messages');
    }
});</pre></div><p>In component <a id="id425" class="indexterm"/>listeners, we <a id="id426" class="indexterm"/>handle the <code class="literal">click</code> event of the send button with the <code class="literal">onSendClick</code> method. This creates a new record on the current session and saves it to the server. In the <code class="literal">callback</code> method, we dispatch the application to the route that shows thread messages, but note that we'll use the ID of the new message in the event of it being a brand new thread and the <code class="literal">parentID</code> of the new message if it's a reply.</p><p>In terms of handling routes, there's one (<code class="literal">hideComposer</code>) that hides the composer when viewing the messages in a thread because there's no need for it to be visible at that point. Then, there's a second (<code class="literal">showComposer</code>) that sets the <code class="literal">parentId</code> on the <code class="literal">newMessage</code> and shows the composer. For new threads, there's no ID captured by the route, so the <code class="literal">parentId</code> argument will be undefined and <code class="literal">newMessage.parentId</code> will be set as such. This enables the automatic viewing and hiding of the recipient and subject back in the composer view itself. Back when designing the app, we referred to this as <code class="literal">currentThreadId</code>, but we can see now that it makes sense to incorporate it in the <code class="literal">newMessage</code> object and pass this to the server when we save the new record.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec85"/>Deciding on a theme</h1></div></div></div><p>We've <a id="id427" class="indexterm"/>covered all of the parts of this application apart from one: the<a id="id428" class="indexterm"/> way it looks. Cast your mind back to the screenshot of the app in action earlier in the chapter. In fact, have a look at the login screen to see how it differs from a standard Ext JS app:</p><div><img src="img/5308OT_07_06.jpg" alt="Deciding on a theme"/></div><p>We've changed key things such as the font and color of the window frame, but take a look at the code to perform this:</p><div><pre class="programlisting">// sass/etc/all.scss
$body-font-family: 'Roboto', sans-serif;
$window-base-color: #fff;
$window-header-color: #000;
$window-padding: 20px;
$window-header-font-family: $body-font-family;
$toolbar-footer-background-color: #fff;
$form-label-font-family: $body-font-family;</pre></div><p>Ext JS themes provide an extensive range of variables designated by the dollar sign in front of them. By defining our own, such as <code class="literal">$body-font-family</code>, and overriding existing ones, we can easily shape the look of our application to suit different requirements.</p><p>Not only this, but<a id="id429" class="indexterm"/> from a maintenance point of view, it's far preferable to set a few variables than it's to write a swathe of CSS rules to override theme style sheets. We can avoid problems like CSS precedence and finding the correct selectors to use and get on with making our app stand out. However, if we need to, we can drop down to use SASS, the CSS-like compiler that Ext JS uses for theming. Take a look at the styling for the thread view:</p><div><pre class="programlisting">// sass/src/view/threads/Threads.scss
.thread-view {
   font-family: $body-font-family;
   margin: $gutters;

   .x-view-item-focused {
          outline: 0 !important;

         .header {
               color: rgb(255, 20, 108);
         }
   }

   .header {
         font-size: 125%;
   }

   .body {
         font-size: 105%;
         color: #666;
         padding: 10px 0;
         line-height: 160%;
   }

   .date {
         color: $subdued-grey;
         font-size: 150%;
         padding: 0 15px;
         font-weight: bold
   }
}

.thread {
   display: flex;
   padding: 50px;

   &amp;:hover {
          cursor: pointer;
   }

   .details {
          border-bottom: 1px solid $subdued-grey;
   }

   &amp;:last-child .details {
          border-bottom: 0 !important;
   }

   .date {
          width: 80px;
          text-align: right;
   }
    .details {
          flex: 1;
   }
}</pre></div><p>The thread view <a id="id430" class="indexterm"/>is a DataView, meaning its template can contain any custom HTML. Writing new SASS rules makes sense here, but Ext JS allows you to do this in a modular and reusable way, similar to the features it provides to write JavaScript classes. In the next few chapters, we'll discuss this and other features of theming in more depth.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec86"/>Summary</h1></div></div></div><p>We've taken a different approach to designing and implementing this application. Rather than discussing the same details we have in previous chapters, we've avoided retreading old ground and talked about a higher level of architecture.</p><p>By implementing routes, view model bindings, and events more extensively than ever before, we've shown how a declarative approach to Ext JS can simplify our code and make it incredibly easy to understand. At the same time, components that issue and listen to events are more decoupled, leading to fewer bugs and increased testability.</p><p>We also touched on theming, showing how a few lines of code can dramatically affect the look of an app and how we can write custom style rules to create brand new components.</p><p>In the next chapter, we'll continue to explore the architectural ideas we've used already, but expanding them to look at how to make best use of them in the design phase. We'll look at how Ext JS architecture applies to theming and how we can continue to improve our code reuse all across our application.</p></div></body></html>