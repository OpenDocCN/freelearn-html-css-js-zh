- en: Click-Click Boom! Applying Interactivity to Your Map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you learned what is needed to build a basic map with
    D3.js. We also discussed the concepts of enter, update, and exit and how they
    apply to maps. You should also understand how D3 mixes and matches HTML with data.
    However, let's say you want to take it a step further and add more interactivity
    to your map. We covered only the tip of the iceberg regarding click events in
    the previous chapter. Now, it's time to dig deeper.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will expand our knowledge of events and event types. We
    will progress by experimenting and building upon what you''ve learned. The following
    topics are covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Events and how they occur
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 1 - hover events and tooltips
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 2 - tooltips with visualizations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 3 - panning and zooming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 4 - orthographic projections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 5 - rotating orthographic projections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Experiment 6 - dragging orthographic projections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Events and how they occur
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following is taken directly from the w3 specifications:'
  prefs: []
  type: TYPE_NORMAL
- en: '"The Event interface is used to provide contextual information about an event
    to the handler processing the event. An object that implements the Event interface
    is generally passed as the first parameter to an event handler. More specific
    context information is passed to event handlers by deriving additional interfaces
    from Event which contain information directly relating to the type of event they
    accompany. These derived interfaces are also implemented by the object passed
    to the event listener."'
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, an event is a user input action that takes place in the browser.
    If your user clicks, touches, drags, or rotates, an event will fire. If you have
    event listeners registered to those particular events, the listeners will catch
    the event and determine the event type. The listeners will also expose properties
    associated with the event. For example, if we want to add an event listener in
    plain JavaScript, we would add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Note that you first need to have the button in the DOM in order to get its ID.
    Once you have it, you can simply add an event listener to listen to the element's
    click event. The event listener will catch the click event every time it fires
    and logs `Hello world` to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Until jQuery, events were very tricky, and different browsers had different
    ways of catching these events. However, thankfully, this is all in the past. Now,
    we live in a world where modern browsers are more consistent with event handling.
  prefs: []
  type: TYPE_NORMAL
- en: In the world of D3, you won't have to worry about this. Generating events, catching
    them, and reacting to them is baked into the library and works across all browsers.
    A good example of this is the hover event.
  prefs: []
  type: TYPE_NORMAL
- en: Experiment 1 – hover events and tooltips
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Building on our previous example, we can easily swap our `click` method with
    a `hover` method. Instead of having `var click`, we will now have `var hover`
    with the corresponding function. Feel free to open `example-1.html` of the `chapter-5`
    code base to go over the complete example (`http://localhost:8080/chapter-5/example-1.html`).
    Let''s review the necessary code to change our click event to a hover event. In
    this particular case, we will need a little more CSS and HTML. In our `<style>`
    tag, add the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This style is for a basic tooltip. It is positioned **absolutely** so that
    it can take whatever *x* and *y* coordinates we give it (left and top). It also
    has some filler styles for the fonts and colors. The `tooltip` is styled to the
    element in the DOM that has the ID of `#tooltip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we add the logic to handle a `hover` event when it is fired:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This function, aside from logging the event, will find the DOM element with
    an ID of `tooltip` and position it at the *x* and *y* coordinates of the event.
    These coordinates are a part of the properties of the event and are named `pageX`
    and `pageY`, respectively. Next, we will insert text with the state name (`d.properties.NAME_1`)
    into the `tooltip`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will change our binding from a click to a `mouseover` event in the
    on section of the code. We will also change the event handler to the `hover` function
    we created earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the changes have been saved and viewed, you should notice basic tooltips
    on your map:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e2101ebd-e276-43e9-848e-064c471387c3.png)'
  prefs: []
  type: TYPE_IMG
- en: Experiment 2 – tooltips with visualizations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this next experiment, we will enhance our tooltips with additional visualizations.
    In a similar fashion, we will outline the additional code to provide this functionality
    (`http://localhost:8080/chapter-5/example-2.html`).
  prefs: []
  type: TYPE_NORMAL
- en: 'To our CSS, we will need to add the following lines of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This will style our SVG container (inside our tooltip DOM element) to align
    it with the label of the state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we''ll include two new scripts to create visualizations:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding JavaScript files contain the D3 code for creating a line chart
    visualization. The chart itself contains and leverages the *Towards* *Reusable
    Chart* described by Mike Bostock at: [http://bost.ocks.org/mike/chart/](http://bost.ocks.org/mike/chart/).
    Feel free to examine the code; it is a very simple visualization that follows
    the enter, update, and exit pattern. We will explore this chart further in [Chapter
    7](ded15f0d-44ff-4b2d-a2ac-ecbba7d5dd63.xhtml), *Testing*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We will now declare two new variables. The `db` variable will hold a hashmap
    to quickly lookup values by `geoID`. The `sparkline` variable is the function
    that will draw our simple line chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This function parses data and formats it into a structure that the `sparkline`
    function can use to create the line chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'We will bring back our `geoID` function from [Chapter 4](c22382c6-84d9-411f-b795-681df2321005.xhtml),
    *Creating a Map*, in order to quickly create unique IDs for each state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'For our hover event handler, we need to add two new lines. First, we will declare
    an ID variable that holds the unique `geoID` for the state we are hovering over.
    Then, we will call our `sparkline` function to draw a line chart in the `tooltip`
    selection. The data is retrieved from the preceding `db` variable. For more information
    on how the call works, refer to: [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We load our `.csv` file via AJAX and invoke the `setDb()` function (described
    earlier).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see a map that displays a `tooltip` with a line chart for every
    state in Mexico. In summary:'
  prefs: []
  type: TYPE_NORMAL
- en: The map is drawn as usual.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will create a small lookup `db` that contains additional data about each
    state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we will register a hover event that fires whenever the user's mouse passes
    over a state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hover event fires and retrieves data about the state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The hover event also places the name of the state in the DOM and calls a function
    that creates a line chart with the retrieved data:![](img/2f2788b5-1820-4e55-b32f-d3465e138d29.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Experiment 3 – panning and zooming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common request when working with maps is to provide the ability to pan
    and zoom around the visualization. This is especially useful when a large map
    contains abundant detail. Luckily, D3 provides an event listener to help with
    this feature. In this experiment, we will outline the principles to provide basic
    panning and zooming for your map. This experiment requires us to start with `example-1.html`;
    however, feel free to look at `http://localhost:8080/chapter-5/example-3.html`
    for reference.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we will add a simple CSS class in our `<style>` section; this class
    will act as a rectangle over the entire map. This will be our zoomable area:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to define a function to handle the event when the zoom listener
    is fired. The following function can be placed right below the map declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes advantage of two variables exposed while panning and zooming:
    `d3.event.scale` and `d3.event.translate`. The variables are defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`d3.event.scale`: This defines the zoom level in terms of an SVG scale.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`d3.event.translate`: This defines the position of the map in relation to the
    mouse in terms of an SVG translate.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With this information available, we can set the SVG attributes (scale and translate)
    of the map container to the event variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Similar to the hover event listener, we need to create a new zoom event listener.
    Create the preceding function after the `zoom()` function. Note that there is
    one additional setting to understand, `scaleExtent()`.
  prefs: []
  type: TYPE_NORMAL
- en: The `scaleExtent()` setting provides a scale range of the zooming amount. The
    first element in the array is the maximum that the map can zoom out. The second
    element in the array is the maximum that the map can zoom in. Remember that `1`
    is the original size of our map based on our bounding-box formula from [Chapter
    4](c22382c6-84d9-411f-b795-681df2321005.xhtml), *Creating a Map*. The minimum
    value that `scaleExtent()` can be set to is `0`, to zoom out. In `example-3.html`,
    alter these numbers to get a feel of how they work. For example, if you change
    `1` to `5`, you will see that the map can zoom out to half its original size.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are additional settings to this event listener that can be reviewed at: [https://github.com/mbostock/d3/wiki/Zoom-Behavior](https://github.com/mbostock/d3/wiki/Zoom-Behavior):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Finally, right after the `mexico.exit` section, we will add a transparent rectangle
    to the entire visualization and bind the new listener. Remember that the rectangle
    is using the CSS class we defined at the beginning of the experiment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you should have full zooming and panning capabilities on the Mexican map.
    You can either double-click to zoom in or use your scroll wheel. The interactions
    should also work for swipe and pinch gestures on a tablet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/644dc9cc-0d9f-452e-95b3-64cea8a3e087.png)'
  prefs: []
  type: TYPE_IMG
- en: Experiment 4 – orthographic projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the next set of experiments in this chapter, we will switch gears and look
    at interactivity with orthographic projections (representing a three-dimensional
    map on a two-dimensional screen). A better visualization to illustrate these concepts
    is the entire globe instead of a single country. This experiment will start with
    `http://localhost:8080/chapter-5/example-4.html` and require a new datafile, which
    is provided for you. You will notice that the code base is almost identical, with
    the exception of three changes that we will outline here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we will change our `d3.geo` projection from `d3.geo.mercator` to `d3.geo.orthographic`.
    We also have an additional setting to configure: the `clipAngle` at `90` degrees.
    This places an imaginary plane through the globe and clips the back of the projection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will substitute the old `geo-data.json` file for the new datafile,
    `world.json`. We will also set up new variables for our data joining in order
    to provide better readability in the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: As we have seen many times now, we will apply the standard `enter()` pattern.
    You should now have a static map of the globe, as seen in the following screenshot.
    You can also work directly with `example-4.html`.
  prefs: []
  type: TYPE_NORMAL
- en: In the last two sections, we will bring the globe to life!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/36a69fdf-fade-4ec3-94f7-c3e6690a03e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Experiment 5 – rotating orthographic projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our previous example was very fascinating. We went from visualizing a map in
    two dimensions to three dimensions with just a few lines. The next step is to
    animate it. For this experiment, open `http://localhost:8080/chapter-5/example-5.html`
    in the code samples. Let''s now piece it together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We added an index variable that will hold the rotation rate. Don''t worry;
    we''ll explain how this is used here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As Mexico is the center of the universe and requires special attention, we
    isolated it into its own variable by taking the corresponding feature from the
    countries'' feature array. This will allow us to manipulate it separately from
    the rest of the globe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will data join the information we isolated earlier to its own variable.
    This way, we will have one map that represents the entire world and another one
    that represents just Mexico:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We will inject the map of Mexico and apply the `geo.path` that contains the
    same projection we used for the world map. We will also add a light yellow background
    to Mexico using the `fill` CSS style and an orange border using the stroke:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where the action starts, literally. We created an interval that executes
    every 20 milliseconds. This interval contains a function that utilizes our index
    variable and increments the value by `0.2`. This value is then applied to the
    `rotate` function of our projection. Specifically, we will adjust the rotation
    every `20` ms on this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Yaw is represented by the first value of the array (in this case, `i`), pitch
    represented by the second value, and roll by the third value. Yaw, pitch, and
    roll are rotation angles and are applied in their respective vectors. The following
    image provides an illustration of how the angles rotate:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4e02e608-c616-4261-b527-1a2d6c55e0c2.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we see that the yaw vector points in the *z* direction and is around the
    center axis. The pitch goes along our *x* axis, and the yaw goes around our *y*
    axis. The Greek characters (in parentheses in the preceding image) are often used
    to depict yaw, pitch, and roll.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our case, the index variable, `i`, is increasing and is allocated to the
    yaw rotation. This means that our globe will spin from left to right around the
    center axis. If we were to swap the position of our index so that it is in the
    pitch location (the second array element), our globe would spin vertically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will use the same D3 update pattern and update all the paths with
    the new projection. Give it a shot, play around with the example, and see how
    the globe spins in different directions. When complete, you will see the rotating
    globe in your browser, as in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7deb056-1d3c-4323-87a0-c2731f5e91f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Experiment 6 – dragging orthographic projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For our last example, we will add the ability to drag our globe so that the
    user can spin it to the left or right. Open `http://localhost:8080/chapter-5/example-6.html`
    from the code samples and let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Our first piece of new code is our dragging event handler. This function will
    be executed every time the user drags the mouse on the screen. The algorithm executes
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Stores the current rotation value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates the projection's rotation based on the distance it is dragged.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates all the paths in the world map.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Updates all the paths in the map of Mexico.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The second step deserves a little more explanation. Just like the `d3.behavior.zoom`
    event handler, `d3.behavior.drag` exposes information about the performed action.
    In this case, `d3.event.dx` and `d3.event.dy` indicate the distance dragged from
    the previous location. The `c[0] + d3.event.dx/2` code tells us that we need to
    take the previous yaw value and add the amount of drag the user is performing.
    We will divide the drag amount by two to slow down the rotation by half; otherwise,
    every pixel the user drags will correlate to *1* degree of rotation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will bind our `dragging` method to our drag event, as we saw earlier,
    with click, hover, and zoom:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we need an area to bind our drag event. Using our previous technique,
    we will add a transparent rectangle on top of the visualization. This will allow
    us to very clearly detect the *x* and *y* positions on our SVG element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Give it a spin! You''ll notice that if you click-and-drag the world, it will
    spin in the corresponding yaw direction:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3097f608-1f0f-412b-959b-d0159a2e35c5.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered many examples to get you started with interactivity for your D3 map
    visualizations. We went over the basics of event handling, explored various methods
    to bind events to the map, outlined the two `d3.behavior` APIs, and even dipped
    our toes into orthographic projections. If you wish to dig deeper into world rotations,
    and the math involved, check out the Jason Davies article at: [http://www.jasondavies.com/maps/rotate/](http://www.jasondavies.com/maps/rotate/).
  prefs: []
  type: TYPE_NORMAL
- en: After two chapters of drawing and interacting with maps, the next chapter will
    explain how to obtain geo data in order to create any map you want. We'll also
    include some techniques to optimize the data files for viewing the web.
  prefs: []
  type: TYPE_NORMAL
