<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Starting Type-Driven Development</h1>
                </header>
            
            <article>
                
<p>In this book, we are exploring the techniques and idioms available in type-driven development. Some people also refer to type-driven development as type-level programming. Static types offer several benefits, including:</p>
<ul>
<li>Preventing incorrect code from getting a chance to run</li>
<li>Documenting the current codebase</li>
<li>Helping to correctly refactor the codebase by pointing out any parts of code you may have missed</li>
<li>Offering richer IDE support, for example, auto-completion</li>
<li>Better performance when the compiler knows types and can optimize code accordingly</li>
</ul>
<p class="mce-root">Type-driven development is the practice of using static types to restrict what your code can do. Normally, your programming language gives you enough power to represent any computation. With type-driven development, you are essentially trying to make it impossible for your code to do undesirable things.</p>
<p>In this chapter, we will do some basic critical analysis of a piece of code and look at the possible errors it may contain. We'll also introduce ReasonML, the language we will use to learn type-driven development and compare it with JavaScript. We'll get started with a basic Reason project and then introduce Reason, as well as its related communities and ecosystems.</p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>The main idea and benefits of type-driven development</li>
<li>Dynamically typed code versus its statically typed ReasonML equivalent</li>
<li>The Reason language, ecosystem, and related projects</li>
<li>How to set up a basic Reason project, which we will use throughout this book</li>
<li>The Try Reason online playground</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Analyzing code for hidden errors</h1>
                </header>
            
            <article>
                
<p>Let's suppose that you have the following JavaScript:</p>
<pre>// src/Ch01/Ch01_Demo.js<br/><span class="underline">function</span> <em>makePerson</em>(<em>id</em>, <em>name</em>) { <span class="underline">return</span> {<em>id</em>, <em>name</em>}; }</pre>
<p>A lot of things can go wrong with the preceding code; they are as follows:</p>
<ul>
<li>The caller can pass in nulls or undefined values as arguments</li>
<li>The caller can pass in unintended types of arguments</li>
<li>The caller can manipulate the returned <kbd>person</kbd> object any way they like, for example, they can add or remove properties</li>
</ul>
<p>In other words, this code doesn't prevent a number of potential errors. In JavaScript, we have linters, such as ESLint (<a href="https://eslint.org/">https://eslint.org/</a>), that check for a lot of possible errors, but you have to remember to find them, enable them, and then work around their limitations. A linter can be helpful in various other ways, such as by pointing out the recommended best practices in a coding style. However, linters in JavaScript are often re-purposed to perform static type checking tasks as well; because they offer so much flexibility and need to be configured (in fact, people usually upload their preferred sets of configuration for different styles of programming), there may be large differences in what exactly gets checked across different codebases.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Adding types</h1>
                </header>
            
            <article>
                
<p>With a static type system, we can restrict our <kbd>makePerson</kbd> function in quite a few ways. Here's an example using ReasonML, the language that we're using in this book to learn type-driven development:</p>
<pre>/* src/Ch01/Ch01_Demo.re */<br/><span class="underline">type</span> <strong>person</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>};<br/><span class="underline">let</span> <em>makePerson</em>(<em>id</em>, <em>name</em>) = {<em>id</em>, <em>name</em>};</pre>
<p>Here, we define a new data type, <kbd>person</kbd>, and a function that creates a value of the type given the required arguments. We have one more line in the preceding code than we do in the JavaScript code, but in exchange, we get the following guarantees:</p>
<ul>
<li>The caller cannot pass in null or undefined arguments</li>
<li>The caller cannot pass in the wrong types of arguments</li>
<li>The caller cannot mutate the result value of the function</li>
</ul>
<p>Notice in the previous example that we didn't have to declare the argument or types for the <kbd>makePerson</kbd> function. This is because ReasonML has great type inference that automatically understands that <kbd>int</kbd>, <kbd>string</kbd>, and <kbd>person</kbd> must be the only possible types allowed for those parts of the function.</p>
<p>ReasonML will compile the previous code into the following JavaScript:</p>
<pre>// src/Ch01/Ch01_Demo.bs.js<br/><span class="underline">function</span> <em>makePerson</em>(<em>id</em>, <em>name</em>) { <span class="underline">return</span> [<em>id</em>, <em>name</em>]; }</pre>
<p>As you can see, the preceding code looks almost exactly like the JavaScript we wrote earlier—the main difference is that Reason's JavaScript compiler turns records (which we'll explore later) into JavaScript arrays to take advantage of their speed.</p>
<p>This is just a glimpse of what static types can do to your codebase. In the coming chapters, we'll have a look at many more practical applications.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">ReasonML</h1>
                </header>
            
            <article>
                
<p>We're going to explore type-driven development using ReasonML (<a href="https://reasonml.github.io/">https://reasonml.github.io/</a>). Reason is a JavaScript-like syntax and is also a set of tools for OCaml (<a href="https://ocaml.org/">https://ocaml.org/</a>). OCaml is a mature statically typed functional programming language with excellent support for object-oriented and modular programming.</p>
<p>We're going to write Reason code and compile it to JavaScript using the BuckleScript compiler (<a href="https://bucklescript.github.io/">https://bucklescript.github.io/</a>). BuckleScript takes input from Reason code and outputs essentially a simple subset of ES5 (that is, no ES2015-style classes, no arrow functions, and so on). This will allow us to write strongly statically typed code and see what the output JavaScript looks like with all the types stripped away.</p>
<div class="packt_tip">BuckleScript, by default, outputs JavaScript files with the extension <kbd>.bs.js</kbd> to distinguish them from your other JS files. You can see this in the example output file, <kbd>src/Ch01/Ch01_Demo.bs.js</kbd>.</div>
<p>The Reason toolkit currently consists of:</p>
<ul>
<li>A code formatting and syntax translation tool, <kbd>refmt</kbd></li>
<li>An interactive code evaluation environment, <kbd>rtop</kbd></li>
<li>A build manager for native-compilation projects (we won't need this one for this book), <kbd>rebuild</kbd></li>
<li>A tool that provides intellisense abilities to editors, <kbd>ocamlmerlin-reason</kbd></li>
</ul>
<p>These tools work together to provide a minimal, yet powerful, development experience. Together with a good editor (we recommend Visual Studio Code), they cover most of your day-to-day development needs.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why ReasonML?</h1>
                </header>
            
            <article>
                
<p>So why have we chosen ReasonML over something else? For example, TypeScript and Flow are popular languages that target JavaScript today (among many others), but we chose Reason because:</p>
<ul>
<li>It has a powerful and elegant type system, which neatly fits together many type-driven development concepts</li>
<li>Its JavaScript compiler (BuckleScript) has incredibly fast compiles, optimization, and high-quality dead-code elimination; fast compiles are great to have if you’re doing type-driven development, and performant code is great to have in any system</li>
<li>It has a very helpful and enthusiastic community that's very accessible</li>
<li>It gives you access to the mature OCaml community and its aggregated knowledge base</li>
</ul>
<p>We will take advantage of the contrasts between the two languages to understand how statically typed Reason code is converted into dynamically typed JavaScript code yet still runs safely by design.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting started with ReasonML</h1>
                </header>
            
            <article>
                
<p>The Reason website has a great quickstart guide as well as tutorials for setting up editor support. First, install NodeJS to get the <strong>node package manager</strong> (<strong>npm</strong>). Then, run the following:</p>
<pre>npm install -g bs-platform<br/>cd &lt;your-projects-folder&gt;<br/>bsb –init learning-tydd-reason –theme basic-reason<br/>cd learning-tydd-reason</pre>
<p>Now we can do an initial compile with the following command:</p>
<pre>bsb -make-world</pre>
<p>The preceding command builds your entire project and its dependencies recursively. It will be almost instantaneous.</p>
<p>It's worth mentioning that we actually recommend running the preceding shell commands (substituting in your actual projects folder, of course), because throughout this book, we're going to arrange the code examples in the form of a single project, <kbd>learning-tydd-reason</kbd>, and the code examples that you type into the various given file names will fit together to make up that project.</p>
<p>You will almost certainly want to set up editor support in Reason so that you can get things like autocompletion and go to definition. The guides available on the ReasonML website (<a href="https://reasonml.github.io/docs/en/global-installation.html">https://reasonml.github.io/docs/en/global-installation.html</a>) are very helpful for this. Currently, Visual Studio Code (<a href="http://code.visualstudio.com/">http://code.visualstudio.com/</a>) is the best-supported editor; you will probably get the best results from using that.</p>
<div class="packt_tip">If you are trying to decide on the install method, we would personally recommend the OPAM method (<strong>OPAM</strong> is the abbreviation of <strong>OCaml Package Manager</strong>).</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using Try Reason</h1>
                </header>
            
            <article>
                
<p>Reason provides a fantastic resource for learners: an online Reason-to-JavaScript compiler and evaluator. To access it, go to the Reason website and click <span class="packt_screen">Try</span> in the navigation bar at the top. You can use it to quickly try out different ideas.</p>
<p>Let's run through a quick example using Try Reason to get our bearings. Type in the example code from <kbd>src/Ch01/Ch01_Demo.re</kbd> into the <span class="packt_screen">Reason</span> section of the Try Reason web app. Now add the following line after that:</p>
<pre><span class="underline">let</span> <em>bob</em> = <em>makePerson</em>(1, "Bob");</pre>
<p>Now if you examine the output JS, you should see that the following changes have been made:</p>
<ul>
<li>Types have been stripped away</li>
<li>Records have been transformed into arrays without field names (records are roughly like C structs or JavaScript objects)</li>
<li>Every declared value is explicitly exported (made public)</li>
</ul>
<p>Note that we have purposely introduced very little actual Reason syntax in this chapter. If you are curious to explore the syntax (which is very similar to JavaScript at its core), it's best if you explore the excellent Reason website documentation. Since the focus of this book is type-driven development, in the upcoming chapters we will introduce all the syntax we will need and discuss its impact on our understanding of the code.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going further</h1>
                </header>
            
            <article>
                
<p>The ReasonML community is a helpful, fast-growing one. If you need help with anything, don't be afraid to ask. You'll only be a beginner once, and once you're comfortable, you'll be able to help other beginners. Check out the community page at <a href="https://reasonml.github.io/docs/en/community.html">https://reasonml.github.io/docs/en/community.html</a> and drop by the discord chat as the first point of contact.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we introduced the basic ideas of type-driven development and critically analyzed a piece of dynamically-typed code to explore its potential error conditions that would be prevented by adding static types. We also introduced the ReasonML language and its ecosystem, set up our own Reason project, and got a glimpse of how it can compile statically typed code to JavaScript.</p>
<p>The next chapter will be an important one—we'll delve more into types, values, and working in Reason. See you there!</p>


            </article>

            
        </section>
    </body></html>