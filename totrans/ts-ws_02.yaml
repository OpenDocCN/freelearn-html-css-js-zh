- en: 1\. TypeScript Fundamentals
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. TypeScript基础知识
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, we'll briefly illustrate the problems that exist in JavaScript
    development environments, and we'll see exactly how TypeScript helps us write
    better and more maintainable code. This chapter will first help you set up the
    TypeScript compiler and then teach you the fundamentals. Additionally, we'll begin
    our journey into types, as they are the core feature of TypeScript – it's right
    in the name. Finally, you will be able to test your newly gained TypeScript skills
    by creating your own library.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要说明JavaScript开发环境中存在的问题，并确切了解TypeScript是如何帮助我们编写更好、更易于维护的代码的。本章将首先帮助你设置TypeScript编译器，然后教授基础知识。此外，我们将开始我们的类型之旅，因为它们是TypeScript的核心特性——这就在其名称中。最后，你将能够通过创建自己的库来测试你新获得的语言技能。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The world of online applications has grown tremendously in the past few decades.
    With it, web-based applications have grown not only in size but also in complexity.
    JavaScript, a language that was originally thought of and used as a go-between
    between the core application logic and the user interface, is being seen in a
    different light. It is the de facto language with which web apps are being developed.
    However, it just was not designed for the building of large applications with
    lots of moving parts. Along came TypeScript.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的几十年里，在线应用程序的世界已经发生了巨大的变化。随着它的发展，基于Web的应用程序不仅在规模上增长，而且在复杂性上也增长。原本被认为是核心应用程序逻辑与用户界面之间的中介语言JavaScript，现在正以不同的视角被看待。它是开发Web应用程序的事实上的语言。然而，它并不是为构建具有许多移动部件的大型应用程序而设计的。TypeScript随之而来。
- en: TypeScript is a superset of JavaScript that provides lots of enterprise-level
    features that JavaScript lacks, such as modules, types, interfaces, generics,
    managed asynchrony, and so on. They make our code easier to write, debug, and
    manage. In this chapter, you will first learn how the TypeScript compiler works,
    how transpilation occurs, and how you can set up the compiler options to suit
    your needs. Then, you will dive straight into TypeScript types, functions, and
    objects. You will also learn how you can make your own types in TypeScript. Finally,
    you can test your skills by attempting to create your own library to work with
    strings. This chapter serves as a launchpad with which you can jump-start your
    TypeScript journey.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是JavaScript的超集，它提供了JavaScript所缺乏的大量企业级特性，例如模块、类型、接口、泛型、管理异步等。它们使我们的代码更容易编写、调试和管理。在本章中，你将首先了解TypeScript编译器的工作原理，编译是如何发生的，以及如何设置编译器选项以满足你的需求。然后，你将直接深入TypeScript的类型、函数和对象。你还将学习如何在TypeScript中创建自己的类型。最后，你可以通过尝试创建自己的字符串库来测试你的技能。本章作为一个发射台，可以帮助你启动你的TypeScript之旅。
- en: The Evolution of TypeScript
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript的演变
- en: TypeScript was designed by Microsoft as a special-purpose language with a single
    goal – to enable people to write better JavaScript. But why was that an issue
    at all? To understand the problem, we have to go back to the roots of the scripting
    languages for the web.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript是由微软设计的一种专用语言，其单一目标是——使人们能够编写更好的JavaScript。但为什么这会成为问题呢？为了理解这个问题，我们必须追溯到网络脚本语言的根源。
- en: In the beginning, JavaScript was designed to enable only a basic level of interactivity
    on the web.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在最初，JavaScript被设计为仅允许在网络上实现基本级别的交互性。
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: JavaScript was initially developed in 1995 by Brendan Eich for use in Netscape
    Navigator.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript最初是在1995年由布兰登·艾奇（Brendan Eich）为在Netscape Navigator中使用而开发的。
- en: It was specifically not designed to be the main language that runs within a
    web page, but to be a kind of glue between the browser and the plugins, such as
    Java applets that run on the site. The heavy lifting was supposed to be done by
    the plugin code, with JavaScript providing a simple layer of interoperability.
    JavaScript did not even have any methods that would enable it to access the server.
    Another design goal for JavaScript was that it had to be easy to use for non-professional
    developers. That meant that the language had to be extremely forgiving of errors,
    and quite lax with its syntax.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 它并不是专门设计为在网页内运行的主体语言，而是一种在浏览器和插件（如在该网站上运行的Java小程序）之间的粘合剂。重负载应该由插件代码来完成，JavaScript提供一层简单的互操作性。JavaScript甚至没有任何方法可以使其访问服务器。JavaScript的另一个设计目标是它必须易于非专业开发者使用。这意味着该语言必须对错误非常宽容，并且在语法上相当宽松。
- en: For a few years, that was the task that JavaScript (or, more properly, ECMAScript,
    as it was standardized) was actually doing. But more and more web pages came into
    existence, and more and more of them needed dynamic content. Suddenly, people
    needed to use a lot of JavaScript. Web pages started getting more and more complex,
    and they were now being referred to as web *applications*. JavaScript got the
    ability (via AJAX) to access servers and even other sites, and a whole ecosystem
    of libraries appeared that helped us write better web applications.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 几年来，JavaScript（或者更准确地说，ECMAScript，因为它已经被标准化）实际上就是在做这项任务。但随着越来越多的网页出现，越来越多的网页需要动态内容。突然之间，人们需要使用大量的JavaScript。网页变得越来越复杂，现在它们被称为Web
    *应用程序*。JavaScript通过AJAX获得了访问服务器甚至其他网站的能力，并出现了一个完整的生态系统，这些库帮助我们编写更好的Web应用程序。
- en: However, the language itself was still lacking lots of features that are present
    in most languages – primarily features that are targeted toward professional developers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，该语言本身仍然缺少许多大多数语言都具备的功能——主要是针对专业开发者的功能。
- en: Note
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Some of the most talked-about features included a lack of module/namespace support,
    type-checked expressions, better scoping mechanisms, and better support for asynchronous
    functionality.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些最常讨论的功能包括缺少模块/命名空间支持、类型检查表达式、更好的作用域机制以及更好的异步功能支持。
- en: Since it was designed for small-scale usage, it was very troublesome to build,
    and especially to maintain, large applications built with JavaScript. On the other
    hand, once it was standardized, JavaScript became the *only* way to actually run
    code inside the browser. So, one solution that was popular in the 2000s was to
    make an emulation layer – a kind of a tool that enabled developers to use their
    favorite language to develop an application that will take the original source
    code as input and output equivalent JavaScript code. Such tools became known as
    *transpilers* – a portmanteau of the words "translator" and "compiler." While
    traditional compilers take source code as input and output machine code that can
    execute directly on the target machine, transpilers basically translated the source
    code from one language to another, specifically to JavaScript. The resulting code
    is then executed on the browser.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它是为小规模使用而设计的，因此构建和维护用JavaScript构建的大型应用程序非常麻烦。另一方面，一旦它被标准化，JavaScript就成为了在浏览器内部实际运行代码的*唯一*方式。因此，2000年代流行的一种解决方案是创建一个仿真层——一种工具，允许开发者使用他们喜欢的语言开发应用程序，该应用程序将原始源代码作为输入，并输出等效的JavaScript代码。这样的工具被称为*转译器*——它是“translator”（翻译器）和“compiler”（编译器）两个词的组合。虽然传统的编译器将源代码作为输入，并输出可以在目标机器上直接执行的机器代码，但转译器基本上是将源代码从一种语言翻译成另一种语言，特别是翻译成JavaScript。然后，生成的代码在浏览器上执行。
- en: Note
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The code actually gets compiled inside the browser, but that's another story.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，代码是在浏览器内部编译的，但这又是另一个故事。
- en: There were two significant groups of transpilers present – ones that transpiled
    from an existing language (C#, Java, Ruby, and so on) and ones that transpiled
    from a language specifically designed to make web development easier (CoffeeScript,
    Dart, Elm, and so on).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当时存在两组显著的转译器——一组是从现有语言（C#、Java、Ruby等）转译而来，另一组是从专门设计来简化Web开发的语言（CoffeeScript、Dart、Elm等）转译而来。
- en: Note
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can see a comprehensive list at [https://packt.link/YRoA0](https://packt.link/YRoA0).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/YRoA0](https://packt.link/YRoA0)看到一份全面的列表。
- en: The major problem with most transpilers was that they were not native to the
    web and JavaScript. The JavaScript that was generated was confusing and non-idiomatic
    – it looked like it was written by a machine and not a human. That would have
    been fine, except that generated mess was the code that was actually executing.
    So, using a transpiler meant that we had to forgo the debugging experience, as
    we could not understand what was actually being run. Additionally, the file size
    of the generated code was usually large, and more often than not, it included
    a huge base library that needed to load before we would be able to run our transpiled
    code.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数转译器的主要问题在于它们不是针对Web和JavaScript本地的。生成的JavaScript代码令人困惑且不符合语言习惯——看起来像是机器写的而不是人写的。这本来是可以的，但生成的混乱代码实际上是正在执行的代码。因此，使用转译器意味着我们必须放弃调试体验，因为我们无法理解实际正在运行的内容。此外，生成的代码文件大小通常很大，而且往往包括一个巨大的基础库，在我们可以运行转译后的代码之前需要加载。
- en: Basically, by 2012 there were two options in sight – write a large web application
    using plain JavaScript, with all the drawbacks that it had, or write large web
    applications using a transpiler, writing better and more maintainable code, but being removed
    from the platform where our code actually runs.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，到2012年，有两个选择——使用纯JavaScript编写大型Web应用程序，所有这些缺点都存在，或者使用转换器编写大型Web应用程序，编写更好、更易于维护的代码，但我们的代码实际上运行的平台上被移除。
- en: Then, TypeScript was introduced.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，TypeScript被引入。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: A video of the introductory lecture is available at [https://channel9.msdn.com/Events/Build/2012/3-012](https://channel9.msdn.com/Events/Build/2012/3-012).
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 可以在[https://channel9.msdn.com/Events/Build/2012/3-012](https://channel9.msdn.com/Events/Build/2012/3-012)找到介绍性讲座的视频。
- en: Design Goals of TypeScript
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript的设计目标
- en: The core idea behind it was one that, in hindsight, seems quite obvious. Instead
    of replacing JavaScript with another language, why not just add the things that
    are missing? And why not add them in such a way that they can be very reasonably
    removed at the transpiling step, so that the generated code will not only look
    and be idiomatic but also be quite small and performant? What if we can add things
    such as static typing, but in an optional way, so that it can be used as much
    or as little as we want? What if all of that existed while we're developing and
    we can have nice tooling and use a nice environment, yet we're still able to debug
    and understand the generated code?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 它背后的核心思想，事后看来似乎相当明显。为什么不直接用另一种语言替换JavaScript，而是添加缺失的功能呢？为什么不以这种方式添加它们，以便在转换步骤中可以非常合理地移除它们，这样生成的代码不仅看起来和感觉是惯用的，而且相当小且性能良好？如果我们能够添加诸如静态类型这样的功能，但以可选的方式，这样我们就可以根据需要使用多少？如果我们开发时所有这些功能都存在，我们就可以拥有良好的工具和良好的环境，同时我们仍然能够调试和理解生成的代码？
- en: 'The design goals of TypeScript, as initially stated, were as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript的设计目标，如最初所述，如下所示：
- en: Extend JavaScript to facilitate writing large applications.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 扩展JavaScript以方便编写大型应用程序。
- en: Create a strict superset of JavaScript (that is, any valid JavaScript is valid TypeScript).
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个JavaScript的严格超集（即，任何有效的JavaScript都是有效的TypeScript）。
- en: Enhance the development tooling support.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增强开发工具支持。
- en: Generate JavaScript that runs on any JavaScript execution environment.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成在任何JavaScript执行环境中运行的JavaScript。
- en: Easy transfer between TypeScript and JavaScript code.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: TypeScript和JavaScript代码之间的轻松迁移。
- en: Generate clean, idiomatic JavaScript.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生成干净、惯用的JavaScript。
- en: Align with future JavaScript standards.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与未来的JavaScript标准保持一致。
- en: Sounds like a pie-in-the-sky promise, and the initial response was a bit lukewarm.
    But, as time progressed, and as people actually tried it and started using it
    in real applications, the benefits became obvious.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 听起来像是一个天方夜谭的承诺，最初的反应有些冷淡。但随着时间的推移，当人们真正尝试并开始在现实应用中使用它时，好处变得明显。
- en: Note
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The author's lecture on TypeScript, which was the first one to be broadcast
    worldwide by a non-Microsoft employee, can be found at [https://www.slideshare.net/sweko/typescript-javascript-done-right](https://www.slideshare.net/sweko/typescript-javascript-done-right).
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 作者关于TypeScript的讲座，这是第一个由非微软员工向全球播出的讲座，可以在[https://www.slideshare.net/sweko/typescript-javascript-done-right](https://www.slideshare.net/sweko/typescript-javascript-done-right)找到。
- en: Two areas where TypeScript became a power player were JavaScript libraries and
    server-side JavaScript, where the added strictness of type checking and formal
    modules enabled higher-quality code. Currently, all of the most popular web development
    frameworks are either natively written in TypeScript (such as Angular, Vue, and
    Deno) or have tight integrations with TypeScript (such as React and Node).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript成为主要玩家的两个领域是JavaScript库和服务器端JavaScript，其中类型检查的严格性和正式模块的引入使得代码质量更高。目前，所有最受欢迎的Web开发框架要么是原生用TypeScript编写的（如Angular、Vue和Deno），要么与TypeScript有紧密的集成（如React和Node）。
- en: Getting Started with TypeScript
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript入门
- en: 'Consider the following TypeScript program – a simple function that adds two numbers:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下TypeScript程序——一个简单的添加两个数字的函数：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'No, that''s not a joke – that''s real-life TypeScript. We just did not use
    any TypeScript-specific features. We can save this file as `add.ts` and can compile
    it to JavaScript using the following command:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 不，这不是一个玩笑——这是真实的TypeScript。我们只是没有使用任何TypeScript特定的功能。我们可以将此文件保存为`add.ts`，并使用以下命令将其编译为JavaScript：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This will generate our output file, `add.js`. If we open it and look inside,
    we can see that the generated JavaScript is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成我们的输出文件，`add.js`。如果我们打开它并查看内部内容，我们可以看到生成的 JavaScript 代码如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Yes, aside from some spacing, the code is identical, and we have our first successful transpilation.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，除了一些间距外，代码是相同的，我们完成了第一次成功的转换。
- en: The TypeScript Compiler
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: TypeScript 编译器
- en: 'We will add to the example, of course, but let''s take a moment to analyze
    what happened. First of all, we gave our file the `.ts` file extension. All TypeScript
    files have this extension, and they contain the TypeScript source code of our
    application. But, even if our code is valid JavaScript (as in this case), we cannot
    just load the `.ts` files inside a browser and run them. We need to compile/transpile
    them using the tool called the "TypeScript compiler," or `tsc` for short. What
    this tool does is takes TypeScript files as arguments and generates JavaScript
    files as outputs. In our case, our input was `add.ts` and our output was `add.js`.
    The `tsc` compiler is an extremely powerful tool, and it has a lot of options
    that we''re able to set. We can get a full list of the options using this command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们将在示例中添加更多内容，但让我们花一点时间分析一下发生了什么。首先，我们给文件添加了`.ts`文件扩展名。所有 TypeScript 文件都有这个扩展名，它们包含我们应用程序的
    TypeScript 源代码。但是，即使我们的代码是有效的 JavaScript（如本例所示），我们也不能直接在浏览器中加载`.ts`文件并运行它们。我们需要使用名为“TypeScript
    编译器”的工具或简称`tsc`来编译/转换它们。这个工具的作用是将 TypeScript 文件作为参数，生成 JavaScript 文件作为输出。在我们的例子中，我们的输入是`add.ts`，输出是`add.js`。`tsc`编译器是一个非常强大的工具，它有很多我们可以设置的选项。我们可以使用此命令获取选项的完整列表：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The most common and important ones are as follows:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见且最重要的选项如下：
- en: '`–outFile`: With this option, we can specify the name of the output file we
    want to be generated. If it''s not specified, it defaults to the same name as
    the input file, but with the `.js` extension.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–outFile`：使用此选项，我们可以指定要生成的输出文件名。如果没有指定，它将默认为与输入文件相同的名称，但带有`.js`扩展名。'
- en: '`–outDir`: With this option, we can specify the location of the output file(s).
    By default, the generated files will be in the same location as the source files.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–outDir`：使用此选项，我们可以指定输出文件的位置。默认情况下，生成的文件将与源文件位于同一位置。'
- en: '`–types`: With this option, we can specify additional types that will be allowed
    in our source code.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–types`：使用此选项，我们可以指定在源代码中允许的附加类型。'
- en: '`–lib`: With this option, we specify which library files need to be loaded.
    As there are different execution environments for JavaScript, with different default
    libraries (for example, browser JavaScript has a `window` object, and Node.js
    has a `process` object), we can specify which one we want to target. We can also
    use this option to allow or disallow specific JavaScript functionality. For example,
    the `array.include` method was added in the `es2016` JavaScript version. If we
    want to assume that the method will be available, then we need to add the `es2016.array.include`
    library.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–lib`：使用此选项，我们指定需要加载的库文件。由于 JavaScript 有不同的执行环境，默认库也不同（例如，浏览器 JavaScript 有一个`window`对象，而
    Node.js 有一个`process`对象），我们可以指定我们想要的目标。我们还可以使用此选项允许或禁止特定的 JavaScript 功能。例如，`array.include`方法是在`es2016`
    JavaScript 版本中添加的。如果我们假设该方法将是可用的，那么我们需要添加`es2016.array.include`库。'
- en: '`–target`: With this option, we specify which version of the ECMAScript (that
    is, JavaScript) language we''re targeting. That is, if we need to support older
    browsers, we can use the `ES3` or `ES5` values, which will compile our code to
    JavaScript code that will execute in any environment that supports, correspondingly,
    versions 3 and 5 of the JavaScript language. If, on the other hand, we know that
    we''ll run in an ultra-modern environment, as the latest Node.js runtime, we can
    use the `ES2020` target, or even `ESNEXT`, which is always the next available
    version of the ECMAScript language.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`–target`：使用此选项，我们指定要针对的 ECMAScript（即 JavaScript）语言的版本。也就是说，如果我们需要支持旧版浏览器，我们可以使用`ES3`或`ES5`值，这将编译我们的代码为可以在相应地支持
    JavaScript 语言 3 和 5 版本的任何环境中执行的 JavaScript 代码。另一方面，如果我们知道我们将在一个超现代环境中运行，比如最新的
    Node.js 运行时，我们可以使用`ES2020`目标，甚至`ESNEXT`，这是 ECMAScript 语言的下一个可用版本。'
- en: There are several more options; however, we have only discussed a few here.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 还有更多选项；然而，我们在这里只讨论了其中的一些。
- en: Setting Up a TypeScript Project
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 TypeScript 项目
- en: 'Since the TypeScript compiler has lots of options, and we''ll need to use quite
    a few of them, specifying all of them each and every time we transpile a file
    will get tedious very fast. In order to avoid that, we can save our default options
    in a special file that will be accessed by the `tsc` command. The best way to
    generate this special file called `tsconfig.json` is to use `tsc` itself with
    the `--init` option. So, navigate to the folder where you want to store your TypeScript
    project and execute the following command:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 TypeScript 编译器有很多选项，而我们又需要使用其中很多选项，每次转换文件时指定所有选项会很快变得繁琐。为了避免这种情况，我们可以将默认选项保存在一个特殊文件中，该文件将由
    `tsc` 命令访问。生成此特殊文件（名为 `tsconfig.json`）的最佳方式是使用带有 `--init` 选项的 `tsc` 本身。因此，导航到您想要存储
    TypeScript 项目的文件夹，并执行以下命令：
- en: '[PRE4]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This will generate a `tsconfig.json` file with the most commonly used option.
    The rest of the options are commented out, so if we want to use some other set
    of options, we can simply uncomment what we need. If we ignore the comments (which
    include a link to the documentation about the options), we get the following content:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个包含最常用选项的 `tsconfig.json` 文件。其余选项已注释掉，因此如果我们想使用其他一组选项，我们可以简单地取消注释所需的选项。如果我们忽略注释（其中包含有关选项的文档链接），我们得到以下内容：
- en: '[PRE5]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can see that each and every option in the `tsconfig.json` file has a corresponding
    command-line switch, for example, `module`, `target`, and so on. If a command-line
    switch is specified, it takes precedence. However, if a command-line switch is
    not defined, then `tsc` looks for the nearest `tsconfig.json` file up the directory
    hierarchy and takes the value specified there.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到 `tsconfig.json` 文件中的每个选项都有一个对应的命令行开关，例如 `module`、`target` 等。如果指定了命令行开关，则具有优先级。然而，如果没有定义命令行开关，则
    `tsc` 会查找目录层次结构中的最近 `tsconfig.json` 文件，并采用那里指定的值。
- en: 'Exercise 1.01: Using tsconfig.json and Getting Started with TypeScript'
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.01：使用 tsconfig.json 和 TypeScript 入门
- en: 'In this exercise, we''ll see how to command TypeScript using the `tsconfig.json`
    file. We''ll see how to create TypeScript files and transpile them to JavaScript,
    based on the options we specify:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何使用 `tsconfig.json` 文件来命令 TypeScript。我们将看到如何创建 TypeScript 文件并将它们转换为
    JavaScript，这取决于我们指定的选项：
- en: Note
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Please make sure you have installed **Visual Studio** (**VS**) Code and followed
    the installation steps as mentioned in the *Preface*. The code files for this
    exercise can be found here: [https://packt.link/30NuU](https://packt.link/30NuU).'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您已安装**Visual Studio**（**VS**）Code，并按照**前言**中提到的安装步骤进行操作。本练习的代码文件可以在此处找到：[https://packt.link/30NuU](https://packt.link/30NuU)。
- en: 'Create a new folder and execute the following command in a new terminal within
    it:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的文件夹，并在其中打开一个新的终端，然后执行以下命令：
- en: '[PRE6]'
  id: totrans-70
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Verify that a new `tsconfig.json` file is created within the folder and that
    its target value is `es5`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证文件夹内是否已创建一个新的 `tsconfig.json` 文件，并且其目标值是 `es5`。
- en: Create a new file called `squares.ts` inside it.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其中创建一个名为 `squares.ts` 的新文件。
- en: 'In `squares.ts`, create a function called `squares`:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `squares.ts` 文件中，创建一个名为 `squares` 的函数：
- en: '[PRE7]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a new array from the input argument, using the JavaScript `map` function
    with an arrow function argument:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 JavaScript `map` 函数和箭头函数参数从输入参数创建一个新数组：
- en: '[PRE8]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Return the new array from the function:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数中返回新的数组：
- en: '[PRE9]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Save the file and run the following command in the folder:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在文件夹中运行以下命令：
- en: '[PRE10]'
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Verify that there is a new file in the folder called `squares.js` with the
    following content:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证文件夹中是否有一个名为 `squares.js` 的新文件，其内容如下：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Here, we can see that the transpilation step did several things:'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这里，我们可以看到转换步骤做了几件事情：
- en: '- It removed the type annotation from the `array: number[]` parameter, transpiling
    it to `array`.'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 它从 `array: number[]` 参数中移除了类型注解，将其转换为 `array`。'
- en: '- It changed the `const result` variable declaration to a `var result` declaration.'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 它将 `const result` 变量声明更改为 `var result` 声明。'
- en: '- It changed the arrow function, `x=>x*x`, to a regular function, `function
    (x) { return x * x; }`.'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '- 它将箭头函数 `x=>x*x` 转换为普通函数 `function (x) { return x * x; }`。'
- en: While the first is TypeScript-specific code, the second and third are examples
    of TypeScript's backward compatibility – both the arrow functions and the `const`
    declarations are JavaScript features that were introduced in the ES6 version of
    the language.
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然第一个是 TypeScript 特定的代码，第二个和第三个是 TypeScript 向后兼容性的示例——箭头函数和 `const` 声明都是 JavaScript
    特性，这些特性是在语言 ES6 版本中引入的。
- en: 'Run the following command in the folder:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件夹中运行以下命令：
- en: '[PRE12]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will override the setting from the `tsconfig.json` file and it will transpile
    the TypeScript code to `ES6`-compatible JavaScript.
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将覆盖 `tsconfig.json` 文件中的设置，并将 TypeScript 代码转换为与 `ES6` 兼容的 JavaScript。
- en: 'Verify that the contents of the `squares.js` file are now as follows:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `squares.js` 文件的内容现在如下所示：
- en: '[PRE13]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: You can note that, in contrast to the results in *step 8*, now the `const` keyword
    and the arrow functions are intact, because the target we specified supports them
    natively. This is an extremely important feature of TypeScript. With this feature,
    even if we don't use the rich type system that TypeScript provides, we can still
    write code in the most modern version of JavaScript available, and TypeScript
    will seamlessly transpile our code to a version that can actually be consumed
    by our customers.
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以注意到，与第8步的结果相比，现在 `const` 关键字和箭头函数仍然完好无损，因为指定的目标环境原生支持它们。这是 TypeScript 的一个极其重要的特性。有了这个特性，即使我们不使用
    TypeScript 提供的丰富类型系统，我们也可以编写最现代版本的 JavaScript 代码，并且 TypeScript 会无缝地将我们的代码转换为顾客实际可以消费的版本。
- en: Types and Their Uses
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 类型及其用途
- en: 'We''ve mentioned that TypeScript''s type system is its distinguishing feature,
    so let''s take a better look at it. JavaScript is what''s called a loosely typed
    language. That means that it does not enforce any rules on the defined variables
    and their values. Consider, for example, that we define a variable called `count`
    and set it to the value of `3`:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经提到 TypeScript 的类型系统是其区别于其他语言的特征，因此让我们更深入地了解一下。JavaScript 被称为弱类型语言。这意味着它不对定义的变量及其值施加任何规则。例如，假设我们定义一个名为
    `count` 的变量并将其设置为 `3` 的值：
- en: '[PRE14]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'There is nothing that prevents us from setting that variable to a value that
    is a string, a date, an array, or basically any object. All of the following assignments
    are valid:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 没有任何东西阻止我们将该变量设置为字符串、日期、数组或基本上任何对象的值。以下所有赋值都是有效的：
- en: '[PRE15]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In almost all scenarios, this is not a behavior we actually want. Moreover,
    since JavaScript does not know when we are writing the code whether a variable
    contains a string or a number, it cannot stop us from trying to, for example, convert
    it to lowercase. We cannot know whether that operation will succeed or fail until
    the moment we actually try it, when running the code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在几乎所有场景中，这并不是我们真正希望的行为。此外，由于 JavaScript 无法在编写代码时知道变量包含的是字符串还是数字，它无法阻止我们尝试，例如，将其转换为小写。我们无法知道该操作是否成功或失败，直到我们实际尝试运行代码的那一刻。
- en: 'Let''s take the following example:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看一个以下示例：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This code will either output `"String"` or throw a `variable.toLowerCase is
    not a function` error. The only way to determine whether this code will break
    is to actually run it. In a nutshell, in a loosely typed language, while values
    themselves have types, variables, on the other hand, don't. They just take the
    type of the value they are currently holding. So, any checks whether a method
    is possible on a variable, such as `variable.toLowerCase()`, can only be done
    when we have the actual value, that is, when we run the code. Once more, this
    is quite fine for small-sized applications, but it can become tedious for large-scale
    applications. In contrast, strongly typed languages enforce the type rules for
    both the values and the variables they live in. This means that the language itself
    can detect the error as you are typing the code, as it has more information about
    what is going on in your code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将输出 `"String"` 或抛出 `variable.toLowerCase is not a function` 错误。确定这段代码是否会出错的唯一方法就是实际运行它。简而言之，在弱类型语言中，虽然值本身有类型，但变量另一方面却没有。它们只是取当前持有的值的类型。因此，任何关于变量上是否可以执行方法的检查，例如
    `variable.toLowerCase()`，只能在我们有实际值时进行，也就是说，当我们运行代码时。再次强调，这对于小型应用程序来说相当不错，但对于大型应用程序来说可能会变得繁琐。相比之下，强类型语言对值和它们所居住的变量的类型规则进行强制执行。这意味着语言本身可以在你编写代码时检测到错误，因为它对你的代码正在发生的事情有更多的信息。
- en: So, in a large software product, (in most cases) we don't want variables that
    have values of different types. So, we want to be able to somehow say "this variable
    has to be a number, and if someone tries to put something that is not a number
    inside it, issue an error."
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在一个大型软件产品中，（在大多数情况下）我们不希望变量具有不同类型的值。因此，我们希望能够以某种方式说明“这个变量必须是数字，如果有人试图在其中放入非数字的内容，则引发错误。”
- en: 'This is where TypeScript, as a strongly typed language, comes in. We have two
    ways that we can use to bind a variable to a type. The simpler one is to simply
    annotate the variable with the type we want it to be, like this:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是 TypeScript 作为一种强类型语言发挥作用的地方。我们可以使用两种方法来将变量绑定到类型。更简单的一种方法是将我们想要的类型直接注解到变量上，就像这样：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `: number` part of the code is called a *type* annotation, and we''re doing
    just that – saying "this variable has to be a number, and if someone tries to
    put something that is not a number inside it, issue an error."'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '代码中的 `: number` 部分被称为 *类型注解*，我们正是这样做的——说“这个变量必须是一个数字，如果有人试图在其中放入不是数字的东西，就抛出一个错误。”'
- en: 'Now, if we try to assign a number to that variable, everything is fine. But
    the minute we try to assign a string to the variable, we''ll get an error message:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试将一个数字赋值给这个变量，一切正常。但是，当我们尝试将一个字符串赋值给变量时，我们会收到一个错误信息：
- en: '![Figure 1.1: Error message from assigning an incorrect type'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.1: Error message from assigning an incorrect type](img/Figure_1.1_Error_message_from_assigning_an_incorrect_type.jpg)'
- en: '](img/B14508_01_01.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_01_01.jpg](img/B14508_01_01.jpg)'
- en: 'Figure 1.1: Error message from assigning an incorrect type'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：赋值错误类型时的错误信息
- en: This type of annotation is explicit and specific to TypeScript. Another way
    is simply to assign a value to a variable and let TypeScript work its magic. The
    magic is called *type inference*, and that means that TypeScript will try to guess
    the type of the variable based on the value provided.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型的注解是明确的，并且是 TypeScript 特有的。另一种方法是将一个值赋给一个变量，让 TypeScript 发挥其魔法。这种魔法被称为 *类型推断*，这意味着
    TypeScript 将尝试根据提供的值猜测变量的类型。
- en: 'Let''s define a variable and initialize it with a value, like this:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们定义一个变量并用一个值来初始化它，就像这样：
- en: '[PRE18]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, if we try to assign a string to that variable, TypeScript will issue an
    error:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们尝试将一个字符串赋值给这个变量，TypeScript 将会抛出一个错误：
- en: '![Figure 1.2: Error message from assigning an incorrect type'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.2: Error message from assigning an incorrect type](img/Figure_1.2_Error_message_from_assigning_an_incorrect_type.jpg)'
- en: '](img/B14508_01_02.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/B14508_01_02.jpg](img/B14508_01_02.jpg)'
- en: 'Figure 1.2: Error message from assigning an incorrect type'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：赋值错误类型时的错误信息
- en: From the error message, we can see the type that TypeScript correctly inferred
    for the variable – `number`. Actually, in most cases, we won't even need to add
    type annotations, as TypeScript's powerful type inference engine will correctly
    infer the type of the variable.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 从错误信息中，我们可以看到 TypeScript 正确推断出的变量的类型——`number`。实际上，在大多数情况下，我们甚至不需要添加类型注解，因为
    TypeScript 强大的类型推断引擎将正确推断出变量的类型。
- en: TypeScript and Functions
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript 和函数
- en: 'Another huge benefit of TypeScript is automatic function invocation checking.
    Let''s say that we have the function we used for our first TypeScript file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 的另一个巨大好处是自动函数调用检查。假设我们使用了我们第一个 TypeScript 文件中的函数：
- en: '[PRE19]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Even without any type annotations, TypeScript still has some information about
    this function – namely, that it takes two, and exactly two, parameters.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 即使没有任何类型注解，TypeScript 仍然对这个函数有一些信息——即它接受两个，且恰好两个参数。
- en: 'In contrast, JavaScript does not enforce that the number of actual arguments
    has to conform to the number of parameters defined, so all of the following invocations
    are valid calls in JavaScript:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 与此相反，JavaScript 不强制实际参数的数量必须符合定义的参数数量，因此以下所有调用在 JavaScript 中都是有效的调用：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In JavaScript, we can call a function with more arguments than parameters,
    fewer arguments, or even without any arguments at all. If we have more arguments
    than needed, the extra arguments are simply ignored (and stored in the magical
    `arguments` variable), and if we have fewer arguments than needed, the extra parameters
    are given the value `undefined`. So, in essence, the preceding calls will be correspondingly
    transformed into the following:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，我们可以用一个比参数多的参数个数、少的参数个数，甚至没有任何参数的方式来调用一个函数。如果我们提供的参数多于所需的，额外的参数将被简单地忽略（并存储在神奇的
    `arguments` 变量中），如果我们提供的参数少于所需的，额外的参数将被赋予 `undefined` 的值。因此，本质上，前面的调用将被相应地转换为以下形式：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In the third and fourth cases, the return value of the function will be the
    special numeric value `NaN`.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三和第四种情况下，函数的返回值将是特殊的数值 `NaN`。
- en: 'TypeScript has a radically different approach to this issue. A function can
    only be called using valid arguments – both in number and in type. So, if we write
    the same code, but this time in a TypeScript file, we''ll get appropriate error
    messages. For a case where we have extra arguments, we''ll get an error message
    on the extra arguments:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript对此问题采取了根本不同的方法。一个函数只能使用有效的参数调用——无论是数量还是类型。因此，如果我们用相同的代码，但这次是在TypeScript文件中编写，我们将得到适当的错误信息。对于有额外参数的情况，我们将在额外参数上得到错误信息：
- en: '![Figure 1.3: Error message from using an incorrect number of'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：使用错误数量的参数的错误信息——参数过多]'
- en: arguments – too many in this case
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 参数——参数过多
- en: '](img/B14508_01_03.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_01_03.jpg]'
- en: 'Figure 1.3: Error message from using an incorrect number of arguments – too
    many in this case'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.3：使用错误数量的参数的错误信息——参数过多]'
- en: 'For cases with too few arguments, we get the error message on the method itself:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于参数数量过少的情况，错误信息会显示在方法本身上：
- en: '![Figure 1.4: Error message from using an incorrect number'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4：使用错误数量的参数的错误信息]'
- en: of arguments – too few in this case
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 参数数量——在这个例子中参数过少
- en: '](img/B14508_01_04.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_01_04.jpg]'
- en: 'Figure 1.4: Error message from using an incorrect number of arguments – too
    few in this case'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.4：使用错误数量的参数的错误信息——参数过少]'
- en: In this case, we're notified that a required parameter is missing, as well as
    what the name and the type of that parameter should be. Note that it's a common
    JavaScript technique to have methods that accept a variable number of parameters,
    accept optional parameters, or provide some defaults if a parameter is not specified.
    All those cases (and many more) are correctly handled by TypeScript.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们会收到通知，指出缺少了一个必需的参数，以及该参数的名称和类型。请注意，在JavaScript中，有一个常见的技巧，即方法可以接受可变数量的参数，可以接受可选参数，或者如果未指定参数，则提供一些默认值。所有这些情况（以及更多）都由TypeScript正确处理。
- en: Note
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Details on how to write such methods using TypeScript are inlcuded in *Chapter
    3*, *Functions*.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 关于如何使用TypeScript编写此类方法的详细信息包含在第3章“函数”中。
- en: 'Of course, parameter checking works not only on the number but also on the
    type of the parameters as well. We would want the `add` function to work only
    with numbers – it does not make sense to add a Boolean and an object, for example.
    In TypeScript, we can annotate our function like this:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，参数检查不仅适用于参数的数量，也适用于参数的类型。我们希望`add`函数只与数字一起工作——例如，将布尔值和对象相加是没有意义的。在TypeScript中，我们可以这样注释我们的函数：
- en: '[PRE22]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This will cause the compiler not only to check that the number of arguments
    matches the number of parameters but also to verify that the types used for the
    arguments are actually valid. Since JavaScript can't check for that, adding a
    Boolean and an object is actually a valid call to the JavaScript equivalent of
    our `add` method. Furthermore, since JavaScript tries to be as forgiving as possible,
    we won't even get a runtime error – the call will be successful, as JavaScript
    will coerce both the object and Boolean to a common string representation, and
    then try (and succeed) to add those two values together.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致编译器不仅检查参数数量是否与参数数量匹配，还要验证用于参数的类型是否实际有效。由于JavaScript无法检查这一点，添加一个布尔值和一个对象实际上是调用我们`add`方法JavaScript等价物的有效调用。此外，由于JavaScript尽可能地宽容，我们甚至不会得到运行时错误——调用将成功，因为JavaScript会将这两个值都强制转换为共同的字符串表示形式，然后尝试（并成功）将这两个值相加。
- en: 'Let''s interpret the following call to our function as both JavaScript and
    TypeScript:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将以下对函数的调用解释为JavaScript和TypeScript：
- en: '[PRE23]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This is valid, albeit nonsensical, JavaScript code. If run, it will yield the
    result `[object Object]false`, which would not be useful in any context.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这段JavaScript代码虽然不合逻辑，但却是有效的。如果运行，它将产生 `[object Object]false` 的结果，这在任何上下文中都不会有用。
- en: 'The same code, interpreted as TypeScript, will yield the following compile
    type error:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 将相同的代码解释为TypeScript，将产生以下编译类型错误：
- en: '![Figure 1.5: Error message on VS Code'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5：VS Code上的错误信息]'
- en: '](img/B14508_01_05.jpg)'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_01_05.jpg]'
- en: 'Figure 1.5: Error message on VS Code'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.5：VS Code上的错误信息]'
- en: 'We can also annotate the return type of the function, adding a type annotation
    after the parameter list:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以注释函数的返回类型，在参数列表之后添加类型注释：
- en: '[PRE24]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'That is usually not necessary, as TypeScript can actually infer the return
    type from the return statements given. In our case, since `x` and `y` are numbers,
    `x+y` will be a number as well, which means that our function will return a number.
    However, if we do annotate the return type, TypeScript will enforce that contract
    as well:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下并不需要这样做，因为TypeScript实际上可以从给定的返回语句中推断出返回类型。在我们的例子中，由于`x`和`y`是数字，`x+y`也将是数字，这意味着我们的函数将返回一个数字。然而，如果我们确实注释了返回类型，TypeScript也会强制执行该合约：
- en: '![Figure 1.6: TypeScript enforcing the correct type'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6：TypeScript强制执行正确的类型](#)'
- en: '](img/B14508_01_06.jpg)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_01_06.jpg)'
- en: 'Figure 1.6: TypeScript enforcing the correct type'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6：TypeScript强制执行正确的类型](#)'
- en: 'In either case, whether we explicitly annotate the return type or it''s inferred,
    the type of the function will be applied to any values that are produced by calling
    the function. So, if we assign the return value to some variable, that variable
    will have the type of `number` as well:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，无论是显式注释返回类型还是推断，函数的类型都将应用于调用函数产生的任何值。因此，如果我们将返回值赋给某个变量，该变量也将具有`number`类型：
- en: '![Figure 1.7: VS Code showing the type of the variable'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7：VS Code显示变量的类型](#)'
- en: '](img/B14508_01_07.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_01_07.jpg)'
- en: 'Figure 1.7: VS Code showing the type of the variable'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.7：VS Code显示变量的类型](#)'
- en: 'Also, if we try to assign the return value to a variable that is already known
    to be something else other than a number, we''ll get an appropriate error:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们尝试将返回值赋给已知不是数字的变量，我们会得到适当的错误：
- en: '![Figure 1.8: Error message on VS Code'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8：VS Code上的错误信息](#)'
- en: '](img/B14508_01_08.jpg)'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_01_08.jpg)'
- en: 'Figure 1.8: Error message on VS Code'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8：VS Code上的错误信息](#)'
- en: Let's make another great point about TypeScript and its type system. As can
    be seen, the screenshots in this chapter don't show actual compiler error messages
    – they are taken from inside a code editor (VS Code, an editor that is itself
    written in TypeScript).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再谈谈TypeScript及其类型系统的一个优点。如所见，本章中的截图并没有显示实际的编译器错误信息——它们是从代码编辑器内部（VS Code，这是一个用TypeScript编写的编辑器）获取的。
- en: We did not even have to actually compile the code. Instead, we got the error
    messages while we typed the code – an experience that is familiar to developers
    in other strongly typed languages, such as C# or Java.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们甚至不必实际编译代码。相反，我们在编写代码时得到了错误信息——这是其他强类型语言（如C#或Java）的开发者所熟悉的经验。
- en: This happens because of the design of the TypeScript compiler, specifically
    its Language Service API. This enables the editor to easily use the compiler to
    check the code as it's written so that we can get a nice and intuitive GUI. Additionally,
    since all the editors will use the same compiler, the development experience will
    be similar across different editors. This is a dramatic change from the situation
    that we started with – fully writing, loading, and actually executing the JavaScript
    code in order to know whether it even makes sense.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为TypeScript编译器的设计，特别是其语言服务API。这使得编辑器能够轻松地使用编译器来检查代码，以便我们得到一个良好且直观的GUI。此外，由于所有编辑器都将使用相同的编译器，因此不同编辑器之间的开发体验将相似。这与我们最初的情况形成了鲜明对比——完全编写、加载并实际执行JavaScript代码，以了解它是否有意义。
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In recent years, some editors have started using the TypeScript Language Service
    API on JavaScript code as well, so TypeScript improves even the plain JavaScript
    development experience.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 近年来，一些编辑器已经开始在JavaScript代码上使用TypeScript语言服务API，因此TypeScript甚至提高了纯JavaScript的开发体验。
- en: 'In a nutshell, using TypeScript changes one of the most prevalent pain points
    for JavaScript development – inconsistent and sometimes even impossible tooling
    support – into a much easier and more convenient experience. In our case, we need
    only to open a parenthesis when calling the `add` function, and we''ll see the
    following:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，使用TypeScript将JavaScript开发中最普遍的痛点之一——不一致且有时甚至不可能的工具支持——转变为更简单、更方便的体验。在我们的案例中，我们只需要在调用`add`函数时打开一个括号，我们就会看到以下内容：
- en: '![Figure 1.9: List of parameters that the function can take'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9：函数可以接受的参数列表](#)'
- en: '](img/B14508_01_09.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_01_09.jpg)'
- en: 'Figure 1.9: List of parameters that the function can take'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.9：函数可以接受的参数列表](#)'
- en: We are shown a list of parameters that shows that the function – which can be
    defined in another file, by another developer – takes two numbers and also returns
    a number.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到一个参数列表，显示该函数（可以由另一位开发者定义，位于另一个文件中）接受两个数字，并返回一个数字。
- en: 'Exercise 1.02: Working with Functions in TypeScript'
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.02：在TypeScript中使用函数
- en: 'In this exercise, we''ll define a simple function and see how we can and can''t
    invoke it. The function we will be developing will be a string utility function
    that shortens a string to a snippet. We''ll basically cut off the text after a
    given length, but take care that we don''t chop a word in half. If the string
    is larger than the maximum length, we''ll add an ellipsis (`…`) to the end:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个简单的函数，并看看我们如何可以和不可以调用它。我们将开发的函数将是一个字符串实用函数，用于将字符串缩短为片段。我们基本上会在给定的长度之后截断文本，但要注意不要将单词截成两半。如果字符串长度超过最大长度，我们将在末尾添加省略号（`…`）：
- en: Note
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/BHj53](https://packt.link/BHj53).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下位置找到：[https://packt.link/BHj53](https://packt.link/BHj53)。
- en: Create a new file called `snippet.ts`.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`snippet.ts`的新文件。
- en: 'In `snippet.ts`, define a simple function called `snippet`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`snippet.ts`中，定义一个名为`snippet`的简单函数：
- en: '[PRE25]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Check whether the text is smaller than the specified length, and if it is,
    return it unchanged:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查文本是否小于指定的长度，如果是，则返回它未更改：
- en: '[PRE26]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'If the text is larger than the maximum length, we''ll need to add an ellipsis.
    The maximum number of characters that we''ll be able to show is the specified
    length minus the length of our ellipsis (as it takes up space too). We''ll use
    the `slice` string method to extract that many characters from the text:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果文本长度超过最大长度，我们需要添加省略号。我们能够显示的最大字符数是指定的长度减去省略号的长度（因为它也占用空间）。我们将使用`slice`字符串方法从文本中提取这么多字符：
- en: '[PRE27]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We''ll find the last word boundary before the cutoff, using `lastIndexOf`,
    and then combine the text up to that point with the ellipsis:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`lastIndexOf`找到截止点之前的最后一个单词边界，然后结合到那个点的文本和省略号：
- en: '[PRE28]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Return the result from the function:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数返回结果：
- en: '[PRE29]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'After the function, create a few calls to the function with different parameter types:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数之后，创建几个使用不同参数类型的函数调用：
- en: '[PRE30]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Save the file and run the following command in the folder:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在文件夹中运行以下命令：
- en: '[PRE31]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Verify that the file did not compile correctly. You will get specifics from
    the compiler about the errors found, and the compilation will end with the following message:'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证文件没有正确编译。您将从编译器那里获得关于找到的错误的具体信息，并且编译将以以下消息结束：
- en: '[PRE32]'
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Comment out or delete all invocations except the first one:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注释掉或删除除了第一个之外的所有调用：
- en: '[PRE33]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Save the file and compile it again:'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并再次编译：
- en: '[PRE34]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Verify that the compilation ended successfully and that there is a `snippet.js`
    file generated in the same folder. Execute it in the `node` environment with the
    following command:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译成功结束，并且在同一文件夹中生成了一个`snippet.js`文件。在`node`环境中使用以下命令执行它：
- en: '[PRE35]'
  id: totrans-201
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'You will see an output that looks as follows:'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您将看到一个如下所示的输出：
- en: '[PRE36]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In this exercise, we developed a simple string utility function, using TypeScript.
    We saw the two main strengths of TypeScript. For one, we can see that the code
    is idiomatic JavaScript – we could leverage our existing JavaScript knowledge
    to write the function. *Steps 3* through *6*, the actual body of the function,
    are exactly the same in JavaScript and TypeScript.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们开发了一个简单的字符串实用函数，使用了TypeScript。我们看到了TypeScript的两个主要优势。一方面，我们可以看到代码是符合JavaScript语法的
    – 我们可以利用现有的JavaScript知识来编写函数。从*步骤3*到*步骤6*，函数的实际主体在JavaScript和TypeScript中完全相同。
- en: Next, we saw that TypeScript takes care that we invoke the function correctly.
    In *step 7*, we tried five different invocations of the function. The last four
    invocations are incorrect ones – they would have been errors either in JavaScript
    or TypeScript. The important difference is that with TypeScript, we immediately
    got feedback that the usage is invalid. With JavaScript, the errors would have
    only been visible when we, or a client, actually executed the code.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们看到TypeScript会确保我们正确地调用函数。在*步骤7*中，我们尝试了五种不同的函数调用方式。最后四种调用是错误的 – 在JavaScript或TypeScript中它们都会导致错误。重要的区别是，使用TypeScript，我们立即得到了关于使用无效的反馈。在JavaScript中，错误只有在实际执行代码时，我们或客户端才会看到。
- en: TypeScript and Objects
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TypeScript和对象
- en: 'One great thing about JavaScript is its object literal syntax. While in some
    languages, to create an object we have to do a lot of groundwork, such as creating
    classes and defining constructors, in JavaScript, and by extension in TypeScript,
    we can just create the object as a literal. So, if we want to create a `person`
    object, with `firstName` and `lastName` properties, we only need to write the
    following:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的一个优点是其对象字面量语法。在有些语言中，为了创建一个对象，我们必须做很多前期工作，比如创建类和定义构造函数，但在 JavaScript
    中，以及 TypeScript 中，我们只需将对象作为字面量创建。所以，如果我们想创建一个具有 `firstName` 和 `lastName` 属性的 `person`
    对象，我们只需要编写以下内容：
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'JavaScript makes it easy to create and use the object, just like any other
    value. We can access its properties, pass it as an argument into `methods`, receive
    it as a `return` value from functions, and so on. And because of JavaScript''s
    dynamic nature, it''s very easy to add properties to our object. If we wanted
    to add an `age` property to our object, we could just write the following:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 使得创建和使用对象变得很容易，就像任何其他值一样。我们可以访问其属性，将其作为参数传递给 `methods`，从函数中接收它作为
    `return` 值，等等。由于 JavaScript 的动态特性，很容易向我们的对象添加属性。如果我们想向对象添加一个 `age` 属性，我们可以简单地写出以下内容：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'However, because of the loose typing, JavaScript has no knowledge of our object.
    It does not know what the possible properties of our object are, and what methods
    can and cannot use it as an argument or a return value. So, say we make a typo,
    for example, writing out something like this:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于类型宽松，JavaScript 对我们的对象一无所知。它不知道我们对象的可能属性是什么，以及哪些方法和不能将其用作参数或返回值。所以，比如说我们犯了一个拼写错误，例如，写出如下内容：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'JavaScript will happily execute this code and write out `Hi undefined`. That
    is not what we intended, and will only be visible and detectible when the code
    is actually run in the browser. Using TypeScript, we have a few options to remedy
    that. So, let''s rewrite our `person` object using TypeScript:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 会愉快地执行此代码并输出 `Hi undefined`。这并不是我们想要的，并且只有在代码在浏览器中实际运行时才会可见和可检测。使用
    TypeScript，我们有几种选项来解决这个问题。所以，让我们用 TypeScript 重新编写我们的 `person` 对象：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'This code will immediately be marked as invalid by the compiler, even when
    we haven''t added any type information:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码将被编译器立即标记为无效，即使我们没有添加任何类型信息：
- en: '![Figure 1.10: TypeScript compiler inferring the type of the object'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10：TypeScript 编译器推断对象的类型'
- en: '](img/B14508_01_10.jpg)'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_01_10.jpg)'
- en: 'Figure 1.10: TypeScript compiler inferring the type of the object'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10：TypeScript 编译器推断对象的类型'
- en: From the error message, we can see what the TypeScript compiler inferred for
    the type of our object – it thinks that its type consists of two properties, `firstName`
    of type `string` and `lastName` of type `string`. And according to that definition,
    there is no place for another property called `fristName`, so we are issued an
    error.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 从错误信息中，我们可以看到 TypeScript 编译器为我们对象的类型推断了什么——它认为其类型由两个属性组成，`firstName` 类型为 `string`
    和 `lastName` 类型为 `string`。根据这个定义，没有名为 `fristName` 的另一个属性的位置，所以我们收到了一个错误。
- en: Note
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Notice the suggestion `Did you mean 'firstName'?` along with the link to the
    definition of the `person` class. Since typos are common, the type inference algorithm
    tries to detect and offer suggestions on common typos.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 注意到建议 `你是指 'firstName' 吗？` 以及到 `person` 类定义的链接。由于拼写错误很常见，类型推断算法试图检测并提供对常见拼写错误的建议。
- en: 'So, once more, we have detected a bug in our code just by using TypeScript,
    with no additional code written. TypeScript does this by analyzing the definition
    of the object and extracts the data from there. It will allow us to write code
    such as the following:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，再次强调，我们仅通过使用 TypeScript 就检测到了代码中的错误，而无需编写任何额外的代码。TypeScript 通过分析对象的定义并从中提取数据来实现这一点。它将允许我们编写如下代码：
- en: '[PRE41]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'But it will not allow us to write code where we set `lastName` to a number:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 但它不会允许我们编写将 `lastName` 设置为数字的代码：
- en: '![Figure 1.11: Error message by assigning an incorrect type to lastName'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11：将 lastName 分配为错误类型时的错误信息'
- en: '](img/B14508_01_11.jpg)'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/B14508_01_11.jpg)'
- en: 'Figure 1.11: Error message by assigning an incorrect type to lastName'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11：将 lastName 分配为错误类型时的错误信息
- en: 'Sometimes, we know more about the shape of our objects than TypeScript does.
    For example, TypeScript inferred that our type has only the `firstName` and `lastName`
    properties. So, if we set the age in TypeScript, with `person.age = 36;`, we will
    get an error. In this case, we can explicitly define the type of our object, using
    a TypeScript interface. The syntax that we can use looks as follows:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们对对象的形状比 TypeScript 更了解。例如，TypeScript 推断出我们的类型只有 `firstName` 和 `lastName`
    属性。所以，如果我们用 `person.age = 36;` 在 TypeScript 中设置年龄，我们会得到一个错误。在这种情况下，我们可以显式地定义我们对象的类型，使用
    TypeScript 接口。我们可以使用的语法如下：
- en: '[PRE42]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: With this piece of code, we're defining an abstract – a structure that some
    object will need to satisfy in order to be allowed to be treated as a `Person`
    object. Notice the question mark (`?`) next to the `age` variable name. That denotes
    that that property is in fact optional. An object does not have to have an `age`
    property in order to be a `Person` object. However, if it does have an `age` property,
    that property has to be a number. The two other properties (`firstName` and `lastName`)
    are mandatory.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，我们定义了一个抽象 – 一个某些对象需要满足的结构，以便能够被当作 `Person` 对象对待。注意 `age` 变量旁边的问号（`?`）。这表示该属性实际上是可选的。一个对象不一定要有
    `age` 属性才能成为 `Person` 对象。然而，如果它有 `age` 属性，该属性必须是数字。另外两个属性（`firstName` 和 `lastName`）是必需的。
- en: 'Using this definition, we can define and use our object using the following:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个定义，我们可以使用以下方式定义和使用我们的对象：
- en: '[PRE43]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'We can use interfaces as type annotations for function arguments and return
    types as well. For example, we can define a function called `showFullName` that
    will take a person object and display the full name to the console:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将接口用作函数参数和返回类型的类型注解。例如，我们可以定义一个名为 `showFullName` 的函数，它将接受一个人员对象并在控制台显示全名：
- en: '[PRE44]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'If we invoke this function with `showFullName(person)`, we''ll see that it
    will display `Ada Lovelace` on the console. We can also define a function that
    will take two strings, and return a new object that fits the `Person` interface:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们用 `showFullName(person)` 调用这个函数，我们会在控制台看到它将显示 `Ada Lovelace`。我们还可以定义一个函数，它将接受两个字符串，并返回一个符合
    `Person` 接口的新对象：
- en: '[PRE45]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: One important thing that we need to point out is that, unlike in other languages,
    the interfaces in TypeScript are structural and not nominal. What that means is
    that if we have a certain object that fulfills the "rules" of the interface, that
    object can be considered to be a value of that interface. In our `makePerson`
    function, we did not specify that the `result` variable is of the `Person` type
    – we just used an object literal with `firstName` and `lastName` properties, which
    were strings. Since that is enough to be considered a person, the code compiles
    and runs just fine. This is a huge boon to the type inference system, as we can
    have lots of type checks without having to explicitly define them. In fact, it's
    quite common to omit the return type of functions.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要指出的一件重要的事情是，与其它语言不同，TypeScript 中的接口是结构性的，而不是名义性的。这意味着，如果我们有一个满足接口“规则”的特定对象，那么这个对象可以被认为是该接口的值。在我们的
    `makePerson` 函数中，我们没有指定 `result` 变量是 `Person` 类型 – 我们只是使用了一个具有 `firstName` 和 `lastName`
    属性的对象字面量，这些属性都是字符串。由于这足以被认为是人，代码可以编译并正常运行。这对类型推断系统来说是一个巨大的好处，因为我们可以在不显式定义它们的情况下进行大量的类型检查。事实上，省略函数的返回类型是很常见的。
- en: 'Exercise 1.03: Working with Objects'
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.03：与对象一起工作
- en: 'In this exercise, we''ll define a simple object that encapsulates a book with
    a few properties. We''ll try to access and modify the object''s data and verify
    that TypeScript constrains us according to inferred or explicit rules. We will
    also create a function that takes a book object and prints out the book''s details:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个简单的对象，它封装了一个带有几个属性的书籍。我们将尝试访问和修改对象的数据，并验证 TypeScript 根据推断或显式规则来约束我们。我们还将创建一个函数，该函数接受一个书籍对象并打印出书籍的详细信息：
- en: Note
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/N8y1f](https://packt.link/N8y1f).'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下链接找到：[https://packt.link/N8y1f](https://packt.link/N8y1f)。
- en: Create a new file called `book.ts`.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `book.ts` 的新文件。
- en: 'In `book.ts`, define a simple interface called `Book`. We will have properties
    for the author and the title of the book, optional properties for the number of
    pages of the book, and a Boolean that denotes whether we have read the book:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `book.ts` 中，定义一个简单的接口 `Book`。我们将为书籍的作者和标题添加属性，为书籍的页数添加可选属性，以及一个表示我们是否已阅读这本书的布尔值：
- en: '[PRE46]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Add a function called `showBook` that will display the book''s author and title
    to the console. It should also display whether the book has been read or not,
    that is, whether the `isRead` property is present:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`showBook`的函数，该函数将显示书籍的作者和标题到控制台。它还应显示书籍是否已被阅读，即`isRead`属性是否存在：
- en: '[PRE47]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a function called `setPages` that will take a book and a number of pages
    as parameters, and set the `pages` property of the book to the provided value:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`setPages`的函数，该函数将接受一本书和页数作为参数，并将书的`pages`属性设置为提供的值：
- en: '[PRE48]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Add a function called `readBook` that will take a book and mark it as having
    been read:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`readBook`的函数，该函数将接受一本书并将其标记为已阅读：
- en: '[PRE49]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Create several objects that fulfill the interface. You can, but don''t have
    to, annotate them with the interface we have created:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建几个满足接口的对象。你可以，但不必，用我们创建的接口注释它们：
- en: '[PRE50]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Add code that will call methods on the books:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个调用书籍上方法的代码：
- en: '[PRE51]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'Save the file and run the following command in the folder:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在文件夹中运行以下命令：
- en: '[PRE52]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Verify that the compilation ended successfully and that there is a `book.js`
    file generated in the same folder. Execute it in the `node` environment with the
    following command:'
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功结束，并在同一文件夹中生成了一个`book.js`文件。使用以下命令在`node`环境中执行它：
- en: '[PRE53]'
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'You will see an output that looks as follows:'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到如下所示的输出：
- en: '[PRE54]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In this exercise, we created and used an interface, a purely TypeScript construct.
    We used it to describe the shape of the objects we will use. Without actually
    creating any specific objects of that shape, we were able to use the full power
    of TypeScript's tooling and type inference to create a couple of functions that
    operate on the objects of the given shape.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们创建并使用了接口，这是一个纯TypeScript结构。我们用它来描述我们将使用的对象的形状。在没有实际创建任何特定形状的对象的情况下，我们能够使用TypeScript的工具和类型推断的全部功能来创建几个操作给定形状对象的函数。
- en: After that, we were able to actually create some objects that had the required
    shape (with and without making the declaration explicit). We were able to use
    both kinds of objects as parameters to our functions, and the results were in
    line with the interface we declared.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们实际上创建了一些具有所需形状的对象（无论是否明确声明）。我们能够将这两种类型的对象作为函数的参数使用，并且结果与我们所声明的接口一致。
- en: This demonstrated how a simple addition of an interface made our code much safer
    to write and execute.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 这演示了添加一个接口如何使我们的代码在编写和执行时更加安全。
- en: Basic Types
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本类型
- en: 'Even though JavaScript is a loosely typed language, that does not mean that
    values do not have types. There are several primitive types that are available
    to the JavaScript developer. We can get the type of the value using the `typeof`
    operator, available both in JavaScript and TypeScript. Let''s inspect some values
    and see what the results will be:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管JavaScript是一种弱类型语言，但这并不意味着值没有类型。JavaScript开发者可以使用几种原始类型。我们可以使用`typeof`运算符来获取值的类型，该运算符在JavaScript和TypeScript中都可用。让我们检查一些值并查看结果：
- en: '[PRE55]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'The execution of the preceding code will write the string `"number"` to the
    console. Now, consider another snippet:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码的执行将在控制台写入字符串`"number"`。现在，考虑另一个片段：
- en: '[PRE56]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'The preceding expression will write the string `"string"` to the console. Consider
    the following snippet:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 上述表达式将在控制台写入字符串`"string"`。考虑以下片段：
- en: '[PRE57]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This will write out `"boolean"` to the console.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台输出`"boolean"`。
- en: 'All of the preceding types are what are called "primitives." They are baked
    directly into the execution environment, whether that is a browser or a server-side
    application. We can always use them as needed. There is an additional primitive
    type that has only a single value, and that''s the undefined type, whose only
    value is undefined. If we try to call `typeof` undefined, we will receive the
    string `"undefined"`. Other than the primitives, JavaScript and by extension TypeScript
    have two so-called "structural" types. Those are, respectively, objects, that
    is, custom-created pieces of code that contain data, and functions, that is, custom-created
    pieces of code that contain logic. This distinction between data and logic is
    not a clear-cut border, but it can be a useful approximation. For example, we
    can define an object with some properties using the object literal syntax:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的前述类型都被称为“原始类型”。它们直接嵌入到执行环境中，无论是浏览器还是服务器端应用程序。我们总是可以根据需要使用它们。还有一个只有一个值的额外原始类型，那就是
    `undefined` 类型，其唯一值就是 `undefined`。如果我们尝试对 `undefined` 调用 `typeof`，我们将收到字符串 `"undefined"`。除了原始类型之外，JavaScript
    和 TypeScript 还有两种所谓的“结构化”类型。分别是对象，即包含数据的自定义代码片段，和函数，即包含逻辑的自定义代码片段。这种数据和逻辑之间的区别并不是一个明确的界限，但它可以是一个有用的近似。例如，我们可以使用对象字面量语法定义一个具有一些属性的对象：
- en: '[PRE58]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Calling the `typeof` operator on the `days` object will return the string `"object"`.
    We can also use the `typeof` operator if we have an `add` function as we defined before:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 对 `days` 对象调用 `typeof` 操作符将返回字符串 `"object"`。如果我们有一个之前定义的 `add` 函数，我们也可以使用 `typeof`
    操作符：
- en: '[PRE59]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This will display the string `"function"`.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 这将显示字符串 `"function"`。
- en: Note
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Recent versions of JavaScript added `bigint` and `symbol` as primitive types,
    but they won't be encountered outside of specific scenarios.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的最新版本增加了 `bigint` 和 `symbol` 作为原始类型，但它们只在特定场景下才会遇到。
- en: 'Exercise 1.04: Examining typeof'
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.04：检查 typeof
- en: 'In this exercise, we''ll see how to use the `typeof` operator to determine
    the type of a value, and we will investigate the responses:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将看到如何使用 `typeof` 操作符来确定值的类型，并且我们将调查这些响应：
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/uhJqN](https://packt.link/uhJqN).'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在以下链接找到：[https://packt.link/uhJqN](https://packt.link/uhJqN)。
- en: Create a new file called `type-test.ts`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `type-test.ts` 的新文件。
- en: 'In `type-test.ts`, define several variables with differing values:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `type-test.ts` 文件中，定义几个具有不同值的变量：
- en: '[PRE60]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Add all the variables into a containing array, using the array literal syntax:'
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组字面量语法将所有变量添加到一个包含数组中：
- en: '[PRE61]'
  id: totrans-287
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Loop all the variables using a `for..of` loop, and for each value, call the
    `typeof` operator. Show the result on the console, along with the value itself:'
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `for..of` 循环遍历所有变量，并对每个值调用 `typeof` 操作符。在控制台上显示结果，包括值本身：
- en: '[PRE62]'
  id: totrans-289
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Save the file and run the following command in the folder:'
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在文件夹中运行以下命令：
- en: '[PRE63]'
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After the compilation is done, you will have a `type-test.js` file. Execute
    it in the `node` environment with the following command:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编译完成后，你将有一个 `type-test.js` 文件。使用以下命令在 `node` 环境中执行它：
- en: '[PRE64]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'You will see that the output is as follows:'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到以下输出：
- en: '[PRE65]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note specifically the output from the `months` and `nothing. typeof` variables
    will return the string `"object"` both for arrays and the `null` value. Also note
    that the `calculator` variable is an object whose only property is actually a
    function; that is, we have an object whose piece of data is actually a piece of
    logic. This is possible because functions are first-class values in JavaScript
    and TypeScript, which means that we can manipulate them just like we would regular
    values.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 特别注意 `months` 和 `nothing. typeof` 变量的输出，它们对于数组和 `null` 值都会返回字符串 `"object"`。还要注意，`calculator`
    变量是一个对象，其唯一的属性实际上是一个函数；也就是说，我们有一个对象，其数据部分实际上是一段逻辑。这是可能的，因为函数在 JavaScript 和 TypeScript
    中是一等值，这意味着我们可以像处理常规值一样操作它们。
- en: Strings
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: Words and text are part of any application, just as they are part of everyday
    life. In JavaScript, they are represented by the `string` type. Unlike in other
    languages, such as C++ or Java, strings in JavaScripts are not treated as an array-like
    object that consists of smaller parts (characters). Instead, strings are a first-order
    citizen of JavaScript. In addition, JavaScript strings natively support Unicode,
    so we won't get any problems with characters with, for example, Cyrillic or Arabic
    script. Just like in JavaScript, to define a string in TypeScript, we can use
    single quotes (`'`) or double quotes (`"`). Of course, if we start the string
    with a single quote, we have to end it with a single quote, and vice versa. We
    can also use a special type of string definition, called *template strings*. These
    strings are delimited with the backtick character (`` ` ``) and support two very
    important things for web development – newlines and embedded expressions. They
    are supported in all environments that support ES2015, but TypeScript is able
    to compile to any JavaScript target environment.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 单词和文本是任何应用程序的一部分，就像它们是日常生活的一部分一样。在JavaScript中，它们由`string`类型表示。与C++或Java等其他语言不同，JavaScript中的字符串不是作为由更小部分（字符）组成的类似数组的对象来处理的。相反，字符串是JavaScript的一等公民。此外，JavaScript字符串原生支持Unicode，因此我们不会遇到像西里尔文或阿拉伯文这样的字符问题。就像在JavaScript中一样，要在TypeScript中定义一个字符串，我们可以使用单引号(`'`)或双引号(`"`)。当然，如果我们以单引号开始字符串，我们必须以单引号结束，反之亦然。我们还可以使用一种特殊的字符串定义类型，称为*模板字符串*。这些字符串由反引号字符(```
    ` ``)分隔，并支持对Web开发非常重要的两个特性——换行和嵌入表达式。它们在所有支持ES2015的环境中得到支持，但TypeScript能够编译到任何JavaScript目标环境。
- en: 'Using embedded expressions and newlines inside a string enables us to generate
    nice HTML, because instead of string concatenation, we''re able to use embedded
    expressions to have a much clearer view of the generated output. For example,
    if we had a `person` object with `firstName` and `lastName` properties, and we
    wanted to display a simple greeting inside a `<div>` tag, we would have to write
    code as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在字符串内部使用嵌入表达式和换行，使我们能够生成漂亮的HTML，因为与字符串连接不同，我们能够使用嵌入表达式来获得对生成输出的更清晰视图。例如，如果我们有一个具有`firstName`和`lastName`属性的`person`对象，并且我们想在`<div>`标签内显示一个简单的问候语，我们必须编写如下代码：
- en: '[PRE66]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'From this code (which can get much more complex), it''s difficult to see what
    will actually be written and where. Using template strings transforms this into
    the following:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 从这段代码（它可以变得更加复杂）中，很难看出实际会写什么以及在哪里写。使用模板字符串可以将它转换为以下形式：
- en: '[PRE67]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: In order to output the `firstName` and `lastName` values, we have to surround
    them with brackets (`{}`), preceded by a dollar sign (`$`). We are not limited
    to variable names, but can have whole expressions, including the conditional operator
    (`?:`).
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了输出`firstName`和`lastName`的值，我们必须用括号(`{}`)将它们括起来，并在其前加上美元符号(`$`)。我们不仅限于变量名，还可以有整个表达式，包括条件运算符(`?:`)。
- en: Numbers
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数字
- en: Numbers are an important aspect of the world. We use them to quantify everything
    around us. And, it's worth noting, that there are two quite different kinds of
    numbers that you encounter in your daily life – integers and real numbers. One
    distinguishing difference between the two kinds of numbers is that integers are
    numbers without any fractional part. These often result from counting things;
    for example, the number of people in town. On the other hand, real numbers can
    have a fractional component to them. For example, the weight or height of a person
    is often a real number.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 数字是世界的 重要方面。我们用它们来量化我们周围的一切。值得注意的是，你在日常生活中会遇到两种相当不同的数字类型——整数和实数。这两种数字之间的一种区别是，整数是没有小数部分的数字。这些通常来自计数；例如，城镇中的人数。另一方面，实数可以有分数部分。例如，一个人的体重或身高通常是一个实数。
- en: In most programming languages, these two types of numbers are represented with
    (at least) two different primitive types; for example, in C#, we have a type called
    `int` for integers and a type called `float` for real numbers.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数编程语言中，这两种类型的数字至少用两种不同的原始类型来表示；例如，在C#中，我们有一个名为`int`的整数类型和一个名为`float`的实数类型。
- en: In JavaScript, and consequently in TypeScript, they are indeed the same primitive
    type. That primitive type is simply called `number`. Under the hood, it's a 64-bit
    floating-point number, fully implementing the IEEE 754 standard. This standard
    is specified for real numbers, and this leads to some weirdness that is specific
    to JavaScript. For example, in most environments, dividing by zero results in
    an error. In JavaScript and TypeScript, division by zero results in some special
    numbers such as `Infinity` or `NaN`. Additionally, there is no concept of integer
    division in JavaScript, as division is always done using real numbers.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，以及 TypeScript 中，它们确实是相同的原始类型。这个原始类型简单地称为 `number`。在底层，它是一个 64
    位浮点数，完全实现了 IEEE 754 标准。这个标准是为实数指定的，这导致了一些在 JavaScript 中特有的奇怪现象。例如，在大多数环境中，除以零会导致错误。在
    JavaScript 和 TypeScript 中，除以零会导致一些特殊的数字，例如 `Infinity` 或 `NaN`。此外，JavaScript 中没有整数除法这个概念，因为除法总是使用实数进行。
- en: However, even if everything is stored as floating-point real numbers, JavaScript
    guarantees that all operations that can be done using only integer arithmetic
    will be done exactly. One famous example of this behavior is adding `0.1` to `0.2`.
    In all compliant JavaScript engines, we get the result `0.30000000000000004` because
    of the finite precision of the underlying type. What we are guaranteed is that
    we can never get a decimal result if we are adding integers. The engine makes
    sure that `1+1=2` with no decimal remainder. All integer operations are completely
    safe, but only if the results are within a specified range. JavaScript has a special
    constant defined (`Number.MAX_SAFE_INTEGER`) with a value of `9007199254740991`
    (with digit grouping, this is represented as `9.007.199.254.740.991`) over which
    we might get precision and rounding errors.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使所有内容都存储为浮点实数，JavaScript 保证所有仅使用整数算术可以进行的操作都将被精确执行。一个著名的例子是将 `0.1` 加到 `0.2`
    上。在所有符合标准的 JavaScript 引擎中，我们得到的结果是 `0.30000000000000004`，这是因为底层类型的有限精度。我们保证的是，如果我们正在添加整数，我们永远不会得到小数结果。引擎确保
    `1+1=2`，没有小数余数。所有整数操作都是完全安全的，但前提是结果在指定的范围内。JavaScript 定义了一个特殊的常量（`Number.MAX_SAFE_INTEGER`），其值为
    `9007199254740991`（带数字分组，表示为 `9.007.199.254.740.991`），超过这个值我们可能会遇到精度和舍入错误。
- en: Booleans
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布尔类型
- en: Booleans are one of the simplest, and also one of the most used and useful,
    primitive types. This datatype has exactly two values, `true` and `false`. The
    useful thing is that if a variable of this type does not have a certain value,
    well, then it automatically has the other, as that is the only other possible
    option. In theory, this is sound, but in JavaScript, there are a lot of possibilities
    for things to go wrong. Since it has no type information, it cannot guarantee
    that a certain variable actually holds a Boolean value, which means that we always
    have to be careful of our Boolean checks.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔类型是最简单，同时也是最常用且最有用的原始类型之一。这种数据类型恰好有两个值，`true` 和 `false`。有用的地方在于，如果一个变量的这种类型没有特定的值，那么它自动具有另一个值，因为这是唯一可能的另一个选项。在理论上，这是合理的，但在
    JavaScript 中，有很多可能导致错误的情况。由于它没有类型信息，它不能保证某个变量实际上持有布尔值，这意味着我们总是必须小心我们的布尔检查。
- en: 'TypeScript completely defines away this problem. Say we define a variable as
    a Boolean, using either a type annotation or type inference, as follows:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 完全解决了这个问题。比如说，我们定义一个变量为布尔类型，无论是使用类型注解还是类型推断，如下所示：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: We can be absolutely sure that the variable will always have exactly one of
    the two possible values.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以绝对确信变量将始终具有两种可能值之一。
- en: Arrays
  id: totrans-314
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数组
- en: 'One of the reasons computers are popular, aside from accessing social networking
    sites and playing video games, is that they are able to run the same processing
    algorithm on a whole collection of values, as many times as needed, without getting
    bored or making any errors. In order to be able to do that, we need to somehow
    organize the data into a collection of similar values that we can access one at
    a time. In JavaScript, the primary mechanism for such processing is the array.
    JavaScript has an extremely simple interface for creating arrays using the array
    literal syntax. We just list the elements, surrounded by brackets (`[ ]`), and
    we have an array:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 除了访问社交网站和玩电子游戏之外，计算机之所以受欢迎，其中一个原因就是它们能够对整个值集合运行相同的处理算法，无论需要多少次，都不会感到无聊或出错。为了能够做到这一点，我们需要以某种方式将数据组织成一系列相似的值，我们可以一次访问一个。在
    JavaScript 中，处理此类数据的主要机制是数组。JavaScript 使用数组字面量语法创建数组具有极其简单的接口。我们只需列出元素，用括号（`[
    ]`）包围，就得到了一个数组：
- en: '[PRE69]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We can access that array using an index:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用索引来访问该数组：
- en: '[PRE70]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'That makes it easy to use a `for` loop to go through the elements and process
    them all with a single piece of code:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 这使得使用 `for` 循环遍历元素并使用单一代码块处理所有元素变得很容易：
- en: '[PRE71]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'We can also use a `for..of` loop to iterate through the values, and the following
    snippet will calculate the sum of all the numbers in the array:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用 `for..of` 循环来遍历值，以下代码片段将计算数组中所有数字的总和：
- en: '[PRE72]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'As with anything in JavaScript, it has no mechanism to enforce that all the
    items in an array satisfy the "similarity" requirement we mentioned previously.
    So, there''s nothing stopping us from adding a string, a Boolean, an object, or
    even a function to the array of numbers we have defined. All of these are valid
    JavaScript commands that will execute successfully:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 与 JavaScript 中的任何事物一样，它没有机制来强制数组中的所有项目都满足我们之前提到的“相似性”要求。因此，我们无法阻止我们向定义的数字数组中添加字符串、布尔值、对象，甚至函数。所有这些都是有效的
    JavaScript 命令，将成功执行：
- en: '[PRE73]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: In almost all cases, it is not to our benefit to have an array with vastly different
    types as elements. The main benefit of arrays is that we can group similar items
    together and work with all of them with the same code. If we have different types,
    we lose that advantage, so we might as well not use an array at all.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: '在几乎所有情况下，拥有具有不同类型的数组元素对我们来说都没有好处。数组的主要好处是我们可以将相似的项目分组在一起，并使用相同的代码处理所有这些项目。如果我们有不同的类型，我们就失去了这个优势，所以我们甚至可以不使用数组。 '
- en: With TypeScript, we can restrict the type so that an array will only allow a
    single type of value for its elements. Arrays have something that is referred
    to as a *composite* or *generic* type. That means that when we are specifying
    the type of the array, we're specifying it indirectly, via another type.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，我们可以限制类型，使得数组只允许其元素具有单一类型。数组有一种被称为 *复合* 或 *泛型* 的类型。这意味着当我们指定数组的类型时，我们实际上是间接指定的，通过另一个类型。
- en: 'In this case, we define the type of the array through the type of the array''s
    elements, for example, we can have an array whose elements will be numbers or
    an array whose elements will be strings. In TypeScript, we denote that by writing
    the type of the element and then appending brackets to the type name. So, if we
    needed our `numbers` array to only accept values whose type is `number`, we will
    denote that as follows:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们通过数组元素的类型来定义数组的类型，例如，我们可以有一个元素为数字的数组，或者一个元素为字符串的数组。在 TypeScript 中，我们通过编写元素类型并在类型名称后附加括号来表示这一点。所以，如果我们需要我们的
    `numbers` 数组只接受类型为 `number` 的值，我们将表示如下：
- en: '[PRE74]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Even better, if we are initializing our array, we can omit the type annotation
    and let TypeScript infer the value:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 更好的是，如果我们初始化数组，我们可以省略类型注解，让 TypeScript 推断值：
- en: '![Figure 1.12: TypeScript inferring the type of the elements in the array'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12：TypeScript 推断数组中元素的类型'
- en: '](img/B14508_01_12.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_01_12.jpg](img/B14508_01_12.jpg)'
- en: 'Figure 1.12: TypeScript inferring the type of the elements in the array'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12：TypeScript 推断数组中元素的类型
- en: As shown previously, TypeScript will not let us use the `push` method with a
    value whose type does not match the type of the elements, nor will it allow elements
    to be set to invalid values.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，TypeScript 不会让我们使用与数组元素类型不匹配的 `push` 方法，也不会允许将元素设置为无效值。
- en: 'Another, equivalent way to denote the type of the array is to use generic type
    syntax. In that case, we can use the `Array` type, with the type of the actual
    elements in angle brackets:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 表示数组类型的另一种等效方法是使用泛型类型语法。在这种情况下，我们可以使用`Array`类型，并在尖括号中指定实际元素的类型：
- en: '[PRE75]'
  id: totrans-335
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: Generic classes and methods will be covered in detail in *Chapter 9, Generics
    and Conditional Types*.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型类和方法将在第9章“泛型和条件类型”中详细介绍。
- en: The benefit here is that we can be certain that if an array claims to have elements
    of a certain type, it will indeed have that kind of element, and we can process
    them without worrying that a bug introduced an incompatible element.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的好处是，我们可以确信，如果一个数组声称具有某种类型的元素，它确实会有那种类型的元素，我们可以处理它们而不用担心引入了不兼容的元素。
- en: Tuples
  id: totrans-338
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 元组
- en: 'Another common usage of arrays in JavaScript is to group data – just like objects,
    but without the hassle (and benefit) of property names. We could, for example,
    instead of creating a `person` object create a `person` array where, by convention,
    we''ll use the first element to hold the first name, the second element to hold
    the last name, and the third element to hold the age. We could define such an
    array using the following:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript中，数组的一个常见用法是分组数据——就像对象一样，但不需要（且没有）属性名带来的麻烦（和好处）。例如，我们可以创建一个`person`数组而不是创建一个`person`对象，按照惯例，我们将使用第一个元素来保存名字，第二个元素来保存姓氏，第三个元素来保存年龄。我们可以使用以下方式定义这样的数组：
- en: '[PRE76]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: In this case, even as we are using the same structure – an array – we're not
    using it to group an unknown number of unrelated data of the same type, we're
    using it to group a known number of related data that can be of separate types.
    This kind of array is called a *tuple*. Once more, JavaScript has no mechanism
    to enforce the structure of a tuple, so in our code we can do lots of things that
    are syntactically valid, but nonsensical semantically. We could add a fourth element
    in the array, we can set the first element to be a number, the third to be a function,
    and so on.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，尽管我们使用的是相同的结构——一个数组——但我们不是用它来分组未知数量的无关数据，而是用它来分组已知数量的相关数据，这些数据可以是不同的类型。这种数组被称为*元组*。再次强调，JavaScript没有机制来强制执行元组的结构，因此在我们的代码中我们可以做很多在语法上是有效的，但在语义上却是无意义的。我们可以在数组中添加第四个元素，我们可以将第一个元素设置为数字，第三个元素设置为函数，等等。
- en: 'With TypeScript, we can formally define the number and types of the data elements
    that we need inside a tuple, using syntax such as the following:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 使用TypeScript，我们可以正式定义元组内部所需的数据元素的数量和类型，使用如下语法：
- en: '[PRE77]'
  id: totrans-343
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'The `[string, string, number]` declaration tells TypeScript that we intend
    to use a tuple of three elements, that the first two elements will be a string,
    and the third will be a number. TypeScript now has enough information to enforce
    the structure. So, if we write code that will call the `toLowerCase` method on
    the first element of the tuple and multiply the third element by 10, that will
    work, as the first operation is valid on a string and the second is valid on a
    number:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: '`[string, string, number]`声明告诉TypeScript我们打算使用一个包含三个元素的元组，前两个元素将是字符串，第三个将是数字。TypeScript现在有足够的信息来强制执行结构。因此，如果我们编写代码来在元组的第一个元素上调用`toLowerCase`方法并将第三个元素乘以10，这将有效，因为第一个操作对字符串是有效的，第二个操作对数字是有效的：'
- en: '[PRE78]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'But if we try the operations the other way around, we''ll get errors on both
    calls:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们尝试以相反的顺序执行操作，两次调用都会出现错误：
- en: '![Figure 1.13: TypeScript error when performing incorrect operations'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.13：TypeScript在执行错误操作时的错误](img/B14508_01_13.jpg)'
- en: '](img/B14508_01_13.jpg)'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_01_13.jpg](img/B14508_01_13.jpg)'
- en: 'Figure 1.13: TypeScript error when performing incorrect operations'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13：TypeScript在执行错误操作时的错误
- en: 'Additionally, if we try to access an element that is outside of the defined
    range, we''ll get an error as well:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们尝试访问定义范围之外的一个元素，也会出现错误：
- en: '![Figure 1.14: TypeScript when accessing elements outside the defined range'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.14：TypeScript在访问定义范围之外的元素时](img/B14508_01_14.jpg)'
- en: '](img/B14508_01_14.jpg)'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片 B14508_01_14.jpg](img/B14508_01_14.jpg)'
- en: 'Figure 1.14: TypeScript when accessing elements outside the defined range'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14：TypeScript在访问定义范围之外的元素时
- en: Schwartzian transform
  id: totrans-354
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Schwartzian转换
- en: 'Arrays have a helpful sort function, which we can use to sort the objects contained
    in the array. However, during the sorting process, multiple comparisons will be
    done on the same objects. For example, if we sort an array of 100 numbers, the
    method that compares two numbers will be called more than 500 times, on average.
    Let''s say that we have a `Person` interface, defined with the following:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 数组有一个有用的排序函数，我们可以用它来对数组中的对象进行排序。然而，在排序过程中，会对相同的对象进行多次比较。例如，如果我们对一个包含100个数字的数组进行排序，比较两个数字的方法平均会被调用超过500次。假设我们有一个`Person`接口，如下定义：
- en: '[PRE79]'
  id: totrans-356
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'If we want to get the full name of the person, we might use a function such
    as this:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想获取某人的全名，我们可能会使用如下函数：
- en: '[PRE80]'
  id: totrans-358
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If we have an array of `Person` objects, called `persons`, and want to sort
    it according to full name, we might use the following code:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有一个名为`persons`的`Person`对象数组，并想按全名对其进行排序，我们可能会使用以下代码：
- en: '[PRE81]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: This will sort the `persons` array, albeit in an inefficient manner. If we have
    100 `Person` objects, this means that we have 100 different targets for the `getFullName`
    functions. But if we have more than 500 calls to the comparison function, that
    would mean that we have more than 1,000 calls to the `getFullName` function, so
    at least 900 calls are redundant.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按不高效的方式对`persons`数组进行排序。如果我们有100个`Person`对象，这意味着我们有100个不同的目标调用`getFullName`函数。但如果比较函数的调用超过500次，那么就意味着对`getFullName`函数的调用超过1000次，所以至少有900次调用是多余的。
- en: Note
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The relation gets worse: for 10,000 persons, we will have around a quarter
    of a million redundant calls.'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 关系变得更糟：对于10,000个人，我们将有大约25万的冗余调用。
- en: Our method is fast and trivial, but if some expensive calculations were needed,
    simple sorting could slow down our application.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的方法既快又简单，但如果需要一些昂贵的计算，简单的排序可能会减慢我们的应用程序。
- en: 'Fortunately, there''s a simple technique called a Schwartzian transform that
    can help us with that. The technique has three parts:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，有一种简单的技术称为Schwartzian转换，可以帮助我们解决这个问题。这项技术有三个部分：
- en: We will transform each element in the array into a tuple of two elements. The
    first element of the tuple will be the original value, and the second will be
    the result of the ordering function (colloquially, the Schwartz).
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将把数组中的每个元素转换成一个包含两个元素的元组。元组的第一个元素将是原始值，第二个将是排序函数的结果（口语中称为Schwartz）。
- en: We will sort the array on the second element of the tuple.
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将根据元组的第二个元素对数组进行排序。
- en: We will transform each tuple, discarding the ordering element and taking the
    original value.
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将转换每个元组，丢弃排序元素，并取原始值。
- en: We will employ this technique in the following exercise.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在下面的练习中使用这项技术。
- en: 'Exercise 1.05: Using Arrays and Tuples to Create an Efficient Sort of Objects'
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.05：使用数组和元组创建对象的高效排序
- en: In this exercise, we are going to employ the Schwartzian transform to sort and
    print a predefined array of programmers. Each programmer object will be an instance
    of the `Person` interface, defined in the previous section.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将使用Schwartzian转换来排序并打印预定义的程序员数组。每个程序员对象将是上一节中定义的`Person`接口的一个实例。
- en: We'll want to sort the programmers based on their full name, which can be calculated
    using the `getFullName` function, also from the previous section.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望根据全名对程序员进行排序，这可以通过上一节中的`getFullName`函数来计算。
- en: 'In order to implement a Schwartzian transform, we''ll take the following steps:'
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现Schwartzian转换，我们将采取以下步骤：
- en: We'll use the `map` method of the array in order to transform our programmers
    into a tuple of the `[Person, string]` type, where the first element is the actual
    programmer and the second element is the full name string.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用数组的`map`方法来将程序员转换成`[Person, string]`类型的元组，其中第一个元素是实际的程序员，第二个元素是全名字符串。
- en: We'll use the `sort` method of the array to sort the tuples, using the second
    element of each tuple.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用数组的`sort`方法对元组进行排序，使用每个元组的第二个元素。
- en: We'll use the `map` method once more to transform the tuples back to an array
    of programmers by just taking the first element and discarding the second element.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将再次使用`map`方法将元组转换回程序员的数组，只需取第一个元素并丢弃第二个元素。
- en: 'Let''s start:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Note
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/EgZnX](https://packt.link/EgZnX).'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习的代码文件可以在以下链接找到：[https://packt.link/EgZnX](https://packt.link/EgZnX)。
- en: Create a new file called `person-sort.ts`.
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`person-sort.ts`的新文件。
- en: 'Inside the file, create the interface for the `Person` objects:'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中，为`Person`对象创建接口：
- en: '[PRE82]'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Create the function that will get the full name of a given person:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个获取给定人员全名的函数：
- en: '[PRE83]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: We will use the `count` variable to detect the total number of calls of the function.
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将使用`count`变量来检测函数的总调用次数。
- en: 'Define an array of persons and add a few objects with `firstName` and `lastName`
    properties:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个人员数组，并添加一些具有`firstName`和`lastName`属性的几个对象：
- en: '[PRE84]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Define a naïve and straight forward sorting function:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个简单直接的排序函数：
- en: '[PRE85]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Use a Schwartzian transform and define a function that will take an array of
    persons and return (a sorted) array of persons:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Schwartzian转换并定义一个函数，该函数将接受人员数组并返回（排序后的）人员数组：
- en: '[PRE86]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Use the array''s `map` function to transform each element into a tuple:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用数组的`map`函数将每个元素转换为一个元组：
- en: '[PRE87]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Sort the `tuples` array of tuples, using the standard `sort` method:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用标准的`sort`方法对元组的`tuples`数组进行排序：
- en: '[PRE88]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: We should note that the `sort` function takes two objects, in our case, two
    tuples, and we sort the tuples according to their second element – the result
    of the `getFullName` call.
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们应该注意，`sort`函数接受两个对象，在我们的情况下，两个元组，我们根据`getFullName`调用的结果按第二个元素对元组进行排序。
- en: 'Transform the sorted array of tuples into the format we want – just an array
    of `person` objects – by taking the first element of each tuple, discarding the Schwartz:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将排序后的元组数组转换为所需的格式——只是一个`person`对象的数组——通过取每个元组的第一个元素，丢弃Schwartz：
- en: '[PRE89]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: The last three steps are the three parts of the Schwartzian transform.
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后三个步骤是Schwartzian转换的三个部分。
- en: 'Return the new array from the function:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数返回新的数组：
- en: '[PRE90]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Add a line that will call the `naiveSortPersons` function on our defined array:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一行代码，调用我们定义的数组上的`naiveSortPersons`函数：
- en: '[PRE91]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: Output both the sorted array, and the count variable.
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出排序后的数组和计数变量。
- en: '[PRE92]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Add a line that will call the `schwartzSortPersons` function on our defined array:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一行代码，调用我们定义的数组上的`schwartzSortPersons`函数：
- en: '[PRE93]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Output both the `sorted` array and the `count` variable. The `count` variable
    should be identical to the number of items in the array, which is 7 in our example.
    Without the optimization, the method would have been called 28 times:'
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出`sorted`数组和`count`变量。`count`变量应该与数组中的项目数量相同，在我们的例子中是7。没有优化，该方法将被调用28次：
- en: '[PRE94]'
  id: totrans-409
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Save and compile the file:'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译文件：
- en: '[PRE95]'
  id: totrans-411
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Verify that the compilation ended successfully and that there is a `person-sort.js`
    file generated in the same folder. Execute it in the `node` environment with the
    following command:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功，并在同一文件夹中生成一个`person-sort.js`文件。在`node`环境中使用以下命令执行它：
- en: '[PRE96]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'You will see an output that looks as follows:'
  id: totrans-414
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到如下所示的输出：
- en: '[PRE97]'
  id: totrans-415
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: We can easily check that the values that are outputted are sorted according
    to their full names. We can also notice a 7 at the end of output – that's the
    total number of calls of the `getFullName` function. Since we have 7 items in
    the programmers array, we can conclude that the function was called just once
    for each object.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地检查输出的值是按照全名排序的。我们还可以注意到输出末尾的7，那是`getFullName`函数调用的总次数。由于程序员数组中有7个项目，我们可以得出结论，该函数对每个对象只调用了一次。
- en: 'We could have instead sorted the programmers array directly, using code such
    as the following:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以改用以下代码直接对程序员数组进行排序：
- en: '[PRE98]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: In this case, for this array, the count of execution of the `getFullName` function
    would have been 28, which is four times as high as our optimized version.
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，对于这个数组，`getFullName`函数的执行次数将是28次，是优化版本的4倍。
- en: Enums
  id: totrans-420
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: Often we have some types that have a predefined set of values, and no other
    value is valid. For example, there are four and only four cardinal directions
    (East, West, North, and South). There are four and only four different suits in
    a deck of cards. So, how do we define a variable that should have such a value?
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 通常我们有一些具有预定义值集的类型，没有其他值是有效的。例如，有四个且只有四个基本方向（东、西、北、南）。一副牌中只有四种不同的花色。那么，我们如何定义一个应该具有这种值的变量呢？
- en: 'In TypeScript, we can use an `enum` type to do that. The simplest way to define
    an enum would be as follows:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，我们可以使用`enum`类型来实现这一点。定义枚举的最简单方法如下：
- en: '[PRE99]'
  id: totrans-423
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'We can then define and use a variable of such type, and TypeScript will help
    us use it:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以定义并使用此类变量，TypeScript将帮助我们使用它：
- en: '[PRE100]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'TypeScript will infer that the type of the `trumpSuit` variable is `Suit` and
    will only allow us to access those four values. Any attempt to assign something
    else to the variable will result in an error:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript会推断`trumpSuit`变量的类型为`Suit`，并且只允许我们访问这四个值。任何尝试将其他内容赋值给该变量的操作都将导致错误：
- en: '![Figure 1.15: TypeScript inferring the type of trumpSuit'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.15：TypeScript推断trumpSuit的类型'
- en: '](img/B14508_01_15.jpg)'
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_01_15.jpg)'
- en: 'Figure 1.15: TypeScript inferring the type of trumpSuit'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.15：TypeScript推断trumpSuit的类型
- en: 'So far, all the types we''ve encountered were JavaScript types that were augmented
    with TypeScript. Unlike that, enums are specific to TypeScript. Under the hood,
    the `Suit` class actually compiles into an object with values like this:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们遇到的所有类型都是TypeScript增强的JavaScript类型。与这些不同，枚举是TypeScript特有的。在底层，`Suit`类实际上编译成一个具有如下值的对象：
- en: '[PRE101]'
  id: totrans-431
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'TypeScript will automatically assign numbers starting with zero to the options
    provided and add a reverse mapping as well, so if we have the option, we can get
    the value, but if we have the value, we can map to the option as well. We can
    also explicitly set the provided numbers as well:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript会自动将零开始的数字分配给提供的选项，并添加反向映射，因此如果我们有选项，我们可以得到值，但如果我们有值，我们也可以映射到选项。我们还可以显式设置提供的数字：
- en: '[PRE102]'
  id: totrans-433
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'We can also use strings instead of numbers, with syntax like this:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以使用字符串而不是数字，语法如下：
- en: '[PRE103]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'These enums are called string-based enums, and they compile to an object like this:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 这些枚举被称为基于字符串的枚举，它们编译成如下对象：
- en: '[PRE104]'
  id: totrans-437
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Any and Unknown
  id: totrans-438
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Any和Unknown
- en: 'So far, we have explained how TypeScript inference works, and how powerful
    it is. But sometimes we actually want to have JavaScript''s "anything goes" behavior.
    For example, what if we genuinely need a variable that will sometimes hold a string
    and sometimes hold a number? The following code will issue an error because we''re
    trying to assign a string to a variable that TypeScript inferred to be a number:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经解释了TypeScript推断的工作原理及其强大之处。但有时我们实际上希望拥有JavaScript的“任何事都可以”的行为。例如，如果我们确实需要一个变量有时会包含字符串有时会包含数字怎么办？以下代码将引发错误，因为我们试图将字符串赋值给TypeScript推断为数字的变量：
- en: '[PRE105]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'This is how the code will appear on VS Code with the error message:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在VS Code中显示的代码及其错误信息：
- en: '![Figure 1.16: TypeScript inferring the type of variable'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.16：TypeScript推断变量的类型'
- en: '](img/B14508_01_16.jpg)'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_01_16.jpg)'
- en: 'Figure 1.16: TypeScript inferring the type of variable'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.16：TypeScript推断变量的类型
- en: 'What we need to do is somehow suspend the type inference for that specific
    variable. To be able to do that, TypeScript provides us with the `any` type:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的是以某种方式暂停对该特定变量的类型推断。为了能够做到这一点，TypeScript为我们提供了`any`类型：
- en: '[PRE106]'
  id: totrans-446
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This type annotation reverts the `variable` variable to the default JavaScript
    behavior, so none of the calls involving that variable will be checked by the
    compiler. Additionally, most calls that include a variable of the `any` type will
    infer a result of the same type. This means that the `any` type is highly contagious,
    and even if we define it in a single place in our application, it can propagate
    to lots of places.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型注解将`variable`变量恢复到JavaScript的默认行为，因此涉及该变量的所有调用都不会被编译器检查。此外，大多数包含`any`类型变量的调用都会推断出相同类型的返回值。这意味着`any`类型具有高度传染性，即使我们在应用程序的单一位置定义它，它也可以传播到很多地方。
- en: Since using `any` effectively negates most of TypeScript's benefits, it's best
    used as seldom as possible, and only when absolutely necessary. It's a powerful
    tool to use the opt-in/opt-out design of TypeScript so that we can gradually upgrade
    existing JavaScript code into TypeScript.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: '由于使用`any`实际上否定了TypeScript的大部分好处，因此最好尽可能少地使用它，并且仅在绝对必要时使用。它是使用TypeScript的opt-in/opt-out设计的一个强大工具，这样我们就可以逐步将现有的JavaScript代码升级到TypeScript。 '
- en: 'One scenario that is sometimes used is a combination of the dynamic nature
    of `any` and the static nature of TypeScript – we can have an array where the
    elements can be anything:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 有时使用的一个场景是`any`的动态性和TypeScript的静态性相结合——我们可以有一个元素可以是任何内容的数组：
- en: '[PRE107]'
  id: totrans-450
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Starting from version 3.0, TypeScript also offers another type with dynamic
    semantics – the `unknown` type. While still dynamic, it''s much more constricted
    in what can be done with it. For example, the following code will compile using
    `any`:'
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 从3.0版本开始，TypeScript还提供了一种具有动态语义的另一种类型——`unknown`类型。虽然仍然是动态的，但它对可以执行的操作有更多的限制。例如，以下代码将使用`any`编译：
- en: '[PRE108]'
  id: totrans-452
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'On the other hand, the same code with an `unknown` type annotation results
    in the following:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，带有 `unknown` 类型注解的相同代码会导致以下结果：
- en: '![Figure 1.17: TypeScript compiler error message'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.17：TypeScript 编译器错误信息'
- en: '](img/B14508_01_17.jpg)'
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_01_17.jpg)'
- en: 'Figure 1.17: TypeScript compiler error message'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.17：TypeScript 编译器错误信息'
- en: 'The `unknown` type basically flips the assertion and the burden of proof. With
    `any`, the flow is that, since we don''t know that it''s not a string, we can
    treat it as a string. With `unknown`, we don''t know whether it''s a string, so
    we can''t treat it as a string. In order to do anything useful with an `unknown`,
    we need to explicitly test its value and determine our actions based on that:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: '`unknown` 类型基本上是反转了断言和证明责任。使用 `any` 时，流程是这样的，因为我们不知道它不是字符串，所以我们可以将其视为字符串。使用
    `unknown` 时，我们不知道它是否是字符串，因此不能将其视为字符串。为了对 `unknown` 执行任何有用的操作，我们需要显式地测试其值并根据该值确定我们的操作：'
- en: '[PRE109]'
  id: totrans-458
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Null and Undefined
  id: totrans-459
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Null 和 Undefined
- en: 'One of the specifics of JavaScript is that it has two separate values that
    signify that there isn''t a value: `null` and `undefined`. The difference between
    the two is that `null` has to be specified explicitly – so if something is `null`,
    that is because someone set it to `null`. Meanwhile, if something has the value
    `undefined` usually it means that the value is not set at all. For example, let''s
    look at a `person` object defined with the following:'
  id: totrans-460
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的一个具体特性是它有两个表示没有值的独立值：`null` 和 `undefined`。这两个值之间的区别在于 `null` 必须被显式指定——所以如果某物是
    `null`，那是因为有人将其设置为 `null`。另一方面，如果某物的值为 `undefined`，通常意味着该值根本未设置。例如，让我们看看以下定义的
    `person` 对象：
- en: '[PRE110]'
  id: totrans-461
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'The value of the `lastName` property has been set to `null` explicitly. On
    the other hand, the `age` property is not set at all. So, if we print them out,
    we''ll see that the `lastName` property has a value of `null`, while the `age`
    property has a value of `undefined`:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: '`lastName` 属性的值已被显式设置为 `null`。另一方面，`age` 属性根本未设置。因此，如果我们打印它们，我们会看到 `lastName`
    属性的值为 `null`，而 `age` 属性的值为 `undefined`：'
- en: '[PRE111]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: We should note that if we have some optional properties in an object, their
    default value will be `undefined`. Similarly, if we have optional parameters in
    a function, the default value of the argument will be `undefined` as well.
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该注意，如果我们有一个对象中有可选属性，它们的默认值将是 `undefined`。同样，如果我们有一个函数中有可选参数，参数的默认值也将是 `undefined`。
- en: Never
  id: totrans-465
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Never
- en: 'There is another "not a value" type that''s specific to TypeScript, and that
    is the special `never` type. This type represents a value that never occurs. For
    example, if we have a function where the end of the function is not reachable
    and has no return statements, its return type will be `never`. An example of such
    a function will be as follows:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 中还有一个特定的“非值”类型，那就是特殊的 `never` 类型。此类型表示永远不会发生值的类型。例如，如果我们有一个函数，函数的末尾不可达且没有返回语句，其返回类型将是
    `never`。这样的函数示例如下：
- en: '[PRE112]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The type of the `value` variable will be inferred as `never`. Another situation
    where `never` is useful is if we have a logical condition that cannot be `true`.
    As a simple example, let''s look at this code:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 变量的类型将被推断为 `never`。`never` 另一个有用的场景是我们有一个无法为真的逻辑条件。作为一个简单的例子，让我们看看以下代码：'
- en: '[PRE113]'
  id: totrans-469
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'The conditional statement will always be `true`, so we will always see the
    text in the console. But if we add an `else` branch to this code, the value of
    `x` inside the branch cannot be `true` because we''re in the `else` branch, but
    cannot be anything else because it was defined as `true`. So, the actual type
    is inferred to be `never`. Since `never` does not have any properties or methods,
    this branch will throw a compile error:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 条件语句始终为 `true`，因此我们总会看到控制台中的文本。但如果我们给这段代码添加一个 `else` 分支，分支内的 `x` 的值不能为 `true`，因为我们处于
    `else` 分支中，但不能是任何其他值，因为它被定义为 `true`。因此，实际推断的类型是 `never`。由于 `never` 没有任何属性或方法，这个分支将抛出编译错误：
- en: '![Figure 1.18: Compiler error from using the never type'
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.18：使用 never 类型导致的编译器错误'
- en: '](img/B14508_01_18.jpg)'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/B14508_01_18.jpg)'
- en: 'Figure 1.18: Compiler error from using the never type'
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.18：使用 never 类型导致的编译器错误
- en: Function Types
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数类型
- en: 'The last built-in type in JavaScript that we''ll take a look at is not really
    a piece of data – it''s a piece of code. Since functions are first-order objects
    in JavaScript, they remain so in TypeScript as well. And just like the others,
    functions get types as well. The type of a function is a bit more complicated
    than the other types. In order to identify it, we need all the parameters and
    their types, as well as the return values and their types. Let''s take a look
    at an `add` function defined with the following:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要查看的 JavaScript 的最后一个内置类型实际上并不是数据的一部分——它是一段代码。由于函数在 JavaScript 中是一阶对象，因此在
    TypeScript 中也是如此。就像其他类型一样，函数也有类型。函数的类型比其他类型要复杂一些。为了识别它，我们需要所有参数及其类型，以及返回值及其类型。让我们看看以下定义的
    `add` 函数：
- en: '[PRE114]'
  id: totrans-476
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'To fully describe the type of the function, we need to know that it is a function
    that takes a number as the first parameter and a number as the second parameter
    and returns a number. In TypeScript, we''ll write this as `(x: number, y: number)
    => number`.'
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: '为了完全描述函数的类型，我们需要知道它是一个接受一个数字作为第一个参数，另一个数字作为第二个参数并返回一个数字的函数。在 TypeScript 中，我们将它写成
    `(x: number, y: number) => number`。'
- en: Making Your Own Types
  id: totrans-478
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建自己的类型
- en: 'Of course, aside from using the types that are already available in JavaScript,
    we can define our own types. We have several options for that. We can use the
    JavaScript `class` specification to declare our own classes, with properties and
    methods. A simple class can be defined with the following:'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，除了使用 JavaScript 中已经可用的类型之外，我们还可以定义自己的类型。我们有几种选择。我们可以使用 JavaScript 的 `class`
    规范来声明自己的类，包括属性和方法。一个简单的类可以用以下方式定义：
- en: '[PRE115]'
  id: totrans-480
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: 'We can create objects of this class and use methods on them:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建此类对象并使用它们的方法：
- en: '[PRE116]'
  id: totrans-482
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Another way to formalize our complex structures is to use an interface:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种形式化我们复杂结构的方法是使用一个接口：
- en: '[PRE117]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: Unlike classes, which compile to JavaScript classes or constructor functions
    (depending on the compilation target), interfaces are a TypeScript-only construct.
    When compiling, they are checked statically, and then removed from the compiled code.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 与将编译为 JavaScript 类或构造函数（取决于编译目标）的类不同，接口是 TypeScript 独有的结构。在编译时，它们会进行静态检查，然后从编译后的代码中删除。
- en: Both classes and interfaces are useful if implementing a class hierarchy, as
    both constructs are suitable for extension and inheritance.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 如果实现类层次结构，类和接口都是有用的，因为这两种结构都适合扩展和继承。
- en: 'Yet another way is to use type aliases, with the `type` keyword. We can basically
    put a name that we will use as a type alias to just about anything available in
    TypeScript. For example, if we want to have another name for the primitive `number`
    type, for example, `integer`, we can always do the following:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是使用类型别名，使用 `type` 关键字。基本上，我们可以将用作类型别名的名称放入 TypeScript 中几乎任何可用的东西。例如，如果我们想为原始的
    `number` 类型提供一个别名，例如 `integer`，我们可以始终这样做：
- en: '[PRE118]'
  id: totrans-488
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'If we want to give a name to a tuple, `[string, string, number?]`, that we
    use to store a person, we can alias that with the following:'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想给一个用于存储人的元组 `[string, string, number?]` 命名，我们可以用以下方式别名它：
- en: '[PRE119]'
  id: totrans-490
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: 'We can also use objects and functions in the definition of a type alias:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以在类型别名的定义中使用对象和函数：
- en: '[PRE120]'
  id: totrans-492
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: We will go into more details and intricacies of the `class`, `interface`, and
    `type` keywords in *Chapter 4*, *Classes and Objects*, *Chapter 5*, *Interfaces
    and Inheritance*, and *Chapter 6*, *Advance Types*, respectively.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在第 4 章“类和对象”、第 5 章“接口和继承”和第 6 章“高级类型”中更详细地探讨 `class`、`interface` 和 `type`
    关键字的复杂性和细节。
- en: 'Exercise 1.06: Making a Calculator Function'
  id: totrans-494
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.06：创建计算器函数
- en: 'In this exercise, we''ll define a calculator function that will take the operands
    and the operation as parameters. We will design it so it is easy to extend it
    with additional operations and use that behavior to extend it:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将定义一个计算器函数，它将接受操作数和操作作为参数。我们将设计它以便于扩展额外的操作，并利用这种行为来扩展它：
- en: Note
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this exercise can be found here: [https://packt.link/dKoCZ](https://packt.link/dKoCZ).'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 本练习的代码文件可以在以下位置找到：[https://packt.link/dKoCZ](https://packt.link/dKoCZ)。
- en: Create a new file called `calculator.ts`.
  id: totrans-498
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `calculator.ts` 的新文件。
- en: 'In `calculator.ts`, define an enum with all the operators that we want to support
    inside our code:'
  id: totrans-499
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `calculator.ts` 中，定义一个枚举，其中包含我们想要在代码中支持的运算符：
- en: '[PRE121]'
  id: totrans-500
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: 'Define an empty (for now) `calculator` function that will be our main interface.
    The function should take three parameters: the two numbers that we want to operate
    on, as well as an operator:'
  id: totrans-501
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个空的（目前）`calculator`函数，它将是我们的主要接口。该函数应接受三个参数：我们要操作的数字以及一个操作符：
- en: '[PRE122]'
  id: totrans-502
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Create a type alias for a function that does a calculation on two numbers.
    Such a function will take two numbers as parameters and return a single number:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为执行两个数字计算的函数创建一个类型别名。此类函数将接受两个数字作为参数并返回一个数字：
- en: '[PRE123]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Create an empty array that can hold multiple tuples of the `[Operator, Operation]`
    type. This will be our dictionary, where we store all our methods:'
  id: totrans-505
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个可以存储多个`[Operator, Operation]`类型元组的空数组。这将是我们字典，其中存储所有我们的方法：
- en: '[PRE124]'
  id: totrans-506
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: 'Create an `add` method that satisfies the `Operation` type (you don''t need
    to explicitly reference it):'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个满足`Operation`类型的`add`方法（你不需要显式引用它）：
- en: '[PRE125]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'Create a tuple of the `Operator.Add` value and the `add` function and add it
    to the `operations` array:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个包含`Operator.Add`值和`add`函数的元组，并将其添加到`operations`数组中：
- en: '[PRE126]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Repeat *steps 6* and *7* for the subtraction, multiplication, and division
    functions:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对减法、乘法和除法函数重复*步骤6*和*步骤7*：
- en: '[PRE127]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'Implement the `calculator` function, using the `operations` array to find the
    correct tuple by the `Operator` provided, and then using the corresponding `Operation`
    value to do the calculation:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现一个`calculator`函数，使用`operations`数组通过提供的`Operator`找到正确的元组，然后使用相应的`Operation`值进行计算：
- en: '[PRE128]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: Note that, as long as a function has the required type, that is, it takes two
    numbers and outputs a number, we can use it as an operation.
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，只要一个函数具有所需类型，即它接受两个数字并输出一个数字，我们就可以将其用作操作。
- en: 'Let''s take the calculator for a test run. Write some code that will call the
    `calculator` function with different arguments:'
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们测试一下计算器。编写一些代码来调用`calculator`函数，并传递不同的参数：
- en: '[PRE129]'
  id: totrans-517
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'Save the file and run the following command in the folder:'
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在文件夹中运行以下命令：
- en: '[PRE130]'
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Verify that the compilation ended successfully and that there is a `calculator.js`
    file generated in the same folder. Execute it in the `node` environment with the
    following command:'
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证编译是否成功完成，并在同一文件夹中生成一个`calculator.js`文件。使用以下命令在`node`环境中执行它：
- en: '[PRE131]'
  id: totrans-521
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE131]'
- en: 'You will see the output looks as follows:'
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到输出如下所示：
- en: '[PRE132]'
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'Now, let''s try to extend our calculator by adding a modulo operation. First,
    we need to add that option to the `Operator` enum:'
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们尝试通过添加模运算来扩展我们的计算器。首先，我们需要将此选项添加到`Operator`枚举中：
- en: '[PRE133]'
  id: totrans-525
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Add a function called `modulo` of the `Operation` type, and add a corresponding
    tuple to the `operations` array:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为`modulo`的`Operation`类型函数，并添加一个相应的元组到`operations`数组中：
- en: '[PRE134]'
  id: totrans-527
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'At the end of the file, add a call to the `calculator` function that uses the
    `Modulo` operator:'
  id: totrans-528
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件末尾添加一个调用`calculator`函数的调用，该函数使用`Modulo`运算符：
- en: '[PRE135]'
  id: totrans-529
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'Save and compile the file and run the resulting JavaScript with the following command:'
  id: totrans-530
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存并编译文件，并使用以下命令运行生成的JavaScript：
- en: '[PRE136]'
  id: totrans-531
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'You will see an output that looks as follows:'
  id: totrans-532
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将看到如下所示的输出：
- en: '[PRE137]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Note that when we extended our calculator with the modulo function, we did not
    change the `calculator` function at all. In this exercise, we saw how we can use
    the tuples, arrays, and function types to effectively design an extensible system.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们通过模运算功能扩展计算器时，我们根本就没有改变`calculator`函数。在这个练习中，我们看到了如何使用元组、数组和函数类型来有效地设计一个可扩展的系统。
- en: 'Activity 1.01: Creating a Library for Working with Strings'
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动一.01：创建用于处理字符串的库
- en: 'Your task is to create a series of simple functions that will help you do some
    common operations on strings. Some of the operations are already supported in
    the standard JavaScript library, but you will use them as a convenient learning
    exercise, both of JavaScript internals and TypeScript as a language. Our library
    will have the following functions:'
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 你的任务是创建一系列简单的函数，这些函数将帮助你执行一些常见的字符串操作。其中一些操作已经在标准JavaScript库中得到支持，但你将使用它们作为一个方便的学习练习，既包括JavaScript内部机制，也包括TypeScript作为一门语言。我们的库将包含以下函数：
- en: '`toTitleCase`: This will process a string and will capitalize the first letter
    of each word but will make all the other letters lowercase.'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toTitleCase`：这将处理一个字符串，并将每个单词的首字母大写，但将其他所有字母转换为小写。'
- en: 'Test cases for this function are as follows:'
  id: totrans-538
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数的测试用例如下：
- en: '[PRE138]'
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE138]'
- en: '`countWords`: This will count the number of separate words within a string.
    Words are delimited by spaces, dashes (`-`), or underscores (`_`).'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`countWords`：这将计算字符串中不同单词的数量。单词由空格、连字符（`-`）或下划线（`_`）分隔。'
- en: 'Test cases for this function are as follows:'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数的测试用例如下：
- en: '[PRE139]'
  id: totrans-542
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: '`toWords`: This will return all the words that are within a string. Words are
    delimited by spaces, dashes (`-`), or underscores (`_`).'
  id: totrans-543
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toWords`: 此函数将返回字符串中所有的单词。单词由空格、破折号（`-`）或下划线（`_`）分隔。'
- en: 'Test cases for this function are as follows:'
  id: totrans-544
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数的测试用例如下：
- en: '[PRE140]'
  id: totrans-545
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: '`repeat`: This will take a string and a number and return that same string
    repeated that number of times.'
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`repeat`: 此函数将接受一个字符串和一个数字，并返回重复该次数的相同字符串。'
- en: 'Test cases for this function are as follows:'
  id: totrans-547
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数的测试用例如下：
- en: '[PRE141]'
  id: totrans-548
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE141]'
- en: '`isAlpha`: This will return `true` if the string only has alpha characters
    (that is, letters). Test cases for this function are as follows:'
  id: totrans-549
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isAlpha`: 如果字符串仅包含字母字符（即，字母），此函数将返回`true`。此函数的测试用例如下：'
- en: '[PRE142]'
  id: totrans-550
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE142]'
- en: '`isBlank`: This will return `true` if the string is blank, that is, consists
    only of whitespace characters.'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isBlank`: 如果字符串为空，即仅由空白字符组成，此函数将返回`true`。'
- en: 'Test cases for this function are as follows:'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此函数的测试用例如下：
- en: '[PRE143]'
  id: totrans-553
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE143]'
- en: When writing the functions, make sure to think of the types of the parameters
    and the types of the return values.
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在编写函数时，请确保考虑参数的类型和返回值的类型。
- en: Note
  id: totrans-555
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: 'The code files for this activity can be found here: [https://packt.link/TOZuy](https://packt.link/TOZuy).'
  id: totrans-556
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此活动的代码文件可以在以下位置找到：[https://packt.link/TOZuy](https://packt.link/TOZuy)。
- en: 'Here are some steps to help you create the preceding functions (note that there
    are multiple ways to implement each of the functions, so treat these steps as suggestions):'
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些帮助你创建前面函数的步骤（请注意，实现每个函数的方法有多种，因此将这些步骤视为建议）：
- en: 'Creating the `toTitleCase` function: In order to change each word, we''ll need
    first to get all the words. You can use the `split` function to make a single
    string into an array of words. Next, we''ll need to `slice` off the first letter
    from the rest of the word. We can use the `toLowerCase` and `toUpperCase` methods
    to make something lower- and uppercase, respectively. After we get all the words
    properly cased, we can use the `join` array method to make an array of strings
    into a single large string.'
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`toTitleCase`函数：为了更改每个单词，我们首先需要获取所有单词。你可以使用`split`函数将单个字符串转换成单词数组。接下来，我们需要从单词的其余部分`slice`掉第一个字母。我们可以使用`toLowerCase`和`toUpperCase`方法来分别创建小写和大写。在得到所有单词正确的大小写后，我们可以使用`join`数组方法将字符串数组转换成单个长字符串。
- en: 'Creating the `countWords` function: In order to get the words, we can split
    the original string on any occurrence of any of the three delimiters ( `" "`,
    `"_"`, and `"-"`). Fortunately, the `split` function can take a regular expression
    as a parameter, which we can use to our benefit. Once we have the words in an
    array, we just need to count the elements.'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`countWords`函数：为了获取单词，我们可以将原始字符串根据任意一个分隔符（`" "`, `"_"`, 和 `"-"`）的出现进行分割。幸运的是，`split`函数可以接受一个正则表达式作为参数，我们可以利用这一点。一旦我们有了单词数组，我们只需计算元素的数量。
- en: 'Creating the `towards` function: This method can use the same approach as the
    preceding one. Instead of counting the words, we''ll just need to return them.
    Take note of the return type of this method.'
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`towards`函数：此方法可以使用与前面相同的方法。我们不需要计数单词，只需返回它们即可。请注意此方法的返回类型。
- en: 'Creating the `repeat` function: Create an array with the required length (using
    the `Array` constructor), and set each element to the input value (using the array''s
    `fill` method). After that, you can use the `join` method of the array to join
    the values into a single long string.'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`repeat`函数：创建一个具有所需长度的数组（使用`Array`构造函数），并使用数组的`fill`方法将每个元素设置为输入值。之后，你可以使用数组的`join`方法将值连接成一个长字符串。
- en: 'Creating the `isAlpha` function: We can design a regular expression that will
    test this, but we can also split the string into single characters, using the
    string `split` method. Once we have the character array, we can use the map function
    to transform all the characters to lowercase. We can then use the filter method
    to return only those characters that are not between "a" and "z". If we don''t
    have such characters, then the input only has letters, so we should return true.
    Otherwise, we should return false.'
  id: totrans-562
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`isAlpha`函数：我们可以设计一个正则表达式来测试这一点，但我们也可以使用字符串的`split`方法将字符串拆分成单个字符。一旦我们有了字符数组，我们可以使用map函数将所有字符转换为小写。然后我们可以使用filter方法返回不在"a"和"z"之间的字符。如果没有这样的字符，则输入仅包含字母，因此我们应该返回true。否则，我们应该返回false。
- en: 'Creating the `isBlank` function: One way to create such a function is to repeatedly
    test whether the first character is empty, and if it is, to remove it (a `while`
    loop works best for this). That loop will break either on the first non-blank
    characters or when it runs out of the first elements, that is, when the input
    is empty. In the first case, the string is not blank, so we should return `false`;
    otherwise, we should return `true`.'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建`isBlank`函数：创建此类函数的一种方法是通过反复测试第一个字符是否为空，如果是，则移除它（`while`循环最适合这种情况）。这个循环会在遇到第一个非空字符或当它耗尽第一个元素时（即输入为空时）中断。在前一种情况下，字符串不是空的，因此我们应该返回`false`；否则，我们应该返回`true`。
- en: Note
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor375)`.`
  id: totrans-565
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 该活动的解决方案可以通过[此链接](B14508_Solution_ePub.xhtml#_idTextAnchor375)找到。
- en: Summary
  id: totrans-566
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we looked at the world before TypeScript and described the
    problems and issues that TypeScript was actually designed to solve. We had a brief
    overview of how TypeScript operates under the hood, got ourselves introduced to
    the `tsc` compiler, and learned how we can control it using the `tsconfig.json`
    file.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了TypeScript出现之前的世界，并描述了TypeScript实际上旨在解决的问题和问题。我们简要概述了TypeScript在底层是如何运行的，了解了`tsc`编译器，并学习了如何使用`tsconfig.json`文件来控制它。
- en: We familiarized ourselves with the differences between TypeScript and JavaScript
    and saw how TypeScript infers the types from the values that we provide. We learned
    how different primitive types are treated in TypeScript, and finally, we learned
    how to create our own types to structure the building blocks of a large-scale,
    enterprise-level web application. Equipped with the fundamentals, you are now
    in a position to delve further into TypeScript, with the next chapter teaching
    you about declaration files.
  id: totrans-568
  prefs: []
  type: TYPE_NORMAL
  zh: 我们熟悉了TypeScript和JavaScript之间的差异，并了解了TypeScript是如何从我们提供的值中推断类型的。我们学习了TypeScript中不同原始类型是如何处理的，最后，我们学习了如何创建自己的类型来构建大型、企业级Web应用程序的基本构建块。掌握了基础知识后，你现在可以进一步深入研究TypeScript，下一章将教你关于声明文件的内容。
