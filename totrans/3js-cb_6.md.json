["```js\n  <script src=\"img/OrbitControls.js\"></script>\n  <script src=\"img/OBJLoader.js\"></script>\n```", "```js\n      var loader = new THREE.OBJLoader();\n      loader.load(\n        \"../assets/models/cow/cow.obj\",\n        function(cow) {\n          // get the main cow geometry from the \n          // loaded object hierarchy\n          var cowGeometry = cow.children[1].geometry;\n        }\n      );\n    ```", "```js\n      var pcMat = new THREE.PointCloudMaterial();\n      pcMat.map = THREE.ImageUtils.loadTexture(\"../assets/textures/ps_smoke.png\");\n      pcMat.color = new THREE.Color(0x5555ff);\n      pcMat.transparent = true;\n      pcMat.size = 0.2;\n      pcMat.blending = THREE.AdditiveBlending;\n    ```", "```js\n      pc = new THREE.PointCloud(geometry, pcMat);\n      pc.sizeAttenuation = true;\n      pc.sortPoints = true;\n    ```", "```js\n      scene.add(pc);\n    ```", "```js\n      var x = 100;\n      var y = 100;\n      var geometry = new THREE.Geometry();\n      for (var i = 0 ; i < x ; i++) {\n        for (var j = 0 ; j < y ; j++) {\n          var v = new THREE.Vector3();\n          v.x = i / 10;\n          v.y = Math.sin(i/100 * Math.PI*2) + Math.cos(j/100 * Math.PI) * 2;\n          v.z = j / 10;\n          geometry.vertices.push(v);\n        }\n      }\n    ```", "```js\n      var pcMat = new THREE.PointCloudMaterial(geometry);\n      pcMat.map = THREE.ImageUtils.loadTexture (\"../assets/textures/ps_smoke.png\");\n      pcMat.color = new THREE.Color(0x55ff55);\n      pcMat.transparent = true;\n      pcMat.size = 0.2;\n      pcMat.blending = THREE.AdditiveBlending;\n    ```", "```js\n      pc = new THREE.PointCloud(geometry, pcMat);\n      pc.sizeAttenuation = true;\n      pc.sortPoints = true;\n      scene.add(pc);\n    ```", "```js\n      var x = 100;\n      var y = 100;\n      var geometry = new THREE.Geometry();\n      for (var i = 0 ; i < x ; i++) {\n        for (var j = 0 ; j < y ; j++) {\n          var v = new THREE.Vector3(i,0,j);\n     var rnd = Math.random()/2 + 0.5;\n     geometry.colors.push(\n     new THREE.Color(rnd, rnd/4, 0));\n          geometry.vertices.push(v);\n        }\n      }\n    ```", "```js\n      var pcMat = new THREE.PointCloudMaterial(geometry);\n      pcMat.vertexColors = true;\n      pcMat.map = THREE.ImageUtils.loadTexture(\"../assets/textures/ps_smoke.png\");\n      pcMat.transparent = true;\n      pc = new THREE.PointCloud(geometry, pcMat);\n      scene.add(pc);\n    ```", "```js\n      for (var i = 0 ; i < pc.geometry.colors.length ; i++) {\n        var rnd = Math.random()/2 + 0.5;\n        pc.geometry.colors[i] = new THREE.Color(rnd, rnd/4, 0);\n      }\n      pc.geometry.colorsNeedUpdate = true;\n    ```", "```js\n  gl_FragColor = vec4( psColor, opacity );\n```", "```js\n      var geometry = new THREE.Geometry();\n     var pSize = [];\n     var pOpacity = [];\n     var width= 100;\n     var height = 100;\n      // create the geometry and set custom values\n      for (var i = 0 ; i < width ; i++) {\n        for (var j = 0 ; height < y ; j++) {\n          var v = new THREE.Vector3();\n          v.x = i / 10;\n          v.y = (Math.sin(i/200 * Math.PI*2) + Math.cos(j/50 * Math.PI) + Math.sin((j+i)/40 * Math.PI))/2;\n          v.z = j / 10;\n          // add the vertex\n          geometry.vertices.push(v);\n          // add vertex specific color, size and opacity\n     geometry.colors.push(new THREE.Color(v.y,0.5,0.7));\n     pSize.push(Math.random());\n     pOpacity.push(Math.random()/4+0.5);\n        }\n      }\n    ```", "```js\n      var attributes = ...; // filled in in next steps\n      var uniforms = ...;   // filled in in next steps\n      var psMat2 = new THREE.ShaderMaterial({\n        attributes: attributes,\n        uniforms: uniforms,\n        transparent : true,\n        blending : THREE.AdditiveBlending,\n        vertexShader: document getElementById('pointVertexShader').text,\n        fragmentShader: document getElementById('pointFragmentShader').text\n      });\n    ```", "```js\n      var attributes = {\n        pSize:    { type: 'f', value: pSize },\n        pOpacity: { type: 'f', value: pOpacity }\n      };\n    ```", "```js\n      var basicShader = THREE.ShaderLib['point_basic'];\n      var uniforms = THREE.UniformsUtils.merge([basicShader.uniforms]);\n      uniforms['map'].value = THREE.ImageUtils.loadTexture(\"../assets/textures/ps_smoke.png\");\n      uniforms['size'].value = 100;\n      uniforms['opacity'].value = 0.5;\n      uniforms['psColor'].value = new THREE.Color(0xffffff);\n    ```", "```js\n      <script id=\"pointVertexShader\" type=\"x-shader/x-vertex\">\n        precision highp float;\n        precision highp int;\n        attribute vec3 color;\n        attribute float pSize;\n        attribute float pOpacity;\n        uniform float size;\n        uniform float scale;\n        varying vec3 vColor;\n        varying float vOpacity;\n        void main() {\n          vColor = color;\n          vOpacity = pOpacity;\n          vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n          gl_PointSize = 2.0 * pSize * size * ( scale / length( mvPosition.xyz ) );\n          gl_Position = projectionMatrix * mvPosition;\n        }\n      </script>\n    ```", "```js\n      <script id=\"pointFragmentShader\" type=\"x-shader/x-fragment\">\n        precision highp float;\n        precision highp int;\n        uniform vec3 psColor;\n        uniform float opacity;\n        varying vec3 vColor;\n        varying float vOpacity;\n        uniform sampler2D map;\n        void main() {\n          gl_FragColor = vec4( psColor, vOpacity );\n          gl_FragColor = gl_FragColor * texture2D( map,vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) );\n          gl_FragColor = gl_FragColor * vec4( vColor, 1.0 );\n        }\n      </script>\n    ```", "```js\n      ps = new THREE.PointCloud(geometry, psMat2);\n      ps.sortPoints = true;\n      scene.add(ps);\n    ```", "```js\n      var step = 0;\n      function render() {\n        renderer.render(scene, camera);\n        requestAnimationFrame(render);\n        step=0.005;\n        var count = 0;\n        var geometry = ps.geometry;\n        geometry.vertices.forEach(function(v){\n          // calculate new value for the y value\n          v.y =  ( Math.sin((v.x/20+step) * Math.PI*2) + Math.cos((v.z/5+step*2) * Math.PI) + Math.sin((v.x + v.y + step*2)/4 * Math.PI))/2;\n          // and calculate new colors\n          geometry.colors[count++]= new THREE.Color(v.y,0.5,0.7);\n        });\n        geometry.verticesNeedUpdate = true;\n        geometry.colorsNeedUpdate = true;\n      }\n    ```", "```js\n      cube = new THREE.CubeGeometry(4,6,4,20,20,20);\n      cube.vertices.forEach(function(v) {\n        v.velocity = Math.random();\n      });\n      createPointSystemFromGeometry(cube);\n    ```", "```js\n      var psMat = new THREE.PointCloudMaterial();\n      psMat.map = THREE.ImageUtils.loadTexture(\"../assets/textures/ps_ball.png\");\n      psMat.blending = THREE.AdditiveBlending;\n      psMat.transparent = true;\n      psMat.opacity = 0.6;\n      var ps = new THREE.PointCloud(cube, psMat);\n      ps.sortPoints = true;\n      scene.add(ps);\n    ```", "```js\n      var avgVertexNormals = [];\n      var avgVertexCount = [];\n      for (var i = 0 ; i < cube.vertices.length ; i++) {\n        avgVertexNormals.push(new THREE.Vector3(0,0,0));\n        avgVertexCount.push(0);\n      }\n      // first add all the normals\n      cube.faces.forEach(function (f) {\n        var vA = f.vertexNormals[0];\n        var vB = f.vertexNormals[1];\n        var vC = f.vertexNormals[2];\n        // update the count\n        avgVertexCount[f.a]+=1;\n        avgVertexCount[f.b]+=1;\n        avgVertexCount[f.c]+=1;\n        // add the vector\n        avgVertexNormals[f.a].add(vA);\n        avgVertexNormals[f.b].add(vB);\n        avgVertexNormals[f.c].add(vC);\n      });\n      // then calculate the average\n      for (var i = 0 ; i < avgVertexNormals.length ; i++) {\n        avgVertexNormals[i].divideScalar(avgVertexCount[i]);\n      }\n    ```", "```js\n      function explode(outwards) {\n        var dir = outwards === true ? 1 : -1;\n        var count = 0;\n        cube.vertices.forEach(function(v){\n          v.x+=(avgVertexNormals[count].x * v.velocity * control.scale)*dir;\n          v.y+=(avgVertexNormals[count].y * v.velocity * control.scale)*dir;\n          v.z+=(avgVertexNormals[count].z * v.velocity * control.scale)*dir;\n          count++;\n        });\n        cube.verticesNeedUpdate = true;\n      }\n    ```", "```js\n      function render() {\n        renderer.render(scene, camera);\n        explode(true); // or explode(false)\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n  <script src=\"img/CopyShader.js\"></script>\n  <script src=\"img/EffectComposer.js\"></script>\n  <script src=\"img/RenderPass.js\"></script>\n  <script src=\"img/ShaderPass.js\"></script>\n  <script src=\"img/MaskPass.js\"></script>\n```", "```js\n  <script src=\"img/DotScreenShader.js\"></script>\n```", "```js\n      var composer;\n    ```", "```js\n      composer = new THREE.EffectComposer( renderer );\n    ```", "```js\n      var renderPass = new THREE.RenderPass( scene, camera );\n      composer.addPass( renderPass  );\n    ```", "```js\n      var effect = new THREE.ShaderPass( THREE.DotScreenShader);\n      effect.uniforms[ 'scale' ].value = 4;\n      effect.renderToScreen = true;\n      composer.addPass( effect );\n    ```", "```js\n      function render() {\n        composer.render();\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n  <script src=\"img/CopyShader.js\"></script>\n  <script src=\"img/EffectComposer.js\"></script>\n  <script src=\"img/RenderPass.js\"></script>\n  <script src=\"img/ShaderPass.js\"></script>\n  <script src=\"img/MaskPass.js\"></script>\n```", "```js\n      var composer = new THREE.EffectComposer( renderer );\n      var renderPass = new THREE.RenderPass( scene, camera );\n      composer.addPass( renderPass  );\n    ```", "```js\n      var customShader = {\n        uniforms: {\n          \"tDiffuse\": { type: \"t\", value: null},\n          \"scale\":    { type: \"f\", value: 1.0 },\n          \"texSize\":  { type: \"v2\", value: new THREE.Vector2( 50, 50 ) },\n          \"center\":   { type: \"v2\", value: new THREE.Vector2( 0.5, 0.5 ) },\n        },\n        vertexShader: document.getElementById('hexagonVertexShader').text,\n        fragmentShader: document.getElementById('hexagonFragmentShader').text\n      };\n      var effect = new THREE.ShaderPass( customShader );\n      effect.renderToScreen = true;\n      composer.addPass( effect );\n    ```", "```js\n      <script id=\"hexagonVertexShader\" type=\"x-shader/x-vertex\">\n        varying vec2 texCoord;\n        void main() {\n          texCoord = uv;\n          gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n        }\n      </script>\n    ```", "```js\n      <script id=\"hexagonFragmentShader\" type=\"x-shader/x-fragment\">\n        uniform sampler2D tDiffuse;\n        uniform vec2 center;\n        uniform float scale;\n        uniform vec2 texSize;\n        varying vec2 texCoord;\n        void main() {\n          vec2 tex = (texCoord * texSize - center) / scale;\n          tex.y /= 0.866025404;\n          tex.x -= tex.y * 0.5;\n          vec2 a;\n          if (tex.x + tex.y - floor(tex.x) - floor(tex.y) < 1.0)\n          a = vec2(floor(tex.x), floor(tex.y));\n          else a = vec2(ceil(tex.x), ceil(tex.y));\n          vec2 b = vec2(ceil(tex.x), floor(tex.y));\n          vec2 c = vec2(floor(tex.x), ceil(tex.y));\n          vec3 TEX = vec3(tex.x, tex.y, 1.0 - tex.x - tex.y);\n          vec3 A = vec3(a.x, a.y, 1.0 - a.x - a.y);\n          vec3 B = vec3(b.x, b.y, 1.0 - b.x - b.y);\n          vec3 C = vec3(c.x, c.y, 1.0 - c.x - c.y);\n          float alen = length(TEX - A);\n          float blen = length(TEX - B);\n          float clen = length(TEX - C);\n          vec2 choice;\n          if (alen < blen) {\n            if (alen < clen) choice = a;\n            else choice = c;\n          } else {\n            if (blen < clen) choice = b;\n            else choice = c;\n          }\n          choice.x += choice.y * 0.5;\n          choice.y *= 0.866025404;\n          choice *= scale / texSize;\n          gl_FragColor = texture2D(tDiffuse, choice \n            + center / texSize);\n        }\n      </script>\n    ```", "```js\n      function render() {\n        composer.render();\n        requestAnimationFrame(render);\n      }\n    ```", "```js\n      window.addEventListener(\"keyup\", copyCanvas);\n    ```", "```js\n      function copyCanvas(e) {\n        var imgData, imgNode;\n        if (e.which !== 80) {\n          return;\n        } else {\n          imgData = renderer.domElement.toDataURL();\n        }\n        // create a new image and add to the document\n        imgNode = document.createElement(\"img\");\n        imgNode.src = imgData;\n        document.body.appendChild(imgNode);\n      }\n    ```", "```js\n      renderer = new THREE.WebGLRenderer({preserveDrawingBuffer: true});\n    ```", "```js\n  var link = document.createElement(\"a\");\n  link.download = 'capture.png';\n  link.href = imgData;\n  link.click();\n```"]