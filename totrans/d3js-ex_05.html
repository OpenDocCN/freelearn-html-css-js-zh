<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Using Data and Scales"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Using Data and Scales</h1></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Creating a Bar Graph">Chapter 4</a>, <span class="emphasis"><em>Creating a Bar Graph</em></span>, you learned how to create a bar graph that was based upon a sequence of integers that were statically coded within the application. Although the resulting graph looks quite nice, there are several issues with the way the data is provided and rendered.</p><p>One of the issues is that the data is hard-coded within the application. Almost invariably, we are going to load the data from an external source. D3.js provides a rich set of functionalities for loading data from sources over the web, and which is represented in different formats. In this chapter, you will learn to use D3.js for loading data from the web in JSON, CSV, and TSV formats.</p><p>A second issue with the data in the example given in the previous chapter was that it was simply an array of integers. Data will often be represented as collections of objects with multiple properties, many of which we do not need for our visualization. They are also often represented as strings instead of numeric values. In this chapter, you will learn how to select just the data that you want and to convert it to the desired data type.</p><p>Yet another issue in our previous bar graph was that we assumed that the values represented in the data had a direct mapping to the pixels in the visualization. This is normally not the case, and we need to scale the data into the size of our rendering in the browser. This can be easily accomplished using scales, which we already examined relative to axes, and now we will apply them to data.</p><p>One last issue in the previous example was that our code for calculating the size and positions of the bars was performed manually. Bar graphs are common enough in D3.js applications, and there are built-in functions that can do this for us automatically. We will examine using these to simplify our code.</p><p>So let's jump in. In this chapter, we will specifically cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Loading data in JSON, TSV, or CSV formats from the Web</li><li class="listitem" style="list-style-type: disc">Extracting fields from objects using the <code class="literal">.map()</code> function</li><li class="listitem" style="list-style-type: disc">Converting string values into their representative numeric data types</li><li class="listitem" style="list-style-type: disc">Using linear scales for transforming continuous values</li><li class="listitem" style="list-style-type: disc">Using ordinal scales for mapping discrete data</li><li class="listitem" style="list-style-type: disc">Using bands for calculating the size and position of our bars</li><li class="listitem" style="list-style-type: disc">Applying what we've learned to date for creating a rich bar graph using real data</li></ul></div><div class="section" title="Data"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Data</h1></div></div></div><p>Data is the<a id="id223" class="indexterm"/> core of creating a data visualization. Almost every visual item created in D3 will need to be bound to a piece of data. This data can come from a number of sources. It can be explicitly coded in the visualization, loaded from an external source, or result from manipulation or calculation from other data.</p><p>Most data used to create a D3.js visualization is either obtained from a file or a web service <a id="id224" class="indexterm"/>or URL. This data is often in one of many<a id="id225" class="indexterm"/> formats such as JSON, XML, <span class="strong"><strong>CSV</strong></span> (<span class="strong"><strong>Comma Separated Values</strong></span>), and <span class="strong"><strong>TSV</strong></span> (<span class="strong"><strong>Tab Separated Values</strong></span>). We will need to convert the data in these formats into JavaScript objects, and D3.js provides us with convenient functions for doing this.</p><div class="section" title="Loading data with D3.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec33"/>Loading data with D3.js</h2></div></div></div><p>D3.js provides<a id="id226" class="indexterm"/> a number of helper functions to load data from outside<a id="id227" class="indexterm"/> the browser as well as to simultaneously convert it into JavaScript objects. Probably, the most common data formats that you may come across and which we will cover are:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">JSON</li><li class="listitem" style="list-style-type: disc">TSV</li><li class="listitem" style="list-style-type: disc">CSV</li></ul></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note69"/>Note</h3><p>You may have noticed that I have omitted XML from the list in our examples. D3.js does have functions to load XML, but unlike with JSON, TSV and CSV, the results of the load are not converted automatically into JavaScript objects, and require additional manipulation using the JavaScript XML/DOM facilities. XML will be considered out of scope for this text as most of the scenarios you will currently come across will be handled with these three formats, if not  solely by JSON, which has become almost the ubiquitous data format for the Web.</p></div></div><p>To demonstrate working with all these formats of data, we will examine a dataset that I have put together and placed in a GitHub that represents the viewership of the episodes of Season 5 <a id="id228" class="indexterm"/>of <a id="id229" class="indexterm"/>AMC's <span class="emphasis"><em>The Walking Dead</em></span>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note70"/>Note</h3><p>This GitHub was built manually using data on <a class="ulink" href="https://en.wikipedia.org/wiki/The_Walking_Dead_(season_5)">https://en.wikipedia.org/wiki/The_Walking_Dead_(season_5)</a>.</p></div></div><div class="section" title="Loading JSON data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec06"/>Loading JSON data</h3></div></div></div><p>Data in the <span class="strong"><strong>JavaScript Object Notation</strong></span> (<span class="strong"><strong>JSON</strong></span>) format is convenient for conversion into <a id="id230" class="indexterm"/>JavaScript objects. It is a very flexible format which supports named properties as well as hierarchical data.</p><p>The JSON data<a id="id231" class="indexterm"/> for<a id="id232" class="indexterm"/> this example is<a id="id233" class="indexterm"/> stored in GitHub and is available at <a class="ulink" href="https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.json">https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.json</a>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note71"/>Note</h3><p>The URL is a little unwieldy. You can go directly to the gist with all three versions of this data at <a class="ulink" href="https://goo.gl/OfD1hc">https://goo.gl/OfD1hc</a>.</p></div></div><p>Clicking on the link will display the data in the browser. This file contains an array of JavaScript objects, each of which has six properties and represents an individual episode of the program. The first two objects are the following:</p><div class="informalexample"><pre class="programlisting">[
{
  "Season": 5,
  "Episode":  1,
  "SeriesNumber": 52,
  "Title": "No Sanctuary",
  "FirstAirDate": "10-12-2014",
  "USViewers": 17290000
},
{
  "Season": 5,
  "Episode":  2,
  "SeriesNumber": 53,
  "Title": "Strangers",
  "FirstAirDate": "10-19-2014",
  "USViewers": 15140000
},
…
]</pre></div><p>This data can be loaded into our D3.js application using the <code class="literal">d3.json()</code> function. This function, like many others in D3.js, performs asynchronously. It takes two parameters: the URL of the<a id="id234" class="indexterm"/> data to load, and a callback function that is called when <a id="id235" class="indexterm"/>the data has been loaded.</p><p>The following example demonstrates loading this data and displaying the first item in the array.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note72"/>Note</h3><p>bl.ock (5.1): <a class="ulink" href="http://goo.gl/Qe63wH">http://goo.gl/Qe63wH</a>
</p></div></div><p>The main portion of the code that loads the data is as follows:</p><div class="informalexample"><pre class="programlisting">var url = "https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.json";
d3.json(url, function (error, data) {
    console.log(data[0]);
});
console.log("Data in D3.js is loaded asynchronously");</pre></div><p>There is no visible output from this example, but the output is written to the JavaScript console:</p><div class="informalexample"><pre class="programlisting">"Data in D3.js is loaded asynchronously"
[object Object] {
  Episode: 1,
  FirstAirDate: "10-12-2014",
  Season: 5,
  SeriesNumber: 52,
  Title: "No Sanctuary",
  USViewers: 17290000
}</pre></div><p>Note that the loading of data in D3.js is performed asynchronously. The output from the <code class="literal">console.log()</code> call shows that the data is loaded asynchronously and is executed first. Later, when the data is loaded, we see the output from the second call to <code class="literal">console.log()</code>.</p><p>The callback function itself has two parameters. The first is a reference to an object representing an error if one occurs. In such a case, this variable will be non-null and contain details. Non-null means the data was loaded, and is represented by the data variable.</p></div><div class="section" title="Loading TSV data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec07"/>Loading TSV data</h3></div></div></div><p>TSV is a type<a id="id236" class="indexterm"/> of data that you will come across if you do enough D3.js<a id="id237" class="indexterm"/> programming. In a TSV file, the values are separated by tab characters. Generally, the first line of the file is a tab-separated sequence of names for each of the values.</p><p>TSV files have the benefit of being less verbose than JSON files, and are often generated automatically by many systems that are not JavaScript based.</p><p>The episode<a id="id238" class="indexterm"/> data in the TSV format is available at <a class="ulink" href="https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.tsv">https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.tsv</a>.</p><p>Clicking on the link, you will see the following in your browser:</p><div class="informalexample"><pre class="programlisting">Season Episode SeriesNumber Title FirstAirDate USViewers
5 1 52 No Sanctuary 10-12-2014 17290000
5 2 53 Strangers 10-19-2014 15140000 
5 3 54 Four Walls and a Roof 10-26-2014 13800000
5 4 55 Slabtown 11-02-2014 14520000
5 5 56 Self Help 11-09-2014 13530000
5 6 57 Consumed 11-16-2014 14070000
5 7 58 Crossed 11-23-2014 13330000
5 8 59 Coda 11-30-2014 14810000
5 9 60 What Happened and What's Going On 02-08-2015 15640000
5 10 61 Them 02-15-2015 12270000
5 11 62 The Distance 02-22-2015 13440000
5 12 63 Remember 03-01-2015 14430000
5 13 64 Forget 03-08-2015 14530000
5 14 65 Spend 03-15-2015 13780000
5 15 66 Try 03-22-2015 13760000
5 16 67 Conquer 03-29-2015 15780000</pre></div><p>We can load the data from this file using <code class="literal">d3.tsv()</code>. The following contains the code for the example:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note73"/>Note</h3><p>bl.ock (5.2): <a class="ulink" href="http://goo.gl/nlq8jy">http://goo.gl/nlq8jy</a>
</p></div></div><p>The code is identical to the JSON example except for the URL and the call to <code class="literal">d3.json()</code>. The output in the console is, however, different.</p><div class="informalexample"><pre class="programlisting">[object Object] {
  Episode: "1",
  FirstAirDate: "10-12-2014",
  Season: "5",
  SeriesNumber: "52",
  Title: "No Sanctuary",
  USViewers: "17290000"
}</pre></div><p>Notice that the properties <span class="strong"><strong>Episode</strong></span>, <span class="strong"><strong>Season</strong></span>, <span class="strong"><strong>SeriesNumber</strong></span>, and <span class="strong"><strong>USViewers</strong></span> are now of type string<a id="id239" class="indexterm"/> instead of integer. TSV files do not have a means of implying<a id="id240" class="indexterm"/> the type like JSON does, so everything defaults to string. These will often need to be converted to another type, and we will examine that in the next section on mapping and data conversion.</p></div><div class="section" title="Loading CSV data"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec08"/>Loading CSV data</h3></div></div></div><p>CSV is a <a id="id241" class="indexterm"/>format similar to TSV except that instead of tab characters <a id="id242" class="indexterm"/>delimiting the fields, a comma is used. CSV is a fairly common format, common as output from spreadsheet applications, which is used for creating data to be consumed by other applications in many organizations.</p><p>The CSV version <a id="id243" class="indexterm"/>of the data is available at <a class="ulink" href="https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.csv">https://gist.githubusercontent.com/d3byex/e5ce6526ba2208014379/raw/8fefb14cc18f0440dc00248f23cbf6aec80dcc13/walking_dead_s5.csv</a>.</p><p>Opening the link, you will see the following in your browser:</p><div class="informalexample"><pre class="programlisting">Season,Episode,SeriesNumber,Title,FirstAirDate,USViewers
5,1,52,No Sanctuary,10-12-2014,17290000
5,2,53,Strangers,10-19-2014,15140000 
5,3,54,Four Walls and a Roof,10-26-2014,13800000
5,4,55,Slabtown,11-02-2014,14520000
5,5,56,Self Help,11-09-2014,13530000
5,6,57,Consumed,11-16-2014,14070000
5,7,58,Crossed,11-23-2014,13330000
5,8,59,Coda,11-30-2014,14810000
5,9,60,What Happened and What's Going On,02-08-2015,15640000
5,10,61,Them,02-15-2015,12270000
5,11,62,The Distance,02-22-2015,13440000
5,12,63,Remember,03-01-2015,14430000
5,13,64,Forget,03-08-2015,14530000
5,14,65,Spend,03-15-2015,13780000
5,15,66,Try,03-22-2015,13760000
5,16,67,Conquer,03-29-2015,15780000</pre></div><p>The example for demonstrating the loading of the preceding data using <code class="literal">d3.csv()</code> is available at the following link:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note74"/>Note</h3><p>bl.ock (5.3): <a class="ulink" href="http://goo.gl/JUX9CA">http://goo.gl/JUX9CA</a>
</p></div></div><p>The result<a id="id244" class="indexterm"/> is identical to that of the TSV example in that all the fields <a id="id245" class="indexterm"/>are loaded as strings.</p></div></div><div class="section" title="Mapping fields and converting strings to numbers"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec34"/>Mapping fields and converting strings to numbers</h2></div></div></div><p>We are going to use this data (in its CSV source) to render a bar graph that shows us the comparison <a id="id246" class="indexterm"/>of the viewership levels for each episode. If we <a id="id247" class="indexterm"/>are to use these fields as-is for creating the<a id="id248" class="indexterm"/> bar graph, those values will be interpreted incorrectly as their types are strings instead of numbers, and our resulting graph will be incorrect.</p><p>Additionally, for the purpose of creating a bar chart showing viewership, we don't need the properties and can omit the <code class="literal">Season</code>, <code class="literal">SeriesNumber</code>, and <code class="literal">FirstAirDate</code> fields. It's not a real issue with this dataset, but sometimes, the data can have hundreds of columns and billions of rows, so it will be more efficient to extract only the necessary properties to help save memory.</p><p>These can be accomplished in a naive manner using a <code class="literal">for</code> loop, copying the desired fields into a new JavaScript object, and using one of the parse functions to convert the data. D3.js gives us a better way, a functional way, to perform this task.</p><p>D3.js provides us with the a .<code class="literal">map()</code> function that can be used on an array, which will apply a function to each of the array's items. This function returns a JavaScript object, and D3.js collects all these objects and returns them in an array. This gives us a simple way of selecting just the properties that we want and to convert the data, all in a single statement.</p><p>To demonstrate this in action, open the example given at the following link:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note75"/>Note</h3><p>bl.ock (5.4): <a class="ulink" href="http://goo.gl/ex2e8C">http://goo.gl/ex2e8C</a>
</p></div></div><p>The important portion of the code is the call to <code class="literal">data.map()</code>:</p><div class="informalexample"><pre class="programlisting">var mappedAndConverted = data.map(function(d) {
    return {
        Episode: +d.Episode,
        USViewers: +d.USViewers,
        Title: d.Title
    };
});
console.log(mappedAndConverted);</pre></div><p>The function that is passed to the <code class="literal">.map()</code> returns a new JavaScript object for each item in the array data. This new object consists of only the three specified properties. These objects are all collected by <code class="literal">.map()</code> and stored in the <code class="literal">mappedAndConverted</code> variable.</p><p>The following code shows the first two objects in the new array:</p><div class="informalexample"><pre class="programlisting">[[object Object] {
  Episode: 1,
  Title: "No Sanctuary",
  USViewers: 17290000
}, [object Object] {
  Episode: 2,
  Title: "Strangers",
  USViewers: 15140000
},</pre></div><p>Note<a id="id249" class="indexterm"/> that <code class="literal">Episode</code> and <code class="literal">USViewers</code> are now numeric <a id="id250" class="indexterm"/>values. This is accomplished by applying the unary <code class="literal">+</code> operator, which <a id="id251" class="indexterm"/>will convert a string to its appropriate numeric type.</p></div></div></div>
<div class="section" title="Scales"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec30"/>Scales</h1></div></div></div><p>Scales are<a id="id252" class="indexterm"/> functions provided by D3.js that map a set of values to another set of values. The input set of values is referred to as the domain, and the output is the range. The basic reason for the existence of scales is to prevent us from coding loops, and doing a lot of math to make these conversions happen. This is a very useful thing.</p><p>There are three general categories of scales: quantitative, ordinal, and time-scale. Within each category of scale, D3.js provides a number of concrete implementations that exist for accomplishing a specific type of mapping data useful for data visualization.</p><p>Covering examples of every type of scale would consume more space than is available in this book, and at the same time become tedious to read. We will examine several common scales that are used—kind of the 80/20 rule, where the few we cover here will be used most of the time you use scales.</p><div class="section" title="Linear scales"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec35"/>Linear scales</h2></div></div></div><p>Linear scales are a type of quantitative scale that are arguably the most commonly used ones. The <a id="id253" class="indexterm"/>mapping performed is linear in that the output range is calculated<a id="id254" class="indexterm"/> using a linear function of the input domain.</p><p>A good example<a id="id255" class="indexterm"/> of using a linear scale is the scenario with our <span class="emphasis"><em>The Walking Dead</em></span> viewership data. We need to draw bars from this data; but if we use the code that we used earlier in the book, our bars will be extremely tall since that code has a one to one mapping between the value and the pixels.</p><p>Let's assume that our area for the bars on the graph has a height of 400 pixels. We would like to map the lowest viewership value to a bar that is 100 pixels tall, and map the largest viewership value to 400. The following example performs this task:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note76"/>Note</h3><p>bl.ock (5.5): <a class="ulink" href="http://goo.gl/dgg0zf">http://goo.gl/dgg0zf</a>
</p></div></div><p>The code <a id="id256" class="indexterm"/>starts, as with the CSV example, by loading that data and mapping/converting it. The next task is to determine the minimum and maximum <a id="id257" class="indexterm"/>viewership values:</p><div class="informalexample"><pre class="programlisting">var viewership = mappedAndConverted.map(function (d) { 
     return d.USViewers; 
});
var minViewership = d3.min(viewership);
var maxViewership = d3.max(viewership);</pre></div><p>Next, we define several variables representing the minimum and maximum height that we would like for the bars:</p><div class="informalexample"><pre class="programlisting">var minBarHeight = 100, maxBarHeight = 400;</pre></div><p>The scale is then created as follows:</p><div class="informalexample"><pre class="programlisting">var yScale = d3.scale
    .linear()
    .domain([minViewership, maxViewership])
    .range([minBarHeight, maxBarHeight]);</pre></div><p>We can now use the <code class="literal">yScale</code> object as though it is a function. The following will log the results of scaling the minimum and maximum viewership values:</p><div class="informalexample"><pre class="programlisting">console.log(minViewership + " -&gt; " + yScale(minViewership));
console.log(maxViewership + " -&gt; " + yScale(maxViewership));</pre></div><p>Examining the console output, we can see that the scaling resulted in the expected values:</p><div class="informalexample"><pre class="programlisting">"12270000 -&gt; 100"
"17290000 -&gt; 400"</pre></div></div><div class="section" title="Ordinal scales"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec36"/>Ordinal scales</h2></div></div></div><p>Ordinal scales<a id="id258" class="indexterm"/> are, in a way, similar to dictionary objects. The values in the <a id="id259" class="indexterm"/>domain and range are discrete. There must be an entry in the range for every unique input value, and that value must have a mapping to a single value in the range.</p><p>There are several common uses for ordinal scales, and we will examine four common uses that we will use throughout the remainder of this book.</p><div class="section" title="Mapping color strings to codes"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec09"/>Mapping color strings to codes</h3></div></div></div><p>Open the following link for an example of an ordinal scale. This example does not use the data from <span class="emphasis"><em>The Walking Dead</em></span>, and simply demonstrates the mapping of string literals representing <a id="id260" class="indexterm"/>primary colors into the corresponding color codes.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note77"/>Note</h3><p>bl.ock (5.6): <a class="ulink" href="http://goo.gl/DezcUN">http://goo.gl/DezcUN</a>
</p></div></div><p>The scale is created as follows:</p><div class="informalexample"><pre class="programlisting">var colorScale = d3.scale.ordinal()
    .domain(['red', 'green', 'blue'])
    .range(['#ff0000', '#00ff00', '#0000ff']);</pre></div><p>We can now pass any of the range values to the <code class="literal">colorScale</code>, as demonstrated with the following:</p><div class="informalexample"><pre class="programlisting">console.log(colorScale('red'),
    colorsScale('green'),
    colorScale('blue'));</pre></div><p>Examining the console output, we can see the results of this mapping as follows:</p><div class="informalexample"><pre class="programlisting">"#ff0000"
"#00ff00"
"#0000ff"</pre></div></div><div class="section" title="Mapping integers to color scales"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec10"/>Mapping integers to color scales</h3></div></div></div><p>D3.js comes <a id="id261" class="indexterm"/>with several special built-in scales that are referred to as <span class="strong"><strong>categorical</strong></span> scales. It sounds like a fancy term, but they are simply<a id="id262" class="indexterm"/> mappings of a set of integers to unique colors (unique within that scale).</p><p>These are useful when you have a set of sequential 0-based integer keys in your data, and you want to use a unique color for each, but you do not want to manually create all the mappings (like we did for the three strings in the previous example).</p><p>Open the following link for an example of using a 10 color categorical scale:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note78"/>Note</h3><p>bl.ock (5.7): <a class="ulink" href="http://goo.gl/RSW9Qa">http://goo.gl/RSW9Qa</a>
</p></div></div><p>The preceding example renders 10 adjacent rectangles, each with a unique color from a <code class="literal">category10()</code> color scale. You will see this in your browser when executing this example.</p><div class="mediaobject"><img src="graphics/B04230_05_02.jpg" alt="Mapping integers to color scales"/></div><p>The example starts by creating an array of 10 integers from 0 to 9.</p><div class="informalexample"><pre class="programlisting">var data = d3.range(0, 9);</pre></div><p>The <a id="id263" class="indexterm"/>scale is created next:</p><div class="informalexample"><pre class="programlisting">var colorScale = d3.scale.category10();</pre></div><p>Now we can bind the integers to the rectangles, and set the fill for each by passing the value to the <code class="literal">colorScale</code> function:</p><div class="informalexample"><pre class="programlisting">var svg = d3.select('body')
    .append('svg')
    .attr({width: 200, height: 20});

svg.selectAll('rect')
    .data(data)
    .enter()
    .append('rect')
    .attr({
        fill: function(d) { return colorScale(d); },
        x: function(d, i) { return i * 20 },
        width: 20,
        height: 20
    });</pre></div><p>D3.js provides four sets of categorical color scales that can be used depending upon your scenario. You can take <a id="id264" class="indexterm"/>a look at them on the D3.js documentation page at <a class="ulink" href="https://github.com/mbostock/d3/wiki/Ordinal-Scales">https://github.com/mbostock/d3/wiki/Ordinal-Scales</a>.</p></div><div class="section" title="The ordinal scale using rangeBands"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec11"/>The ordinal scale using rangeBands</h3></div></div></div><p>In <a class="link" href="ch04.html" title="Chapter 4. Creating a Bar Graph">Chapter 4</a>, <span class="emphasis"><em>Creating a Bar Graph</em></span>, when we drew the graph we calculated the positions of the bars based upon a fixed bar size and padding. This is actually a very inflexible means <a id="id265" class="indexterm"/>of accomplishing this task. D3.js gives us a special scale that we can use, given the domain values and essentially a width, that will tell us the start and end values for each bar such that all the bars fit perfectly within the range!</p><p>Let's take a look using this special scale with the following example:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note79"/>Note</h3><p>bl.ock (5.8): <a class="ulink" href="http://goo.gl/OG3g7S">http://goo.gl/OG3g7S</a>
</p></div></div><p>This example creates a simple ordinal scale specifying the range using the <code class="literal">.rangeBands()</code> function instead of <code class="literal">.range()</code>. The entire code of the example is as follows:</p><div class="informalexample"><pre class="programlisting">var bands = d3.scale.ordinal()
    .domain([0, 1, 2])
    .rangeBands([0, 100]);
console.log(bands.range()); 
console.log(bands.rangeBand());</pre></div><p>The <code class="literal">.range()</code> function will return an array with values representing the extents of an equal number<a id="id266" class="indexterm"/> of evenly-spaced divisions of the range specified to <code class="literal">.rangeBands()</code>. In this case, the width of the range is <code class="literal">100</code>, and there are three items specified in the domain; hence, the result is the following:</p><div class="informalexample"><pre class="programlisting">[0, 33.333333333333336, 66.66666666666667]</pre></div><p>Technically, this result is the values that represent the start of each band. The width of each band can be found using the <code class="literal">.rangeBand()</code> function, in this case returning the following:</p><div class="informalexample"><pre class="programlisting">33.333333333333336</pre></div><p>This width may seem simplistic. Why have this function if we can just calculate the difference between two adjacent values in the result of <code class="literal">.range()</code>? To demonstrate, let's look at a slight modification of this example, available at the following link.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note80"/>Note</h3><p>bl.ock (5.9): <a class="ulink" href="http://goo.gl/JPsuqh">http://goo.gl/JPsuqh</a></p></div></div><p>This makes one modification to the call to <code class="literal">.rangeBands()</code>, adding an additional parameter that specifies the padding that should exist between the bars:</p><div class="informalexample"><pre class="programlisting">var bands = d3.scale.ordinal()
    .domain([0, 1, 2])
    .rangeRoundBands([0, 100], 0.1);</pre></div><p>The output differs slightly due to the addition of padding between the bands:</p><div class="informalexample"><pre class="programlisting">[3.2258064516129035, 35.483870967741936, 67.74193548387096]
29.032258064516128</pre></div><p>The width of each band is now 29.03, with a padding of 3.23 between bands (including on the outside of the two outer bands).</p><p>The value for padding is a value between 0.0 (the default, and which results in a padding of 0) and 1.0, resulting in bands of width 0.0. A value of 0.5 makes the padding the same width as each band.</p></div></div><div class="section" title="Visualizing The Walking Dead viewership"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec37"/>Visualizing The Walking Dead viewership</h2></div></div></div><p>Now we<a id="id267" class="indexterm"/> pull everything from the chapter together to render a bar graph of the viewership across all the episodes of <span class="emphasis"><em>The Walking Dead</em></span>:</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note81"/>Note</h3><p>bl.ock (5.10): <a class="ulink" href="http://goo.gl/T8d6OU">http://goo.gl/T8d6OU</a>
</p></div></div><p>The output of the preceding example is as follows:</p><div class="mediaobject"><img src="graphics/B04230_05_01.jpg" alt="Visualizing The Walking Dead viewership"/></div><p>Now let's step through how this is created. After loading the data from the JSON file, the first thing that is performed is the extraction of the <code class="literal">USViewership</code> values and the determining of the maximum value:</p><div class="informalexample"><pre class="programlisting">var viewership = data.map(function (d) {
    return d.USViewers;
});

var maxViewers = d3.max(viewership);</pre></div><p>Then various variables, which represent various metrics for the graph, and the main SVG element are<a id="id268" class="indexterm"/> created:</p><div class="informalexample"><pre class="programlisting">var margin = { top: 10, right: 10, bottom: 260, left: 85 };

var graphWidth = 500, graphHeight = 300;

var totalWidth = graphWidth + margin.left + margin.right;
var totalHeight = graphHeight + margin.top + margin.bottom;

var axisPadding = 3;

var svg = d3.select('body')
    .append('svg')
    .attr({ width: totalWidth, height: totalHeight });</pre></div><p>The container for holding the bars is created next:</p><div class="informalexample"><pre class="programlisting">var mainGroup = svg
    .append('g')
    .attr('transform', 'translate(' + margin.left + ',' + 
                                      margin.top + ")");</pre></div><p>Now we create an ordinal scale for the bars using <code class="literal">.rangeBands()</code>. We will use this to calculate the bar position and padding:</p><div class="informalexample"><pre class="programlisting">var bands = d3.scale.ordinal()
    .domain(viewership)
    .rangeBands([0, graphWidth], 0.05);</pre></div><p>We also require a scale to calculate the height of each bar:</p><div class="informalexample"><pre class="programlisting">var yScale = d3.scale
    .linear()
    .domain([0, maxViewers])
    .range([0, graphHeight]);</pre></div><p>The following function is used by the selection that creates the bars to position each of them:</p><div class="informalexample"><pre class="programlisting">function translator(d, i) {
    return "translate(" + bands.range()[i] + "," +
                          (graphHeight - yScale(d)) + ")";
}</pre></div><p>Now we create the groups for the content of each bar:</p><div class="informalexample"><pre class="programlisting">var barGroup = mainGroup.selectAll('g')
    .data(viewership)
    .enter()
    .append('g')
    .attr('transform', translator);</pre></div><p>Next we append the rectangle for the bar:</p><div class="informalexample"><pre class="programlisting">barGroup.append('rect')
    .attr({
        fill: 'steelblue',
        width: bands.rangeBand(),
        height: function(d) { return yScale(d); }
    });</pre></div><p>And then <a id="id269" class="indexterm"/>add a label to the bar to show the exact viewership value:</p><div class="informalexample"><pre class="programlisting">barGroup.append('text')
    .text(function(d) { return d; })
    .style('text-anchor', 'start')
    .attr({
        dx: 10,
        dy: -10,
        transform: 'rotate(90)',
        fill: 'white'
    });</pre></div><p>The bars are now complete, so we move on to creating both the axes. We start with the left axis:</p><div class="informalexample"><pre class="programlisting">var leftAxisGroup = svg.append('g');
leftAxisGroup.attr({
    transform: 'translate(' + (margin.left - axisPadding) + ',' +
                               margin.top + ')'
});

var yAxisScale = d3.scale
    .linear()
    .domain([maxViewers, 0])
    .range([0, graphHeight]);

var leftAxis = d3.svg.axis()
    .orient('left')
    .scale(yAxisScale);
var leftAxisNodes = leftAxisGroup.call(leftAxis);
styleAxisNodes(leftAxisNodes);</pre></div><p>And now create a bottom axis which displays the titles:</p><div class="informalexample"><pre class="programlisting">var titles = data.map(function(d) { return d.Title; });
var bottomAxisScale = d3.scale.ordinal()
    .domain(titles)
    .rangeBands([axisPadding, graphWidth + axisPadding]);

var bottomAxis = d3.svg
    .axis()
    .scale(bottomAxisScale)
    .orient("bottom");

var bottomAxisX = margin.left - axisPadding;
var bottomAxisY = totalHeight - margin.bottom + axisPadding;

var bottomAxisGroup = svg.append("g")
    .attr({ transform: 'translate(' + bottomAxisX + ',' + bottomAxisY + ')' });

var bottomAxisNodes = bottomAxisGroup.call(bottomAxis);
styleAxisNodes(bottomAxisNodes);

bottomAxisNodes.selectAll("text")
    .style('text-anchor', 'start')
    .attr({
        dx: 10,
        dy: -5,
        transform: 'rotate(90)'
});</pre></div><p>The following<a id="id270" class="indexterm"/> function is reusable code for styling the axes:</p><div class="informalexample"><pre class="programlisting">function styleAxisNodes(axisNodes) {
    axisNodes.selectAll('.domain')
        .attr({
            fill: 'none',
            'stroke-width': 1,
            stroke: 'black'
        });
    axisNodes.selectAll('.tick line')
        .attr({
            fill: 'none',
            'stroke-width': 1,
            stroke: 'black'
        });
}</pre></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec31"/>Summary</h1></div></div></div><p>In this chapter, you learned how to load data from the web and use it as the basis for a bar graph. We started with loading data in the JSON, CSV, and TSV formats. You learned how to use the <code class="literal">.map()</code> function to extract just the values that you desire from this data, and examined the issues and solutions needed for converting string values into numeric values.</p><p>Next we covered scales in some more detail, and looked at several examples of the ways to use scales for mapping data from one range of values to another as well as to map discrete values such as color names to color codes. We covered categorical scales, a means of mapping integer values into predefined color maps, and a concept that we will use frequently in our examples. Our examination of scales ended with a demonstration of using <code class="literal">.rangeBands()</code>, and how it can help us size and place bars within a predefined area.</p><p>We closed the chapter by combining all of these concepts together into, what is up to this point, our best example of generating a bar chart. This demonstrated loading the data, using multiple scales for both data and axes, and using <code class="literal">.rangeBands()</code> to determine the placement of the bars, as well as using not only a vertical but also a horizontal axis.</p><p>In the next chapter, we will branch out of bar graphs into another type of data visualization—scatter (and bubble) plots.</p></div></body></html>