<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Say Cheese!</h1></div></div></div><p>There was a time, not so long ago, when cameras on mobile phones didn't exist. And then there was a time when those cameras were so bad, they were really only useful for snapping <em>reminder shots</em>, for example, snapping a picture of a store item that you wanted to look up more information about later. But now so many mobile devices have excellent cameras that can take fantastic pictures. In this project, we'll look at how to use these cameras in our own app.</p><div><div><div><div><h1 class="title"><a id="ch06lvl1sec54"/>What do we build?</h1></div></div></div><p>In this Project, we're going<a id="id624" class="indexterm"/> to build an app called <code class="literal">Imgn</code>. It won't be a complete app; all it <a id="id625" class="indexterm"/>will do is take pictures and let you view them. But there are a lot of things you could add on to it, such as sharing functionality or creative filters that could change the image after it was taken.</p><p>What this app will do, however, is show the process for taking a picture via the device's camera and also show the process for accessing the user's photo album so that images can be imported to the app. Like with our previous apps, we'll have full file management, so images can be deleted, copied, and renamed at will. We'll accomplish this a little differently though; we'll be implementing something seen in a lot of photo apps – the image grid.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec117"/>What does it do?</h2></div></div></div><p>Ultimately, the app <a id="id626" class="indexterm"/>will let you take a picture or import one from your photo library, and then view it. While it sounds simple enough, the app has full image management, which means we'll go over how to delete, copy, and rename images as well. In most photo apps, there is usually the option to delete images in batches (say you took several blurry photos and don't want them anymore), and deleting images in batches with the <code class="literal">File</code> API<a id="id627" class="indexterm"/> can be a bit tricky.</p><p>Most photo apps also use <a id="id628" class="indexterm"/>what is called the image grid, which is a grid of small image thumbnails that let the user see several images at once on the screen and scroll through them all. This grid isn't terribly hard to implement; it's really just a series of thumbnails that wrap using good-old HTML. Where this idea falls apart is that there's no functionality in PhoneGap to create a thumbnail from an image; which means that the images displayed as a thumbnail are really the full-sized image, they're just scaled down to a small thumbnail. This scaling introduces a lot of performance problems, and as a workaround, we'll be using the HTML5 <code class="literal">Canvas</code> tag<a id="id629" class="indexterm"/> to actually get some of that performance back.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec118"/>Why is it great?</h2></div></div></div><p>We'll be covering a lot of <a id="id630" class="indexterm"/>technologies in this project, all of which are critical if you're going to make a performant photo app. We'll look at how to take a picture and how to import one from the user's photo library – both of which are critically important in a large number of apps. Social apps use this kind of functionality quite often, but there are other apps that do so as well.</p><p>As always, we'll be covering file management, which is never that easy. In this project, we'll be introduced to the idea of a wrapper for the <code class="literal">File</code> API, which should make dealing with files just a little bit easier. Ultimately, though, we still have to get a bit tricky when dealing with files, so be prepared to twist your brain inside out.</p><p>We'll be working with something that's gaining a lot of traction in the mobile web world: the <strong>HTML5 Canvas</strong>. It's been used to great effect in desktop websites, but only now have our mobile devices started to become fast enough to use Canvas in interesting ways.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec119"/>How are we going to do it?</h2></div></div></div><p>As in all our previous<a id="id631" class="indexterm"/> tasks, we're going to approach this using our tried-and-true approach:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing the user interface and the look and feel</li><li class="listitem" style="list-style-type: disc">Designing the data model</li><li class="listitem" style="list-style-type: disc">Implementing the documents view</li><li class="listitem" style="list-style-type: disc">Implementing the image view</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec120"/>What do I need to get started?</h2></div></div></div><p>In order to get started, you'll need to <a id="id632" class="indexterm"/>create the project as you've done in each project so far. You should also take a look at the resources directory in the project files for this project. We've got several icon files that you might find interesting.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec55"/>Designing the user interface and the look and feel</h1></div></div></div><p>Conceptually, this is a <a id="id633" class="indexterm"/>pretty simple app from a user interface perspective. If you've <a id="id634" class="indexterm"/>seen a photo app on a phone, chances are you already know where we're headed. Even so, let's design a mockup, and then flesh that out a bit to come up with the assets we'll need for our look and feel.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec121"/>Getting on with it</h2></div></div></div><p>Let's examine the mockups <a id="id635" class="indexterm"/>for this project:</p><div><img src="img/9403OS_06_01.jpg" alt="Getting on with it"/></div><p>The left-most screen is simply a grid (1) of all the images that the user has added to the app. These images might be taken with the camera, or they might have been imported in various ways.</p><p>In the navigation bar, we'll have a fancy title – photo apps, for some reason, seem to call for something less utilitarian than some of our apps have been lately. We'll also be including an <strong>Edit</strong> button that can also change state to a <strong>Done</strong> button (2). This button indicates the current state; if a user taps <strong>Edit</strong>, the images will become selectable for batch operations such as a <em>delete</em> operation. In this mode, the button switches to <strong>Done</strong>. If the user taps the button again, they will exit selection mode, and the button will indicate <strong>Edit</strong> once again. Any selections the user made will be discarded.</p><p>It's been a little while since <a id="id636" class="indexterm"/>we had a toolbar (3), too. We'll show various icons <a id="id637" class="indexterm"/>here depending upon the current editing state. If we're not in selection mode (the navigation bar button shows <strong>Edit</strong>), we'll show a camera and a film roll. These two icons will allow interaction with the camera and photo album, respectively. If we are in the selection mode (the navigation bar button shows <strong>Done</strong>), and have at least one image selected, we'll show a trashcan icon and a person icon indicating <em>delete</em> and <em>share</em>, respectively.</p><p>If we aren't in a selection mode, the user can tap an image to see it enlarged. At this point, we'll move to the right-most screen seen in the preceding screenshot. The navigation bar will have a <strong>Back</strong> button (4). The image will be displayed in the content area (5). If the image is larger than the screen, it will be able to scroll. In the toolbar (6), we'll provide a way to delete the image, or to share it.</p><p>Now that we've gone over the mockups, let's flesh things out a bit more. Here's the final result after doing some work in our favorite graphics editor:</p><div><img src="img/9403_06_02.jpg" alt="Getting on with it"/></div><p>While the basic <a id="id638" class="indexterm"/>
<a id="id639" class="indexterm"/>elements of all our apps are present, it's clear that they've been spruced up quite a bit. The navigation bar has been given a fresh coat of paint and a playful font for the title of the app. The toolbar has also been given a nice upgrade to a darker color.</p><p>Each image will be given a simple white border and a drop shadow to help it stand out from the background. These effects are easily achieved using CSS, so we won't need images for this particular part.</p><p>For the rest of the app though, it's a different story. We'll have four icons, namely, a camera, a film roll, a trashcan, and a person. These icons will always reside in the toolbar and can be tapped to perform an action. The navigation bar and toolbar itself will also need to be a graphical asset. These would be quite difficult to render using CSS alone (especially since there is some subtle <em>noise</em> in both to give them some texture). Finally, the title itself needs to be an image asset since the font we've used may not be available on the device. About the only thing other than the photos themselves on this workup that we can do without images is the <strong>Edit</strong> button on the navigation bar. We'll be using the same CSS we've been using to accomplish the display of the button.</p><p>The second screen of this app, the image view, isn't mocked up here – all it would be is a large image in the middle with the rest of the design unchanged. The two icons would be the trashcan and the person in the toolbar, but that's about all that's different.</p><p>Now that we've determined what needs to be a graphical asset, it's time to splice them out of our mockup. You can see the final result in the <code class="literal">www/images</code> directory of our project.</p><div><div><h3 class="title"><a id="tip03"/>Tip</h3><p>We made the title its own image separate from the navigation bar. This is because the navigation bar is free to tile and we wouldn't want the title to tile along with it!</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec122"/>What did we do?</h2></div></div></div><p>In this task <a id="id640" class="indexterm"/>
<a id="id641" class="indexterm"/>we've mocked up the user interface and detailed how everything works together. We've also fleshed out the mockup so that we were able to generate the image assets we'll need for the implementation of the app.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec56"/>Designing the data model</h1></div></div></div><p>For the first time, our <a id="id642" class="indexterm"/>
<a id="id643" class="indexterm"/>data model is going to be remarkably simple. There's really not a lot to keep track of here. In a way, our data model is exactly replicated by what is in persistent storage—the images themselves.</p><div><div><div><div><h2 class="title"><a id="ch06lvl2sec123"/>Getting on with it</h2></div></div></div><p>Just like in prior tasks, we do have a document collection model that reads all the images in persistent storage and lets our document view interact with them. There has been almost no change in this particular model (save for the name), so we won't cover it here.</p><p>What we will cover is not quite a data model, but still important. When a user taps the <strong>Edit</strong> button, we want them to be able to select multiple pictures for a batch operation (such as delete). To do this, we need to keep track of which images are selected, and which ones aren't.</p><p>The model itself is so simple that it doesn't actually have its own code file. It's just an array combined with a single property that indicates if we are in selection mode or not. This is what it looks like:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">inSelectionMode</code></li><li class="listitem" style="list-style-type: disc"><code class="literal">selectedItems[]</code></li></ul></div><p>That's it. Dreadfully simple, yes, but it is important to understand how this works to provide a selection mechanism.</p><p>When the app begins, we won't be in the selection mode, so<a id="id644" class="indexterm"/> <code class="literal">inSelectionMode</code> will be <code class="literal">false</code>. If the user taps <strong>Edit</strong>, we change this to <code class="literal">true</code>, and change the color of the borders around all the images to a light yellow color. The color itself really doesn't matter; it's done simply to show that the device responded to the tap and that all the images are currently not selected (we'll use red to indicate selected images). This also means the <code class="literal">selectedItems</code> array<a id="id645" class="indexterm"/> will also be blank.</p><p>There are two ways <a id="id646" class="indexterm"/>
<a id="id647" class="indexterm"/>we could approach how to keep track of which images are selected. We could set up an array that had as many items as images on the screen. This would work, but chances are pretty good that most of these images would remain unselected throughout the selection operation. Unless the user is intending to delete all the images (which, while possible, is something that doesn't happen very often), there's really no need to waste all that space.</p><p>Instead, we'll keep a track of these selections using a<a id="id648" class="indexterm"/> <code class="literal">sparse</code>
<strong> </strong>array; each item in the array will instead point to the image that is selected. That means, if we select three images, the array only needs to be three items long. Any image not contained within the array can be considered to be unselected, and those that are in the array are considered selected.</p><p>This does present a few difficulties in how to manage this array, though. Thankfully it's not too hard to get one's head around.</p><p>Let's imagine that the user taps on image 3 while in selection mode. First we'll change the border color to something striking (red, in our example) to indicate that we <em>heard</em> the user. Then we'll use the <code class="literal">push</code> method<a id="id649" class="indexterm"/> of the array to add the image to the selection. At this point our array contains exactly one item with the value of <code class="literal">3</code>. The user goes on to select a few more items, and say we finally end up with an array of <code class="literal">3</code>, <code class="literal">1</code>, <code class="literal">9</code>. This means images 1, 3, and 9 are selected. (Notice that the order simply doesn't matter.)</p><p>Now, let's imagine that the user taps image 1 again. It's already selected, so we should unselect it. To do this, we need to remove the second item of the array so that we're left with an array of <code class="literal">3</code>, <code class="literal">9</code>. JavaScript makes it really easy to do this, though the names of the methods might not be immediately obvious.</p><p>First, we'll use <code class="literal">indexOf</code> to <a id="id650" class="indexterm"/>find where <code class="literal">1</code> is in the array. Once we've found the location, we'll use <code class="literal">splice()</code> to tell JavaScript to remove that particular item. The <code class="literal">splice()</code> method<a id="id651" class="indexterm"/> can be used for really cool array operations, but it also does item removal particularly well.</p><p>With these three <a id="id652" class="indexterm"/>
<a id="id653" class="indexterm"/>methods on the array, we can track the selection state of any image. If we can't find the image in the array, we know it isn't selected. If we do find the image in the array, we know it is selected. And that's really all we need to know.</p><p>When the user is done with their selection, they have the option to do something with it. This is where things can get a little dicey. Let's say they want to delete several images at once. The <code class="literal">File</code> API is a bit painful, as we've seen from previous tasks, and now we have to figure out a way to call it several times in a row. In other programming languages with synchronous file operations, we'd use a simple<a id="id654" class="indexterm"/> <code class="literal">for</code> loop, but we don't have that luxury with the <code class="literal">File</code> API provided by PhoneGap, since it is an asynchronous API.</p><p>The other thing the user can do is end their selection, which they can do by tapping on <strong>Done</strong>. When this occurs, we will change all the image borders back to white to indicate that we've heard the user, and to also indicate that any selected images are now unselected.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec124"/>What did we do?</h2></div></div></div><p>In this task, we've examined a simple data model that keeps track of selections in an array. We've discussed how we'll use <code class="literal">push()</code>, <code class="literal">indexOf()</code>, and <code class="literal">splice()</code> to maintain this array, and how all this will appear to the user.</p><p>Since this model is so simple, we've not bothered to give it a separate file; we'll make it a part of the document view that we'll implement next.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec57"/>Implementing the document view</h1></div></div></div><p>While there are portions of our <a id="id655" class="indexterm"/>
<a id="id656" class="indexterm"/>document view that are the same as or similar to the previous projects, there is also quite a bit that is different. The view has to handle taking pictures, importing them, and then dealing with the user selecting several pictures at once in advance of a batch operation. This means there is quite a bit going on, even if the underlying model is pretty simple.</p><p>Here's how the view will look, first for iOS:</p><div><img src="img/9403_06_03.jpg" alt="Implementing the document view"/></div><p>For Android, the view <a id="id657" class="indexterm"/>
<a id="id658" class="indexterm"/>will be as follows:</p><div><img src="img/9403_06_04.jpg" alt="Implementing the document view"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec125"/>Getting ready</h2></div></div></div><p>Our view is <a id="id659" class="indexterm"/>
<a id="id660" class="indexterm"/>located in <code class="literal">www/views/documentsView.html</code> in the files for this project if you want to follow along.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec126"/>Getting on with it</h2></div></div></div><p>As always, let's start with the HTML portion of our view:</p><div><pre class="programlisting">&lt;div class="viewBackground"&gt;
  &lt;div class="navigationBar"&gt;
    &lt;div style="padding-top:7px" id="documentsView_title"&gt;&lt;/div&gt;
    &lt;button class="barButton" id="documentsView_editButton" style="right:10px" &gt;&lt;/button&gt;
  &lt;/div&gt;
  &lt;div class="content avoidNavigationBar avoidToolBar" style="padding:0; overflow: scroll;" id="documentsView_scroller"&gt;
    &lt;div id="documentsView_contentArea" style="padding: 0; height: auto; position: relative;"&gt;&lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="toolBar"&gt;
    &lt;span class="icon" id="documentsView_cameraButton"&gt;&lt;img src="img/photo_64.png" width=32 height=32 /&gt;&lt;/span&gt;
    &lt;span class="icon" id="documentsView_importButton"&gt;&lt;img src="img/film_64.png" width=32 height=32 /&gt;&lt;/span&gt;
    &lt;span class="icon" id="documentsView_deleteButton"&gt;&lt;img src="img/trash_64.png" width=32 height=32 /&gt;&lt;/span&gt;
    &lt;span class="icon" id="documentsView_shareButton"&gt;&lt;img src="img/man_64.png" width=32 height=32 /&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>Most of this <a id="id661" class="indexterm"/>
<a id="id662" class="indexterm"/>code is similar to the document views in previous projects. The <code class="literal">div</code> element <code class="literal">documentsView_title</code> has an in-line style to bring the title image down a bit; otherwise, it would align to the top of the navigation bar. The rest of the changes rest in the <code class="literal">div</code> classed <code class="literal">toolBar</code> where we have four icons defined, namely the photo (<code class="literal">photo_64.png</code>) icon, the film (<code class="literal">film_64.png</code>) icon, the trash (<code class="literal">trash_64.png</code>) icon, and the person (<code class="literal">man_64.png</code>) icon. As these icons aren't going to change based on localization, it is safe to put them here rather than define the content in<a id="id663" class="indexterm"/> <code class="literal">initializeView()</code>.</p><p>Next, let's look at our template that we will use for each image:</p><div><pre class="programlisting">&lt;div id="documentsView_documentTemplate" class="hidden"&gt;
  &lt;div class="documentContainer" id="documentsView_item%INDEX%"&gt;
    &lt;div class="documentImage"&gt;
      &lt;canvas width=84 height=84
      id="documentsView_item%INDEX%_canvas"
      onclick="documentsView.documentContainerTapped(%INDEX%);"&gt;&lt;/canvas&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;</pre></div><p>This is probably the simplest template we've had in quite some time. All that is contained within is a <code class="literal">canvas</code> tag with a unique <code class="literal">id</code> value and a <code class="literal">click</code> handler. Don't let the simplicity fool you that we use a <code class="literal">canvas</code> tag rather than an <code class="literal">img</code> tag means that we have to have code that draws images to the <code class="literal">canvas</code> tag later on. The gains, however, that using <code class="literal">canvas</code> brings is worth this extra code.</p><div><div><h3 class="title"><a id="tip04"/>Tip</h3><p>We have given the <code class="literal">canvas</code> tag a specific <code class="literal">width</code> and <code class="literal">height</code>; this gives it a defined shape until we can later override it with the actual image width and height. This is simply to make a smoother transition from an unloaded image to a loaded image.</p></div></div><p>With the HTML out of the way, let's take a look at the code:</p><div><pre class="programlisting">  var documentsView = $ge("documentsView") || {};
  documentsView.firstTime = true;
  documentsView.lastScrollLeft = 0;
  documentsView.lastScrollTop = 0;
  documentsView.myScroll = {};
  documentsView.availableDocuments = {};
  documentsView.inSelectionMode = false;
  documentsView.selectedItems = [];
  documentsView.globalAlert = null;</pre></div><p>Most of these <a id="id664" class="indexterm"/>
<a id="id665" class="indexterm"/>properties just used are the ones we're familiar with from previous projects. However, there are three that are important to this particular project, mentioned as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">inSelectionMode</code>: This<a id="id666" class="indexterm"/> indicates if the user has placed us into the selection mode. In the selection mode, the user can select multiple images for a batch operation (such as a delete operation), whereas outside of the selection mode, tapping the image results in viewing it larger.</li><li class="listitem" style="list-style-type: disc"><code class="literal">selectedItems</code>: This is an array, <a id="id667" class="indexterm"/>as discussed in the previous task, it contains the selected images. This is a <em>sparse</em> array, as it only contains those images actually selected and not those that are unselected.</li><li class="listitem" style="list-style-type: disc"><code class="literal">globalAlert</code>: This is a <a id="id668" class="indexterm"/>placeholder for an alert. We'll use this when doing a batch delete. If the user happens to delete several images at once, it might take a few seconds, and so we want to be able to display an alert over the action going on underneath.</li></ul></div><p>After this, we have the initialization code for the view given as follows:</p><div><pre class="programlisting">  documentsView.initializeView = function()
  {
    PKUTIL.include(["./models/ImageDocumentCollection.js", "./models/VoiceRecDocument.js"], function()
    {
      documentsView.displayAvailableDocuments();
    });

    documentsView.viewTitle = $ge("documentsView_title");
    documentsView.viewTitle.innerHTML = __T("APP_TITLE_IMG");

    documentsView.editButton = $ge("documentsView_editButton");
    documentsView.editButton.innerHTML = __T("EDIT");
    PKUI.CORE.addTouchListener(documentsView.editButton, "touchend",
      function(e)
      {
        documentsView.toggleSelection();
      }
    );</pre></div><p>So far, not much is different than in our previous projects. In the preceding code, we've added text and code to the <strong>Edit</strong> button – if tapped, we'll call <code class="literal">toggleSelection()</code>,<a id="id669" class="indexterm"/> which will switch the selection modes.</p><p>Next, we'll define<a id="id670" class="indexterm"/>
<a id="id671" class="indexterm"/> the handlers for each icon on the toolbar using the following code snippet:</p><div><pre class="programlisting">    documentsView.cameraButton = $ge("documentsView_cameraButton");
    PKUI.CORE.addTouchListener(documentsView.cameraButton, "touchend",
      function(e)
    {
    documentsView.takePicture();
      }
    );
    
    documentsView.importButton = $ge("documentsView_importButton");
    PKUI.CORE.addTouchListener(documentsView.importButton, "touchend",
      function(e)
      {
        documentsView.importPicture();
      }
    );
    
    documentsView.deleteButton = $ge("documentsView_deleteButton");
    documentsView.deleteButton.style.display="none";
    PKUI.CORE.addTouchListener(documentsView.deleteButton, "touchend",
      function(e)
      {
        documentsView.confirmDeletePictures();
      }
    );
    
    documentsView.shareButton = $ge("documentsView_shareButton");
    documentsView.shareButton.style.display="none";</pre></div><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p>We've not attached a touch listener to the <strong>Share</strong> button for now. Refer to <a class="link" href="ch02.html" title="Chapter 2. Let's Get Social!">Project 2</a>, <em>Let's Get Social!</em> if you want to implement sharing.</p></div></div><p>Something important to note is that the last two icons are set to a <code class="literal">display</code> of <code class="literal">none</code>, which means they won't show up on the screen. This is because they only apply to selected images and there's no need to display them if they can't do anything. When we change selection modes and at least one image is selected, we'll re-display them.</p><p>With the view initialized, let's look at<a id="id672" class="indexterm"/> <code class="literal">toggleSelection()</code>. This is the handler for when the user taps the <strong>Edit</strong> button:</p><div><pre class="programlisting">  documentsView.toggleSelection = function ()
  {
    var i;
    var anElement;
    documentsView.inSelectionMode = !documentsView.inSelectionMode;</pre></div><p>The first thing we <a id="id673" class="indexterm"/>
<a id="id674" class="indexterm"/>need to do (given the name of the method) is to switch selection modes. We'll take advantage of how Booleans work to simply switch the value: if it is <code class="literal">false</code> coming in, we'll switch it to <code class="literal">true</code>, and vice versa.</p><div><pre class="programlisting">    if (documentsView.inSelectionMode)
    {
      documentsView.editButton.innerHTML=__T("DONE");
      documentsView.selectedItems=[];
      for (i=0; i&lt;documentsView.availableDocuments.getDocumentCount(); i++)
      {
        anElement = $ge("documentsView_item"+i+"_canvas");
        anElement.style.border = "3px solid #FF8";
      }
      
      documentsView.cameraButton.style.display="none";
      documentsView.importButton.style.display="none";
      documentsView.deleteButton.style.display="none";
      documentsView.shareButton.style.display="none";
      
    }</pre></div><p>As seen in the preceding code, if we're now in the selection mode, we'll alter the <strong>Edit</strong> button to display <strong>Done</strong> so that the user knows how to end the selection mode. Next we empty the <code class="literal">selectedItems</code> array so that any previous selections are wiped out. Since we're using the image borders to indicate selection state, we need to iterate through each image and set its border to the unselected state (light yellow). Finally, we hide all the icons in the toolbar as none of them are immediately applicable.</p><div><pre class="programlisting">    else
    {
      documentsView.editButton.innerHTML=__T("EDIT");
      for (i=0; i&lt;documentsView.availableDocuments.getDocumentCount(); i++)
      {
        anElement = $ge("documentsView_item"+i+"_canvas");
        anElement.style.border = "3px solid #FFF";
      }
      
      documentsView.cameraButton.style.display="inline";
      documentsView.importButton.style.display="inline";
      documentsView.deleteButton.style.display="none";
      documentsView.shareButton.style.display="none";
      
    }
  }</pre></div><p>On the other hand, if we're ending a selection, we need to switch the <strong>Done</strong> button back to <strong>Edit</strong> and then turn all the image borders back to white. We also have to re-enable the first two icons (camera and import) since they now apply to our current state. The last two icons are hidden (since they may have been visible just prior to ending the selection).</p><p>Switching the selection<a id="id675" class="indexterm"/>
<a id="id676" class="indexterm"/> mode, of course, isn't sufficient to actually implement selection, so let's look at<a id="id677" class="indexterm"/> <code class="literal">documentContainerTapped()</code>, which is called every time an image is tapped:</p><div><pre class="programlisting">  documentsView.documentContainerTapped = function(idx)
  {
    var theElement = $ge("documentsView_item" + idx + "_canvas");
    if (documentsView.inSelectionMode)
    {</pre></div><p>Tapping on an image means different things based on whether or not we're in the selection mode. If we are in the selection mode, tapping on it should either select the image (if not previously selected), unselect the image (if previously selected), and then update the toolbar; this is done using the following code snippet:</p><div><pre class="programlisting">      if ( documentsView.selectedItems.indexOf (idx) &gt; -1 )
      {
        theElement.style.border = "3px solid #FF8";
        documentsView.selectedItems.splice (
        documentsView.selectedItems.indexOf( idx), 1);
      }</pre></div><p>To determine if the image is selected, we use<a id="id678" class="indexterm"/> <code class="literal">indexOf()</code>. If the image is in the array, we know the image is currently selected; therefore, tapping on it should deselect it and we change the border color to light yellow and remove the image from the <code class="literal">selectedItems</code> array using the<a id="id679" class="indexterm"/> <code class="literal">splice()</code> method.</p><div><pre class="programlisting">      else
      {
        theElement.style.border = "3px solid #800";
        documentsView.selectedItems.push(idx);
      }</pre></div><p>If the image isn't found in the<a id="id680" class="indexterm"/> <code class="literal">selectedItems</code> array, we know we need to select it, so we change the border color (red) and add it to the array via the<a id="id681" class="indexterm"/> <code class="literal">push()</code> method.</p><div><pre class="programlisting">      if (documentsView.selectedItems.length&gt;0)
      {
        documentsView.deleteButton.style.display="inline";
        documentsView.shareButton.style.display="inline";
      }
      else
      {
        documentsView.deleteButton.style.display="none";
        documentsView.shareButton.style.display="none";
      }
    }</pre></div><p>Regardless of whether<a id="id682" class="indexterm"/>
<a id="id683" class="indexterm"/> or not we selected or deselected the image, we need to handle the toolbar. If we've selected at least one image, we'll display the <em>delete</em> and <em>share</em> icons. If the selection ever becomes empty, we'll hide them again.</p><div><pre class="programlisting">    else
    {
      PKUI.CORE.pushView (imageView);
      PKUTIL.delay(500, function()
      {
        imageView.setImage ( documentsView.availableDocuments.getDocumentAtIndex(idx).fullPath, idx );
      } );
    }
  }</pre></div><p>If we're not in the selection mode, tapping on the image should move to the image view so that we can see it at full size. We push the view first, then after <code class="literal">500</code> ms we actually tell the view what image to display. This may seem odd at first (normally we'd do this in the opposite order), but it is intended to smooth the transition to the new view. Images obtained from the camera can be quite large, and loading that image takes some time. If it is loading at the same time as the transition, the transition will stutter, making the app feel slower than it really is. So instead, we wait until the transition will be over, and then tell the view to load the image.</p><p>With selection out of the way, let's look at how we take and import pictures. Essentially these actions are the same thing, only the source of the image is different. Of course, to the user, they are very different. One involves taking a picture (framing the picture, waiting for the right moment, pressing the shutter release, and so on) while the other only involves the user searching for an image already on their camera. But to the app, they are technically the same thing with different image sources. Because of this, we'll have three methods, the first two to determine what the image source is, and the final one to do the actual <a id="id684" class="indexterm"/>
<a id="id685" class="indexterm"/>work of taking or importing the image.</p><div><pre class="programlisting">  documentsView.takePicture = function()
  {
    documentsView.doPicture ( Camera.PictureSourceType.CAMERA );
  }</pre></div><p>First up, taking a picture. We'll call <code class="literal">doPicture()</code> <a id="id686" class="indexterm"/>with the source of <code class="literal">CAMERA</code>, which indicates that the picture is to be obtained from the device camera. The user interface will vary based on the platform and device, but we don't need to worry about that as PhoneGap provides the interface for us.</p><div><pre class="programlisting">  documentsView.importPicture = function()
  {
    documentsView.doPicture ( Camera.PictureSourceType.PHOTOLIBRARY );
  }</pre></div><p>To import a picture, we call <code class="literal">doPicture()</code> with the source of <code class="literal">PHOTOLIBRARY</code>. This indicates that the image should come from the user's own library of images. Again, the user interface will vary based on the platform and device, but our app doesn't have to worry about that as PhoneGap will handle all the details for us.</p><div><pre class="programlisting">  documentsView.doPicture = function( source )
  {
    navigator.camera.getPicture ( 
      function (uri)
      {
        PKFILE.moveFileTo ( uri, "doc://" + PKUTIL.getUnixTime() + ".jpg",
        function ()
        {
          documentsView.reloadAvailableDocuments();
        },
        function (evt)
        {
          console.log (JSON.stringify(evt));
          var anAlert = new 
          PKUI.MESSAGE.Alert(__T("Oops!"), __T("Failed to save the image."));
          anAlert.show();
        } )
      },
      function (msg)
      {
        var anAlert = new PKUI.MESSAGE.Alert(__T("Oops!"), 
        msg);
        anAlert.show();
      },
      { quality: 50,
        destinationType: Camera.DestinationType.FILE_URI,
        sourceType: source,
        encodingType: Camera.EncodingType.JPEG,
        mediaType: Camera.MediaType.PICTURE,
        correctOrientation: true,
        saveToPhotoAlbum: false
      }
    );
  }</pre></div><p>There are several layers of callbacks going on in this function, each of which relies on the previous step being executed correctly. Let's look at the outer layer for now.</p><p>To take an image, or<a id="id687" class="indexterm"/>
<a id="id688" class="indexterm"/> import one, we call <code class="literal">navigator.camera.getPicture()</code> with three parameters: the <code class="literal">success</code> function<a id="id689" class="indexterm"/>, the <code class="literal">failure</code> function<a id="id690" class="indexterm"/>, and the options. The options in our function are at the very end of the method. Here's what each one means:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">quality</code>: This is the compression<a id="id691" class="indexterm"/> used for the image. We use <code class="literal">50</code> because it is a good tradeoff between quality and file size. Furthermore, some devices have problems handling images from the camera with a quality higher than 50. (Typically, on devices that exhibit problems with a quality larger than 50, the app would crash. Not a good end-user experience.)</li><li class="listitem" style="list-style-type: disc"><code class="literal">destinationType</code>: It <a id="id692" class="indexterm"/>determines the destination. There are two options here: we can either request a base64-encoded string which represents the image data, or we can request the file location where the image was saved. We're requesting the file location instead of base64, simply due to ease of handling and memory concerns. (Base64 is at least double the file size of the image.)</li><li class="listitem" style="list-style-type: disc"><code class="literal">sourceType</code>: It determines <a id="id693" class="indexterm"/>where the image should come from. If set to <code class="literal">CAMERA</code>, it will get the image from the camera. If <code class="literal">PHOTOLIBRARY</code>, it will get it from the user's library. Note that we take the incoming parameter here, which is what<a id="id694" class="indexterm"/> <code class="literal">takePicture()</code> and <code class="literal">importPicture()</code> <a id="id695" class="indexterm"/>send to us.</li><li class="listitem" style="list-style-type: disc"><code class="literal">encodingType</code>: This is <a id="id696" class="indexterm"/>the image format, generally either JPEG or PNG. PNGs are great for images with a lot of pixel repetition (such as diagrams), and are lossless. For photography, however, PNGs would be too large. Instead, we'll use JPEGs. Though lossy, they won't be so large as to be unwieldy.</li><li class="listitem" style="list-style-type: disc"><code class="literal">mediaType</code>: The camera<a id="id697" class="indexterm"/> can often be used to take video instead of a still image. In this case, all we want is a still image, so we send <code class="literal">PICTURE</code>. This also limits the available formats when importing an image. Without this, a user could import a video instead, which we can't handle.</li><li class="listitem" style="list-style-type: disc"><code class="literal">correctOrientation</code>: This <a id="id698" class="indexterm"/>parameter can be used to correct the orientation used to take an image. For example, if the phone was rotated and we didn't correct the orientation, the image might appear sideways or upside-down. With this enabled, we get the image right-side up.</li><li class="listitem" style="list-style-type: disc"><code class="literal">saveToPhotoAlbum</code>: This can be <a id="id699" class="indexterm"/>either <code class="literal">true</code> or <code class="literal">false</code>. If <code class="literal">true</code>, the image taken by the camera will be saved to the photo album and our app. If <code class="literal">false</code>, only our app receives the image. While we use <code class="literal">false</code> here, it is really a matter of choice. Does it make sense for the image to be saved to the album as well as your app? The answer to that question depends on your app and its target audience.</li></ul></div><p>If we move into the <code class="literal">success</code> function for <code class="literal">navigator.camera.getPicture()</code>, we see this line:</p><div><pre class="programlisting">        PKFILE.moveFileTo ( uri, "doc://" + PKUTIL.getUnixTime() + ".jpg",</pre></div><p>The file given to us <a id="id700" class="indexterm"/>
<a id="id701" class="indexterm"/>by the camera may be in a temporary spot (especially on iOS), so we first move the file to a more permanent location. We're using the <code class="literal">PKFILE FILE</code> API wrapper to do this, which we'll discuss later on in this task. Using <code class="literal">doc://</code> here ensures that the file is written to persistent storage, and using the Unix Time (which is milliseconds since 1st January, 1970) ensures a nearly unique filename. (It's frankly impossible for the user to take two images in quick enough succession to end up on the same millisecond.)</p><p>When the move is complete, we call another <code class="literal">success</code> function, which simply reloads the available documents, which in our case redisplays the image grid with the new image in it.</p><p>Along the way we also have <code class="literal">failure</code> functions where we have the <code class="literal">alerts</code>. These are important if, for some reason, the camera fails to take the picture, or an import goes badly.</p><p>Next up, let's handle deleting multiple pictures at once (deleting a single picture is done the same way we've deleted documents in past projects):</p><div><pre class="programlisting">  documentsView.confirmDeletePictures = function ()
  {
    var anAlert = new PKUI.MESSAGE.Confirm(__T("Delete Image(s)"), __T("This will delete the selected image(s). This action is unrecoverable."), __T("Don't Delete&lt;|Delete*"), function(i)
    {
      if (i == 1)
      {
        PKUTIL.delay ( 100, documentsView.deleteSelectedPictures );
      }
    });
    anAlert.show();
  }</pre></div><p>First we ask the user if <a id="id702" class="indexterm"/>
<a id="id703" class="indexterm"/>they really want to delete the selected images as the action is unrecoverable. If they do, we call <code class="literal">deleteSelectedPictures()</code> <a id="id704" class="indexterm"/>after a short delay. This delay is to give enough time for the first alert to go away before <code class="literal">deleteSelectedPictures()</code> puts up its own alert.</p><div><pre class="programlisting">  documentsView.deleteSelectedPictures = function ()
  {
    if (documentsView.selectedItems.length &gt; 0)
    {
      var currentIndex = documentsView.selectedItems.pop();
      if (documentsView.globalAlert == null)
      {
        documentsView.globalAlert = new PKUI.MESSAGE.Alert(__T("Please Wait"), __T("Deleting Selected Images..."));
        documentsView.globalAlert.show();
      }
      PKUTIL.delay (100, function () {
      PKFILE.removeFile ( documentsView.availableDocuments.getDocumentAtIndex(currentIndex).fullPath,
      documentsView.deleteSelectedPictures,
      function (e)
      {
        documentsView.globalAlert.hide();
        var anAlert = new PKUI.MESSAGE.Alert (__T("Oops!"), __T("Failed to remove file."));
        anAlert.show();
        documentsView.reloadAvailableDocuments();
      }
      );
    }
    );
    }
    else
    {
      if (documentsView.globalAlert)
      {
        documentsView.toggleSelection();
        documentsView.reloadAvailableDocuments();
        documentsView.globalAlert.hide();
        PKUTIL.delay (750, function() { documentsView.globalAlert = null; } );
      }
      else
      {
        console.log ("ASSERT: We shouldn't be able to delete anything without having prior selected something.");
      }
    }
  }</pre></div><p>This method requires us to switch our brain inside-out a bit, since there's something missing we might normally expect—a <code class="literal">for</code> loop. Because the <code class="literal">FILE</code> APIs are all asynchronous, we can't loop around them, we need to be able to ensure all the API requests are finished before we tell the user we're done.</p><p>So instead, we use something akin to recursion. It's not true recursion, since the function calls aren't nested within each other, but it is close enough to be a bit painful on our neurons.</p><p>We start by checking the length of the <code class="literal">selectedItems</code> array. If it has any images in it, we know we need to delete one. If it has nothing in it, we know we've finished the job and can clean everything up.</p><p>If we need to remove an <a id="id705" class="indexterm"/>
<a id="id706" class="indexterm"/>image, we call <code class="literal">PKFILE.removeFile</code> with the full path to the image. We also pass along our current method to the<a id="id707" class="indexterm"/> <code class="literal">success</code> function. This means that once the image is successfully deleted, we'll be called again to repeat the process until we've deleted all images in the <code class="literal">selectedImages</code> array. The process will only stop when a failure occurs or when the <code class="literal">selectedImages</code> array is empty.</p><p>When the <code class="literal">selectedImages</code> array is empty, we need to clean things up. We clear the alert we created when starting the deletion process, and we reload all our available documents.</p><p>With all this talk about reloading the document listing, perhaps we should go into that a bit:</p><div><pre class="programlisting">  documentsView.documentIterator = function(o)
  {</pre></div><p>The first portion of this function is identical to previous projects, so we'll skip ahead to the interesting bits in the following code snippet:</p><div><pre class="programlisting">    PKUTIL.delay(100, function()
    {
      for (var i = 0; i &lt; theNumberOfDocuments; i++)
      {
        var theDocumentEntry = o.getDocumentAtIndex(i);
        var theElement = $ge("documentsView_item" + i + "");
        var theLPGesture = new GESTURES.LongPressGesture(theElement, function(o)
        {
          documentsView.longPressReceived(o.data);
        });
        theLPGesture.data = i;</pre></div><p>Just like in our last project, we <a id="id708" class="indexterm"/>
<a id="id709" class="indexterm"/>have a long press gesture attached to each image. When a long press is received, we'll display a menu allowing the user to delete, copy, or rename the image.</p><p>The more interesting bit is this next part, where we actually render the image's thumbnail onto each <code class="literal">canvas</code>:</p><div><pre class="programlisting">        var img = new Image();
        img.i = i;</pre></div><p>First, for each available document, we create a new <code class="literal">Image</code> object. We assign an <code class="literal">index</code> to a property of the object as well, because we'll need it later when the image is finished loading.</p><div><pre class="programlisting">        img.onload = function ()
        {</pre></div><p>We then attach a method to the <code class="literal">onload</code> event of the image. This is where we'll render the image to the canvas.</p><div><pre class="programlisting">          var newWidth = 84;
          var newHeight = (this.height / this.width) * 84;
          if (newHeight &gt; 84)
          {
            newHeight = 84;
            newWidth = (this.width / this.height) * 84;
          }</pre></div><p>The first thing we do after the image is loaded is to determine the size of the thumbnail. Since we want to maintain the aspect ratio, we have to know the image's width and height, something we can do by using <code class="literal">this.height</code> and <code class="literal">this.width</code>. First we assume the image will fit into a width of <code class="literal">84</code> pixels, and determine the height using the ratio of the height to the width. But on some images this might result in them being taller than <code class="literal">84</code> pixels, and so we redo the calculation for these images based on a height of <code class="literal">84</code> pixels.</p><div><pre class="programlisting">          var newLeft = 42 - (newWidth/2);
          var newTop = 42 - (newHeight/2);</pre></div><p>Once the thumbnail's width and height are determined, we can figure out the top and left so that the image is nicely centered within its 84 x 84 container.</p><div><pre class="programlisting">          var theCanvas = $ge("documentsView_item" + this.i + "_canvas");
          theCanvas.setAttribute ("width", newWidth * window.devicePixelRatio);
          theCanvas.setAttribute ("height",newHeight * window.devicePixelRatio);
          theCanvas.style.width = ""+newWidth+"px"; theCanvas.style.height = ""+newHeight+"px";
          theCanvas.style.left  = ""+newLeft +"px"; theCanvas.style.top = ""+newTop+"px";</pre></div><p>Next, we obtain the <a id="id710" class="indexterm"/>
<a id="id711" class="indexterm"/>canvas and set its width and height to the newly calculated values. Notice that we set both the CSS and the HTML width and height; this is important because the size of the canvas may actually be different on displays with different pixel ratios. (On a retina display the canvas is actually twice as large, but the CSS compresses it back to the original size visually.)</p><div><pre class="programlisting">          var theCanvasCtx = theCanvas.getContext("2d");
          theCanvasCtx.save();
          theCanvasCtx.scale (window.devicePixelRatio, window.devicePixelRatio);
          theCanvasCtx.imageSmoothingEnabled = false;</pre></div><p>Next, we obtain a context from the canvas. We then scale the canvas to the pixel ratio so that we can continue to use point-based pixels on devices where each point is more than one pixel. Then we turn off image smoothing; this is to help speed up the next line:</p><div><pre class="programlisting">          theCanvasCtx.drawImage (this, 0, 0, newWidth, newHeight);</pre></div><p>This line physically draws the image to the canvas at the size we calculated earlier. Once done, we will have a nice thumbnail instead of an empty canvas.</p><p>This operation isn't free, however; it takes time to draw the image to a smaller scale, but we only have to do this once (whenever we load the available documents). If we had used <code class="literal">IMG</code> tags for all our thumbnails, this would have had to be done every time something changed on the view, which would be so slow as to be unusable.</p><div><pre class="programlisting">          theCanvasCtx.restore();
        }
        img.src = theDocumentEntry.fullPath;
      }
    });
  }</pre></div><p>Finally, we set the image's source. This triggers loading of the image, which will trigger the image's <code class="literal">onload()</code> method<a id="id712" class="indexterm"/> when finished. This operation isn't free either, but again, it only happens whenever we load the list of documents.</p><p>The rest of the view's code is very similar, if not identical, to prior projects, so we won't go over that code again.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec127"/>What did we do?</h2></div></div></div><p>We've touched on <a id="id713" class="indexterm"/>
<a id="id714" class="indexterm"/>quite a bit of stuff in this task. We created code that can take and import pictures, we worked with the HTML5 <code class="literal">canvas</code> tags, and we started working with a <code class="literal">FILE</code> API wrapper that makes working with files just a bit easier.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec128"/>What else do I need to know?</h2></div></div></div><p>We mentioned that we would discuss the <code class="literal">FILE</code> API wrapper a bit more, and here's as good a place as any.</p><p>Think of <code class="literal">PKFILE</code> as a convenience wrapper that makes working with files somewhat easier. It doesn't take away the asynchronous nature, but it does encapsulate some of the operations that a file operation typically has to do, getting the file system especially. It also gives us the ability to add in some shortcuts for referencing persistent and temporary storage.</p><p>Let's cover that last part first. Any filename that contains one of the following automatically gets translated to the system-specific value:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">doc://</code> is translated to <code class="literal">/path/to/app/persistent/storage/</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tmp://</code> is translated to <code class="literal">/path/to/app/temporary/stora</code><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">lhost</code> is replaced with <code class="literal">""</code>; the <code class="literal">FILE</code> APIs can't handle a path starting with this.</li></ul></div><p>Because <code class="literal">PKFILE</code> will translate these values in any path or filename for every method, we no longer have to worry about obtaining the file systems for ourselves. This cuts out at least one callback chain and simplifies how we refer to files within our own app's storage. For example, we can refer to <code class="literal">doc://photo.jpg</code> instead of something like <code class="literal">/var/something/somethingelse/app/Documents/photo.jpg</code>.</p><p>Each method in <code class="literal">PKFILE</code> takes some combination of filenames, and <code class="literal">success</code> and <code class="literal">failure</code> parameters. The <code class="literal">failure</code> functions are always passed an object that indicates the reason for failure. The <code class="literal">success</code> functions aren't passed any parameters.</p><p>We won't go <a id="id715" class="indexterm"/>
<a id="id716" class="indexterm"/>over the code for the wrapper, mainly because it isn't really anything you haven't seen before. If you want to take a look, it is located in <code class="literal">framework/fileutil.js</code> in the files available for this project.</p></li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec58"/>Implementing the image view</h1></div></div></div><p>The image view itself is very <a id="id717" class="indexterm"/>
<a id="id718" class="indexterm"/>simple: all it does is display a single image along with two icons in the toolbar (<strong>Delete</strong> and <strong>Share</strong>). Here's how our view will look, first for iOS:</p><div><img src="img/9403_06_05.jpg" alt="Implementing the image view"/></div><p>For Android, the<a id="id719" class="indexterm"/>
<a id="id720" class="indexterm"/> view is as follows:</p><div><img src="img/9403_06_06.jpg" alt="Implementing the image view"/></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec129"/>Getting ready</h2></div></div></div><p>If you want to follow along, the code is in <code class="literal">www/views/imageView.js</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec130"/>Getting on with it</h2></div></div></div><p>Typically we'd start with the HTML for the view, but this is very similar to the previous project. Instead we'll start with the template used to display the image:</p><div><pre class="programlisting">&lt;div id="imageView_documentTemplate" class="hidden"&gt;
  &lt;img src="img/%SRC%" width=100% /&gt;
&lt;/div&gt;</pre></div><p>This is probably the simplest <a id="id721" class="indexterm"/>
<a id="id722" class="indexterm"/>template we've ever had. It is literally just an image with a specified width. The height will be inferred from the aspect ratio of the image.</p><p>Like the template, the code is going to very simple as well:</p><div><pre class="programlisting">  var imageView = $ge("imageView") || {};
  imageView.imagePath = "";
  imageView.imageIndex = -1;
  imageView.setImage = function ( imagePath, imageIndex )
  {
    imageView.imagePath = imagePath;
    imageView.imageIndex = imageIndex;
    
    $ge("imageView_contentArea").innerHTML =
      PKUTIL.instanceOfTemplate($ge("imageView_documentTemplate"),
      { "src" : imageView.imagePath        });
  }</pre></div><p>We store two items: the path to the image and the index of the image. We also provide a method called <code class="literal">setImage</code> <a id="id723" class="indexterm"/>that others can use to tell us which image to load. Once called, we replace the content area with the image data.</p><p>Our view also supports <a id="id724" class="indexterm"/>
<a id="id725" class="indexterm"/>deleting the picture being viewed. Here's how that is handled:</p><div><pre class="programlisting">  imageView.confirmDeletePictures = function ()
  {
    var anAlert = new PKUI.MESSAGE.Confirm(__T("Delete Image"), __T("This will delete the selected image.This action is unrecoverable."), __T("Don't Delete&lt;|Delete*"), function(i)
    {
      if (i == 1)
      {
        PKUTIL.delay ( 100, imageView.deleteSelectedPicture );
      }
    });
    anAlert.show();
  }
  
  imageView.deleteSelectedPicture = function ()
  {
    PKFILE.removeFile ( imageView.imagePath,
    function ()
      {
        PKUTIL.delay(100, function() { PKUI.CORE.popView(); } );
        documentsView.reloadAvailableDocuments();
        
        },
      function (e)
      {
        var anAlert = new PKUI.MESSAGE.Alert (__T("Oops!"), __T("Failed to remove file."));
        anAlert.show();
        documentsView.reloadAvailableDocuments();
      }
      );
  }</pre></div><p>We first ask the user if they are sure, and if so, we will remove the file via <code class="literal">PKFILE.removeFile()</code>. Once removed, we pop ourselves off the view stack because it doesn't make a lot of sense to be viewing an image that is now deleted. We also tell the <code class="literal">documentsView</code> to reload its documents, seeing as we've modified the file system.</p><div><pre class="programlisting">  imageView.viewDidHide = function ()
  {
    $ge("imageView_contentArea").innerHTML = "";
  }</pre></div><p>There's one last method to cover, and that's the <code class="literal">viewDidHide()</code> method<a id="id726" class="indexterm"/> seen in the preceding code snippet. All we do here is clear out the content area so that when the image view is not being displayed, no image is sitting there hidden and taking up the memory. It also means the next time the view is displayed, there isn't an <a id="id727" class="indexterm"/>
<a id="id728" class="indexterm"/>odd transition where the last loaded image is visible for a couple moments before the new one is loaded. (Remember, we wait a few milliseconds before loading in a new picture to ensure a smooth transition.)</p></div><div><div><div><div><h2 class="title"><a id="ch06lvl2sec131"/>What did we do?</h2></div></div></div><p>In this task, we implemented the image view, handled loading the image, and also handled deleting the image.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec59"/>Game Over..... Wrapping it up</h1></div></div></div><p>Well, that wasn't terribly hard, was it? We have been able to take pictures using the in-built camera, and we've also been able to import images directly from the user's photo library. We've worked with displaying thumbnails via the HTML5 <code class="literal">canvas</code> tag to improve performance as well. Finally, we have worked a little with a <code class="literal">FILE</code> API wrapper to help make our code simpler to write.</p></div>
<div><div><div><div><h1 class="title"><a id="ch06lvl1sec60"/>Can you take the HEAT? The Hotshot Challenge</h1></div></div></div><p>There's a lot that could be done to improve the project as it stands now. Why don't you try a few?</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add sharing capabilities to the app. Be careful to deal with batch sharing multiple images, too.</li><li class="listitem" style="list-style-type: disc">Add filters to the images so that they can be converted to black and white, sepia, and more. If you want to save the files, you'll need to write a native plugin to save the data returned from the canvas.</li><li class="listitem" style="list-style-type: disc">Speed things up a bit by generating a thumbnail from each image if it doesn't already have one. You could store the thumbnail in local storage if you wanted, it wouldn't be very big, or use the <code class="literal">File</code> API to store it.</li></ul></div></div></body></html>