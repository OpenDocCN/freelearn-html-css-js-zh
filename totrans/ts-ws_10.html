<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-182">9. <a id="_idTextAnchor220"/>Generics and Conditional Types</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces generics and conditional types. This chapter first teaches you about what generics are, and some basic generics usage in different contexts – interfaces, classes, functions, and so on. Next, you'll learn about generic constraints, and how to make your code more type-safe while using generics, to avoid errors at runtime. Lastly, you'll learn about conditional types and how they make generics even more powerful by introducing type-level <em class="italic">logic</em> at compile time.</p>
			<p class="callout">By the end of this chapter, you will be able to apply generics to real-world use cases. </p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor221"/>Introduction</h1>
			<p>In the previous chapter, we saw how we can use dependency injection in TypeScript. In this chapter, we'll cover two of the more advanced features that TypeScript's type system offers, useful mostly in advanced applications or when building libraries – generics and conditional types.</p>
			<p>TypeScript includes a very strong type system that covers a lot of use cases and advanced types. In earlier chapters, we saw some of the more basic ways in which you can utilize the type system while building applications.</p>
			<p>Generics are one of the building blocks of many languages, such as Java, C#, Rust, and of course TypeScript, and they aim to allow developers to write dynamic and reuseable <em class="italic">generic</em> pieces of code with types that are <em class="italic">unknown</em> when writing the code but will be specified later, when using these generic pieces of code. In other words, generics are a sort of "placeholder" when the concrete type isn't known at the time of creating an application.</p>
			<p>For example, if you want to write a generic <em class="italic">List</em> data structure, the implementation is the same for whatever type of item it may store, but the actual type of item is <em class="italic">unknown</em> when writing the <em class="italic">List</em> class. We can then use generics as a sort of a "placeholder" type when writing it, and the user of the <em class="italic">List </em>class will specify it when they know the concrete type it'll use, thereby filling in this "placeholder."</p>
			<p>Conditional types allow us to bring <em class="italic">logic</em> into TypeScript's type system, which will be checked at <em class="italic">compile time</em>. This means that our types can be safer, and we can make code stricter, and move some of our logic from runtime to compile time, which means that less code needs to run on the server or in the user's browser. Additionally, conditional types allow us to write more complex types, with more complex relations between them. </p>
			<p>For example, if we want to remove some options from a string literal union, we can use the <code>Extract</code> type to only take some of them:</p>
			<pre>type Only FooAndBar = Extract&lt;"foo" | "bar" | "baz", "foo" | "bar"&gt;;  // "foo" | "bar"</pre>
			<p>While not restricted to usage with generic types, conditional types are usually used in these cases, since you want to write some logic on a type unknown and ahead of time, because otherwise, you could write it explicitly yourself.</p>
			<p>In this chapter, we'll explore both generics and conditional types and see how they can make your code more robust, resilient to changes, and offer a better developer experience when used externally.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor222"/>Generics</h1>
			<p>As mentioned, generics help us write code that has types that are unknown when writing it but will be known later on, when someone uses the code. They allow us to put "placeholders" where concrete types would've been used otherwise, and for these placeholders to be filled in later, by the user of our code. Generics allow us to write a code once, and use it for multiple <strong class="bold">types</strong>, without losing type-safety along the way, or even increasing the type-safety in comparison to what we can achieve without it.</p>
			<p>Let's see how generics help us with typing things more correctly, starting with a very basic function—<code>identity</code>:</p>
			<pre>// identity.ts
function identity(x: number): number {
    return x;
}</pre>
			<p>The <code>identity</code> function takes in a <code>number</code>, <code>x</code>, and just returns <code>x</code>. Now, let's say we want the same functionality for strings too:</p>
			<pre>// identityString.ts
function identityString(x: string) {
    return x;
}</pre>
			<p>Since type information is just for compile time, the two functions are the exact same in the compiled JavaScript output:</p>
			<pre>// identity.js
function identity(x) {
    return x;
}
// identityString.js
function identityString(x) {
    return x;
}</pre>
			<p>Since the output JavaScript code is the same and given that TypeScript only adds types on top of existing JavaScript, there's a way to type this existing <code>identity</code> function such that it'll support both use cases. We can type <code>identity</code> in multiple ways – the most simple way is to type <code>x</code> as <code>any</code>. However, this means we lose type-safety inside the function, not to mention in the <code>return</code> type:</p>
			<pre>function identity(x: any): any {
    return x;
}
const result = identity('foo');
result.toFixed();</pre>
			<p>This is probably not what we want. Since <code>result</code> is of type <code>any</code>, TypeScript cannot know that <code>result.toFixed()</code> in the preceding code will throw an error at runtime (since strings don't have a <code>toFixed()</code> method):</p>
			<div><div><img src="img/B14508_09_01.jpg" alt="Figure 9.1: Running this code results in a TypeError at runtime&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1: Running this code results in a TypeError at runtime</p>
			<p>Instead, we can leverage generics – we'll type <code>x</code> as a generic type <code>T</code>, and return the same type from the function. Consider the following code:</p>
			<pre>function identity&lt;T&gt;(x: T): T {
	return x;
}</pre>
			<p>In TypeScript, generics are written using angled brackets, and a placeholder type name between them. In the preceding code, <code>T</code> is generic and serves as a "placeholder." Now if we update the code with the following details, we will get a compile-time error as shown here (red underline):</p>
			<div><div><img src="img/B14508_09_02.jpg" alt="Figure 9.2: Compile-time error due to generics being used&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2: Compile-time error due to generics being used</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The placeholder type name can be anything, and its name is only useful for the developer using the code – so try to give generic types useful names that have meaning in the context they're used in.</p>
			<p>Note that we only have a single function (identity) implementation that can be used with both strings and numbers. TypeScript also knows the return type automatically and can provide useful errors at compile time. Moreover, we can pass any other type to the <code>identity</code> function, without the need to modify it at all.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We didn't even have to tell TypeScript what the type of the generic is when calling <code>identity()</code>. TypeScript can usually infer the type of the generic(s) itself from the arguments.</p>
			<p class="callout">Usually, having to manually specify the type of the generic when calling a function is a code smell (a sign that the underlying code might contain a bigger problem), when it can be inferred from the arguments (though there are exceptions to this).</p>
			<p>Generics come in all sorts of forms—from functions like we just saw, to interfaces, types, and classes. They all behave the same, just in their own scope—so function generics are only applicable for that function, while class generics are for that class's instance, and can also be used inside its methods/properties. In the next sections, we'll explore each of these types of generics.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor223"/>Generic Interfaces</h2>
			<p>Generic interfaces are interfaces that have some additional type, not previously known to the author of the interface, "attached" to them. This additional type gives "context" to the interface and allows better type-safety when using it.</p>
			<p>In fact, if you've used TypeScript in the past, you've probably already interacted with generics, maybe without even realizing it. They are at play everywhere—just take a look at this basic line of code:</p>
			<pre>const arr = [1, 2, 3];</pre>
			<p>If you hover over <code>arr</code>, you'll see it's of type <code>number[]</code>:</p>
			<div><div><img src="img/B14508_09_03.jpg" alt="Figure 9.3: The type of arr is inferred to be number[]&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3: The type of <code>arr</code> is inferred to be <code>number[]</code></p>
			<p><code>number[]</code> is just a shorter syntax for <code>Array&lt;number&gt; </code>—generics at play again.</p>
			<p>In arrays, generics are used for the type of elements that the array holds. Without generics, <code>Array</code> would have to be typed with <code>any</code> all over the place or have a separate <code>interface</code> for every type possible (including non-built-in ones, so that's out of the question).</p>
			<p>Let's take a look at the <code>Array&lt;T&gt;</code> interface definition:</p>
			<div><div><img src="img/B14508_09_04.jpg" alt="Figure 9.4: Some of the Array&lt;T&gt; interface, where generics are heavily used&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4: Some of the Array&lt;T&gt; interface, where generics are heavily used</p>
			<p>As you can see, the <code>pop</code>, <code>push</code>, and <code>concat</code> methods all use the <code>T</code> generic type to know what they return, or what they can accept as arguments. This is why the following code doesn't compile:</p>
			<div><div><img src="img/B14508_09_05.jpg" alt="Figure 9.5: An error when trying to push an incompatible type to an array with &#13;&#10;a specific generic type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5: An error when trying to push an incompatible type to an array with a specific generic type</p>
			<p>This is also how TypeScript can infer the type of the <code>value</code> in the callback for <code>map</code>, <code>filter</code>, and <code>forEach</code>:</p>
			<div><div><img src="img/B14508_09_06.jpg" alt="Figure 9.6: Type inference when using the map method of Array&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6: Type inference when using the <code>map</code> method of <code>Array</code></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor224"/>Generic Types</h2>
			<p>Generics can be used on plain types, for example, to create a <code>Dictionary&lt;V&gt;</code> type, and also to describe a map between strings of any values of type <code>V</code>, which is unknown ahead of time, and therefore <em class="italic">generic</em>:</p>
			<pre>type Dictionary&lt;V&gt; = Record&lt;string, V&gt;;</pre>
			<p>There are more use cases for generic types, but mostly you'll either be using them together with generic constraints (explained later in this chapter) or describing them with interf<a id="_idTextAnchor225"/><a id="_idTextAnchor226"/>aces (though mostly anything that an <code>interface</code> can do, a <code>type</code> can as well).</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor227"/>Generic Classes</h2>
			<p>Generics are also very useful for classes. As we've seen earlier in the chapter, the built-in <code>Array</code> class uses generics. These generics are specified at the class's definition and apply to that instance of the class. Properties and methods of the class can then utilize that generic type for their own definitions.</p>
			<p>For example, let's create a simple <code>Box&lt;T&gt;</code> class that holds a value of any type <code>T</code> and allows retrieving it later:</p>
			<pre>class Box&lt;T&gt;  {
    private _value: T;
    constructor(value: T) {
        this._value = value
    }
    get value(): T {
        return this.value;
    }
}</pre>
			<p>The <code>_value</code> property, the <code>constructor</code>, and the <code>value</code> getter use the <code>T</code> generic type from the class's definition for their own types. This type could also be used for other methods in this class if there were any.</p>
			<p>Additionally, methods of the class can add their own generics, which will only apply to that method's scope – for example, if we wanted to add a <code>map</code> method to the <code>Box</code> class, we could type it like so:</p>
			<pre>class Box&lt;T&gt;  {
    ...
    map&lt;U&gt;(mapper: (value: T) =&gt; U): U {
        return mapper(this.value)
    }
}</pre>
			<p>The <code>U</code> generic type can be used inside the <code>map</code> method declaration, as well as within its implementation, but it cannot be used in other class members (like the <code>value</code> getter from earlier), unlike <code>T</code> – which is scoped to the entire class.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor228"/>Exercise 9.01: Generic Set class</h1>
			<p>In this exercise, we'll create a <code>Set&lt;T&gt;</code> class that implements that <code>Set</code> data structure – a data structure that can hold items, without a specific order, and without duplications, using generics.</p>
			<p>Follow these steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/R336a">https://packt.link/R336a</a>.</p>
			<ol>
				<li>Start by creating a <code>Set</code> class that has a generic <code>T</code> type. This type will be the type of the items in the set:<pre>class Set&lt;T&gt; {
}</pre></li>
				<li>Next, let's add a constructor that takes some optional initial values. These will need to be an array with items of type <code>T</code>, to match our <code>Set</code> items:<pre>class Set&lt;T&gt; {
  private items: T[];
  constructor(initialItems: T[] = []) {
    this.items = initialItems;
  }
}</pre><p>We use default parameters to initialize <code>initialItems</code> with an empty array if we haven't been supplied with one – this makes this parameter optional, while still making it convenient to work with inside our constructor implementation.</p></li>
				<li>Let's add the <code>size</code> getter, which returns the size of the set. This will simply be our <code>items</code> length:<pre>class Set&lt;T&gt; {
  private items: T[];
  //...
  get size(): number {
    return this.items.length;
  }
}</pre></li>
				<li>Next, let's add a <code>has</code> method, which checks whether a given item is already in the set:<pre>class Set&lt;T&gt; {
  private items: T[];
  //...
  has(item: T): boolean {
    return this.items.includes(item);
  }
}</pre><p>Notice that we use the <code>T</code> type in the <code>has</code> definition – we can use it since it's in the scope of the class, where <code>T</code> was declared.</p></li>
				<li>Lastly, we also need a way to add and remove items from our set – let's add those:<pre>class Set&lt;T&gt; {
  ...
  add(item: T): void {
    if (!this.has(item)) {
      this.items.push(item);
    }
  }
  remove(item: T): void {
    const itemIndex = this.items.indexOf(item);
    if (itemIndex &gt;= 0) {
      this.items.splice(itemIndex, 1);
    }
  }
}</pre><p>For the <code>add</code> method, we first check whether the given <code>item</code> already exists, and if not, add it.</p><p>For the <code>remove</code> method, we look for the index of the given item. If it exists, we remove it from the array.</p></li>
				<li>Now, write the following two lines of code:<pre>const set = new Set &lt;number&gt;([1,2,3]);  
set.add(1) // works – since 1 is a number
set.add('hello') //Error – since 'hello' is not a number</pre><p>On your IDE, you will see the following:</p><div><img src="img/B14508_09_07.jpg" alt="Figure 9.7: Type-safety in the Set class because of generics&#13;&#10;"/></div><p class="figure-caption">Figure 9.7: Type-safety in the Set class because of generics</p><p>We can see how the <code>Set</code> class can be used, and how it keeps itself type-safe, not allowing items of multiple types to be mixed together in the same class, for instance, in the following <em class="italic">step 7</em>.</p></li>
				<li>Lastly, if you go back to the <code>Set</code> class implementation, you'll notice that the type of <code>items</code> within the class is <code>T[]</code>, so if we tried to add an item that TypeScript doesn't know is of type <code>T</code> to the <code>items</code> array, we'd get an error:</li>
			</ol>
			<div><div><img src="img/B14508_09_08.jpg" alt="Figure 9.8: Type-safety in the Set class because of generics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8: Type-safety in the Set class because of generics</p>
			<p>This is expected, since <code>T</code> can be of any type, and not just a string – as we saw in the preceding example where we created a <code>Set&lt;number&gt;</code> – a set that can only hold numbers.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor229"/>Generic Functions</h2>
			<p>We've already briefly seen generic functions at the beginning of this chapter with the <code>identity&lt;T&gt;()</code> function. But let's look at a more real-world, more useful use case—say you want to write a wrapper around <code>fetch()</code> for fetching JSON data, such that users won't have to call <code>.json()</code> on the response. Consider the following code:</p>
			<pre>interface FetchResponse {
	status: number;
	headers: Headers;
	data: any;
}
async function fetchJson(url: string): Promise&lt;FetchResponse&gt; {
	const response = await fetch(url);
	return {
		headers: response.headers,
		status: response.status,
		data: await response.json(),
	};
}</pre>
			<p>Here, we use the browser's <code>fetch</code> function to make a <code>GET</code> call to the given <code>url</code> and then return an object with the main parts of the response – the <code>headers</code>, the status code (<code>status</code>), and the body, after parsing it as JSON (<code>data</code>).</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><code>fetch()</code> is not part of ECMAScript and is therefore not part of the language. It's available natively in all modern browsers and can be used in Node.js via packages such as <code>node-fetch</code>, <code>isomorphic-fetch</code>, and others.</p>
			<p>The <code>json()</code> method returns <code>Promise&lt;any&gt;</code>. This means that the following code <em class="italic">may</em> throw at runtime, if the returned object doesn't have a <code>title</code> property, or it isn't of type <code>string</code>:</p>
			<pre>	const { data } = await fetchJson('https://jsonplaceholder.typicode.com/todos/1');
	console.log(data.title.toUpperCase()); // does data have a title property? What type is it?..</pre>
			<p>It would be useful if a consumer calling the <code>fetchJson</code> function could know what the type of <code>data</code> is. For that, we could add a generic type to the <code>fetchJson</code> function, which we'd also need to indicate in the return type somehow – that's where <code>interface</code> and <code>type</code> generics come in again. Consider the following code of <code>fetchJson.ts</code>:</p>
			<pre>// fetchJson.ts
interface FetchResponse&lt;T&gt; {
    status: number;
    headers: Headers;
    data: T;
}
async function fetchJson&lt;T&gt;(url: string): Promise&lt;FetchResponse&lt;T&gt;&gt; {
    const response = await fetch(url);
    return {
        headers: response.headers,
        status: response.status,
        data: await response.json(),
    };
}</pre>
			<p>This is very similar to the first declaration of <code>fetchJson</code> seen previously. Actually, the resulting JavaScript is exactly the same. However, this declaration now uses generics to allow the users of the function to specify the return type expected from making the <code>GET</code> call.</p>
			<p>Now consider the code of <code>usage.ts</code>:</p>
			<pre>// usage.ts
(async () =&gt; {
    interface Todo {
        userId: number;
        id: number;
        title: string;
        completed: boolean;
    }
    const { data } = await fetchJson&lt;Todo&gt;('https://jsonplaceholder.typicode.com/todos/1');
    console.log(data.title); // ✅ title is of type 'string'
    console.log(data.doesntExist); // ❌ 'doesntExist' doesn't compile
})();</pre>
			<p>Here, we allow the user to pass in a <code>T</code> generic type to <code>fetchJson&lt;T&gt;()</code>, which the function declaration later passes to the <code>FetchResponse&lt;T&gt;</code> interface, tying things together.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Just like interfaces, generics only exist at compile time. So, anything you write there is as safe as you make the compiler understand it to be. For example, if you were to type <code>Todo</code> differently, or pass a different type, then the actual result – there is no guard built into TypeScript to verify it at runtime (without user/library code – see user type guard in <em class="italic">Chapter 5</em>, <em class="italic">Inheritance and Interfaces</em>).</p>
			<p>Note that in the preceding example, the <code>T</code> generic is a <em class="italic">convenience generic</em>—it's only there for the user's convenience—it's only used once, and doesn't offer any more type-safety than a simple type assertion would:</p>
			<pre>const response = await fetchJson('https://jsonplaceholder.typicode.com/todos/1');
const todo = response.data as Todo;</pre>
			<p>Note that generics, just like variables, have scopes, and you can define generics at multiple levels, letting the user provide them as needed. For example, notice how we use the <code>T</code> generic type that's declared in the <code>map</code> function, in our inner function (in line 2 in the following snippet):</p>
			<pre>function map&lt;T, U&gt;(fn: (item: T) =&gt; U) {
    return (items: T[]) =&gt; {
        return items.map(fn);
    };
}
const multiplier = map((x: number) =&gt; x * 2);
const multiplied = multiplier([1, 2, 3]); // returns: [2, 4, 6]</pre>
			<p>This applies to things such as interfaces and classes too. In the <code>Array&lt;T&gt;</code> interface, the <code>map</code> function takes an additional generic to be used as the output type, as can be seen in the <code>Array&lt;T&gt;</code> interface declaration in TypeScript:</p>
			<pre>interface Array&lt;T&gt; {
    // ...
    map&lt;U&gt;(callbackfn: (value: T, index: number, array: T[]) =&gt; U, thisArg?: any): U[];
    // ...
}</pre>
			<p>Consider the following screenshot:</p>
			<div><div><img src="img/B14508_09_09.jpg" alt="Figure 9.9: The map method of Array&lt;T&gt; has a return type inferred based on the type returned from callbackfn&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9: The map method of Array&lt;T&gt; has a return type inferred based on the type returned from callbackfn</p>
			<p>Once we add the code shown above, again, we don't need to explicitly tell TypeScript that <code>U</code> is <code>string</code> – it can <em class="italic">infer</em> it from the return type of the callback function (though we could explicitly pass it if we wanted to). The <code>map</code> method of <code>Array&lt;T&gt;</code> has a return type inferred based on the type returned from <code>callbackfn</code>. It's inferred to <code>string[]</code> in this case.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor230"/>Generic Constraints</h2>
			<p>Sometimes you want to define a generic to be constrained to some subset of types. At the beginning of this chapter, we looked at the <code>identity</code> function – there it was easy and made sense to support <em class="italic">any</em> type. But what about typing a <code>getLength</code> function – which only makes sense for arrays and strings. It doesn't make sense to accept just <em class="italic">any</em> type – what would the output of <code>getLength(true)</code> be? In order to constrain the type of values our function can accept, we can use generic constraints. Consider the following code:</p>
			<pre>function getLength&lt;T extends any[] | string&gt;(x: T): number {
	return x.length;
}</pre>
			<p>This definition <em class="italic">constrains</em> the given <code>T</code> type to be a subtype of either <code>any[]</code> (an array of anything – <code>string[]</code>, <code>number[]</code>, or any <code>Foo[]</code> would all be valid types) or a <code>string</code>. If we pass an invalid type, we get a compilation error as you can see here:</p>
			<div><div><img src="img/B14508_09_10.jpg" alt="Figure 9.10: Compile-time errors are given for invalid types when passed &#13;&#10;to the getLength function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10: Compile-time errors are given for invalid types when passed to the getLength function</p>
			<p>There are many use cases for generic constraints, and more often than not you'll want to set some of these in place when using generics, since when writing the code, you probably assume some underlying type for it. Additionally, putting generic constraints lets TypeScript narrow the possible type of the generic type, and gives you better suggestions and type-checking.</p>
			<p>For example, in a more real-world scenario, we might have some functions that return us plain dates while others return an epoch. We want to always work with dates, so we can create a function, <code>toDate</code>, that accepts these types and normalizes a <code>Date</code> function from them:</p>
			<pre>function toDate&lt;T extends Date | number&gt;(value: T) {
    if (value instanceof Date) {
        return value;
    }
    return new Date(value);
}</pre>
			<p>Here, we first check if the given value is a date. If so, we can just return it. Otherwise, we create a new <code>Date</code> function with the <code>value</code> and return that. </p>
			<p>Generic constraints are especially powerful for creating higher-order functions, where typing the incoming function can be very hard, and keeping type-safety is a big benefit for code maintainability. In the next exercise, we'll see more uses for generic constraints in a real-world application and cases where it brings better typing to our code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Higher-order functions are functions that either take in another function as an argument or return a function. We'll explore these more in <em class="italic">Chapter 12</em>, <em class="italic">Guide to Promises in TypeScript</em>.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor231"/>Exercise 9.02: The Generic memoize Function</h2>
			<p>In this exercise, we'll create a <code>memoize</code> function that, using generics, will be completely type-safe—it takes in a function and returns a function of the same type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Memoization is a way to optimize performance, by reducing the number of times something is done. A memorization function is a higher-order function that caches the results of the inner function passed to it.</p>
			<p>Follow these steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/zUx6H">https://packt.link/zUx6H</a>.</p>
			<ol>
				<li value="1">Start by implementing the naïve function definition. We'll add types later:<pre>function memoize(fn: Function, keyGetter?: (args: any[]) =&gt; string) {
    // TODO: we'll implement the function in the next steps
}</pre><p><code>memoize</code> takes in a function, <code>fn</code>, to memoize, as well as an optional <code>keyGetter</code> to serialize the arguments to a key, used for later lookups.</p></li>
				<li>Next, let's implement the function itself:<pre>function memoize(fn: Function, keyGetter?: (args: any[]) =&gt; string) {
    const cache: Record&lt;string, any&gt; = {};
    return (...args: any[]) =&gt; {
        const key = (keyGetter || JSON.stringify)(args);
        if (!(key in cache)) {
            cache[key] = fn(...args);
        }
        return cache[key];
    };
}</pre><p>In the <code>memoize</code> function, we create an empty <code>cache</code> dictionary – the keys are the serialized arguments, and the values are the results of running the <code>fn</code> function on those arguments.</p><p>We then return a function that, given some arguments, <code>args</code> will check to see if the results for running <code>fn</code> with them have already been cached. If they haven't, we run <code>fn</code> with these arguments and cache the result. Lastly, we return the value we have stored in the cache, which is either a past calculation or the one we just ran and cached. </p></li>
				<li>To test this out, we'll write an "expensive" function with one that loops for 10 seconds before adding two numbers:<pre>function expensiveCalculation(a: number, b: number) {
    const timeout = 10000;
    const start = Date.now();
    while (Date.now() &lt;= start + timeout);
    return a + b;
}</pre><p class="callout-heading">Note</p><p class="callout">Since memoization is meant to reduce the number of calls, it is usually effective in functions that take a long time to run – to illustrate this, we made <code>expensiveCalculation</code>, a function that takes a needlessly long time to run (10 seconds).</p></li>
				<li>Next's let's <code>memoize</code> it:<pre>const memoizedExpensiveCalculation = memoize(expensiveCalculation);</pre><p>Notice that the memoized version is not type-safe. It does verify that we give it a <code>function</code>, but the returned value is a very loosely typed function, which may fail at runtime or have unexpected behavior if not typed correctly – you can pass in any number of arguments to it, with any type, and it will compile fine, even though at runtime the function expects to only be called with two arguments, both of which should be of type <code>number</code>.</p><p>Here we are memoizing with the following:</p><pre>expensiveCalculation("not-a-number", 1); 
memoizedExpensiveCalculation("not-a-number", 1); </pre></li>
				<li>On your IDE, hover over the preceding two line of code. You will notice the following:<div><img src="img/B14508_09_11.jpg" alt="Figure 9.11: Message on the IDE&#13;&#10;"/></div><p class="figure-caption">Figure 9.11: Message on the IDE</p><p>As can be seen in the preceding screenshot, the memoized version of <code>expensiveCalculation</code> is not type-safe – it allows passing in a string as the first parameter, when it should only accept a number.</p></li>
				<li>Go back to the top of the file and then add generic constraints and make our <code>memoize</code> function more type-safe. First, we need to define a couple of helper types:<pre>type AnyFunction = (...args: any[]) =&gt; any;
type KeyGetter&lt;Fn extends AnyFunction&gt; = (...args: Parameters&lt;Fn&gt;) =&gt; string;</pre><p>The first type, <code>AnyFunction</code>, describes a function that takes any number of arguments and returns anything. The second type, <code>KeyGetter</code>, describes a function that takes in the parameters of the generically constrained function <code>Fn</code> and returns a string. Notice that we constrain <code>Fn</code> to be of type <code>AnyFunction</code>. This ensures that we get a function, and allows us to use the built-in <code>Parameters&lt;T&gt;</code> type, which takes in a type of a function and returns the parameters it takes.</p></li>
				<li>Next, make our <code>memoize</code> function definition more type-safe using the two types we just defined – typing both arguments in a better way:<pre>function memoize&lt;Fn extends AnyFunction&gt;(fn: Fn, keyGetter?: KeyGetter&lt;Fn&gt;) {</pre><p>Again, we constrain <code>Fn</code> to be of type <code>AnyFunction</code> to ensure we get a function, as we did before, as well as to be able to use the specific function type later, for our return type.</p><p>Now we have a more type-safe function, since <code>keyGetter</code> is now type-safe but it still doesn't return a typed function back. </p></li>
				<li>Let's fix that by also making the implementation more type-safe:<pre>function memoize&lt;Fn extends AnyFunction&gt;(fn: Fn, keyGetter?: KeyGetter&lt;Fn&gt;) {
    const cache: Record&lt;string, ReturnType&lt;Fn&gt;&gt; = {};
    return (...args: Parameters&lt;Fn&gt;) =&gt; {
        const key = (keyGetter || JSON.stringify)(args);
        if (!(key in cache)) {
            cache[key] = fn(...args);
        }
        return cache[key];
    };
}</pre><p>We use <code>ReturnType&lt;Fn&gt;</code> for the values of our cache instead of <code>any</code>. <code>ReturnType&lt;T&gt;</code> is another built-in type that types in a type of a function and returns the return type of that function. We also use the <code>Parameters&lt;T&gt;</code> type again here, to describe the function we're returning from <code>memoize</code>.</p></li>
				<li>Hover your mouse over <code>memoizedExpensiveCalculation('not-a-number')</code>. Now, our <code>memoize</code> implementation is completely type-safe, and the code that didn't cause a compile-time error in <em class="italic">step 4</em> now runs correctly:</li>
			</ol>
			<div><div><img src="img/B14508_09_12.jpg" alt="Figure 9.12: The type of memoizedExpensiveCalculation is the same as the original expensiveCalculation function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12: The type of memoizedExpensiveCalculation is the same as the original expensiveCalculation function</p>
			<p>This exercise demonstrates how generics can be used in functions and types, and how they integrate with one another. Using generics here is what allows the <code>memoize</code> function to be completely type-safe, so there is less chance of our code hitting errors during runtime.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor232"/>Generic Defaults</h2>
			<p>Sometimes, you want to <em class="italic">allow</em> for generics, but not <em class="italic">require</em> them – you want to give some sensible defaults, but allow overriding them as needed. For example, consider the following definition of an <code>Identifiable</code> interface:</p>
			<pre>interface Identifiable&lt;Id extends string | number = number&gt; {
    id: Id;
}</pre>
			<p>This can be used by other interfaces like so:</p>
			<pre>interface Person extends Identifiable&lt;number&gt; {
    name: string;
    age: number;
}
interface Car extends Identifiable&lt;string&gt; {
    make: string;
}
declare const p: Person; // typeof p.id === 'number'
declare const c: Car; // typeof c.id === 'string';</pre>
			<p>The current implementation requires every implementer of the <code>Identifiable</code> interface to specify the type of <code>Id</code> it has. But maybe we want to give some default, so you only have to specify it if you don't want that default type. Consider the following code:</p>
			<pre>interface Identifiable&lt;Id extends string | number <strong class="bold">= number</strong>&gt; {
    id: Id;
}</pre>
			<p>Notice the <code>Id</code> generic type a default type of <code>number</code>, which simplifies the code for the implementors of this interface:</p>
			<pre>interface Person extends Identifiable {
    name: string;
    age: number;
}
interface Car extends Identifiable&lt;string&gt; {
    make: string;
}</pre>
			<p>Note that now <code>Person</code> doesn't have to specify the type of <code>Id</code>, and the code is equivalent to before.</p>
			<p>Another, more real-world, scenario is with React components—each React component <em class="italic">may</em> have props and <em class="italic">may</em> have state, both of which you can specify when declaring a component (by extending React's <code>Component</code> type), but it doesn't have to have either, so there's a default <code>{}</code> given to the generic type of both:</p>
			<div><div><img src="img/B14508_09_13.jpg" alt="Figure 9.13: Partial snippet from the @types/react package&#13;&#10;"/>
				</div>
			</div>
			<pre>@types/react</strong> package</pre>
			<p>This makes React components have no props and no state by default, but these can be specified if they need either of them.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor233"/>Conditional Types</h1>
			<p>Conditional types were introduced in TypeScript 2.8 and allow complex type expressions, some of which drive some of the built-in types we saw earlier. These are really powerful, since they allow us to write <em class="italic">logic</em> inside our types. The syntax for this is <code>T extends U ? X : Y</code>. This is very similar to the regular JavaScript ternary operator, which allows for inline conditions, the only difference in the syntax is that you have to use the <code>extends</code> keyword and that this check is done at compile time and <em class="italic">not</em> runtime.</p>
			<p>This allows us to write a <code>NonNullable&lt;T&gt;</code> type:</p>
			<pre>type NonNullable&lt;T&gt; = T extends null | undefined ? never : T; </pre>
			<p>This is already built into the language, but it's driven by the same code you could write in your app.</p>
			<p>This means that you can check whether a type is nullable at compile time and change the type signature or inference based on that. An example use case for this would be an <code>isNonNullable</code> function. Consider the following code:</p>
			<pre>function isNonNullable&lt;T&gt;(x: T): x is NonNullable&lt;T&gt; {
    return x !== null &amp;&amp; x !== undefined;
}</pre>
			<p>The preceding code together with the <code>filter</code> method of <code>Array</code> can allow you to filter for relevant items. For example, consider the following definition of an array with items of mixed types:</p>
			<div><div><img src="img/B14508_09_14.jpg" alt="Figure 9.14: The type of arr is an array, where each element is either number, &#13;&#10;null, or undefined&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14: The type of arr is an array, where each element is either number, null, or undefined</p>
			<p>When we call <code>arr.filter(isNonNullable)</code>, we can get a properly typed array:</p>
			<div><div><img src="img/B14508_09_15.jpg" alt="Figure 9.15: The type of nonNullalbeArr is inferred to be number[]&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15: The type of nonNullalbeArr is inferred to be number[]</p>
			<p>Lastly, another addition to TypeScript in 2.8 was the <code>infer</code> keyword, which allows you to get help from the compiler in <em class="italic">inferring</em> the type of something, from another type. </p>
			<p>Here's a simple example:</p>
			<pre>type ArrayItem&lt;T extends any[]&gt; = T extends Array&lt;infer U&gt; ? U : never;</pre>
			<p>Here, we want to get the inner type of an array (for example, for an array of type <code>Person[]</code>, you want to get <code>Person</code>). So we check if the passed generic type <code>T extends Array&lt;infer U&gt;</code> the <code>infer</code> keyword suggests to the compiler that the compiler should try to understand what the type is, and assign that to <code>U</code>, which we then use as the return value from this conditional type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This specific example type was also possible in previous versions via <code>type ArrayItem&lt;T extends any[]&gt; = T[number]</code>.</p>
			<p>Another very useful example that was not previously possible outside of arrays was to "unbox" a type. For example, given the <code>Promise&lt;Foo&gt;</code> type, we want to get the <code>Foo</code> type back. This is now possible with the <code>infer</code> keyword. </p>
			<p>Similarly to the last example, where we extracted the array inner type, we can use the same technique for any other generic type that "boxes" another type:</p>
			<pre>type PromiseValueType&lt;T&gt; = T extends Promise&lt;any&gt; ? T : never;</pre>
			<p>This will yield the following type information on the IDE:</p>
			<div><div><img src="img/B14508_09_16.jpg" alt="Figure 9.16: The type of UnpromisedPerson is Person&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16: The type of UnpromisedPerson is Person</p>
			<p>In the next activity, we'll take a look at a more real-world use case for conditional types, as well as usage of the <code>infer</code> keyword.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor234"/>Activity 9.01: Creating a DeepPartial&lt;T&gt; Type</h2>
			<p>In this activity, we'll be using concepts learned in this chapter—generics, conditional types, and the <code>infer</code> keyword—to create a <code>DeepPartial&lt;T&gt;</code> type. This type is like the built-in <code>Partial&lt;T&gt;</code> type. But we will work recursively and make every property in the object optional, recursively.</p>
			<p>This will allow you to correctly type variables and so on so that all of their properties, at any level, can be optional. For example, a <code>REST</code> server will serve resources, and allow modifying them using a <code>PATCH</code> request, which should get a partial structure of the original resource, to modify.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/YQUex">https://packt.link/YQUex</a>.</p>
			<p>To create this type, we'll need to deal with a few cases:</p>
			<ol>
				<li value="1">Primitives – strings, numbers, and other primitives, in addition to dates, are not something we can apply <code>Partial</code> to. So <code>DeepPartial&lt;string&gt; === string</code>.</li>
				<li>For constructs like objects, <code>Array</code>, <code>Set</code>, and <code>Map</code>, we want to "reach into" the construct and apply <code>DeepPartial</code> to their values.</li>
				<li>For everything else, we want to just apply <code>Partial</code>.</li>
			</ol>
			<p>Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">Create a <code>PartialPrimitive</code> type.</li>
				<li>Define a basic <code>DeepPartial&lt;T&gt;</code> type that can handle primitives and objects at the top level.</li>
				<li>Add support for arrays by defining a <code>DeepPartialArray&lt;T&gt;</code> type and add handling for it in our <code>DeepPartial&lt;T&gt;</code> type.</li>
				<li>Add support for sets by defining a <code>DeepPartialSet&lt;T&gt;</code> type and add handling for it in our <code>DeepPartial&lt;T&gt;</code> type.</li>
				<li>Add support for maps by defining a <code>DeepPartialMap&lt;T&gt;</code> type and add handling for it in our <code>DeepPartial&lt;T&gt;</code> type.</li>
				<li>Add support for plain objects, by applying the <code>?</code> property modifier on each of their properties, and passing their values wrapped in <code>DeepReadonly</code>.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor426">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor235"/>Summary</h1>
			<p>This chapter got you started with the basics of generics and conditional types. We learned about generics in a lot of different use cases, why they are useful, as well as some extensions to their basic usage – generic defaults and conditional types. We performed a couple of exercises to show how you can include generics in your code to make it type-safe and avoid errors at runtime.</p>
			<p>Generics are useful in all kinds of applications, both frontend and backend, and are used everywhere, but especially so in libraries, where a lot of the time, you want to expose an API that leverages the applications' types, which you might not know ahead of time.</p>
			<p>In the next chapter, you'll learn about asynchronous development, some of which you encountered briefly in this chapter when typing external APIs.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>