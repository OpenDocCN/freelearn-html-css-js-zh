<html><head></head><body>
		<div>
			<div id="_idContainer107" class="Content">
			</div>
		</div>
		<div id="_idContainer108" class="Content">
			<h1 id="_idParaDest-182">9. <a id="_idTextAnchor220"/>Generics and Conditional Types</h1>
		</div>
		<div id="_idContainer125" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">This chapter introduces generics and conditional types. This chapter first teaches you about what generics are, and some basic generics usage in different contexts – interfaces, classes, functions, and so on. Next, you'll learn about generic constraints, and how to make your code more type-safe while using generics, to avoid errors at runtime. Lastly, you'll learn about conditional types and how they make generics even more powerful by introducing type-level <em class="italic">logic</em> at compile time.</p>
			<p class="callout">By the end of this chapter, you will be able to apply generics to real-world use cases. </p>
			<h1 id="_idParaDest-183"><a id="_idTextAnchor221"/>Introduction</h1>
			<p>In the previous chapter, we saw how we can use dependency injection in TypeScript. In this chapter, we'll cover two of the more advanced features that TypeScript's type system offers, useful mostly in advanced applications or when building libraries – generics and conditional types.</p>
			<p>TypeScript includes a very strong type system that covers a lot of use cases and advanced types. In earlier chapters, we saw some of the more basic ways in which you can utilize the type system while building applications.</p>
			<p>Generics are one of the building blocks of many languages, such as Java, C#, Rust, and of course TypeScript, and they aim to allow developers to write dynamic and reuseable <em class="italic">generic</em> pieces of code with types that are <em class="italic">unknown</em> when writing the code but will be specified later, when using these generic pieces of code. In other words, generics are a sort of "placeholder" when the concrete type isn't known at the time of creating an application.</p>
			<p>For example, if you want to write a generic <em class="italic">List</em> data structure, the implementation is the same for whatever type of item it may store, but the actual type of item is <em class="italic">unknown</em> when writing the <em class="italic">List</em> class. We can then use generics as a sort of a "placeholder" type when writing it, and the user of the <em class="italic">List </em>class will specify it when they know the concrete type it'll use, thereby filling in this "placeholder."</p>
			<p>Conditional types allow us to bring <em class="italic">logic</em> into TypeScript's type system, which will be checked at <em class="italic">compile time</em>. This means that our types can be safer, and we can make code stricter, and move some of our logic from runtime to compile time, which means that less code needs to run on the server or in the user's browser. Additionally, conditional types allow us to write more complex types, with more complex relations between them. </p>
			<p>For example, if we want to remove some options from a string literal union, we can use the <strong class="source-inline">Extract</strong> type to only take some of them:</p>
			<p class="source-code">type Only FooAndBar = Extract&lt;"foo" | "bar" | "baz", "foo" | "bar"&gt;;  // "foo" | "bar"</p>
			<p>While not restricted to usage with generic types, conditional types are usually used in these cases, since you want to write some logic on a type unknown and ahead of time, because otherwise, you could write it explicitly yourself.</p>
			<p>In this chapter, we'll explore both generics and conditional types and see how they can make your code more robust, resilient to changes, and offer a better developer experience when used externally.</p>
			<h1 id="_idParaDest-184"><a id="_idTextAnchor222"/>Generics</h1>
			<p>As mentioned, generics help us write code that has types that are unknown when writing it but will be known later on, when someone uses the code. They allow us to put "placeholders" where concrete types would've been used otherwise, and for these placeholders to be filled in later, by the user of our code. Generics allow us to write a code once, and use it for multiple <strong class="bold">types</strong>, without losing type-safety along the way, or even increasing the type-safety in comparison to what we can achieve without it.</p>
			<p>Let's see how generics help us with typing things more correctly, starting with a very basic function—<strong class="source-inline">identity</strong>:</p>
			<p class="source-code">// identity.ts</p>
			<p class="source-code">function identity(x: number): number {</p>
			<p class="source-code">    return x;</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">identity</strong> function takes in a <strong class="source-inline">number</strong>, <strong class="source-inline">x</strong>, and just returns <strong class="source-inline">x</strong>. Now, let's say we want the same functionality for strings too:</p>
			<p class="source-code">// identityString.ts</p>
			<p class="source-code">function identityString(x: string) {</p>
			<p class="source-code">    return x;</p>
			<p class="source-code">}</p>
			<p>Since type information is just for compile time, the two functions are the exact same in the compiled JavaScript output:</p>
			<p class="source-code">// identity.js</p>
			<p class="source-code">function identity(x) {</p>
			<p class="source-code">    return x;</p>
			<p class="source-code">}</p>
			<p class="source-code">// identityString.js</p>
			<p class="source-code">function identityString(x) {</p>
			<p class="source-code">    return x;</p>
			<p class="source-code">}</p>
			<p>Since the output JavaScript code is the same and given that TypeScript only adds types on top of existing JavaScript, there's a way to type this existing <strong class="source-inline">identity</strong> function such that it'll support both use cases. We can type <strong class="source-inline">identity</strong> in multiple ways – the most simple way is to type <strong class="source-inline">x</strong> as <strong class="source-inline">any</strong>. However, this means we lose type-safety inside the function, not to mention in the <strong class="source-inline">return</strong> type:</p>
			<p class="source-code">function identity(x: any): any {</p>
			<p class="source-code">    return x;</p>
			<p class="source-code">}</p>
			<p class="source-code">const result = identity('foo');</p>
			<p class="source-code">result.toFixed();</p>
			<p>This is probably not what we want. Since <strong class="source-inline">result</strong> is of type <strong class="source-inline">any</strong>, TypeScript cannot know that <strong class="source-inline">result.toFixed()</strong> in the preceding code will throw an error at runtime (since strings don't have a <strong class="source-inline">toFixed()</strong> method):</p>
			<div>
				<div id="_idContainer109" class="IMG---Figure">
					<img src="image/B14508_09_01.jpg" alt="Figure 9.1: Running this code results in a TypeError at runtime&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1: Running this code results in a TypeError at runtime</p>
			<p>Instead, we can leverage generics – we'll type <strong class="source-inline">x</strong> as a generic type <strong class="source-inline">T</strong>, and return the same type from the function. Consider the following code:</p>
			<p class="source-code">function identity&lt;T&gt;(x: T): T {</p>
			<p class="source-code">	return x;</p>
			<p class="source-code">}</p>
			<p>In TypeScript, generics are written using angled brackets, and a placeholder type name between them. In the preceding code, <strong class="source-inline">T</strong> is generic and serves as a "placeholder." Now if we update the code with the following details, we will get a compile-time error as shown here (red underline):</p>
			<div>
				<div id="_idContainer110" class="IMG---Figure">
					<img src="image/B14508_09_02.jpg" alt="Figure 9.2: Compile-time error due to generics being used&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2: Compile-time error due to generics being used</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The placeholder type name can be anything, and its name is only useful for the developer using the code – so try to give generic types useful names that have meaning in the context they're used in.</p>
			<p>Note that we only have a single function (identity) implementation that can be used with both strings and numbers. TypeScript also knows the return type automatically and can provide useful errors at compile time. Moreover, we can pass any other type to the <strong class="source-inline">identity</strong> function, without the need to modify it at all.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We didn't even have to tell TypeScript what the type of the generic is when calling <strong class="source-inline">identity()</strong>. TypeScript can usually infer the type of the generic(s) itself from the arguments.</p>
			<p class="callout">Usually, having to manually specify the type of the generic when calling a function is a code smell (a sign that the underlying code might contain a bigger problem), when it can be inferred from the arguments (though there are exceptions to this).</p>
			<p>Generics come in all sorts of forms—from functions like we just saw, to interfaces, types, and classes. They all behave the same, just in their own scope—so function generics are only applicable for that function, while class generics are for that class's instance, and can also be used inside its methods/properties. In the next sections, we'll explore each of these types of generics.</p>
			<h2 id="_idParaDest-185"><a id="_idTextAnchor223"/>Generic Interfaces</h2>
			<p>Generic interfaces are interfaces that have some additional type, not previously known to the author of the interface, "attached" to them. This additional type gives "context" to the interface and allows better type-safety when using it.</p>
			<p>In fact, if you've used TypeScript in the past, you've probably already interacted with generics, maybe without even realizing it. They are at play everywhere—just take a look at this basic line of code:</p>
			<p class="source-code">const arr = [1, 2, 3];</p>
			<p>If you hover over <strong class="source-inline">arr</strong>, you'll see it's of type <strong class="source-inline">number[]</strong>:</p>
			<div>
				<div id="_idContainer111" class="IMG---Figure">
					<img src="image/B14508_09_03.jpg" alt="Figure 9.3: The type of arr is inferred to be number[]&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3: The type of <strong class="source-inline">arr</strong> is inferred to be <strong class="source-inline">number[]</strong></p>
			<p><strong class="source-inline">number[]</strong> is just a shorter syntax for <strong class="source-inline">Array&lt;number&gt; </strong>—generics at play again.</p>
			<p>In arrays, generics are used for the type of elements that the array holds. Without generics, <strong class="source-inline">Array</strong> would have to be typed with <strong class="source-inline">any</strong> all over the place or have a separate <strong class="source-inline">interface</strong> for every type possible (including non-built-in ones, so that's out of the question).</p>
			<p>Let's take a look at the <strong class="source-inline">Array&lt;T&gt;</strong> interface definition:</p>
			<div>
				<div id="_idContainer112" class="IMG---Figure">
					<img src="image/B14508_09_04.jpg" alt="Figure 9.4: Some of the Array&lt;T&gt; interface, where generics are heavily used&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4: Some of the Array&lt;T&gt; interface, where generics are heavily used</p>
			<p>As you can see, the <strong class="source-inline">pop</strong>, <strong class="source-inline">push</strong>, and <strong class="source-inline">concat</strong> methods all use the <strong class="source-inline">T</strong> generic type to know what they return, or what they can accept as arguments. This is why the following code doesn't compile:</p>
			<div>
				<div id="_idContainer113" class="IMG---Figure">
					<img src="image/B14508_09_05.jpg" alt="Figure 9.5: An error when trying to push an incompatible type to an array with &#13;&#10;a specific generic type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.5: An error when trying to push an incompatible type to an array with a specific generic type</p>
			<p>This is also how TypeScript can infer the type of the <strong class="source-inline">value</strong> in the callback for <strong class="source-inline">map</strong>, <strong class="source-inline">filter</strong>, and <strong class="source-inline">forEach</strong>:</p>
			<div>
				<div id="_idContainer114" class="IMG---Figure">
					<img src="image/B14508_09_06.jpg" alt="Figure 9.6: Type inference when using the map method of Array&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6: Type inference when using the <strong class="source-inline">map</strong> method of <strong class="source-inline">Array</strong></p>
			<h2 id="_idParaDest-186"><a id="_idTextAnchor224"/>Generic Types</h2>
			<p>Generics can be used on plain types, for example, to create a <strong class="source-inline">Dictionary&lt;V&gt;</strong> type, and also to describe a map between strings of any values of type <strong class="source-inline">V</strong>, which is unknown ahead of time, and therefore <em class="italic">generic</em>:</p>
			<p class="source-code">type Dictionary&lt;V&gt; = Record&lt;string, V&gt;;</p>
			<p>There are more use cases for generic types, but mostly you'll either be using them together with generic constraints (explained later in this chapter) or describing them with interf<a id="_idTextAnchor225"/><a id="_idTextAnchor226"/>aces (though mostly anything that an <strong class="source-inline">interface</strong> can do, a <strong class="source-inline">type</strong> can as well).</p>
			<h2 id="_idParaDest-187"><a id="_idTextAnchor227"/>Generic Classes</h2>
			<p>Generics are also very useful for classes. As we've seen earlier in the chapter, the built-in <strong class="source-inline">Array</strong> class uses generics. These generics are specified at the class's definition and apply to that instance of the class. Properties and methods of the class can then utilize that generic type for their own definitions.</p>
			<p>For example, let's create a simple <strong class="source-inline">Box&lt;T&gt;</strong> class that holds a value of any type <strong class="source-inline">T</strong> and allows retrieving it later:</p>
			<p class="source-code">class Box&lt;T&gt;  {</p>
			<p class="source-code">    private _value: T;</p>
			<p class="source-code">    constructor(value: T) {</p>
			<p class="source-code">        this._value = value</p>
			<p class="source-code">    }</p>
			<p class="source-code">    get value(): T {</p>
			<p class="source-code">        return this.value;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">_value</strong> property, the <strong class="source-inline">constructor</strong>, and the <strong class="source-inline">value</strong> getter use the <strong class="source-inline">T</strong> generic type from the class's definition for their own types. This type could also be used for other methods in this class if there were any.</p>
			<p>Additionally, methods of the class can add their own generics, which will only apply to that method's scope – for example, if we wanted to add a <strong class="source-inline">map</strong> method to the <strong class="source-inline">Box</strong> class, we could type it like so:</p>
			<p class="source-code">class Box&lt;T&gt;  {</p>
			<p class="source-code">    ...</p>
			<p class="source-code">    map&lt;U&gt;(mapper: (value: T) =&gt; U): U {</p>
			<p class="source-code">        return mapper(this.value)</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">U</strong> generic type can be used inside the <strong class="source-inline">map</strong> method declaration, as well as within its implementation, but it cannot be used in other class members (like the <strong class="source-inline">value</strong> getter from earlier), unlike <strong class="source-inline">T</strong> – which is scoped to the entire class.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor228"/>Exercise 9.01: Generic Set class</h1>
			<p>In this exercise, we'll create a <strong class="source-inline">Set&lt;T&gt;</strong> class that implements that <strong class="source-inline">Set</strong> data structure – a data structure that can hold items, without a specific order, and without duplications, using generics.</p>
			<p>Follow these steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this exercise can be found here: <a href="https://packt.link/R336a">https://packt.link/R336a</a>.</p>
			<ol>
				<li>Start by creating a <strong class="source-inline">Set</strong> class that has a generic <strong class="source-inline">T</strong> type. This type will be the type of the items in the set:<p class="source-code">class Set&lt;T&gt; {</p><p class="source-code">}</p></li>
				<li>Next, let's add a constructor that takes some optional initial values. These will need to be an array with items of type <strong class="source-inline">T</strong>, to match our <strong class="source-inline">Set</strong> items:<p class="source-code">class Set&lt;T&gt; {</p><p class="source-code">  private items: T[];</p><p class="source-code">  constructor(initialItems: T[] = []) {</p><p class="source-code">    this.items = initialItems;</p><p class="source-code">  }</p><p class="source-code">}</p><p>We use default parameters to initialize <strong class="source-inline">initialItems</strong> with an empty array if we haven't been supplied with one – this makes this parameter optional, while still making it convenient to work with inside our constructor implementation.</p></li>
				<li>Let's add the <strong class="source-inline">size</strong> getter, which returns the size of the set. This will simply be our <strong class="source-inline">items</strong> length:<p class="source-code">class Set&lt;T&gt; {</p><p class="source-code">  private items: T[];</p><p class="source-code">  //...</p><p class="source-code">  get size(): number {</p><p class="source-code">    return this.items.length;</p><p class="source-code">  }</p><p class="source-code">}</p></li>
				<li>Next, let's add a <strong class="source-inline">has</strong> method, which checks whether a given item is already in the set:<p class="source-code">class Set&lt;T&gt; {</p><p class="source-code">  private items: T[];</p><p class="source-code">  //...</p><p class="source-code">  has(item: T): boolean {</p><p class="source-code">    return this.items.includes(item);</p><p class="source-code">  }</p><p class="source-code">}</p><p>Notice that we use the <strong class="source-inline">T</strong> type in the <strong class="source-inline">has</strong> definition – we can use it since it's in the scope of the class, where <strong class="source-inline">T</strong> was declared.</p></li>
				<li>Lastly, we also need a way to add and remove items from our set – let's add those:<p class="source-code">class Set&lt;T&gt; {</p><p class="source-code">  ...</p><p class="source-code">  add(item: T): void {</p><p class="source-code">    if (!this.has(item)) {</p><p class="source-code">      this.items.push(item);</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">  remove(item: T): void {</p><p class="source-code">    const itemIndex = this.items.indexOf(item);</p><p class="source-code">    if (itemIndex &gt;= 0) {</p><p class="source-code">      this.items.splice(itemIndex, 1);</p><p class="source-code">    }</p><p class="source-code">  }</p><p class="source-code">}</p><p>For the <strong class="source-inline">add</strong> method, we first check whether the given <strong class="source-inline">item</strong> already exists, and if not, add it.</p><p>For the <strong class="source-inline">remove</strong> method, we look for the index of the given item. If it exists, we remove it from the array.</p></li>
				<li>Now, write the following two lines of code:<p class="source-code">const set = new Set &lt;number&gt;([1,2,3]);  </p><p class="source-code">set.add(1) // works – since 1 is a number</p><p class="source-code">set.add('hello') //Error – since 'hello' is not a number</p><p>On your IDE, you will see the following:</p><div id="_idContainer115" class="IMG---Figure"><img src="image/B14508_09_07.jpg" alt="Figure 9.7: Type-safety in the Set class because of generics&#13;&#10;"/></div><p class="figure-caption">Figure 9.7: Type-safety in the Set class because of generics</p><p>We can see how the <strong class="source-inline">Set</strong> class can be used, and how it keeps itself type-safe, not allowing items of multiple types to be mixed together in the same class, for instance, in the following <em class="italic">step 7</em>.</p></li>
				<li>Lastly, if you go back to the <strong class="source-inline">Set</strong> class implementation, you'll notice that the type of <strong class="source-inline">items</strong> within the class is <strong class="source-inline">T[]</strong>, so if we tried to add an item that TypeScript doesn't know is of type <strong class="source-inline">T</strong> to the <strong class="source-inline">items</strong> array, we'd get an error:</li>
			</ol>
			<div>
				<div id="_idContainer116" class="IMG---Figure">
					<img src="image/B14508_09_08.jpg" alt="Figure 9.8: Type-safety in the Set class because of generics&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.8: Type-safety in the Set class because of generics</p>
			<p>This is expected, since <strong class="source-inline">T</strong> can be of any type, and not just a string – as we saw in the preceding example where we created a <strong class="source-inline">Set&lt;number&gt;</strong> – a set that can only hold numbers.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor229"/>Generic Functions</h2>
			<p>We've already briefly seen generic functions at the beginning of this chapter with the <strong class="source-inline">identity&lt;T&gt;()</strong> function. But let's look at a more real-world, more useful use case—say you want to write a wrapper around <strong class="source-inline">fetch()</strong> for fetching JSON data, such that users won't have to call <strong class="source-inline">.json()</strong> on the response. Consider the following code:</p>
			<p class="source-code">interface FetchResponse {</p>
			<p class="source-code">	status: number;</p>
			<p class="source-code">	headers: Headers;</p>
			<p class="source-code">	data: any;</p>
			<p class="source-code">}</p>
			<p class="source-code">async function fetchJson(url: string): Promise&lt;FetchResponse&gt; {</p>
			<p class="source-code">	const response = await fetch(url);</p>
			<p class="source-code">	return {</p>
			<p class="source-code">		headers: response.headers,</p>
			<p class="source-code">		status: response.status,</p>
			<p class="source-code">		data: await response.json(),</p>
			<p class="source-code">	};</p>
			<p class="source-code">}</p>
			<p>Here, we use the browser's <strong class="source-inline">fetch</strong> function to make a <strong class="source-inline">GET</strong> call to the given <strong class="source-inline">url</strong> and then return an object with the main parts of the response – the <strong class="source-inline">headers</strong>, the status code (<strong class="source-inline">status</strong>), and the body, after parsing it as JSON (<strong class="source-inline">data</strong>).</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">fetch()</strong> is not part of ECMAScript and is therefore not part of the language. It's available natively in all modern browsers and can be used in Node.js via packages such as <strong class="source-inline">node-fetch</strong>, <strong class="source-inline">isomorphic-fetch</strong>, and others.</p>
			<p>The <strong class="source-inline">json()</strong> method returns <strong class="source-inline">Promise&lt;any&gt;</strong>. This means that the following code <em class="italic">may</em> throw at runtime, if the returned object doesn't have a <strong class="source-inline">title</strong> property, or it isn't of type <strong class="source-inline">string</strong>:</p>
			<p class="source-code">	const { data } = await fetchJson('https://jsonplaceholder.typicode.com/todos/1');</p>
			<p class="source-code">	console.log(data.title.toUpperCase()); // does data have a title property? What type is it?..</p>
			<p>It would be useful if a consumer calling the <strong class="source-inline">fetchJson</strong> function could know what the type of <strong class="source-inline">data</strong> is. For that, we could add a generic type to the <strong class="source-inline">fetchJson</strong> function, which we'd also need to indicate in the return type somehow – that's where <strong class="source-inline">interface</strong> and <strong class="source-inline">type</strong> generics come in again. Consider the following code of <strong class="source-inline">fetchJson.ts</strong>:</p>
			<p class="source-code">// fetchJson.ts</p>
			<p class="source-code">interface FetchResponse&lt;T&gt; {</p>
			<p class="source-code">    status: number;</p>
			<p class="source-code">    headers: Headers;</p>
			<p class="source-code">    data: T;</p>
			<p class="source-code">}</p>
			<p class="source-code">async function fetchJson&lt;T&gt;(url: string): Promise&lt;FetchResponse&lt;T&gt;&gt; {</p>
			<p class="source-code">    const response = await fetch(url);</p>
			<p class="source-code">    return {</p>
			<p class="source-code">        headers: response.headers,</p>
			<p class="source-code">        status: response.status,</p>
			<p class="source-code">        data: await response.json(),</p>
			<p class="source-code">    };</p>
			<p class="source-code">}</p>
			<p>This is very similar to the first declaration of <strong class="source-inline">fetchJson</strong> seen previously. Actually, the resulting JavaScript is exactly the same. However, this declaration now uses generics to allow the users of the function to specify the return type expected from making the <strong class="source-inline">GET</strong> call.</p>
			<p>Now consider the code of <strong class="source-inline">usage.ts</strong>:</p>
			<p class="source-code">// usage.ts</p>
			<p class="source-code">(async () =&gt; {</p>
			<p class="source-code">    interface Todo {</p>
			<p class="source-code">        userId: number;</p>
			<p class="source-code">        id: number;</p>
			<p class="source-code">        title: string;</p>
			<p class="source-code">        completed: boolean;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    const { data } = await fetchJson&lt;Todo&gt;('https://jsonplaceholder.typicode.com/todos/1');</p>
			<p class="source-code">    console.log(data.title); // ✅ title is of type 'string'</p>
			<p class="source-code">    console.log(data.doesntExist); // ❌ 'doesntExist' doesn't compile</p>
			<p class="source-code">})();</p>
			<p>Here, we allow the user to pass in a <strong class="source-inline">T</strong> generic type to <strong class="source-inline">fetchJson&lt;T&gt;()</strong>, which the function declaration later passes to the <strong class="source-inline">FetchResponse&lt;T&gt;</strong> interface, tying things together.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Just like interfaces, generics only exist at compile time. So, anything you write there is as safe as you make the compiler understand it to be. For example, if you were to type <strong class="source-inline">Todo</strong> differently, or pass a different type, then the actual result – there is no guard built into TypeScript to verify it at runtime (without user/library code – see user type guard in <em class="italic">Chapter 5</em>, <em class="italic">Inheritance and Interfaces</em>).</p>
			<p>Note that in the preceding example, the <strong class="source-inline">T</strong> generic is a <em class="italic">convenience generic</em>—it's only there for the user's convenience—it's only used once, and doesn't offer any more type-safety than a simple type assertion would:</p>
			<p class="source-code">const response = await fetchJson('https://jsonplaceholder.typicode.com/todos/1');</p>
			<p class="source-code">const todo = response.data as Todo;</p>
			<p>Note that generics, just like variables, have scopes, and you can define generics at multiple levels, letting the user provide them as needed. For example, notice how we use the <strong class="source-inline">T</strong> generic type that's declared in the <strong class="source-inline">map</strong> function, in our inner function (in line 2 in the following snippet):</p>
			<p class="source-code">function map&lt;T, U&gt;(fn: (item: T) =&gt; U) {</p>
			<p class="source-code">    return (items: T[]) =&gt; {</p>
			<p class="source-code">        return items.map(fn);</p>
			<p class="source-code">    };</p>
			<p class="source-code">}</p>
			<p class="source-code">const multiplier = map((x: number) =&gt; x * 2);</p>
			<p class="source-code">const multiplied = multiplier([1, 2, 3]); // returns: [2, 4, 6]</p>
			<p>This applies to things such as interfaces and classes too. In the <strong class="source-inline">Array&lt;T&gt;</strong> interface, the <strong class="source-inline">map</strong> function takes an additional generic to be used as the output type, as can be seen in the <strong class="source-inline">Array&lt;T&gt;</strong> interface declaration in TypeScript:</p>
			<p class="source-code">interface Array&lt;T&gt; {</p>
			<p class="source-code">    // ...</p>
			<p class="source-code">    map&lt;U&gt;(callbackfn: (value: T, index: number, array: T[]) =&gt; U, thisArg?: any): U[];</p>
			<p class="source-code">    // ...</p>
			<p class="source-code">}</p>
			<p>Consider the following screenshot:</p>
			<div>
				<div id="_idContainer117" class="IMG---Figure">
					<img src="image/B14508_09_09.jpg" alt="Figure 9.9: The map method of Array&lt;T&gt; has a return type inferred based on the type returned from callbackfn&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9: The map method of Array&lt;T&gt; has a return type inferred based on the type returned from callbackfn</p>
			<p>Once we add the code shown above, again, we don't need to explicitly tell TypeScript that <strong class="source-inline">U</strong> is <strong class="source-inline">string</strong> – it can <em class="italic">infer</em> it from the return type of the callback function (though we could explicitly pass it if we wanted to). The <strong class="source-inline">map</strong> method of <strong class="source-inline">Array&lt;T&gt;</strong> has a return type inferred based on the type returned from <strong class="source-inline">callbackfn</strong>. It's inferred to <strong class="source-inline">string[]</strong> in this case.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor230"/>Generic Constraints</h2>
			<p>Sometimes you want to define a generic to be constrained to some subset of types. At the beginning of this chapter, we looked at the <strong class="source-inline">identity</strong> function – there it was easy and made sense to support <em class="italic">any</em> type. But what about typing a <strong class="source-inline">getLength</strong> function – which only makes sense for arrays and strings. It doesn't make sense to accept just <em class="italic">any</em> type – what would the output of <strong class="source-inline">getLength(true)</strong> be? In order to constrain the type of values our function can accept, we can use generic constraints. Consider the following code:</p>
			<p class="source-code">function getLength&lt;T extends any[] | string&gt;(x: T): number {</p>
			<p class="source-code">	return x.length;</p>
			<p class="source-code">}</p>
			<p>This definition <em class="italic">constrains</em> the given <strong class="source-inline">T</strong> type to be a subtype of either <strong class="source-inline">any[]</strong> (an array of anything – <strong class="source-inline">string[]</strong>, <strong class="source-inline">number[]</strong>, or any <strong class="source-inline">Foo[]</strong> would all be valid types) or a <strong class="source-inline">string</strong>. If we pass an invalid type, we get a compilation error as you can see here:</p>
			<div>
				<div id="_idContainer118" class="IMG---Figure">
					<img src="image/B14508_09_10.jpg" alt="Figure 9.10: Compile-time errors are given for invalid types when passed &#13;&#10;to the getLength function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.10: Compile-time errors are given for invalid types when passed to the getLength function</p>
			<p>There are many use cases for generic constraints, and more often than not you'll want to set some of these in place when using generics, since when writing the code, you probably assume some underlying type for it. Additionally, putting generic constraints lets TypeScript narrow the possible type of the generic type, and gives you better suggestions and type-checking.</p>
			<p>For example, in a more real-world scenario, we might have some functions that return us plain dates while others return an epoch. We want to always work with dates, so we can create a function, <strong class="source-inline">toDate</strong>, that accepts these types and normalizes a <strong class="source-inline">Date</strong> function from them:</p>
			<p class="source-code">function toDate&lt;T extends Date | number&gt;(value: T) {</p>
			<p class="source-code">    if (value instanceof Date) {</p>
			<p class="source-code">        return value;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return new Date(value);</p>
			<p class="source-code">}</p>
			<p>Here, we first check if the given value is a date. If so, we can just return it. Otherwise, we create a new <strong class="source-inline">Date</strong> function with the <strong class="source-inline">value</strong> and return that. </p>
			<p>Generic constraints are especially powerful for creating higher-order functions, where typing the incoming function can be very hard, and keeping type-safety is a big benefit for code maintainability. In the next exercise, we'll see more uses for generic constraints in a real-world application and cases where it brings better typing to our code.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Higher-order functions are functions that either take in another function as an argument or return a function. We'll explore these more in <em class="italic">Chapter 12</em>, <em class="italic">Guide to Promises in TypeScript</em>.</p>
			<h2 id="_idParaDest-191"><a id="_idTextAnchor231"/>Exercise 9.02: The Generic memoize Function</h2>
			<p>In this exercise, we'll create a <strong class="source-inline">memoize</strong> function that, using generics, will be completely type-safe—it takes in a function and returns a function of the same type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Memoization is a way to optimize performance, by reducing the number of times something is done. A memorization function is a higher-order function that caches the results of the inner function passed to it.</p>
			<p>Follow these steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/zUx6H">https://packt.link/zUx6H</a>.</p>
			<ol>
				<li value="1">Start by implementing the naïve function definition. We'll add types later:<p class="source-code">function memoize(fn: Function, keyGetter?: (args: any[]) =&gt; string) {</p><p class="source-code">    // TODO: we'll implement the function in the next steps</p><p class="source-code">}</p><p><strong class="source-inline">memoize</strong> takes in a function, <strong class="source-inline">fn</strong>, to memoize, as well as an optional <strong class="source-inline">keyGetter</strong> to serialize the arguments to a key, used for later lookups.</p></li>
				<li>Next, let's implement the function itself:<p class="source-code">function memoize(fn: Function, keyGetter?: (args: any[]) =&gt; string) {</p><p class="source-code">    const cache: Record&lt;string, any&gt; = {};</p><p class="source-code">    return (...args: any[]) =&gt; {</p><p class="source-code">        const key = (keyGetter || JSON.stringify)(args);</p><p class="source-code">        if (!(key in cache)) {</p><p class="source-code">            cache[key] = fn(...args);</p><p class="source-code">        }</p><p class="source-code">        return cache[key];</p><p class="source-code">    };</p><p class="source-code">}</p><p>In the <strong class="source-inline">memoize</strong> function, we create an empty <strong class="source-inline">cache</strong> dictionary – the keys are the serialized arguments, and the values are the results of running the <strong class="source-inline">fn</strong> function on those arguments.</p><p>We then return a function that, given some arguments, <strong class="source-inline">args</strong> will check to see if the results for running <strong class="source-inline">fn</strong> with them have already been cached. If they haven't, we run <strong class="source-inline">fn</strong> with these arguments and cache the result. Lastly, we return the value we have stored in the cache, which is either a past calculation or the one we just ran and cached. </p></li>
				<li>To test this out, we'll write an "expensive" function with one that loops for 10 seconds before adding two numbers:<p class="source-code">function expensiveCalculation(a: number, b: number) {</p><p class="source-code">    const timeout = 10000;</p><p class="source-code">    const start = Date.now();</p><p class="source-code">    while (Date.now() &lt;= start + timeout);</p><p class="source-code">    return a + b;</p><p class="source-code">}</p><p class="callout-heading">Note</p><p class="callout">Since memoization is meant to reduce the number of calls, it is usually effective in functions that take a long time to run – to illustrate this, we made <strong class="source-inline">expensiveCalculation</strong>, a function that takes a needlessly long time to run (10 seconds).</p></li>
				<li>Next's let's <strong class="source-inline">memoize</strong> it:<p class="source-code">const memoizedExpensiveCalculation = memoize(expensiveCalculation);</p><p>Notice that the memoized version is not type-safe. It does verify that we give it a <strong class="source-inline">function</strong>, but the returned value is a very loosely typed function, which may fail at runtime or have unexpected behavior if not typed correctly – you can pass in any number of arguments to it, with any type, and it will compile fine, even though at runtime the function expects to only be called with two arguments, both of which should be of type <strong class="source-inline">number</strong>.</p><p>Here we are memoizing with the following:</p><p class="source-code">expensiveCalculation("not-a-number", 1); </p><p class="source-code">memoizedExpensiveCalculation("not-a-number", 1); </p></li>
				<li>On your IDE, hover over the preceding two line of code. You will notice the following:<div id="_idContainer119" class="IMG---Figure"><img src="image/B14508_09_11.jpg" alt="Figure 9.11: Message on the IDE&#13;&#10;"/></div><p class="figure-caption">Figure 9.11: Message on the IDE</p><p>As can be seen in the preceding screenshot, the memoized version of <strong class="source-inline">expensiveCalculation</strong> is not type-safe – it allows passing in a string as the first parameter, when it should only accept a number.</p></li>
				<li>Go back to the top of the file and then add generic constraints and make our <strong class="source-inline">memoize</strong> function more type-safe. First, we need to define a couple of helper types:<p class="source-code">type AnyFunction = (...args: any[]) =&gt; any;</p><p class="source-code">type KeyGetter&lt;Fn extends AnyFunction&gt; = (...args: Parameters&lt;Fn&gt;) =&gt; string;</p><p>The first type, <strong class="source-inline">AnyFunction</strong>, describes a function that takes any number of arguments and returns anything. The second type, <strong class="source-inline">KeyGetter</strong>, describes a function that takes in the parameters of the generically constrained function <strong class="source-inline">Fn</strong> and returns a string. Notice that we constrain <strong class="source-inline">Fn</strong> to be of type <strong class="source-inline">AnyFunction</strong>. This ensures that we get a function, and allows us to use the built-in <strong class="source-inline">Parameters&lt;T&gt;</strong> type, which takes in a type of a function and returns the parameters it takes.</p></li>
				<li>Next, make our <strong class="source-inline">memoize</strong> function definition more type-safe using the two types we just defined – typing both arguments in a better way:<p class="source-code">function memoize&lt;Fn extends AnyFunction&gt;(fn: Fn, keyGetter?: KeyGetter&lt;Fn&gt;) {</p><p>Again, we constrain <strong class="source-inline">Fn</strong> to be of type <strong class="source-inline">AnyFunction</strong> to ensure we get a function, as we did before, as well as to be able to use the specific function type later, for our return type.</p><p>Now we have a more type-safe function, since <strong class="source-inline">keyGetter</strong> is now type-safe but it still doesn't return a typed function back. </p></li>
				<li>Let's fix that by also making the implementation more type-safe:<p class="source-code">function memoize&lt;Fn extends AnyFunction&gt;(fn: Fn, keyGetter?: KeyGetter&lt;Fn&gt;) {</p><p class="source-code">    const cache: Record&lt;string, ReturnType&lt;Fn&gt;&gt; = {};</p><p class="source-code">    return (...args: Parameters&lt;Fn&gt;) =&gt; {</p><p class="source-code">        const key = (keyGetter || JSON.stringify)(args);</p><p class="source-code">        if (!(key in cache)) {</p><p class="source-code">            cache[key] = fn(...args);</p><p class="source-code">        }</p><p class="source-code">        return cache[key];</p><p class="source-code">    };</p><p class="source-code">}</p><p>We use <strong class="source-inline">ReturnType&lt;Fn&gt;</strong> for the values of our cache instead of <strong class="source-inline">any</strong>. <strong class="source-inline">ReturnType&lt;T&gt;</strong> is another built-in type that types in a type of a function and returns the return type of that function. We also use the <strong class="source-inline">Parameters&lt;T&gt;</strong> type again here, to describe the function we're returning from <strong class="source-inline">memoize</strong>.</p></li>
				<li>Hover your mouse over <strong class="source-inline">memoizedExpensiveCalculation('not-a-number')</strong>. Now, our <strong class="source-inline">memoize</strong> implementation is completely type-safe, and the code that didn't cause a compile-time error in <em class="italic">step 4</em> now runs correctly:</li>
			</ol>
			<div>
				<div id="_idContainer120" class="IMG---Figure">
					<img src="image/B14508_09_12.jpg" alt="Figure 9.12: The type of memoizedExpensiveCalculation is the same as the original expensiveCalculation function&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12: The type of memoizedExpensiveCalculation is the same as the original expensiveCalculation function</p>
			<p>This exercise demonstrates how generics can be used in functions and types, and how they integrate with one another. Using generics here is what allows the <strong class="source-inline">memoize</strong> function to be completely type-safe, so there is less chance of our code hitting errors during runtime.</p>
			<h2 id="_idParaDest-192"><a id="_idTextAnchor232"/>Generic Defaults</h2>
			<p>Sometimes, you want to <em class="italic">allow</em> for generics, but not <em class="italic">require</em> them – you want to give some sensible defaults, but allow overriding them as needed. For example, consider the following definition of an <strong class="source-inline">Identifiable</strong> interface:</p>
			<p class="source-code">interface Identifiable&lt;Id extends string | number = number&gt; {</p>
			<p class="source-code">    id: Id;</p>
			<p class="source-code">}</p>
			<p>This can be used by other interfaces like so:</p>
			<p class="source-code">interface Person extends Identifiable&lt;number&gt; {</p>
			<p class="source-code">    name: string;</p>
			<p class="source-code">    age: number;</p>
			<p class="source-code">}</p>
			<p class="source-code">interface Car extends Identifiable&lt;string&gt; {</p>
			<p class="source-code">    make: string;</p>
			<p class="source-code">}</p>
			<p class="source-code">declare const p: Person; // typeof p.id === 'number'</p>
			<p class="source-code">declare const c: Car; // typeof c.id === 'string';</p>
			<p>The current implementation requires every implementer of the <strong class="source-inline">Identifiable</strong> interface to specify the type of <strong class="source-inline">Id</strong> it has. But maybe we want to give some default, so you only have to specify it if you don't want that default type. Consider the following code:</p>
			<p class="source-code">interface Identifiable&lt;Id extends string | number <strong class="bold">= number</strong>&gt; {</p>
			<p class="source-code">    id: Id;</p>
			<p class="source-code">}</p>
			<p>Notice the <strong class="bold">bolded</strong> code change. We give the <strong class="source-inline">Id</strong> generic type a default type of <strong class="source-inline">number</strong>, which simplifies the code for the implementors of this interface:</p>
			<p class="source-code">interface Person extends Identifiable {</p>
			<p class="source-code">    name: string;</p>
			<p class="source-code">    age: number;</p>
			<p class="source-code">}</p>
			<p class="source-code">interface Car extends Identifiable&lt;string&gt; {</p>
			<p class="source-code">    make: string;</p>
			<p class="source-code">}</p>
			<p>Note that now <strong class="source-inline">Person</strong> doesn't have to specify the type of <strong class="source-inline">Id</strong>, and the code is equivalent to before.</p>
			<p>Another, more real-world, scenario is with React components—each React component <em class="italic">may</em> have props and <em class="italic">may</em> have state, both of which you can specify when declaring a component (by extending React's <strong class="source-inline">Component</strong> type), but it doesn't have to have either, so there's a default <strong class="source-inline">{}</strong> given to the generic type of both:</p>
			<div>
				<div id="_idContainer121" class="IMG---Figure">
					<img src="image/B14508_09_13.jpg" alt="Figure 9.13: Partial snippet from the @types/react package&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13: Partial snippet from the <strong class="source-inline">@types/react</strong> package</p>
			<p>This makes React components have no props and no state by default, but these can be specified if they need either of them.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor233"/>Conditional Types</h1>
			<p>Conditional types were introduced in TypeScript 2.8 and allow complex type expressions, some of which drive some of the built-in types we saw earlier. These are really powerful, since they allow us to write <em class="italic">logic</em> inside our types. The syntax for this is <strong class="source-inline">T extends U ? X : Y</strong>. This is very similar to the regular JavaScript ternary operator, which allows for inline conditions, the only difference in the syntax is that you have to use the <strong class="source-inline">extends</strong> keyword and that this check is done at compile time and <em class="italic">not</em> runtime.</p>
			<p>This allows us to write a <strong class="source-inline">NonNullable&lt;T&gt;</strong> type:</p>
			<p class="source-code">type NonNullable&lt;T&gt; = T extends null | undefined ? never : T; </p>
			<p>This is already built into the language, but it's driven by the same code you could write in your app.</p>
			<p>This means that you can check whether a type is nullable at compile time and change the type signature or inference based on that. An example use case for this would be an <strong class="source-inline">isNonNullable</strong> function. Consider the following code:</p>
			<p class="source-code">function isNonNullable&lt;T&gt;(x: T): x is NonNullable&lt;T&gt; {</p>
			<p class="source-code">    return x !== null &amp;&amp; x !== undefined;</p>
			<p class="source-code">}</p>
			<p>The preceding code together with the <strong class="source-inline">filter</strong> method of <strong class="source-inline">Array</strong> can allow you to filter for relevant items. For example, consider the following definition of an array with items of mixed types:</p>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B14508_09_14.jpg" alt="Figure 9.14: The type of arr is an array, where each element is either number, &#13;&#10;null, or undefined&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.14: The type of arr is an array, where each element is either number, null, or undefined</p>
			<p>When we call <strong class="source-inline">arr.filter(isNonNullable)</strong>, we can get a properly typed array:</p>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B14508_09_15.jpg" alt="Figure 9.15: The type of nonNullalbeArr is inferred to be number[]&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15: The type of nonNullalbeArr is inferred to be number[]</p>
			<p>Lastly, another addition to TypeScript in 2.8 was the <strong class="source-inline">infer</strong> keyword, which allows you to get help from the compiler in <em class="italic">inferring</em> the type of something, from another type. </p>
			<p>Here's a simple example:</p>
			<p class="source-code">type ArrayItem&lt;T extends any[]&gt; = T extends Array&lt;infer U&gt; ? U : never;</p>
			<p>Here, we want to get the inner type of an array (for example, for an array of type <strong class="source-inline">Person[]</strong>, you want to get <strong class="source-inline">Person</strong>). So we check if the passed generic type <strong class="source-inline">T extends Array&lt;infer U&gt;</strong> the <strong class="source-inline">infer</strong> keyword suggests to the compiler that the compiler should try to understand what the type is, and assign that to <strong class="source-inline">U</strong>, which we then use as the return value from this conditional type.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This specific example type was also possible in previous versions via <strong class="source-inline">type ArrayItem&lt;T extends any[]&gt; = T[number]</strong>.</p>
			<p>Another very useful example that was not previously possible outside of arrays was to "unbox" a type. For example, given the <strong class="source-inline">Promise&lt;Foo&gt;</strong> type, we want to get the <strong class="source-inline">Foo</strong> type back. This is now possible with the <strong class="source-inline">infer</strong> keyword. </p>
			<p>Similarly to the last example, where we extracted the array inner type, we can use the same technique for any other generic type that "boxes" another type:</p>
			<p class="source-code">type PromiseValueType&lt;T&gt; = T extends Promise&lt;any&gt; ? T : never;</p>
			<p>This will yield the following type information on the IDE:</p>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/B14508_09_16.jpg" alt="Figure 9.16: The type of UnpromisedPerson is Person&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16: The type of UnpromisedPerson is Person</p>
			<p>In the next activity, we'll take a look at a more real-world use case for conditional types, as well as usage of the <strong class="source-inline">infer</strong> keyword.</p>
			<h2 id="_idParaDest-194"><a id="_idTextAnchor234"/>Activity 9.01: Creating a DeepPartial&lt;T&gt; Type</h2>
			<p>In this activity, we'll be using concepts learned in this chapter—generics, conditional types, and the <strong class="source-inline">infer</strong> keyword—to create a <strong class="source-inline">DeepPartial&lt;T&gt;</strong> type. This type is like the built-in <strong class="source-inline">Partial&lt;T&gt;</strong> type. But we will work recursively and make every property in the object optional, recursively.</p>
			<p>This will allow you to correctly type variables and so on so that all of their properties, at any level, can be optional. For example, a <strong class="source-inline">REST</strong> server will serve resources, and allow modifying them using a <strong class="source-inline">PATCH</strong> request, which should get a partial structure of the original resource, to modify.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code file for this activity can be found here: <a href="https://packt.link/YQUex">https://packt.link/YQUex</a>.</p>
			<p>To create this type, we'll need to deal with a few cases:</p>
			<ol>
				<li value="1">Primitives – strings, numbers, and other primitives, in addition to dates, are not something we can apply <strong class="source-inline">Partial</strong> to. So <strong class="source-inline">DeepPartial&lt;string&gt; === string</strong>.</li>
				<li>For constructs like objects, <strong class="source-inline">Array</strong>, <strong class="source-inline">Set</strong>, and <strong class="source-inline">Map</strong>, we want to "reach into" the construct and apply <strong class="source-inline">DeepPartial</strong> to their values.</li>
				<li>For everything else, we want to just apply <strong class="source-inline">Partial</strong>.</li>
			</ol>
			<p>Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">Create a <strong class="source-inline">PartialPrimitive</strong> type.</li>
				<li>Define a basic <strong class="source-inline">DeepPartial&lt;T&gt;</strong> type that can handle primitives and objects at the top level.</li>
				<li>Add support for arrays by defining a <strong class="source-inline">DeepPartialArray&lt;T&gt;</strong> type and add handling for it in our <strong class="source-inline">DeepPartial&lt;T&gt;</strong> type.</li>
				<li>Add support for sets by defining a <strong class="source-inline">DeepPartialSet&lt;T&gt;</strong> type and add handling for it in our <strong class="source-inline">DeepPartial&lt;T&gt;</strong> type.</li>
				<li>Add support for maps by defining a <strong class="source-inline">DeepPartialMap&lt;T&gt;</strong> type and add handling for it in our <strong class="source-inline">DeepPartial&lt;T&gt;</strong> type.</li>
				<li>Add support for plain objects, by applying the <strong class="source-inline">?</strong> property modifier on each of their properties, and passing their values wrapped in <strong class="source-inline">DeepReadonly</strong>.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor426">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor235"/>Summary</h1>
			<p>This chapter got you started with the basics of generics and conditional types. We learned about generics in a lot of different use cases, why they are useful, as well as some extensions to their basic usage – generic defaults and conditional types. We performed a couple of exercises to show how you can include generics in your code to make it type-safe and avoid errors at runtime.</p>
			<p>Generics are useful in all kinds of applications, both frontend and backend, and are used everywhere, but especially so in libraries, where a lot of the time, you want to expose an API that leverages the applications' types, which you might not know ahead of time.</p>
			<p>In the next chapter, you'll learn about asynchronous development, some of which you encountered briefly in this chapter when typing external APIs.</p>
		</div>
		<div>
			<div id="_idContainer126" class="Content">
			</div>
		</div>
	</body></html>