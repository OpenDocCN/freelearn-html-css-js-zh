- en: Chapter 7. Static Data Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have implemented capabilities related to basic features of the application.
    From now on, we will start implementing the application's core features, starting
    with static data management. What exactly is this? Every application has information
    that is not directly related to the core business, but this information is used
    by the core business logic somehow.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of data in every application: static data and dynamic data.
    For example, the types of categories, languages, cities, and countries can exist
    independently of the core business and can be used by the core business information
    as well; this is what we call static data because it does not change very often.
    And there is the dynamic data, which is the information that changes in the application,
    what we call core business data. Clients, orders, and sales would be examples
    of dynamic or core business data.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can treat this static information as though they are independent MySQL tables
    (since we are using MySQL as the database server), and we can perform all the
    actions we can do on a MySQL table. So in this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new system module called static data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all information as a MySQL table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new records on the tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live search on the table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering information
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing and deleting a record
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an abstract component for reuse in all tables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting the tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we open and analyze the **Entity Relationship** (**ER**) diagram that comes
    with the Sakila installation, we will notice the following tables:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the tables](img/0457OT_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a reminder, the Sakila database can be downloaded at [http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html),
    and its documentation with installation instructions can be found at [http://dev.mysql.com/doc/sakila/en/](http://dev.mysql.com/doc/sakila/en/).
  prefs: []
  type: TYPE_NORMAL
- en: These tables can exist independently of the other tables, and we are going to
    work with them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we open SQL editor in MySQL Workbench (version 6 ) ([http://dev.mysql.com/downloads/workbench/](http://dev.mysql.com/downloads/workbench/)),
    we can select a table, right-click on it, and select **Select Rows – Limit 1000**.
    When we choose this option, a new tab will be opened, and it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the tables](img/0457OT_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The table shown previously is the `actor` table. The idea is to implement screens
    that look similar to the preceding screenshot for each of the tables that we selected:
    **Actors**, **Categories**, **Languages**, **Cities**, and **Countries** as displayed
    in the following screenshot (which is the final result of the code that we will
    be implementing in this chapter):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the tables](img/0457OT_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our goal in this chapter is to minimize the amount of code to implement these
    five screens. This means we want to create the most generic code as possible and
    will facilitate future code fixes and enhancements and also make it easier to
    create new screens with these same features if needed.
  prefs: []
  type: TYPE_NORMAL
- en: So let's go ahead and start the development.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, we are going to start by creating the models. First, let''s list
    the tables we will be working with and their columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Actor`: `actor_id`, `first_name`, `last_name`, `last_update`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Category`: `category_id`, `name`, `last_update`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Language`: `language_id`, `name`, `last_update`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`City`: `city_id`, `city`, `country_id`, `last_update`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Country`: `country_id`, `country`, `last_update`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could create one Model for each of these entities with no problem at all;
    however, we want to reuse as much code as possible. Take another look at the list
    of tables and their columns. Notice that all tables have one column in common—the
    `last_update` column.
  prefs: []
  type: TYPE_NORMAL
- en: All the previous tables have the `last_update` column in common. That being
    said, we can create a super model that contains this field. When we implement
    the `actor` and `category` models, we can extend the super Model, in which case
    we do not need to declare the column. Don't you think?
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OOP, there is a concept called inheritance, which is a way to reuse the code
    of existing objects. Ext JS uses an OOP approach, so we can apply the same concept
    in Ext JS applications. If you take a look back at the code we already implemented,
    you will notice that we are already applying inheritance in most of our classes
    (with the exception of the `util` package), but we are creating classes that inherit
    from Ext JS classes. Now, we will start creating our own super classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As all the models that we will be working with have the `last_update` column
    in common (if you take a look, all the Sakila tables have this column), we can
    create a super Model with this field. So, we will create a new file under `app/model/staticData`
    named `Base.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This Model has only one column, that is, `last_update`. On the tables, the `last_update`
    column has the type `timestamp`, so the `type` of the field needs to be `date`,
    and we will also apply `date format:` '`Y-m-j H:i:s`', which is years, months,
    days, hours, minutes, and seconds, following the same format as we have in the
    database (`2006-02-15 04:34:33`).
  prefs: []
  type: TYPE_NORMAL
- en: When we can create each Model representing the tables, we will not need to declare
    the `last_update` field again.
  prefs: []
  type: TYPE_NORMAL
- en: Look again at the code at line `#1`. We are not extending the default `Ext.data.Model`
    class, but another `Base` class. Remember the `security.Base` Model we created
    in the preceding chapter? We are going to move its code to the model package and
    make some changes.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting the Base Model schema
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a file named `Base.js` inside the `app/model` folder with the following
    content in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between this code and the code we implemented in the preceding
    chapter is `namespace` (`#1`). Instead of using `Packt.model.security`, we are
    going to use only `Packt.model`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Packt.model.security.Base` class we created in the preceding chapter will
    look simpler now as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: It is very similar to the `staticData.Base` Model we are creating for this chapter.
    The difference is in the field that is common for the `staticData` package (`last_update`)
    and `security` package (`id`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a single schema for the application now means `entityName` of the models
    will be created based on their name after `''Packt.model''`. This means that the
    `User` and `Group` models we created in the preceding chapter will have `entityName`
    `security.User`, and `security.Group` respectively. However, we do not want to
    break the code we have implemented already, and for this reason we want the `User`
    and `Group` Model classes to have the entity name as `User` and `Group`. We can
    do this by adding `entityName: ''User''` to the `User` Model and `entityName:
    ''Group''` to the `Group` Model. We will do the same for the specific models we
    will be creating next.'
  prefs: []
  type: TYPE_NORMAL
- en: Having a super `Base` Model for all models within the application means our
    models will follow a pattern. The proxy template is also common for all models,
    and this means our server-side code will also follow a pattern. This is good to
    organize the application and for future maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Specific models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can create all the models representing each table. Let''s start with
    the Actor Model. We will create a new class named `Packt.model.staticData.Actor`;
    therefore, we need to create a new file name `Actor.js` under `app/model/staticData`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three important things we need to note in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: This Model is extending (`#1`) from the `Packt.model.staticData.Base` class,
    which extends from the `Packt.model.Base` class, which in turn extends from the
    `Ext.data.Model` class. This means this Model inherits all the attributes and
    behavior from the classes `Packt.model.staticData.Base`, `Packt.model.Base`, and
    `Ext.data.Model`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we created a super Model with the schema `Packt.model`, the default `entityName`
    created for this Model would be `staticData.Actor`. We are using `entityName`
    to help the proxy compile the `url` template with `entityName`. To make our life
    easier we are going to overwrite `entityName` as well (`#2`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third point is `idProperty` (`#3`). By default, `idProperty` has the value
    "`id`". This means that when we declare a Model with a field named "`id`", Ext
    JS already knows that this is the unique field of this Model. When it is different
    from "`id`", we need to specify it using the `idProperty` configuration. As all
    Sakila tables do not have a unique field called "`id`"—it is always the *name
    of the entity* + "*_id*"—we will need to declare this configuration in all models.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can do the same for the other models. We need to create four more classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Packt.model.staticData.Category`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.model.staticData.Language`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.model.staticData.City`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.model.staticData.Country`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end, we will have six Model classes (one super Model and five specific
    models) created inside the `app/model/staticData` package. If we create a UML-class
    diagram for the Model classes, we will have the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specific models](img/0457OT_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The **Actor**, **Category**, **Language**, **City**, and **Country** models
    extend the `Packt.model.staticData` Base Model, which extends from `Packt.model.Base`,
    which in turn extends the `Ext.data.Model` class.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Store
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to create the stores for each Model. As we did with the Model,
    we will try to create a generic Store as well (in this chapter, will create a
    generic code for all screens, so creating a super Model, Store, and View is part
    of the capability). Although the common configurations are not in the Store, but
    in the Proxy (which we declared inside the schema in the `Packt.model.Base` class),
    having a super Store class can help us to listen to events that are common for
    all the static data stores.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a super Store named `Packt.store.staticData.Base`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we need a Store for each Model, we will create the following stores:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Actors`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Categories`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Languages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Cities`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Countries`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end of this topic, we will have created all the previous classes. If
    we create a UML diagram for them, we will have something like the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Store](img/0457OT_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All the Store classes extend from the `Base` Store.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what we need to create, let's get our hands dirty!
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first class we need to create is the `Packt.store.staticData.Base` class.
    Inside this class, we will only declare `autoLoad` as `true` so that all the subclasses
    of this Store can be loaded when the application launches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: All the specific stores that we will create will extend this Store. Creating
    a super Store like this can feel pointless; however, we do not know that during
    future maintenance, we will need to add some common Store configuration.
  prefs: []
  type: TYPE_NORMAL
- en: As we will use MVC for this module, another reason is that inside the Controller,
    we can also listen to Store events (available since Ext JS 4.2). If we want to
    listen to the same event of a set of stores and we execute exactly the same method,
    having a super Store will save us some lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: Specific Store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next step is to implement the `Actors`, `Categories`, `Languages`, `Cities`,
    and `Countries` stores.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start with the `Actors` Store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: After the definition of the Store, we need to extend from the Ext JS `Store`
    class. As we are using a super Store, we can extend directly from the super Store
    (`#1`), which means extending from the `Packt.store.staticData.Base` class.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to declare the `fields` or the `model` that this Store is going
    to represent. In our case, we always declare the Model (`#2`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a `model` inside the Store is good for reuse purposes. The `fields` configuration
    is recommended just in case we need to create a very specific Store with specific
    data that we are not planning to reuse throughout the application, as in a chart
    or a report.
  prefs: []
  type: TYPE_NORMAL
- en: For the other stores, the only thing that is going to be different is the name
    of the Store and the Model.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As models and stores are very similar, we are not going to list their code in
    this chapter. However, if you need the code to compare with yours or simply want
    to get the complete source code, you can download the code bundle from this book
    or get it at [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).
  prefs: []
  type: TYPE_NORMAL
- en: Creating an abstract GridPanel for reuse
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now is the time to implement the views. We have to implement five views: one
    to perform the CRUD operations for Actor, one for Category, one for Language,
    one for City, and one for Country.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot represents the final result we want to achieve after
    implementing the **Actors** screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an abstract GridPanel for reuse](img/0457OT_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the following screenshot represents the final result we want to achieve
    after implementing the **Categories** screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an abstract GridPanel for reuse](img/0457OT_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Did you notice anything similar between these two screens? Let''s take a look
    again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an abstract GridPanel for reuse](img/0457OT_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The top toolbar is the same (**1**); there is a Live Search capability (**2**);
    there is a filter plugin (**4**), and the **Last Update** and widget columns are
    also common (**3**). Going a little bit further, both GridPanels can be edited
    using a cell editor (similar to MS Excel capabilities, where you can edit a single
    cell by clicking on it). The only things different between these two screens are
    the columns that are specific to each screen (**5**). Does this mean we can reuse
    a good part of the code if we use inheritance by creating a super GridPanel with
    all these common capabilities? Yes!
  prefs: []
  type: TYPE_NORMAL
- en: 'So this is what we are going to do. So let''s create a new class named `Packt.view.staticData.BaseGrid`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We will extend the `Ext.ux.LiveSearchGridPanel` class instead of `Ext.grid.Panel`.
    The `Ext.ux.LiveSearchGridPanel` class already extends the `Ext.grid.Panel` class
    and also adds the Live Search toolbar (**2**). The `LiveSearchGridPanel` class
    is a plugin that is distributed with the Ext JS SDK. So, we do not need to worry
    about adding it manually to our project (you will learn how to add third-party
    plugins to the project later in this book).
  prefs: []
  type: TYPE_NORMAL
- en: As we will also add a toolbar with the **Add**, **Save Changes**, **Cancel Changes**
    buttons, we need to require the `util.Glyphs` class we created (`#2`).
  prefs: []
  type: TYPE_NORMAL
- en: The configurations `#3` and `#4` show the border of each cell of the grid and
    to alternate between a white background and a light gray background.
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, any other component that is responsible for displaying information
    in Ext JS, such as the "Panel" piece is only the shell. The View is responsible
    for displaying the columns in a GridPanel. We can customize it using the `viewConfig`
    (`#4`).
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create an `initComponent` method.
  prefs: []
  type: TYPE_NORMAL
- en: To initComponent or not?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While browsing other developers' code, we might see some using the `initComponent`
    when declaring an Ext JS class and some who do not (as we have done until now).
    So what is the difference between using it and not using it?
  prefs: []
  type: TYPE_NORMAL
- en: When declaring an Ext JS class, we usually configure it according to the application
    needs. They might become either a parent class for other classes or not. If they
    become a parent class, some of the configurations will be overridden, while some
    will not. Usually, we declare the ones that we expect to override in the class
    as configurations. We declare inside the `initComponent` method the ones we do
    not want to be overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'As there are a few configurations we do not want to be overridden, we will
    declare them inside the `initComponent`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can define how the user can select information from the GridPanel: the default
    configuration is the `Selection RowModel` class. As we want the user to be able
    to edit cell by cell, we will use the `Selection CellModel` class (`#5`) and also
    the `CellEditing` plugin (`#6`), which is part of the Ext JS SDK. For the `CellEditing`
    plugin, we configure the cell to be available to edit when the user clicks on
    the cell (if we need the user to double-click, we can change to `clicksToEdit:
    2`). To help us later in the Controller, we also assign an ID to this plugin.'
  prefs: []
  type: TYPE_NORMAL
- en: To be able to filter the information (the Live Search will only highlight the
    matching records), we will use the **Filters** plugin (`#7`). The **Filters**
    plugin is also part of the Ext JS SDK.
  prefs: []
  type: TYPE_NORMAL
- en: The `callParent` method (`#8`) will call `initConfig` from the superclass `Ext.ux.LiveSearchGridPanel`
    passing the arguments we defined.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a common mistake to forget to include the `callParent` call when overriding
    the `initComponent` method. If the component does not work, make sure you are
    calling the `callParent` method!
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to declare `dockedItems`. As all GridPanels will have the
    same toolbar, we can declare `dockedItems` in the super class we are creating,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We will have **Add**, **Save Changes**, **Cancel Changes**, and **Clear Filters**
    buttons. Note that the toolbar (`#9`) and each of the buttons (`#10`) has `itemId`
    declared. As we are going to use the MVC approach in this example, we will declare
    a Controller. The `itemId` configuration has a responsibility similar to the reference
    that we declare when working with a ViewController. We will discuss the importance
    of `itemId` more when we declare the Controller later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When declaring buttons inside a toolbar, we can omit the `xtype: ''button''`
    configuration since the button is the default component for toolbars.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Glyphs` class, we need to add the following attributes inside its
    `config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'And finally, we will add the two columns that are common for all the screens
    (`Last Update` column and Widget Column `delete` (`#13`)) along with the columns
    already declared in each specific GridPanel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code we merge (`#11`) `me.columns` (`#12`) with two other `columns`
    and assign this value to `me.columns` again. We want all child grids to have these
    two columns plus the specific columns for each child grid. If the columns configuration
    from the `BaseGrid` class were outside `initConfig`, then when a child class declared
    its own columns configuration the value would be overridden. If we declare the
    `columns` configuration inside `initComponent`, a child class would not be able
    to add its own `columns` configuration, so we need to merge these two configurations
    (the columns from the child class `#12` with the two columns we want each child
    class to have).
  prefs: []
  type: TYPE_NORMAL
- en: For the delete button, we are going to use a Widget Column (`#13`) (introduced
    in Ext JS 5). Until Ext JS 4, the only way to have a button inside a Grid Column
    was using an Action Column. We are going to use a button (`#16`) to represent
    a Widget Column. Because it is a Widget Column, there is no reason to make this
    column `sortable` (`#14`), and we can also disable its menu (`#15`).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to discuss lines `#17` and `#18` in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Widget Column in the MVC architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look again at the Widget Column declared in the super GridPanel,
    especially in the `handler` configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Even though the Widget Column is a widget and contains `xtype`, it is not possible
    to listen to its events in the MVC Controller, so we need a workaround to make
    it work in the MVC architecture. The reason is that the items that can be declared
    inside a Widget Column are subclasses of the `Ext.Widget` class, which is a subclass
    of the `Ext.Evented` class. MVC Controllers can only listen to events fired by
    a component subclass (panel, button, grid, tree, chart, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: That is why we are firing a custom event (`#18`) passing the parameters we need,
    so we can catch this event in this Controller and handle the programming logic
    needed to delete a record.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are setting `scope` of the handler as `me` (`#17`), which
    refers to `this` of the GridPanel. This means it will be the GridPanel that will
    be firing the `widgetclick` event, passing the grid itself and the widget button.
    The `btn` parameter contains a method named `getWidgetRecord`, which is used to
    retrieve the Model represented by the GridPanel row where the user clicked on
    the **Delete** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were using an Action Column (a very popular choice until Ext JS 4) we
    would handle it in the MVC architecture in the same way (firing a custom event).
    An example can be found at: [http://goo.gl/pxdU4i](http://goo.gl/pxdU4i).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Handling Widget Column handlers in the MVVM approach is easier. Instead of
    firing a custom event, we can simply refer to the method used in the ViewController
    as follows: `handler: ''onWidgetClick''`.'
  prefs: []
  type: TYPE_NORMAL
- en: Live Search plugin versus Filter plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both plugins have the objective of helping the user to search for information
    quickly. In our project, we are using both.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Live Search plugin will search for any matching result in all the columns
    of the GridPanel. The search is also performed locally, which means that if we
    use the paging toolbar, this plugin will not work as expected. When using the
    paging toolbar, the grid only displays one page at a time, which means it is a
    limited number of rows. The remaining information is not kept locally, the paging
    toolbar only fetches the requested information, and this is the reason the search
    will not work when using paging. In our case, we display all the records from
    the database at once, so the plugin works as expected. For example, if we search
    for "`ada`", we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Live Search plugin versus Filter plugin](img/0457OT_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And the Filter plugin will apply the filters on the Store as well, so it will
    only display to the user the matching results, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Live Search plugin versus Filter plugin](img/0457OT_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Specific GridPanels for each table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our last stop before we implement the Controller is the specific GridPanels.
    We have already created the super GridPanel that contains most of the capabilities
    that we need. Now we just need to declare the specific configurations for each
    GridPanel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create five GridPanels that will extend from the `Packt.view.staticData.BaseGrid`
    class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Actors`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Categories`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Languages`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Cities`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Countries`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the `Actors` GridPanel, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Each specific class has its own `xtype` (`#1`). We also need to execute an
    `UPDATE` query in the database to update the menu table with the new xtypes we
    are creating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The first declaration that is specific to the `Actors` GridPanel is the Store
    (`#2`). We are going to use the `Actors` Store. Because the `Actors` Store is
    inside the `staticData` folder (`store/staticData`), we also need to pass the
    name of the subfolder; otherwise, Ext JS will think that this Store file is inside
    the `app/store` folder, which is not true.
  prefs: []
  type: TYPE_NORMAL
- en: Then we need to declare the `columns` specific to the `Actors` GridPanel (we
    do not need to declare the `Last Update` and the `Delete` Action Column because
    they are already in the super GridPanel).
  prefs: []
  type: TYPE_NORMAL
- en: What you need to pay attention to now are the `editor` and `filter` configurations
    for each column. The `editor` is for editing (`cellediting` plugin). We will only
    apply this configuration to the columns we want the user to be able to edit, and
    the `filter` (`filters` plugin) is the configuration that we will apply to the
    `columns` we want the user to be able to `filter` information from.
  prefs: []
  type: TYPE_NORMAL
- en: For example, for the `id` column, we do not want the user to be able to edit
    it as it is a sequence provided by the MySQL database auto increment, so we will
    not apply the `editor` configuration to it. However, the user can filter the information
    based on the ID, so we will apply the `filter` configuration (`#3`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the user to be able to edit the other two columns: `first_name` and
    `last_name`, so we will add the `editor` configuration. We can perform client
    validations as we can do on a field of a form too. For example, we want both fields
    to be mandatory (`#4` and `#7`) and the maximum number of characters the user
    can enter is `45` (`#5` and `#8`).'
  prefs: []
  type: TYPE_NORMAL
- en: And at last, as both columns are rendering text values (`string`), we will also
    apply `filter` (`#6` and `#9`).
  prefs: []
  type: TYPE_NORMAL
- en: 'For other filter types, please refer to the Ext JS documentation as shown in
    the following screenshot. The documentation provides an example and more configuration
    options that we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Specific GridPanels for each table](img/0457OT_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: And that is it! The super GridPanel will provide all the other capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Live Search CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we navigate to the Live Search Grid example ([http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html](http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html))
    and we go through its source code, we can see that the example imports two CSS
    files: the `LiveSearchGridPanel.css` and `statusbar.css` (because the Live Search
    plugin has a dependency on the `statusbar` plugin). We also need to add this CSS
    to our application.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to copy these two CSS files and rename the extension to `scss`.
    The Live Search CSS can be copied from `ext/src/ux/css`, and the `statusbar` CSS
    can be copied from `ext/src/ux/statusbar`. We need to place these two files inside
    our application custom CSS, which is located in the `sass/etc` directory. Create
    a new folder named `ux` and paste these files. Inside `all.scss`, we are going
    to import these two Sass files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `statusbar` plugin displays an icon, and we need to fix the path to the
    `statusbar` images as well. Inside the `statusbar.scss` file, replace all matches
    "`../images`" by "`images/statusbar`". Go to `ext/src/ux/statusbar`, copy the
    `images` folder, and paste it inside `resources/images`. Rename `resources/images/images`
    to `resources/images/statusbar`. If you have `Sencha app watch` being executed
    in the terminal, Sencha Cmd will rebuild the app CSS file and the plugin will
    work 100 percent.
  prefs: []
  type: TYPE_NORMAL
- en: Generic Controller for all tables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to implement the last piece of the static data module. The goal
    is to implement a Controller that has the most generic code that will provide
    the functionalities for all the screens, without us having to create any specific
    method for any screens.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start with the base of the Controller. We are going to create a new
    class named `Packt.controller.StaticData`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: For now, we are going to declare the `requires` ((`#1`)—we are going to use
    the `Util` class in some methods and also the `Glyphs` class), the `stores` ((`#2`)—where
    we can list all the stores of this module), and also the `views` ((`#3`)—where
    we can list all views of this module).
  prefs: []
  type: TYPE_NORMAL
- en: As we are instantiating the views by their `xtype`, we need to declare them
    somewhere (`#2`). This can be inside the `requires` configuration in the `Application.js`
    file or inside a Controller. This is needed because Ext JS does not know the xtypes
    we are creating, so the names of the classes need to be listed somewhere.
  prefs: []
  type: TYPE_NORMAL
- en: The `stores` declaration (`#2`) that we are listing in this Controller will
    be instantiated when the Controller is instantiated as well. As this is a Controller
    from the MVC architecture, its scope is global, and it will be created when the
    application launches. Using the MVC approach for this case is interesting; after
    all, we are constructing the static data module that refers to common data used
    by other entities of the application. In this case, this information will be live
    throughout the life cycle of the application. This is unlike the Views, ViewModels,
    ViewControllers, and stores declared inside ViewModels, which are alive as long
    as the View is alive (tab opened). As we set `autoLoad:true` in the `Base` Store,
    when the application launches, the stores listed in this Controller will be instantiated
    and loaded.
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `init` function and `this.control` where we are going to listen
    to all the events that we are interested in.
  prefs: []
  type: TYPE_NORMAL
- en: Finding the correct selector
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the toolbar from each static data grid panel, we have a button with the text
    **Add**. When we click on this button, we want to add a new Model entry to the
    Store (and consequently, add a new record on the GridPanel) and enable editing
    so that the user can fill in the values to save them later (when they click on
    the **Save Changes** button).
  prefs: []
  type: TYPE_NORMAL
- en: When listening to an event in a Controller, first we need to pass the selector
    that is going to be used by the `Ext.ComponentQuery` class to find the component.
    Then we need to list the event that we want to listen to. And then, we need to
    declare the function that is going to be executed when the event we are listening
    to is fired, or declare the name of the Controller method that is going to be
    executed when the event is fired. In our case, we are going to declare the method
    only for code organization purposes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s focus on finding the correct selector for the **Add** button (the
    other buttons will be similar as well). According to the `Ext.ComponentQuery`
    API documentation, we can retrieve components by using their `xtype` (if you are
    already familiar with JQuery, you will notice that `Ext.ComponentQuery` selector
    behavior is very similar to JQuery selector behavior). Well, we are trying to
    retrieve two buttons, and their `xtype` is `button`. We can then try the selector
    `''button''`. But before we start coding, let''s make sure that this is the correct
    selector to avoid changing the code all the time trying to figure out the correct
    selector. There is one very useful tip we can try: open the browser console—Command
    Editor—and type the following command and click on Run:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the following screenshot, it returned an array of the buttons
    that were found by the selector we used, and the array contains several buttons!
    Too many buttons is not what we want. We want to narrow down to the **Add** button
    from the **Actors** screen, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the correct selector](img/0457OT_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to draw a path of the **Actors** screen using the components `xtype`
    we used. We have the **Actors** screen (`xtype: actorsgrid`); inside the screen,
    we have a toolbar (`xtype: toolbar`); and inside the toolbar, we have some buttons
    (`xtype: button`). Therefore, we have `actorsgrid` | `toolbar` | `button`. So
    we can try the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s try this last selector on the **Console**, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the correct selector](img/0457OT_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now the result is an array of six buttons, and these are the buttons that we
    are looking for! There is still one detail missing: if we use the `''actorsgrid
    toolbar button''` selector, it will listen to the click event (which is the event
    we want to listen to) of all the six buttons.'
  prefs: []
  type: TYPE_NORMAL
- en: However, when we click on the **Cancel** button, an action should happen; when
    we click on the **Save** button, a different action should happen because it is
    a different button. So we still want to narrow down the selector even more until
    it returns the **Add** button that we are looking for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the Base Grid panel code, notice that we declared a configuration
    named `itemId` for all buttons. We can use these `itemId` configurations to identify
    the buttons in a unique way. And according to the `Ext.ComponentQuery` API documentation,
    we can use `#` as a prefix of `itemId`. So let''s try the following command on
    the **Console** to get the **Add** button reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And the output will be only one button as we expect:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the correct selector](img/0457OT_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: So now we have the selectors that we were looking for! Using the **Console**
    is a great tool and can save us a lot of time when trying to find the exact selector
    that we want instead of coding, testing, not getting the selector we want, coding
    again, testing again, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Could we use only `button#add` as selector? Yes, we could use a shorter selector.
    However, it would work perfectly for now. As the application grows and we declare
    more classes and more buttons, the event would be fired for all buttons that have
    the `itemId` with `add` value, and this could lead to an error of the application.
    We always need to remember that `itemId` is scoped locally to its container. Using
    the `actorsgrid toolbar button` or `actorsgrid button` as selector, we make sure
    that the event will come from the button from the **Actors** screen.
  prefs: []
  type: TYPE_NORMAL
- en: Now's the time for one last detail. The selector we found is specific to the
    **Actors** screen. We want some generic code—code that can be used for all screens
    from the static data module. The good news is that we created a super class (`Packt.view.staticData.BaseGrid`)
    with `xtype staticdatagrid`.
  prefs: []
  type: TYPE_NORMAL
- en: Using itemId versus id – Ext.Cmp is bad!
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever we can, we will always try to use the `itemId` configuration instead
    of `id` to uniquely identify a component. And here comes the question: Why?'
  prefs: []
  type: TYPE_NORMAL
- en: When using `id`, we need to make sure that `id` is unique and none of all the
    other components of the application can have the same `id` property. Now, imagine
    the situation where you are working with other developers on the same team and
    it is a big application. How can you make sure that `id` is going to be unique?
    It will be pretty difficult. Don't you think? And this can be a hard task to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Components created with `id` can be accessed globally using `Ext.getCmp`, which
    is shorthand for `Ext.ComponentManager.get`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to mention one example, when using `Ext.getCmp` to retrieve a component
    by its `id`, it is going to return the last component declared with the given
    `id`. And if `id` is not unique, it can return the component that you are not
    expecting, and this can lead to an error in the application, as shown in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using itemId versus id – Ext.Cmp is bad!](img/0457OT_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Do not panic! There is an elegant solution: using `itemId` instead of `id`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `itemId` can be used as an alternative way to get a reference of a component.
    The `itemId` is an index to the container's internal `MixedCollection`, and that
    is why `itemId` is scoped locally to the container. This is the biggest advantage
    of `itemId`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can have a class named `MyWindow1` extending from `Window`,
    and inside this class, we can have a button with `itemId` containing the `submit`
    value. Then, we can have another class named `MyWindow2`, also extending from
    `Window`, and inside the class, we can also have a button with the `itemId` as
    `submit`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having two `itemIds` with the same value is not an issue. We only need to be
    careful when we use `Ext.ComponentQuery` to retrieve the component we want. For
    example, if we have a **Login** window whose alias is `login` and another screen
    called **Registration** window whose alias is `registration` and both windows
    have a button **Save**, whose `itemId` is `save`, if we simply use `Ext.ComponentQuery.query(''button#save'')`,
    the result will be an array with two results. However, if we narrow down the selector
    even more—let''s say we want the **Login Save** button, and not the **Registration
    Save** button, we need to use `Ext.ComponentQuery.query(''login button#save'')`,
    and the result will be only one, which is exactly what we expect. The contents
    of this paragraph are aptly encapsulated in the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using itemId versus id – Ext.Cmp is bad!](img/0457OT_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that we will not use `Ext.getCmp` in the code of our project
    as it is not a good practice because of the reasons listed previously. Until Ext
    JS 3, this was the way that we had to use to retrieve components. But from Ext
    JS 4 onwards, and with the introduction of the MVC architecture and MVVM, this
    is not needed anymore.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new record on the GridPanel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to find the correct selector to use in the Controller,
    let''s go ahead and declare the selector for the **Add** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to implement the method `onButtonClickAdd`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: From the parameters, we only have the `button` reference. We need to get the
    GridPanel reference. So, we are going to use the `up` method to get it (`#1`).
    Again, we are going to use the super GridPanel `xtype` as selector (`staticdatagrid`),
    because this way we have the most generic code possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'All components in Ext JS have methods to query other components. They are listed
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`up`: This navigates up the ownership hierarchy searching for an ancestor container
    that matches any passed selector or component'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`down`: This retrieves the first descendant of this container that matches
    the passed selector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query`: This retrieves all descendant components that match the passed selector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method query also has some alternatives, such as `queryBy(function)` and
    `queryById`.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the GridPanel reference, we can get the Store reference using the
    `getStore` method (`#2`).
  prefs: []
  type: TYPE_NORMAL
- en: We need to have the Model name to instantiate it (`#5`) so that we can insert
    on the first position of the Store (this way it will be the first line of the
    GridPanel). So, still targeting generic code, we can get the `modelName` from
    the `store` (`#3`).
  prefs: []
  type: TYPE_NORMAL
- en: We can pass some configurations to the Model when we instantiate it. We want
    the `Last Update` column to be updated as well; we will only pass it as configuration
    with the most current *Date* and *Time*.
  prefs: []
  type: TYPE_NORMAL
- en: And at last, we also want to focus on a cell of the row so that the user can
    be aware that the cell can be edited, so we will focus on the second column of
    the grid (the first one is the `id`, which is not editable) of the first row (`#7`).
    But to do so, we need a reference to the `celleditor` plugin; we can get it by
    using the `getPlugin` method, passing `pluginId` as the parameter (`#4`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to remember, we declared the `pluginId` for the `cellediting` plugin of
    the `Packt.view.staticData.BaseGrid` class, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that with only one method, we can program the necessary logic. The code
    is generic and provides the same capability to all static data grid panels.
  prefs: []
  type: TYPE_NORMAL
- en: Editing an existing record
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The editing of a cell will be done automatically by the `cellediting` plugin.
    However, when the user clicks on a cell to edit and finishes the editing, we need
    to update the **Last Update** value to the current *Date* and *Time*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cellediting` plugin has an event named `edit` that allows us to listen
    to the event we want. Unfortunately, the Controller is not able to listen to plugin
    events. Lucky for us, the GridPanel class also fires this event (the `cellediting`
    plugin forwards the event to the `GridPanel` internally), so we can listen to
    it. So we are going to add the following code to the Controller `init` control:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to implement the `onEdit` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The second parameter is the event (`context`). From this parameter, we can get
    the **Model** instance (`record`) that the user edited and then set the `last_update`
    field to the current *Date* and *Time*.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the handling Widget Column in the Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, the read, create, and update actions have already been implemented. Now,
    we need to implement the delete action. We do not have a button for the delete
    action, but we do have an `item` of an Action Column.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the topic *Handling the Widget Column in the MVC architecture*, you learned
    how to fire the event from the item of the Action Column so that we could handle
    it on the Controller. We cannot listen to the event fired by the Action Column
    itself; however, we can listen to the event fired by the Action Column that we
    created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see how you can implement the `handleActionColumn` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: As this is a custom event, we need to get the parameters that were passed by
    the item of the Action Column.
  prefs: []
  type: TYPE_NORMAL
- en: So first, we need to get the Store and also the `record` that the user clicked
    to delete. Then, using the second parameter, which is the name of the `action`
    of the Action Column item, we have a way to know which item fired the event. So
    if the `action` value is `delete`, we are going to remove the `record` from the
    Store and ask the user to commit the changes by pressing the button **Save Changes**,
    which is going to synchronize the models from the Store with the information we
    have on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Saving the changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After the user performs an update, delete, or create action, the cells that
    were updated will have a mark (the dirty mark so that the Store knows what models
    were modified) as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving the changes](img/0457OT_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the same way that we can perform changes on the MySQL table, we need to save
    the changes (commit). That is why we created the **Save Changes** button; this
    way, we will synchronize all the changes at once to the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, we need to add a listener to `me.control`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we need to implement the `onButtonClickSave` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The implementation of the method is pretty straightforward: we simply need
    to get the Store (`#2`) from the GridPanel (`#1`) and call the method `sync` (`#5`).'
  prefs: []
  type: TYPE_NORMAL
- en: However, we are going to validate that the information entered in the cells
    of the Grid contain valid information. To do so, we are going to call the method
    `validate` from the grid (`#3`) and get the `errors`. If no errors were found
    (`#4`), then we `sync` the Store with the server (`#5`); otherwise, we display
    the `errors` (`#6`).
  prefs: []
  type: TYPE_NORMAL
- en: The Grid Panel does not have a validate method by default. We are going to add
    this method to the `Base` Grid Panel.
  prefs: []
  type: TYPE_NORMAL
- en: Validating cellediting in GridPanel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Going back to the class `Packt.view.staticData.BaseGrid`, we are going to add
    the logic to validate a row from the grid and also the entire grid before saving.
    In this example, you will learn that we can also add useful methods to the classes
    we create; we do not need to develop all the code inside the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first method we are going to implement is `validateRow`. Given a record,
    we are going to validate it using Model validators, and if there are any errors,
    we will add the same form icon that Ext JS displays in the forms in case of validation
    errors in the cell that contains the error, and we will also add a tooltip in
    this cell (similar behavior from the form validation). The code for the method
    is as follows (we need to add it inside the `initComponent` method):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Given a `record` Model (`#1`), we are going to use its method `validate`. This
    method verifies that the information contained in the Model is valid according
    to the Model validators (we need to go back to the models we defined for this
    chapter and add the validators). This method returns an object with all the errors
    found in the record.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `isValid` method (`#2`), we can easily find out whether the Model
    is valid or not. If it is valid, we return `true` (we will use this information
    later).
  prefs: []
  type: TYPE_NORMAL
- en: The `columnIndexes` (`#3`) is in an array that contains `dataIndex` of each
    column of the grid. This method was present in the grid panel class back in Ext
    JS 4.1, but in Ext JS 4.2, it was removed, and it is not present in Ext JS 5\.
    We are going to implement this method as well, but with the difference being that
    in this case, we are only interested in the columns that have the editor enabled
    (since we want to validate it).
  prefs: []
  type: TYPE_NORMAL
- en: Then, for each `column` of the grid that has the editor enabled (`#4`), we are
    going to retrieve the `errors` specific for that column from the Model (`#5`).
    We are going to add each error `message` (`#6`) to an array of messages. After
    that, we are going to add the same error icon from an invalid form field to the
    grid cell (`#7`). And, at last, we are also going to add a tooltip to the cell
    with error (`#8`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to implement the `getColumnIndexes` function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: For each column of the grid (`#9`), we are going to verify that the editor is
    enabled (`#10`), and if yes, we are going to add `dataIndex` to the `columnIndexes`
    array (`#11`). In the end, we return this array (`#12`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `validateRow` method will only work for a single row. When we click on
    the **Save Changes** button, we want to validate the entire grid. To do so, we
    are going to implement one more method inside the `initComponent`, which is called
    `validate` (the method we called in the Controller):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For the `validate` method, we are going to retrieve all the rows from the grid,
    and for each one (`#13`), we are going to call the `validateRow` method (`#14`).
    In line `#14`, we are also keeping track of whether any previous row `is valid`
    or not.
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we return (`#16`) `undefined` if no error was found or we return
    an object with a title and message (`#15`) that we can use in the Controller to
    display an alert.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add an empty row or edit a cell with invalid information, the grid will
    display an error icon on the cell and also a tooltip when we mouse over it. The
    output will be similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating cellediting in GridPanel](img/0457OT_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Model validators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make this code work, we need to add the Model validators to `staticData`
    model. For example, for the `Actors` model, we can add the following code based
    on the database validations for the `actor` table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'And in the `Packt.model.staticData.Base` class, we can add the `last_update`
    validator that is going to be common to all `staticData` models:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The autoSync configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Store has a configuration named `autoSync`. The default value is `false`,
    but if we set it to `true`, the Store will automatically synchronize with the
    server whenever a change is detected. This can be good, but it also can be bad—it
    depends on how we are going to use it.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we did not have the validations, the user could create an empty
    row and try to send it to the server. The server code would fail (some columns
    cannot be `null`), and this would be bad for the application. With `autoSync`
    set to `false`, the user can also choose when to save the information and the
    information can be sent in bulk instead of sending one request per action (create,
    update, or destroy)—`allowSingle` has to be set to `false` in the proxy writer
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling the changes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the user can save the changes (commit), the user can also cancel them (rollback).
    All you have to do is to reload the Store so that you get the most updated information
    from the server, and the changes made by the user will be lost.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we need to listen to the event, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And we need to implement the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If you want, you can add a message asking whether the user really wants to roll
    back the changes. Calling the `reload` method from the Store is what we need to
    do to make it work.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an alternative to the `reload` method of the Store, we could also call the
    method `rejectChanges` instead; however, the `reload` method is more failsafe,
    since we are getting the information from the server again.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the filter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the `filter` plugin on the GridPanel, it will do everything that
    we need (when used locally). But there is one thing that it doesn''t provide to
    the user: the option to clear all the filters at once. So that is why we implemented
    a **Clear Filters** button.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, let''s listen to the event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'And then we can implement the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: When using the `filter` plugin, we are able to get a property named `filters`
    from the GridPanel. Then, all we need to do it is to call the `clearFilters` method.
    This will clear the filter values from each column that was filtered and will
    also clear the filters from the Store.
  prefs: []
  type: TYPE_NORMAL
- en: Listening to Store events in the Controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And the last event we will be listening to is the `write` event from the Store.
    We already added an `exception` listener to the Proxy (in Ext JS 3, the Store
    had an exception listener, while in Ext JS 4 and 5 this listener was moved to
    the Proxy). Now we need to add a listener in case of success.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to listen to the event from the Store in the Controller. This
    feature was introduced in Ext JS 4.2.x.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `init` function of the Controller, we will add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'We can listen to Store events inside the store option. The previous code will
    work for the **Actors** screen. If we want to do the same for the other screen,
    we need to add the same code as the preceding one. For example, the following
    code needs to be added for the **Categories** screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We cannot use the Base Store `storeId` here because each child Store will have
    its own `storeId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The write event is fired whenever the Store receives the response from the
    server. So let''s implement the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will simply display a message saying the changes have been saved. Notice
    that the message is also generic; this way we can use it for all the static data
    modules. A screenshot of the output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Listening to Store events in the Controller](img/0457OT_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Debug tip – Sencha extension for Chrome
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we need to inspect a particular Ext JS component we have instantiated
    for debugging purposes. Finding which methods are available and the current attributes
    and configurations that are set in the object can be a little tricky. When working
    in MVC, we might need to find the Store ID created and the stores that are alive
    in the application. Using `console.log` to output a particular object to inspect
    it is a lot of work!
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sencha Labs team released a free extension for Chrome called **Sencha App
    Inspector**. When working with Ext JS (or Sencha Touch), it is recommended that
    you use this extension to help debug the application. In the following screenshot,
    we can see the extension in action—stores that have been instantiated by the application
    and the data that has been loaded into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug tip – Sencha extension for Chrome](img/0457OT_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about Sencha App Inspector and the download link please
    visit [https://github.com/senchalabs/AppInspector/](https://github.com/senchalabs/AppInspector/).
  prefs: []
  type: TYPE_NORMAL
- en: Firefox extension – Illuminations for Developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your favorite browser for development is not Chrome, there is also a Sencha
    extension for Firefox (which can be used within Firebug) called Illuminations
    for Developers.
  prefs: []
  type: TYPE_NORMAL
- en: It is not a free extension (but it is possible to try it for free for a limited
    period of time), and its cost has a good cost-benefit.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the extension in action (stores that
    have been instantiated by the application and its properties):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Firefox extension – Illuminations for Developers](img/0457OT_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about Illuminations for Developers and the download link,
    please visit [http://www.illuminations-for-developers.com/](http://www.illuminations-for-developers.com/).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to implement screens that look very similar
    to the MySQL Table Editor. The most important concept we covered in this chapter
    is implementing abstract classes, using the inheritance concept from OOP. We are
    used to using these concepts on server-side languages, such as PHP, Java, .NET,
    and so on. This chapter demonstrated that it is also important to use these concepts
    on the Ext JS side; this way, we can reuse a lot of code and also implement generic
    code that provides the same capability for more than one screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a Base Model, Store, View and a Controller. We used the following
    plugins: `celleditor` for the GridPanel and Live Search grid and `filter` plugin
    for the GridPanel as well. You learned how to perform CRUD operations using the
    Store capabilities. You also learned how to create custom events and handle Widget
    Column events on the Controller. We also explored many of the MVC Controller capabilities
    in this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Reminder: you can get the complete source code for this chapter (with extra
    capabilities and server-side code) by downloading the code bundle from this book
    or from the GitHub repository [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn how to implement the Content Management
    module, which goes further than just managing one single table as we did on this
    chapter. We will manage information from other tables (related to the business
    of the application) and all its relations within the database.
  prefs: []
  type: TYPE_NORMAL
