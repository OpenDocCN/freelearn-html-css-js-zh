- en: Chapter 7. Static Data Management
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have implemented capabilities related to basic features of the application.
    From now on, we will start implementing the application's core features, starting
    with static data management. What exactly is this? Every application has information
    that is not directly related to the core business, but this information is used
    by the core business logic somehow.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of data in every application: static data and dynamic data.
    For example, the types of categories, languages, cities, and countries can exist
    independently of the core business and can be used by the core business information
    as well; this is what we call static data because it does not change very often.
    And there is the dynamic data, which is the information that changes in the application,
    what we call core business data. Clients, orders, and sales would be examples
    of dynamic or core business data.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'We can treat this static information as though they are independent MySQL tables
    (since we are using MySQL as the database server), and we can perform all the
    actions we can do on a MySQL table. So in this chapter, we will cover:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new system module called static data
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Listing all information as a MySQL table
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating new records on the tables
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Live search on the table
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering information
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Editing and deleting a record
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an abstract component for reuse in all tables
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Presenting the tables
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we open and analyze the **Entity Relationship** (**ER**) diagram that comes
    with the Sakila installation, we will notice the following tables:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the tables](img/0457OT_07_01.jpg)'
  id: totrans-13
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-14
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As a reminder, the Sakila database can be downloaded at [http://dev.mysql.com/doc/index-other.html](http://dev.mysql.com/doc/index-other.html),
    and its documentation with installation instructions can be found at [http://dev.mysql.com/doc/sakila/en/](http://dev.mysql.com/doc/sakila/en/).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: These tables can exist independently of the other tables, and we are going to
    work with them in this chapter.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'When we open SQL editor in MySQL Workbench (version 6 ) ([http://dev.mysql.com/downloads/workbench/](http://dev.mysql.com/downloads/workbench/)),
    we can select a table, right-click on it, and select **Select Rows – Limit 1000**.
    When we choose this option, a new tab will be opened, and it looks as follows:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the tables](img/0457OT_07_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
- en: 'The table shown previously is the `actor` table. The idea is to implement screens
    that look similar to the preceding screenshot for each of the tables that we selected:
    **Actors**, **Categories**, **Languages**, **Cities**, and **Countries** as displayed
    in the following screenshot (which is the final result of the code that we will
    be implementing in this chapter):'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the tables](img/0457OT_07_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
- en: Our goal in this chapter is to minimize the amount of code to implement these
    five screens. This means we want to create the most generic code as possible and
    will facilitate future code fixes and enhancements and also make it easier to
    create new screens with these same features if needed.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: So let's go ahead and start the development.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Model
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As usual, we are going to start by creating the models. First, let''s list
    the tables we will be working with and their columns:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: '`Actor`: `actor_id`, `first_name`, `last_name`, `last_update`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Category`: `category_id`, `name`, `last_update`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Language`: `language_id`, `name`, `last_update`'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`City`: `city_id`, `city`, `country_id`, `last_update`'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Country`: `country_id`, `country`, `last_update`'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We could create one Model for each of these entities with no problem at all;
    however, we want to reuse as much code as possible. Take another look at the list
    of tables and their columns. Notice that all tables have one column in common—the
    `last_update` column.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: All the previous tables have the `last_update` column in common. That being
    said, we can create a super model that contains this field. When we implement
    the `actor` and `category` models, we can extend the super Model, in which case
    we do not need to declare the column. Don't you think?
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Model
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In OOP, there is a concept called inheritance, which is a way to reuse the code
    of existing objects. Ext JS uses an OOP approach, so we can apply the same concept
    in Ext JS applications. If you take a look back at the code we already implemented,
    you will notice that we are already applying inheritance in most of our classes
    (with the exception of the `util` package), but we are creating classes that inherit
    from Ext JS classes. Now, we will start creating our own super classes.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: 'As all the models that we will be working with have the `last_update` column
    in common (if you take a look, all the Sakila tables have this column), we can
    create a super Model with this field. So, we will create a new file under `app/model/staticData`
    named `Base.js`:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This Model has only one column, that is, `last_update`. On the tables, the `last_update`
    column has the type `timestamp`, so the `type` of the field needs to be `date`,
    and we will also apply `date format:` '`Y-m-j H:i:s`', which is years, months,
    days, hours, minutes, and seconds, following the same format as we have in the
    database (`2006-02-15 04:34:33`).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: When we can create each Model representing the tables, we will not need to declare
    the `last_update` field again.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Look again at the code at line `#1`. We are not extending the default `Ext.data.Model`
    class, but another `Base` class. Remember the `security.Base` Model we created
    in the preceding chapter? We are going to move its code to the model package and
    make some changes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Adapting the Base Model schema
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a file named `Base.js` inside the `app/model` folder with the following
    content in it:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The only difference between this code and the code we implemented in the preceding
    chapter is `namespace` (`#1`). Instead of using `Packt.model.security`, we are
    going to use only `Packt.model`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Packt.model.security.Base` class we created in the preceding chapter will
    look simpler now as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is very similar to the `staticData.Base` Model we are creating for this chapter.
    The difference is in the field that is common for the `staticData` package (`last_update`)
    and `security` package (`id`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a single schema for the application now means `entityName` of the models
    will be created based on their name after `''Packt.model''`. This means that the
    `User` and `Group` models we created in the preceding chapter will have `entityName`
    `security.User`, and `security.Group` respectively. However, we do not want to
    break the code we have implemented already, and for this reason we want the `User`
    and `Group` Model classes to have the entity name as `User` and `Group`. We can
    do this by adding `entityName: ''User''` to the `User` Model and `entityName:
    ''Group''` to the `Group` Model. We will do the same for the specific models we
    will be creating next.'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Having a super `Base` Model for all models within the application means our
    models will follow a pattern. The proxy template is also common for all models,
    and this means our server-side code will also follow a pattern. This is good to
    organize the application and for future maintenance.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Specific models
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we can create all the models representing each table. Let''s start with
    the Actor Model. We will create a new class named `Packt.model.staticData.Actor`;
    therefore, we need to create a new file name `Actor.js` under `app/model/staticData`,
    as follows:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'There are three important things we need to note in the preceding code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: This Model is extending (`#1`) from the `Packt.model.staticData.Base` class,
    which extends from the `Packt.model.Base` class, which in turn extends from the
    `Ext.data.Model` class. This means this Model inherits all the attributes and
    behavior from the classes `Packt.model.staticData.Base`, `Packt.model.Base`, and
    `Ext.data.Model`.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we created a super Model with the schema `Packt.model`, the default `entityName`
    created for this Model would be `staticData.Actor`. We are using `entityName`
    to help the proxy compile the `url` template with `entityName`. To make our life
    easier we are going to overwrite `entityName` as well (`#2`).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The third point is `idProperty` (`#3`). By default, `idProperty` has the value
    "`id`". This means that when we declare a Model with a field named "`id`", Ext
    JS already knows that this is the unique field of this Model. When it is different
    from "`id`", we need to specify it using the `idProperty` configuration. As all
    Sakila tables do not have a unique field called "`id`"—it is always the *name
    of the entity* + "*_id*"—we will need to declare this configuration in all models.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now we can do the same for the other models. We need to create four more classes:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: '`Packt.model.staticData.Category`'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.model.staticData.Language`'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.model.staticData.City`'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.model.staticData.Country`'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end, we will have six Model classes (one super Model and five specific
    models) created inside the `app/model/staticData` package. If we create a UML-class
    diagram for the Model classes, we will have the following diagram:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: '![Specific models](img/0457OT_07_04.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
- en: The **Actor**, **Category**, **Language**, **City**, and **Country** models
    extend the `Packt.model.staticData` Base Model, which extends from `Packt.model.Base`,
    which in turn extends the `Ext.data.Model` class.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Store
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The next step is to create the stores for each Model. As we did with the Model,
    we will try to create a generic Store as well (in this chapter, will create a
    generic code for all screens, so creating a super Model, Store, and View is part
    of the capability). Although the common configurations are not in the Store, but
    in the Proxy (which we declared inside the schema in the `Packt.model.Base` class),
    having a super Store class can help us to listen to events that are common for
    all the static data stores.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: We will create a super Store named `Packt.store.staticData.Base`.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: 'As we need a Store for each Model, we will create the following stores:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Actors`'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Categories`'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Languages`'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Cities`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.store.staticData.Countries`'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'At the end of this topic, we will have created all the previous classes. If
    we create a UML diagram for them, we will have something like the following diagram:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a Store](img/0457OT_07_05.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
- en: All the Store classes extend from the `Base` Store.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know what we need to create, let's get our hands dirty!
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: Abstract Store
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first class we need to create is the `Packt.store.staticData.Base` class.
    Inside this class, we will only declare `autoLoad` as `true` so that all the subclasses
    of this Store can be loaded when the application launches:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: All the specific stores that we will create will extend this Store. Creating
    a super Store like this can feel pointless; however, we do not know that during
    future maintenance, we will need to add some common Store configuration.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: As we will use MVC for this module, another reason is that inside the Controller,
    we can also listen to Store events (available since Ext JS 4.2). If we want to
    listen to the same event of a set of stores and we execute exactly the same method,
    having a super Store will save us some lines of code.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Specific Store
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our next step is to implement the `Actors`, `Categories`, `Languages`, `Cities`,
    and `Countries` stores.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start with the `Actors` Store:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: After the definition of the Store, we need to extend from the Ext JS `Store`
    class. As we are using a super Store, we can extend directly from the super Store
    (`#1`), which means extending from the `Packt.store.staticData.Base` class.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to declare the `fields` or the `model` that this Store is going
    to represent. In our case, we always declare the Model (`#2`).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using a `model` inside the Store is good for reuse purposes. The `fields` configuration
    is recommended just in case we need to create a very specific Store with specific
    data that we are not planning to reuse throughout the application, as in a chart
    or a report.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
- en: For the other stores, the only thing that is going to be different is the name
    of the Store and the Model.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As models and stores are very similar, we are not going to list their code in
    this chapter. However, if you need the code to compare with yours or simply want
    to get the complete source code, you can download the code bundle from this book
    or get it at [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: Creating an abstract GridPanel for reuse
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now is the time to implement the views. We have to implement five views: one
    to perform the CRUD operations for Actor, one for Category, one for Language,
    one for City, and one for Country.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot represents the final result we want to achieve after
    implementing the **Actors** screen:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an abstract GridPanel for reuse](img/0457OT_07_06.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
- en: 'And the following screenshot represents the final result we want to achieve
    after implementing the **Categories** screen:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an abstract GridPanel for reuse](img/0457OT_07_07.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
- en: 'Did you notice anything similar between these two screens? Let''s take a look
    again:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an abstract GridPanel for reuse](img/0457OT_07_08.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
- en: The top toolbar is the same (**1**); there is a Live Search capability (**2**);
    there is a filter plugin (**4**), and the **Last Update** and widget columns are
    also common (**3**). Going a little bit further, both GridPanels can be edited
    using a cell editor (similar to MS Excel capabilities, where you can edit a single
    cell by clicking on it). The only things different between these two screens are
    the columns that are specific to each screen (**5**). Does this mean we can reuse
    a good part of the code if we use inheritance by creating a super GridPanel with
    all these common capabilities? Yes!
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: 'So this is what we are going to do. So let''s create a new class named `Packt.view.staticData.BaseGrid`,
    as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: We will extend the `Ext.ux.LiveSearchGridPanel` class instead of `Ext.grid.Panel`.
    The `Ext.ux.LiveSearchGridPanel` class already extends the `Ext.grid.Panel` class
    and also adds the Live Search toolbar (**2**). The `LiveSearchGridPanel` class
    is a plugin that is distributed with the Ext JS SDK. So, we do not need to worry
    about adding it manually to our project (you will learn how to add third-party
    plugins to the project later in this book).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: As we will also add a toolbar with the **Add**, **Save Changes**, **Cancel Changes**
    buttons, we need to require the `util.Glyphs` class we created (`#2`).
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: The configurations `#3` and `#4` show the border of each cell of the grid and
    to alternate between a white background and a light gray background.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: Likewise, any other component that is responsible for displaying information
    in Ext JS, such as the "Panel" piece is only the shell. The View is responsible
    for displaying the columns in a GridPanel. We can customize it using the `viewConfig`
    (`#4`).
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to create an `initComponent` method.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: To initComponent or not?
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While browsing other developers' code, we might see some using the `initComponent`
    when declaring an Ext JS class and some who do not (as we have done until now).
    So what is the difference between using it and not using it?
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: When declaring an Ext JS class, we usually configure it according to the application
    needs. They might become either a parent class for other classes or not. If they
    become a parent class, some of the configurations will be overridden, while some
    will not. Usually, we declare the ones that we expect to override in the class
    as configurations. We declare inside the `initComponent` method the ones we do
    not want to be overridden.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'As there are a few configurations we do not want to be overridden, we will
    declare them inside the `initComponent`, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can define how the user can select information from the GridPanel: the default
    configuration is the `Selection RowModel` class. As we want the user to be able
    to edit cell by cell, we will use the `Selection CellModel` class (`#5`) and also
    the `CellEditing` plugin (`#6`), which is part of the Ext JS SDK. For the `CellEditing`
    plugin, we configure the cell to be available to edit when the user clicks on
    the cell (if we need the user to double-click, we can change to `clicksToEdit:
    2`). To help us later in the Controller, we also assign an ID to this plugin.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: To be able to filter the information (the Live Search will only highlight the
    matching records), we will use the **Filters** plugin (`#7`). The **Filters**
    plugin is also part of the Ext JS SDK.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: The `callParent` method (`#8`) will call `initConfig` from the superclass `Ext.ux.LiveSearchGridPanel`
    passing the arguments we defined.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-116
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is a common mistake to forget to include the `callParent` call when overriding
    the `initComponent` method. If the component does not work, make sure you are
    calling the `callParent` method!
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to declare `dockedItems`. As all GridPanels will have the
    same toolbar, we can declare `dockedItems` in the super class we are creating,
    as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We will have **Add**, **Save Changes**, **Cancel Changes**, and **Clear Filters**
    buttons. Note that the toolbar (`#9`) and each of the buttons (`#10`) has `itemId`
    declared. As we are going to use the MVC approach in this example, we will declare
    a Controller. The `itemId` configuration has a responsibility similar to the reference
    that we declare when working with a ViewController. We will discuss the importance
    of `itemId` more when we declare the Controller later in this chapter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When declaring buttons inside a toolbar, we can omit the `xtype: ''button''`
    configuration since the button is the default component for toolbars.'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `Glyphs` class, we need to add the following attributes inside its
    `config`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And finally, we will add the two columns that are common for all the screens
    (`Last Update` column and Widget Column `delete` (`#13`)) along with the columns
    already declared in each specific GridPanel:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the preceding code we merge (`#11`) `me.columns` (`#12`) with two other `columns`
    and assign this value to `me.columns` again. We want all child grids to have these
    two columns plus the specific columns for each child grid. If the columns configuration
    from the `BaseGrid` class were outside `initConfig`, then when a child class declared
    its own columns configuration the value would be overridden. If we declare the
    `columns` configuration inside `initComponent`, a child class would not be able
    to add its own `columns` configuration, so we need to merge these two configurations
    (the columns from the child class `#12` with the two columns we want each child
    class to have).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: For the delete button, we are going to use a Widget Column (`#13`) (introduced
    in Ext JS 5). Until Ext JS 4, the only way to have a button inside a Grid Column
    was using an Action Column. We are going to use a button (`#16`) to represent
    a Widget Column. Because it is a Widget Column, there is no reason to make this
    column `sortable` (`#14`), and we can also disable its menu (`#15`).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: We are going to discuss lines `#17` and `#18` in the next section.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Handling the Widget Column in the MVC architecture
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s take a look again at the Widget Column declared in the super GridPanel,
    especially in the `handler` configuration:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Even though the Widget Column is a widget and contains `xtype`, it is not possible
    to listen to its events in the MVC Controller, so we need a workaround to make
    it work in the MVC architecture. The reason is that the items that can be declared
    inside a Widget Column are subclasses of the `Ext.Widget` class, which is a subclass
    of the `Ext.Evented` class. MVC Controllers can only listen to events fired by
    a component subclass (panel, button, grid, tree, chart, and so on).
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: That is why we are firing a custom event (`#18`) passing the parameters we need,
    so we can catch this event in this Controller and handle the programming logic
    needed to delete a record.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are setting `scope` of the handler as `me` (`#17`), which
    refers to `this` of the GridPanel. This means it will be the GridPanel that will
    be firing the `widgetclick` event, passing the grid itself and the widget button.
    The `btn` parameter contains a method named `getWidgetRecord`, which is used to
    retrieve the Model represented by the GridPanel row where the user clicked on
    the **Delete** button.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were using an Action Column (a very popular choice until Ext JS 4) we
    would handle it in the MVC architecture in the same way (firing a custom event).
    An example can be found at: [http://goo.gl/pxdU4i](http://goo.gl/pxdU4i).'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-137
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Handling Widget Column handlers in the MVVM approach is easier. Instead of
    firing a custom event, we can simply refer to the method used in the ViewController
    as follows: `handler: ''onWidgetClick''`.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Live Search plugin versus Filter plugin
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Both plugins have the objective of helping the user to search for information
    quickly. In our project, we are using both.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: 'The Live Search plugin will search for any matching result in all the columns
    of the GridPanel. The search is also performed locally, which means that if we
    use the paging toolbar, this plugin will not work as expected. When using the
    paging toolbar, the grid only displays one page at a time, which means it is a
    limited number of rows. The remaining information is not kept locally, the paging
    toolbar only fetches the requested information, and this is the reason the search
    will not work when using paging. In our case, we display all the records from
    the database at once, so the plugin works as expected. For example, if we search
    for "`ada`", we will get the following output:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: '![Live Search plugin versus Filter plugin](img/0457OT_07_09.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
- en: 'And the Filter plugin will apply the filters on the Store as well, so it will
    only display to the user the matching results, as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '![Live Search plugin versus Filter plugin](img/0457OT_07_10.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
- en: Specific GridPanels for each table
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our last stop before we implement the Controller is the specific GridPanels.
    We have already created the super GridPanel that contains most of the capabilities
    that we need. Now we just need to declare the specific configurations for each
    GridPanel.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: 'We will create five GridPanels that will extend from the `Packt.view.staticData.BaseGrid`
    class, as follows:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Actors`'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Categories`'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Languages`'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Cities`'
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.view.staticData.Countries`'
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s start with the `Actors` GridPanel, as follows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Each specific class has its own `xtype` (`#1`). We also need to execute an
    `UPDATE` query in the database to update the menu table with the new xtypes we
    are creating:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The first declaration that is specific to the `Actors` GridPanel is the Store
    (`#2`). We are going to use the `Actors` Store. Because the `Actors` Store is
    inside the `staticData` folder (`store/staticData`), we also need to pass the
    name of the subfolder; otherwise, Ext JS will think that this Store file is inside
    the `app/store` folder, which is not true.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: Then we need to declare the `columns` specific to the `Actors` GridPanel (we
    do not need to declare the `Last Update` and the `Delete` Action Column because
    they are already in the super GridPanel).
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: What you need to pay attention to now are the `editor` and `filter` configurations
    for each column. The `editor` is for editing (`cellediting` plugin). We will only
    apply this configuration to the columns we want the user to be able to edit, and
    the `filter` (`filters` plugin) is the configuration that we will apply to the
    `columns` we want the user to be able to `filter` information from.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: For example, for the `id` column, we do not want the user to be able to edit
    it as it is a sequence provided by the MySQL database auto increment, so we will
    not apply the `editor` configuration to it. However, the user can filter the information
    based on the ID, so we will apply the `filter` configuration (`#3`).
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: 'We want the user to be able to edit the other two columns: `first_name` and
    `last_name`, so we will add the `editor` configuration. We can perform client
    validations as we can do on a field of a form too. For example, we want both fields
    to be mandatory (`#4` and `#7`) and the maximum number of characters the user
    can enter is `45` (`#5` and `#8`).'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: And at last, as both columns are rendering text values (`string`), we will also
    apply `filter` (`#6` and `#9`).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: 'For other filter types, please refer to the Ext JS documentation as shown in
    the following screenshot. The documentation provides an example and more configuration
    options that we can use:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '![Specific GridPanels for each table](img/0457OT_07_11.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
- en: And that is it! The super GridPanel will provide all the other capabilities.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Live Search CSS
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we navigate to the Live Search Grid example ([http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html](http://dev.sencha.com/ext/5.0.1/examples/grid/live-search-grid.html))
    and we go through its source code, we can see that the example imports two CSS
    files: the `LiveSearchGridPanel.css` and `statusbar.css` (because the Live Search
    plugin has a dependency on the `statusbar` plugin). We also need to add this CSS
    to our application.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to copy these two CSS files and rename the extension to `scss`.
    The Live Search CSS can be copied from `ext/src/ux/css`, and the `statusbar` CSS
    can be copied from `ext/src/ux/statusbar`. We need to place these two files inside
    our application custom CSS, which is located in the `sass/etc` directory. Create
    a new folder named `ux` and paste these files. Inside `all.scss`, we are going
    to import these two Sass files:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `statusbar` plugin displays an icon, and we need to fix the path to the
    `statusbar` images as well. Inside the `statusbar.scss` file, replace all matches
    "`../images`" by "`images/statusbar`". Go to `ext/src/ux/statusbar`, copy the
    `images` folder, and paste it inside `resources/images`. Rename `resources/images/images`
    to `resources/images/statusbar`. If you have `Sencha app watch` being executed
    in the terminal, Sencha Cmd will rebuild the app CSS file and the plugin will
    work 100 percent.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
- en: Generic Controller for all tables
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to implement the last piece of the static data module. The goal
    is to implement a Controller that has the most generic code that will provide
    the functionalities for all the screens, without us having to create any specific
    method for any screens.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s start with the base of the Controller. We are going to create a new
    class named `Packt.controller.StaticData`, as follows:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: For now, we are going to declare the `requires` ((`#1`)—we are going to use
    the `Util` class in some methods and also the `Glyphs` class), the `stores` ((`#2`)—where
    we can list all the stores of this module), and also the `views` ((`#3`)—where
    we can list all views of this module).
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: As we are instantiating the views by their `xtype`, we need to declare them
    somewhere (`#2`). This can be inside the `requires` configuration in the `Application.js`
    file or inside a Controller. This is needed because Ext JS does not know the xtypes
    we are creating, so the names of the classes need to be listed somewhere.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
- en: The `stores` declaration (`#2`) that we are listing in this Controller will
    be instantiated when the Controller is instantiated as well. As this is a Controller
    from the MVC architecture, its scope is global, and it will be created when the
    application launches. Using the MVC approach for this case is interesting; after
    all, we are constructing the static data module that refers to common data used
    by other entities of the application. In this case, this information will be live
    throughout the life cycle of the application. This is unlike the Views, ViewModels,
    ViewControllers, and stores declared inside ViewModels, which are alive as long
    as the View is alive (tab opened). As we set `autoLoad:true` in the `Base` Store,
    when the application launches, the stores listed in this Controller will be instantiated
    and loaded.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `init` function and `this.control` where we are going to listen
    to all the events that we are interested in.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Finding the correct selector
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the toolbar from each static data grid panel, we have a button with the text
    **Add**. When we click on this button, we want to add a new Model entry to the
    Store (and consequently, add a new record on the GridPanel) and enable editing
    so that the user can fill in the values to save them later (when they click on
    the **Save Changes** button).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: When listening to an event in a Controller, first we need to pass the selector
    that is going to be used by the `Ext.ComponentQuery` class to find the component.
    Then we need to list the event that we want to listen to. And then, we need to
    declare the function that is going to be executed when the event we are listening
    to is fired, or declare the name of the Controller method that is going to be
    executed when the event is fired. In our case, we are going to declare the method
    only for code organization purposes.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s focus on finding the correct selector for the **Add** button (the
    other buttons will be similar as well). According to the `Ext.ComponentQuery`
    API documentation, we can retrieve components by using their `xtype` (if you are
    already familiar with JQuery, you will notice that `Ext.ComponentQuery` selector
    behavior is very similar to JQuery selector behavior). Well, we are trying to
    retrieve two buttons, and their `xtype` is `button`. We can then try the selector
    `''button''`. But before we start coding, let''s make sure that this is the correct
    selector to avoid changing the code all the time trying to figure out the correct
    selector. There is one very useful tip we can try: open the browser console—Command
    Editor—and type the following command and click on Run:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As we can see in the following screenshot, it returned an array of the buttons
    that were found by the selector we used, and the array contains several buttons!
    Too many buttons is not what we want. We want to narrow down to the **Add** button
    from the **Actors** screen, as shown in the following screenshot:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the correct selector](img/0457OT_07_12.jpg)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
- en: 'Let''s try to draw a path of the **Actors** screen using the components `xtype`
    we used. We have the **Actors** screen (`xtype: actorsgrid`); inside the screen,
    we have a toolbar (`xtype: toolbar`); and inside the toolbar, we have some buttons
    (`xtype: button`). Therefore, we have `actorsgrid` | `toolbar` | `button`. So
    we can try the following command:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'So let''s try this last selector on the **Console**, as follows:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the correct selector](img/0457OT_07_13.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
- en: 'Now the result is an array of six buttons, and these are the buttons that we
    are looking for! There is still one detail missing: if we use the `''actorsgrid
    toolbar button''` selector, it will listen to the click event (which is the event
    we want to listen to) of all the six buttons.'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: However, when we click on the **Cancel** button, an action should happen; when
    we click on the **Save** button, a different action should happen because it is
    a different button. So we still want to narrow down the selector even more until
    it returns the **Add** button that we are looking for.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to the Base Grid panel code, notice that we declared a configuration
    named `itemId` for all buttons. We can use these `itemId` configurations to identify
    the buttons in a unique way. And according to the `Ext.ComponentQuery` API documentation,
    we can use `#` as a prefix of `itemId`. So let''s try the following command on
    the **Console** to get the **Add** button reference:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'And the output will be only one button as we expect:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
- en: '![Finding the correct selector](img/0457OT_07_14.jpg)'
  id: totrans-195
  prefs: []
  type: TYPE_IMG
- en: So now we have the selectors that we were looking for! Using the **Console**
    is a great tool and can save us a lot of time when trying to find the exact selector
    that we want instead of coding, testing, not getting the selector we want, coding
    again, testing again, and so on.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Could we use only `button#add` as selector? Yes, we could use a shorter selector.
    However, it would work perfectly for now. As the application grows and we declare
    more classes and more buttons, the event would be fired for all buttons that have
    the `itemId` with `add` value, and this could lead to an error of the application.
    We always need to remember that `itemId` is scoped locally to its container. Using
    the `actorsgrid toolbar button` or `actorsgrid button` as selector, we make sure
    that the event will come from the button from the **Actors** screen.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: Now's the time for one last detail. The selector we found is specific to the
    **Actors** screen. We want some generic code—code that can be used for all screens
    from the static data module. The good news is that we created a super class (`Packt.view.staticData.BaseGrid`)
    with `xtype staticdatagrid`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: Using itemId versus id – Ext.Cmp is bad!
  id: totrans-200
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Whenever we can, we will always try to use the `itemId` configuration instead
    of `id` to uniquely identify a component. And here comes the question: Why?'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: When using `id`, we need to make sure that `id` is unique and none of all the
    other components of the application can have the same `id` property. Now, imagine
    the situation where you are working with other developers on the same team and
    it is a big application. How can you make sure that `id` is going to be unique?
    It will be pretty difficult. Don't you think? And this can be a hard task to achieve.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: Components created with `id` can be accessed globally using `Ext.getCmp`, which
    is shorthand for `Ext.ComponentManager.get`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to mention one example, when using `Ext.getCmp` to retrieve a component
    by its `id`, it is going to return the last component declared with the given
    `id`. And if `id` is not unique, it can return the component that you are not
    expecting, and this can lead to an error in the application, as shown in the following
    figure:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: '![Using itemId versus id – Ext.Cmp is bad!](img/0457OT_07_20.jpg)'
  id: totrans-205
  prefs: []
  type: TYPE_IMG
- en: 'Do not panic! There is an elegant solution: using `itemId` instead of `id`.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: The `itemId` can be used as an alternative way to get a reference of a component.
    The `itemId` is an index to the container's internal `MixedCollection`, and that
    is why `itemId` is scoped locally to the container. This is the biggest advantage
    of `itemId`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: For example, we can have a class named `MyWindow1` extending from `Window`,
    and inside this class, we can have a button with `itemId` containing the `submit`
    value. Then, we can have another class named `MyWindow2`, also extending from
    `Window`, and inside the class, we can also have a button with the `itemId` as
    `submit`.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'Having two `itemIds` with the same value is not an issue. We only need to be
    careful when we use `Ext.ComponentQuery` to retrieve the component we want. For
    example, if we have a **Login** window whose alias is `login` and another screen
    called **Registration** window whose alias is `registration` and both windows
    have a button **Save**, whose `itemId` is `save`, if we simply use `Ext.ComponentQuery.query(''button#save'')`,
    the result will be an array with two results. However, if we narrow down the selector
    even more—let''s say we want the **Login Save** button, and not the **Registration
    Save** button, we need to use `Ext.ComponentQuery.query(''login button#save'')`,
    and the result will be only one, which is exactly what we expect. The contents
    of this paragraph are aptly encapsulated in the following image:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: '![Using itemId versus id – Ext.Cmp is bad!](img/0457OT_07_21.jpg)'
  id: totrans-210
  prefs: []
  type: TYPE_IMG
- en: You will notice that we will not use `Ext.getCmp` in the code of our project
    as it is not a good practice because of the reasons listed previously. Until Ext
    JS 3, this was the way that we had to use to retrieve components. But from Ext
    JS 4 onwards, and with the introduction of the MVC architecture and MVVM, this
    is not needed anymore.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: Adding a new record on the GridPanel
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we know how to find the correct selector to use in the Controller,
    let''s go ahead and declare the selector for the **Add** button:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, we need to implement the method `onButtonClickAdd`:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: From the parameters, we only have the `button` reference. We need to get the
    GridPanel reference. So, we are going to use the `up` method to get it (`#1`).
    Again, we are going to use the super GridPanel `xtype` as selector (`staticdatagrid`),
    because this way we have the most generic code possible.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
- en: 'All components in Ext JS have methods to query other components. They are listed
    as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
- en: '`up`: This navigates up the ownership hierarchy searching for an ancestor container
    that matches any passed selector or component'
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`down`: This retrieves the first descendant of this container that matches
    the passed selector'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`query`: This retrieves all descendant components that match the passed selector'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method query also has some alternatives, such as `queryBy(function)` and
    `queryById`.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the GridPanel reference, we can get the Store reference using the
    `getStore` method (`#2`).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: We need to have the Model name to instantiate it (`#5`) so that we can insert
    on the first position of the Store (this way it will be the first line of the
    GridPanel). So, still targeting generic code, we can get the `modelName` from
    the `store` (`#3`).
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: We can pass some configurations to the Model when we instantiate it. We want
    the `Last Update` column to be updated as well; we will only pass it as configuration
    with the most current *Date* and *Time*.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: And at last, we also want to focus on a cell of the row so that the user can
    be aware that the cell can be edited, so we will focus on the second column of
    the grid (the first one is the `id`, which is not editable) of the first row (`#7`).
    But to do so, we need a reference to the `celleditor` plugin; we can get it by
    using the `getPlugin` method, passing `pluginId` as the parameter (`#4`).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: 'Just to remember, we declared the `pluginId` for the `cellediting` plugin of
    the `Packt.view.staticData.BaseGrid` class, as shown in the following code snippet:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that with only one method, we can program the necessary logic. The code
    is generic and provides the same capability to all static data grid panels.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
- en: Editing an existing record
  id: totrans-231
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The editing of a cell will be done automatically by the `cellediting` plugin.
    However, when the user clicks on a cell to edit and finishes the editing, we need
    to update the **Last Update** value to the current *Date* and *Time*.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
- en: 'The `cellediting` plugin has an event named `edit` that allows us to listen
    to the event we want. Unfortunately, the Controller is not able to listen to plugin
    events. Lucky for us, the GridPanel class also fires this event (the `cellediting`
    plugin forwards the event to the `GridPanel` internally), so we can listen to
    it. So we are going to add the following code to the Controller `init` control:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, we need to implement the `onEdit` method, as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The second parameter is the event (`context`). From this parameter, we can get
    the **Model** instance (`record`) that the user edited and then set the `last_update`
    field to the current *Date* and *Time*.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
- en: Deleting the handling Widget Column in the Controller
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Well, the read, create, and update actions have already been implemented. Now,
    we need to implement the delete action. We do not have a button for the delete
    action, but we do have an `item` of an Action Column.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'In the topic *Handling the Widget Column in the MVC architecture*, you learned
    how to fire the event from the item of the Action Column so that we could handle
    it on the Controller. We cannot listen to the event fired by the Action Column
    itself; however, we can listen to the event fired by the Action Column that we
    created:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, let''s see how you can implement the `handleActionColumn` method:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: As this is a custom event, we need to get the parameters that were passed by
    the item of the Action Column.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: So first, we need to get the Store and also the `record` that the user clicked
    to delete. Then, using the second parameter, which is the name of the `action`
    of the Action Column item, we have a way to know which item fired the event. So
    if the `action` value is `delete`, we are going to remove the `record` from the
    Store and ask the user to commit the changes by pressing the button **Save Changes**,
    which is going to synchronize the models from the Store with the information we
    have on the server.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，首先，我们需要获取Store以及用户点击删除的`record`。然后，使用第二个参数，即Action列项的`action`名称，我们有一种方式知道哪个项触发了事件。所以如果`action`值是`delete`，我们将从Store中删除`record`并要求用户通过按下按钮**保存更改**来提交更改，这将同步Store中的模型与服务器上的信息。
- en: Saving the changes
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保存更改
- en: 'After the user performs an update, delete, or create action, the cells that
    were updated will have a mark (the dirty mark so that the Store knows what models
    were modified) as shown in the following screenshot:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 用户执行更新、删除或创建操作后，更新的单元格将有一个标记（脏标记，以便Store知道哪些模型已被修改），如下面的截图所示：
- en: '![Saving the changes](img/0457OT_07_15.jpg)'
  id: totrans-248
  prefs: []
  type: TYPE_IMG
  zh: '![保存更改](img/0457OT_07_15.jpg)'
- en: In the same way that we can perform changes on the MySQL table, we need to save
    the changes (commit). That is why we created the **Save Changes** button; this
    way, we will synchronize all the changes at once to the server.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们可以在MySQL表中执行更改的方式相同，我们需要保存更改（提交）。这就是为什么我们创建了**保存更改**按钮；这样，我们将一次性将所有更改同步到服务器。
- en: 'So first, we need to add a listener to `me.control`, as follows:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要向`me.control`添加一个监听器，如下所示：
- en: '[PRE26]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Then, we need to implement the `onButtonClickSave` method:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要实现`onButtonClickSave`方法：
- en: '[PRE27]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The implementation of the method is pretty straightforward: we simply need
    to get the Store (`#2`) from the GridPanel (`#1`) and call the method `sync` (`#5`).'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的实现相当简单：我们只需要从GridPanel（`#1`）获取Store（`#2`）并调用`sync`方法（`#5`）。
- en: However, we are going to validate that the information entered in the cells
    of the Grid contain valid information. To do so, we are going to call the method
    `validate` from the grid (`#3`) and get the `errors`. If no errors were found
    (`#4`), then we `sync` the Store with the server (`#5`); otherwise, we display
    the `errors` (`#6`).
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，我们将验证在Grid的单元格中输入的信息是否包含有效信息。为此，我们将从网格（`#3`）调用`validate`方法并获取`errors`。如果没有发现错误（`#4`），则将Store与服务器同步（`#5`）；否则，显示`errors`（`#6`）。
- en: The Grid Panel does not have a validate method by default. We are going to add
    this method to the `Base` Grid Panel.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: Grid Panel默认没有验证方法。我们将向`Base` Grid Panel添加此方法。
- en: Validating cellediting in GridPanel
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证GridPanel中的单元格编辑
- en: Going back to the class `Packt.view.staticData.BaseGrid`, we are going to add
    the logic to validate a row from the grid and also the entire grid before saving.
    In this example, you will learn that we can also add useful methods to the classes
    we create; we do not need to develop all the code inside the Controller.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 回到类`Packt.view.staticData.BaseGrid`，我们将添加验证行和整个网格在保存之前的逻辑。在这个例子中，你将了解到我们也可以向创建的类中添加有用的方法；我们不需要在Controller中开发所有代码。
- en: 'The first method we are going to implement is `validateRow`. Given a record,
    we are going to validate it using Model validators, and if there are any errors,
    we will add the same form icon that Ext JS displays in the forms in case of validation
    errors in the cell that contains the error, and we will also add a tooltip in
    this cell (similar behavior from the form validation). The code for the method
    is as follows (we need to add it inside the `initComponent` method):'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的第一种方法是`validateRow`。给定一个记录，我们将使用模型验证器来验证它，如果有任何错误，我们将在包含错误的单元格中添加Ext
    JS在表单中显示的相同表单图标（在单元格验证错误的情况下），并且我们还将在此单元格中添加一个工具提示（与表单验证类似的行为）。该方法的代码如下（我们需要将其添加到`initComponent`方法中）：
- en: '[PRE28]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Given a `record` Model (`#1`), we are going to use its method `validate`. This
    method verifies that the information contained in the Model is valid according
    to the Model validators (we need to go back to the models we defined for this
    chapter and add the validators). This method returns an object with all the errors
    found in the record.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 给定一个`record`模型（`#1`），我们将使用其`validate`方法。此方法验证模型中包含的信息是否根据模型验证器有效（我们需要回到本章定义的模型并添加验证器）。此方法返回一个包含记录中所有错误的对象。
- en: Using the `isValid` method (`#2`), we can easily find out whether the Model
    is valid or not. If it is valid, we return `true` (we will use this information
    later).
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
- en: The `columnIndexes` (`#3`) is in an array that contains `dataIndex` of each
    column of the grid. This method was present in the grid panel class back in Ext
    JS 4.1, but in Ext JS 4.2, it was removed, and it is not present in Ext JS 5\.
    We are going to implement this method as well, but with the difference being that
    in this case, we are only interested in the columns that have the editor enabled
    (since we want to validate it).
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
- en: Then, for each `column` of the grid that has the editor enabled (`#4`), we are
    going to retrieve the `errors` specific for that column from the Model (`#5`).
    We are going to add each error `message` (`#6`) to an array of messages. After
    that, we are going to add the same error icon from an invalid form field to the
    grid cell (`#7`). And, at last, we are also going to add a tooltip to the cell
    with error (`#8`).
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to implement the `getColumnIndexes` function, as follows:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-266
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: For each column of the grid (`#9`), we are going to verify that the editor is
    enabled (`#10`), and if yes, we are going to add `dataIndex` to the `columnIndexes`
    array (`#11`). In the end, we return this array (`#12`).
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: 'The `validateRow` method will only work for a single row. When we click on
    the **Save Changes** button, we want to validate the entire grid. To do so, we
    are going to implement one more method inside the `initComponent`, which is called
    `validate` (the method we called in the Controller):'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: For the `validate` method, we are going to retrieve all the rows from the grid,
    and for each one (`#13`), we are going to call the `validateRow` method (`#14`).
    In line `#14`, we are also keeping track of whether any previous row `is valid`
    or not.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: In the end, we return (`#16`) `undefined` if no error was found or we return
    an object with a title and message (`#15`) that we can use in the Controller to
    display an alert.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'If we add an empty row or edit a cell with invalid information, the grid will
    display an error icon on the cell and also a tooltip when we mouse over it. The
    output will be similar to the following screenshot:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
- en: '![Validating cellediting in GridPanel](img/0457OT_07_16.jpg)'
  id: totrans-273
  prefs: []
  type: TYPE_IMG
- en: Model validators
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'To make this code work, we need to add the Model validators to `staticData`
    model. For example, for the `Actors` model, we can add the following code based
    on the database validations for the `actor` table:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'And in the `Packt.model.staticData.Base` class, we can add the `last_update`
    validator that is going to be common to all `staticData` models:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The autoSync configuration
  id: totrans-279
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Store has a configuration named `autoSync`. The default value is `false`,
    but if we set it to `true`, the Store will automatically synchronize with the
    server whenever a change is detected. This can be good, but it also can be bad—it
    depends on how we are going to use it.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we did not have the validations, the user could create an empty
    row and try to send it to the server. The server code would fail (some columns
    cannot be `null`), and this would be bad for the application. With `autoSync`
    set to `false`, the user can also choose when to save the information and the
    information can be sent in bulk instead of sending one request per action (create,
    update, or destroy)—`allowSingle` has to be set to `false` in the proxy writer
    as well.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: Canceling the changes
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the user can save the changes (commit), the user can also cancel them (rollback).
    All you have to do is to reload the Store so that you get the most updated information
    from the server, and the changes made by the user will be lost.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: 'So we need to listen to the event, as follows:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'And we need to implement the method:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-287
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If you want, you can add a message asking whether the user really wants to roll
    back the changes. Calling the `reload` method from the Store is what we need to
    do to make it work.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-289
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As an alternative to the `reload` method of the Store, we could also call the
    method `rejectChanges` instead; however, the `reload` method is more failsafe,
    since we are getting the information from the server again.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the filter
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When using the `filter` plugin on the GridPanel, it will do everything that
    we need (when used locally). But there is one thing that it doesn''t provide to
    the user: the option to clear all the filters at once. So that is why we implemented
    a **Clear Filters** button.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: 'So first, let''s listen to the event:'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'And then we can implement the method:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-296
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: When using the `filter` plugin, we are able to get a property named `filters`
    from the GridPanel. Then, all we need to do it is to call the `clearFilters` method.
    This will clear the filter values from each column that was filtered and will
    also clear the filters from the Store.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
- en: Listening to Store events in the Controller
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: And the last event we will be listening to is the `write` event from the Store.
    We already added an `exception` listener to the Proxy (in Ext JS 3, the Store
    had an exception listener, while in Ext JS 4 and 5 this listener was moved to
    the Proxy). Now we need to add a listener in case of success.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to listen to the event from the Store in the Controller. This
    feature was introduced in Ext JS 4.2.x.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `init` function of the Controller, we will add the following code:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We can listen to Store events inside the store option. The previous code will
    work for the **Actors** screen. If we want to do the same for the other screen,
    we need to add the same code as the preceding one. For example, the following
    code needs to be added for the **Categories** screen:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: We cannot use the Base Store `storeId` here because each child Store will have
    its own `storeId`.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: 'The write event is fired whenever the Store receives the response from the
    server. So let''s implement the method:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We will simply display a message saying the changes have been saved. Notice
    that the message is also generic; this way we can use it for all the static data
    modules. A screenshot of the output is as follows:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: '![Listening to Store events in the Controller](img/0457OT_07_17.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
- en: Debug tip – Sencha extension for Chrome
  id: totrans-310
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes we need to inspect a particular Ext JS component we have instantiated
    for debugging purposes. Finding which methods are available and the current attributes
    and configurations that are set in the object can be a little tricky. When working
    in MVC, we might need to find the Store ID created and the stores that are alive
    in the application. Using `console.log` to output a particular object to inspect
    it is a lot of work!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
- en: 'The Sencha Labs team released a free extension for Chrome called **Sencha App
    Inspector**. When working with Ext JS (or Sencha Touch), it is recommended that
    you use this extension to help debug the application. In the following screenshot,
    we can see the extension in action—stores that have been instantiated by the application
    and the data that has been loaded into it:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
- en: '![Debug tip – Sencha extension for Chrome](img/0457OT_07_18.jpg)'
  id: totrans-313
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about Sencha App Inspector and the download link please
    visit [https://github.com/senchalabs/AppInspector/](https://github.com/senchalabs/AppInspector/).
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: Firefox extension – Illuminations for Developers
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If your favorite browser for development is not Chrome, there is also a Sencha
    extension for Firefox (which can be used within Firebug) called Illuminations
    for Developers.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
- en: It is not a free extension (but it is possible to try it for free for a limited
    period of time), and its cost has a good cost-benefit.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, we can see the extension in action (stores that
    have been instantiated by the application and its properties):'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: '![Firefox extension – Illuminations for Developers](img/0457OT_07_19.jpg)'
  id: totrans-320
  prefs: []
  type: TYPE_IMG
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information about Illuminations for Developers and the download link,
    please visit [http://www.illuminations-for-developers.com/](http://www.illuminations-for-developers.com/).
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to implement screens that look very similar
    to the MySQL Table Editor. The most important concept we covered in this chapter
    is implementing abstract classes, using the inheritance concept from OOP. We are
    used to using these concepts on server-side languages, such as PHP, Java, .NET,
    and so on. This chapter demonstrated that it is also important to use these concepts
    on the Ext JS side; this way, we can reuse a lot of code and also implement generic
    code that provides the same capability for more than one screen.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: 'We created a Base Model, Store, View and a Controller. We used the following
    plugins: `celleditor` for the GridPanel and Live Search grid and `filter` plugin
    for the GridPanel as well. You learned how to perform CRUD operations using the
    Store capabilities. You also learned how to create custom events and handle Widget
    Column events on the Controller. We also explored many of the MVC Controller capabilities
    in this chapter.'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个基础模型、存储、视图和控制器。我们使用了以下插件：`celleditor` 用于 GridPanel 和 Live Search 网格，以及
    `filter` 插件用于 GridPanel。你学习了如何使用 Store 的功能来执行 CRUD 操作。你还学习了如何在控制器上创建自定义事件和处理 Widget
    Column 事件。在本章中，我们还探索了许多 MVC 控制器的功能。
- en: Note
  id: totrans-326
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Reminder: you can get the complete source code for this chapter (with extra
    capabilities and server-side code) by downloading the code bundle from this book
    or from the GitHub repository [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 提醒：你可以通过从本书或 GitHub 仓库 [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs)
    下载代码包来获取本章（包含额外功能和服务器端代码）的完整源代码。
- en: In the next chapter, you will learn how to implement the Content Management
    module, which goes further than just managing one single table as we did on this
    chapter. We will manage information from other tables (related to the business
    of the application) and all its relations within the database.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习如何实现内容管理模块，这比本章中仅管理单个表要深入得多。我们将管理来自其他表（与应用程序的业务相关）的信息及其在数据库中的所有关系。
