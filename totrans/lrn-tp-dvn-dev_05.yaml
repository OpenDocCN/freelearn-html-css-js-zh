- en: Putting Alternative Values in Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how to build values that capture multiple types
    of values together, and the different ways that we can build those types. This
    lets us say that we have a value of the composite (product) type only if we have
    *all* of the values of their composed types. Sometimes though, we need values
    that must be *only one* type out of several types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover these *only one* types, namely:'
  prefs: []
  type: TYPE_NORMAL
- en: Variant types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphic variant types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generalized algebraic data types
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collectively, these types are known as *sum types* because the number of possible
    values that a sum type can contain is the *sum* of the number of possible values
    of each of its component types. We'll see how this is true in this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Variant types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Variant types are Reason''s simple, idiomatic sum types. You can think of them
    as similar to enums (a limited set of values that are declared to form a type)
    from other languages, only more powerful because each *variant case* (possible
    alternative value) can optionally carry a payload inside it. Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This module defines some types for storing someone''s education level and a
    payment method of either cash or purchase order:'
  prefs: []
  type: TYPE_NORMAL
- en: Variant type definitions start with `type typeName =` just like any other type
    of definition, and have one or more *variant constructors* (also known as *data
    constructors*) on the right-hand side of the equals sign. These constructors all
    have the exact same type and can be used as literal values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Variant constructors must start with an uppercase letter and can each carry
    any number of payloads, as defined within parentheses. This can be a comma-separated
    list of types that will make up the payload. Here we defined the `poNumber` type
    instead of just using `string` directly, to make the code more self-documenting.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can use variant cases directly as literal values. Now, `bobEducation` has
    the type `education`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For variant constructors that carry payloads, we can pass them in as a comma-separated
    list between parentheses, a syntax that mirrors their definition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first variant type, `education`, is a simple one that we can find in a lot
    of languages. It just defines an allowed set of values for a person's education.
    Of course, this may not be realistic in all scenarios, but sometimes we just need
    types to be realistic enough to model our problem.
  prefs: []
  type: TYPE_NORMAL
- en: The next variant type, `paymentMethod`, is the really interesting one. It's
    saying that valid payment methods are cash or a purchase order with a PO number.
    Note that for cash we don't need any extra info, but for a purchase order we require
    its number; it's impossible to describe a PO with a corresponding number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about this for a second. To represent a payment method in other
    languages, you might do something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice the problem? Nothing''s stopping us from creating objects with `type:
    ''PaymentMethod.Cash''` and a `poNumber` property, or even worse, `type: ''PaymentMethod.PurchaseOrder''`
    and no `poNumber` property. We''d have no static guarantees that purchase orders
    would always have an associated ID. Variant types give us this static guarantee.'
  prefs: []
  type: TYPE_NORMAL
- en: Pattern matching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can construct variant values easily enough—just type in the variant constructors
    and give them any data they need. But variants really shine when we work with
    their values.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, suppose you want to write a function that returns a thank you
    message for any given payment. Part of the message will hinge on the payment method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will introduce some new syntax here:'
  prefs: []
  type: TYPE_NORMAL
- en: We use a **type equation** to tell the compiler that this variant type defined
    in this module is the same as the other variant type defined in `Ch05_Variants`,
    and crucially that its constructors are also exactly the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We **pattern match** on the given payment method using Reason's `switch` expression,
    which can **destructure** data that can match against patterns.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We could have simply redefined the variant type in both modules; but variant
    types in Reason are nominal (that is, even the same variant type definition is
    considered a distinct type if it's in a different module) unless we use a type
    equation. In this simple example it's not critical that the compiler equates the
    two types, but sometimes in a Reason codebase, you'll want to *bring in* the variant
    constructors from another module for ease of access. Otherwise, you'll need to
    either open the other module (risky) or prefix the constructors with the modules
    (verbose), for example, `Ch05_Variants.Cash`.
  prefs: []
  type: TYPE_NORMAL
- en: The power of switch
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we saw how to use the `switch` expression. But that
    barely scratched the surface of what `switch` can do. Switch expressions match
    against arbitrary patterns and evaluate the branch that corresponds to the *first*
    matching pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a slightly more formal syntax for a switch expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This entire syntactic form evaluates to a single value. Each subsection of the
    expression that starts with a bar character (`|`) is called a **branch**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The steps for evaluating the expression are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Evaluate `expr`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Match the  value of `expr` against `pat1`; if it matches, evaluate the entire
    expression to `res1` and ignore all the other branches.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Otherwise, continue matching the value against each pattern in turn, and evaluate
    to the first result that corresponds to the matching pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If none of the patterns match, throw a runtime error (called an exception),
    `Match_failure`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Each branch of the expression must have the same return type for it to compile.
    Note that the order of the branches may or may not be important, depending on
    what kind of patterns we're matching. If we're matching against a variant type's
    exact cases, order is not important because variant cases naturally don't have
    any concept of *ordering*. That is, even if we defined `Cash` before `PurchaseOrder`
    in the `paymentMethod` type definition, that doesn't mean that `Cash` is intrinsically
    *less* than `PurchaseOrder`. There is no precedence.
  prefs: []
  type: TYPE_NORMAL
- en: However, patterns don't have to be variant cases. They can be any valid combination
    of names and literal values. In this context, a name is anything that is a valid
    Reason identifier, such as `age` or `_123`. Literal values include variant cases,
    but also values of basic types such as `char`, `string`, `int`, `float`, and so
    on; and also tuples and record values. If a pattern matches against the input
    expression, any names it contains get *bound* to the relevant parts of the expression
    and are made available in the scope of the result expression on the right-hand
    side of the `=>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With name binding, literal values, and ordering, patterns can get quite sophisticated;
    let''s see a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few interesting things here:'
  prefs: []
  type: TYPE_NORMAL
- en: We're switching on an `int` ID, listing multiple alternative patterns on a single
    line, separated by bars. Patterns are in fact recursively defined; this means
    that patterns can contain more patterns! In other words, we can combine several
    individual patterns, such as `1`, `2`, and so on, with the vertical bar to indicate
    that any of these should match. This is called an **or pattern**. Note that the
    ordering of the patterns means that at runtime, the input ID will first be checked
    against the numbers 1 to 5, and only then with the other patterns. In this pattern
    match, the underscore symbol (`_`) means *anything, I don't care and don't bind
    the value*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Given a `person` value, we switch on its name and ID. We're actually switching
    on a single expression; the expression `(person.id, person.name)` is a tuple that
    we create on the spot and match against immediately. The really interesting thing
    here is the ordering of the patterns. We're expressing the logic that we always
    show a special message for Dave, and if it's not Dave and if it's someone with
    ID 1, we greet them as the boss, and only if it's not Dave or the boss, we greet
    the person by name and ID.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `greet2`, we switch on the `person` directly using record literal patterns
    and express the same ordered logic as before, only this time we don't need to
    construct a temporary tuple since we know we can pattern match directly against
    records. There's not necessarily a performance benefit to this, but you may find
    the code slightly neater–it's subjective.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pattern matching can handle quite sophisticated data structures, because of
    the special property of patterns that they are *composable.* However, with this
    great power come two warnings: first, we need to understand the order in which
    we list the branches of our switch expressions so that we don''t get unexpected
    results; second, we need to avoid potential runtime errors arising from the use
    of refutable patterns.'
  prefs: []
  type: TYPE_NORMAL
- en: Refutable patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s important to understand that the `switch` expression is one form of pattern
    matching in Reason, out of three:'
  prefs: []
  type: TYPE_NORMAL
- en: Switch expression
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let binding (see [Chapter 2](ff0971a6-9cf3-4680-8010-47acb7663764.xhtml), *Program
    with Types and Values*)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Function arguments (we'll cover functions in a future chapter)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'With all three forms of pattern matching, we run the risk of runtime errors
    if we use refutable patterns incorrectly. *Refutable patterns* are patterns that
    type-check, but could *potentially* fail at runtime. Here are a couple of simple
    examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Surprised by `let 3 = 3`? Remember that the left-hand side of the equals sign
    can be any pattern–even a single literal value! Also, let `PurchaseOrder(poNumber)
    = ...` is a destructuring of a variant case, not a function definition. The difference
    is the case of the first letter, `P`. Remember that Reason modules and data constructors
    start with an uppercase letter, while types and values start with a lowercase
    letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try the first binding, you''ll see the following warning:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not really obvious what the problem is: the value being bound is literally
    3, it could never be 0, so how could we forget to handle it? The thing to realize
    is that the compiler looks only at the types–it sees that we used a refutable
    pattern of type `int`, and warns us about the simplest `int` that it knows we
    didn''t handle: `0`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try the second:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, it''s quite obvious: at runtime, the `getPoNumber` function could
    get called with the `Cash` value (because that type-checks!) but it doesn''t know
    how to handle it. There''s nothing it can do but throw a runtime error. The compiler
    figures this out in the same way as before, by looking at the `paymentMethod`
    type and looking for values of the type that it knows weren''t handled.'
  prefs: []
  type: TYPE_NORMAL
- en: This feature that checks if we handled all possible patterns of any given type
    is called **exhaustivity checking** and is one of the most powerful and useful
    features of Reason's type system. It's also present in a few languages that are
    either derived from the same ML (Meta Language) heritage as Reason or took inspiration
    from it. No matter what language, if you have exhaustivity checking at your disposal,
    try to use it as much as possible because it's a great safety net.
  prefs: []
  type: TYPE_NORMAL
- en: The when clause and general branching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Not only do switch expressions pattern match on their inputs, but they can
    also add a general test condition called a `when` **clause** to the end of each
    pattern. This lets you check completely general conditions in each branch to match
    against that branch. Note that using a `when` clause does give up exhaustivity
    checking, though, so before reaching for it, think about if you can do without.
    Sometimes, you just can''t. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This code sample shows a scenario for using a `when` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: We redefine the types we need and equate them for interoperability. Strictly
    speaking, in this case, we didn't need to do that. But in most real-world code,
    you would.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We add a `when` clause to the `PurchaseOrder(poNumber)` base pattern to check
    that the PO number starts with the word ACME. This is something we can't do with
    pattern matching because we can't match against parts of strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also evaluate the branch to a `Some(poNumber)`. `Some` is a built-in data
    constructor that expresses the idea that *there is a value here (as opposed to
    no value)*. It actually accepts *any* type, not just a `string`, and we'll see
    how that works in the next chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The case where the PO number doesn't start with the word ACME evaluates to `None`,
    which is the same type as `Some(whatever)`, but it expresses the idea that *there's
    no value here*. The type of `Some(whatever)` and `None` is a variant type `option(whateverType)`,
    and it's very useful for safely passing around values that might not logically
    exist. In this case, it's useful for our function `getAcmeOrder` because, given
    any payment method at runtime, it might not actually contain an ACME purchase
    order, so we need a way to say *it's not an ACME PO*, and `None` gives us that.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reason also has a traditional `if`-`else` syntax, which is also an expression
    and evaluates to a value. Both the `if` and `else` branches must evaluate to values
    of the same type; if we leave out the `else` branch, it's assumed to evaluate
    to `()` of type `unit`. In Reason, `()`—pronounced *unit*—roughly means the same
    thing that `void` means in C, C++, and so on, except that it's an actual assignable
    value and it can come in handy sometimes. In the case of `if` expressions, concretely
    this means that we should either include an `else` clause or ensure that the `if`
    clause evaluates to type `unit`. Typically, this happens with functions that carry
    out an action and don't evaluate to a useful value, for example, `Js.log("Hello")`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: So far in this book, we've seen a couple of types that look like `typeName(typeParam)`,
    but we haven't delved into what they are or how they work. In the next chapter,
    we'll learn about parameterized types and how they can help write safe, reusable
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Stricter safety checks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It''s worth digressing a bit to the compiler''s exhaustivity check warning.
    As you''ll recall, it looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The problem with a compile warning is that it doesn't fail the compile. We can
    end up with code running in production that type-checked, but is not actually
    type-safe, because it forgot to handle some corner case. It would really be ideal
    if we could tell the compiler to fail the compile if it finds any non-exhaustive
    patterns, so we can rule out shipping them to production.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, we can tell the compiler to *promote* a warning to an error. In
    our case, since we''re using a BuckleScript project, we can edit the `bsconfig.json`
    file slightly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: After editing the file, we can restart `bsb -w` to have the new setting take
    effect. The `"warnings"` property contains an object with potentially a couple
    of properties, one of which is an `"error"` property that has a corresponding
    string value listing the warning numbers that we want to promote into errors with
    the `"+NUM"` syntax. We can get the exact number from the compiler warning message
    (see preceding snippet).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, this same warning will fail the compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Now the compiler will stop the compiling when it encounters a *fatal warning* and
    we can enjoy safer pattern matching.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic variant types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Reason''s variant types are conceptually simple, much of their power
    comes from the ability to use them with pattern matching and exhaustivity checking.
    Reason also provides a more powerful, but also more complex sum type, called **polymorphic
    variants***.* As the name suggests, these variants are more flexible than regular
    variants. Here are a few things that we can do with polymorphic variants, but
    not with regular variants:'
  prefs: []
  type: TYPE_NORMAL
- en: Create values without defining the types beforehand, letting the compiler infer
    the type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Compose multiple sets of variant cases together
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define functions that handle *at least* a set of variant cases as input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define functions that output *at most* a set of variant cases as output
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a sense, we can think of polymorphic variants as being related to regular
    variants in the same way that objects are related to records. They are, in fact,
    structural types in the same way that objects and modules are because the compiler
    infers the types of values by inspecting their structures.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and typing values
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s see a few examples to get a feel for how polymorphic variants work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot of new syntaxes here, but hopefully it should look somewhat
    similar to regular variant syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: We can define an adhoc polymorphic variant value and let the compiler figure
    out its type. In this case, the editor support should show us a type ``[> `Red]``.
    This means a polymorphic variant type that has at least the `` `Red `` data constructor
    that I've seen, and possibly more. The brackets (`[...]`) around the type syntactically
    distinguish it from regular variants and also suggest that we should think of
    it as like a bounded set.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphic variant constructors can contain payloads just like regular variant
    constructors. Also, unlike regular constructors, polymorphic constructors can
    start with a lowercase letter. This is still unambiguous though because polymorphic
    variant constructors must always be prefixed with a back-tick character.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can explicitly define polymorphic variant types using the syntax shown. Note
    that the compiler doesn't automatically infer any later values that use the defined
    constructors as being of the defined type. I'll explain this a bit more in the
    *fifth* point.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Polymorphic variant types can compose other polymorphic variant types and become
    an expanded set of cases. This lets us model cases that can be considered part
    of the set (type), but can also be considered separately, for example, device
    input events.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We must explicitly annotate a value with a polymorphic variant type to tell
    the compiler that it must be *exactly* this type. Without this annotation, within
    the module the compiler will infer the type from the structure of the data constructor,
    that is, in this case ``[> `keypress(char)]``. Note that declaring the exact types
    of the polymorphic variant values in module signatures will work, but only from
    the point of view of other modules, not internally within the module. Usually,
    that's good enough!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can''t declare that a polymorphic variant constructor has some type if that
    type doesn''t actually declare the constructor first. Here''s what the error would
    look like:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can visualize the error as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d205b705-478c-4df8-8136-cd6a8659f9aa.png)'
  prefs: []
  type: TYPE_IMG
- en: Polymorphic variant type mismatch
  prefs: []
  type: TYPE_NORMAL
- en: Inputting values into functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we can create polymorphic variant values, let''s do something useful
    with them. How can we handle a value that we get at runtime? It turns out, the
    same way we''d handle a normal variant: pattern matching:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can pattern match on an input polymorphic variant data constructor the same
    way we''d match against a regular constructor: by writing out the constructor
    as a pattern and binding any of its contained data that we want to use.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We use a BuckleScript-specific string interpolation syntax for convenience
    here: `{j| ... $name ... |j}`. The `name` must be in scope, and it must be only
    a name, not an arbitrary expression such as `1 + 2`. The `{j|` and `|j}` act as
    string delimiters and can be used for multiline and Unicode string literals as
    well.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can call the function with any value that conforms to its inferred input
    type, which `pressA` does because we made sure both its type and our new function
    have the same polymorphic variant cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can as usual pattern match directly with a `let`-binding, but notice that
    there's no exhaustivity warning here. The compiler now doesn't know what other
    cases there might be, so it doesn't warn us. For this reason, it's best to avoid
    let-binding pattern matching of polymorphic variant values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Understanding polymorphic variant inference
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have type hinting enabled in your editor, it should tell you that the
    type of `eventToString` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The compiler alphabetizes the variant cases when printing them out, but just
    like with regular variants, the cases don't have any intrinsic ordering.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function type is divided into two main parts: the input on the left of
    the arrow, and the output on the right. The input is a polymorphic variant type
    that can contain any of the listed cases or less, and these cases can have payloads
    in the given positions. Notice that the payloads all have types that look like
    `''x`, that is, starting with an apostrophe character. As we mentioned before,
    this character means that this type will be filled in later. Specifically, it''s
    known as a type parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: The most important thing to understand about this inferred function type is
    that the input polymorphic variant is given an upper bound (`<`), meaning this
    function can handle a polymorphic variant type that has these cases, and also
    polymorphic variant types that have a *subset* of these cases, but it certainly
    can't handle any *more* cases.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's tackle the reason why all the payload types are going to be filled
    in later. We already know that they're just ints and floats. Why couldn't the
    compiler figure that out?
  prefs: []
  type: TYPE_NORMAL
- en: It turns out that when we used the payloads in BuckleScript's special string
    interpolation syntax sugar, the compiler was never told what their exact types
    were. String interpolation just lets us stuff anything in a JavaScript string,
    without having to be specific to the compiler as we usually would, for example,
    with a string concatenation such as `"Hello" ++ " world"`. This is very convenient
    for producing output, but can lead to pitfalls where the compiler can't infer
    a type; so it's good to be aware of this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Overall, notice the important safety property we achieve that''s very similar
    to the type safety of objects: we can (to a certain extent) use adhoc variant
    constructors safely with the compiler''s help.'
  prefs: []
  type: TYPE_NORMAL
- en: Outputting values from functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'What if we want to go in the opposite direction? That is, output polymorphic
    variant values from functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, two interesting things happen:'
  prefs: []
  type: TYPE_NORMAL
- en: The compiler does exhaustivity checking on the input, which is a string, so
    we need to handle *all* possible string inputs (the last one is the catch-all)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The compiler swaps the polymorphic variant type''s bound, making the type (of
    the function):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This time, the compiler infers a *lower bound* for the polymorphic variant return
    type, because it seems that the function returns those cases and it may potentially
    return more, but it will certainly never return *fewer* cases.
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphic variant types are a deep and powerful part of Reason, and we'll
    explore them a bit more in the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Generalized algebraic data types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Generalized algebraic data types** (**GADTs**) are another deep and powerful
    area of the language. As with polymorphic variant types, much of their true power
    is exposed when they''re used with type parameters. But we can understand their
    surface syntax and how they relate to regular variant types, for now.'
  prefs: []
  type: TYPE_NORMAL
- en: 'GADTs are, as the name suggests, a generalized form of algebraic data types.
    The name is a slight misnomer because they are really more of a generalized form
    of regular variant types only. *Algebraic data types* is a general name for both
    product and sum types taken together. Syntactically, GADTs look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: GADT definition syntax looks much like regular variant definition syntax, except
    that the data constructors explicitly declare their type at the end. For monomorphic
    types (that is, ones that don't have any type parameters), this doesn't look very
    useful. In the next chapter, we'll see why it's so powerful.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Value construction looks the same as for regular variants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pattern matching also looks the same as for regular variants.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Designing for correctness with types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've seen the product and sum types in action, let's take a step back
    and ask how they can work together. Intuitively, product types let us group values
    together, and sum types let us choose one among a restricted set of values. Together,
    they express a wide range of data modeling scenarios. Let's look at a couple of
    examples.
  prefs: []
  type: TYPE_NORMAL
- en: Products and sums together
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, a simple example to warm up. Suppose we''re asked to track the following
    attributes of a person for a Customer Relationship Management software:'
  prefs: []
  type: TYPE_NORMAL
- en: 'ID number: A string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Name: A string'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Education level: O*ne of* school, college, postgrad, or other'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A valid person record must have *all of* these attributes. Notice how we''re
    using the specific phrasing *one of* and *all of*. These give us a hint about
    how to model the data: *one of* means a sum type and *all of* means a product
    type! It''s very useful to think about the requirements in these terms as we break
    down a data structure into its component parts.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The main choice after that is specifically which implementations of product
    and sum types to use. Usually, we''ll reach for the simplest possible implementations:
    records and variants. So, in this case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The person record type `Ch05_CrmPerson.t` is a record type composed out of
    three other types: an `int`, a `string`, *and* an `education`. The `education`
    type is a variant type that admits *one of* the four legal education values.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The valid `t` values are built by grouping together all the required component
    values, including the `education` values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Notice how the values are constructed by obeying the business logic laid out
    by the types: for a person record, we need an ID, a name, and an education; for
    an education value, we need only one of the allowable values.'
  prefs: []
  type: TYPE_NORMAL
- en: Recursive types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's look at a more interesting example. Suppose we need to model not
    just one, but a *list* of person records. Suppose we also need to be able to walk
    through this list, one person at a time, and carry out some actions based on the
    data from each person. A natural data structure for this would be a *singly linked
    list.* As you might know, a singly linked list is a series of nodes that each
    point to the next node in the list, or to *nothing* in case there is no next node
    (that is, for the last node of the list).
  prefs: []
  type: TYPE_NORMAL
- en: 'In Reason, a natural way to model this list is with a recursive variant type.
    A *recursive type* is one that contains values of its *own* type. This neat trick
    works because Reason internally separates the storage of values from their types,
    so they don''t end up taking infinite storage. Here''s an example implementation
    of our person record list scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Using a recursive type reveals some new and interesting syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The type definition of a recursive type doesn''t look any different from what
    we saw before, except that it contains a reference to its own type. We''re not
    having to do anything special because, in Reason, all type definitions are recursive
    by default. In fact, if we want to make a type definition *non-recursive* (which
    we do in some circumstances), we''ll need to use an extra keyword: `type nonrec
    t = ...`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can define a value of a recursive type like normal, except it can contain
    other values of its own type. We locally open the `Ch05_CrmPerson` module to get
    access to the people values defined there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To walk through all the values of a recursive type, we'll usually need a *recursive
    function* (that is, a function that calls itself). Unlike types, functions aren't
    recursive by default, because traditionally recursive functions are slightly more
    expensive in terms of runtime performance. So when we need recursion, we specify
    it with the `let rec ...` syntax.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can destructure a recursive value in the normal way, just as if it were non-recursive;
    we just need to make sure we pass its recursive portion, `list`, into the recursive
    `greet` call.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To handle the non-recursive portion of `Ch05_PersonList.t` (`Empty`), we just
    need to *do nothing*, so we return unit, the *empty value*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our recursive `greet` function has an interesting property: it is tail-recursive.
    *Tail recursion* is the property that a recursive function has if it calls itself
    in tail position, that is, if it calls itself as the last (tail) operation of
    any of its branches of evaluation. For example, `greet` calls itself as the last
    operation of its first branch, where it handles the `Node` variant case.'
  prefs: []
  type: TYPE_NORMAL
- en: We're paying attention to this tail recursion property because the BuckleScript
    compiler has a special ability to convert tail recursion into a simple, efficient
    loop in the output JavaScript. If you examine the output, you'll see that the
    loop looks almost handwritten.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we covered what collectively are known as sum types: variants
    and pattern matching, polymorphic variants, and GADTs. These are some of the bread-and-butter
    typing techniques in Reason, and they enable powerful data modeling techniques
    when used in the right combinations.'
  prefs: []
  type: TYPE_NORMAL
- en: However, it's becoming increasingly clear that a lot of typing power still remains
    to be explored. In the next chapter, we will fully cover the type parameters (generics)
    that we've glimpsed at so far while using different kinds of type techniques.
  prefs: []
  type: TYPE_NORMAL
