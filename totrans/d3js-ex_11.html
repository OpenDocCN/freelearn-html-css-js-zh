<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch11"/>Chapter 11. Visualizing Information Networks</h1></div></div></div><p>In this chapter, we will examine a specific type of layout known as a <strong>force-directed graph</strong>. These are a <a id="id506" class="indexterm"/>type of visualization that are generally utilized to display network information: interconnected nodes.</p><p>A particularly common type of network visualization is of the relationships within a social network. A visualization of a social network can help you understand how different people have formed various relationships. These include links between others as well as the way groups of people form clusters or cliques of friends and how those groups interrelate.</p><p>D3.js provides extensive capabilities for creating very complex network visualizations using force-directed networks. We will overview a number of representative examples of these graphs, cover a little bit of the theory of how they operate, and dive into a few examples to demonstrate their creation and usage.</p><p>Specifically, in this chapter we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A brief overview of force-directed graphs</li><li class="listitem" style="list-style-type: disc">Creating a basic force-directed graph</li><li class="listitem" style="list-style-type: disc">Modifying the length of the links</li><li class="listitem" style="list-style-type: disc">Forcing nodes to move away from each other</li><li class="listitem" style="list-style-type: disc">Labeling the nodes</li><li class="listitem" style="list-style-type: disc">Forcing nodes to stay in place</li><li class="listitem" style="list-style-type: disc">Expressing directionality and type with link visuals</li></ul></div><div><div><div><div><h1 class="title"><a id="ch11lvl1sec51"/>An overview of force-directed graphs</h1></div></div></div><p>There are a <a id="id507" class="indexterm"/>number of means of rendering network data. A particularly common one, which we will examine in this chapter, is to use a class of algorithms known as <a id="id508" class="indexterm"/>force-directed layouts.</p><p>These algorithms position the nodes in the graph in a two or three dimensional space. The positioning is performed by assigning forces along edges and nodes, and then these forces are used to simulate moving the nodes into a position where the amount of energy in the entire system is minimized.</p><p>The following is a representative picture of a force-directed graph from a Wiki. Nodes are pages, and the lines between the nodes represent the links between the pages. Node size varies based on the number of links in/out of a particular node:</p><div><img src="img/B04320_11_01.jpg" alt="An overview of force-directed graphs"/></div><p>The fundamental components of a force-directed graph are the nodes in the graph and the relations between those nodes. The graph is iteratively laid out, usually animated during the process, and can take quite a few iterations to <strong>stabilize</strong>.</p><p>The force layout algorithm in D3.js takes into account a number of factors. A few of the important parameters of the <a id="id509" class="indexterm"/>algorithm and how they influence the simulation are the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Size (width and height)</strong>: This represents an overall size of the diagram, and a center of gravity, normally the center of the diagram. Nodes in the diagram will tend to move towards this point. If nodes do not have an initial <code class="literal">x</code> and <code class="literal">y</code> position, then they will be placed randomly in a position between 0 and width in the <code class="literal">x</code> direction and height in the <code class="literal">y</code> direction.</li><li class="listitem" style="list-style-type: disc"><strong>Charge</strong>: This describes how much a node attracts other nodes. Negative values push away other nodes, and positive numbers attract. The larger the value in either direction, the stronger is the force in that direction.</li><li class="listitem" style="list-style-type: disc"><strong>Charge distance</strong>: This specifies the maximum distance over which charge has effect (it defaults to infinity). Smaller values assist in performance of the layout, and result in a more localized layout of nodes in clusters.</li><li class="listitem" style="list-style-type: disc"><strong>Friction</strong>: Represents an amount of velocity delay. This value should be in the range of <code class="literal">[0, 1]</code>. At each tick of the layout, the velocity of every node is multiplied by this value. Using a value of 0 therefore, freezes all nodes in place, and <code class="literal">1</code> is a frictionless environment. Values in between eventually slow the nodes to a point where overall motion is small enough, and the simulation can be considered complete as the total amount of movement falls below the layout threshold at which point the graph is referred to as stable.</li><li class="listitem" style="list-style-type: disc"><strong>Link distance</strong>: This specifies a desired distance between nodes at the end of the simulation. At each tick of the simulation, the distance between linked nodes is compared to this value, and nodes move towards or away from each other to try to reach the desired distance.</li><li class="listitem" style="list-style-type: disc"><strong>Link strength</strong>: This is a value in the range of <code class="literal">[0, 1]</code>, specifying how stretchable the link distance is during the simulation. A value of 0 is rigid and <code class="literal">1</code> is completely flexible.</li><li class="listitem" style="list-style-type: disc"><strong>Gravity</strong>: This specifies an attraction of each node to the center of the layout. This is a weak geometric constraint. That is, the higher the overall gravity, the further away it is from the center of the rendering. This value is useful for keeping layouts relatively centered in the diagram and in keeping disconnected nodes from flying out to infinity.</li></ul></div><p>We will go over <a id="id510" class="indexterm"/>enough of these parameters to get a good feel for making useful visualizations.</p><div><div><h3 class="title"><a id="note130"/>Note</h3><p>More detail on <a id="id511" class="indexterm"/>all the layout parameters is available at <a class="ulink" href="https://github.com/mbostock/d3/wiki/Force-Layout">https://github.com/mbostock/d3/wiki/Force-Layout</a>.</p></div></div><p>In addition to the parameters that facilitate the actual layout of the nodes, it is also possible to use other visual in a force-directed graph to convey various values in the underlying information:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The color of a node can be used to distinguish nodes of particular types, such as people versus employers, or by their relation, such as all persons who work at a particular employer, or how many degrees of separation the node is from another node.</li><li class="listitem" style="list-style-type: disc">The size of a node, which generally represents the magnitude of importance of the node. Often the number of links influence the size of a node.</li><li class="listitem" style="list-style-type: disc">The thickness of the rendering of a link can be used to demonstrate that certain links have more influence than others or that the links are of particular types, that is, highways versus railways.</li><li class="listitem" style="list-style-type: disc">The directionality of link, showing that the link has either no directionality or is one or bi-directional.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec52"/>A simple force-directed graph</h1></div></div></div><p>Our first <a id="id512" class="indexterm"/>example will demonstrate how to construct a force-directed graph. The online example is available at the following link:</p><div><div><h3 class="title"><a id="note131"/>Note</h3><p>bl.ock (11.1): <a class="ulink" href="http://goo.gl/ZyxCej">http://goo.gl/ZyxCej</a>
</p></div></div><p>All our force-directed <a id="id513" class="indexterm"/>graphs will start by loading data that represents a network. This example uses the data at <a class="ulink" href="https://gist.githubusercontent.com/d3byex/5a8267f90a0d215fcb3e/raw/ba3b2e3065ca8eafb375f01155dc99c569fae66b/uni_network.json">https://gist.githubusercontent.com/d3byex/5a8267f90a0d215fcb3e/raw/ba3b2e3065ca8eafb375f01155dc99c569fae66b/uni_network.json</a>.</p><p>The following are the contents of the file at the preceding link:</p><div><pre class="programlisting">{
  "nodes": [
    { "name": "Mike" },
    { "name": "Marcia" },
    { "name": "Chrissy" },
    { "name": "Selena" },
    { "name": "William" },
    { "name": "Mikael" },
    { "name": "Bleu" },
    { "name": "Tagg" },
    { "name": "Bob" },
    { "name": "Mona" }
  ],
  "edges": [
    { "source": 0, "target":  1 },
    { "source": 0, "target":  4 },
    { "source": 0, "target":  5 },
    { "source": 0, "target":  6 },
    { "source": 0, "target":  7 },
    { "source": 1, "target":  2 },
    { "source": 1, "target":  3 },
    { "source": 1, "target":  5 },
    { "source": 1, "target":  8 },
    { "source": 1, "target":  9 },
  ]
}</pre></div><p>The force-directed layout algorithms in D3.js require the data to be in this format. This needs to be an object with a <code class="literal">nodes</code> and an <code class="literal">edges</code> property. The <code class="literal">nodes</code> property can be an array of any other objects you like to use. These are typically your data items.</p><p>The <code class="literal">edges</code> array must <a id="id514" class="indexterm"/>consist of objects with both <code class="literal">source</code> and <code class="literal">target</code> properties, and the value for each is the index into the <code class="literal">nodes</code> array of the source and target nodes. You can add other properties, but we need to supply at least these two.</p><p>To start rendering the graph, we load this data and get the main SVG element created:</p><div><pre class="programlisting">var url = 'https://gist.githubusercontent.com/d3byex/5a8267f90a0d215fcb3e/raw/ba3b2e3065ca8eafb375f01155dc99c569fae66b/uni_network.json';
d3.json(url, function(error, data) {
    var width = 960, height = 500;
    var svg = d3.select('body').append('svg')
        .attr({
            width: width,
            height: height
        });</pre></div><p>The next step is to create the layout for the graph using <code class="literal">d3.layout.force()</code>. There are many options, several of which we will explore over the course of our examples, but we start with the following:</p><div><pre class="programlisting">var force = d3.layout.force()
    .nodes(data.nodes)
    .links(data.edges)
    .size([width, height])
    .start();</pre></div><p>This informs the layout about the location of the nodes and links using the <code class="literal">.node()</code> and <code class="literal">.link()</code> functions respectively. The call to <code class="literal">.size()</code> informs the layout about the area to constrain the layout within and has two effects on the graph: the gravitational center and the initial random position.</p><p>The call to <code class="literal">.start()</code> begins the simulation, and must be called after the layout is created and the nodes and links are assigned. If the nodes and links change later, it can be called again to <a id="id515" class="indexterm"/>restart the simulation. Note that the simulation starts after this function returns, not immediately. So, you can still make other changes to the visual.</p><p>Now we can render the links and nodes:</p><div><pre class="programlisting">var edges = svg.selectAll('line')
    .data(data.edges)
    .enter()
    .append('line')
    .style('stroke', '#ccc')
    .style('stroke-width', 1);

var colors = d3.scale.category20();
var nodes = svg
    .selectAll('circle')
    .data(data.nodes)
    .enter()
    .append('circle')
    .attr('r', 10)
    .attr('fill', function(d, i) {
        return colors(i);
    })
    .call(force.drag);</pre></div><p>Note that we also chained the <code class="literal">.call()</code> function passing it a reference to the <code class="literal">force.drag</code> function of our layout. This function is provided by the layout object to easily allow us a means of dragging the nodes in the network.</p><p>There is one more step required. A force layout is a simulation and consists of a sequence of <strong>ticks</strong> that we must handle. Each tick represents that the layout algorithm has passed over the nodes and recalculated their positions, and this gives us the opportunity to reposition the visuals.</p><p>To hook into the ticks, we can use the <code class="literal">force.on()</code> function, telling it that we want to listen to <code class="literal">tick</code> events, and on each event, call a function to allow us to reposition our visuals. The following is <a id="id516" class="indexterm"/>our function for this activity:</p><div><pre class="programlisting">force.on('tick', function() {
    edges.attr({
        x1: function(d) { return d.source.x; },
        y1: function(d) { return d.source.y; },
        x2: function(d) { return d.target.x; },
        y2: function(d) { return d.target.y; }
    });

    nodes.attr('cx', function(d) { return d.x; })
         .attr('cy', function(d) { return d.y; });
});</pre></div><p>On each tick, we need to reposition each node and edge appropriately. Notice how we are doing this. D3.js has added to our data <code class="literal">x</code> and a <code class="literal">y</code> properties, which are the calculated position. It also has added a <code class="literal">px</code> and <code class="literal">py</code> property to each data node, which represents the previous <code class="literal">x</code> and <code class="literal">y</code> position.</p><div><div><h3 class="title"><a id="note132"/>Note</h3><p>You can also use <code class="literal">start</code> and <code class="literal">end</code> as parameters of the <code class="literal">on()</code> method to trap when the simulation begins and completes.</p></div></div><p>On running this, the output will be similar to the following:</p><div><img src="img/B04320_11_02.jpg" alt="A simple force-directed graph"/></div><p>Every time this example is executed, the nodes will finish in a different position. This is due to the algorithm specifying a random start position for each node.</p><p>The nodes are very close in this example, to the point where the links are almost not visible. But it is possible to drag the nodes with the mouse, which will expose the links. Also notice that the layout is executed while you drag and the nodes snap back to the middle when the dragged node is released.</p></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec53"/>Using link distance to spread out the nodes</h1></div></div></div><p>These <a id="id517" class="indexterm"/>nodes in the previous example are a <a id="id518" class="indexterm"/>little too close together and we have a hard time seeing the edges. To add more distance between the nodes, we can specify a link distance. This is demonstrated by the following example:</p><div><div><h3 class="title"><a id="note133"/>Note</h3><p>bl.ock (11.2): <a class="ulink" href="http://goo.gl/dd1T3O">http://goo.gl/dd1T3O</a>
</p></div></div><p>The one <a id="id519" class="indexterm"/>modification this example makes to the <a id="id520" class="indexterm"/>previous one is that it increases the link distance to <code class="literal">200</code> (the default is <code class="literal">20</code>):</p><div><pre class="programlisting">var force = d3.layout.force()
    .nodes(data.nodes)
    .links(data.edges)
    .size([width, height])
    .linkDistance(200)
    .start();</pre></div><p>This modification results in some better spacing of the nodes at the end of the simulation:</p><div><img src="img/B04320_11_03.jpg" alt="Using link distance to spread out the nodes"/></div><p>Drag the nodes around. It will demonstrate some of the physics in play:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">No matter where you move any node(s), the graph returns to the center of the visualization. This is the effect of gravity on the layout and of it being placed in the center.</li><li class="listitem" style="list-style-type: disc">The nodes always come together, but are always at least the link distance apart. The gravity attracts them to the center and the default charge, which is <code class="literal">-30</code>, makes the nodes push away from each other, but not enough to stretch the links much or make the nodes escape the center of gravity.</li><li class="listitem" style="list-style-type: disc">The preceding point has an important ramification in the result of the visualization. The links between nodes will generally cross each other. In many network visualizations, it is desirable to try and make the links not cross each other, as it simplifies the ability to follow the links, and hence, the relationships. We <a id="id521" class="indexterm"/>will examine <a id="id522" class="indexterm"/>how to fix this in the next example.</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec54"/>Adding repulsion to nodes for preventing crossed links</h1></div></div></div><p>The <a id="id523" class="indexterm"/>means by which we attempt to prevent crossing links is to apply an amount of repulsion to each of the nodes. When the amount of repulsion exceeds the pull of the center of gravity, the nodes can move away from this point. They will also move away from the other nodes, tending to expand the result graph out to a maximum size, with the effect of causing the links to not cross.</p><p>The following example demonstrates node repulsion:</p><div><div><h3 class="title"><a id="note134"/>Note</h3><p>bl.ock (11.3): <a class="ulink" href="http://goo.gl/PCHK68">http://goo.gl/PCHK68</a>
</p></div></div><p>This example makes two modifications to the previous example:</p><div><pre class="programlisting">var force = d3.layout.force()
    .nodes(data.nodes)
    .links(data.edges)
    .size([width, height])
    .linkDistance(1)
    .charge(-5000)
    .start();</pre></div><p>This creates a charge with a value of <code class="literal">-5000</code>, meaning that the nodes actually repulse each other. There is also a smaller link distance, as the repulsion will push the nodes apart quite a bit, therefore stretching the links. Leaving the links at <code class="literal">200</code> would make the links very long.</p><p>When this simulation completes, you will have a graph that looks like the following:</p><div><img src="img/B04320_11_04.jpg" alt="Adding repulsion to nodes for preventing crossed links"/></div><p>Notice how the nodes now tried to get as far away from each other as possible! The links were stretched quite a bit too, event though the link distance is set to <code class="literal">1</code>. Links are, by default, elastic and will be stretched or compressed based on the charges and gravity in the system.</p><p>Rerun this <a id="id524" class="indexterm"/>simulation again and again. You will notice that it almost always converges to this same shape with the nodes in the same relative places in the graph (the group itself will likely be rotated a different amount each time). In a really rare case, there may still be a crossed edge, but the repulsion is set high enough to prevent this for most executions.</p><div><div><div><div><h2 class="title"><a id="ch11lvl2sec69"/>Labelling the nodes</h2></div></div></div><p>Something <a id="id525" class="indexterm"/>that has been missing in our force-directed graphs is labelling of the nodes so that we can tell what data the nodes represent. The following example demonstrates how to add labels to the nodes:</p><div><div><h3 class="title"><a id="note135"/>Note</h3><p>bl.ock (11.4): <a class="ulink" href="http://goo.gl/31VfSU">http://goo.gl/31VfSU</a>
</p></div></div><p>The difference in this preceding example is that instead of representing a node by a single circle SVG element, we represent it by a group which contains both a circle and a text element:</p><div><pre class="programlisting">var nodes = svg.selectAll('g')
    .data(data.nodes)
    .enter()
    .append('g')
    .call(force.drag);

var colors = d3.scale.category20();
nodes.append('circle')
    .attr('r', 10)
    .attr('fill', function (d, i) {
        return colors(i);
    })
    .call(force.drag);

nodes.append('text')
    .attr({
            dx: 12,
            dy: '.35em',
            'pointer-events': 'none'
        })
.style('font', '10px sans-serif')
.text(function (d) { return d.name });</pre></div><p>Then we need one <a id="id526" class="indexterm"/>more change during the processing of the tick event. Since we now need to position an SVG group instead of a circle, this code needs to translate the group into position instead of using the <code class="literal">x</code> and <code class="literal">y</code> properties:</p><div><pre class="programlisting">force.on('tick', function () {
    edges.each(function (d) {
        d3.select(this).attr({
            x1: d.source.x,
            y1: d.source.y,
            x2: d.target.x,
            y2: d.target.y
        });
    });

    nodes.attr('transform', function (d) { 
    return 'translate(' + d.x + ',' + d.y + ')'; 
    });
});</pre></div><p>The result of this example now looks like the following:</p><div><img src="img/B04320_11_05.jpg" alt="Labelling the nodes"/></div></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec70"/>Making nodes stick in place</h2></div></div></div><p>A common—and <a id="id527" class="indexterm"/>frustrating—issue when examining nodes in a force network is that when you move one node of a clump of other nodes to see it better and then let it go, it goes back to where it was. I'll bet you've experienced this madness already just while using these examples.</p><p>The can be remidied by using a concept known as making the nodes sticky. The following example demonstrates this in operation:</p><div><div><h3 class="title"><a id="note136"/>Note</h3><p>bl.ock (11.5): <a class="ulink" href="http://goo.gl/nmQu3d">http://goo.gl/nmQu3d</a>
</p></div></div><p>Now, when you drag a node, it will stay where you leave it. Nodes that are fixed in place will change to have a thick black border. To release a node, double click it and it will be put back into the force layout.</p><p>The following image shows this with three nodes fixed in place:</p><div><img src="img/B04320_11_06.jpg" alt="Making nodes stick in place"/></div><p>Now let's examine the modifications needed to make this work. This works by adding a few function chains to <a id="id528" class="indexterm"/>our code to create the circles:</p><div><pre class="programlisting">nodes.append('circle')
    .attr('r', 10)
    .attr({
        r: 10,
        fill: function(d, i) {
            return colors(i);
        },
        stroke: 'black',
        'stroke-width': 0
    })
    .call(force.drag()
        .on("dragstart", function(d) {
            d.fixed = true;
            d3.select(this).attr('stroke-width', 3);
        }))
    .on('dblclick', function(d) {
        d.fixed = false;
        d3.select(this).attr('stroke-width', 0);
    });</pre></div><p>When the circle is first created, in addition to having its fill color specified, it will also have a stroke color of black but of width <code class="literal">0</code>.</p><p>Then, instead of using <code class="literal">.call(force.drag)</code>, we replace that with a custom drag implementation. At the start of the drag, the code sets a property, <code class="literal">fixed,</code> on the data object to <code class="literal">true</code>. If the force layout object sees that the object has this property, and its value is <code class="literal">true</code>, then it will not attempt to reposition the item. And then, the border is set to be three pixels in width.</p><p>The last modification is <a id="id529" class="indexterm"/>to handle the <code class="literal">dblclick</code> mouse event, which will set the fixed property to <code class="literal">false</code>, releasing the node to be part of the layout and then hiding the thick border.</p></div><div><div><div><div><h2 class="title"><a id="ch11lvl2sec71"/>Adding directionality markers and style to the links</h2></div></div></div><p>Relationships <a id="id530" class="indexterm"/>between a node can be one-way or bi-directional. The <a id="id531" class="indexterm"/>code we have written so far assumed one-way, or perhaps, non-directional. Let's now look at how we can express the direction in the relationship by adding arrow heads to the lines.</p><p>The example we will create will assume that each entry in the edges collection of the data represents a one-way link from the source to the target. If there is a bi-directional link, there will be an additional entry in <code class="literal">edges</code> with the source and target reversed.</p><p>The example will use the data from <a class="ulink" href="https://gist.githubusercontent.com/d3byex/5a8267f90a0d215fcb3e/raw/8469d2a7da14c1c8180ebb2ea8ddf1e2944f990c/multi_network.html">https://gist.githubusercontent.com/d3byex/5a8267f90a0d215fcb3e/raw/8469d2a7da14c1c8180ebb2ea8ddf1e2944f990c/multi_network.html</a>, which has several bi-directional links added as well as a <code class="literal">type</code> property to specify the type of the relationship.</p><p>The edges collection in this data is the following. The nodes have not changed:</p><div><pre class="programlisting">"edges": [
  { "source": 0, "target":  1, "type": "spouse" },
  { "source": 1, "target":  0, "type": "spouse" },
  { "source": 0, "target":  4, "type": "coworker"},
  { "source": 4, "target":  0, "type": "coworker"},
  { "source": 0, "target":  5, "type": "father" },
  { "source": 5, "target":  0, "type": "son" },
  { "source": 0, "target":  6, "type": "master" },
  { "source": 6, "target":  0, "type": "pet" },
  { "source": 0, "target":  7, "type": "master" },
  { "source": 1, "target":  2, "type": "spouse" },
  { "source": 1, "target":  3, "type": "friend" },
  { "source": 1, "target":  5, "type": "mother" },
  { "source": 1, "target":  8, "type": "pet" },
  { "source": 8, "target":  1, "type": "master" },
  { "source": 1, "target":  9, "type": "pet" },
  { "source": 5, "target": 10, "type": "pet" }
]</pre></div><div><div><h3 class="title"><a id="note137"/>Note</h3><p>bl.ock (11.6): <a class="ulink" href="https://goo.gl/hucTe1">https://goo.gl/hucTe1</a>
</p></div></div><p>The following <a id="id532" class="indexterm"/>image depicts the result of this example:</p><div><img src="img/B04320_11_07.jpg" alt="Adding directionality markers and style to the links"/></div><p>Let's see how the <a id="id533" class="indexterm"/>code goes about creating this visualization.</p><p>The first thing that is changed in this example is that it uses styles to color the different types of links:</p><div><pre class="programlisting">.link {
    fill: none;
    stroke: #666;
    stroke-width: 1.5px;
}

.link.spouse {
    stroke: green;
}

.link.son {
    stroke: blue;
}

.link.father {
    stroke: blue;
    stroke-dasharray: 0, 2, 1;
}

.link.friend {
    stroke: teal;
}

.link.pet {
    stroke: purple;
}

.link.master {
    stroke: purple;
    stroke-dasharray: 0, 2, 1;
}

.link.ruler {
    stroke: red;
    stroke-dasharray: 0, 2, 1;
}

.link.coworker {
    stroke: green;
    stroke-dasharray: 0, 2, 1;
}</pre></div><p>The code to load <a id="id534" class="indexterm"/>the data and to set up the SVG element and <a id="id535" class="indexterm"/>the force layout is the same as the last example. The other difference is that the code needs to determine the specifc link types as they will be used for markers and styles:</p><div><pre class="programlisting">var linkTypes = d3.set(data.edges.map(function (d) {
    return d.type;
})).values();</pre></div><p>Next, there are markers created for each of the link types. These will render a curved path with an arrow head on each end, created by the last chained function to set the <code class="literal">d</code> attribute:</p><div><pre class="programlisting">svg.append("defs")
    .selectAll("marker")
    .data(linkTypes)
    .enter()
    .append("marker")
    .attr({
        id: function (d) { return d; },
        viewBox: "0 -5 10 10",
        refX: 15,
        refY: -1.5,
        markerWidth: 6,
        markerHeight: 6,
        orient: "auto"
    })
    .append("path")
    .attr("d", "M0,-5L10,0L0,5"); </pre></div><p>The next step is to create the edges:</p><div><pre class="programlisting">var edges = svg.append("g")
    .selectAll("path")
    .data(force.links())
    .enter()
    .append("path")
    .attr("class", function (d) {
        return "link " + d.type;
    })
    .attr("marker-end", function(d) {
         return "url(#" + d.type + ")";
    }); </pre></div><p>Instead of using a <a id="id536" class="indexterm"/>line, the code now uses a path. The <code class="literal">d</code> property <a id="id537" class="indexterm"/>of the path is not specified at this time. It will be set at every tick of the simulation. This path references one of the styles by using the type as part of the class name, and the <code class="literal">marker-end</code> attributes specifies which marker definition to use for this segment.</p><p>The circles are created in the same manner as the previous example, and so is the text. The last change is that the tick handler is modified to not only reposition the nodes, but to also regenerate paths based on arcs:</p><div><pre class="programlisting">force.on("tick", function () {
    edges.attr("d", function (d) {
        var dx = d.target.x - d.source.x,
            dy = d.target.y - d.source.y,
            dr = Math.sqrt(dx * dx + dy * dy);
        return "M" + d.source.x + "," + d.source.y + "A" +
                dr + "," + dr + " 0 0,1 " +
                d.target.x + "," + d.target.y;
    });
    nodes.attr("transform", function (d) {
        return "translate(" + d.x + "," + d.y + ")";
    });
}); </pre></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch11lvl1sec55"/>Summary</h1></div></div></div><p>In this chapter, we explained how to use D3.js for generating force-directed graphs. These types of graphs are some of the most interesting types of graphs and can be used to visualize large sets of interconnected data such as social networks.</p><p>The chapter started by going over the basic concepts of creating a graph, stepping through an example that progressively refined the graph, while making the effort to demonstrate how several of the parameters effect the result of the graph.</p><p>We then covered several techniques for enhancing and making the graphs more usable. These included labeling nodes with text, replacing nodes with images, and styling links to show direction and type.</p><p>In the next chapter, we will cover using D3.js for creating maps. We will also learn quite a bit about GeoJSON and TopoJSON, both of which, when combined with D3.js, allow us to create complex visuals based on geographic data.</p></div></body></html>