<html><head></head><body>
<div class="calibre1" id="_idContainer020">
<h1 class="chapternumber"><span class="kobospan" id="kobo.1.1">3</span></h1>
<h1 class="chaptertitle" id="_idParaDest-33"><span class="kobospan" id="kobo.2.1">JavaScript and TypeScript Primer</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.3.1">Developers come to the world of web app development via many paths and are not always grounded in the basic technologies that web apps rely on. </span><span class="kobospan" id="kobo.3.2">In this chapter, I introduce the basic features of JavaScript and TypeScript. </span><span class="kobospan" id="kobo.3.3">This is not a comprehensive guide to either language, but it addresses the essentials, and it will give you the knowledge you need to get started.</span></p>
<h1 class="heading" id="_idParaDest-34"><span class="kobospan" id="kobo.4.1">Preparing for this chapter</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.5.1">To prepare for this chapter, create a folder named </span><code class="inlinecode"><span class="kobospan" id="kobo.6.1">primer</span></code><span class="kobospan" id="kobo.7.1"> in a convenient location. </span><span class="kobospan" id="kobo.7.2">Navigate to the </span><code class="inlinecode"><span class="kobospan" id="kobo.8.1">primer</span></code><span class="kobospan" id="kobo.9.1"> folder and run the command shown in </span><em class="italic"><span class="kobospan" id="kobo.10.1">Listing 3.1</span></em><span class="kobospan" id="kobo.11.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.12.1">Listing 3.1: Preparing the project folder</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.13.1">npm init --yes
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.14.1">Run the command shown in </span><em class="italic"><span class="kobospan" id="kobo.15.1">Listing 3.2</span></em><span class="kobospan" id="kobo.16.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.17.1">primer</span></code><span class="kobospan" id="kobo.18.1"> folder to install the development packages that are used in this chapter.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.19.1">Listing 3.2: Installing the development package</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.20.1">npm install nodemon@2.0.20
npm install tsc-watch@6.0.4
npm install typescript@5.2.2
npm install @tsconfig/node20@20.1.4
npm install @types/node@20.6.1
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.21.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.22.1">nodemon</span></code><span class="kobospan" id="kobo.23.1"> package will be used at the start of the chapter to monitor and execute JavaScript files. </span><span class="kobospan" id="kobo.23.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.24.1">tsc-watc1h</span></code><span class="kobospan" id="kobo.25.1"> package does the same thing for TypeScript files, and the </span><code class="inlinecode"><span class="kobospan" id="kobo.26.1">typescript</span></code><span class="kobospan" id="kobo.27.1"> package contains the TypeScript compiler. </span><span class="kobospan" id="kobo.27.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.28.1">@tsconfig/node20</span></code><span class="kobospan" id="kobo.29.1"> package contains configuration settings for the TypeScript compiler for use in Node.js projects.</span></p>
<p class="normal"><span class="kobospan" id="kobo.30.1">Replace the </span><code class="inlinecode"><span class="kobospan" id="kobo.31.1">scripts</span></code><span class="kobospan" id="kobo.32.1"> section in the </span><code class="inlinecode"><span class="kobospan" id="kobo.33.1">package.json</span></code><span class="kobospan" id="kobo.34.1"> file as shown in </span><em class="italic"><span class="kobospan" id="kobo.35.1">Listing 3.3</span></em><span class="kobospan" id="kobo.36.1">, which will make it easier to use the development packages.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.37.1">Listing 3.3: Replacing the scripts section in the package.json file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.38.1">{
  "name": "primer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
   </span><strong class="screentext"><span class="kobospan" id="kobo.39.1"> "use_js": "nodemon",</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.40.1">    "</span></strong><strong class="screentext"><span class="kobospan" id="kobo.41.1">use_ts": "tsc-watch --onSuccess \"node index.js\""</span></strong><span class="kobospan" id="kobo.42.1">
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@tsconfig/node20": "^20.1.4",
    "@types/node": "^20.6.1",
    "nodemon": "^2.0.20",
    "tsc-watch": "^6.0.4",
    "typescript": "^5.2.2"
  }
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.43.1">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.44.1">tsconfig.json</span></code><span class="kobospan" id="kobo.45.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.46.1">primer</span></code><span class="kobospan" id="kobo.47.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.48.1">Listing 3.4</span></em><span class="kobospan" id="kobo.49.1">, which creates a basic configuration for the TypeScript compiler suitable for a Node.js project.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.50.1">Listing 3.4: The contents of the tsconfig.json file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.51.1">{
    "extends": "@tsconfig/node20/tsconfig.json"
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.52.1">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.53.1">index.js</span></code><span class="kobospan" id="kobo.54.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.55.1">primer</span></code><span class="kobospan" id="kobo.56.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.57.1">Listing 3.5</span></em><span class="kobospan" id="kobo.58.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.59.1">Listing 3.5: The contents of the index.js file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.60.1">console.log("Hello, World");
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.61.1">Run the command shown in </span><em class="italic"><span class="kobospan" id="kobo.62.1">Listing 3.6</span></em><span class="kobospan" id="kobo.63.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.64.1">primer</span></code><span class="kobospan" id="kobo.65.1"> folder to start monitoring and executing JavaScript files.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.66.1">Listing 3.6: Starting the development tools</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.67.1">npm run use_js
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.68.1">The monitor will generate output similar to the following and will include the message written by the statement in </span><em class="italic"><span class="kobospan" id="kobo.69.1">Listing 3.5</span></em><span class="kobospan" id="kobo.70.1">:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.71.1">[nodemon] 2.0.20
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node index.js`
</span><strong class="screentext"><span class="kobospan" id="kobo.72.1">Hello, World</span></strong><span class="kobospan" id="kobo.73.1">
[nodemon] clean exit - waiting for changes before restart
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.74.1">Any change to the </span><code class="inlinecode"><span class="kobospan" id="kobo.75.1">index.js</span></code><span class="kobospan" id="kobo.76.1"> file will be detected by the </span><code class="inlinecode"><span class="kobospan" id="kobo.77.1">nodemon</span></code><span class="kobospan" id="kobo.78.1"> package and will be executed by the Node.js runtime.</span></p>
<h1 class="heading" id="_idParaDest-35"><span class="kobospan" id="kobo.79.1">Understanding JavaScript confusion</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.80.1">JavaScript</span><a id="_idIndexMarker056" class="calibre3"/><span class="kobospan" id="kobo.81.1"> is an incredible language that has been the engine of transformation for web application development. </span><span class="kobospan" id="kobo.81.2">I love JavaScript and will extol its virtues to anyone foolish enough to ask; it is one of the most fluid and expressive languages I have used.</span></p>
<p class="normal"><span class="kobospan" id="kobo.82.1">That said, JavaScript is a little odd and it causes confusion. </span><span class="kobospan" id="kobo.82.2">At first glance, JavaScript</span><a id="_idIndexMarker057" class="calibre3"/><span class="kobospan" id="kobo.83.1"> looks like any other programming language, which gives programmers new to the language a sense of confidence. </span><span class="kobospan" id="kobo.83.2">That confidence does not last, and it is only a matter of time until the separate searches on Stack Overflow begin.</span></p>
<p class="normal"><span class="kobospan" id="kobo.84.1">JavaScript isn’t like other mainstream languages. </span><span class="kobospan" id="kobo.84.2">To see the most confusing features, replace the contents of the </span><code class="inlinecode"><span class="kobospan" id="kobo.85.1">index.js</span></code><span class="kobospan" id="kobo.86.1"> file with the code shown in </span><em class="italic"><span class="kobospan" id="kobo.87.1">Listing 3.7</span></em><span class="kobospan" id="kobo.88.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.89.1">Listing 3.7: Replacing the contents of the index.js file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.90.1">function sum(first, second) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.91.1">    return first + second;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.92.1">}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.93.1">let result = </span></strong><strong class="screentext"><span class="kobospan" id="kobo.94.1">sum(10, 10);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.95.1">console.log(`Result value: ${result}, Result type: ${typeof result}`);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.96.1">result = sum(</span></strong><strong class="screentext"><span class="kobospan" id="kobo.97.1">10, "10");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.98.1">console.log(`Result value: ${result}, Result type: ${typeof result}`);</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.99.1">Save the changes and the contents of the file will be executed, producing the following results:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.100.1">Result value: 20, Result type: number
Result value: 1010, Result type: string
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.101.1">There are two calls to a function named </span><code class="inlinecode"><span class="kobospan" id="kobo.102.1">sum</span></code><span class="kobospan" id="kobo.103.1">, and JavaScript allows different types to be used as the function arguments. </span><span class="kobospan" id="kobo.103.2">The first call uses two number values (</span><code class="inlinecode"><span class="kobospan" id="kobo.104.1">10</span></code><span class="kobospan" id="kobo.105.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.106.1">10</span></code><span class="kobospan" id="kobo.107.1">). </span><span class="kobospan" id="kobo.107.2">The second call uses a number value (</span><code class="inlinecode"><span class="kobospan" id="kobo.108.1">10</span></code><span class="kobospan" id="kobo.109.1">) and a string value (</span><code class="inlinecode"><span class="kobospan" id="kobo.110.1">"10"</span></code><span class="kobospan" id="kobo.111.1">).</span></p>
<p class="normal"><span class="kobospan" id="kobo.112.1">JavaScript is </span><em class="italic"><span class="kobospan" id="kobo.113.1">dynamically typed</span></em><span class="kobospan" id="kobo.114.1">, which means that variables are not restricted to a specific type of value, and any type of value can be assigned to any variable, including function parameters.</span></p>
<p class="normal"><span class="kobospan" id="kobo.115.1">If you look at the output produced by </span><em class="italic"><span class="kobospan" id="kobo.116.1">Listing 3.7</span></em><span class="kobospan" id="kobo.117.1">, you will see that the function results are oddly different and have different types:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.118.1">Result value: </span><strong class="screentext"><span class="kobospan" id="kobo.119.1">20</span></strong><span class="kobospan" id="kobo.120.1">, Result type: </span><strong class="screentext"><span class="kobospan" id="kobo.121.1">number</span></strong><span class="kobospan" id="kobo.122.1">
Result value: </span><strong class="screentext"><span class="kobospan" id="kobo.123.1">1010</span></strong><span class="kobospan" id="kobo.124.1">, Result type: </span><strong class="screentext"><span class="kobospan" id="kobo.125.1">string</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.126.1">JavaScript is also </span><em class="italic"><span class="kobospan" id="kobo.127.1">weakly typed</span></em><span class="kobospan" id="kobo.128.1">, which means that values will be implicitly converted so</span><a id="_idIndexMarker058" class="calibre3"/><span class="kobospan" id="kobo.129.1"> they can be used together, through a process known as </span><em class="italic"><span class="kobospan" id="kobo.130.1">type coercion</span></em><span class="kobospan" id="kobo.131.1">. </span><span class="kobospan" id="kobo.131.2">This can be a convenient feature, but it can lead to unexpected results because values are coerced in different ways based on the operation that is performed. </span><span class="kobospan" id="kobo.131.3">When the </span><code class="inlinecode"><span class="kobospan" id="kobo.132.1">+</span></code><span class="kobospan" id="kobo.133.1"> operator is applied to a pair of </span><code class="inlinecode"><span class="kobospan" id="kobo.134.1">number</span></code><span class="kobospan" id="kobo.135.1"> values, JavaScript adds the two values together to produce a </span><code class="inlinecode"><span class="kobospan" id="kobo.136.1">number</span></code><span class="kobospan" id="kobo.137.1"> value. </span><span class="kobospan" id="kobo.137.2">If the </span><code class="inlinecode"><span class="kobospan" id="kobo.138.1">+</span></code><span class="kobospan" id="kobo.139.1"> operator is applied to a </span><code class="inlinecode"><span class="kobospan" id="kobo.140.1">string</span></code><span class="kobospan" id="kobo.141.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.142.1">number</span></code><span class="kobospan" id="kobo.143.1"> value, then JavaScript converts the </span><code class="inlinecode"><span class="kobospan" id="kobo.144.1">number</span></code><span class="kobospan" id="kobo.145.1"> value to </span><code class="inlinecode"><span class="kobospan" id="kobo.146.1">string</span></code><span class="kobospan" id="kobo.147.1"> and concatenates the values to produce a </span><code class="inlinecode"><span class="kobospan" id="kobo.148.1">string</span></code><span class="kobospan" id="kobo.149.1"> result. </span><span class="kobospan" id="kobo.149.2">This is why </span><code class="inlinecode"><span class="kobospan" id="kobo.150.1">"10" + 10</span></code><span class="kobospan" id="kobo.151.1"> produces the </span><code class="inlinecode"><span class="kobospan" id="kobo.152.1">string</span></code><span class="kobospan" id="kobo.153.1"> result </span><code class="inlinecode"><span class="kobospan" id="kobo.154.1">1010</span></code><span class="kobospan" id="kobo.155.1">, but </span><code class="inlinecode"><span class="kobospan" id="kobo.156.1">10 + 10</span></code><span class="kobospan" id="kobo.157.1"> produces the number result </span><code class="inlinecode"><span class="kobospan" id="kobo.158.1">20</span></code><span class="kobospan" id="kobo.159.1">.</span></p>
<h2 class="heading1" id="_idParaDest-36"><span class="kobospan" id="kobo.160.1">Using the JavaScript features to express type expectations</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.161.1">The way </span><a id="_idIndexMarker059" class="calibre3"/><span class="kobospan" id="kobo.162.1">that JavaScript handles data types can be confusing, especially when first using the language, but the behavior is consistent and predictable once you understand what’s happening.</span></p>
<p class="normal"><span class="kobospan" id="kobo.163.1">A bigger issue is that it can be difficult to communicate the assumptions and expectations used to write JavaScript code. </span><span class="kobospan" id="kobo.163.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.164.1">sum</span></code><span class="kobospan" id="kobo.165.1"> function is incredibly simple, but with more complex functions, it can be difficult to figure out which data types are expected and which data types will be returned.</span></p>
<p class="normal"><span class="kobospan" id="kobo.166.1">JavaScript provides features for checking types, which can be used to enforce type expectations, as shown in </span><em class="italic"><span class="kobospan" id="kobo.167.1">Listing 3.8</span></em><span class="kobospan" id="kobo.168.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.169.1">Listing 3.8: Checking types in the index.js file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.170.1">function sum(first, second) {
   </span><strong class="screentext"><span class="kobospan" id="kobo.171.1"> if (typeof first == "number" &amp;&amp; typeof second == "number") {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.172.1">        return</span></strong><strong class="screentext"><span class="kobospan" id="kobo.173.1"> first + second;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.174.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.175.1">    throw Error("Expected two numbers");</span></strong><span class="kobospan" id="kobo.176.1">
}
let result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.177.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.178.1">typeof</span></code><span class="kobospan" id="kobo.179.1"> keyword is used to check that both parameters are </span><code class="inlinecode"><span class="kobospan" id="kobo.180.1">number</span></code><span class="kobospan" id="kobo.181.1"> values and uses the </span><code class="inlinecode"><span class="kobospan" id="kobo.182.1">throw</span></code><span class="kobospan" id="kobo.183.1"> keyword to create an error if any other type is received. </span><span class="kobospan" id="kobo.183.2">When the code is </span><a id="_idIndexMarker060" class="calibre3"/><span class="kobospan" id="kobo.184.1">executed, the first call to the </span><code class="inlinecode"><span class="kobospan" id="kobo.185.1">sum</span></code><span class="kobospan" id="kobo.186.1"> function works, but the second fails:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.187.1">Result value: 20, Result type: number
C:\primer\index.js:5
    throw Error("Expected two numbers");
    ^
Error: Expected two numbers at sum (C:\primer\index.js:5:11)
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.188.1">These kinds of type checks are effective but they are only applied when the JavaScript code is executed, and that means that thorough testing is required to ensure that the </span><code class="inlinecode"><span class="kobospan" id="kobo.189.1">sum</span></code><span class="kobospan" id="kobo.190.1"> function isn’t invoked with the wrong types.</span></p>
<h2 class="heading1" id="_idParaDest-37"><span class="kobospan" id="kobo.191.1">Using JavaScript to check type expectations</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.192.1">TypeScript doesn’t change the way that the JavaScript type system works but it does make it easier to express and enforce type expectations, so that type mismatches can be found and resolved more easily. </span><span class="kobospan" id="kobo.192.2">Add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.193.1">index.ts</span></code><span class="kobospan" id="kobo.194.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.195.1">primer</span></code><span class="kobospan" id="kobo.196.1"> folder with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.197.1">Listing 3.9</span></em><span class="kobospan" id="kobo.198.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.199.1">Listing 3.9: The contents of the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.200.1">function sum(first: number, second: number) {
    return first + second;
}
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.201.1">Use </span><code class="inlinecode"><span class="kobospan" id="kobo.202.1">Control+C</span></code><span class="kobospan" id="kobo.203.1"> to stop the </span><code class="inlinecode"><span class="kobospan" id="kobo.204.1">npm</span></code><span class="kobospan" id="kobo.205.1"> command that executes JavaScript code, and run the command shown in </span><em class="italic"><span class="kobospan" id="kobo.206.1">Listing 3.10</span></em><span class="kobospan" id="kobo.207.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.208.1">primer</span></code><span class="kobospan" id="kobo.209.1"> folder to start the command that runs TypeScript.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.210.1">Listing 3.10: Starting the TypeScript tools</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.211.1">npm run use_ts
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.212.1">The TypeScript compiler processes the contents of the </span><code class="inlinecode"><span class="kobospan" id="kobo.213.1">index.ts</span></code><span class="kobospan" id="kobo.214.1"> file and generates the following error:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.215.1">index.ts(5,22): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.216.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.217.1">sum</span></code><span class="kobospan" id="kobo.218.1"> function</span><a id="_idIndexMarker061" class="calibre3"/><span class="kobospan" id="kobo.219.1"> parameters are decorated with </span><em class="italic"><span class="kobospan" id="kobo.220.1">type annotations</span></em><span class="kobospan" id="kobo.221.1">, which tell the TypeScript compiler that the </span><code class="inlinecode"><span class="kobospan" id="kobo.222.1">sum</span></code><span class="kobospan" id="kobo.223.1"> function expects to receive only </span><code class="inlinecode"><span class="kobospan" id="kobo.224.1">number</span></code><span class="kobospan" id="kobo.225.1"> values. </span><span class="kobospan" id="kobo.225.2">The compiler inspects the values used as arguments when the function is invoked and reports an error because one of the arguments is not </span><code class="inlinecode"><span class="kobospan" id="kobo.226.1">number</span></code><span class="kobospan" id="kobo.227.1">.</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.228.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.229.1">If you are using Visual Studio Code, you may see an error displayed in the editor window with the message </span><em class="italic"><span class="kobospan" id="kobo.230.1">Cannot redeclare block-scoped variable</span></em><span class="kobospan" id="kobo.231.1">. </span><span class="kobospan" id="kobo.231.2">This happens when the TypeScript and JavaScript files are both open for editing. </span><span class="kobospan" id="kobo.231.3">If you close the JavaScript file, the error will disappear.</span></p>
</div>
<h3 class="heading2" id="_idParaDest-38"><span class="kobospan" id="kobo.232.1">Using a type union</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.233.1">Using a</span><a id="_idIndexMarker062" class="calibre3"/><span class="kobospan" id="kobo.234.1"> single type, such as </span><code class="inlinecode"><span class="kobospan" id="kobo.235.1">number</span></code><span class="kobospan" id="kobo.236.1">, in an annotation makes JavaScript behave more like other programming languages but restricts some of the flexibility of the dynamic JavaScript type system. </span><span class="kobospan" id="kobo.236.2">JavaScript code can be written to intentionally support multiple types, as shown in </span><em class="italic"><span class="kobospan" id="kobo.237.1">Listing 3.11</span></em><span class="kobospan" id="kobo.238.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.239.1">Listing 3.11. </span><span class="kobospan" id="kobo.239.2">Supporting multiple types in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.240.1">function sum(first: number, second: number) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.241.1">    if</span></strong><strong class="screentext"><span class="kobospan" id="kobo.242.1"> (typeof second == "string") {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.243.1">        return first + Number.parseInt(second);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.244.1">    } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.245.1">        return first + second;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.246.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.247.1">}</span></strong><span class="kobospan" id="kobo.248.1">
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.249.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.250.1">sum</span></code><span class="kobospan" id="kobo.251.1"> function</span><a id="_idIndexMarker063" class="calibre3"/><span class="kobospan" id="kobo.252.1"> checks to see whether the </span><code class="inlinecode"><span class="kobospan" id="kobo.253.1">second</span></code><span class="kobospan" id="kobo.254.1"> parameter is a string value and, if it is, uses the built-in </span><code class="inlinecode"><span class="kobospan" id="kobo.255.1">Number.parseInt</span></code><span class="kobospan" id="kobo.256.1"> function to convert it to a </span><code class="inlinecode"><span class="kobospan" id="kobo.257.1">number</span></code><span class="kobospan" id="kobo.258.1"> value.</span></p>
<p class="normal"><span class="kobospan" id="kobo.259.1">This has caused a mismatch between the capabilities of the function and the type annotations applied to the parameters, and so the compiler produces the same error as for </span><em class="italic"><span class="kobospan" id="kobo.260.1">Listing 3.10</span></em><span class="kobospan" id="kobo.261.1">. </span><span class="kobospan" id="kobo.261.2">The mismatch can be resolved using a </span><em class="italic"><span class="kobospan" id="kobo.262.1">type union</span></em><span class="kobospan" id="kobo.263.1">, as shown in </span><em class="italic"><span class="kobospan" id="kobo.264.1">Listing 3.12</span></em><span class="kobospan" id="kobo.265.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.266.1">Listing 3.12: Using a type union in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.267.1">function sum(first: number, second: number | string) {</span></strong><span class="kobospan" id="kobo.268.1">
    if (typeof second == "string") {
        return first + Number.parseInt(second);
    } else {
        return first + second;       
    }
}
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.269.1">A bar (the </span><code class="inlinecode"><span class="kobospan" id="kobo.270.1">|</span></code><span class="kobospan" id="kobo.271.1"> character) is used to combine types, so that </span><code class="inlinecode"><span class="kobospan" id="kobo.272.1">number | string</span></code><span class="kobospan" id="kobo.273.1"> tells the compiler that the </span><code class="inlinecode"><span class="kobospan" id="kobo.274.1">second</span></code><span class="kobospan" id="kobo.275.1"> parameter can be a </span><code class="inlinecode"><span class="kobospan" id="kobo.276.1">number</span></code><span class="kobospan" id="kobo.277.1"> value or a </span><code class="inlinecode"><span class="kobospan" id="kobo.278.1">string</span></code><span class="kobospan" id="kobo.279.1"> value. </span><span class="kobospan" id="kobo.279.2">The TypeScript checks all uses of the </span><code class="inlinecode"><span class="kobospan" id="kobo.280.1">sum</span></code><span class="kobospan" id="kobo.281.1"> function and finds that all of the types used as arguments match the type annotations. </span><span class="kobospan" id="kobo.281.2">The code produces the following output when it is executed:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.282.1">Result value: 20, Result type: number
Result value: 20, Result type: number
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.283.1">The TypeScript</span><a id="_idIndexMarker064" class="calibre3"/><span class="kobospan" id="kobo.284.1"> compiler is clever and uses JavaScript features like the </span><code class="inlinecode"><span class="kobospan" id="kobo.285.1">typeof</span></code><span class="kobospan" id="kobo.286.1"> keyword to figure out how types are being used. </span><em class="italic"><span class="kobospan" id="kobo.287.1">Listing 3.13</span></em><span class="kobospan" id="kobo.288.1"> changes the implementation of the </span><code class="inlinecode"><span class="kobospan" id="kobo.289.1">sum</span></code><span class="kobospan" id="kobo.290.1"> function so that </span><code class="inlinecode"><span class="kobospan" id="kobo.291.1">string</span></code><span class="kobospan" id="kobo.292.1"> values are no longer treated separately from </span><code class="inlinecode"><span class="kobospan" id="kobo.293.1">number</span></code><span class="kobospan" id="kobo.294.1"> values.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.295.1">Listing 3.13: Changing the function in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.296.1">function sum(first: number, second: number | string) {
   </span><strong class="screentext"><span class="kobospan" id="kobo.297.1"> return first + second;</span></strong><span class="kobospan" id="kobo.298.1">
}
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.299.1">The TypeScript compiler knows that JavaScript will do different things when it applies the addition operator to two </span><code class="inlinecode"><span class="kobospan" id="kobo.300.1">number</span></code><span class="kobospan" id="kobo.301.1"> values or </span><code class="inlinecode"><span class="kobospan" id="kobo.302.1">string</span></code><span class="kobospan" id="kobo.303.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.304.1">number</span></code><span class="kobospan" id="kobo.305.1">, which means that this statement produces an ambiguous result:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.306.1">...
</span><span class="kobospan" id="kobo.306.2">return first + second;       
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.307.1">TypeScript is designed to avoid ambiguity, and the compiler will generate the following error when compiling the code:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.308.1">index.ts(2,12): error TS2365: Operator '+' cannot be applied to types 'number' and 'string | number'.
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.309.1">The purpose of TypeScript is only to highlight potential problems, not to enforce any particular solution to a problem. </span><span class="kobospan" id="kobo.309.2">The code in </span><em class="italic"><span class="kobospan" id="kobo.310.1">Listing 3.13</span></em><span class="kobospan" id="kobo.311.1"> is legal JavaScript, but the TypeScript compiler has generated an error because there is a mismatch between the type annotations applied to the parameters and the way that the parameter values are used inside the </span><code class="inlinecode"><span class="kobospan" id="kobo.312.1">sum</span></code><span class="kobospan" id="kobo.313.1"> function.</span></p>
<p class="normal"><span class="kobospan" id="kobo.314.1">One way to resolve</span><a id="_idIndexMarker065" class="calibre3"/><span class="kobospan" id="kobo.315.1"> this problem is to return to the code in </span><em class="italic"><span class="kobospan" id="kobo.316.1">Listing 3.12</span></em><span class="kobospan" id="kobo.317.1">, which is sensible if the </span><code class="inlinecode"><span class="kobospan" id="kobo.318.1">sum</span></code><span class="kobospan" id="kobo.319.1"> function wants to process </span><code class="inlinecode"><span class="kobospan" id="kobo.320.1">number</span></code><span class="kobospan" id="kobo.321.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.322.1">string</span></code><span class="kobospan" id="kobo.323.1"> values without type coercion. </span><span class="kobospan" id="kobo.323.2">An alternative is to tell the compiler that the ambiguity is intentional, as shown in </span><em class="italic"><span class="kobospan" id="kobo.324.1">Listing 3.14</span></em><span class="kobospan" id="kobo.325.1">, which is sensible if type coercion is required.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.326.1">Listing 3.14: Resolving ambiguity in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.327.1">function sum(first: number, second: number | string) {
    </span><strong class="screentext"><span class="kobospan" id="kobo.328.1">return first + (second as any);</span></strong><span class="kobospan" id="kobo.329.1">
}
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.330.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.331.1">as</span></code><span class="kobospan" id="kobo.332.1"> keyword tells the TypeScript compiler that its knowledge of the </span><code class="inlinecode"><span class="kobospan" id="kobo.333.1">second</span></code><span class="kobospan" id="kobo.334.1"> value is incomplete and that it should treat it as a type that I specify. </span><span class="kobospan" id="kobo.334.2">In this case, I have specified the </span><code class="inlinecode"><span class="kobospan" id="kobo.335.1">any</span></code><span class="kobospan" id="kobo.336.1"> type, which has the effect of telling the TypeScript that ambiguity is expected and prevents it from producing an error. </span><span class="kobospan" id="kobo.336.2">This code produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.337.1">Result value: 1010, Result type: string
Result value: 20, Result type: number
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.338.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.339.1">as</span></code><span class="kobospan" id="kobo.340.1"> keyword should be used with caution because the TypeScript compiler is sophisticated and usually has a good understanding of how data types are being used. </span><span class="kobospan" id="kobo.340.2">Equally, using the </span><code class="inlinecode"><span class="kobospan" id="kobo.341.1">any</span></code><span class="kobospan" id="kobo.342.1"> type can be dangerous because it essentially stops the TypeScript compiler from checking types. </span><span class="kobospan" id="kobo.342.2">When you tell the TypeScript compiler that you know more about the code, then you need to make sure that you are right; otherwise, you will return to the runtime error issue that led to the introduction of TypeScript in the first place.</span></p>
<h1 class="heading" id="_idParaDest-39"><span class="kobospan" id="kobo.343.1">Understanding the basic TypeScript/JavaScript features</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.344.1">Now that you understand the relationship between TypeScript and JavaScript, it is time to describe </span><a id="_idIndexMarker066" class="calibre3"/><span class="kobospan" id="kobo.345.1">the basic language features you will need to follow the examples in this book. </span><span class="kobospan" id="kobo.345.2">This is not a comprehensive guide to either </span><a id="_idIndexMarker067" class="calibre3"/><span class="kobospan" id="kobo.346.1">TypeScript or JavaScript, but it should be enough to get you started.</span></p>
<h2 class="heading1" id="_idParaDest-40"><span class="kobospan" id="kobo.347.1">Defining variables and constants</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.348.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.349.1">let</span></code><span class="kobospan" id="kobo.350.1"> keyword is </span><a id="_idIndexMarker068" class="calibre3"/><span class="kobospan" id="kobo.351.1">used to define variables, and the </span><code class="inlinecode"><span class="kobospan" id="kobo.352.1">const</span></code><span class="kobospan" id="kobo.353.1"> keyword</span><a id="_idIndexMarker069" class="calibre3"/><span class="kobospan" id="kobo.354.1"> is used to define a constant value that will not change, as shown in </span><em class="italic"><span class="kobospan" id="kobo.355.1">Listing 3.15</span></em><span class="kobospan" id="kobo.356.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.357.1">Listing 3.15: Defining variables and constants in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.358.1">let condition = true;
let person = "Bob";
const age = 40;
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.359.1">The TypeScript compiler infers the type of each variable or constant from the value it is assigned and will generate an error if a value of a different type is assigned. </span><span class="kobospan" id="kobo.359.2">Types can be specified explicitly, as shown in </span><em class="italic"><span class="kobospan" id="kobo.360.1">Listing 3.16</span></em><span class="kobospan" id="kobo.361.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.362.1">Listing 3.16. </span><span class="kobospan" id="kobo.362.2">Specifying types in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.363.1">let condition: boolean = true;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.364.1">let person: string = "Bob";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.365.1">const age: number = 40</span></strong><strong class="screentext"><span class="kobospan" id="kobo.366.1">;</span></strong>
</code></pre>
<h2 class="heading1" id="_idParaDest-41"><span class="kobospan" id="kobo.367.1">Dealing with unassigned and null values</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.368.1">In </span><a id="_idIndexMarker070" class="calibre3"/><span class="kobospan" id="kobo.369.1">JavaScript, variables that have been defined but not assigned a value are assigned the special value </span><code class="inlinecode"><span class="kobospan" id="kobo.370.1">undefined</span></code><span class="kobospan" id="kobo.371.1">, whose type is </span><code class="inlinecode"><span class="kobospan" id="kobo.372.1">undefined</span></code><span class="kobospan" id="kobo.373.1">, as shown in </span><em class="italic"><span class="kobospan" id="kobo.374.1">Listing 3.17</span></em><span class="kobospan" id="kobo.375.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.376.1">Listing 3.17: Defining a variable without a value in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.377.1">let condition: boolean = true;
let person: string = "Bob";
const age: number = 40;
let place;
console.log("Place value: " + place + " Type: " + typeof(place));
place = "London";
console.log("Place value: " + place + " Type: " + typeof(place));
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.378.1">This code produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.379.1">Place value: undefined Type: undefined
Place value: London Type: string
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.380.1">This </span><a id="_idIndexMarker071" class="calibre3"/><span class="kobospan" id="kobo.381.1">behavior may seem nonsensical in isolation, but it is consistent with the rest of JavaScript, where values have types, and any value can be assigned to a variable. </span><span class="kobospan" id="kobo.381.2">JavaScript also defines a separate special value, </span><code class="inlinecode"><span class="kobospan" id="kobo.382.1">null</span></code><span class="kobospan" id="kobo.383.1">, which can be assigned to variables to indicate no value or result, as shown in </span><em class="italic"><span class="kobospan" id="kobo.384.1">Listing 3.18</span></em><span class="kobospan" id="kobo.385.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.386.1">Listing 3.18: Assigning null in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.387.1">let condition: boolean = true;
let person: string = "Bob";
const age: number = 40;
let place;
console.log("Place value: " + place + " Type: " + typeof(place));
place = "London";
console.log("Place value: " + place + " Type: " + typeof(place));
</span><strong class="screentext"><span class="kobospan" id="kobo.388.1">place = null;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.389.1">console.log("Place value: " + place + " Type: " + typeof(place));</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.390.1">I can generally provide a robust defense of the way that JavaScript features work, but there is an oddity of the </span><code class="inlinecode"><span class="kobospan" id="kobo.391.1">null</span></code><span class="kobospan" id="kobo.392.1"> value that makes little sense, which can be seen in the output this code produces:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.393.1">Place value: undefined Type: undefined
Place value: London Type: string
Place value: null Type: object
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.394.1">The </span><a id="_idIndexMarker072" class="calibre3"/><span class="kobospan" id="kobo.395.1">oddity is that the type of the special </span><code class="inlinecode"><span class="kobospan" id="kobo.396.1">null</span></code><span class="kobospan" id="kobo.397.1"> value is </span><code class="inlinecode"><span class="kobospan" id="kobo.398.1">object</span></code><span class="kobospan" id="kobo.399.1">. </span><span class="kobospan" id="kobo.399.2">This JavaScript quirk dates back to the first version of JavaScript and hasn’t been addressed because so much code has been written that depends on it. </span><span class="kobospan" id="kobo.399.3">Leaving aside this inconsistency, when the TypeScript compiler processes the code, it determines that values of different types are assigned to the </span><code class="inlinecode"><span class="kobospan" id="kobo.400.1">place</span></code><span class="kobospan" id="kobo.401.1"> variable and infers the variable’s type as </span><code class="inlinecode"><span class="kobospan" id="kobo.402.1">any</span></code><span class="kobospan" id="kobo.403.1">.</span></p>
<p class="normal"><span class="kobospan" id="kobo.404.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.405.1">any</span></code><span class="kobospan" id="kobo.406.1"> type allows values of any type to be used, which effectively disables the TypeScript compiler’s type checks. </span><span class="kobospan" id="kobo.406.2">A type union can be used to restrict the values that can be used, while still allowing </span><code class="inlinecode"><span class="kobospan" id="kobo.407.1">undefined</span></code><span class="kobospan" id="kobo.408.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.409.1">null</span></code><span class="kobospan" id="kobo.410.1"> to be used, as shown in </span><em class="italic"><span class="kobospan" id="kobo.411.1">Listing 3.19</span></em><span class="kobospan" id="kobo.412.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.413.1">Listing 3.19: Using a type union in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.414.1">let condition: boolean = true;
let person: string = "Bob";
const age: number = 40;
</span><strong class="screentext"><span class="kobospan" id="kobo.415.1">let place: string | undefined</span></strong><strong class="screentext"><span class="kobospan" id="kobo.416.1"> | null;</span></strong><span class="kobospan" id="kobo.417.1">
console.log("Place value: " + place + " Type: " + typeof(place));
place = "London";
console.log("Place value: " + place + " Type: " + typeof(place));
place = null;
console.log("Place value: " + place + " Type: " + typeof(place));
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.418.1">This type union allows the </span><code class="inlinecode"><span class="kobospan" id="kobo.419.1">place</span></code><span class="kobospan" id="kobo.420.1"> variable to be assigned </span><code class="inlinecode"><span class="kobospan" id="kobo.421.1">string</span></code><span class="kobospan" id="kobo.422.1"> values or </span><code class="inlinecode"><span class="kobospan" id="kobo.423.1">undefined</span></code><span class="kobospan" id="kobo.424.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.425.1">null</span></code><span class="kobospan" id="kobo.426.1">. </span><span class="kobospan" id="kobo.426.2">Notice that </span><code class="inlinecode"><span class="kobospan" id="kobo.427.1">null</span></code><span class="kobospan" id="kobo.428.1"> is specified by value in the type union. </span><span class="kobospan" id="kobo.428.2">This listing produces the same output as </span><em class="italic"><span class="kobospan" id="kobo.429.1">Listing 3.18</span></em><span class="kobospan" id="kobo.430.1">.</span></p>
<h2 class="heading1" id="_idParaDest-42"><span class="kobospan" id="kobo.431.1">Using the JavaScript primitive types</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.432.1">JavaScript defines</span><a id="_idIndexMarker073" class="calibre3"/><span class="kobospan" id="kobo.433.1"> a small set of commonly used primitive types: </span><code class="inlinecode"><span class="kobospan" id="kobo.434.1">string</span></code><span class="kobospan" id="kobo.435.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.436.1">number</span></code><span class="kobospan" id="kobo.437.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.438.1">boolean</span></code><span class="kobospan" id="kobo.439.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.440.1">undefined</span></code><span class="kobospan" id="kobo.441.1">, and </span><code class="inlinecode"><span class="kobospan" id="kobo.442.1">null</span></code><span class="kobospan" id="kobo.443.1">. </span><span class="kobospan" id="kobo.443.2">This may seem like a short list, but JavaScript manages to fit a lot of flexibility into these types. </span><span class="kobospan" id="kobo.443.3">(There are also </span><code class="inlinecode"><span class="kobospan" id="kobo.444.1">symbol</span></code><span class="kobospan" id="kobo.445.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.446.1">bigint</span></code><span class="kobospan" id="kobo.447.1"> types, but these are relatively new additions to JavaScript and are not as widely used and not used in this book.)</span></p>
<h3 class="heading2" id="_idParaDest-43"><span class="kobospan" id="kobo.448.1">Working with booleans</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.449.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.450.1">boolean</span></code><span class="kobospan" id="kobo.451.1"> type </span><a id="_idIndexMarker074" class="calibre3"/><span class="kobospan" id="kobo.452.1">has two values: </span><code class="inlinecode"><span class="kobospan" id="kobo.453.1">true</span></code><span class="kobospan" id="kobo.454.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.455.1">false</span></code><span class="kobospan" id="kobo.456.1">. </span><em class="italic"><span class="kobospan" id="kobo.457.1">Listing 3.20</span></em><span class="kobospan" id="kobo.458.1"> shows both values being used, but this type is most useful when used </span><a id="_idIndexMarker075" class="calibre3"/><span class="kobospan" id="kobo.459.1">in conditional statements, such as an </span><code class="inlinecode"><span class="kobospan" id="kobo.460.1">if</span></code><span class="kobospan" id="kobo.461.1"> statement. </span><span class="kobospan" id="kobo.461.2">There is no output from this listing. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.462.1">Listing 3.20: Defining boolean values in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.463.1">let firstBool = true;
let secondBool = false;
</span></code></pre>
<h3 class="heading2" id="_idParaDest-44"><span class="kobospan" id="kobo.464.1">Working with strings</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.465.1">You</span><a id="_idIndexMarker076" class="calibre3"/><span class="kobospan" id="kobo.466.1"> define </span><code class="inlinecode"><span class="kobospan" id="kobo.467.1">string</span></code><span class="kobospan" id="kobo.468.1"> values using either the</span><a id="_idIndexMarker077" class="calibre3"/><span class="kobospan" id="kobo.469.1"> double or single quote characters, as shown in </span><em class="italic"><span class="kobospan" id="kobo.470.1">Listing 3.21</span></em><span class="kobospan" id="kobo.471.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.472.1">Listing 3.21: Defining string variables in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.473.1">let firstString = "This is a string";
let secondString = 'And so is this';
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.474.1">The quote characters you use must match. </span><span class="kobospan" id="kobo.474.2">You can’t start a string with a single quote and finish with a double quote, for example. </span><span class="kobospan" id="kobo.474.3">There is no output from this listing.</span></p>
<h3 class="heading2" id="_idParaDest-45"><span class="kobospan" id="kobo.475.1">Using template strings</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.476.1">A common </span><a id="_idIndexMarker078" class="calibre3"/><span class="kobospan" id="kobo.477.1">programming task is to combine </span><a id="_idIndexMarker079" class="calibre3"/><span class="kobospan" id="kobo.478.1">static content with data values to produce a string that can be presented to the user. </span><span class="kobospan" id="kobo.478.2">JavaScript supports </span><em class="italic"><span class="kobospan" id="kobo.479.1">template strings</span></em><span class="kobospan" id="kobo.480.1">, which allow data values to be specified in line with static content, as shown in </span><em class="italic"><span class="kobospan" id="kobo.481.1">Listing 3.22</span></em><span class="kobospan" id="kobo.482.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.483.1">Listing 3.22: Using a template string in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.484.1">let place: string | undefined | null;
console.log(`Place value: ${place} Type: ${typeof(place)}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.485.1">Template strings</span><a id="_idIndexMarker080" class="calibre3"/><span class="kobospan" id="kobo.486.1"> begin and end with </span><a id="_idIndexMarker081" class="calibre3"/><span class="kobospan" id="kobo.487.1">backticks (the </span><code class="inlinecode"><span class="kobospan" id="kobo.488.1">`</span></code><span class="kobospan" id="kobo.489.1"> character), and data values are denoted by curly braces preceded by a dollar sign. </span><span class="kobospan" id="kobo.489.2">This string, for example, incorporates the value of the </span><code class="inlinecode"><span class="kobospan" id="kobo.490.1">place</span></code><span class="kobospan" id="kobo.491.1"> variable and its type into the template string:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.492.1">...
</span><span class="kobospan" id="kobo.492.2">console.log(`Place value: ${place} Type: ${typeof(place)}`);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.493.1">This example produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.494.1">Place value: undefined Type: undefined
</span></code></pre>
<h3 class="heading2" id="_idParaDest-46"><span class="kobospan" id="kobo.495.1">Working with numbers</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.496.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.497.1">number</span></code><span class="kobospan" id="kobo.498.1"> type is</span><a id="_idIndexMarker082" class="calibre3"/><span class="kobospan" id="kobo.499.1"> used to represent both </span><em class="italic"><span class="kobospan" id="kobo.500.1">integer</span></em><span class="kobospan" id="kobo.501.1"> and </span><em class="italic"><span class="kobospan" id="kobo.502.1">floating-point</span></em><span class="kobospan" id="kobo.503.1"> numbers, as shown in </span><em class="italic"><span class="kobospan" id="kobo.504.1">Listing 3.23</span></em><span class="kobospan" id="kobo.505.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.506.1">Listing 3.23: Defining number values in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.507.1">let daysInWeek = 7;
let pi = 3.14;
let hexValue = 0xFFFF;
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.508.1">You don’t have to </span><a id="_idIndexMarker083" class="calibre3"/><span class="kobospan" id="kobo.509.1">specify which kind of number you are using. </span><span class="kobospan" id="kobo.509.2">You just express the value you require, and JavaScript will act accordingly. </span><span class="kobospan" id="kobo.509.3">In the listing, I have defined an integer value, defined a floating-point value, and prefixed a value with </span><code class="inlinecode"><span class="kobospan" id="kobo.510.1">0x</span></code><span class="kobospan" id="kobo.511.1"> to denote a hexadecimal value. </span><em class="italic"><span class="kobospan" id="kobo.512.1">Listing 3.23</span></em><span class="kobospan" id="kobo.513.1"> doesn’t produce any output.</span></p>
<h3 class="heading2" id="_idParaDest-47"><span class="kobospan" id="kobo.514.1">Working with null and undefined values</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.515.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.516.1">null</span></code><span class="kobospan" id="kobo.517.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.518.1">undefined</span></code><span class="kobospan" id="kobo.519.1"> values have no features, such as properties or methods, but the </span><a id="_idIndexMarker084" class="calibre3"/><span class="kobospan" id="kobo.520.1">unusual approach</span><a id="_idIndexMarker085" class="calibre3"/><span class="kobospan" id="kobo.521.1"> taken by JavaScript means that you can only assign these values to variables whose type is a union that includes </span><code class="inlinecode"><span class="kobospan" id="kobo.522.1">null</span></code><span class="kobospan" id="kobo.523.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.524.1">undefined</span></code><span class="kobospan" id="kobo.525.1">, as shown in </span><em class="italic"><span class="kobospan" id="kobo.526.1">Listing 3.24</span></em><span class="kobospan" id="kobo.527.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.528.1">Listing 3.24: Assigning null and undefined values in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.529.1">let person1 = "Alice";
let person2: string | undefined = "Bob";
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.530.1">The TypeScript compiler will infer the type of the </span><code class="inlinecode"><span class="kobospan" id="kobo.531.1">person1</span></code><span class="kobospan" id="kobo.532.1"> variable as </span><code class="inlinecode"><span class="kobospan" id="kobo.533.1">string</span></code><span class="kobospan" id="kobo.534.1"> because that is the type of the value assigned to it. </span><span class="kobospan" id="kobo.534.2">This variable cannot be assigned the </span><code class="inlinecode"><span class="kobospan" id="kobo.535.1">null</span></code><span class="kobospan" id="kobo.536.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.537.1">undefined</span></code><span class="kobospan" id="kobo.538.1"> value.</span></p>
<p class="normal"><span class="kobospan" id="kobo.539.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.540.1">person2</span></code><span class="kobospan" id="kobo.541.1"> variable</span><a id="_idIndexMarker086" class="calibre3"/><span class="kobospan" id="kobo.542.1"> is defined </span><a id="_idIndexMarker087" class="calibre3"/><span class="kobospan" id="kobo.543.1">with a type annotation that specifies </span><code class="inlinecode"><span class="kobospan" id="kobo.544.1">string</span></code><span class="kobospan" id="kobo.545.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.546.1">undefined</span></code><span class="kobospan" id="kobo.547.1"> values. </span><span class="kobospan" id="kobo.547.2">This variable can be assigned </span><code class="inlinecode"><span class="kobospan" id="kobo.548.1">undefined</span></code><span class="kobospan" id="kobo.549.1"> but not </span><code class="inlinecode"><span class="kobospan" id="kobo.550.1">null</span></code><span class="kobospan" id="kobo.551.1">, as </span><code class="inlinecode"><span class="kobospan" id="kobo.552.1">null</span></code><span class="kobospan" id="kobo.553.1"> is not part of the type union. </span><em class="italic"><span class="kobospan" id="kobo.554.1">Listing 3.24</span></em><span class="kobospan" id="kobo.555.1"> doesn’t produce any output.</span></p>
<h2 class="heading1" id="_idParaDest-48"><span class="kobospan" id="kobo.556.1">Using the JavaScript operators</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.557.1">JavaScript </span><a id="_idIndexMarker088" class="calibre3"/><span class="kobospan" id="kobo.558.1">defines a largely standard set of operators, the most useful of which are described in the following sections.</span></p>
<h3 class="heading2" id="_idParaDest-49"><span class="kobospan" id="kobo.559.1">Using conditional statements</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.560.1">Many </span><a id="_idIndexMarker089" class="calibre3"/><span class="kobospan" id="kobo.561.1">of the JavaScript operators are used in </span><a id="_idIndexMarker090" class="calibre3"/><span class="kobospan" id="kobo.562.1">conjunction with conditional statements. </span><span class="kobospan" id="kobo.562.2">In this book, I tend to use </span><code class="inlinecode"><span class="kobospan" id="kobo.563.1">if/else</span></code><span class="kobospan" id="kobo.564.1">, but JavaScript also supports </span><code class="inlinecode"><span class="kobospan" id="kobo.565.1">switch</span></code><span class="kobospan" id="kobo.566.1"> statements, and </span><em class="italic"><span class="kobospan" id="kobo.567.1">Listing 3.25</span></em><span class="kobospan" id="kobo.568.1"> shows the use of both, which will be familiar if you have worked with pretty much any programming language. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.569.1">Listing 3.25: Using the if/else and switch conditional statements in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.570.1">let firstName = "Adam";
if (firstName == "Adam") {
    console.log("firstName is Adam");
} else if (firstName == "Jacqui") {
    console.log("firstName is Jacqui");
} else {
    console.log("firstName is neither Adam or Jacqui");
}
switch (firstName) {
    case "Adam":
        console.log("firstName is Adam");
        break;
    case "Jacqui":
        console.log("firstName is Jacqui");
        break;
    default:
        console.log("firstName is neither Adam or Jacqui");
        break;
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.571.1">The </span><a id="_idIndexMarker091" class="calibre3"/><span class="kobospan" id="kobo.572.1">results from the listing</span><a id="_idIndexMarker092" class="calibre3"/><span class="kobospan" id="kobo.573.1"> are as follows:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.574.1">firstName is Adam
firstName is Adam
</span></code></pre>
<h3 class="heading2" id="_idParaDest-50"><span class="kobospan" id="kobo.575.1">The equality operator vs. </span><span class="kobospan" id="kobo.575.2">the identity operator</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.576.1">In JavaScript, the </span><a id="_idIndexMarker093" class="calibre3"/><span class="kobospan" id="kobo.577.1">equality operator (</span><code class="inlinecode"><span class="kobospan" id="kobo.578.1">==</span></code><span class="kobospan" id="kobo.579.1">) will attempt to coerce (convert) operands to the same type</span><a id="_idIndexMarker094" class="calibre3"/><span class="kobospan" id="kobo.580.1"> to assess equality. </span><span class="kobospan" id="kobo.580.2">This can be a useful feature, but</span><a id="_idIndexMarker095" class="calibre3"/><span class="kobospan" id="kobo.581.1"> it is widely misunderstood and often leads to unexpected results. </span><em class="italic"><span class="kobospan" id="kobo.582.1">Listing 3.26</span></em><span class="kobospan" id="kobo.583.1"> shows the equality operator in action. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.584.1">Listing 3.26: Using the equality operator in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.585.1">let firstVal: any = 5;
let secondVal: any = "5";
if (firstVal == secondVal) {
    console.log("They are the same");
} else {
    console.log("They are NOT the same");
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.586.1">The output from this code is as follows:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.587.1">They are the same
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.588.1">JavaScript is converting the two operands into the same type and comparing them. </span><span class="kobospan" id="kobo.588.2">In essence, the equality operator tests that values are the same, irrespective of their type.</span></p>
<p class="normal"><span class="kobospan" id="kobo.589.1">If you want </span><a id="_idIndexMarker096" class="calibre3"/><span class="kobospan" id="kobo.590.1">to test to ensure </span><a id="_idIndexMarker097" class="calibre3"/><span class="kobospan" id="kobo.591.1">that the values </span><em class="italic"><span class="kobospan" id="kobo.592.1">and</span></em><span class="kobospan" id="kobo.593.1"> the types are the same, then you need to use the </span><a id="_idIndexMarker098" class="calibre3"/><span class="kobospan" id="kobo.594.1">identity operator (</span><code class="inlinecode"><span class="kobospan" id="kobo.595.1">===</span></code><span class="kobospan" id="kobo.596.1">, three equals signs, rather than the two of the equality operator), as shown in </span><em class="italic"><span class="kobospan" id="kobo.597.1">Listing 3.27</span></em><span class="kobospan" id="kobo.598.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.599.1">Listing 3.27: Using the identity operator in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.600.1">let firstVal: any = 5;
let secondVal: any = "5";
</span><strong class="screentext"><span class="kobospan" id="kobo.601.1">if (firstVal === secondVal) {</span></strong><span class="kobospan" id="kobo.602.1">
    console.log("They are the same");
} else {
    console.log("They are NOT the same");
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.603.1">In this example, the identity operator will consider the two variables to be different. </span><span class="kobospan" id="kobo.603.2">This operator doesn’t coerce types. </span><span class="kobospan" id="kobo.603.3">The result from this code is as follows:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.604.1">They are NOT the same
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.605.1">To demonstrate how JavaScript works, I had to use the </span><code class="inlinecode"><span class="kobospan" id="kobo.606.1">any</span></code><span class="kobospan" id="kobo.607.1"> type when declaring the </span><code class="inlinecode"><span class="kobospan" id="kobo.608.1">firstVal</span></code><span class="kobospan" id="kobo.609.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.610.1">secondVal</span></code><span class="kobospan" id="kobo.611.1"> variables because TypeScript restricts the use of the equality operator so that it can be used only on two values of the same type. </span><em class="italic"><span class="kobospan" id="kobo.612.1">Listing 3.28</span></em><span class="kobospan" id="kobo.613.1"> removes the variable type annotations and allows TypeScript to infer the types from the assigned values.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.614.1">Listing 3.28: Removing the type annotations in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.615.1">let firstVal = 5;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.616.1">let</span></strong><strong class="screentext"><span class="kobospan" id="kobo.617.1"> secondVal = "5";</span></strong><span class="kobospan" id="kobo.618.1">
if (firstVal === secondVal) {
    console.log("They are the same");
} else {
    console.log("They are NOT the same");
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.619.1">The TypeScript compiler </span><a id="_idIndexMarker099" class="calibre3"/><span class="kobospan" id="kobo.620.1">detects that the variable types are not the same </span><a id="_idIndexMarker100" class="calibre3"/><span class="kobospan" id="kobo.621.1">and generates </span><a id="_idIndexMarker101" class="calibre3"/><span class="kobospan" id="kobo.622.1">the following error:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.623.1">index.ts(4,5): error TS2367: This comparison appears to be unintentional because the types 'number' and 'string' have no overlap
</span></code></pre>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.624.1">Understanding Truthy and Falsy Values</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.625.1">An important consequence of type coercion is JavaScript </span><em class="italic"><span class="kobospan" id="kobo.626.1">truthiness</span></em><span class="kobospan" id="kobo.627.1">. </span><span class="kobospan" id="kobo.627.2">A </span><em class="italic"><span class="kobospan" id="kobo.628.1">truthy</span></em><span class="kobospan" id="kobo.629.1"> value is one that evaluates to </span><code class="inlinecode"><span class="kobospan" id="kobo.630.1">true</span></code><span class="kobospan" id="kobo.631.1"> when coerced to a Boolean value, and a </span><em class="italic"><span class="kobospan" id="kobo.632.1">falsy</span></em><span class="kobospan" id="kobo.633.1"> value is one that evaluates to </span><code class="inlinecode"><span class="kobospan" id="kobo.634.1">false</span></code><span class="kobospan" id="kobo.635.1"> when coerced to a Boolean value. </span><span class="kobospan" id="kobo.635.2">Every value is truthy except </span><code class="inlinecode"><span class="kobospan" id="kobo.636.1">false</span></code><span class="kobospan" id="kobo.637.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.638.1">0</span></code><span class="kobospan" id="kobo.639.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.640.1">-0</span></code><span class="kobospan" id="kobo.641.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.642.1">""</span></code><span class="kobospan" id="kobo.643.1"> (the empty string), </span><code class="inlinecode"><span class="kobospan" id="kobo.644.1">null</span></code><span class="kobospan" id="kobo.645.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.646.1">undefined</span></code><span class="kobospan" id="kobo.647.1">, and </span><code class="inlinecode"><span class="kobospan" id="kobo.648.1">NaN</span></code><span class="kobospan" id="kobo.649.1">.</span></p>
<p class="normal"><span class="kobospan" id="kobo.650.1">This feature is often used to check that a variable has been assigned a value and you will see many examples in later chapters, like this expression:</span></p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2"><span class="kobospan" id="kobo.651.1">...</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.652.1">if (customer) {</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.653.1">...</span></code>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.654.1">This is a useful way to see if a value has been assigned value, especially when querying a database or processing data received from the user. </span><span class="kobospan" id="kobo.654.2">Don’t be tempted to use an expression like this one:</span></p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2"><span class="kobospan" id="kobo.655.1">...</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.656.1">if (customer == true) {</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.657.1">...</span></code>
</code></pre>
</div>
<div class="note">
<p class="normal"><span class="kobospan" id="kobo.658.1">In this expression, the type coercion is applied to the </span><code class="inlinecode"><span class="kobospan" id="kobo.659.1">true</span></code><span class="kobospan" id="kobo.660.1"> value and not whatever value has been assigned to </span><code class="inlinecode"><span class="kobospan" id="kobo.661.1">customer</span></code><span class="kobospan" id="kobo.662.1">, which is unlikely to produce the expected result.</span></p>
</div>
<h3 class="heading2" id="_idParaDest-51"><span class="kobospan" id="kobo.663.1">Using the null and nullish coalescing operators</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.664.1">The</span><a id="_idIndexMarker102" class="calibre3"/><span class="kobospan" id="kobo.665.1"> logical OR operator (</span><code class="inlinecode"><span class="kobospan" id="kobo.666.1">||</span></code><span class="kobospan" id="kobo.667.1">) has been traditionally used as a null coalescing operator in JavaScript, allowing </span><a id="_idIndexMarker103" class="calibre3"/><span class="kobospan" id="kobo.668.1">a fallback value to be used in place of </span><code class="inlinecode"><span class="kobospan" id="kobo.669.1">null</span></code><span class="kobospan" id="kobo.670.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.671.1">undefined</span></code><span class="kobospan" id="kobo.672.1"> values, as shown in </span><em class="italic"><span class="kobospan" id="kobo.673.1">Listing 3.29</span></em><span class="kobospan" id="kobo.674.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.675.1">Listing 3.29: Using the null coalescing operator in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.676.1">let val1: string | undefined;
let val2: string | undefined = "London";
let coalesced1 = val1 || "fallback value";
let coalesced2 = val2 || "fallback value";
console.log(`Result 1: ${coalesced1}`);
console.log(`Result 2: ${coalesced2}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.677.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.678.1">||</span></code><span class="kobospan" id="kobo.679.1"> operator </span><a id="_idIndexMarker104" class="calibre3"/><span class="kobospan" id="kobo.680.1">returns the left-hand operand if it evaluates as truthy and returns the right-hand operand otherwise. </span><span class="kobospan" id="kobo.680.2">When the operator is applied to </span><code class="inlinecode"><span class="kobospan" id="kobo.681.1">val1</span></code><span class="kobospan" id="kobo.682.1">, the right-hand operand is returned because no value has been assigned to the variable, meaning that it is </span><code class="inlinecode"><span class="kobospan" id="kobo.683.1">undefined</span></code><span class="kobospan" id="kobo.684.1">. </span><span class="kobospan" id="kobo.684.2">When the operator is applied to </span><code class="inlinecode"><span class="kobospan" id="kobo.685.1">val2</span></code><span class="kobospan" id="kobo.686.1">, the left-hand operand is returned because the variable has been assigned the string </span><code class="inlinecode"><span class="kobospan" id="kobo.687.1">London</span></code><span class="kobospan" id="kobo.688.1">, which evaluates as truthy. </span><span class="kobospan" id="kobo.688.2">This code produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.689.1">Result 1: fallback value
Result 2: London
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.690.1">The problem with using the </span><code class="inlinecode"><span class="kobospan" id="kobo.691.1">||</span></code><span class="kobospan" id="kobo.692.1"> operator this way is that truthy and falsy values can produce unexpected results, as shown in </span><em class="italic"><span class="kobospan" id="kobo.693.1">Listing 3.30</span></em><span class="kobospan" id="kobo.694.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.695.1">Listing 3.30: An unexpected null coalescing result in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.696.1">let val1: string | undefined;
let val2: string | undefined = "London";
</span><strong class="screentext"><span class="kobospan" id="kobo.697.1">let val3: number | </span></strong><strong class="screentext"><span class="kobospan" id="kobo.698.1">undefined = 0;</span></strong><span class="kobospan" id="kobo.699.1">
let coalesced1 = val1 || "fallback value";
let coalesced2 = val2 || "fallback value";
</span><strong class="screentext"><span class="kobospan" id="kobo.700.1">let coalesced3 = val3 || 100;</span></strong><span class="kobospan" id="kobo.701.1">
console.log(`Result 1: ${coalesced1}`);
console.log(`Result 2: ${coalesced2}`);
</span><strong class="screentext"><span class="kobospan" id="kobo.702.1">console.log(`Result 3: ${coalesced3}</span></strong><strong class="screentext"><span class="kobospan" id="kobo.703.1">`);</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.704.1">The new </span><a id="_idIndexMarker105" class="calibre3"/><span class="kobospan" id="kobo.705.1">coalescing </span><a id="_idIndexMarker106" class="calibre3"/><span class="kobospan" id="kobo.706.1">operation returns the fallback value, even though the </span><code class="inlinecode"><span class="kobospan" id="kobo.707.1">val3</span></code><span class="kobospan" id="kobo.708.1"> variable</span><a id="_idIndexMarker107" class="calibre3"/><span class="kobospan" id="kobo.709.1"> is neither </span><code class="inlinecode"><span class="kobospan" id="kobo.710.1">null</span></code><span class="kobospan" id="kobo.711.1"> nor </span><code class="inlinecode"><span class="kobospan" id="kobo.712.1">undefined</span></code><span class="kobospan" id="kobo.713.1">, because </span><code class="inlinecode"><span class="kobospan" id="kobo.714.1">0</span></code><span class="kobospan" id="kobo.715.1"> evaluates as falsy. </span><span class="kobospan" id="kobo.715.2">The code produces the following results:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.716.1">Result 1: fallback value
Result 2: London
Result 3: 100
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.717.1">The nullish coalescing operator (</span><code class="inlinecode"><span class="kobospan" id="kobo.718.1">??</span></code><span class="kobospan" id="kobo.719.1">) addresses this issue by returning the right-hand operand only if the left-hand operand is </span><code class="inlinecode"><span class="kobospan" id="kobo.720.1">null</span></code><span class="kobospan" id="kobo.721.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.722.1">undefined</span></code><span class="kobospan" id="kobo.723.1">, as shown in </span><em class="italic"><span class="kobospan" id="kobo.724.1">Listing 3.31</span></em><span class="kobospan" id="kobo.725.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.726.1">Listing 3.31: Using the nullish coalescing operator in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.727.1">let val1: string | undefined;
let val2: string | undefined = "London";
let val3: number | undefined = 0;
</span><strong class="screentext"><span class="kobospan" id="kobo.728.1">let coalesced1 = val1 ?? </span><span class="kobospan" id="kobo.728.2">"fallback value";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.729.1">let coalesced2 = val2 ?? </span><span class="kobospan" id="kobo.729.2">"fallback value";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.730.1">let coalesced3 = val3 ?? </span><span class="kobospan" id="kobo.730.2">100;</span></strong><span class="kobospan" id="kobo.731.1">
console.log(`Result 1: ${coalesced1}`);
console.log(`Result 2: ${coalesced2}`);
console.log(`Result 3: ${coalesced3}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.732.1">The nullish operator doesn’t consider truthy and falsy outcomes and looks only for the </span><code class="inlinecode"><span class="kobospan" id="kobo.733.1">null</span></code><span class="kobospan" id="kobo.734.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.735.1">undefined</span></code><span class="kobospan" id="kobo.736.1"> values. </span><span class="kobospan" id="kobo.736.2">This code produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.737.1">Result 1: fallback value
Result 2: London
Result 3: 0
</span></code></pre>
<h3 class="heading2" id="_idParaDest-52"><span class="kobospan" id="kobo.738.1">Using the optional chaining operator</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.739.1">As</span><a id="_idIndexMarker108" class="calibre3"/><span class="kobospan" id="kobo.740.1"> explained earlier, TypeScript won’t allow </span><code class="inlinecode"><span class="kobospan" id="kobo.741.1">null</span></code><span class="kobospan" id="kobo.742.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.743.1">undefined</span></code><span class="kobospan" id="kobo.744.1"> to be assigned to variables unless they</span><a id="_idIndexMarker109" class="calibre3"/><span class="kobospan" id="kobo.745.1"> have been defined with a suitable type union. </span><span class="kobospan" id="kobo.745.2">Furthermore, TypeScript will only allow methods and properties defined by all of the types in the union to be used. </span></p>
<p class="normal"><span class="kobospan" id="kobo.746.1">This combination of features means that you have to guard against </span><code class="inlinecode"><span class="kobospan" id="kobo.747.1">null</span></code><span class="kobospan" id="kobo.748.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.749.1">undefined</span></code><span class="kobospan" id="kobo.750.1"> values before you can use the features provided by any other type in a union, as demonstrated in </span><em class="italic"><span class="kobospan" id="kobo.751.1">Listing 3.32</span></em><span class="kobospan" id="kobo.752.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.753.1">Listing 3.32: Guarding against null or undefined values in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.754.1">let count: number | undefined | null = 100;
if (count != null &amp;&amp; count != undefined) {
    let result1: string = count.toFixed(2);
    console.log(`Result 1: ${result1}`);
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.755.1">To invoke the </span><code class="inlinecode"><span class="kobospan" id="kobo.756.1">toFixed</span></code><span class="kobospan" id="kobo.757.1"> method, I have to make sure that the </span><code class="inlinecode"><span class="kobospan" id="kobo.758.1">count</span></code><span class="kobospan" id="kobo.759.1"> variable hasn’t been assigned </span><code class="inlinecode"><span class="kobospan" id="kobo.760.1">null</span></code><span class="kobospan" id="kobo.761.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.762.1">undefined</span></code><span class="kobospan" id="kobo.763.1">. </span><span class="kobospan" id="kobo.763.2">The TypeScript compiler understands the meaning of the expressions in the </span><code class="inlinecode"><span class="kobospan" id="kobo.764.1">if</span></code><span class="kobospan" id="kobo.765.1"> statement and knows that excluding </span><code class="inlinecode"><span class="kobospan" id="kobo.766.1">null</span></code><span class="kobospan" id="kobo.767.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.768.1">undefined</span></code><span class="kobospan" id="kobo.769.1"> values means that the value assigned to </span><code class="inlinecode"><span class="kobospan" id="kobo.770.1">count</span></code><span class="kobospan" id="kobo.771.1"> must be </span><code class="inlinecode"><span class="kobospan" id="kobo.772.1">number</span></code><span class="kobospan" id="kobo.773.1">, meaning that the </span><code class="inlinecode"><span class="kobospan" id="kobo.774.1">toFixed</span></code><span class="kobospan" id="kobo.775.1"> method can be used safely. </span><span class="kobospan" id="kobo.775.2">This code produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.776.1">Result 1: 100.00
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.777.1">The optional chaining operator (the </span><code class="inlinecode"><span class="kobospan" id="kobo.778.1">?</span></code><span class="kobospan" id="kobo.779.1"> character) simplifies the guarding process, as shown in </span><em class="italic"><span class="kobospan" id="kobo.780.1">Listing 3.33</span></em><span class="kobospan" id="kobo.781.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.782.1">Listing 3.33: Using the optional chaining operator in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.783.1">let count: number | undefined | null = 100;
if (count != null &amp;&amp; count != undefined) {
    let result1: string = count.toFixed(2);
    console.log(`Result 1: ${result1}`);
}
</span><strong class="screentext"><span class="kobospan" id="kobo.784.1">let result2: string | undefined = count?.toFixed(</span></strong><strong class="screentext"><span class="kobospan" id="kobo.785.1">2);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.786.1">console.log(`Result 2: ${result2}`);</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.787.1">The operator</span><a id="_idIndexMarker110" class="calibre3"/><span class="kobospan" id="kobo.788.1"> is applied between the variable and the method call and will return </span><code class="inlinecode"><span class="kobospan" id="kobo.789.1">undefined</span></code><span class="kobospan" id="kobo.790.1"> if the value is </span><code class="inlinecode"><span class="kobospan" id="kobo.791.1">null</span></code><span class="kobospan" id="kobo.792.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.793.1">undefined</span></code><span class="kobospan" id="kobo.794.1">, preventing the method from being invoked:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.795.1">...
</span><span class="kobospan" id="kobo.795.2">let result2: string | undefined = count?.toFixed(2);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.796.1">If the </span><a id="_idIndexMarker111" class="calibre3"/><span class="kobospan" id="kobo.797.1">value isn’t </span><code class="inlinecode"><span class="kobospan" id="kobo.798.1">null</span></code><span class="kobospan" id="kobo.799.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.800.1">undefined</span></code><span class="kobospan" id="kobo.801.1">, then the method call will proceed as normal. </span><span class="kobospan" id="kobo.801.2">The result from an expression that includes the optional chaining operator is a type union of undefined and the result from the method. </span><span class="kobospan" id="kobo.801.3">In this case, the union will be </span><code class="inlinecode"><span class="kobospan" id="kobo.802.1">string |</span></code> <code class="inlinecode"><span class="kobospan" id="kobo.803.1">undefined</span></code><span class="kobospan" id="kobo.804.1"> because the </span><code class="inlinecode"><span class="kobospan" id="kobo.805.1">toFixed</span></code><span class="kobospan" id="kobo.806.1"> method returns </span><code class="inlinecode"><span class="kobospan" id="kobo.807.1">string</span></code><span class="kobospan" id="kobo.808.1">. </span><span class="kobospan" id="kobo.808.2">The code in </span><em class="italic"><span class="kobospan" id="kobo.809.1">Listing 3.33</span></em><span class="kobospan" id="kobo.810.1"> produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.811.1">Result 1: 100.00
Result 2: 100.00
</span></code></pre>
<h1 class="heading" id="_idParaDest-53"><span class="kobospan" id="kobo.812.1">Defining and using functions</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.813.1">When </span><a id="_idIndexMarker112" class="calibre3"/><span class="kobospan" id="kobo.814.1">Node.js processes a JavaScript file, it executes the statements in the order in which they have been defined. </span><span class="kobospan" id="kobo.814.2">In common with most languages, JavaScript </span><a id="_idIndexMarker113" class="calibre3"/><span class="kobospan" id="kobo.815.1">allows statements to be grouped into a function, which won’t be executed until a statement that invokes the function is executed, as shown in </span><em class="italic"><span class="kobospan" id="kobo.816.1">Listing 3.34</span></em><span class="kobospan" id="kobo.817.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.818.1">Listing 3.34: Defining a function in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.819.1">function writeValue(val: string | null) {
    console.log(`Value: ${val ?? </span><span class="kobospan" id="kobo.819.2">"Fallback value"}`)
}
writeValue("London");
writeValue(null);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.820.1">Functions </span><a id="_idIndexMarker114" class="calibre3"/><span class="kobospan" id="kobo.821.1">are defined with the </span><code class="inlinecode"><span class="kobospan" id="kobo.822.1">function</span></code><span class="kobospan" id="kobo.823.1"> keyword and are given a name. </span><span class="kobospan" id="kobo.823.2">If a function defines parameters, then TypeScript requires type annotations, which</span><a id="_idIndexMarker115" class="calibre3"/><span class="kobospan" id="kobo.824.1"> are used to enforce consistency in the use of the function. </span><span class="kobospan" id="kobo.824.2">The function in </span><em class="italic"><span class="kobospan" id="kobo.825.1">Listing 3.34</span></em><span class="kobospan" id="kobo.826.1"> is named </span><code class="inlinecode"><span class="kobospan" id="kobo.827.1">writeValue</span></code><span class="kobospan" id="kobo.828.1">, and it defines a parameter that will accept </span><code class="inlinecode"><span class="kobospan" id="kobo.829.1">string</span></code><span class="kobospan" id="kobo.830.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.831.1">null</span></code><span class="kobospan" id="kobo.832.1"> values. </span><span class="kobospan" id="kobo.832.2">The statement inside of the function isn’t executed until the function is executed. </span><span class="kobospan" id="kobo.832.3">The code in </span><em class="italic"><span class="kobospan" id="kobo.833.1">Listing 3.34</span></em><span class="kobospan" id="kobo.834.1"> produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.835.1">Value: London
Value: Fallback value
</span></code></pre>
<h2 class="heading1" id="_idParaDest-54"><span class="kobospan" id="kobo.836.1">Defining optional function parameters</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.837.1">By default, TypeScript </span><a id="_idIndexMarker116" class="calibre3"/><span class="kobospan" id="kobo.838.1">will allow </span><a id="_idIndexMarker117" class="calibre3"/><span class="kobospan" id="kobo.839.1">functions to be invoked only when the number of arguments matches the number of parameters the function defines. </span><span class="kobospan" id="kobo.839.2">This may seem obvious if you are used to other mainstream languages, but a function can be called with any number of arguments in JavaScript, regardless of how many parameters have been defined. </span><span class="kobospan" id="kobo.839.3">The </span><code class="inlinecode"><span class="kobospan" id="kobo.840.1">?</span></code><span class="kobospan" id="kobo.841.1"> character is used to denote an optional parameter, as shown in </span><em class="italic"><span class="kobospan" id="kobo.842.1">Listing 3.35</span></em><span class="kobospan" id="kobo.843.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.844.1">Listing 3.35: Defining an optional parameter in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.845.1">function writeValue</span></strong><strong class="screentext"><span class="kobospan" id="kobo.846.1">(val?: string) {</span></strong><span class="kobospan" id="kobo.847.1">
    console.log(`Value: ${val ?? </span><span class="kobospan" id="kobo.847.2">"Fallback value"}`)
}
writeValue("London");
</span><strong class="screentext"><span class="kobospan" id="kobo.848.1">writeValue();</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.849.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.850.1">?</span></code><span class="kobospan" id="kobo.851.1"> operator has been applied to the </span><code class="inlinecode"><span class="kobospan" id="kobo.852.1">val</span></code><span class="kobospan" id="kobo.853.1"> parameter, which means that the function can be invoked with zero or one argument. </span><span class="kobospan" id="kobo.853.2">Within the function, the parameter type is </span><code class="inlinecode"><span class="kobospan" id="kobo.854.1">string | undefined</span></code><span class="kobospan" id="kobo.855.1">, because the value will be undefined if the function is invoked without an argument.</span></p>
<div class="packt_tip">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.856.1">Note</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.857.1">Don’t confuse </span><code class="inlinecode"><span class="kobospan" id="kobo.858.1">val?: string</span></code><span class="kobospan" id="kobo.859.1">, which is an optional parameter, with </span><code class="inlinecode"><span class="kobospan" id="kobo.860.1">val: string | undefined</span></code><span class="kobospan" id="kobo.861.1">, which is a type union of </span><code class="inlinecode"><span class="kobospan" id="kobo.862.1">string</span></code><span class="kobospan" id="kobo.863.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.864.1">undefined</span></code><span class="kobospan" id="kobo.865.1">. </span><span class="kobospan" id="kobo.865.2">The type union requires the function to be invoked with an argument, which may be the value </span><code class="inlinecode"><span class="kobospan" id="kobo.866.1">undefined</span></code><span class="kobospan" id="kobo.867.1">, whereas the optional parameter allows the function to be invoked without an argument.</span></p>
</div>
<p class="normal"><span class="kobospan" id="kobo.868.1">The </span><a id="_idIndexMarker118" class="calibre3"/><span class="kobospan" id="kobo.869.1">code in </span><em class="italic"><span class="kobospan" id="kobo.870.1">Listing 3.35</span></em><span class="kobospan" id="kobo.871.1"> produces the </span><a id="_idIndexMarker119" class="calibre3"/><span class="kobospan" id="kobo.872.1">following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.873.1">Value: London
Value: Fallback value
</span></code></pre>
<h2 class="heading1" id="_idParaDest-55"><span class="kobospan" id="kobo.874.1">Defining default parameter values</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.875.1">Parameters</span><a id="_idIndexMarker120" class="calibre3"/><span class="kobospan" id="kobo.876.1"> can be defined with a </span><a id="_idIndexMarker121" class="calibre3"/><span class="kobospan" id="kobo.877.1">default value, which will be used when the function is invoked without a corresponding argument. </span><span class="kobospan" id="kobo.877.2">This can be a useful way to avoid dealing with </span><code class="inlinecode"><span class="kobospan" id="kobo.878.1">undefined</span></code><span class="kobospan" id="kobo.879.1"> values, as shown in </span><em class="italic"><span class="kobospan" id="kobo.880.1">Listing 3.36</span></em><span class="kobospan" id="kobo.881.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.882.1">Listing 3.36: Defining a default parameter value in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.883.1">function writeValue(val: string = "default value") {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.884.1">    console.log</span></strong><strong class="screentext"><span class="kobospan" id="kobo.885.1">(`Value: ${val}`)</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.886.1">}</span></strong><span class="kobospan" id="kobo.887.1">
writeValue("London");
writeValue();
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.888.1">The default value will be used when the function is invoked without an argument. </span><span class="kobospan" id="kobo.888.2">This means that the type of the parameter in the example will always be </span><code class="inlinecode"><span class="kobospan" id="kobo.889.1">string</span></code><span class="kobospan" id="kobo.890.1">, so I don’t have to check for </span><code class="inlinecode"><span class="kobospan" id="kobo.891.1">undefined</span></code><span class="kobospan" id="kobo.892.1"> values. </span><span class="kobospan" id="kobo.892.2">The code in </span><em class="italic"><span class="kobospan" id="kobo.893.1">Listing 3.36</span></em><span class="kobospan" id="kobo.894.1"> produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.895.1">Value: London
Value: default value
</span></code></pre>
<h2 class="heading1" id="_idParaDest-56"><span class="kobospan" id="kobo.896.1">Defining rest parameters</span></h2>
<p class="normal1"><em class="italic"><span class="kobospan" id="kobo.897.1">Rest parameters</span></em><span class="kobospan" id="kobo.898.1"> are </span><a id="_idIndexMarker122" class="calibre3"/><span class="kobospan" id="kobo.899.1">used to capture any </span><a id="_idIndexMarker123" class="calibre3"/><span class="kobospan" id="kobo.900.1">additional arguments when a function is invoked with additional arguments, as shown in </span><em class="italic"><span class="kobospan" id="kobo.901.1">Listing 3.37</span></em><span class="kobospan" id="kobo.902.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.903.1">Listing 3.37: Using a rest parameter in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.904.1">function writeValue(val: string, ...extraInfo: string[]) {
    console.log(`Value: ${val}, Extras: ${extraInfo}`)
}
writeValue("London", "Raining", "Cold");
writeValue("Paris", "Sunny");
writeValue("New York");
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.905.1">The rest parameter must be the last parameter defined by the function, and its name is prefixed with an ellipsis (three periods, </span><code class="inlinecode"><span class="kobospan" id="kobo.906.1">...</span></code><span class="kobospan" id="kobo.907.1">). </span><span class="kobospan" id="kobo.907.2">The rest parameter is an array to which any extra arguments will be assigned. </span><span class="kobospan" id="kobo.907.3">In the listing, the function prints out each extra argument to the console, producing the following results:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.908.1">Value: London, Extras: Raining,Cold
Value: Paris, Extras: Sunny
Value: New York, Extras:
</span></code></pre>
<h2 class="heading1" id="_idParaDest-57"><span class="kobospan" id="kobo.909.1">Defining functions that return results</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.910.1">You can</span><a id="_idIndexMarker124" class="calibre3"/><span class="kobospan" id="kobo.911.1"> return results from functions by declaring the return data type and using the </span><code class="inlinecode"><span class="kobospan" id="kobo.912.1">return</span></code><span class="kobospan" id="kobo.913.1"> keyword within the function body, as shown in </span><em class="italic"><span class="kobospan" id="kobo.914.1">Listing 3.38</span></em><span class="kobospan" id="kobo.915.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.916.1">Listing 3.38: Returning a result in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.917.1">function composeString(val: string) : string {
    return `Composed string: ${val}`;
}
function writeValue(val?: string) {
    console.log(composeString(val ?? </span><span class="kobospan" id="kobo.917.2">"Fallback value"));
}
writeValue("London");
writeValue();
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.918.1">The new </span><a id="_idIndexMarker125" class="calibre3"/><span class="kobospan" id="kobo.919.1">function defines one parameter, which is </span><code class="inlinecode"><span class="kobospan" id="kobo.920.1">string</span></code><span class="kobospan" id="kobo.921.1">, and returns a result, which is also a </span><code class="inlinecode"><span class="kobospan" id="kobo.922.1">string</span></code><span class="kobospan" id="kobo.923.1">. </span><span class="kobospan" id="kobo.923.2">The type of the result is defined using a type annotation after the parameters:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.924.1">...
</span><span class="kobospan" id="kobo.924.2">function composeString(val: string) </span><strong class="screentext"><span class="kobospan" id="kobo.925.1">: string</span></strong><span class="kobospan" id="kobo.926.1"> {
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.927.1">TypeScript will check the use of the </span><code class="inlinecode"><span class="kobospan" id="kobo.928.1">return</span></code><span class="kobospan" id="kobo.929.1"> keyword to ensure that the function returns a result and that the result is of the expected type. </span><span class="kobospan" id="kobo.929.2">This code produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.930.1">Composed string: London
Composed string: Fallback value
</span></code></pre>
<h2 class="heading1" id="_idParaDest-58"><span class="kobospan" id="kobo.931.1">Using functions as arguments to other functions</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.932.1">JavaScript </span><a id="_idIndexMarker126" class="calibre3"/><span class="kobospan" id="kobo.933.1">functions are values, which means you can use one function as the argument to another, as demonstrated in </span><em class="italic"><span class="kobospan" id="kobo.934.1">Listing 3.39</span></em><span class="kobospan" id="kobo.935.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.936.1">Listing 3.39: Using a function as an argument to another function in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.937.1">function getUKCapital() : string {
    return "London";
}
function writeCity(f: () =&gt; string)  {
    console.log(`City: ${f()}`)
}
writeCity(getUKCapital);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.938.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.939.1">writeCity</span></code><span class="kobospan" id="kobo.940.1"> function defines a parameter called </span><code class="inlinecode"><span class="kobospan" id="kobo.941.1">f</span></code><span class="kobospan" id="kobo.942.1">, which is a function that it invokes to get the value to insert into the string that it writes out. </span><span class="kobospan" id="kobo.942.2">TypeScript requires the function parameter to be described so that the types of its parameters and results are declared:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.943.1">...
</span><span class="kobospan" id="kobo.943.2">function writeCity(</span><strong class="screentext"><span class="kobospan" id="kobo.944.1">f: () =&gt; string</span></strong><span class="kobospan" id="kobo.945.1">)  {
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.946.1">This is the </span><em class="italic"><span class="kobospan" id="kobo.947.1">arrow syntax</span></em><span class="kobospan" id="kobo.948.1">, also known as </span><em class="italic"><span class="kobospan" id="kobo.949.1">fat arrow syntax</span></em><span class="kobospan" id="kobo.950.1"> or </span><em class="italic"><span class="kobospan" id="kobo.951.1">lambda expression syntax</span></em><span class="kobospan" id="kobo.952.1">. </span><span class="kobospan" id="kobo.952.2">There </span><a id="_idIndexMarker127" class="calibre3"/><span class="kobospan" id="kobo.953.1">are three parts to an arrow function: the input parameters surrounded by parentheses, then an equal sign and a greater-than sign (the “arrow”), and finally, the function result. </span><span class="kobospan" id="kobo.953.2">The parameter function doesn’t define any parameters, so the parentheses are empty. </span><span class="kobospan" id="kobo.953.3">This means that the type of parameter </span><code class="inlinecode"><span class="kobospan" id="kobo.954.1">f</span></code><span class="kobospan" id="kobo.955.1"> is a function that accepts no parameters and returns a </span><code class="inlinecode"><span class="kobospan" id="kobo.956.1">string</span></code><span class="kobospan" id="kobo.957.1"> result. </span><span class="kobospan" id="kobo.957.2">The parameter function is invoked within a template string:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.958.1">...
</span><span class="kobospan" id="kobo.958.2">console.log(`City: ${</span><strong class="screentext"><span class="kobospan" id="kobo.959.1">f()</span></strong><span class="kobospan" id="kobo.960.1">}`)
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.961.1">Only functions with the specified combination of parameters and result can be used as an argument to </span><code class="inlinecode"><span class="kobospan" id="kobo.962.1">writeCity</span></code><span class="kobospan" id="kobo.963.1">. </span><span class="kobospan" id="kobo.963.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.964.1">getUKCapital</span></code><span class="kobospan" id="kobo.965.1"> function has the correct characteristics:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.966.1">...
</span><span class="kobospan" id="kobo.966.2">writeCity(</span><strong class="screentext"><span class="kobospan" id="kobo.967.1">getUKCapital</span></strong><span class="kobospan" id="kobo.968.1">);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.969.1">Notice that only the name of the function is used as the argument. </span><span class="kobospan" id="kobo.969.2">If you follow the function name with parentheses, </span><code class="inlinecode"><span class="kobospan" id="kobo.970.1">writeCity(getUKCapital())</span></code><span class="kobospan" id="kobo.971.1">, then you are telling JavaScript to invoke the </span><code class="inlinecode"><span class="kobospan" id="kobo.972.1">getUKCapital</span></code><span class="kobospan" id="kobo.973.1"> function and pass the result to the </span><code class="inlinecode"><span class="kobospan" id="kobo.974.1">writeCity</span></code><span class="kobospan" id="kobo.975.1"> function. </span><span class="kobospan" id="kobo.975.2">TypeScript will detect that the result from the </span><code class="inlinecode"><span class="kobospan" id="kobo.976.1">getUKCapital</span></code><span class="kobospan" id="kobo.977.1"> function doesn’t match the parameter type defined by the </span><code class="inlinecode"><span class="kobospan" id="kobo.978.1">writeCity</span></code><span class="kobospan" id="kobo.979.1"> function and will produce an error when the code is compiled. </span><span class="kobospan" id="kobo.979.2">The code in </span><em class="italic"><span class="kobospan" id="kobo.980.1">Listing 3.39</span></em><span class="kobospan" id="kobo.981.1"> produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.982.1">City: London
</span></code></pre>
<h3 class="heading2" id="_idParaDest-59"><span class="kobospan" id="kobo.983.1">Defining functions using the arrow syntax</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.984.1">The </span><a id="_idIndexMarker128" class="calibre3"/><span class="kobospan" id="kobo.985.1">arrow syntax</span><a id="_idIndexMarker129" class="calibre3"/><span class="kobospan" id="kobo.986.1"> can </span><a id="_idIndexMarker130" class="calibre3"/><span class="kobospan" id="kobo.987.1">also be used to define functions, which is a useful way to define functions inline, as shown in </span><em class="italic"><span class="kobospan" id="kobo.988.1">Listing 3.40</span></em><span class="kobospan" id="kobo.989.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.990.1">Listing 3.40: Defining an arrow function in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.991.1">function getUKCapital() : string {
    return "London";
}
function writeCity(f: () =&gt; string)  {
    console.log(`City: ${f()}`)
}
writeCity(getUKCapital);
</span><strong class="screentext"><span class="kobospan" id="kobo.992.1">writeCity(</span></strong><strong class="screentext"><span class="kobospan" id="kobo.993.1">() =&gt; "Paris");</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.994.1">This inline function receives no parameters and returns the literal string value </span><code class="inlinecode"><span class="kobospan" id="kobo.995.1">Paris</span></code><span class="kobospan" id="kobo.996.1">, defining a function that can be used as an argument to the </span><code class="inlinecode"><span class="kobospan" id="kobo.997.1">writeCity</span></code><span class="kobospan" id="kobo.998.1"> function. </span><span class="kobospan" id="kobo.998.2">The code in </span><em class="italic"><span class="kobospan" id="kobo.999.1">Listing 3.40</span></em><span class="kobospan" id="kobo.1000.1"> produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1001.1">City: London
City: Paris
</span></code></pre>
<h3 class="heading2" id="_idParaDest-60"><span class="kobospan" id="kobo.1002.1">Understanding value closure</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.1003.1">Functions </span><a id="_idIndexMarker131" class="calibre3"/><span class="kobospan" id="kobo.1004.1">can </span><a id="_idIndexMarker132" class="calibre3"/><span class="kobospan" id="kobo.1005.1">access values that are defined in the surrounding code, using a feature called </span><em class="italic"><span class="kobospan" id="kobo.1006.1">closure</span></em><span class="kobospan" id="kobo.1007.1">, as demonstrated in </span><em class="italic"><span class="kobospan" id="kobo.1008.1">Listing 3.41</span></em><span class="kobospan" id="kobo.1009.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1010.1">Listing 3.41: Using a closure in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1011.1">function getUKCapital() : string {
    return "London";
}
function writeCity(f: () =&gt; string)  {
    console.log(`City: ${f()}`)
}
writeCity(getUKCapital);
writeCity(() =&gt; "Paris");
</span><strong class="screentext"><span class="kobospan" id="kobo.1012.1">let myCity = "Rome";</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1013.1">writeCity(() =&gt; myCity);</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1014.1">The new </span><a id="_idIndexMarker133" class="calibre3"/><span class="kobospan" id="kobo.1015.1">arrow function returns the value of the variable named </span><code class="inlinecode"><span class="kobospan" id="kobo.1016.1">myCity</span></code><span class="kobospan" id="kobo.1017.1">, which is defined in the surrounding code. </span><span class="kobospan" id="kobo.1017.2">This is a powerful feature that </span><a id="_idIndexMarker134" class="calibre3"/><span class="kobospan" id="kobo.1018.1">means you don’t have to define parameters on functions to pass around data values, but caution is required because it is easy to get unexpected results when using common variable names like </span><code class="inlinecode"><span class="kobospan" id="kobo.1019.1">counter</span></code><span class="kobospan" id="kobo.1020.1"> or </span><code class="inlinecode"><span class="kobospan" id="kobo.1021.1">index</span></code><span class="kobospan" id="kobo.1022.1">, where you may not realize that you are reusing a variable name from the surrounding code. </span><span class="kobospan" id="kobo.1022.2">This example produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1023.1">City: London
City: Paris
City: Rome
</span></code></pre>
<h1 class="heading" id="_idParaDest-61"><span class="kobospan" id="kobo.1024.1">Working with arrays</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.1025.1">JavaScript arrays </span><a id="_idIndexMarker135" class="calibre3"/><span class="kobospan" id="kobo.1026.1">work like arrays in most other programming languages. </span><em class="italic"><span class="kobospan" id="kobo.1027.1">Listing 3.42</span></em><span class="kobospan" id="kobo.1028.1"> demonstrates how to create and populate an array. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1029.1">Listing 3.42: Creating and populating an array in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1030.1">let myArray = [];
myArray[0] = 100;
myArray[1] = "Adam";
myArray[2] = true;
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1031.1">I have created a new and empty array using the literal syntax, which uses square brackets, and assigned the array to a variable named </span><code class="inlinecode"><span class="kobospan" id="kobo.1032.1">myArray</span></code><span class="kobospan" id="kobo.1033.1">. </span><span class="kobospan" id="kobo.1033.2">In the subsequent statements, I assign values to various index positions in the array. </span><span class="kobospan" id="kobo.1033.3">(There is no output from this listing.)</span></p>
<p class="normal"><span class="kobospan" id="kobo.1034.1">There are a </span><a id="_idIndexMarker136" class="calibre3"/><span class="kobospan" id="kobo.1035.1">couple of things to note in this example. </span><span class="kobospan" id="kobo.1035.2">First, I didn’t need to declare the number of items in the array when I created it. </span><span class="kobospan" id="kobo.1035.3">JavaScript arrays will resize themselves to hold any number of items. </span><span class="kobospan" id="kobo.1035.4">The second point is that I didn’t have to declare the data types that the array would hold. </span><span class="kobospan" id="kobo.1035.5">Any JavaScript array can hold any mix of data types. </span><span class="kobospan" id="kobo.1035.6">In the example, I have assigned three items to the array: </span><code class="inlinecode"><span class="kobospan" id="kobo.1036.1">number</span></code><span class="kobospan" id="kobo.1037.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.1038.1">string</span></code><span class="kobospan" id="kobo.1039.1">, and </span><code class="inlinecode"><span class="kobospan" id="kobo.1040.1">boolean</span></code><span class="kobospan" id="kobo.1041.1">. </span><span class="kobospan" id="kobo.1041.2">The TypeScript compiler infers the type of the array as </span><code class="inlinecode"><span class="kobospan" id="kobo.1042.1">any[]</span></code><span class="kobospan" id="kobo.1043.1">, denoting an array that can hold values of all types. </span><span class="kobospan" id="kobo.1043.2">The example can be written with the type annotation shown in </span><em class="italic"><span class="kobospan" id="kobo.1044.1">Listing 3.43</span></em><span class="kobospan" id="kobo.1045.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1046.1">Listing 3.43: Using a type annotation in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.1047.1">let </span></strong><strong class="screentext"><span class="kobospan" id="kobo.1048.1">myArray: any[] = [];</span></strong><span class="kobospan" id="kobo.1049.1">
myArray[0] = 100;
myArray[1] = "Adam";
myArray[2] = true;
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1050.1">Arrays can be restricted to values with specific types, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1051.1">Listing 3.44</span></em><span class="kobospan" id="kobo.1052.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1053.1">Listing 3.44: Restricting array value types in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.1054.1">let</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1055.1"> myArray: (number | string | boolean)[] = [];</span></strong><span class="kobospan" id="kobo.1056.1">
myArray[0] = 100;
myArray[1] = "Adam";
myArray[2] = true;
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1057.1">The type union restricts the array so that it can hold only </span><code class="inlinecode"><span class="kobospan" id="kobo.1058.1">number</span></code><span class="kobospan" id="kobo.1059.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.1060.1">string</span></code><span class="kobospan" id="kobo.1061.1">, and </span><code class="inlinecode"><span class="kobospan" id="kobo.1062.1">boolean</span></code><span class="kobospan" id="kobo.1063.1"> values. </span><span class="kobospan" id="kobo.1063.2">Notice that I have put the type union in parentheses because the union </span><code class="inlinecode"><span class="kobospan" id="kobo.1064.1">number | string | boolean[]</span></code><span class="kobospan" id="kobo.1065.1"> denotes a value that can be assigned </span><code class="inlinecode"><span class="kobospan" id="kobo.1066.1">number</span></code><span class="kobospan" id="kobo.1067.1">, a </span><code class="inlinecode"><span class="kobospan" id="kobo.1068.1">string</span></code><span class="kobospan" id="kobo.1069.1">, or an array of </span><code class="inlinecode"><span class="kobospan" id="kobo.1070.1">boolean</span></code><span class="kobospan" id="kobo.1071.1"> values, which is not what is intended.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1072.1">Arrays can be defined and populated in a single statement, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1073.1">Listing 3.45</span></em><span class="kobospan" id="kobo.1074.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1075.1">Listing 3.45: Populating a new array in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1076.1">let myArray: (number | string | boolean)[] = [100, "Adam", true];
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1077.1">If you omit the type annotation, TypeScript will infer the array type from the values used </span><a id="_idIndexMarker137" class="calibre3"/><span class="kobospan" id="kobo.1078.1">to populate the array. </span><span class="kobospan" id="kobo.1078.2">You should rely on this feature with caution for arrays that are intended to hold multiple types because it requires that the full range of types is used when creating the array.</span></p>
<h2 class="heading1" id="_idParaDest-62"><span class="kobospan" id="kobo.1079.1">Reading and modifying the contents of an array</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1080.1">You read</span><a id="_idIndexMarker138" class="calibre3"/><span class="kobospan" id="kobo.1081.1"> the value at a given index using square braces (</span><code class="inlinecode"><span class="kobospan" id="kobo.1082.1">[</span></code><span class="kobospan" id="kobo.1083.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.1084.1">]</span></code><span class="kobospan" id="kobo.1085.1">), placing</span><a id="_idIndexMarker139" class="calibre3"/><span class="kobospan" id="kobo.1086.1"> the index you require between the braces, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1087.1">Listing 3.46</span></em><span class="kobospan" id="kobo.1088.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1089.1">Listing 3.46: Reading the data from an array index in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1090.1">let myArray: (number | string | boolean)[] = [100, "Adam", true];
</span><strong class="screentext"><span class="kobospan" id="kobo.1091.1">let val = myArray[0];</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1092.1">console.log(`Value: ${val}`);</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1093.1">The TypeScript compiler infers the type of values in the array so that the type of the </span><code class="inlinecode"><span class="kobospan" id="kobo.1094.1">val</span></code><span class="kobospan" id="kobo.1095.1"> variable in </span><em class="italic"><span class="kobospan" id="kobo.1096.1">Listing 3.46</span></em><span class="kobospan" id="kobo.1097.1"> is </span><code class="inlinecode"><span class="kobospan" id="kobo.1098.1">number | string | boolean</span></code><span class="kobospan" id="kobo.1099.1">. </span><span class="kobospan" id="kobo.1099.2">This code produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1100.1">Value: 100
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1101.1">You can modify the data held in any position in a JavaScript array simply by assigning a new value to the index, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1102.1">Listing 3.47</span></em><span class="kobospan" id="kobo.1103.1">. </span><span class="kobospan" id="kobo.1103.2">The TypeScript compiler will check that the type of the value you assign matches the array element type.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1104.1">Listing 3.47: Modifying the contents of an array in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1105.1">let myArray: (number | string | boolean)[] = [100, "Adam", true];
</span><strong class="screentext"><span class="kobospan" id="kobo.1106.1">myArray[0</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1107.1">] = "Tuesday";</span></strong><span class="kobospan" id="kobo.1108.1">
let val = myArray[0];
console.log(`Value: ${val}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1109.1">In this example, I have assigned a </span><code class="inlinecode"><span class="kobospan" id="kobo.1110.1">string</span></code><span class="kobospan" id="kobo.1111.1"> to position </span><code class="inlinecode"><span class="kobospan" id="kobo.1112.1">0</span></code><span class="kobospan" id="kobo.1113.1"> in the array, a position that was </span><a id="_idIndexMarker140" class="calibre3"/><span class="kobospan" id="kobo.1114.1">previously </span><a id="_idIndexMarker141" class="calibre3"/><span class="kobospan" id="kobo.1115.1">held by a </span><code class="inlinecode"><span class="kobospan" id="kobo.1116.1">number</span></code><span class="kobospan" id="kobo.1117.1">. </span><span class="kobospan" id="kobo.1117.2">This code produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1118.1">Value: Tuesday
</span></code></pre>
<h2 class="heading1" id="_idParaDest-63"><span class="kobospan" id="kobo.1119.1">Enumerating the contents of an array</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1120.1">You </span><a id="_idIndexMarker142" class="calibre3"/><span class="kobospan" id="kobo.1121.1">enumerate the content of an array using a </span><code class="inlinecode"><span class="kobospan" id="kobo.1122.1">for</span></code><span class="kobospan" id="kobo.1123.1"> loop or the </span><code class="inlinecode"><span class="kobospan" id="kobo.1124.1">forEach</span></code><span class="kobospan" id="kobo.1125.1"> method, which receives a function that is called to process each element in the array. </span><em class="italic"><span class="kobospan" id="kobo.1126.1">Listing 3.48</span></em><span class="kobospan" id="kobo.1127.1"> shows both approaches. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1128.1">Listing 3.48: Enumerating the contents of an array in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1129.1">let myArray: (number | string | boolean)[] = [100, "Adam", true];
</span><strong class="screentext"><span class="kobospan" id="kobo.1130.1">for (let i = 0; i &lt; myArray.length; i++) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1131.1">    console.log("Index " + i + ": " + myArray[i]);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1132.1">}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1133.1">console</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1134.1">.log("---");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1135.1">myArray.forEach((value, index) =&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1136.1">    console.log("Index " + index + ": " + value));</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1137.1">The JavaScript </span><code class="inlinecode"><span class="kobospan" id="kobo.1138.1">for</span></code><span class="kobospan" id="kobo.1139.1"> loop works just the same way as loops in many other languages. </span><span class="kobospan" id="kobo.1139.2">You determine how many elements there are in the array using its </span><code class="inlinecode"><span class="kobospan" id="kobo.1140.1">length</span></code><span class="kobospan" id="kobo.1141.1"> property.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1142.1">The function passed to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1143.1">forEach</span></code><span class="kobospan" id="kobo.1144.1"> method is given two arguments: the value of the current item to be processed and the position of that item in the array. </span><span class="kobospan" id="kobo.1144.2">In this listing, I have used an arrow function as the argument to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1145.1">forEach</span></code><span class="kobospan" id="kobo.1146.1"> method, which is the kind of use for which they excel (and you will see used throughout this book). </span><span class="kobospan" id="kobo.1146.2">The output from the listing is as follows:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1147.1">Index 0: 100
Index 1: Adam
Index 2: true
---
Index 0: 100
Index 1: Adam
Index 2: true
</span></code></pre>
<h2 class="heading1" id="_idParaDest-64"><span class="kobospan" id="kobo.1148.1">Using the spread operator</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1149.1">The</span><a id="_idIndexMarker143" class="calibre3"/><span class="kobospan" id="kobo.1150.1"> spread operator is used to expand an array so </span><a id="_idIndexMarker144" class="calibre3"/><span class="kobospan" id="kobo.1151.1">that its contents can be used as function arguments or combined with other arrays. </span><span class="kobospan" id="kobo.1151.2">In </span><em class="italic"><span class="kobospan" id="kobo.1152.1">Listing 3.49</span></em><span class="kobospan" id="kobo.1153.1">, I used the spread operator to expand an array so that its items can be combined into another array. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1154.1">Listing 3.49: Using the spread operator in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1155.1">let myArray: (number | string | boolean)[] = [100, "Adam", true];
</span><strong class="screentext"><span class="kobospan" id="kobo.1156.1">let otherArray = [...myArray, 200, "Bob", false];</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1157.1">// for (let i = 0; i &lt; myArray.length; i++) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1158.1">//     console.log("Index " + i + ": " + myArray[i]);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1159.1">// }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1160.1">// console.log("---");</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1161.1">otherArray.forEach(</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1162.1">(value, index) =&gt;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1163.1">    console.log("Index " + index + ": " + value));</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1164.1">The spread operator is an ellipsis (a sequence of three periods), and it causes the array to be unpacked:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1165.1">...
</span><span class="kobospan" id="kobo.1165.2">let otherArray = [</span><strong class="screentext"><span class="kobospan" id="kobo.1166.1">...myArray</span></strong><span class="kobospan" id="kobo.1167.1">, 200, "Bob", false];
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1168.1">Using the spread operator, I can specify </span><code class="inlinecode"><span class="kobospan" id="kobo.1169.1">myArray</span></code><span class="kobospan" id="kobo.1170.1"> as an item when I define </span><code class="inlinecode"><span class="kobospan" id="kobo.1171.1">otherArray</span></code><span class="kobospan" id="kobo.1172.1">, with the result that the contents of the first array will be unpacked and added as items to the second array. </span><span class="kobospan" id="kobo.1172.2">This example produces the following results:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1173.1">Index 0: 100
Index 1: Adam
Index 2: true
Index 3: 200
Index 4: Bob
Index 5: false
</span></code></pre>
<h1 class="heading" id="_idParaDest-65"><span class="kobospan" id="kobo.1174.1">Working with objects</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.1175.1">JavaScript </span><a id="_idIndexMarker145" class="calibre3"/><span class="kobospan" id="kobo.1176.1">objects are a collection of properties, each of which has a name and value. </span><span class="kobospan" id="kobo.1176.2">The simplest way to create an object is to use the literal syntax, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1177.1">Listing 3.50</span></em><span class="kobospan" id="kobo.1178.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1179.1">Listing 3.50: Creating an object in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1180.1">let hat = {
    name: "Hat",
    price: 100
};
let boots = {
    name: "Boots",
    price: 100
}
console.log(`Name: ${hat.name}, Price: ${hat.price}`);
console.log(`Name: ${boots.name}, Price: ${boots.price}`);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1181.1">The literal syntax uses braces to contain a list of property names and values. </span><span class="kobospan" id="kobo.1181.2">Names are separated from their values with colons and from other properties with commas. </span><span class="kobospan" id="kobo.1181.3">Two objects are defined in </span><em class="italic"><span class="kobospan" id="kobo.1182.1">Listing 3.50</span></em><span class="kobospan" id="kobo.1183.1"> and assigned to variables named </span><code class="inlinecode"><span class="kobospan" id="kobo.1184.1">hat</span></code><span class="kobospan" id="kobo.1185.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.1186.1">boots</span></code><span class="kobospan" id="kobo.1187.1">. </span><span class="kobospan" id="kobo.1187.2">The properties defined by the object can be accessed through the variable name, as shown in this statement:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1188.1">...
</span><span class="kobospan" id="kobo.1188.2">console.log(`Name: ${hat.name}, Price: ${hat.price}`);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1189.1">The code in </span><em class="italic"><span class="kobospan" id="kobo.1190.1">Listing 3.50</span></em><span class="kobospan" id="kobo.1191.1"> produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1192.1">Name: Hat, Price: 100
Name: Boots, Price: 100
</span></code></pre>
<h2 class="heading1" id="_idParaDest-66"><span class="kobospan" id="kobo.1193.1">Understanding literal object types</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1194.1">When</span><a id="_idIndexMarker146" class="calibre3"/><span class="kobospan" id="kobo.1195.1"> the TypeScript compiler encounters a literal object, it </span><a id="_idIndexMarker147" class="calibre3"/><span class="kobospan" id="kobo.1196.1">infers its type, using the combination of property names and the values to which they are assigned. </span><span class="kobospan" id="kobo.1196.2">This combination can be used in type annotations, allowing the shape of objects to be described as, for example, function parameters, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1197.1">Listing 3.51</span></em><span class="kobospan" id="kobo.1198.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1199.1">Listing 3.51: Describing an object type in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1200.1">let hat = {
    name: "Hat",
    price: 100
};
let boots = {
    name: "Boots",
    price: 100
}
</span><strong class="screentext"><span class="kobospan" id="kobo.1201.1">function printDetails(product : { name: string, price: number}) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1202.1">    console.log(`Name: ${product.name}, Price: ${product.price}</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1203.1">`);   </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1204.1">}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1205.1">printDetails(hat);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1206.1">printDetails(boots);</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1207.1">The type annotation specifies that the </span><code class="inlinecode"><span class="kobospan" id="kobo.1208.1">product</span></code><span class="kobospan" id="kobo.1209.1"> parameter can accept objects that define a </span><code class="inlinecode"><span class="kobospan" id="kobo.1210.1">string</span></code><span class="kobospan" id="kobo.1211.1"> property called </span><code class="inlinecode"><span class="kobospan" id="kobo.1212.1">name</span></code><span class="kobospan" id="kobo.1213.1">, and a </span><code class="inlinecode"><span class="kobospan" id="kobo.1214.1">number</span></code><span class="kobospan" id="kobo.1215.1"> property named </span><code class="inlinecode"><span class="kobospan" id="kobo.1216.1">price</span></code><span class="kobospan" id="kobo.1217.1">. </span><span class="kobospan" id="kobo.1217.2">This example produces the same output as </span><em class="italic"><span class="kobospan" id="kobo.1218.1">Listing 3.50</span></em><span class="kobospan" id="kobo.1219.1">.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1220.1">A type annotation that describes a combination of property names and types just sets out a minimum threshold for objects, which can define additional properties and can still conform to the type, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1221.1">Listing 3.52</span></em><span class="kobospan" id="kobo.1222.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1223.1">Listing 3.52. </span><span class="kobospan" id="kobo.1223.2">Adding a property in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1224.1">let hat = {
    name: "Hat",
    price: 100
};
let boots = {
    name: "Boots",
    price: 100,
   </span><strong class="screentext"><span class="kobospan" id="kobo.1225.1"> category: "Snow Gear"</span></strong><span class="kobospan" id="kobo.1226.1">
}
function printDetails(product : { name: string, price: number}) {
    console.log(`Name: ${product.name}, Price: ${product.price}`);   
}
printDetails(hat);
printDetails(boots);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1227.1">The</span><a id="_idIndexMarker148" class="calibre3"/><span class="kobospan" id="kobo.1228.1"> listing adds a new</span><a id="_idIndexMarker149" class="calibre3"/><span class="kobospan" id="kobo.1229.1"> property to the objects assigned to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1230.1">boots</span></code><span class="kobospan" id="kobo.1231.1"> variable, but since the object defines the properties described in the type annotation, this object can still be used as an argument to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1232.1">printDetails</span></code><span class="kobospan" id="kobo.1233.1"> function. </span><span class="kobospan" id="kobo.1233.2">This example produces the same output as </span><em class="italic"><span class="kobospan" id="kobo.1234.1">Listing 3.50</span></em><span class="kobospan" id="kobo.1235.1">.</span></p>
<h3 class="heading2" id="_idParaDest-67"><span class="kobospan" id="kobo.1236.1">Defining optional properties in a type annotation</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.1237.1">A </span><a id="_idIndexMarker150" class="calibre3"/><span class="kobospan" id="kobo.1238.1">question mark can be used to denote an optional property, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1239.1">Listing 3.53</span></em><span class="kobospan" id="kobo.1240.1">, allowing objects that don’t define the property to still conform to the type. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1241.1">Listing 3.53 Defining an optional property in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1242.1">let hat = {
    name: "Hat",
    price: 100
};
let boots = {
    name: "Boots",
    price: 100,
    category: "Snow Gear"
}
</span><strong class="screentext"><span class="kobospan" id="kobo.1243.1">function printDetails(product : { name: string, price: number,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1244.1">        category?: string}) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1245.1">    if (product.category != undefined) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1246.1">        console.log(</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1247.1">`Name: ${product.name}, Price: ${product.price}, `</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1248.1">            + `Category: ${product.category}`);   </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1249.1">    } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1250.1">        console.log(`Name: ${product.name}, Price: ${product.price}</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1251.1">`);   </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1252.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1253.1">}</span></strong><span class="kobospan" id="kobo.1254.1">
printDetails(hat);
printDetails(boots);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1255.1">The type annotation</span><a id="_idIndexMarker151" class="calibre3"/><span class="kobospan" id="kobo.1256.1"> adds an optional </span><code class="inlinecode"><span class="kobospan" id="kobo.1257.1">category</span></code><span class="kobospan" id="kobo.1258.1"> property, which is marked as optional. </span><span class="kobospan" id="kobo.1258.2">This means that the type of the property is </span><code class="inlinecode"><span class="kobospan" id="kobo.1259.1">string | undefined</span></code><span class="kobospan" id="kobo.1260.1">, and the function can test to see if a </span><code class="inlinecode"><span class="kobospan" id="kobo.1261.1">category</span></code><span class="kobospan" id="kobo.1262.1"> value has been provided. </span><span class="kobospan" id="kobo.1262.2">This code produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1263.1">Name: Hat, Price: 100
Boots, Price: 100, Category: Snow Gear
</span></code></pre>
<h2 class="heading1" id="_idParaDest-68"><span class="kobospan" id="kobo.1264.1">Defining classes</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1265.1">Classes</span><a id="_idIndexMarker152" class="calibre3"/><span class="kobospan" id="kobo.1266.1"> are templates used to create objects, providing an alternative to the literal syntax. </span><span class="kobospan" id="kobo.1266.2">Support for classes is a recent addition to the JavaScript specification and is intended to make working with JavaScript more consistent with other mainstream programming languages. </span><em class="italic"><span class="kobospan" id="kobo.1267.1">Listing 3.54</span></em><span class="kobospan" id="kobo.1268.1"> defines a class and uses it to create objects. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1269.1">Listing 3.54: Defining a class in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.1270.1">class</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1271.1"> Product {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1272.1">    constructor(name: string, price: number, category?: string) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1273.1">        this.name = name;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1274.1">        this.price = price;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1275.1">        this.category</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1276.1"> = category;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1277.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1278.1">    name: string</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1279.1">    price: number</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1280.1">    category?: string</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1281.1">}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1282.1">let hat = new Product("Hat", 100);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1283.1">let boots = new Product</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1284.1">("Boots", 100, "Snow Gear");</span></strong><span class="kobospan" id="kobo.1285.1">
function printDetails(product : { name: string, price: number,
        category?: string}) {
    if (product.category != undefined) {
        console.log(`Name: ${product.name}, Price: ${product.price}, `
            + `Category: ${product.category}`);   
    } else {
        console.log(`Name: ${product.name}, Price: ${product.price}`);   
    }
}
printDetails(hat);
printDetails(boots);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1286.1">JavaScript </span><a id="_idIndexMarker153" class="calibre3"/><span class="kobospan" id="kobo.1287.1">classes will be familiar if you have used another mainstream language such as Java or C#. </span><span class="kobospan" id="kobo.1287.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1288.1">class</span></code><span class="kobospan" id="kobo.1289.1"> keyword is used to declare a class, followed by the name of the class, which is </span><code class="inlinecode"><span class="kobospan" id="kobo.1290.1">Product</span></code><span class="kobospan" id="kobo.1291.1"> in this example.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1292.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1293.1">constructor</span></code><span class="kobospan" id="kobo.1294.1"> function is invoked when a new object is created using the class, and it provides an opportunity to receive data values and do any initial setup that the class requires. </span><span class="kobospan" id="kobo.1294.2">In the example, the constructor defines </span><code class="inlinecode"><span class="kobospan" id="kobo.1295.1">name</span></code><span class="kobospan" id="kobo.1296.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.1297.1">price</span></code><span class="kobospan" id="kobo.1298.1">, and </span><code class="inlinecode"><span class="kobospan" id="kobo.1299.1">category</span></code><span class="kobospan" id="kobo.1300.1"> parameters that are used to assign values to properties defined with the same names.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1301.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1302.1">new</span></code><span class="kobospan" id="kobo.1303.1"> keyword is used to create an object from a class, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1304.1">...
</span><span class="kobospan" id="kobo.1304.2">let hat = </span><strong class="screentext"><span class="kobospan" id="kobo.1305.1">new</span></strong><span class="kobospan" id="kobo.1306.1"> Product("Hat", 100);
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1307.1">This statement creates a new object using the </span><code class="inlinecode"><span class="kobospan" id="kobo.1308.1">Product</span></code><span class="kobospan" id="kobo.1309.1"> class as its template. </span><code class="inlinecode"><span class="kobospan" id="kobo.1310.1">Product</span></code><span class="kobospan" id="kobo.1311.1"> is used as a function in this situation, and the arguments passed to it will be received </span><a id="_idIndexMarker154" class="calibre3"/><span class="kobospan" id="kobo.1312.1">by the </span><code class="inlinecode"><span class="kobospan" id="kobo.1313.1">constructor</span></code><span class="kobospan" id="kobo.1314.1"> function defined by the class. </span><span class="kobospan" id="kobo.1314.2">The result of this expression is a new object that is assigned to a variable called </span><code class="inlinecode"><span class="kobospan" id="kobo.1315.1">hat</span></code><span class="kobospan" id="kobo.1316.1">.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1317.1">Notice that the objects created from the class can still be used as arguments to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1318.1">printDetails</span></code><span class="kobospan" id="kobo.1319.1"> function. </span><span class="kobospan" id="kobo.1319.2">Introducing a class has changed the way that objects are created, but those objects have the same combination of property names and types and still match the type annotation for the function parameters. </span><span class="kobospan" id="kobo.1319.3">The code in </span><em class="italic"><span class="kobospan" id="kobo.1320.1">Listing 3.54</span></em><span class="kobospan" id="kobo.1321.1"> produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1322.1">Name: Hat, Price: 100
Name: Boots, Price: 100, Category: Snow Gear
</span></code></pre>
<h3 class="heading2" id="_idParaDest-69"><span class="kobospan" id="kobo.1323.1">Adding methods to a class</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.1324.1">I can</span><a id="_idIndexMarker155" class="calibre3"/><span class="kobospan" id="kobo.1325.1"> simplify the code in the example by moving the functionality defined by the </span><code class="inlinecode"><span class="kobospan" id="kobo.1326.1">printDetails</span></code><span class="kobospan" id="kobo.1327.1"> function into a method defined by the </span><code class="inlinecode"><span class="kobospan" id="kobo.1328.1">Product</span></code><span class="kobospan" id="kobo.1329.1"> class, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1330.1">Listing 3.55</span></em><span class="kobospan" id="kobo.1331.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1332.1">Listing 3.55: Defining a method in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1333.1">class Product {
    constructor(name: string, price: number, category?: string) {
        this.name = name;
        this.price = price;
        this.category = category;
    }
    name: string
    price: number
    category?: string
    </span><strong class="screentext"><span class="kobospan" id="kobo.1334.1">printDetails() {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1335.1">        if (this.category != undefined) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1336.1">            console.log(`Name: ${this</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1337.1">.name}, Price: ${this.price}, `</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1338.1">                + `Category: ${this.category}`);   </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1339.1">        } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1340.1">            console.log(`Name: </span></strong><strong class="screentext"><span class="kobospan" id="kobo.1341.1">${this.name}, Price: ${this.price}`);   </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1342.1">        }       </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1343.1">    }</span></strong><span class="kobospan" id="kobo.1344.1">
}
let hat = new Product("Hat", 100);
let boots = new Product("Boots", 100, "Snow Gear");
</span><strong class="screentext"><span class="kobospan" id="kobo.1345.1">// function printDetails(product : { name: string, price: number,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1346.1">//         category?: string}) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1347.1">//     if (product.category != undefined) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1348.1">//         console.log(`Name: ${product.name}, Price: ${product.price}, `</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1349.1">//             + `Category: ${product.category}`);   </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1350.1">//     } else {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1351.1">//         console.log(`Name: ${product.name}, Price: ${product.price}`);   </span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1352.1">//     }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1353.1">// }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1354.1">hat.printDetails();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1355.1">boots.printDetails();</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1356.1">Methods </span><a id="_idIndexMarker156" class="calibre3"/><span class="kobospan" id="kobo.1357.1">are invoked through the object, like this:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1358.1">...
</span><span class="kobospan" id="kobo.1358.2">hat.</span><strong class="screentext"><span class="kobospan" id="kobo.1359.1">printDetails</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1360.1">();</span></strong><span class="kobospan" id="kobo.1361.1">
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1362.1">The method accesses the properties defined by the object through the </span><code class="inlinecode"><span class="kobospan" id="kobo.1363.1">this</span></code><span class="kobospan" id="kobo.1364.1"> keyword:</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1365.1">...
</span><span class="kobospan" id="kobo.1365.2">console.log(`Name: ${</span><strong class="screentext"><span class="kobospan" id="kobo.1366.1">this.name</span></strong><span class="kobospan" id="kobo.1367.1">}, Price: ${</span><strong class="screentext"><span class="kobospan" id="kobo.1368.1">this.price</span></strong><span class="kobospan" id="kobo.1369.1">}`);   
...
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1370.1">This example </span><a id="_idIndexMarker157" class="calibre3"/><span class="kobospan" id="kobo.1371.1">produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1372.1">Name: Hat, Price: 100
Name: Boots, Price: 100, Category: Snow Gear
</span></code></pre>
<h3 class="heading2" id="_idParaDest-70"><span class="kobospan" id="kobo.1373.1">Access controls and simplified constructors</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.1374.1">TypeScript provides support for </span><a id="_idIndexMarker158" class="calibre3"/><span class="kobospan" id="kobo.1375.1">access controls using the </span><code class="inlinecode"><span class="kobospan" id="kobo.1376.1">public</span></code><span class="kobospan" id="kobo.1377.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.1378.1">private</span></code><span class="kobospan" id="kobo.1379.1">, and </span><code class="inlinecode"><span class="kobospan" id="kobo.1380.1">protected</span></code><span class="kobospan" id="kobo.1381.1"> keywords. </span><span class="kobospan" id="kobo.1381.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1382.1">public</span></code><span class="kobospan" id="kobo.1383.1"> class gives unrestricted</span><a id="_idIndexMarker159" class="calibre3"/><span class="kobospan" id="kobo.1384.1"> access to the properties and methods defined by a class, meaning they can be accessed by any other part of the application. </span><span class="kobospan" id="kobo.1384.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1385.1">private</span></code><span class="kobospan" id="kobo.1386.1"> keyword restricts access to features so they can be accessed only within the class that defines them. </span><span class="kobospan" id="kobo.1386.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1387.1">protected</span></code><span class="kobospan" id="kobo.1388.1"> keyword restricts access so that features can be accessed within the class or a subclass. </span></p>
<p class="normal"><span class="kobospan" id="kobo.1389.1">By default, the features defined by a class are accessible by any part of the application, as though the </span><code class="inlinecode"><span class="kobospan" id="kobo.1390.1">public</span></code><span class="kobospan" id="kobo.1391.1"> keyword has been applied. </span><span class="kobospan" id="kobo.1391.2">You won’t see the access control keywords applied to methods and properties in this book because access controls are not essential in a web application. </span><span class="kobospan" id="kobo.1391.3">But there is a related feature that I use often, which allows classes to be simplified by applying the access control keyword to the constructor parameters, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1392.1">Listing 3.56</span></em><span class="kobospan" id="kobo.1393.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1394.1">Listing 3.56: Simplifying the class in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1395.1">class Product {
   </span><strong class="screentext"><span class="kobospan" id="kobo.1396.1"> constructor(public name: string, public price: number,</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1397.1">            public category?: string) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1398.1">        // this.name = name;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1399.1">        // this.price = price;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1400.1">        // this.category = category;</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1401.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1402.1">    // name: string</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1403.1">    // price: number</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1404.1">    // category?: string</span></strong><span class="kobospan" id="kobo.1405.1">
    printDetails() {
        if (this.category != undefined) {
            console.log(`Name: ${this.name}, Price: ${this.price}, `
                + `Category: ${this.category}`);   
        } else {
            console.log(`Name: ${this.name}, Price: ${this.price}`);   
        }       
    }
}
let hat = new Product("Hat", 100);
let boots = new Product("Boots", 100, "Snow Gear");
hat.printDetails();
boots.printDetails();
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1406.1">Adding one </span><a id="_idIndexMarker160" class="calibre3"/><span class="kobospan" id="kobo.1407.1">of the access control keywords to a constructor </span><a id="_idIndexMarker161" class="calibre3"/><span class="kobospan" id="kobo.1408.1">parameter has the effect of creating a property with the same name, type, and access level. </span><span class="kobospan" id="kobo.1408.2">So, adding the </span><code class="inlinecode"><span class="kobospan" id="kobo.1409.1">public</span></code><span class="kobospan" id="kobo.1410.1"> keyword to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1411.1">price</span></code><span class="kobospan" id="kobo.1412.1"> parameter, for example, creates a </span><code class="inlinecode"><span class="kobospan" id="kobo.1413.1">public</span></code><span class="kobospan" id="kobo.1414.1"> property named </span><code class="inlinecode"><span class="kobospan" id="kobo.1415.1">price</span></code><span class="kobospan" id="kobo.1416.1">, which can be assigned </span><code class="inlinecode"><span class="kobospan" id="kobo.1417.1">number</span></code><span class="kobospan" id="kobo.1418.1"> values. </span><span class="kobospan" id="kobo.1418.2">The value received through the constructor is used to initialize the property. </span><span class="kobospan" id="kobo.1418.3">This is a useful feature that eliminates the need to copy parameter values to initialize properties. </span><span class="kobospan" id="kobo.1418.4">The code in </span><em class="italic"><span class="kobospan" id="kobo.1419.1">Listing 3.56</span></em><span class="kobospan" id="kobo.1420.1"> produces the same output as </span><em class="italic"><span class="kobospan" id="kobo.1421.1">Listing 3.53</span></em><span class="kobospan" id="kobo.1422.1">, and only the way that the </span><code class="inlinecode"><span class="kobospan" id="kobo.1423.1">name</span></code><span class="kobospan" id="kobo.1424.1">, </span><code class="inlinecode"><span class="kobospan" id="kobo.1425.1">price</span></code><span class="kobospan" id="kobo.1426.1">, and </span><code class="inlinecode"><span class="kobospan" id="kobo.1427.1">category</span></code><span class="kobospan" id="kobo.1428.1"> properties are defined has changed.</span></p>
<h3 class="heading2" id="_idParaDest-71"><span class="kobospan" id="kobo.1429.1">Using class inheritance</span></h3>
<p class="normal1"><span class="kobospan" id="kobo.1430.1">Classes can</span><a id="_idIndexMarker162" class="calibre3"/><span class="kobospan" id="kobo.1431.1"> inherit behavior from other classes using the </span><code class="inlinecode"><span class="kobospan" id="kobo.1432.1">extends</span></code><span class="kobospan" id="kobo.1433.1"> keyword, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1434.1">Listing 3.57</span></em><span class="kobospan" id="kobo.1435.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1436.1">Listing 3.57: Using class inheritance in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1437.1">class Product {
    constructor(public name: string, public price: number,
        public category?: string) {
    }
    printDetails() {
        if (this.category != undefined) {
            console.log(`Name: ${this.name}, Price: ${this.price}, `
                + `Category: ${this.category}`);   
        } else {
            console.log(`Name: ${this.name}, Price: ${this.price}`);   
        }       
    }
}
</span><strong class="screentext"><span class="kobospan" id="kobo.1438.1">class</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1439.1"> DiscountProduct extends Product {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1440.1">    constructor(name: string, price: number, private discount: number) {</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1441.1">        super(name, price - discount);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1442.1">    }</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1443.1">}</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1444.1">let hat = new </span></strong><strong class="screentext"><span class="kobospan" id="kobo.1445.1">DiscountProduct("Hat", 100, 10);</span></strong><span class="kobospan" id="kobo.1446.1">
let boots = new Product("Boots", 100, "Snow Gear");
hat.printDetails();
boots.printDetails();
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1447.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1448.1">extends</span></code><span class="kobospan" id="kobo.1449.1"> keyword </span><a id="_idIndexMarker163" class="calibre3"/><span class="kobospan" id="kobo.1450.1">is used to declare the class that will be inherited from, known as the </span><em class="italic"><span class="kobospan" id="kobo.1451.1">superclass</span></em><span class="kobospan" id="kobo.1452.1"> or </span><em class="italic"><span class="kobospan" id="kobo.1453.1">base class</span></em><span class="kobospan" id="kobo.1454.1">. </span><span class="kobospan" id="kobo.1454.2">In the listing, </span><code class="inlinecode"><span class="kobospan" id="kobo.1455.1">DiscountProduct</span></code><span class="kobospan" id="kobo.1456.1"> inherits from </span><code class="inlinecode"><span class="kobospan" id="kobo.1457.1">Product</span></code><span class="kobospan" id="kobo.1458.1">. </span><span class="kobospan" id="kobo.1458.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1459.1">super</span></code><span class="kobospan" id="kobo.1460.1"> keyword is used to invoke the superclass’s constructor and methods. </span><code class="inlinecode"><span class="kobospan" id="kobo.1461.1">DiscountProduct</span></code><span class="kobospan" id="kobo.1462.1"> builds on the </span><code class="inlinecode"><span class="kobospan" id="kobo.1463.1">Product</span></code><span class="kobospan" id="kobo.1464.1"> functionality to add support for a price reduction, producing the following results:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1465.1">Name: Hat, Price: 90
Name: Boots, Price: 100, Category: Snow Gear
</span></code></pre>
<h2 class="heading1" id="_idParaDest-72"><span class="kobospan" id="kobo.1466.1">Checking object types</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1467.1">When applied </span><a id="_idIndexMarker164" class="calibre3"/><span class="kobospan" id="kobo.1468.1">to an object, the </span><code class="inlinecode"><span class="kobospan" id="kobo.1469.1">typeof</span></code><span class="kobospan" id="kobo.1470.1"> function will return </span><code class="inlinecode"><span class="kobospan" id="kobo.1471.1">object</span></code><span class="kobospan" id="kobo.1472.1">. </span><span class="kobospan" id="kobo.1472.2">To determine whether an object has been derived from a class, the </span><code class="inlinecode"><span class="kobospan" id="kobo.1473.1">instanceof</span></code><span class="kobospan" id="kobo.1474.1"> keyword </span><a id="_idIndexMarker165" class="calibre3"/><span class="kobospan" id="kobo.1475.1">can be used, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1476.1">Listing 3.58</span></em><span class="kobospan" id="kobo.1477.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1478.1">Listing 3.58: Checking an object type in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1479.1">class Product {
    constructor(public name: string, public price: number,
         public category?: string) {
    }
    printDetails() {
        if (this.category != undefined) {
            console.log(`Name: ${this.name}, Price: ${this.price}, ` +
                `Category: ${this.category}`);   
        } else {
            console.log(`Name: ${this.name}, Price: ${this.price}`);   
        }       
    }
}
class DiscountProduct extends Product {
    constructor(name: string, price: number, private discount: number) {
        super(name, price - discount);
    }
}
let hat = new DiscountProduct("Hat", 100, 10);
let boots = new Product("Boots", 100, "Snow Gear");
</span><strong class="screentext"><span class="kobospan" id="kobo.1480.1">// hat.printDetails();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1481.1">// boots.printDetails();</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1482.1">console.log(`Hat is a Product? </span><span class="kobospan" id="kobo.1482.2">${hat instanceof Product}`);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1483.1">console.</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1484.1">log(`Hat is a DiscountProduct? </span><span class="kobospan" id="kobo.1484.2">${hat instanceof DiscountProduct}`);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1485.1">console.log(`Boots is a Product? </span><span class="kobospan" id="kobo.1485.2">${boots instanceof Product}`);</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1486.1">console.</span></strong><strong class="screentext"><span class="kobospan" id="kobo.1487.1">log("Boots is a DiscountProduct? </span><span class="kobospan" id="kobo.1487.2">"</span></strong>
<strong class="screentext"><span class="kobospan" id="kobo.1488.1">  + (boots instanceof DiscountProduct));</span></strong>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1489.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1490.1">instanceof</span></code><span class="kobospan" id="kobo.1491.1"> keyword</span><a id="_idIndexMarker166" class="calibre3"/><span class="kobospan" id="kobo.1492.1"> is used with an object value and a class, and the expression returns </span><code class="inlinecode"><span class="kobospan" id="kobo.1493.1">true</span></code><span class="kobospan" id="kobo.1494.1"> if the object was created from the class or a superclass. </span><span class="kobospan" id="kobo.1494.2">The code in </span><em class="italic"><span class="kobospan" id="kobo.1495.1">Listing 3.58</span></em><span class="kobospan" id="kobo.1496.1"> produces the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1497.1">Hat is a Product? </span><span class="kobospan" id="kobo.1497.2">True
Hat is a DiscountProduct? </span><span class="kobospan" id="kobo.1497.3">True
Boots is a Product? </span><span class="kobospan" id="kobo.1497.4">True
Boots is a DiscountProduct? </span><span class="kobospan" id="kobo.1497.5">false
</span></code></pre>
<h1 class="heading" id="_idParaDest-73"><span class="kobospan" id="kobo.1498.1">Working with JavaScript modules</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.1499.1">JavaScript modules </span><a id="_idIndexMarker167" class="calibre3"/><span class="kobospan" id="kobo.1500.1">are used to break up an application into separate files. </span><span class="kobospan" id="kobo.1500.2">At runtime, the dependencies between modules are resolved, the files containing the modules are loaded, and the code they contain is executed. </span></p>
<h2 class="heading1" id="_idParaDest-74"><span class="kobospan" id="kobo.1501.1">Creating and using modules</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1502.1">Each TypeScript </span><a id="_idIndexMarker168" class="calibre3"/><span class="kobospan" id="kobo.1503.1">or JavaScript file that you add to a </span><a id="_idIndexMarker169" class="calibre3"/><span class="kobospan" id="kobo.1504.1">project is treated as a module. </span><span class="kobospan" id="kobo.1504.2">To demonstrate, I created a folder called </span><code class="inlinecode"><span class="kobospan" id="kobo.1505.1">modules</span></code><span class="kobospan" id="kobo.1506.1"> in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1507.1">primer</span></code><span class="kobospan" id="kobo.1508.1"> folder, added to it a file called </span><code class="inlinecode"><span class="kobospan" id="kobo.1509.1">name.ts</span></code><span class="kobospan" id="kobo.1510.1">, and added the code shown in </span><em class="italic"><span class="kobospan" id="kobo.1511.1">Listing 3.59</span></em><span class="kobospan" id="kobo.1512.1">. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1513.1">Listing 3.59: The contents of the name.ts file in the modules folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1514.1">export class Name {
    constructor(public first: string, public second: string) {}
    get nameMessage() {
        return `Hello ${this.first} ${this.second}`;
    }
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1515.1">The classes, functions, and variables defined in a JavaScript or TypeScript file can be accessed only within that file by default. </span><span class="kobospan" id="kobo.1515.2">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1516.1">export</span></code><span class="kobospan" id="kobo.1517.1"> keyword is used to make features accessible outside of the file so that they can be used by other parts of the application. </span><span class="kobospan" id="kobo.1517.2">In </span><em class="italic"><span class="kobospan" id="kobo.1518.1">Listing 3.59</span></em><span class="kobospan" id="kobo.1519.1">, I have applied the </span><code class="inlinecode"><span class="kobospan" id="kobo.1520.1">export</span></code><span class="kobospan" id="kobo.1521.1"> keyword to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1522.1">Name</span></code><span class="kobospan" id="kobo.1523.1"> class, which means it is available to be used outside of the module.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1524.1">Next, add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.1525.1">weather.ts</span></code><span class="kobospan" id="kobo.1526.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1527.1">modules</span></code><span class="kobospan" id="kobo.1528.1"> folder with the code shown in </span><em class="italic"><span class="kobospan" id="kobo.1529.1">Listing 3.60</span></em><span class="kobospan" id="kobo.1530.1">. </span><span class="kobospan" id="kobo.1530.2">This module exports a class named </span><code class="inlinecode"><span class="kobospan" id="kobo.1531.1">WeatherLocation</span></code><span class="kobospan" id="kobo.1532.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1533.1">Listing 3.60: The contents of the weather.ts file in the modules folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1534.1">export class WeatherLocation {
    constructor(public weather: string, public city: string) {}
    get weatherMessage() {
        return `It is ${this.weather} in ${this.city}`;
    }
}
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1535.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1536.1">import</span></code><span class="kobospan" id="kobo.1537.1"> keyword </span><a id="_idIndexMarker170" class="calibre3"/><span class="kobospan" id="kobo.1538.1">is used to declare a dependency </span><a id="_idIndexMarker171" class="calibre3"/><span class="kobospan" id="kobo.1539.1">on the features that a module provides. </span><span class="kobospan" id="kobo.1539.2">In </span><em class="italic"><span class="kobospan" id="kobo.1540.1">Listing 3.61</span></em><span class="kobospan" id="kobo.1541.1">, I have used the </span><code class="inlinecode"><span class="kobospan" id="kobo.1542.1">Name</span></code><span class="kobospan" id="kobo.1543.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.1544.1">WeatherLocation</span></code><span class="kobospan" id="kobo.1545.1"> classes in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1546.1">index.ts</span></code><span class="kobospan" id="kobo.1547.1"> file, which means I have to use the </span><code class="inlinecode"><span class="kobospan" id="kobo.1548.1">import</span></code><span class="kobospan" id="kobo.1549.1"> keyword to declare a dependency on them and the modules they come from. </span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1550.1">Listing 3.61: Importing specific types in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1551.1">import { Name } from "./modules/name";
import { WeatherLocation } from "./modules/weather";
let name = new Name("Adam", "Freeman");
let loc = new WeatherLocation("raining", "London");
console.log(name.nameMessage);
console.log(loc.weatherMessage);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1552.1">This is the way that I use the </span><code class="inlinecode"><span class="kobospan" id="kobo.1553.1">import</span></code><span class="kobospan" id="kobo.1554.1"> keyword in most of the examples in this book. </span><span class="kobospan" id="kobo.1554.2">The keyword is followed by curly braces that contain a comma-separated list of the features that the code in the current files depends on, followed by the </span><code class="inlinecode"><span class="kobospan" id="kobo.1555.1">from</span></code><span class="kobospan" id="kobo.1556.1"> keyword, followed by the module name. </span><span class="kobospan" id="kobo.1556.2">In this case, I have imported the </span><code class="inlinecode"><span class="kobospan" id="kobo.1557.1">Name</span></code><span class="kobospan" id="kobo.1558.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.1559.1">WeatherLocation</span></code><span class="kobospan" id="kobo.1560.1"> classes </span><a id="_idIndexMarker172" class="calibre3"/><span class="kobospan" id="kobo.1561.1">from the modules in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1562.1">modules</span></code><span class="kobospan" id="kobo.1563.1"> folder. </span><span class="kobospan" id="kobo.1563.2">Notice that the file </span><a id="_idIndexMarker173" class="calibre3"/><span class="kobospan" id="kobo.1564.1">extension is not included when specifying the module.</span></p>
<p class="normal"><span class="kobospan" id="kobo.1565.1">When the </span><code class="inlinecode"><span class="kobospan" id="kobo.1566.1">index.ts</span></code><span class="kobospan" id="kobo.1567.1"> file is compiled, the TypeScript compiler detects the dependency on the code in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1568.1">name.ts</span></code><span class="kobospan" id="kobo.1569.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.1570.1">weather.ts</span></code><span class="kobospan" id="kobo.1571.1"> files, so that pure JavaScript versions of the modules are created. </span><span class="kobospan" id="kobo.1571.2">During execution, Node.js detects the dependencies in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1572.1">index.js</span></code><span class="kobospan" id="kobo.1573.1"> file and resolves them using the </span><code class="inlinecode"><span class="kobospan" id="kobo.1574.1">name.js</span></code><span class="kobospan" id="kobo.1575.1"> and </span><code class="inlinecode"><span class="kobospan" id="kobo.1576.1">weather.js</span></code><span class="kobospan" id="kobo.1577.1"> files that the compiler creates, producing the following output:</span></p>
<pre class="programlisting1"><code class="hljs-con"><span class="kobospan" id="kobo.1578.1">Hello Adam Freeman
It is raining in London
</span></code></pre>
<h2 class="heading1" id="_idParaDest-75"><span class="kobospan" id="kobo.1579.1">Consolidating module contents</span></h2>
<p class="normal1"><span class="kobospan" id="kobo.1580.1">In later </span><a id="_idIndexMarker174" class="calibre3"/><span class="kobospan" id="kobo.1581.1">examples, especially the SportsStore application in </span><em class="italic"><span class="kobospan" id="kobo.1582.1">Part 3</span></em><span class="kobospan" id="kobo.1583.1">, I consolidate the contents of module folders so that all of the important features can be imported in a single statement, even though they are defined in separate code files. </span><span class="kobospan" id="kobo.1583.2">To see how this works, add a file named </span><code class="inlinecode"><span class="kobospan" id="kobo.1584.1">index.ts</span></code><span class="kobospan" id="kobo.1585.1"> to the </span><code class="inlinecode"><span class="kobospan" id="kobo.1586.1">modules</span></code><span class="kobospan" id="kobo.1587.1"> folder, with the content shown in </span><em class="italic"><span class="kobospan" id="kobo.1588.1">Listing 3.62</span></em><span class="kobospan" id="kobo.1589.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1590.1">Listing 3.62: The contents of the index.ts file in the modules folder</span></p>
<pre class="programlisting"><code class="hljs-code"><span class="kobospan" id="kobo.1591.1">export { Name } from "./name";
export { WeatherLocation } from "./weather";
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1592.1">The </span><code class="inlinecode"><span class="kobospan" id="kobo.1593.1">index.ts</span></code><span class="kobospan" id="kobo.1594.1"> file contains </span><code class="inlinecode"><span class="kobospan" id="kobo.1595.1">export</span></code><span class="kobospan" id="kobo.1596.1"> statements for the features defined in each code file. </span><span class="kobospan" id="kobo.1596.2">This allows these features to be imported by specifying the name of the containing folder, without specifying individual files, as shown in </span><em class="italic"><span class="kobospan" id="kobo.1597.1">Listing 3.63</span></em><span class="kobospan" id="kobo.1598.1">.</span></p>
<p class="packt_figref"><span class="kobospan" id="kobo.1599.1">Listing 3.63: Importing a module folder in the index.ts file in the primer folder</span></p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext"><span class="kobospan" id="kobo.1600.1">import { Name, WeatherLocation } from "./modules";</span></strong><span class="kobospan" id="kobo.1601.1">
let name = new Name("Adam", "Freeman");
let loc = new WeatherLocation("raining", "London");
console.log(name.nameMessage);
console.log(loc.weatherMessage);
</span></code></pre>
<p class="normal"><span class="kobospan" id="kobo.1602.1">This listing </span><a id="_idIndexMarker175" class="calibre3"/><span class="kobospan" id="kobo.1603.1">produces the same output as </span><em class="italic"><span class="kobospan" id="kobo.1604.1">Listing 3.61</span></em><span class="kobospan" id="kobo.1605.1">.</span></p>
<div class="note">
<p class="normal"><strong class="screentext"><span class="kobospan" id="kobo.1606.1">Understanding Module Resolution</span></strong></p>
<p class="normal"><span class="kobospan" id="kobo.1607.1">You will see two different ways of specifying modules in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1608.1">import</span></code><span class="kobospan" id="kobo.1609.1"> statements in this book. </span><span class="kobospan" id="kobo.1609.2">The first is a relative module, in which the name of the module is prefixed with </span><code class="inlinecode"><span class="kobospan" id="kobo.1610.1">./</span></code><span class="kobospan" id="kobo.1611.1">, like this example from </span><em class="italic"><span class="kobospan" id="kobo.1612.1">Listing 3.60</span></em><span class="kobospan" id="kobo.1613.1">: </span></p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2"><span class="kobospan" id="kobo.1614.1">...</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.1615.1">import { Name, WeatherLocation } from "./modules";</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.1616.1">...</span></code>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1617.1">This statement specifies a module located relative to the file that contains the </span><code class="inlinecode"><span class="kobospan" id="kobo.1618.1">import</span></code><span class="kobospan" id="kobo.1619.1"> statement. </span><span class="kobospan" id="kobo.1619.2">In this case, since no filename has been specified, it is the </span><code class="inlinecode"><span class="kobospan" id="kobo.1620.1">index.ts</span></code><span class="kobospan" id="kobo.1621.1"> file in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1622.1">modules</span></code><span class="kobospan" id="kobo.1623.1"> directory that will be loaded. </span><span class="kobospan" id="kobo.1623.2">The other type of import is nonrelative. </span><span class="kobospan" id="kobo.1623.3">Here is an example of a nonrelative </span><code class="inlinecode"><span class="kobospan" id="kobo.1624.1">import</span></code><span class="kobospan" id="kobo.1625.1"> you will see in later chapters:</span></p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2"><span class="kobospan" id="kobo.1626.1">...</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.1627.1">import { Express } from "express";</span></code>
<code class="inlinecode2"><span class="kobospan" id="kobo.1628.1">...</span></code>
</code></pre>
<p class="normal"><span class="kobospan" id="kobo.1629.1">The module in this </span><code class="inlinecode"><span class="kobospan" id="kobo.1630.1">import</span></code><span class="kobospan" id="kobo.1631.1"> statement doesn’t start with </span><code class="inlinecode"><span class="kobospan" id="kobo.1632.1">./</span></code><span class="kobospan" id="kobo.1633.1">, and the dependency is resolved by looking for a package in the </span><code class="inlinecode"><span class="kobospan" id="kobo.1634.1">node_modules</span></code><span class="kobospan" id="kobo.1635.1"> folder. </span><span class="kobospan" id="kobo.1635.2">In this case, the dependency is on a feature provided by the </span><code class="inlinecode"><span class="kobospan" id="kobo.1636.1">express</span></code><span class="kobospan" id="kobo.1637.1"> package, which is introduced in </span><em class="italic"><span class="kobospan" id="kobo.1638.1">Chapter 5</span></em><span class="kobospan" id="kobo.1639.1">.</span></p>
</div>
<h1 class="heading" id="_idParaDest-76"><span class="kobospan" id="kobo.1640.1">Summary</span></h1>
<p class="normal1"><span class="kobospan" id="kobo.1641.1">In this chapter, I described the basic TypeScript and JavaScript features to provide a foundation for the chapters that follow.</span></p>
<ul class="calibre4">
<li class="bulletlist"><span class="kobospan" id="kobo.1642.1">JavaScript is a dynamically typed and weakly typed language, which is an uncommon combination in modern programming languages.</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1643.1">Values of any type can be assigned to variables, constants, and function parameters.</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1644.1">JavaScript will coerce (convert) values to other types to perform comparisons and other operations.</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1645.1">TypeScript is a superset of JavaScript that allows developers to clearly express their assumptions about data types when writing code.</span></li>
<li class="bulletlist1"><span class="kobospan" id="kobo.1646.1">TypeScript doesn’t change the JavaScript type system and TypeScript files are compiled into pure JavaScript.</span></li>
</ul>
<p class="normal"><span class="kobospan" id="kobo.1647.1">In the next chapter, I will describe one of the fundamental concepts that is critical for understanding Node.js and its role in web applications: concurrency.</span></p>
</div>
</body></html>