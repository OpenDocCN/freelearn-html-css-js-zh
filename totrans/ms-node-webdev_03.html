<html><head></head><body>
<div><h1 class="chapternumber">3</h1>
<h1 class="chaptertitle" id="_idParaDest-33">JavaScript and TypeScript Primer</h1>
<p class="normal1">Developers come to the world of web app development via many paths and are not always grounded in the basic technologies that web apps rely on. In this chapter, I introduce the basic features of JavaScript and TypeScript. This is not a comprehensive guide to either language, but it addresses the essentials, and it will give you the knowledge you need to get started.</p>
<h1 class="heading" id="_idParaDest-34">Preparing for this chapter</h1>
<p class="normal1">To prepare for this chapter, create a folder named <code class="inlinecode">primer</code> in a convenient location. Navigate to the <code class="inlinecode">primer</code> folder and run the command shown in <em class="italic">Listing 3.1</em>.</p>
<p class="packt_figref">Listing 3.1: Preparing the project folder</p>
<pre class="programlisting1"><code class="hljs-con">npm init --yes
</code></pre>
<p class="normal">Run the command shown in <em class="italic">Listing 3.2</em> in the <code class="inlinecode">primer</code> folder to install the development packages that are used in this chapter.</p>
<p class="packt_figref">Listing 3.2: Installing the development package</p>
<pre class="programlisting1"><code class="hljs-con">npm install nodemon@2.0.20
npm install tsc-watch@6.0.4
npm install typescript@5.2.2
npm install @tsconfig/node20@20.1.4
npm install @types/node@20.6.1
</code></pre>
<p class="normal">The <code class="inlinecode">nodemon</code> package will be used at the start of the chapter to monitor and execute JavaScript files. The <code class="inlinecode">tsc-watc1h</code> package does the same thing for TypeScript files, and the <code class="inlinecode">typescript</code> package contains the TypeScript compiler. The <code class="inlinecode">@tsconfig/node20</code> package contains configuration settings for the TypeScript compiler for use in Node.js projects.</p>
<p class="normal">Replace the <code class="inlinecode">scripts</code> section in the <code class="inlinecode">package.json</code> file as shown in <em class="italic">Listing 3.3</em>, which will make it easier to use the development packages.</p>
<p class="packt_figref">Listing 3.3: Replacing the scripts section in the package.json file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">{
  "name": "primer",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
   <strong class="screentext"> "use_js": "nodemon",</strong>
<strong class="screentext">    "</strong><strong class="screentext">use_ts": "tsc-watch --onSuccess \"node index.js\""</strong>
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@tsconfig/node20": "^20.1.4",
    "@types/node": "^20.6.1",
    "nodemon": "^2.0.20",
    "tsc-watch": "^6.0.4",
    "typescript": "^5.2.2"
  }
}
</code></pre>
<p class="normal">Add a file named <code class="inlinecode">tsconfig.json</code> to the <code class="inlinecode">primer</code> folder with the content shown in <em class="italic">Listing 3.4</em>, which creates a basic configuration for the TypeScript compiler suitable for a Node.js project.</p>
<p class="packt_figref">Listing 3.4: The contents of the tsconfig.json file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">{
    "extends": "@tsconfig/node20/tsconfig.json"
}
</code></pre>
<p class="normal">Add a file named <code class="inlinecode">index.js</code> to the <code class="inlinecode">primer</code> folder with the content shown in <em class="italic">Listing 3.5</em>.</p>
<p class="packt_figref">Listing 3.5: The contents of the index.js file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">console.log("Hello, World");
</code></pre>
<p class="normal">Run the command shown in <em class="italic">Listing 3.6</em> in the <code class="inlinecode">primer</code> folder to start monitoring and executing JavaScript files.</p>
<p class="packt_figref">Listing 3.6: Starting the development tools</p>
<pre class="programlisting1"><code class="hljs-con">npm run use_js
</code></pre>
<p class="normal">The monitor will generate output similar to the following and will include the message written by the statement in <em class="italic">Listing 3.5</em>:</p>
<pre class="programlisting1"><code class="hljs-con">[nodemon] 2.0.20
[nodemon] to restart at any time, enter `rs`
[nodemon] watching path(s): *.*
[nodemon] watching extensions: js,mjs,json
[nodemon] starting `node index.js`
<strong class="screentext">Hello, World</strong>
[nodemon] clean exit - waiting for changes before restart
</code></pre>
<p class="normal">Any change to the <code class="inlinecode">index.js</code> file will be detected by the <code class="inlinecode">nodemon</code> package and will be executed by the Node.js runtime.</p>
<h1 class="heading" id="_idParaDest-35">Understanding JavaScript confusion</h1>
<p class="normal1">JavaScript<a id="_idIndexMarker056" class="calibre3"/> is an incredible language that has been the engine of transformation for web application development. I love JavaScript and will extol its virtues to anyone foolish enough to ask; it is one of the most fluid and expressive languages I have used.</p>
<p class="normal">That said, JavaScript is a little odd and it causes confusion. At first glance, JavaScript<a id="_idIndexMarker057" class="calibre3"/> looks like any other programming language, which gives programmers new to the language a sense of confidence. That confidence does not last, and it is only a matter of time until the separate searches on Stack Overflow begin.</p>
<p class="normal">JavaScript isn’t like other mainstream languages. To see the most confusing features, replace the contents of the <code class="inlinecode">index.js</code> file with the code shown in <em class="italic">Listing 3.7</em>.</p>
<p class="packt_figref">Listing 3.7: Replacing the contents of the index.js file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">function sum(first, second) {</strong>
<strong class="screentext">    return first + second;</strong>
<strong class="screentext">}</strong>
<strong class="screentext">let result = </strong><strong class="screentext">sum(10, 10);</strong>
<strong class="screentext">console.log(`Result value: ${result}, Result type: ${typeof result}`);</strong>
<strong class="screentext">result = sum(</strong><strong class="screentext">10, "10");</strong>
<strong class="screentext">console.log(`Result value: ${result}, Result type: ${typeof result}`);</strong>
</code></pre>
<p class="normal">Save the changes and the contents of the file will be executed, producing the following results:</p>
<pre class="programlisting1"><code class="hljs-con">Result value: 20, Result type: number
Result value: 1010, Result type: string
</code></pre>
<p class="normal">There are two calls to a function named <code class="inlinecode">sum</code>, and JavaScript allows different types to be used as the function arguments. The first call uses two number values (<code class="inlinecode">10</code> and <code class="inlinecode">10</code>). The second call uses a number value (<code class="inlinecode">10</code>) and a string value (<code class="inlinecode">"10"</code>).</p>
<p class="normal">JavaScript is <em class="italic">dynamically typed</em>, which means that variables are not restricted to a specific type of value, and any type of value can be assigned to any variable, including function parameters.</p>
<p class="normal">If you look at the output produced by <em class="italic">Listing 3.7</em>, you will see that the function results are oddly different and have different types:</p>
<pre class="programlisting1"><code class="hljs-con">Result value: <strong class="screentext">20</strong>, Result type: <strong class="screentext">number</strong>
Result value: <strong class="screentext">1010</strong>, Result type: <strong class="screentext">string</strong>
</code></pre>
<p class="normal">JavaScript is also <em class="italic">weakly typed</em>, which means that values will be implicitly converted so<a id="_idIndexMarker058" class="calibre3"/> they can be used together, through a process known as <em class="italic">type coercion</em>. This can be a convenient feature, but it can lead to unexpected results because values are coerced in different ways based on the operation that is performed. When the <code class="inlinecode">+</code> operator is applied to a pair of <code class="inlinecode">number</code> values, JavaScript adds the two values together to produce a <code class="inlinecode">number</code> value. If the <code class="inlinecode">+</code> operator is applied to a <code class="inlinecode">string</code> and <code class="inlinecode">number</code> value, then JavaScript converts the <code class="inlinecode">number</code> value to <code class="inlinecode">string</code> and concatenates the values to produce a <code class="inlinecode">string</code> result. This is why <code class="inlinecode">"10" + 10</code> produces the <code class="inlinecode">string</code> result <code class="inlinecode">1010</code>, but <code class="inlinecode">10 + 10</code> produces the number result <code class="inlinecode">20</code>.</p>
<h2 class="heading1" id="_idParaDest-36">Using the JavaScript features to express type expectations</h2>
<p class="normal1">The way <a id="_idIndexMarker059" class="calibre3"/>that JavaScript handles data types can be confusing, especially when first using the language, but the behavior is consistent and predictable once you understand what’s happening.</p>
<p class="normal">A bigger issue is that it can be difficult to communicate the assumptions and expectations used to write JavaScript code. The <code class="inlinecode">sum</code> function is incredibly simple, but with more complex functions, it can be difficult to figure out which data types are expected and which data types will be returned.</p>
<p class="normal">JavaScript provides features for checking types, which can be used to enforce type expectations, as shown in <em class="italic">Listing 3.8</em>.</p>
<p class="packt_figref">Listing 3.8: Checking types in the index.js file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function sum(first, second) {
   <strong class="screentext"> if (typeof first == "number" &amp;&amp; typeof second == "number") {</strong>
<strong class="screentext">        return</strong><strong class="screentext"> first + second;</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    throw Error("Expected two numbers");</strong>
}
let result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</code></pre>
<p class="normal">The <code class="inlinecode">typeof</code> keyword is used to check that both parameters are <code class="inlinecode">number</code> values and uses the <code class="inlinecode">throw</code> keyword to create an error if any other type is received. When the code is <a id="_idIndexMarker060" class="calibre3"/>executed, the first call to the <code class="inlinecode">sum</code> function works, but the second fails:</p>
<pre class="programlisting1"><code class="hljs-con">Result value: 20, Result type: number
C:\primer\index.js:5
    throw Error("Expected two numbers");
    ^
Error: Expected two numbers at sum (C:\primer\index.js:5:11)
</code></pre>
<p class="normal">These kinds of type checks are effective but they are only applied when the JavaScript code is executed, and that means that thorough testing is required to ensure that the <code class="inlinecode">sum</code> function isn’t invoked with the wrong types.</p>
<h2 class="heading1" id="_idParaDest-37">Using JavaScript to check type expectations</h2>
<p class="normal1">TypeScript doesn’t change the way that the JavaScript type system works but it does make it easier to express and enforce type expectations, so that type mismatches can be found and resolved more easily. Add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">primer</code> folder with the content shown in <em class="italic">Listing 3.9</em>.</p>
<p class="packt_figref">Listing 3.9: The contents of the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function sum(first: number, second: number) {
    return first + second;
}
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</code></pre>
<p class="normal">Use <code class="inlinecode">Control+C</code> to stop the <code class="inlinecode">npm</code> command that executes JavaScript code, and run the command shown in <em class="italic">Listing 3.10</em> in the <code class="inlinecode">primer</code> folder to start the command that runs TypeScript.</p>
<p class="packt_figref">Listing 3.10: Starting the TypeScript tools</p>
<pre class="programlisting1"><code class="hljs-con">npm run use_ts
</code></pre>
<p class="normal">The TypeScript compiler processes the contents of the <code class="inlinecode">index.ts</code> file and generates the following error:</p>
<pre class="programlisting1"><code class="hljs-con">index.ts(5,22): error TS2345: Argument of type 'string' is not assignable to parameter of type 'number'.
</code></pre>
<p class="normal">The <code class="inlinecode">sum</code> function<a id="_idIndexMarker061" class="calibre3"/> parameters are decorated with <em class="italic">type annotations</em>, which tell the TypeScript compiler that the <code class="inlinecode">sum</code> function expects to receive only <code class="inlinecode">number</code> values. The compiler inspects the values used as arguments when the function is invoked and reports an error because one of the arguments is not <code class="inlinecode">number</code>.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">If you are using Visual Studio Code, you may see an error displayed in the editor window with the message <em class="italic">Cannot redeclare block-scoped variable</em>. This happens when the TypeScript and JavaScript files are both open for editing. If you close the JavaScript file, the error will disappear.</p>
</div>
<h3 class="heading2" id="_idParaDest-38">Using a type union</h3>
<p class="normal1">Using a<a id="_idIndexMarker062" class="calibre3"/> single type, such as <code class="inlinecode">number</code>, in an annotation makes JavaScript behave more like other programming languages but restricts some of the flexibility of the dynamic JavaScript type system. JavaScript code can be written to intentionally support multiple types, as shown in <em class="italic">Listing 3.11</em>.</p>
<p class="packt_figref">Listing 3.11. Supporting multiple types in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">function sum(first: number, second: number) {</strong>
<strong class="screentext">    if</strong><strong class="screentext"> (typeof second == "string") {</strong>
<strong class="screentext">        return first + Number.parseInt(second);</strong>
<strong class="screentext">    } else {</strong>
<strong class="screentext">        return first + second;</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</code></pre>
<p class="normal">The <code class="inlinecode">sum</code> function<a id="_idIndexMarker063" class="calibre3"/> checks to see whether the <code class="inlinecode">second</code> parameter is a string value and, if it is, uses the built-in <code class="inlinecode">Number.parseInt</code> function to convert it to a <code class="inlinecode">number</code> value.</p>
<p class="normal">This has caused a mismatch between the capabilities of the function and the type annotations applied to the parameters, and so the compiler produces the same error as for <em class="italic">Listing 3.10</em>. The mismatch can be resolved using a <em class="italic">type union</em>, as shown in <em class="italic">Listing 3.12</em>.</p>
<p class="packt_figref">Listing 3.12: Using a type union in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">function sum(first: number, second: number | string) {</strong>
    if (typeof second == "string") {
        return first + Number.parseInt(second);
    } else {
        return first + second;       
    }
}
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</code></pre>
<p class="normal">A bar (the <code class="inlinecode">|</code> character) is used to combine types, so that <code class="inlinecode">number | string</code> tells the compiler that the <code class="inlinecode">second</code> parameter can be a <code class="inlinecode">number</code> value or a <code class="inlinecode">string</code> value. The TypeScript checks all uses of the <code class="inlinecode">sum</code> function and finds that all of the types used as arguments match the type annotations. The code produces the following output when it is executed:</p>
<pre class="programlisting1"><code class="hljs-con">Result value: 20, Result type: number
Result value: 20, Result type: number
</code></pre>
<p class="normal">The TypeScript<a id="_idIndexMarker064" class="calibre3"/> compiler is clever and uses JavaScript features like the <code class="inlinecode">typeof</code> keyword to figure out how types are being used. <em class="italic">Listing 3.13</em> changes the implementation of the <code class="inlinecode">sum</code> function so that <code class="inlinecode">string</code> values are no longer treated separately from <code class="inlinecode">number</code> values.</p>
<p class="packt_figref">Listing 3.13: Changing the function in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function sum(first: number, second: number | string) {
   <strong class="screentext"> return first + second;</strong>
}
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</code></pre>
<p class="normal">The TypeScript compiler knows that JavaScript will do different things when it applies the addition operator to two <code class="inlinecode">number</code> values or <code class="inlinecode">string</code> and <code class="inlinecode">number</code>, which means that this statement produces an ambiguous result:</p>
<pre class="programlisting"><code class="hljs-code">...
return first + second;       
...
</code></pre>
<p class="normal">TypeScript is designed to avoid ambiguity, and the compiler will generate the following error when compiling the code:</p>
<pre class="programlisting1"><code class="hljs-con">index.ts(2,12): error TS2365: Operator '+' cannot be applied to types 'number' and 'string | number'.
</code></pre>
<p class="normal">The purpose of TypeScript is only to highlight potential problems, not to enforce any particular solution to a problem. The code in <em class="italic">Listing 3.13</em> is legal JavaScript, but the TypeScript compiler has generated an error because there is a mismatch between the type annotations applied to the parameters and the way that the parameter values are used inside the <code class="inlinecode">sum</code> function.</p>
<p class="normal">One way to resolve<a id="_idIndexMarker065" class="calibre3"/> this problem is to return to the code in <em class="italic">Listing 3.12</em>, which is sensible if the <code class="inlinecode">sum</code> function wants to process <code class="inlinecode">number</code> and <code class="inlinecode">string</code> values without type coercion. An alternative is to tell the compiler that the ambiguity is intentional, as shown in <em class="italic">Listing 3.14</em>, which is sensible if type coercion is required.</p>
<p class="packt_figref">Listing 3.14: Resolving ambiguity in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function sum(first: number, second: number | string) {
    <strong class="screentext">return first + (second as any);</strong>
}
let result = sum(10, "10");
console.log(`Result value: ${result}, Result type: ${typeof result}`);
result = sum(10, 10);
console.log(`Result value: ${result}, Result type: ${typeof result}`);
</code></pre>
<p class="normal">The <code class="inlinecode">as</code> keyword tells the TypeScript compiler that its knowledge of the <code class="inlinecode">second</code> value is incomplete and that it should treat it as a type that I specify. In this case, I have specified the <code class="inlinecode">any</code> type, which has the effect of telling the TypeScript that ambiguity is expected and prevents it from producing an error. This code produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Result value: 1010, Result type: string
Result value: 20, Result type: number
</code></pre>
<p class="normal">The <code class="inlinecode">as</code> keyword should be used with caution because the TypeScript compiler is sophisticated and usually has a good understanding of how data types are being used. Equally, using the <code class="inlinecode">any</code> type can be dangerous because it essentially stops the TypeScript compiler from checking types. When you tell the TypeScript compiler that you know more about the code, then you need to make sure that you are right; otherwise, you will return to the runtime error issue that led to the introduction of TypeScript in the first place.</p>
<h1 class="heading" id="_idParaDest-39">Understanding the basic TypeScript/JavaScript features</h1>
<p class="normal1">Now that you understand the relationship between TypeScript and JavaScript, it is time to describe <a id="_idIndexMarker066" class="calibre3"/>the basic language features you will need to follow the examples in this book. This is not a comprehensive guide to either <a id="_idIndexMarker067" class="calibre3"/>TypeScript or JavaScript, but it should be enough to get you started.</p>
<h2 class="heading1" id="_idParaDest-40">Defining variables and constants</h2>
<p class="normal1">The <code class="inlinecode">let</code> keyword is <a id="_idIndexMarker068" class="calibre3"/>used to define variables, and the <code class="inlinecode">const</code> keyword<a id="_idIndexMarker069" class="calibre3"/> is used to define a constant value that will not change, as shown in <em class="italic">Listing 3.15</em>.</p>
<p class="packt_figref">Listing 3.15: Defining variables and constants in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let condition = true;
let person = "Bob";
const age = 40;
</code></pre>
<p class="normal">The TypeScript compiler infers the type of each variable or constant from the value it is assigned and will generate an error if a value of a different type is assigned. Types can be specified explicitly, as shown in <em class="italic">Listing 3.16</em>.</p>
<p class="packt_figref">Listing 3.16. Specifying types in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">let condition: boolean = true;</strong>
<strong class="screentext">let person: string = "Bob";</strong>
<strong class="screentext">const age: number = 40</strong><strong class="screentext">;</strong>
</code></pre>
<h2 class="heading1" id="_idParaDest-41">Dealing with unassigned and null values</h2>
<p class="normal1">In <a id="_idIndexMarker070" class="calibre3"/>JavaScript, variables that have been defined but not assigned a value are assigned the special value <code class="inlinecode">undefined</code>, whose type is <code class="inlinecode">undefined</code>, as shown in <em class="italic">Listing 3.17</em>.</p>
<p class="packt_figref">Listing 3.17: Defining a variable without a value in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let condition: boolean = true;
let person: string = "Bob";
const age: number = 40;
let place;
console.log("Place value: " + place + " Type: " + typeof(place));
place = "London";
console.log("Place value: " + place + " Type: " + typeof(place));
</code></pre>
<p class="normal">This code produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Place value: undefined Type: undefined
Place value: London Type: string
</code></pre>
<p class="normal">This <a id="_idIndexMarker071" class="calibre3"/>behavior may seem nonsensical in isolation, but it is consistent with the rest of JavaScript, where values have types, and any value can be assigned to a variable. JavaScript also defines a separate special value, <code class="inlinecode">null</code>, which can be assigned to variables to indicate no value or result, as shown in <em class="italic">Listing 3.18</em>.</p>
<p class="packt_figref">Listing 3.18: Assigning null in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let condition: boolean = true;
let person: string = "Bob";
const age: number = 40;
let place;
console.log("Place value: " + place + " Type: " + typeof(place));
place = "London";
console.log("Place value: " + place + " Type: " + typeof(place));
<strong class="screentext">place = null;</strong>
<strong class="screentext">console.log("Place value: " + place + " Type: " + typeof(place));</strong>
</code></pre>
<p class="normal">I can generally provide a robust defense of the way that JavaScript features work, but there is an oddity of the <code class="inlinecode">null</code> value that makes little sense, which can be seen in the output this code produces:</p>
<pre class="programlisting1"><code class="hljs-con">Place value: undefined Type: undefined
Place value: London Type: string
Place value: null Type: object
</code></pre>
<p class="normal">The <a id="_idIndexMarker072" class="calibre3"/>oddity is that the type of the special <code class="inlinecode">null</code> value is <code class="inlinecode">object</code>. This JavaScript quirk dates back to the first version of JavaScript and hasn’t been addressed because so much code has been written that depends on it. Leaving aside this inconsistency, when the TypeScript compiler processes the code, it determines that values of different types are assigned to the <code class="inlinecode">place</code> variable and infers the variable’s type as <code class="inlinecode">any</code>.</p>
<p class="normal">The <code class="inlinecode">any</code> type allows values of any type to be used, which effectively disables the TypeScript compiler’s type checks. A type union can be used to restrict the values that can be used, while still allowing <code class="inlinecode">undefined</code> and <code class="inlinecode">null</code> to be used, as shown in <em class="italic">Listing 3.19</em>.</p>
<p class="packt_figref">Listing 3.19: Using a type union in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let condition: boolean = true;
let person: string = "Bob";
const age: number = 40;
<strong class="screentext">let place: string | undefined</strong><strong class="screentext"> | null;</strong>
console.log("Place value: " + place + " Type: " + typeof(place));
place = "London";
console.log("Place value: " + place + " Type: " + typeof(place));
place = null;
console.log("Place value: " + place + " Type: " + typeof(place));
</code></pre>
<p class="normal">This type union allows the <code class="inlinecode">place</code> variable to be assigned <code class="inlinecode">string</code> values or <code class="inlinecode">undefined</code> or <code class="inlinecode">null</code>. Notice that <code class="inlinecode">null</code> is specified by value in the type union. This listing produces the same output as <em class="italic">Listing 3.18</em>.</p>
<h2 class="heading1" id="_idParaDest-42">Using the JavaScript primitive types</h2>
<p class="normal1">JavaScript defines<a id="_idIndexMarker073" class="calibre3"/> a small set of commonly used primitive types: <code class="inlinecode">string</code>, <code class="inlinecode">number</code>, <code class="inlinecode">boolean</code>, <code class="inlinecode">undefined</code>, and <code class="inlinecode">null</code>. This may seem like a short list, but JavaScript manages to fit a lot of flexibility into these types. (There are also <code class="inlinecode">symbol</code> and <code class="inlinecode">bigint</code> types, but these are relatively new additions to JavaScript and are not as widely used and not used in this book.)</p>
<h3 class="heading2" id="_idParaDest-43">Working with booleans</h3>
<p class="normal1">The <code class="inlinecode">boolean</code> type <a id="_idIndexMarker074" class="calibre3"/>has two values: <code class="inlinecode">true</code> and <code class="inlinecode">false</code>. <em class="italic">Listing 3.20</em> shows both values being used, but this type is most useful when used <a id="_idIndexMarker075" class="calibre3"/>in conditional statements, such as an <code class="inlinecode">if</code> statement. There is no output from this listing. </p>
<p class="packt_figref">Listing 3.20: Defining boolean values in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let firstBool = true;
let secondBool = false;
</code></pre>
<h3 class="heading2" id="_idParaDest-44">Working with strings</h3>
<p class="normal1">You<a id="_idIndexMarker076" class="calibre3"/> define <code class="inlinecode">string</code> values using either the<a id="_idIndexMarker077" class="calibre3"/> double or single quote characters, as shown in <em class="italic">Listing 3.21</em>. </p>
<p class="packt_figref">Listing 3.21: Defining string variables in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let firstString = "This is a string";
let secondString = 'And so is this';
</code></pre>
<p class="normal">The quote characters you use must match. You can’t start a string with a single quote and finish with a double quote, for example. There is no output from this listing.</p>
<h3 class="heading2" id="_idParaDest-45">Using template strings</h3>
<p class="normal1">A common <a id="_idIndexMarker078" class="calibre3"/>programming task is to combine <a id="_idIndexMarker079" class="calibre3"/>static content with data values to produce a string that can be presented to the user. JavaScript supports <em class="italic">template strings</em>, which allow data values to be specified in line with static content, as shown in <em class="italic">Listing 3.22</em>.</p>
<p class="packt_figref">Listing 3.22: Using a template string in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let place: string | undefined | null;
console.log(`Place value: ${place} Type: ${typeof(place)}`);
</code></pre>
<p class="normal">Template strings<a id="_idIndexMarker080" class="calibre3"/> begin and end with <a id="_idIndexMarker081" class="calibre3"/>backticks (the <code class="inlinecode">`</code> character), and data values are denoted by curly braces preceded by a dollar sign. This string, for example, incorporates the value of the <code class="inlinecode">place</code> variable and its type into the template string:</p>
<pre class="programlisting"><code class="hljs-code">...
console.log(`Place value: ${place} Type: ${typeof(place)}`);
...
</code></pre>
<p class="normal">This example produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Place value: undefined Type: undefined
</code></pre>
<h3 class="heading2" id="_idParaDest-46">Working with numbers</h3>
<p class="normal1">The <code class="inlinecode">number</code> type is<a id="_idIndexMarker082" class="calibre3"/> used to represent both <em class="italic">integer</em> and <em class="italic">floating-point</em> numbers, as shown in <em class="italic">Listing 3.23</em>. </p>
<p class="packt_figref">Listing 3.23: Defining number values in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let daysInWeek = 7;
let pi = 3.14;
let hexValue = 0xFFFF;
</code></pre>
<p class="normal">You don’t have to <a id="_idIndexMarker083" class="calibre3"/>specify which kind of number you are using. You just express the value you require, and JavaScript will act accordingly. In the listing, I have defined an integer value, defined a floating-point value, and prefixed a value with <code class="inlinecode">0x</code> to denote a hexadecimal value. <em class="italic">Listing 3.23</em> doesn’t produce any output.</p>
<h3 class="heading2" id="_idParaDest-47">Working with null and undefined values</h3>
<p class="normal1">The <code class="inlinecode">null</code> and <code class="inlinecode">undefined</code> values have no features, such as properties or methods, but the <a id="_idIndexMarker084" class="calibre3"/>unusual approach<a id="_idIndexMarker085" class="calibre3"/> taken by JavaScript means that you can only assign these values to variables whose type is a union that includes <code class="inlinecode">null</code> or <code class="inlinecode">undefined</code>, as shown in <em class="italic">Listing 3.24</em>. </p>
<p class="packt_figref">Listing 3.24: Assigning null and undefined values in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let person1 = "Alice";
let person2: string | undefined = "Bob";
</code></pre>
<p class="normal">The TypeScript compiler will infer the type of the <code class="inlinecode">person1</code> variable as <code class="inlinecode">string</code> because that is the type of the value assigned to it. This variable cannot be assigned the <code class="inlinecode">null</code> or <code class="inlinecode">undefined</code> value.</p>
<p class="normal">The <code class="inlinecode">person2</code> variable<a id="_idIndexMarker086" class="calibre3"/> is defined <a id="_idIndexMarker087" class="calibre3"/>with a type annotation that specifies <code class="inlinecode">string</code> or <code class="inlinecode">undefined</code> values. This variable can be assigned <code class="inlinecode">undefined</code> but not <code class="inlinecode">null</code>, as <code class="inlinecode">null</code> is not part of the type union. <em class="italic">Listing 3.24</em> doesn’t produce any output.</p>
<h2 class="heading1" id="_idParaDest-48">Using the JavaScript operators</h2>
<p class="normal1">JavaScript <a id="_idIndexMarker088" class="calibre3"/>defines a largely standard set of operators, the most useful of which are described in the following sections.</p>
<h3 class="heading2" id="_idParaDest-49">Using conditional statements</h3>
<p class="normal1">Many <a id="_idIndexMarker089" class="calibre3"/>of the JavaScript operators are used in <a id="_idIndexMarker090" class="calibre3"/>conjunction with conditional statements. In this book, I tend to use <code class="inlinecode">if/else</code>, but JavaScript also supports <code class="inlinecode">switch</code> statements, and <em class="italic">Listing 3.25</em> shows the use of both, which will be familiar if you have worked with pretty much any programming language. </p>
<p class="packt_figref">Listing 3.25: Using the if/else and switch conditional statements in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let firstName = "Adam";
if (firstName == "Adam") {
    console.log("firstName is Adam");
} else if (firstName == "Jacqui") {
    console.log("firstName is Jacqui");
} else {
    console.log("firstName is neither Adam or Jacqui");
}
switch (firstName) {
    case "Adam":
        console.log("firstName is Adam");
        break;
    case "Jacqui":
        console.log("firstName is Jacqui");
        break;
    default:
        console.log("firstName is neither Adam or Jacqui");
        break;
}
</code></pre>
<p class="normal">The <a id="_idIndexMarker091" class="calibre3"/>results from the listing<a id="_idIndexMarker092" class="calibre3"/> are as follows:</p>
<pre class="programlisting1"><code class="hljs-con">firstName is Adam
firstName is Adam
</code></pre>
<h3 class="heading2" id="_idParaDest-50">The equality operator vs. the identity operator</h3>
<p class="normal1">In JavaScript, the <a id="_idIndexMarker093" class="calibre3"/>equality operator (<code class="inlinecode">==</code>) will attempt to coerce (convert) operands to the same type<a id="_idIndexMarker094" class="calibre3"/> to assess equality. This can be a useful feature, but<a id="_idIndexMarker095" class="calibre3"/> it is widely misunderstood and often leads to unexpected results. <em class="italic">Listing 3.26</em> shows the equality operator in action. </p>
<p class="packt_figref">Listing 3.26: Using the equality operator in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let firstVal: any = 5;
let secondVal: any = "5";
if (firstVal == secondVal) {
    console.log("They are the same");
} else {
    console.log("They are NOT the same");
}
</code></pre>
<p class="normal">The output from this code is as follows:</p>
<pre class="programlisting1"><code class="hljs-con">They are the same
</code></pre>
<p class="normal">JavaScript is converting the two operands into the same type and comparing them. In essence, the equality operator tests that values are the same, irrespective of their type.</p>
<p class="normal">If you want <a id="_idIndexMarker096" class="calibre3"/>to test to ensure <a id="_idIndexMarker097" class="calibre3"/>that the values <em class="italic">and</em> the types are the same, then you need to use the <a id="_idIndexMarker098" class="calibre3"/>identity operator (<code class="inlinecode">===</code>, three equals signs, rather than the two of the equality operator), as shown in <em class="italic">Listing 3.27</em>.</p>
<p class="packt_figref">Listing 3.27: Using the identity operator in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let firstVal: any = 5;
let secondVal: any = "5";
<strong class="screentext">if (firstVal === secondVal) {</strong>
    console.log("They are the same");
} else {
    console.log("They are NOT the same");
}
</code></pre>
<p class="normal">In this example, the identity operator will consider the two variables to be different. This operator doesn’t coerce types. The result from this code is as follows:</p>
<pre class="programlisting1"><code class="hljs-con">They are NOT the same
</code></pre>
<p class="normal">To demonstrate how JavaScript works, I had to use the <code class="inlinecode">any</code> type when declaring the <code class="inlinecode">firstVal</code> and <code class="inlinecode">secondVal</code> variables because TypeScript restricts the use of the equality operator so that it can be used only on two values of the same type. <em class="italic">Listing 3.28</em> removes the variable type annotations and allows TypeScript to infer the types from the assigned values.</p>
<p class="packt_figref">Listing 3.28: Removing the type annotations in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">let firstVal = 5;</strong>
<strong class="screentext">let</strong><strong class="screentext"> secondVal = "5";</strong>
if (firstVal === secondVal) {
    console.log("They are the same");
} else {
    console.log("They are NOT the same");
}
</code></pre>
<p class="normal">The TypeScript compiler <a id="_idIndexMarker099" class="calibre3"/>detects that the variable types are not the same <a id="_idIndexMarker100" class="calibre3"/>and generates <a id="_idIndexMarker101" class="calibre3"/>the following error:</p>
<pre class="programlisting1"><code class="hljs-con">index.ts(4,5): error TS2367: This comparison appears to be unintentional because the types 'number' and 'string' have no overlap
</code></pre>
<div><p class="normal"><strong class="screentext">Understanding Truthy and Falsy Values</strong></p>
<p class="normal">An important consequence of type coercion is JavaScript <em class="italic">truthiness</em>. A <em class="italic">truthy</em> value is one that evaluates to <code class="inlinecode">true</code> when coerced to a Boolean value, and a <em class="italic">falsy</em> value is one that evaluates to <code class="inlinecode">false</code> when coerced to a Boolean value. Every value is truthy except <code class="inlinecode">false</code>, <code class="inlinecode">0</code>, <code class="inlinecode">-0</code>, <code class="inlinecode">""</code> (the empty string), <code class="inlinecode">null</code>, <code class="inlinecode">undefined</code>, and <code class="inlinecode">NaN</code>.</p>
<p class="normal">This feature is often used to check that a variable has been assigned a value and you will see many examples in later chapters, like this expression:</p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">...</code>
<code class="inlinecode2">if (customer) {</code>
<code class="inlinecode2">...</code>
</code></pre>
<p class="normal">This is a useful way to see if a value has been assigned value, especially when querying a database or processing data received from the user. Don’t be tempted to use an expression like this one:</p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">...</code>
<code class="inlinecode2">if (customer == true) {</code>
<code class="inlinecode2">...</code>
</code></pre>
</div>
<div><p class="normal">In this expression, the type coercion is applied to the <code class="inlinecode">true</code> value and not whatever value has been assigned to <code class="inlinecode">customer</code>, which is unlikely to produce the expected result.</p>
</div>
<h3 class="heading2" id="_idParaDest-51">Using the null and nullish coalescing operators</h3>
<p class="normal1">The<a id="_idIndexMarker102" class="calibre3"/> logical OR operator (<code class="inlinecode">||</code>) has been traditionally used as a null coalescing operator in JavaScript, allowing <a id="_idIndexMarker103" class="calibre3"/>a fallback value to be used in place of <code class="inlinecode">null</code> or <code class="inlinecode">undefined</code> values, as shown in <em class="italic">Listing 3.29</em>. </p>
<p class="packt_figref">Listing 3.29: Using the null coalescing operator in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let val1: string | undefined;
let val2: string | undefined = "London";
let coalesced1 = val1 || "fallback value";
let coalesced2 = val2 || "fallback value";
console.log(`Result 1: ${coalesced1}`);
console.log(`Result 2: ${coalesced2}`);
</code></pre>
<p class="normal">The <code class="inlinecode">||</code> operator <a id="_idIndexMarker104" class="calibre3"/>returns the left-hand operand if it evaluates as truthy and returns the right-hand operand otherwise. When the operator is applied to <code class="inlinecode">val1</code>, the right-hand operand is returned because no value has been assigned to the variable, meaning that it is <code class="inlinecode">undefined</code>. When the operator is applied to <code class="inlinecode">val2</code>, the left-hand operand is returned because the variable has been assigned the string <code class="inlinecode">London</code>, which evaluates as truthy. This code produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Result 1: fallback value
Result 2: London
</code></pre>
<p class="normal">The problem with using the <code class="inlinecode">||</code> operator this way is that truthy and falsy values can produce unexpected results, as shown in <em class="italic">Listing 3.30</em>.</p>
<p class="packt_figref">Listing 3.30: An unexpected null coalescing result in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let val1: string | undefined;
let val2: string | undefined = "London";
<strong class="screentext">let val3: number | </strong><strong class="screentext">undefined = 0;</strong>
let coalesced1 = val1 || "fallback value";
let coalesced2 = val2 || "fallback value";
<strong class="screentext">let coalesced3 = val3 || 100;</strong>
console.log(`Result 1: ${coalesced1}`);
console.log(`Result 2: ${coalesced2}`);
<strong class="screentext">console.log(`Result 3: ${coalesced3}</strong><strong class="screentext">`);</strong>
</code></pre>
<p class="normal">The new <a id="_idIndexMarker105" class="calibre3"/>coalescing <a id="_idIndexMarker106" class="calibre3"/>operation returns the fallback value, even though the <code class="inlinecode">val3</code> variable<a id="_idIndexMarker107" class="calibre3"/> is neither <code class="inlinecode">null</code> nor <code class="inlinecode">undefined</code>, because <code class="inlinecode">0</code> evaluates as falsy. The code produces the following results:</p>
<pre class="programlisting1"><code class="hljs-con">Result 1: fallback value
Result 2: London
Result 3: 100
</code></pre>
<p class="normal">The nullish coalescing operator (<code class="inlinecode">??</code>) addresses this issue by returning the right-hand operand only if the left-hand operand is <code class="inlinecode">null</code> or <code class="inlinecode">undefined</code>, as shown in <em class="italic">Listing 3.31</em>.</p>
<p class="packt_figref">Listing 3.31: Using the nullish coalescing operator in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let val1: string | undefined;
let val2: string | undefined = "London";
let val3: number | undefined = 0;
<strong class="screentext">let coalesced1 = val1 ?? "fallback value";</strong>
<strong class="screentext">let coalesced2 = val2 ?? "fallback value";</strong>
<strong class="screentext">let coalesced3 = val3 ?? 100;</strong>
console.log(`Result 1: ${coalesced1}`);
console.log(`Result 2: ${coalesced2}`);
console.log(`Result 3: ${coalesced3}`);
</code></pre>
<p class="normal">The nullish operator doesn’t consider truthy and falsy outcomes and looks only for the <code class="inlinecode">null</code> and <code class="inlinecode">undefined</code> values. This code produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Result 1: fallback value
Result 2: London
Result 3: 0
</code></pre>
<h3 class="heading2" id="_idParaDest-52">Using the optional chaining operator</h3>
<p class="normal1">As<a id="_idIndexMarker108" class="calibre3"/> explained earlier, TypeScript won’t allow <code class="inlinecode">null</code> or <code class="inlinecode">undefined</code> to be assigned to variables unless they<a id="_idIndexMarker109" class="calibre3"/> have been defined with a suitable type union. Furthermore, TypeScript will only allow methods and properties defined by all of the types in the union to be used. </p>
<p class="normal">This combination of features means that you have to guard against <code class="inlinecode">null</code> or <code class="inlinecode">undefined</code> values before you can use the features provided by any other type in a union, as demonstrated in <em class="italic">Listing 3.32</em>. </p>
<p class="packt_figref">Listing 3.32: Guarding against null or undefined values in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let count: number | undefined | null = 100;
if (count != null &amp;&amp; count != undefined) {
    let result1: string = count.toFixed(2);
    console.log(`Result 1: ${result1}`);
}
</code></pre>
<p class="normal">To invoke the <code class="inlinecode">toFixed</code> method, I have to make sure that the <code class="inlinecode">count</code> variable hasn’t been assigned <code class="inlinecode">null</code> or <code class="inlinecode">undefined</code>. The TypeScript compiler understands the meaning of the expressions in the <code class="inlinecode">if</code> statement and knows that excluding <code class="inlinecode">null</code> and <code class="inlinecode">undefined</code> values means that the value assigned to <code class="inlinecode">count</code> must be <code class="inlinecode">number</code>, meaning that the <code class="inlinecode">toFixed</code> method can be used safely. This code produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Result 1: 100.00
</code></pre>
<p class="normal">The optional chaining operator (the <code class="inlinecode">?</code> character) simplifies the guarding process, as shown in <em class="italic">Listing 3.33</em>.</p>
<p class="packt_figref">Listing 3.33: Using the optional chaining operator in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let count: number | undefined | null = 100;
if (count != null &amp;&amp; count != undefined) {
    let result1: string = count.toFixed(2);
    console.log(`Result 1: ${result1}`);
}
<strong class="screentext">let result2: string | undefined = count?.toFixed(</strong><strong class="screentext">2);</strong>
<strong class="screentext">console.log(`Result 2: ${result2}`);</strong>
</code></pre>
<p class="normal">The operator<a id="_idIndexMarker110" class="calibre3"/> is applied between the variable and the method call and will return <code class="inlinecode">undefined</code> if the value is <code class="inlinecode">null</code> or <code class="inlinecode">undefined</code>, preventing the method from being invoked:</p>
<pre class="programlisting"><code class="hljs-code">...
let result2: string | undefined = count?.toFixed(2);
...
</code></pre>
<p class="normal">If the <a id="_idIndexMarker111" class="calibre3"/>value isn’t <code class="inlinecode">null</code> or <code class="inlinecode">undefined</code>, then the method call will proceed as normal. The result from an expression that includes the optional chaining operator is a type union of undefined and the result from the method. In this case, the union will be <code class="inlinecode">string |</code> <code class="inlinecode">undefined</code> because the <code class="inlinecode">toFixed</code> method returns <code class="inlinecode">string</code>. The code in <em class="italic">Listing 3.33</em> produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Result 1: 100.00
Result 2: 100.00
</code></pre>
<h1 class="heading" id="_idParaDest-53">Defining and using functions</h1>
<p class="normal1">When <a id="_idIndexMarker112" class="calibre3"/>Node.js processes a JavaScript file, it executes the statements in the order in which they have been defined. In common with most languages, JavaScript <a id="_idIndexMarker113" class="calibre3"/>allows statements to be grouped into a function, which won’t be executed until a statement that invokes the function is executed, as shown in <em class="italic">Listing 3.34</em>. </p>
<p class="packt_figref">Listing 3.34: Defining a function in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function writeValue(val: string | null) {
    console.log(`Value: ${val ?? "Fallback value"}`)
}
writeValue("London");
writeValue(null);
</code></pre>
<p class="normal">Functions <a id="_idIndexMarker114" class="calibre3"/>are defined with the <code class="inlinecode">function</code> keyword and are given a name. If a function defines parameters, then TypeScript requires type annotations, which<a id="_idIndexMarker115" class="calibre3"/> are used to enforce consistency in the use of the function. The function in <em class="italic">Listing 3.34</em> is named <code class="inlinecode">writeValue</code>, and it defines a parameter that will accept <code class="inlinecode">string</code> or <code class="inlinecode">null</code> values. The statement inside of the function isn’t executed until the function is executed. The code in <em class="italic">Listing 3.34</em> produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Value: London
Value: Fallback value
</code></pre>
<h2 class="heading1" id="_idParaDest-54">Defining optional function parameters</h2>
<p class="normal1">By default, TypeScript <a id="_idIndexMarker116" class="calibre3"/>will allow <a id="_idIndexMarker117" class="calibre3"/>functions to be invoked only when the number of arguments matches the number of parameters the function defines. This may seem obvious if you are used to other mainstream languages, but a function can be called with any number of arguments in JavaScript, regardless of how many parameters have been defined. The <code class="inlinecode">?</code> character is used to denote an optional parameter, as shown in <em class="italic">Listing 3.35</em>. </p>
<p class="packt_figref">Listing 3.35: Defining an optional parameter in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">function writeValue</strong><strong class="screentext">(val?: string) {</strong>
    console.log(`Value: ${val ?? "Fallback value"}`)
}
writeValue("London");
<strong class="screentext">writeValue();</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">?</code> operator has been applied to the <code class="inlinecode">val</code> parameter, which means that the function can be invoked with zero or one argument. Within the function, the parameter type is <code class="inlinecode">string | undefined</code>, because the value will be undefined if the function is invoked without an argument.</p>
<div><p class="normal"><strong class="screentext">Note</strong></p>
<p class="normal">Don’t confuse <code class="inlinecode">val?: string</code>, which is an optional parameter, with <code class="inlinecode">val: string | undefined</code>, which is a type union of <code class="inlinecode">string</code> and <code class="inlinecode">undefined</code>. The type union requires the function to be invoked with an argument, which may be the value <code class="inlinecode">undefined</code>, whereas the optional parameter allows the function to be invoked without an argument.</p>
</div>
<p class="normal">The <a id="_idIndexMarker118" class="calibre3"/>code in <em class="italic">Listing 3.35</em> produces the <a id="_idIndexMarker119" class="calibre3"/>following output:</p>
<pre class="programlisting1"><code class="hljs-con">Value: London
Value: Fallback value
</code></pre>
<h2 class="heading1" id="_idParaDest-55">Defining default parameter values</h2>
<p class="normal1">Parameters<a id="_idIndexMarker120" class="calibre3"/> can be defined with a <a id="_idIndexMarker121" class="calibre3"/>default value, which will be used when the function is invoked without a corresponding argument. This can be a useful way to avoid dealing with <code class="inlinecode">undefined</code> values, as shown in <em class="italic">Listing 3.36</em>. </p>
<p class="packt_figref">Listing 3.36: Defining a default parameter value in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">function writeValue(val: string = "default value") {</strong>
<strong class="screentext">    console.log</strong><strong class="screentext">(`Value: ${val}`)</strong>
<strong class="screentext">}</strong>
writeValue("London");
writeValue();
</code></pre>
<p class="normal">The default value will be used when the function is invoked without an argument. This means that the type of the parameter in the example will always be <code class="inlinecode">string</code>, so I don’t have to check for <code class="inlinecode">undefined</code> values. The code in <em class="italic">Listing 3.36</em> produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Value: London
Value: default value
</code></pre>
<h2 class="heading1" id="_idParaDest-56">Defining rest parameters</h2>
<p class="normal1"><em class="italic">Rest parameters</em> are <a id="_idIndexMarker122" class="calibre3"/>used to capture any <a id="_idIndexMarker123" class="calibre3"/>additional arguments when a function is invoked with additional arguments, as shown in <em class="italic">Listing 3.37</em>. </p>
<p class="packt_figref">Listing 3.37: Using a rest parameter in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function writeValue(val: string, ...extraInfo: string[]) {
    console.log(`Value: ${val}, Extras: ${extraInfo}`)
}
writeValue("London", "Raining", "Cold");
writeValue("Paris", "Sunny");
writeValue("New York");
</code></pre>
<p class="normal">The rest parameter must be the last parameter defined by the function, and its name is prefixed with an ellipsis (three periods, <code class="inlinecode">...</code>). The rest parameter is an array to which any extra arguments will be assigned. In the listing, the function prints out each extra argument to the console, producing the following results:</p>
<pre class="programlisting1"><code class="hljs-con">Value: London, Extras: Raining,Cold
Value: Paris, Extras: Sunny
Value: New York, Extras:
</code></pre>
<h2 class="heading1" id="_idParaDest-57">Defining functions that return results</h2>
<p class="normal1">You can<a id="_idIndexMarker124" class="calibre3"/> return results from functions by declaring the return data type and using the <code class="inlinecode">return</code> keyword within the function body, as shown in <em class="italic">Listing 3.38</em>. </p>
<p class="packt_figref">Listing 3.38: Returning a result in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function composeString(val: string) : string {
    return `Composed string: ${val}`;
}
function writeValue(val?: string) {
    console.log(composeString(val ?? "Fallback value"));
}
writeValue("London");
writeValue();
</code></pre>
<p class="normal">The new <a id="_idIndexMarker125" class="calibre3"/>function defines one parameter, which is <code class="inlinecode">string</code>, and returns a result, which is also a <code class="inlinecode">string</code>. The type of the result is defined using a type annotation after the parameters:</p>
<pre class="programlisting"><code class="hljs-code">...
function composeString(val: string) <strong class="screentext">: string</strong> {
...
</code></pre>
<p class="normal">TypeScript will check the use of the <code class="inlinecode">return</code> keyword to ensure that the function returns a result and that the result is of the expected type. This code produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Composed string: London
Composed string: Fallback value
</code></pre>
<h2 class="heading1" id="_idParaDest-58">Using functions as arguments to other functions</h2>
<p class="normal1">JavaScript <a id="_idIndexMarker126" class="calibre3"/>functions are values, which means you can use one function as the argument to another, as demonstrated in <em class="italic">Listing 3.39</em>. </p>
<p class="packt_figref">Listing 3.39: Using a function as an argument to another function in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function getUKCapital() : string {
    return "London";
}
function writeCity(f: () =&gt; string)  {
    console.log(`City: ${f()}`)
}
writeCity(getUKCapital);
</code></pre>
<p class="normal">The <code class="inlinecode">writeCity</code> function defines a parameter called <code class="inlinecode">f</code>, which is a function that it invokes to get the value to insert into the string that it writes out. TypeScript requires the function parameter to be described so that the types of its parameters and results are declared:</p>
<pre class="programlisting"><code class="hljs-code">...
function writeCity(<strong class="screentext">f: () =&gt; string</strong>)  {
...
</code></pre>
<p class="normal">This is the <em class="italic">arrow syntax</em>, also known as <em class="italic">fat arrow syntax</em> or <em class="italic">lambda expression syntax</em>. There <a id="_idIndexMarker127" class="calibre3"/>are three parts to an arrow function: the input parameters surrounded by parentheses, then an equal sign and a greater-than sign (the “arrow”), and finally, the function result. The parameter function doesn’t define any parameters, so the parentheses are empty. This means that the type of parameter <code class="inlinecode">f</code> is a function that accepts no parameters and returns a <code class="inlinecode">string</code> result. The parameter function is invoked within a template string:</p>
<pre class="programlisting"><code class="hljs-code">...
console.log(`City: ${<strong class="screentext">f()</strong>}`)
...
</code></pre>
<p class="normal">Only functions with the specified combination of parameters and result can be used as an argument to <code class="inlinecode">writeCity</code>. The <code class="inlinecode">getUKCapital</code> function has the correct characteristics:</p>
<pre class="programlisting"><code class="hljs-code">...
writeCity(<strong class="screentext">getUKCapital</strong>);
...
</code></pre>
<p class="normal">Notice that only the name of the function is used as the argument. If you follow the function name with parentheses, <code class="inlinecode">writeCity(getUKCapital())</code>, then you are telling JavaScript to invoke the <code class="inlinecode">getUKCapital</code> function and pass the result to the <code class="inlinecode">writeCity</code> function. TypeScript will detect that the result from the <code class="inlinecode">getUKCapital</code> function doesn’t match the parameter type defined by the <code class="inlinecode">writeCity</code> function and will produce an error when the code is compiled. The code in <em class="italic">Listing 3.39</em> produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">City: London
</code></pre>
<h3 class="heading2" id="_idParaDest-59">Defining functions using the arrow syntax</h3>
<p class="normal1">The <a id="_idIndexMarker128" class="calibre3"/>arrow syntax<a id="_idIndexMarker129" class="calibre3"/> can <a id="_idIndexMarker130" class="calibre3"/>also be used to define functions, which is a useful way to define functions inline, as shown in <em class="italic">Listing 3.40</em>.</p>
<p class="packt_figref">Listing 3.40: Defining an arrow function in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function getUKCapital() : string {
    return "London";
}
function writeCity(f: () =&gt; string)  {
    console.log(`City: ${f()}`)
}
writeCity(getUKCapital);
<strong class="screentext">writeCity(</strong><strong class="screentext">() =&gt; "Paris");</strong>
</code></pre>
<p class="normal">This inline function receives no parameters and returns the literal string value <code class="inlinecode">Paris</code>, defining a function that can be used as an argument to the <code class="inlinecode">writeCity</code> function. The code in <em class="italic">Listing 3.40</em> produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">City: London
City: Paris
</code></pre>
<h3 class="heading2" id="_idParaDest-60">Understanding value closure</h3>
<p class="normal1">Functions <a id="_idIndexMarker131" class="calibre3"/>can <a id="_idIndexMarker132" class="calibre3"/>access values that are defined in the surrounding code, using a feature called <em class="italic">closure</em>, as demonstrated in <em class="italic">Listing 3.41</em>. </p>
<p class="packt_figref">Listing 3.41: Using a closure in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">function getUKCapital() : string {
    return "London";
}
function writeCity(f: () =&gt; string)  {
    console.log(`City: ${f()}`)
}
writeCity(getUKCapital);
writeCity(() =&gt; "Paris");
<strong class="screentext">let myCity = "Rome";</strong>
<strong class="screentext">writeCity(() =&gt; myCity);</strong>
</code></pre>
<p class="normal">The new <a id="_idIndexMarker133" class="calibre3"/>arrow function returns the value of the variable named <code class="inlinecode">myCity</code>, which is defined in the surrounding code. This is a powerful feature that <a id="_idIndexMarker134" class="calibre3"/>means you don’t have to define parameters on functions to pass around data values, but caution is required because it is easy to get unexpected results when using common variable names like <code class="inlinecode">counter</code> or <code class="inlinecode">index</code>, where you may not realize that you are reusing a variable name from the surrounding code. This example produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">City: London
City: Paris
City: Rome
</code></pre>
<h1 class="heading" id="_idParaDest-61">Working with arrays</h1>
<p class="normal1">JavaScript arrays <a id="_idIndexMarker135" class="calibre3"/>work like arrays in most other programming languages. <em class="italic">Listing 3.42</em> demonstrates how to create and populate an array. </p>
<p class="packt_figref">Listing 3.42: Creating and populating an array in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let myArray = [];
myArray[0] = 100;
myArray[1] = "Adam";
myArray[2] = true;
</code></pre>
<p class="normal">I have created a new and empty array using the literal syntax, which uses square brackets, and assigned the array to a variable named <code class="inlinecode">myArray</code>. In the subsequent statements, I assign values to various index positions in the array. (There is no output from this listing.)</p>
<p class="normal">There are a <a id="_idIndexMarker136" class="calibre3"/>couple of things to note in this example. First, I didn’t need to declare the number of items in the array when I created it. JavaScript arrays will resize themselves to hold any number of items. The second point is that I didn’t have to declare the data types that the array would hold. Any JavaScript array can hold any mix of data types. In the example, I have assigned three items to the array: <code class="inlinecode">number</code>, <code class="inlinecode">string</code>, and <code class="inlinecode">boolean</code>. The TypeScript compiler infers the type of the array as <code class="inlinecode">any[]</code>, denoting an array that can hold values of all types. The example can be written with the type annotation shown in <em class="italic">Listing 3.43</em>.</p>
<p class="packt_figref">Listing 3.43: Using a type annotation in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">let </strong><strong class="screentext">myArray: any[] = [];</strong>
myArray[0] = 100;
myArray[1] = "Adam";
myArray[2] = true;
</code></pre>
<p class="normal">Arrays can be restricted to values with specific types, as shown in <em class="italic">Listing 3.44</em>.</p>
<p class="packt_figref">Listing 3.44: Restricting array value types in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">let</strong><strong class="screentext"> myArray: (number | string | boolean)[] = [];</strong>
myArray[0] = 100;
myArray[1] = "Adam";
myArray[2] = true;
</code></pre>
<p class="normal">The type union restricts the array so that it can hold only <code class="inlinecode">number</code>, <code class="inlinecode">string</code>, and <code class="inlinecode">boolean</code> values. Notice that I have put the type union in parentheses because the union <code class="inlinecode">number | string | boolean[]</code> denotes a value that can be assigned <code class="inlinecode">number</code>, a <code class="inlinecode">string</code>, or an array of <code class="inlinecode">boolean</code> values, which is not what is intended.</p>
<p class="normal">Arrays can be defined and populated in a single statement, as shown in <em class="italic">Listing 3.45</em>.</p>
<p class="packt_figref">Listing 3.45: Populating a new array in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let myArray: (number | string | boolean)[] = [100, "Adam", true];
</code></pre>
<p class="normal">If you omit the type annotation, TypeScript will infer the array type from the values used <a id="_idIndexMarker137" class="calibre3"/>to populate the array. You should rely on this feature with caution for arrays that are intended to hold multiple types because it requires that the full range of types is used when creating the array.</p>
<h2 class="heading1" id="_idParaDest-62">Reading and modifying the contents of an array</h2>
<p class="normal1">You read<a id="_idIndexMarker138" class="calibre3"/> the value at a given index using square braces (<code class="inlinecode">[</code> and <code class="inlinecode">]</code>), placing<a id="_idIndexMarker139" class="calibre3"/> the index you require between the braces, as shown in <em class="italic">Listing 3.46</em>. </p>
<p class="packt_figref">Listing 3.46: Reading the data from an array index in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let myArray: (number | string | boolean)[] = [100, "Adam", true];
<strong class="screentext">let val = myArray[0];</strong>
<strong class="screentext">console.log(`Value: ${val}`);</strong>
</code></pre>
<p class="normal">The TypeScript compiler infers the type of values in the array so that the type of the <code class="inlinecode">val</code> variable in <em class="italic">Listing 3.46</em> is <code class="inlinecode">number | string | boolean</code>. This code produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Value: 100
</code></pre>
<p class="normal">You can modify the data held in any position in a JavaScript array simply by assigning a new value to the index, as shown in <em class="italic">Listing 3.47</em>. The TypeScript compiler will check that the type of the value you assign matches the array element type.</p>
<p class="packt_figref">Listing 3.47: Modifying the contents of an array in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let myArray: (number | string | boolean)[] = [100, "Adam", true];
<strong class="screentext">myArray[0</strong><strong class="screentext">] = "Tuesday";</strong>
let val = myArray[0];
console.log(`Value: ${val}`);
</code></pre>
<p class="normal">In this example, I have assigned a <code class="inlinecode">string</code> to position <code class="inlinecode">0</code> in the array, a position that was <a id="_idIndexMarker140" class="calibre3"/>previously <a id="_idIndexMarker141" class="calibre3"/>held by a <code class="inlinecode">number</code>. This code produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Value: Tuesday
</code></pre>
<h2 class="heading1" id="_idParaDest-63">Enumerating the contents of an array</h2>
<p class="normal1">You <a id="_idIndexMarker142" class="calibre3"/>enumerate the content of an array using a <code class="inlinecode">for</code> loop or the <code class="inlinecode">forEach</code> method, which receives a function that is called to process each element in the array. <em class="italic">Listing 3.48</em> shows both approaches. </p>
<p class="packt_figref">Listing 3.48: Enumerating the contents of an array in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let myArray: (number | string | boolean)[] = [100, "Adam", true];
<strong class="screentext">for (let i = 0; i &lt; myArray.length; i++) {</strong>
<strong class="screentext">    console.log("Index " + i + ": " + myArray[i]);</strong>
<strong class="screentext">}</strong>
<strong class="screentext">console</strong><strong class="screentext">.log("---");</strong>
<strong class="screentext">myArray.forEach((value, index) =&gt;</strong>
<strong class="screentext">    console.log("Index " + index + ": " + value));</strong>
</code></pre>
<p class="normal">The JavaScript <code class="inlinecode">for</code> loop works just the same way as loops in many other languages. You determine how many elements there are in the array using its <code class="inlinecode">length</code> property.</p>
<p class="normal">The function passed to the <code class="inlinecode">forEach</code> method is given two arguments: the value of the current item to be processed and the position of that item in the array. In this listing, I have used an arrow function as the argument to the <code class="inlinecode">forEach</code> method, which is the kind of use for which they excel (and you will see used throughout this book). The output from the listing is as follows:</p>
<pre class="programlisting1"><code class="hljs-con">Index 0: 100
Index 1: Adam
Index 2: true
---
Index 0: 100
Index 1: Adam
Index 2: true
</code></pre>
<h2 class="heading1" id="_idParaDest-64">Using the spread operator</h2>
<p class="normal1">The<a id="_idIndexMarker143" class="calibre3"/> spread operator is used to expand an array so <a id="_idIndexMarker144" class="calibre3"/>that its contents can be used as function arguments or combined with other arrays. In <em class="italic">Listing 3.49</em>, I used the spread operator to expand an array so that its items can be combined into another array. </p>
<p class="packt_figref">Listing 3.49: Using the spread operator in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let myArray: (number | string | boolean)[] = [100, "Adam", true];
<strong class="screentext">let otherArray = [...myArray, 200, "Bob", false];</strong>
<strong class="screentext">// for (let i = 0; i &lt; myArray.length; i++) {</strong>
<strong class="screentext">//     console.log("Index " + i + ": " + myArray[i]);</strong>
<strong class="screentext">// }</strong>
<strong class="screentext">// console.log("---");</strong>
<strong class="screentext">otherArray.forEach(</strong><strong class="screentext">(value, index) =&gt;</strong>
<strong class="screentext">    console.log("Index " + index + ": " + value));</strong>
</code></pre>
<p class="normal">The spread operator is an ellipsis (a sequence of three periods), and it causes the array to be unpacked:</p>
<pre class="programlisting"><code class="hljs-code">...
let otherArray = [<strong class="screentext">...myArray</strong>, 200, "Bob", false];
...
</code></pre>
<p class="normal">Using the spread operator, I can specify <code class="inlinecode">myArray</code> as an item when I define <code class="inlinecode">otherArray</code>, with the result that the contents of the first array will be unpacked and added as items to the second array. This example produces the following results:</p>
<pre class="programlisting1"><code class="hljs-con">Index 0: 100
Index 1: Adam
Index 2: true
Index 3: 200
Index 4: Bob
Index 5: false
</code></pre>
<h1 class="heading" id="_idParaDest-65">Working with objects</h1>
<p class="normal1">JavaScript <a id="_idIndexMarker145" class="calibre3"/>objects are a collection of properties, each of which has a name and value. The simplest way to create an object is to use the literal syntax, as shown in <em class="italic">Listing 3.50</em>. </p>
<p class="packt_figref">Listing 3.50: Creating an object in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let hat = {
    name: "Hat",
    price: 100
};
let boots = {
    name: "Boots",
    price: 100
}
console.log(`Name: ${hat.name}, Price: ${hat.price}`);
console.log(`Name: ${boots.name}, Price: ${boots.price}`);
</code></pre>
<p class="normal">The literal syntax uses braces to contain a list of property names and values. Names are separated from their values with colons and from other properties with commas. Two objects are defined in <em class="italic">Listing 3.50</em> and assigned to variables named <code class="inlinecode">hat</code> and <code class="inlinecode">boots</code>. The properties defined by the object can be accessed through the variable name, as shown in this statement:</p>
<pre class="programlisting"><code class="hljs-code">...
console.log(`Name: ${hat.name}, Price: ${hat.price}`);
...
</code></pre>
<p class="normal">The code in <em class="italic">Listing 3.50</em> produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Name: Hat, Price: 100
Name: Boots, Price: 100
</code></pre>
<h2 class="heading1" id="_idParaDest-66">Understanding literal object types</h2>
<p class="normal1">When<a id="_idIndexMarker146" class="calibre3"/> the TypeScript compiler encounters a literal object, it <a id="_idIndexMarker147" class="calibre3"/>infers its type, using the combination of property names and the values to which they are assigned. This combination can be used in type annotations, allowing the shape of objects to be described as, for example, function parameters, as shown in <em class="italic">Listing 3.51</em>.</p>
<p class="packt_figref">Listing 3.51: Describing an object type in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let hat = {
    name: "Hat",
    price: 100
};
let boots = {
    name: "Boots",
    price: 100
}
<strong class="screentext">function printDetails(product : { name: string, price: number}) {</strong>
<strong class="screentext">    console.log(`Name: ${product.name}, Price: ${product.price}</strong><strong class="screentext">`);   </strong>
<strong class="screentext">}</strong>
<strong class="screentext">printDetails(hat);</strong>
<strong class="screentext">printDetails(boots);</strong>
</code></pre>
<p class="normal">The type annotation specifies that the <code class="inlinecode">product</code> parameter can accept objects that define a <code class="inlinecode">string</code> property called <code class="inlinecode">name</code>, and a <code class="inlinecode">number</code> property named <code class="inlinecode">price</code>. This example produces the same output as <em class="italic">Listing 3.50</em>.</p>
<p class="normal">A type annotation that describes a combination of property names and types just sets out a minimum threshold for objects, which can define additional properties and can still conform to the type, as shown in <em class="italic">Listing 3.52</em>.</p>
<p class="packt_figref">Listing 3.52. Adding a property in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let hat = {
    name: "Hat",
    price: 100
};
let boots = {
    name: "Boots",
    price: 100,
   <strong class="screentext"> category: "Snow Gear"</strong>
}
function printDetails(product : { name: string, price: number}) {
    console.log(`Name: ${product.name}, Price: ${product.price}`);   
}
printDetails(hat);
printDetails(boots);
</code></pre>
<p class="normal">The<a id="_idIndexMarker148" class="calibre3"/> listing adds a new<a id="_idIndexMarker149" class="calibre3"/> property to the objects assigned to the <code class="inlinecode">boots</code> variable, but since the object defines the properties described in the type annotation, this object can still be used as an argument to the <code class="inlinecode">printDetails</code> function. This example produces the same output as <em class="italic">Listing 3.50</em>.</p>
<h3 class="heading2" id="_idParaDest-67">Defining optional properties in a type annotation</h3>
<p class="normal1">A <a id="_idIndexMarker150" class="calibre3"/>question mark can be used to denote an optional property, as shown in <em class="italic">Listing 3.53</em>, allowing objects that don’t define the property to still conform to the type. </p>
<p class="packt_figref">Listing 3.53 Defining an optional property in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">let hat = {
    name: "Hat",
    price: 100
};
let boots = {
    name: "Boots",
    price: 100,
    category: "Snow Gear"
}
<strong class="screentext">function printDetails(product : { name: string, price: number,</strong>
<strong class="screentext">        category?: string}) {</strong>
<strong class="screentext">    if (product.category != undefined) {</strong>
<strong class="screentext">        console.log(</strong><strong class="screentext">`Name: ${product.name}, Price: ${product.price}, `</strong>
<strong class="screentext">            + `Category: ${product.category}`);   </strong>
<strong class="screentext">    } else {</strong>
<strong class="screentext">        console.log(`Name: ${product.name}, Price: ${product.price}</strong><strong class="screentext">`);   </strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
printDetails(hat);
printDetails(boots);
</code></pre>
<p class="normal">The type annotation<a id="_idIndexMarker151" class="calibre3"/> adds an optional <code class="inlinecode">category</code> property, which is marked as optional. This means that the type of the property is <code class="inlinecode">string | undefined</code>, and the function can test to see if a <code class="inlinecode">category</code> value has been provided. This code produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Name: Hat, Price: 100
Boots, Price: 100, Category: Snow Gear
</code></pre>
<h2 class="heading1" id="_idParaDest-68">Defining classes</h2>
<p class="normal1">Classes<a id="_idIndexMarker152" class="calibre3"/> are templates used to create objects, providing an alternative to the literal syntax. Support for classes is a recent addition to the JavaScript specification and is intended to make working with JavaScript more consistent with other mainstream programming languages. <em class="italic">Listing 3.54</em> defines a class and uses it to create objects. </p>
<p class="packt_figref">Listing 3.54: Defining a class in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">class</strong><strong class="screentext"> Product {</strong>
<strong class="screentext">    constructor(name: string, price: number, category?: string) {</strong>
<strong class="screentext">        this.name = name;</strong>
<strong class="screentext">        this.price = price;</strong>
<strong class="screentext">        this.category</strong><strong class="screentext"> = category;</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    name: string</strong>
<strong class="screentext">    price: number</strong>
<strong class="screentext">    category?: string</strong>
<strong class="screentext">}</strong>
<strong class="screentext">let hat = new Product("Hat", 100);</strong>
<strong class="screentext">let boots = new Product</strong><strong class="screentext">("Boots", 100, "Snow Gear");</strong>
function printDetails(product : { name: string, price: number,
        category?: string}) {
    if (product.category != undefined) {
        console.log(`Name: ${product.name}, Price: ${product.price}, `
            + `Category: ${product.category}`);   
    } else {
        console.log(`Name: ${product.name}, Price: ${product.price}`);   
    }
}
printDetails(hat);
printDetails(boots);
</code></pre>
<p class="normal">JavaScript <a id="_idIndexMarker153" class="calibre3"/>classes will be familiar if you have used another mainstream language such as Java or C#. The <code class="inlinecode">class</code> keyword is used to declare a class, followed by the name of the class, which is <code class="inlinecode">Product</code> in this example.</p>
<p class="normal">The <code class="inlinecode">constructor</code> function is invoked when a new object is created using the class, and it provides an opportunity to receive data values and do any initial setup that the class requires. In the example, the constructor defines <code class="inlinecode">name</code>, <code class="inlinecode">price</code>, and <code class="inlinecode">category</code> parameters that are used to assign values to properties defined with the same names.</p>
<p class="normal">The <code class="inlinecode">new</code> keyword is used to create an object from a class, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
let hat = <strong class="screentext">new</strong> Product("Hat", 100);
...
</code></pre>
<p class="normal">This statement creates a new object using the <code class="inlinecode">Product</code> class as its template. <code class="inlinecode">Product</code> is used as a function in this situation, and the arguments passed to it will be received <a id="_idIndexMarker154" class="calibre3"/>by the <code class="inlinecode">constructor</code> function defined by the class. The result of this expression is a new object that is assigned to a variable called <code class="inlinecode">hat</code>.</p>
<p class="normal">Notice that the objects created from the class can still be used as arguments to the <code class="inlinecode">printDetails</code> function. Introducing a class has changed the way that objects are created, but those objects have the same combination of property names and types and still match the type annotation for the function parameters. The code in <em class="italic">Listing 3.54</em> produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Name: Hat, Price: 100
Name: Boots, Price: 100, Category: Snow Gear
</code></pre>
<h3 class="heading2" id="_idParaDest-69">Adding methods to a class</h3>
<p class="normal1">I can<a id="_idIndexMarker155" class="calibre3"/> simplify the code in the example by moving the functionality defined by the <code class="inlinecode">printDetails</code> function into a method defined by the <code class="inlinecode">Product</code> class, as shown in <em class="italic">Listing 3.55</em>.</p>
<p class="packt_figref">Listing 3.55: Defining a method in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">class Product {
    constructor(name: string, price: number, category?: string) {
        this.name = name;
        this.price = price;
        this.category = category;
    }
    name: string
    price: number
    category?: string
    <strong class="screentext">printDetails() {</strong>
<strong class="screentext">        if (this.category != undefined) {</strong>
<strong class="screentext">            console.log(`Name: ${this</strong><strong class="screentext">.name}, Price: ${this.price}, `</strong>
<strong class="screentext">                + `Category: ${this.category}`);   </strong>
<strong class="screentext">        } else {</strong>
<strong class="screentext">            console.log(`Name: </strong><strong class="screentext">${this.name}, Price: ${this.price}`);   </strong>
<strong class="screentext">        }       </strong>
<strong class="screentext">    }</strong>
}
let hat = new Product("Hat", 100);
let boots = new Product("Boots", 100, "Snow Gear");
<strong class="screentext">// function printDetails(product : { name: string, price: number,</strong>
<strong class="screentext">//         category?: string}) {</strong>
<strong class="screentext">//     if (product.category != undefined) {</strong>
<strong class="screentext">//         console.log(`Name: ${product.name}, Price: ${product.price}, `</strong>
<strong class="screentext">//             + `Category: ${product.category}`);   </strong>
<strong class="screentext">//     } else {</strong>
<strong class="screentext">//         console.log(`Name: ${product.name}, Price: ${product.price}`);   </strong>
<strong class="screentext">//     }</strong>
<strong class="screentext">// }</strong>
<strong class="screentext">hat.printDetails();</strong>
<strong class="screentext">boots.printDetails();</strong>
</code></pre>
<p class="normal">Methods <a id="_idIndexMarker156" class="calibre3"/>are invoked through the object, like this:</p>
<pre class="programlisting"><code class="hljs-code">...
hat.<strong class="screentext">printDetails</strong><strong class="screentext">();</strong>
...
</code></pre>
<p class="normal">The method accesses the properties defined by the object through the <code class="inlinecode">this</code> keyword:</p>
<pre class="programlisting"><code class="hljs-code">...
console.log(`Name: ${<strong class="screentext">this.name</strong>}, Price: ${<strong class="screentext">this.price</strong>}`);   
...
</code></pre>
<p class="normal">This example <a id="_idIndexMarker157" class="calibre3"/>produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Name: Hat, Price: 100
Name: Boots, Price: 100, Category: Snow Gear
</code></pre>
<h3 class="heading2" id="_idParaDest-70">Access controls and simplified constructors</h3>
<p class="normal1">TypeScript provides support for <a id="_idIndexMarker158" class="calibre3"/>access controls using the <code class="inlinecode">public</code>, <code class="inlinecode">private</code>, and <code class="inlinecode">protected</code> keywords. The <code class="inlinecode">public</code> class gives unrestricted<a id="_idIndexMarker159" class="calibre3"/> access to the properties and methods defined by a class, meaning they can be accessed by any other part of the application. The <code class="inlinecode">private</code> keyword restricts access to features so they can be accessed only within the class that defines them. The <code class="inlinecode">protected</code> keyword restricts access so that features can be accessed within the class or a subclass. </p>
<p class="normal">By default, the features defined by a class are accessible by any part of the application, as though the <code class="inlinecode">public</code> keyword has been applied. You won’t see the access control keywords applied to methods and properties in this book because access controls are not essential in a web application. But there is a related feature that I use often, which allows classes to be simplified by applying the access control keyword to the constructor parameters, as shown in <em class="italic">Listing 3.56</em>.</p>
<p class="packt_figref">Listing 3.56: Simplifying the class in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">class Product {
   <strong class="screentext"> constructor(public name: string, public price: number,</strong>
<strong class="screentext">            public category?: string) {</strong>
<strong class="screentext">        // this.name = name;</strong>
<strong class="screentext">        // this.price = price;</strong>
<strong class="screentext">        // this.category = category;</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">    // name: string</strong>
<strong class="screentext">    // price: number</strong>
<strong class="screentext">    // category?: string</strong>
    printDetails() {
        if (this.category != undefined) {
            console.log(`Name: ${this.name}, Price: ${this.price}, `
                + `Category: ${this.category}`);   
        } else {
            console.log(`Name: ${this.name}, Price: ${this.price}`);   
        }       
    }
}
let hat = new Product("Hat", 100);
let boots = new Product("Boots", 100, "Snow Gear");
hat.printDetails();
boots.printDetails();
</code></pre>
<p class="normal">Adding one <a id="_idIndexMarker160" class="calibre3"/>of the access control keywords to a constructor <a id="_idIndexMarker161" class="calibre3"/>parameter has the effect of creating a property with the same name, type, and access level. So, adding the <code class="inlinecode">public</code> keyword to the <code class="inlinecode">price</code> parameter, for example, creates a <code class="inlinecode">public</code> property named <code class="inlinecode">price</code>, which can be assigned <code class="inlinecode">number</code> values. The value received through the constructor is used to initialize the property. This is a useful feature that eliminates the need to copy parameter values to initialize properties. The code in <em class="italic">Listing 3.56</em> produces the same output as <em class="italic">Listing 3.53</em>, and only the way that the <code class="inlinecode">name</code>, <code class="inlinecode">price</code>, and <code class="inlinecode">category</code> properties are defined has changed.</p>
<h3 class="heading2" id="_idParaDest-71">Using class inheritance</h3>
<p class="normal1">Classes can<a id="_idIndexMarker162" class="calibre3"/> inherit behavior from other classes using the <code class="inlinecode">extends</code> keyword, as shown in <em class="italic">Listing 3.57</em>. </p>
<p class="packt_figref">Listing 3.57: Using class inheritance in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">class Product {
    constructor(public name: string, public price: number,
        public category?: string) {
    }
    printDetails() {
        if (this.category != undefined) {
            console.log(`Name: ${this.name}, Price: ${this.price}, `
                + `Category: ${this.category}`);   
        } else {
            console.log(`Name: ${this.name}, Price: ${this.price}`);   
        }       
    }
}
<strong class="screentext">class</strong><strong class="screentext"> DiscountProduct extends Product {</strong>
<strong class="screentext">    constructor(name: string, price: number, private discount: number) {</strong>
<strong class="screentext">        super(name, price - discount);</strong>
<strong class="screentext">    }</strong>
<strong class="screentext">}</strong>
<strong class="screentext">let hat = new </strong><strong class="screentext">DiscountProduct("Hat", 100, 10);</strong>
let boots = new Product("Boots", 100, "Snow Gear");
hat.printDetails();
boots.printDetails();
</code></pre>
<p class="normal">The <code class="inlinecode">extends</code> keyword <a id="_idIndexMarker163" class="calibre3"/>is used to declare the class that will be inherited from, known as the <em class="italic">superclass</em> or <em class="italic">base class</em>. In the listing, <code class="inlinecode">DiscountProduct</code> inherits from <code class="inlinecode">Product</code>. The <code class="inlinecode">super</code> keyword is used to invoke the superclass’s constructor and methods. <code class="inlinecode">DiscountProduct</code> builds on the <code class="inlinecode">Product</code> functionality to add support for a price reduction, producing the following results:</p>
<pre class="programlisting1"><code class="hljs-con">Name: Hat, Price: 90
Name: Boots, Price: 100, Category: Snow Gear
</code></pre>
<h2 class="heading1" id="_idParaDest-72">Checking object types</h2>
<p class="normal1">When applied <a id="_idIndexMarker164" class="calibre3"/>to an object, the <code class="inlinecode">typeof</code> function will return <code class="inlinecode">object</code>. To determine whether an object has been derived from a class, the <code class="inlinecode">instanceof</code> keyword <a id="_idIndexMarker165" class="calibre3"/>can be used, as shown in <em class="italic">Listing 3.58</em>.</p>
<p class="packt_figref">Listing 3.58: Checking an object type in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">class Product {
    constructor(public name: string, public price: number,
         public category?: string) {
    }
    printDetails() {
        if (this.category != undefined) {
            console.log(`Name: ${this.name}, Price: ${this.price}, ` +
                `Category: ${this.category}`);   
        } else {
            console.log(`Name: ${this.name}, Price: ${this.price}`);   
        }       
    }
}
class DiscountProduct extends Product {
    constructor(name: string, price: number, private discount: number) {
        super(name, price - discount);
    }
}
let hat = new DiscountProduct("Hat", 100, 10);
let boots = new Product("Boots", 100, "Snow Gear");
<strong class="screentext">// hat.printDetails();</strong>
<strong class="screentext">// boots.printDetails();</strong>
<strong class="screentext">console.log(`Hat is a Product? ${hat instanceof Product}`);</strong>
<strong class="screentext">console.</strong><strong class="screentext">log(`Hat is a DiscountProduct? ${hat instanceof DiscountProduct}`);</strong>
<strong class="screentext">console.log(`Boots is a Product? ${boots instanceof Product}`);</strong>
<strong class="screentext">console.</strong><strong class="screentext">log("Boots is a DiscountProduct? "</strong>
<strong class="screentext">  + (boots instanceof DiscountProduct));</strong>
</code></pre>
<p class="normal">The <code class="inlinecode">instanceof</code> keyword<a id="_idIndexMarker166" class="calibre3"/> is used with an object value and a class, and the expression returns <code class="inlinecode">true</code> if the object was created from the class or a superclass. The code in <em class="italic">Listing 3.58</em> produces the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Hat is a Product? True
Hat is a DiscountProduct? True
Boots is a Product? True
Boots is a DiscountProduct? false
</code></pre>
<h1 class="heading" id="_idParaDest-73">Working with JavaScript modules</h1>
<p class="normal1">JavaScript modules <a id="_idIndexMarker167" class="calibre3"/>are used to break up an application into separate files. At runtime, the dependencies between modules are resolved, the files containing the modules are loaded, and the code they contain is executed. </p>
<h2 class="heading1" id="_idParaDest-74">Creating and using modules</h2>
<p class="normal1">Each TypeScript <a id="_idIndexMarker168" class="calibre3"/>or JavaScript file that you add to a <a id="_idIndexMarker169" class="calibre3"/>project is treated as a module. To demonstrate, I created a folder called <code class="inlinecode">modules</code> in the <code class="inlinecode">primer</code> folder, added to it a file called <code class="inlinecode">name.ts</code>, and added the code shown in <em class="italic">Listing 3.59</em>. </p>
<p class="packt_figref">Listing 3.59: The contents of the name.ts file in the modules folder</p>
<pre class="programlisting"><code class="hljs-code">export class Name {
    constructor(public first: string, public second: string) {}
    get nameMessage() {
        return `Hello ${this.first} ${this.second}`;
    }
}
</code></pre>
<p class="normal">The classes, functions, and variables defined in a JavaScript or TypeScript file can be accessed only within that file by default. The <code class="inlinecode">export</code> keyword is used to make features accessible outside of the file so that they can be used by other parts of the application. In <em class="italic">Listing 3.59</em>, I have applied the <code class="inlinecode">export</code> keyword to the <code class="inlinecode">Name</code> class, which means it is available to be used outside of the module.</p>
<p class="normal">Next, add a file named <code class="inlinecode">weather.ts</code> to the <code class="inlinecode">modules</code> folder with the code shown in <em class="italic">Listing 3.60</em>. This module exports a class named <code class="inlinecode">WeatherLocation</code>.</p>
<p class="packt_figref">Listing 3.60: The contents of the weather.ts file in the modules folder</p>
<pre class="programlisting"><code class="hljs-code">export class WeatherLocation {
    constructor(public weather: string, public city: string) {}
    get weatherMessage() {
        return `It is ${this.weather} in ${this.city}`;
    }
}
</code></pre>
<p class="normal">The <code class="inlinecode">import</code> keyword <a id="_idIndexMarker170" class="calibre3"/>is used to declare a dependency <a id="_idIndexMarker171" class="calibre3"/>on the features that a module provides. In <em class="italic">Listing 3.61</em>, I have used the <code class="inlinecode">Name</code> and <code class="inlinecode">WeatherLocation</code> classes in the <code class="inlinecode">index.ts</code> file, which means I have to use the <code class="inlinecode">import</code> keyword to declare a dependency on them and the modules they come from. </p>
<p class="packt_figref">Listing 3.61: Importing specific types in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code">import { Name } from "./modules/name";
import { WeatherLocation } from "./modules/weather";
let name = new Name("Adam", "Freeman");
let loc = new WeatherLocation("raining", "London");
console.log(name.nameMessage);
console.log(loc.weatherMessage);
</code></pre>
<p class="normal">This is the way that I use the <code class="inlinecode">import</code> keyword in most of the examples in this book. The keyword is followed by curly braces that contain a comma-separated list of the features that the code in the current files depends on, followed by the <code class="inlinecode">from</code> keyword, followed by the module name. In this case, I have imported the <code class="inlinecode">Name</code> and <code class="inlinecode">WeatherLocation</code> classes <a id="_idIndexMarker172" class="calibre3"/>from the modules in the <code class="inlinecode">modules</code> folder. Notice that the file <a id="_idIndexMarker173" class="calibre3"/>extension is not included when specifying the module.</p>
<p class="normal">When the <code class="inlinecode">index.ts</code> file is compiled, the TypeScript compiler detects the dependency on the code in the <code class="inlinecode">name.ts</code> and <code class="inlinecode">weather.ts</code> files, so that pure JavaScript versions of the modules are created. During execution, Node.js detects the dependencies in the <code class="inlinecode">index.js</code> file and resolves them using the <code class="inlinecode">name.js</code> and <code class="inlinecode">weather.js</code> files that the compiler creates, producing the following output:</p>
<pre class="programlisting1"><code class="hljs-con">Hello Adam Freeman
It is raining in London
</code></pre>
<h2 class="heading1" id="_idParaDest-75">Consolidating module contents</h2>
<p class="normal1">In later <a id="_idIndexMarker174" class="calibre3"/>examples, especially the SportsStore application in <em class="italic">Part 3</em>, I consolidate the contents of module folders so that all of the important features can be imported in a single statement, even though they are defined in separate code files. To see how this works, add a file named <code class="inlinecode">index.ts</code> to the <code class="inlinecode">modules</code> folder, with the content shown in <em class="italic">Listing 3.62</em>.</p>
<p class="packt_figref">Listing 3.62: The contents of the index.ts file in the modules folder</p>
<pre class="programlisting"><code class="hljs-code">export { Name } from "./name";
export { WeatherLocation } from "./weather";
</code></pre>
<p class="normal">The <code class="inlinecode">index.ts</code> file contains <code class="inlinecode">export</code> statements for the features defined in each code file. This allows these features to be imported by specifying the name of the containing folder, without specifying individual files, as shown in <em class="italic">Listing 3.63</em>.</p>
<p class="packt_figref">Listing 3.63: Importing a module folder in the index.ts file in the primer folder</p>
<pre class="programlisting"><code class="hljs-code"><strong class="screentext">import { Name, WeatherLocation } from "./modules";</strong>
let name = new Name("Adam", "Freeman");
let loc = new WeatherLocation("raining", "London");
console.log(name.nameMessage);
console.log(loc.weatherMessage);
</code></pre>
<p class="normal">This listing <a id="_idIndexMarker175" class="calibre3"/>produces the same output as <em class="italic">Listing 3.61</em>.</p>
<div><p class="normal"><strong class="screentext">Understanding Module Resolution</strong></p>
<p class="normal">You will see two different ways of specifying modules in the <code class="inlinecode">import</code> statements in this book. The first is a relative module, in which the name of the module is prefixed with <code class="inlinecode">./</code>, like this example from <em class="italic">Listing 3.60</em>: </p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">...</code>
<code class="inlinecode2">import { Name, WeatherLocation } from "./modules";</code>
<code class="inlinecode2">...</code>
</code></pre>
<p class="normal">This statement specifies a module located relative to the file that contains the <code class="inlinecode">import</code> statement. In this case, since no filename has been specified, it is the <code class="inlinecode">index.ts</code> file in the <code class="inlinecode">modules</code> directory that will be loaded. The other type of import is nonrelative. Here is an example of a nonrelative <code class="inlinecode">import</code> you will see in later chapters:</p>
<pre class="programlisting2"><code class="hljs-code"><code class="inlinecode2">...</code>
<code class="inlinecode2">import { Express } from "express";</code>
<code class="inlinecode2">...</code>
</code></pre>
<p class="normal">The module in this <code class="inlinecode">import</code> statement doesn’t start with <code class="inlinecode">./</code>, and the dependency is resolved by looking for a package in the <code class="inlinecode">node_modules</code> folder. In this case, the dependency is on a feature provided by the <code class="inlinecode">express</code> package, which is introduced in <em class="italic">Chapter 5</em>.</p>
</div>
<h1 class="heading" id="_idParaDest-76">Summary</h1>
<p class="normal1">In this chapter, I described the basic TypeScript and JavaScript features to provide a foundation for the chapters that follow.</p>
<ul class="calibre4">
<li class="bulletlist">JavaScript is a dynamically typed and weakly typed language, which is an uncommon combination in modern programming languages.</li>
<li class="bulletlist1">Values of any type can be assigned to variables, constants, and function parameters.</li>
<li class="bulletlist1">JavaScript will coerce (convert) values to other types to perform comparisons and other operations.</li>
<li class="bulletlist1">TypeScript is a superset of JavaScript that allows developers to clearly express their assumptions about data types when writing code.</li>
<li class="bulletlist1">TypeScript doesn’t change the JavaScript type system and TypeScript files are compiled into pure JavaScript.</li>
</ul>
<p class="normal">In the next chapter, I will describe one of the fundamental concepts that is critical for understanding Node.js and its role in web applications: concurrency.</p>
</div>
</body></html>