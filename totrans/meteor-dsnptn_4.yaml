- en: Chapter 4. Application Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter will cover application-wide patterns that share server- and client-
    side code. With these patterns, your code will become more secure and easier to
    manage. You will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Filtering and paging collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Filtering and paging collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we have been publishing collections without thinking much about how
    many documents we are pushing to the client. The more documents we publish, the
    longer it will take the web page to load. To solve this issue, we are going to
    learn how to show only a set number of documents and allow the user to navigate
    through the documents in the collection by either filtering or paging through
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Filters and pagination are easy to build with Meteor's reactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Router gotchas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Routers will always have two types of parameters that they can accept: query
    parameters, and normal parameters. Query parameters are the objects that you will
    commonly see in site URLs followed by a question mark (`<url-path>?page=1`), while
    normal parameters are the type that you define within the route URL (`<url>/<normal-parameter>/named_route/<normal-parameter-2>`).
    It is a common practice to set query parameters on things such as pagination to
    keep your routes from creating URL conflicts.'
  prefs: []
  type: TYPE_NORMAL
- en: A URL conflict happens when two routes look the same but have different parameters.
    A products route such as `/products/:page` collides with a product detail route
    such as `/products/:product-id`. While both the routes are differently expressed
    because of the differences in their normal parameter, you arrive at both the routes
    using the same URL. This means that the only way the router can tell them apart
    is by routing to them programmatically. So the user would have to know that the
    `FlowRouter.go()` command has to be run in the console to reach either one of
    the products pages instead of simply using the URL.
  prefs: []
  type: TYPE_NORMAL
- en: This is why we are going to use query parameters to keep our filtering and pagination
    stateful.
  prefs: []
  type: TYPE_NORMAL
- en: Stateful pagination
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Stateful pagination is simply giving the user the option to copy and paste the
    URL to a different client and see the exact same section of the collection. This
    is important to make the site easy to share.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 2](part0021_split_000.html#page "Chapter 2. Publish and Subscribe
    Patterns"), *Publish and Subscribe Patterns* we had created a products publisher
    and subscriber to elaborate on our publishers. Now we are going to understand
    how to control our subscription reactively so that the user can navigate through
    the entire collection.
  prefs: []
  type: TYPE_NORMAL
- en: First, we need to set up our router to accept a page number. Then we will take
    this number and use it on our subscriber to pull in the data that we need. To
    set up the router, we will use a `FlowRouter` query parameter (the parameter that
    places a question mark next to the URL).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up our query parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: What we are doing here is straightforward. First, we extend the filter object
    with a `page` key that gets the current value of the page query parameter, and
    if this value does not exist, then it is set to `0`. `getQueryParam` is a reactive
    data source, the `autorun` function will resubscribe when the value changes. Then
    we will create a helper for our view so that we can see what page we are on and
    the two events that set the page query parameter.
  prefs: []
  type: TYPE_NORMAL
- en: But wait. How do we know when the limit to pagination has been reached? This
    is where the `tmeasday:publish-counts` package is very useful. It uses a publisher's
    special function to count exactly how many documents are being published.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s set up our publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'To publish our counts, we used the `Counts.publish` function. This function
    takes in a few parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Note that we used the `noReady` parameter to prevent the `ready` function from
    running prematurely. By doing this, we generate a counter that can be accessed
    on the client side by running `Counts.get "products"`. Now you might be thinking,
    why not use `Products.find().count()` instead? In this particular scenario, this
    would be an excellent idea, but you absolutely have to use the `Counts` function
    to make the count reactive, so if any dependencies change, they will be accounted
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s modify our view and helpers to reflect our counter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Great! Users can now copy and paste the URL to obtain the same results they
    had before. This is exactly what we need to make sure our customers can share
    links. If we had kept our page variable confined to a `Session` or a `ReactiveVar`,
    it would have been impossible to share the state of the webapp.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Filtering and searching, too, are critical aspects of any web app. Filtering
    works similar to pagination; the publisher takes additional variables that control
    the filter. We want to make sure that this is stateful, so we need to integrate
    this into our routes, and we need to program our publishers to react to this.
    Also, the filter needs to be compatible with the pager. Let''s start by modifying
    the publisher:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: To build any filter, we have to make sure that the property that creates the
    filter exists and `_.extend` our `filter` object based on this. This makes our
    code easier to maintain. Notice that we can easily add the filter to every section
    that includes the `Products` collection. With this, we have ensured that the filter
    is always used even if tags have filtered the data. By adding the filter to the
    `Counts.publish` function, we have ensured that the publisher is compatible with
    pagination as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s build our controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we have renamed our `filter` object to `ops` to keep things consistent
    between the publisher and subscriber. Then we have attached a `search` key to
    the `ops` object that takes the value of the search query parameter. Notice that
    we can pass an undefined value for `search`, and our subscriber will not fail,
    since the publisher already checks whether the value exists or not and extends
    filters based on this. It is always better to verify variables on the server side
    to ensure that the client doesn't accidentally break things. Also, we need to
    make sure that we know the value of that parameter so that we can create a new
    `search` helper under the `pages` helper. Finally, we have built an event for
    the search bar. Notice that we are setting query parameters to `null` whenever
    they do not apply. This makes sure that they do not appear in our URL if we do
    not need them.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish, we need to create the search bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Notice that our search input is somewhat cluttered with special attributes.
    All these attributes ensure that our input is not doing the things that we do
    not want it to for iOS Safari. It is important to keep up with nonstandard attributes
    such as these to ensure that the site is mobile-friendly. You can find an updated
    list of these attributes here at [https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/Attributes.html](https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/Attributes.html).
  prefs: []
  type: TYPE_NORMAL
- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many packages secure certain parts of the Meteor stack, but even then, you cannot
    rely on these packages completely. Also, you have to be very careful about the
    packages you choose! Some packages might intercept core functions to funnel information
    out of your application. This means that you should always have a look at the
    source code of the package before you install it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This topic is usually an oversight to novice Meteor developers, and yet it
    is one of the most important topics to know about. To secure our webapp we need
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: Define roles (set distinctions between users)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define schemas for every collection (limit how they can modify fields)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define deny rules (limit who can modify fields)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use methods, when necessary, to check parameters (ensure complex security when
    needed)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set browser policies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Roles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using roles, just about every web application creates a distinction between
    users and what they are allowed to do. To help us manage roles easily, we have
    installed the `alanning:roles` package. With this package, we are going to control
    who hits our routes and who may modify our collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'This package makes the `Roles.userIsInRole` function available, which uses
    a `roles` collection to make sure that the user is in the correct role:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Suppose you need to check whether a user is an `admin` or a `manager` before
    they access a certain function. For this, you will simply do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s add an `admin` role to our application. We can start by creating an
    initialization file that will automatically build our admin user:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that we are using the `Roles.addUsersToRoles` function to set the new
    user''s role to `admin`, and this takes place on the server side. Always set user
    roles on the server side. Next, let''s build a login route that can be accessed
    only if you are not already logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: To make sure roles run at the right moment when our user first hits the site,
    we need to make sure that `FlowRouter` activates after roles have been loaded.
    To do this we use `FlowRouter.initialize()` and `FlowRouter.wait()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `FlowRouter.route` function accepts a `triggersEnter` parameter and a `triggersExit`
    parameter. This can be used to redirect the user based on roles. Both these parameters
    are arrays of functions so that many triggers can be added to each route. To make
    it easier for us, we are going to create a dictionary of triggers under a global
    `RT` object. Notice that we do not execute the function within the triggers array,
    so we do not include parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by moving the `/router` folder to the `/_globals` folder. This
    will make sure that the `RT` object is the first thing that is defined. After
    doing this, we should define two triggers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when `FlowRouter` calls these functions, it will include a `context`
    object and a `redirect` function. The `context` object has information about the
    route that we are trying to connect to and our previous route, while the `redirect`
    function is used to redirect a user. In this case, we have attempted to redirect
    to the previous route if it exists, if it does not exist, then we redirect to
    root.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add the `admin_only` trigger to every route except `products` and
    `login`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We can easily create a global trigger that does not apply to the `products`
    nor the `login` routes using the `FlowRouter.triggers.<enter or exit>` function.
    We don't have to worry about including our `404` route since by default; it does
    not run triggers.
  prefs: []
  type: TYPE_NORMAL
- en: 'To finish up, let''s build a custom login page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have used Meteor's core `Meteor.loginWithPassword` function to log
    in, and we have kept a track of the errors using a `ReactiveVar` variable.
  prefs: []
  type: TYPE_NORMAL
- en: Collection2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Suppose a malicious user visits the site and quickly identifies one of our
    collections in the browser console. They are going to update one of the products
    by calling the `Products.update` function. Because our site is insecure, they
    can successfully call something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This will successfully create a field that should not exist for that particular
    product!
  prefs: []
  type: TYPE_NORMAL
- en: With the `aldeed:collection2` package, we are going to secure our collections
    by white-listing fields. This makes sure that the allowed users can only set acceptable
    values on our collections and that these values meet certain criteria.
  prefs: []
  type: TYPE_NORMAL
- en: 'A `collection` field can take the following parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `type` | This defines the type of the value. This can be any JavaScript primitive:
    `String`, `Number`, `Boolean`, `Date`, `Object`, or an array of primitives such
    as `[Object]`, `[String]`. |'
  prefs: []
  type: TYPE_TB
- en: '| `decimal` | This is only available if `type:Number`. This defines whether
    a number is a decimal. This can be `true` or `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `optional` | This defines whether the field is required on insert. This can
    be `true` or `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `regEx` | This checks whether the string matches the defined `regEx` expression.
    This can be any `regEx` expression such as `/^[A-Z]$/`. |'
  prefs: []
  type: TYPE_TB
- en: '| `allowedValues` | This checks whether the string matches any of the values
    in an array. This can be only an array of strings such as `["Green","Blue"]`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `blackbox` | This allows any combination of values and objects to be placed
    as values. This can be only `true` or `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `denyUpdate` | This defines whether the field can be updated. This can be
    only `true` or `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `denyInsert` | This defines whether the field can be inserted. If this field
    is set to `true`, `optional:true` must be set as well. This can be only `true`
    or `false`. |'
  prefs: []
  type: TYPE_TB
- en: '| `autoValue` | This defines the value that the field will take during an operation.
    This can be a `function` only. |'
  prefs: []
  type: TYPE_TB
- en: '| `custom` | This defines the custom function that will validate the field.
    This can be a `function` only. |'
  prefs: []
  type: TYPE_TB
- en: '| `unique` | This defines whether the value of the field should be unique.
    This can be only `true` or `false`. |'
  prefs: []
  type: TYPE_TB
- en: With these parameters, it is easy to lock down every collection including the
    `Meteor.users` collection and increase the security of our app drastically.
  prefs: []
  type: TYPE_NORMAL
- en: As we will save all our numerical data in hundreds, we will never use the `decimal`
    parameter. You should always avoid decimals regardless of whether you are dealing
    with money or not.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both the `autoValue` and `custom` parameters expose variables and functions
    within their context that are critical to understand:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Context variables and functions | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `this.isInsert` | Boolean. This checks whether the field is being inserted.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `this.isUpdate` | Boolean. This checks whether the field is being updated.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `this.upsert` | Boolean. Check whether the field is being upserted. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.userId` | String. This checks the current `userId`. Returns `undefined,`
    if it does not exist and is `null` for all server-initiated functions. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.isFromTrustedCode` | Boolean. This checks whether the field is being
    modified by the server-side code. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.isSet` | Boolean. This checks whether the field is being modified.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `this.value` | Anything. If `this.isSet,` then this will be the value of
    the field. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.operator` | String. If `this.isSet` and `this.isUpdate,` then this
    will be the operator that modifies the value (`$pull`, `$push`, `$addToSet`, `$set`,
    and so on). |'
  prefs: []
  type: TYPE_TB
- en: '| `this.field("<field-name>")` | This is a function that returns an object.
    This gets the object representation of a field that is being modified. From this
    object, you can use `isSet`, `value`, and `operator` to get more information.
    For example, `this.field("name").value` will return the value of the field name,
    if it is set. |'
  prefs: []
  type: TYPE_TB
- en: With these functions, we can add custom validators and custom automatic values
    depending on the state of the modification. Also, we can check what the values
    of other fields are and react to them if we need to. If your validation requires
    complex queries with other collections, DO NOT RELY ON THIS PACKAGE!. This tool
    is strictly to control collection-specific values and not relationships. Remember
    that not all our collections are available on the client side, and therefore,
    are incapable of being validated properly. We will address these kinds of validations
    in the next topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s secure all our collections. We will only show the `Orders` and `OrderDetails`
    collections schemas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the pattern for white-listing a field within our collection
    is a simple object that contains the `Collection2` parameters. Notice that we
    can define rules for subobjects using MongoDB''s dot notation. This means that
    we can set rules for arrays and object arrays in the same fashion as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Still, you do not have to set complex rules often since they are clear indicators
    that a new collection should be created.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that we are not using any complex custom validation in our schema besides
    `name` and `type`. Why? Should we check whether the user is an admin, or whether
    the modification originated from the server-side code, or whether the order belongs
    to the customer?
  prefs: []
  type: TYPE_NORMAL
- en: While we could start adding a few lists of checks for each field, the true source
    of the problem stems from allowing users to modify our collection directly from
    the console. To fully secure our orders, we need to modify the allow/deny rules
    and use trusted code.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that these schemas are used by server-side code
    too. This makes sure that neither the client nor the server can mess up our keys.
  prefs: []
  type: TYPE_NORMAL
- en: Deny rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we know the fields that will be in our collections, we need to make
    sure that the server allows the right people to modify these collections. To do
    this, we first need to understand exactly how the allow/deny rules work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meteor has two core functions that control whether a collection modification
    is allowed or not: `Meteor.allow` and `Meteor.deny`.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Meteor.allow` functions allow a collection to be modified as soon as one
    of the rules resolves to `true`. Also, this means that the other allow rules are
    not evaluated! Knowing this, some developers cram logic into a single allow rule
    that could easily fail. This is bad practice because the code will be difficult
    to maintain.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `Meteor.deny` functions will always run and trump a `Meteor.allow`
    rule that resolves to `true`. To manage our deny rules effectively, we are going
    to use the `ongoworks:security` package. With this package, we can easily build
    reusable and readable rules to be set on our collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin by removing all the allow rules from our project. Then we can
    set some rules for our `Orders` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With this simple rule, we have denied anything that does not match this rule.
    This package integrates directly with our `roles` package, so we can easily use
    the `ifHasRole` function. This rule makes sure that only an admin user can update
    an order's `status` field via the console. To make sure that the rule is applied,
    we have used the `apply` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three things that we need to understand about the deny rules: logic,
    integrated functions, and custom functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Logic in rules decides whether they act as ANDs or ORs. If we have multiple
    functions inside a rule, then we define AND rules. The function that we have defined
    for our orders is an AND rule because this checks `ifLoggedIn` AND `ifHasRole`
    AND `onlyProp` before allowing a modification to pass. If we want to create an
    OR rule, we simply create a new rule. Let''s try this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are stating that a user may `update` `ifLoggedIn` AND `ifHasRole` AND
    `onlyProp` OR never `insert`/`remove`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The package comes with a handful of integrated functions to help in applying
    the rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `never()` | This prevents DB operations |'
  prefs: []
  type: TYPE_TB
- en: '| `ifLoggedIn()` | This allows DB operations if logged in |'
  prefs: []
  type: TYPE_TB
- en: '| `ifHasUserId(<user-id>)` | This allows DB operations if user ID is a particular
    string |'
  prefs: []
  type: TYPE_TB
- en: '| `ifHasRole(<role string>)``ifHasRole({role:<role string>,group:<group>})`
    | This allows DB operations if user belongs to a particular role |'
  prefs: []
  type: TYPE_TB
- en: '| `onlyProps(<string or array of strings>)` | This allows DB operations on
    certain top-level fields only (this will not identify arrays and subobjects) |'
  prefs: []
  type: TYPE_TB
- en: '| `exceptProps(<string or array of strings>)` | This allows DB operations on
    all top-level fields except these (this will not identify arrays and subobjects)
    |'
  prefs: []
  type: TYPE_TB
- en: Custom deny rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While the `security` package functions are useful, you may find yourself needing
    custom functions for more precise handling of your security. To build a custom
    function, you need to use the `Security.defineMethod` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This function accepts two parameters: `transform` and `deny`. The `transform`
    function allows the modification of fields before they enter the `deny` function,
    while the `deny` function is an extended version of `Meteor.deny`. The `deny`
    function passes several arguments that include information about the document
    being modified and the user. These arguments are: `type`, `arguments`, `userId`,
    `document`, `fields`, and `modifier`. The last two arguments (`fields` and `modifier`)
    are only passed if `type` is equal to `update`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add a custom function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are defining an `ifUserIsOwner` function that checks whether the ID
    of the currently logged in user is equal to the `user` field or the `_id` field
    on the modified document.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice that the logic of the rule denies a database operation if the user is
    not the owner of the document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can use this rule to secure our `users` collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are attaching rules to the `Meteor.users` collection in a different
    way. We do this because the `Meteor.users` collection is a special collection
    that is initialized in a different way than the rest of our collections, with
    this we have ensured that the rules are properly attached.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are allowing our users freely to modify the `email` field
    from the console, and only the admin user can modify all users from the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, now that we have locked the code from the client, how are we supposed
    to make things work? Running code directly from an event on the client will fail
    because the code is untrusted. We need to build a trusted code that will handle
    changes to the database. The solution is simple: Meteor methods.'
  prefs: []
  type: TYPE_NORMAL
- en: The Meteor methods – round 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already covered how `Meteor.methods` work, but we have not discussed
    the difference between trusted and untrusted code.
  prefs: []
  type: TYPE_NORMAL
- en: Trusted code can modify multiple documents at once by setting `multi` to `true`
    and can use an arbitrary Mongo selector to find the documents to modify. It bypasses
    any access control rules set up by allow and deny. Trusted code includes all server
    code and `Meteor.methods`.
  prefs: []
  type: TYPE_NORMAL
- en: Untrusted code can modify only a single document at once that is specified by
    its `_id`. The modification is allowed only after checking any applicable allow
    and deny rules. Untrusted code cannot perform upserts. Untrusted code includes
    client code such as event handlers and the console.
  prefs: []
  type: TYPE_NORMAL
- en: This means that whenever we directly modify a collection on the client, we are
    running untrusted code that is limited by our deny rules. Knowing this, it becomes
    obvious that most code, especially complex code with relationships, should run
    on a Meteor method.
  prefs: []
  type: TYPE_NORMAL
- en: But wait. Can a user modify the code of the method on the client side? They
    most certainly can, but remember that the code runs in a stub. The stub makes
    sure that the correct code runs on the server, while the client-side code updates
    the collections temporarily until the server responds. This is what Meteor calls
    **Optimistic UI**.
  prefs: []
  type: TYPE_NORMAL
- en: So, if someone tampers with the client-side version of our Meteor method, the
    server-side version will still run normally and the UI will update correctly.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to understand though that `Meteor.methods` will still be bound
    to the rules we had set on `Collection2`, which is a great feature inside a team
    environment where not everyone understands the structure of all data models.
  prefs: []
  type: TYPE_NORMAL
- en: So where should we use untrusted code? The answer depends greatly on your application,
    but for the most part, you will want everything to run on trusted code because
    it is easier to maintain and safer. Untrusted code should be used mostly to control
    things that the database is not connected to, or information that is allowed to
    be just about anything that the user wants.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use `Meteor.methods` properly, we need to run validation on `Meteor.methods`
    as well. We do this using Meteor''s core `check` package. Let''s upgrade our `cart.add-to-cart`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: First, we have used the `check` function to validate the structure of the `ops`
    object and to ensure that each key inside the object matches the correct type
    of data primitive. When the validation fails, the function will automatically
    stop and return a **404 Match Failed** error to the client.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have checked the status of the order. If the order is not new, then
    we throw a `Meteor.Error`. This will short circuit the function as well and return
    the `error` object to the client. When you are settings errors inside the Meteor
    methods, you will always use `throw new Meteor.Error(<error message>)` to communicate
    the error.
  prefs: []
  type: TYPE_NORMAL
- en: We do not need to worry about doing anything else with our errors. We will see
    how to keep track of our application errors in a different topic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `check` function takes only two variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The `value` parameter takes the variable that will be analyzed, while the `pattern`
    parameter takes the validator. The pattern can be as simple as a JavaScript primitive
    such as `String`, `Number`, and `Boolean`, an array of validators, an object of
    validators, or as complex as a function. The pattern simply needs to return `true`
    for the validation to pass.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meteor includes a handful of useful `pattern` functions through the `Match`
    object:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Pattern function | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Match.Any()` | This allows any value to pass validation. |'
  prefs: []
  type: TYPE_TB
- en: '| `Match.Integer()` | This allows any 32-bit integer. `Infinity` and `NaN`
    are not allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| `Match.ObjectIncluding(<object>:<pattern>)` | This allows an object to include
    key/value pairs that are not defined in the object. The example that we used does
    not allow other key/value pairs from entering the method. |'
  prefs: []
  type: TYPE_TB
- en: '| `Match.Optional(<second-pattern>)` | This allows a value to be `undefined`.
    If the value is defined, then the `second-pattern` will be evaluated instead.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Match.OneOf(<pattern1>, <pattern2>,...)` | This allows a value to pass if
    it matches any of the defined patterns. |'
  prefs: []
  type: TYPE_TB
- en: '| `Match.Where(<function(value){}>)` | This runs `function` and passes the
    defined value as the first parameter. If the function returns `true`, then validation
    passes. |'
  prefs: []
  type: TYPE_TB
- en: Now this is all grand and makes us feel much more secure, but the fact of the
    matter is that we are sharing our server-side logic on the client. This means
    that we absolutely cannot include sensitive data inside a Meteor method. If we
    do want to pass sensitive data, it is best to store it in a server-side variable
    and call it, or if you want to go an extra mile, you can separate the client-side
    method from the server using folders.
  prefs: []
  type: TYPE_NORMAL
- en: Managing the wait time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first chapter gave us a brief explanation of the impact that blocking can
    have on our client. To summarize this, if a function is waiting for a third-party
    or doing something that takes long, you should unblock the function. However,
    what impact can this have?
  prefs: []
  type: TYPE_NORMAL
- en: Remember that methods are placed on a conveyor belt. When we unblock a function,
    we place the method in a different conveyor belt where we cannot put other methods.
    This means that if another method depends on the unblocked method to complete,
    there can be a serious issue because the method can run before, during, or after
    the unblocked method.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our `cart.add-to-cart` method does not have an unblock function.
    This is to make sure that the server adds items to the cart in the same order
    as the client. So what do we do if we have something inside the method that can
    be placed in a separate conveyor belt? Can there be something that can happen
    in parallel and the user does not have to wait to continue?
  prefs: []
  type: TYPE_NORMAL
- en: '`Meteor.defer(<function>)` is a special, undocumented function that can take
    a particular snippet of code and run it in a separate conveyor without blocking
    the function from which it was called. Suppose we want to notify the admin every
    time a new order has been created, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have wrapped the `Email.send` function in a `Meteor.defer`
    function to make the e-mail run in parallel. This benefits the performance of
    your code by running deferred functions in parallel and focusing on producing
    only the results that matter to the user. By doing this, we ensure that the e-mail,
    a process that we know takes a long time to finish, does not block the server
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: Browser policy
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we can secure our collections and functions, we need to protect our
    application as a whole. We can achieve this protection using the `browser-policy`
    package. Let''s install it now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: So what exactly does this package do? By adding this, we are opening an access
    to a series of configuration options that will help us to set our application
    headers and content security policies to protect from cross-site scripting and
    data injection attacks.
  prefs: []
  type: TYPE_NORMAL
- en: These kinds of attacks are often used to steal your data (data theft), change
    the way your site looks (website defacement), and distribute malware. We definitely
    want to avoid all these attacks.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how does this work? By adding the package, we have already protected our
    application against many attacks by default, but we need to be able to control
    this. To do this, the package exposes two objects each with a particular set of
    functions: `BrowserPolicy.framing` and `BrowserPolicy.content`. Both these functions
    must be set in the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Framing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `BrowserPolicy.framing`, we can control whether our web application can
    be rendered inside an iframe or not. We have three functions to control this:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*.framing.disallow()` | This will never render in an iframe regardless of
    the origin. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.framing.restrictToOrigin(origin)` | This will only render in iframes created
    by the specified origin. This may take only one `origin` string and may be called
    only once. Also, it is not fully supported in WebKit. |'
  prefs: []
  type: TYPE_TB
- en: '| `*framing.allowAll()` | This will render in any iframe. |'
  prefs: []
  type: TYPE_TB
- en: You will find yourself using `BrowserPolicy.framing.disallow()` most of the
    time, but it is important to understand that you will still be able to iframe
    your app if origins are the same.
  prefs: []
  type: TYPE_NORMAL
- en: Content
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With `BrowserPolicy.content`, we can control exactly how the content will be
    loaded into our web application. We have many functions for this. However, we
    will actually end up using only a few. The functions are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*.content.allowInlineScripts()` | This allows DOM script tags to run.`DEFAULT`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*.content.disallowInlineScripts()` | This does not allow DOM script tags
    to run. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.content.allowEval()` | This allows the building of JavaScript from strings
    by using the `eval` function. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.content.disallowEval()` | This does not allow the building of JavaScript
    from strings by using the `eval` function.`DEFAULT`. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.content.allowInlineStyles()` | This allows inline styles and style DOM
    elements to run.`DEFAULT`. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.content.disallowInlineStyles()` | This does not allow inline styles and
    style DOM elements to run. |'
  prefs: []
  type: TYPE_TB
- en: 'There are more! The next set of functions defines a white-list of content types
    and how they are allowed to load. `ContentType` can take the value of: `Script`,
    `Object`, `Image`, `Media`, `Font`, `Frame`, and `Connect`.'
  prefs: []
  type: TYPE_NORMAL
- en: '| Function | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `*.allow<ContentType>Origin(origin)``*.allowScriptOrigin(origin)``*.allowObjectOrigin(origin)``*.allowImageOrigin(origin)``*.allowMediaOrigin(origin)``*.allowFontOrigin(origin)``*.allowFrameOrigin(origin)``*.allowConnectOrigin(origin)`
    | This allows the `ContentType` to be loaded from the `origin` string. This function
    can be called multiple times and has a support for wildcards. If a protocol (`http`
    / `https`) is not specified, then BOTH are allowed. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.allow<ContentType>DataUrl()` | This allows the `ContentType` to be loaded
    from a `data:` URL. This will allow base64-encoded images to render. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.allow<ContentType>SameOrigin()` | This allows the `ContentType` to be
    loaded from the same origin as the webapp. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.disallow<ContentType>()` | This does not allow `ContentType` to be loaded.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `*.allowSameOriginForAll()` | This allows all types of content to be loaded
    from the same origin as the webapp. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.allowDataUrlForAll()` | This allows all types of content to be loaded
    from a `data:` URL. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.allowOriginForAll(origin)` | This allows all types of content to be loaded
    from the specified `origin`. |'
  prefs: []
  type: TYPE_TB
- en: '| `*.disallowAll()` | This does not allow any type of content to be loaded
    from anywhere. |'
  prefs: []
  type: TYPE_TB
- en: 'Depending on what we want our application to achieve, we may have to tweak
    our rules. Let''s configure our security policy to the recommended options:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: External APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we know how to secure our application, we need to understand how to
    keep external data sources up to date. There are two patterns that we can use
    to ensure that the information on our server is recent: **synchronization** and
    **webhooks**.'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Synchronization will, basically, get data from our source continuously and refresh
    the database. This type of technique is useful when we need to save information
    from our data source and use that information to produce analytical data via the
    aggregation framework.
  prefs: []
  type: TYPE_NORMAL
- en: To keep our servers synchronized, we need to make sure that the process that
    fetches information does not block the server. We can ensure that this happens
    using nonblocking functions like `Meteor.setInterval`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s synchronize with Stripe. First, we will need to create a collection
    to capture payments, then we will have to set permissions and our Stripe secret,
    and finally, we will build the HTTP `GET` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Notice that when we created our collection, we did not give it a schema. We
    did this because we wanted to make sure that our collection is flexible in case
    the data from our endpoint changes. To secure our collection, we need to make
    sure that nobody can modify this in any way except for trusted code. Then we have
    created a configuration object that is going to hold our Stripe secret and public
    key.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we have created a `/stripe/server/payments.coffee` directory. Here, we
    have added the `get_payments` function to the `Stripe` object that we had defined
    in our _`globals` directory. To have this work properly, we had to pass a `params`
    object to control the way we are requesting data from Stripe's servers. Expect
    to pass `params` for every `GET` request you build since this controls the endpoints'
    `pagination`. Stripe explains in their documentation that we can get the next
    page of data by first checking whether there is more data via the `has_more` key
    and then passing in the last object ID from which to start via the `starting_after`
    parameter.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of this all, we have used the `Meteor.setInterval(<function>,<delay
    in milliseconds>)` function to make sure that the function runs every hour. Are
    we done yet? Not quite. While this code will definitely populate our `Payments`
    collection, it could potentially crash our server as well. Why? The request always
    queries from the beginning of time up to today, which makes the server progressively
    take longer. Another important issue is that if there is one `GET` request being
    processed and it has not finished within the hour, another request could start
    in parallel and consume even more resources.
  prefs: []
  type: TYPE_NORMAL
- en: We can prevent this by controlling our intervals and limiting the time frame
    our interval uses to get the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s make sure that we only have one interval running at a time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are keeping payments together under a `payments` object now.
    Then we have simply set and checked a `is_running` Boolean key to see whether
    the process is running or not. Now if we were to reduce the interval to 1 millisecond,
    it would only GET from the external API after the previous request is done processing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can use the `starting_after` parameter to ensure that we only get the
    latest information. To do this, we will have to use the `moment` function to filter
    data by time and get the latest payment information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we have simply used `moment` to identify a Unix timestamp from
    10 days ago. The `moment` object is made available using the `momentjs:moment`
    package. Notice that we are using the `utc()` function to set `startOf("day")`
    consistently between our development and production environments. Then we have
    queried the server, and if the payment exists, we will use the ID of the payment
    as our `starting_after` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to understand that we can make this query easily only because
    the information that Stripe sends includes a Unix timestamp. Not every API has
    a Unix timestamp. Most likely, you will end up inserting or transforming their
    data to fit your own. This can be easily addressed by extending their response
    when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Webhooks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Webhooks are the way through which other servers can communicate directly with
    ours. They, basically, make a `POST` request to one of our endpoints to inform
    our server that something has happened.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of Stripe, we are going to add an endpoint that will catch all of
    Stripe's charge webhooks. To do this, we will use the `nimble:restivus` package.
  prefs: []
  type: TYPE_NORMAL
- en: '`Restivus` is an excellent package that makes it easy to maintain a RESTful
    API with version control and user authentication. It runs only on the server side
    for security.'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create an instance of `Restivus`. This instance will hold
    the routes for the first version of our endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have attached our new server-side endpoint to the global `Stripe`
    object under the `hooks` and `v1` keys. This will make it easy to create new routes
    for version 1 anywhere in our server. The `Restivus` instance takes in a handful
    of parameters, the ones that you will end up using the most are:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Parameter | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `apiPath` | String defines the parent route of all the endpoints. If we define
    `apiPath` as `"stripe"` and a route as `"charge"`, then the path for the route
    will be `ROOT_URL/stripe/charge`. |'
  prefs: []
  type: TYPE_TB
- en: '| `version` | String defines the version number of the API and adds it to the
    parent route. If we define `version` as `"v1"`, then all the routes will take
    this form: `ROOT_URL/<apiPath>/v1/<route>`. |'
  prefs: []
  type: TYPE_TB
- en: '| `enableCors` | Boolean sets whether the route is accessible from external
    domains. Default: `true`. |'
  prefs: []
  type: TYPE_TB
- en: 'Now let''s create an endpoint that updates the `Payments` collection. To create
    an endpoint, we need to define a route on our `Restivus` instance. To do this,
    we simply call the global object that we had defined and use the `addRoute` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Now our endpoint can catch Stripe's webhook notifications. Notice that the information
    that the `POST` request contains is located in the `@request.body` object. After
    analyzing this object, we can see that the object that Stripe is sending. In this
    case, Stripe sends an object with a `data` key, which in turn contains an `object`
    key that holds the information of the payment. If you want to see the information
    that Stripe is responding with, simply log in to the console.
  prefs: []
  type: TYPE_NORMAL
- en: Also, we are returning a `@done()` function, which notifies Stripe that the
    request was processed. This makes sure that Stripe does not have to make a second
    attempt to notify our server.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `addRoute` function can handle all types of HTTP requests including `get`,
    `put`, `delete`, `patch`, and `options`. The endpoints have these variables in
    their context to help handle requests:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Context variable | Use |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `this.user` | The `Meteor.user` object after authentication passes. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.userId` | The `Meteor.userId` string after authentication passes. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.urlParams` | Parameters defined in the URL string:`ROOT_URL/stripe/v1/charge/:more`To
    access the `more` parameter, you would call `@urlParams.more`. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.queryParams` | Query parameters defined in the URL string:`ROOT_URL/stripe/v1/charge?more=data`To
    access the `more` parameter, you would call `@urlQueryParams.more`. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.bodyParams` | The body of the request. This is the equivalent to `@request.body`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `this.request` | A NodeJS request object. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.response` | A NodeJS response object. |'
  prefs: []
  type: TYPE_TB
- en: '| `this.done()` | This function must be called after handling a response. |'
  prefs: []
  type: TYPE_TB
- en: Now, we can set up webhooks from Stripe by going to their settings page and
    creating a webhook. Make sure to point their URL to the one that we built.
  prefs: []
  type: TYPE_NORMAL
- en: '![Webhooks](img/00002.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We can send a couple of test hooks, too, to make sure that everything works
    as intended. By using both the synchronization pattern and the webhooks pattern,
    we are able to keep our data up to date. You should always use both patterns if
    the API allows you to. Why? This is because their webhooks server could potentially
    fail.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter covered three important things: how to control the amount of data
    that we publish, how to secure our app, and how to better integrate with an external
    API. We learned a pattern to build pagination that functions with filters as well.
    Then we learned how to build user roles and schemas to secure access to our application
    better. Next, we understood the limitations of allow/deny rules and addressed
    these limitations by writing effective deny rules. We quickly realized these deny
    rules were blocking functions from all the event handlers because they are insecure.
    To get around this limitation, we learned how to build trusted code. Towards the
    end, integrating Stripe taught us how to create a nonblocking synchronization
    function and how to use `restivus` to catch incoming messages from external servers.'
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter is going to cover the basics of how to test and maintain our
    code. With the next chapter, we will be able to share our code without fearing
    that someone else will break it.
  prefs: []
  type: TYPE_NORMAL
