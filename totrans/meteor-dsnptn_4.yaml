- en: Chapter 4. Application Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第四章 应用模式
- en: 'This chapter will cover application-wide patterns that share server- and client-
    side code. With these patterns, your code will become more secure and easier to
    manage. You will learn the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖共享服务器和客户端代码的应用程序级模式。使用这些模式，你的代码将变得更加安全且易于管理。你将学习以下主题：
- en: Filtering and paging collections
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 过滤和分页集合
- en: Security
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安全性
- en: External API
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 外部API
- en: Filtering and paging collections
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 过滤和分页集合
- en: So far, we have been publishing collections without thinking much about how
    many documents we are pushing to the client. The more documents we publish, the
    longer it will take the web page to load. To solve this issue, we are going to
    learn how to show only a set number of documents and allow the user to navigate
    through the documents in the collection by either filtering or paging through
    them.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们发布集合时并没有过多考虑我们向客户端推送了多少文档。我们发布的文档越多，网页加载的时间就越长。为了解决这个问题，我们将学习如何只显示一定数量的文档，并允许用户通过过滤或分页在集合中导航。
- en: Filters and pagination are easy to build with Meteor's reactivity.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Meteor的响应性构建过滤器和分页很容易。
- en: Router gotchas
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由注意事项
- en: 'Routers will always have two types of parameters that they can accept: query
    parameters, and normal parameters. Query parameters are the objects that you will
    commonly see in site URLs followed by a question mark (`<url-path>?page=1`), while
    normal parameters are the type that you define within the route URL (`<url>/<normal-parameter>/named_route/<normal-parameter-2>`).
    It is a common practice to set query parameters on things such as pagination to
    keep your routes from creating URL conflicts.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器始终可以接受两种类型的参数：查询参数和普通参数。查询参数是通常在网站URL后面跟着一个问号（`<url-path>?page=1`）的对象，而普通参数是你在路由URL中定义的类型（`<url>/<normal-parameter>/named_route/<normal-parameter-2>`）。在分页等事物上设置查询参数是一种常见的做法，以避免你的路由创建URL冲突。
- en: A URL conflict happens when two routes look the same but have different parameters.
    A products route such as `/products/:page` collides with a product detail route
    such as `/products/:product-id`. While both the routes are differently expressed
    because of the differences in their normal parameter, you arrive at both the routes
    using the same URL. This means that the only way the router can tell them apart
    is by routing to them programmatically. So the user would have to know that the
    `FlowRouter.go()` command has to be run in the console to reach either one of
    the products pages instead of simply using the URL.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个路由看起来相同但参数不同时，会发生URL冲突。例如，一个产品路由如`/products/:page`与一个产品详情路由如`/products/:product-id`冲突。虽然由于普通参数的不同，这两个路由的表达方式不同，但你使用相同的URL到达这两个路由。这意味着路由器唯一能够区分它们的方法是通过编程路由。因此，用户必须知道必须运行`FlowRouter.go()`命令才能到达任何一个产品页面，而不是简单地使用URL。
- en: This is why we are going to use query parameters to keep our filtering and pagination
    stateful.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们将使用查询参数来保持我们的过滤和分页状态。
- en: Stateful pagination
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 状态化分页
- en: Stateful pagination is simply giving the user the option to copy and paste the
    URL to a different client and see the exact same section of the collection. This
    is important to make the site easy to share.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 状态化分页简单来说就是给用户一个选项，让他们能够复制并粘贴URL到不同的客户端，并看到集合中完全相同的部分。这对于使网站易于分享非常重要。
- en: In [Chapter 2](part0021_split_000.html#page "Chapter 2. Publish and Subscribe
    Patterns"), *Publish and Subscribe Patterns* we had created a products publisher
    and subscriber to elaborate on our publishers. Now we are going to understand
    how to control our subscription reactively so that the user can navigate through
    the entire collection.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第二章](part0021_split_000.html#page "第二章 发布和订阅模式")中，我们创建了产品发布者和订阅者来详细说明我们的发布者。现在我们将了解如何以响应式的方式控制我们的订阅，以便用户可以导航整个集合。
- en: First, we need to set up our router to accept a page number. Then we will take
    this number and use it on our subscriber to pull in the data that we need. To
    set up the router, we will use a `FlowRouter` query parameter (the parameter that
    places a question mark next to the URL).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要设置我们的路由器以接受页码。然后我们将使用这个数字在我们的订阅者中获取所需的数据。为了设置路由器，我们将使用`FlowRouter`查询参数（在URL旁边放置问号的参数）。
- en: 'Let''s set up our query parameter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置我们的查询参数：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: What we are doing here is straightforward. First, we extend the filter object
    with a `page` key that gets the current value of the page query parameter, and
    if this value does not exist, then it is set to `0`. `getQueryParam` is a reactive
    data source, the `autorun` function will resubscribe when the value changes. Then
    we will create a helper for our view so that we can see what page we are on and
    the two events that set the page query parameter.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做的事情很简单。首先，我们使用`page`键扩展过滤器对象，该键获取当前页面查询参数的值，如果该值不存在，则将其设置为`0`。"`getQueryParam`"是一个反应性数据源，`autorun`函数将在值变化时重新订阅。然后我们将创建一个视图的辅助函数，这样我们就可以看到我们所在的页面以及设置页面查询参数的两个事件。
- en: But wait. How do we know when the limit to pagination has been reached? This
    is where the `tmeasday:publish-counts` package is very useful. It uses a publisher's
    special function to count exactly how many documents are being published.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 但是等等。我们如何知道分页限制何时达到？这正是`tmeasday:publish-counts`包非常有用的地方。它使用发布者的特殊函数来精确计算正在发布的文档数量。
- en: 'Let''s set up our publisher:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置我们的发布者：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'To publish our counts, we used the `Counts.publish` function. This function
    takes in a few parameters:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 为了发布我们的计数，我们使用了`Counts.publish`函数。这个函数接受几个参数：
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note that we used the `noReady` parameter to prevent the `ready` function from
    running prematurely. By doing this, we generate a counter that can be accessed
    on the client side by running `Counts.get "products"`. Now you might be thinking,
    why not use `Products.find().count()` instead? In this particular scenario, this
    would be an excellent idea, but you absolutely have to use the `Counts` function
    to make the count reactive, so if any dependencies change, they will be accounted
    for.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们使用了`noReady`参数来防止`ready`函数提前运行。通过这样做，我们生成一个计数器，可以通过运行`Counts.get "products"`在客户端访问。现在你可能想知道，为什么不使用`Products.find().count()`呢？在这个特定场景中，这确实是一个很好的主意，但你绝对必须使用`Counts`函数来使计数反应化，这样如果任何依赖项发生变化，它们都会被考虑在内。
- en: 'Let''s modify our view and helpers to reflect our counter:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们修改我们的视图和辅助函数以反映我们的计数器：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Great! Users can now copy and paste the URL to obtain the same results they
    had before. This is exactly what we need to make sure our customers can share
    links. If we had kept our page variable confined to a `Session` or a `ReactiveVar`,
    it would have been impossible to share the state of the webapp.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！现在用户可以复制并粘贴URL以获得他们之前的结果。这正是我们需要确保我们的客户可以分享链接的原因。如果我们保持页面变量局限于`Session`或`ReactiveVar`，那么分享Web应用的状态将是不可能的。
- en: Filtering
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过滤
- en: 'Filtering and searching, too, are critical aspects of any web app. Filtering
    works similar to pagination; the publisher takes additional variables that control
    the filter. We want to make sure that this is stateful, so we need to integrate
    this into our routes, and we need to program our publishers to react to this.
    Also, the filter needs to be compatible with the pager. Let''s start by modifying
    the publisher:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 过滤和搜索也是任何Web应用的关键方面。过滤的工作方式类似于分页；发布者接受额外的变量来控制过滤。我们想确保这是有状态的，因此我们需要将其集成到我们的路由中，并且我们需要编程我们的发布者来对此做出反应。此外，过滤器需要与分页器兼容。让我们先修改发布者：
- en: '[PRE4]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: To build any filter, we have to make sure that the property that creates the
    filter exists and `_.extend` our `filter` object based on this. This makes our
    code easier to maintain. Notice that we can easily add the filter to every section
    that includes the `Products` collection. With this, we have ensured that the filter
    is always used even if tags have filtered the data. By adding the filter to the
    `Counts.publish` function, we have ensured that the publisher is compatible with
    pagination as well.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建任何过滤器，我们必须确保创建过滤器的属性存在，并基于此`_.extend`我们的`filter`对象。这使得我们的代码更容易维护。注意，我们可以轻松地将过滤器添加到包含`Products`集合的每个部分。通过这种方式，我们确保了即使在标签过滤了数据的情况下，过滤器也始终被使用。通过将过滤器添加到`Counts.publish`函数中，我们确保了发布者也与分页兼容。
- en: 'Let''s build our controller:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们构建我们的控制器：
- en: '[PRE5]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we have renamed our `filter` object to `ops` to keep things consistent
    between the publisher and subscriber. Then we have attached a `search` key to
    the `ops` object that takes the value of the search query parameter. Notice that
    we can pass an undefined value for `search`, and our subscriber will not fail,
    since the publisher already checks whether the value exists or not and extends
    filters based on this. It is always better to verify variables on the server side
    to ensure that the client doesn't accidentally break things. Also, we need to
    make sure that we know the value of that parameter so that we can create a new
    `search` helper under the `pages` helper. Finally, we have built an event for
    the search bar. Notice that we are setting query parameters to `null` whenever
    they do not apply. This makes sure that they do not appear in our URL if we do
    not need them.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将`filter`对象重命名为`ops`，以保持发布者和订阅者之间的统一。然后，我们在`ops`对象上附加了一个`search`键，该键接受搜索查询参数的值。请注意，我们可以为`search`传递一个未定义的值，并且我们的订阅者不会失败，因为发布者已经检查了该值是否存在，并基于此扩展了过滤器。始终在服务器端验证变量以确保客户端不会意外地破坏事物更好。此外，我们还需要确保我们知道该参数的值，以便在`pages`辅助程序下创建一个新的`search`辅助程序。最后，我们为搜索栏构建了一个事件。请注意，当它们不适用时，我们正在将查询参数设置为`null`。这确保了如果不需要它们，它们不会出现在我们的URL中。
- en: 'To finish, we need to create the search bar:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要创建搜索栏：
- en: '[PRE6]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice that our search input is somewhat cluttered with special attributes.
    All these attributes ensure that our input is not doing the things that we do
    not want it to for iOS Safari. It is important to keep up with nonstandard attributes
    such as these to ensure that the site is mobile-friendly. You can find an updated
    list of these attributes here at [https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/Attributes.html](https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/Attributes.html).
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的搜索输入有点杂乱，带有特殊属性。所有这些属性都确保我们的输入不会执行我们不希望它执行的事情，针对iOS Safari。保持对非标准属性（如这些）的关注很重要，以确保网站对移动设备友好。您可以在以下位置找到这些属性的更新列表：[https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/Attributes.html](https://developer.apple.com/library/safari/documentation/AppleApplications/Reference/SafariHTMLRef/Articles/Attributes.html)。
- en: Security
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Many packages secure certain parts of the Meteor stack, but even then, you cannot
    rely on these packages completely. Also, you have to be very careful about the
    packages you choose! Some packages might intercept core functions to funnel information
    out of your application. This means that you should always have a look at the
    source code of the package before you install it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 许多包保护Meteor堆栈的某些部分，即使如此，你也不能完全依赖这些包。此外，你必须非常小心地选择你选择的包！一些包可能会拦截核心功能，将信息从你的应用程序中过滤出来。这意味着在安装之前，你应该始终查看该包的源代码。
- en: 'This topic is usually an oversight to novice Meteor developers, and yet it
    is one of the most important topics to know about. To secure our webapp we need
    to:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这个话题通常是新手Meteor开发者的疏忽，然而，它却是需要了解的最重要的话题之一。为了确保我们的webapp安全，我们需要：
- en: Define roles (set distinctions between users)
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义角色（设置用户之间的区别）
- en: Define schemas for every collection (limit how they can modify fields)
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为每个集合定义模式（限制它们可以修改的字段）
- en: Define deny rules (limit who can modify fields)
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义拒绝规则（限制谁可以修改字段）
- en: Use methods, when necessary, to check parameters (ensure complex security when
    needed)
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在必要时使用方法来检查参数（确保需要时具有复杂的安全性）
- en: Set browser policies
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置浏览器策略
- en: Roles
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 角色
- en: Using roles, just about every web application creates a distinction between
    users and what they are allowed to do. To help us manage roles easily, we have
    installed the `alanning:roles` package. With this package, we are going to control
    who hits our routes and who may modify our collections.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 使用角色，几乎每个Web应用都会在用户和他们可以做什么之间创建区别。为了帮助我们轻松管理角色，我们安装了`alanning:roles`包。使用此包，我们将控制谁访问我们的路由以及谁可以修改我们的集合。
- en: 'This package makes the `Roles.userIsInRole` function available, which uses
    a `roles` collection to make sure that the user is in the correct role:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 此包使`Roles.userIsInRole`函数可用，该函数使用`roles`集合确保用户处于正确的角色：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Suppose you need to check whether a user is an `admin` or a `manager` before
    they access a certain function. For this, you will simply do the following:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要在用户访问某个功能之前检查该用户是`admin`还是`manager`。为此，你只需做以下操作：
- en: '[PRE8]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s add an `admin` role to our application. We can start by creating an
    initialization file that will automatically build our admin user:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在应用程序中添加一个 `admin` 角色。我们可以从创建一个初始化文件开始，该文件将自动构建我们的管理员用户：
- en: '[PRE9]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Notice that we are using the `Roles.addUsersToRoles` function to set the new
    user''s role to `admin`, and this takes place on the server side. Always set user
    roles on the server side. Next, let''s build a login route that can be accessed
    only if you are not already logged in:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在使用 `Roles.addUsersToRoles` 函数将新用户的角色设置为 `admin`，并且这一操作是在服务器端完成的。始终在服务器端设置用户角色。接下来，让我们构建一个只有未登录时才能访问的登录路由：
- en: '[PRE10]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: To make sure roles run at the right moment when our user first hits the site,
    we need to make sure that `FlowRouter` activates after roles have been loaded.
    To do this we use `FlowRouter.initialize()` and `FlowRouter.wait()`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保在用户第一次访问网站时角色在正确的时间运行，我们需要确保 `FlowRouter` 在角色加载后激活。为此，我们使用 `FlowRouter.initialize()`
    和 `FlowRouter.wait()`。
- en: '[PRE11]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `FlowRouter.route` function accepts a `triggersEnter` parameter and a `triggersExit`
    parameter. This can be used to redirect the user based on roles. Both these parameters
    are arrays of functions so that many triggers can be added to each route. To make
    it easier for us, we are going to create a dictionary of triggers under a global
    `RT` object. Notice that we do not execute the function within the triggers array,
    so we do not include parentheses.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`FlowRouter.route` 函数接受一个 `triggersEnter` 参数和一个 `triggersExit` 参数。这可以用来根据角色重定向用户。这两个参数都是函数数组，因此可以为每个路由添加多个触发器。为了让我们更容易操作，我们将在全局
    `RT` 对象下创建一个触发器字典。注意，我们不在触发器数组中执行函数，所以不包括括号。'
- en: 'Let''s start by moving the `/router` folder to the `/_globals` folder. This
    will make sure that the `RT` object is the first thing that is defined. After
    doing this, we should define two triggers:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先移动 `/router` 文件夹到 `/_globals` 文件夹。这将确保 `RT` 对象是首先定义的东西。完成此操作后，我们应该定义两个触发器：
- en: '[PRE12]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Notice that when `FlowRouter` calls these functions, it will include a `context`
    object and a `redirect` function. The `context` object has information about the
    route that we are trying to connect to and our previous route, while the `redirect`
    function is used to redirect a user. In this case, we have attempted to redirect
    to the previous route if it exists, if it does not exist, then we redirect to
    root.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当 `FlowRouter` 调用这些函数时，它将包括一个 `context` 对象和一个 `redirect` 函数。`context` 对象包含我们试图连接的路由和我们的上一个路由的信息，而
    `redirect` 函数用于重定向用户。在这种情况下，我们尝试将用户重定向到上一个路由，如果它存在的话；如果不存在，则重定向到根目录。
- en: 'Now, let''s add the `admin_only` trigger to every route except `products` and
    `login`:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们将 `admin_only` 触发器添加到除 `products` 和 `login` 之外的所有路由：
- en: '[PRE13]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: We can easily create a global trigger that does not apply to the `products`
    nor the `login` routes using the `FlowRouter.triggers.<enter or exit>` function.
    We don't have to worry about including our `404` route since by default; it does
    not run triggers.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以轻松地创建一个全局触发器，该触发器不适用于 `products` 和 `login` 路由，使用 `FlowRouter.triggers.<enter
    or exit>` 函数。我们不必担心包含我们的 `404` 路由，因为默认情况下，它不会运行触发器。
- en: 'To finish up, let''s build a custom login page:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们构建一个自定义登录页面：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Here, we have used Meteor's core `Meteor.loginWithPassword` function to log
    in, and we have kept a track of the errors using a `ReactiveVar` variable.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用了 Meteor 的核心 `Meteor.loginWithPassword` 函数进行登录，并使用 `ReactiveVar` 变量跟踪错误。
- en: Collection2
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Collection2
- en: 'Suppose a malicious user visits the site and quickly identifies one of our
    collections in the browser console. They are going to update one of the products
    by calling the `Products.update` function. Because our site is insecure, they
    can successfully call something like this:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个恶意用户访问网站并迅速在浏览器控制台中识别出我们的一个集合。他们将通过调用 `Products.update` 函数来更新其中一个产品。因为我们的网站不安全，他们可以成功调用类似以下的内容：
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This will successfully create a field that should not exist for that particular
    product!
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这样将成功创建一个对于该特定产品不应存在的字段！
- en: With the `aldeed:collection2` package, we are going to secure our collections
    by white-listing fields. This makes sure that the allowed users can only set acceptable
    values on our collections and that these values meet certain criteria.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `aldeed:collection2` 包，我们将通过白名单字段来保护我们的集合。这确保了允许的用户只能在我们的集合上设置可接受的价值，并且这些值符合某些标准。
- en: 'A `collection` field can take the following parameters:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 一个 `collection` 字段可以接受以下参数：
- en: '| Parameter | Use |'
  id: totrans-74
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 用途 |'
- en: '| --- | --- |'
  id: totrans-75
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `type` | This defines the type of the value. This can be any JavaScript primitive:
    `String`, `Number`, `Boolean`, `Date`, `Object`, or an array of primitives such
    as `[Object]`, `[String]`. |'
  id: totrans-76
  prefs: []
  type: TYPE_TB
  zh: '| `type` | 这定义了值的类型。这可以是任何 JavaScript 原始类型：`String`、`Number`、`Boolean`、`Date`、`Object`
    或原始类型的数组，例如 `[Object]`、`[String]`。|'
- en: '| `decimal` | This is only available if `type:Number`. This defines whether
    a number is a decimal. This can be `true` or `false`. |'
  id: totrans-77
  prefs: []
  type: TYPE_TB
  zh: '| `decimal` | 这仅在 `type:Number` 时可用。这定义了一个数字是否是十进制。这可以是 `true` 或 `false`。|'
- en: '| `optional` | This defines whether the field is required on insert. This can
    be `true` or `false`. |'
  id: totrans-78
  prefs: []
  type: TYPE_TB
  zh: '| `optional` | 这定义了在插入时字段是否是必需的。这可以是 `true` 或 `false`。|'
- en: '| `regEx` | This checks whether the string matches the defined `regEx` expression.
    This can be any `regEx` expression such as `/^[A-Z]$/`. |'
  id: totrans-79
  prefs: []
  type: TYPE_TB
  zh: '| `regEx` | 这用于检查字符串是否与定义的 `regEx` 表达式匹配。这可以是任何 `regEx` 表达式，例如 `/^[A-Z]$/`。|'
- en: '| `allowedValues` | This checks whether the string matches any of the values
    in an array. This can be only an array of strings such as `["Green","Blue"]`.
    |'
  id: totrans-80
  prefs: []
  type: TYPE_TB
  zh: '| `allowedValues` | 这用于检查字符串是否与数组中的任何值匹配。这只能是一个字符串数组，例如 `["Green","Blue"]`。|'
- en: '| `blackbox` | This allows any combination of values and objects to be placed
    as values. This can be only `true` or `false`. |'
  id: totrans-81
  prefs: []
  type: TYPE_TB
  zh: '| `blackbox` | 这允许任何组合的值和对象被放置为值。这只能是 `true` 或 `false`。|'
- en: '| `denyUpdate` | This defines whether the field can be updated. This can be
    only `true` or `false`. |'
  id: totrans-82
  prefs: []
  type: TYPE_TB
  zh: '| `denyUpdate` | 这定义了字段是否可以被更新。这只能是 `true` 或 `false`。|'
- en: '| `denyInsert` | This defines whether the field can be inserted. If this field
    is set to `true`, `optional:true` must be set as well. This can be only `true`
    or `false`. |'
  id: totrans-83
  prefs: []
  type: TYPE_TB
  zh: '| `denyInsert` | 这定义了字段是否可以被插入。如果此字段设置为 `true`，则必须同时设置 `optional:true`。这只能是
    `true` 或 `false`。|'
- en: '| `autoValue` | This defines the value that the field will take during an operation.
    This can be a `function` only. |'
  id: totrans-84
  prefs: []
  type: TYPE_TB
  zh: '| `autoValue` | 这定义了字段在操作期间将采取的值。这只能是 `function`。|'
- en: '| `custom` | This defines the custom function that will validate the field.
    This can be a `function` only. |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| `custom` | 这定义了将验证字段的自定义函数。这只能是 `function`。|'
- en: '| `unique` | This defines whether the value of the field should be unique.
    This can be only `true` or `false`. |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `unique` | 这定义了字段值是否应该是唯一的。这只能是 `true` 或 `false`。|'
- en: With these parameters, it is easy to lock down every collection including the
    `Meteor.users` collection and increase the security of our app drastically.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些参数，可以轻松锁定包括 `Meteor.users` 集合在内的每个集合，并极大地提高我们应用程序的安全性。
- en: As we will save all our numerical data in hundreds, we will never use the `decimal`
    parameter. You should always avoid decimals regardless of whether you are dealing
    with money or not.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将把所有数值数据以百为单位保存，所以我们永远不会使用 `decimal` 参数。无论是否处理金钱，都应该始终避免使用小数。
- en: 'Both the `autoValue` and `custom` parameters expose variables and functions
    within their context that are critical to understand:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 自动值和自定义参数在其上下文中暴露了关键的变量和函数：
- en: '| Context variables and functions | Use |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| 上下文变量和函数 | 使用 |'
- en: '| --- | --- |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `this.isInsert` | Boolean. This checks whether the field is being inserted.
    |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `this.isInsert` | 布尔型。这用于检查字段是否正在被插入。|'
- en: '| `this.isUpdate` | Boolean. This checks whether the field is being updated.
    |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `this.isUpdate` | 布尔型。这用于检查字段是否正在被更新。|'
- en: '| `this.upsert` | Boolean. Check whether the field is being upserted. |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `this.upsert` | 布尔型。检查字段是否正在被更新。|'
- en: '| `this.userId` | String. This checks the current `userId`. Returns `undefined,`
    if it does not exist and is `null` for all server-initiated functions. |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| `this.userId` | 字符串型。这用于检查当前的 `userId`。如果不存在则返回 `undefined`，对于所有由服务器启动的函数返回
    `null`。|'
- en: '| `this.isFromTrustedCode` | Boolean. This checks whether the field is being
    modified by the server-side code. |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| `this.isFromTrustedCode` | 布尔型。这用于检查字段是否被服务器端代码修改。|'
- en: '| `this.isSet` | Boolean. This checks whether the field is being modified.
    |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `this.isSet` | 布尔型。这用于检查字段是否正在被修改。|'
- en: '| `this.value` | Anything. If `this.isSet,` then this will be the value of
    the field. |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `this.value` | 任何类型。如果 `this.isSet`，则这将代表字段的值。|'
- en: '| `this.operator` | String. If `this.isSet` and `this.isUpdate,` then this
    will be the operator that modifies the value (`$pull`, `$push`, `$addToSet`, `$set`,
    and so on). |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `this.operator` | 字符串型。如果 `this.isSet` 和 `this.isUpdate`，则这将代表修改值的操作符（`$pull`、`$push`、`$addToSet`、`$set`
    等）。|'
- en: '| `this.field("<field-name>")` | This is a function that returns an object.
    This gets the object representation of a field that is being modified. From this
    object, you can use `isSet`, `value`, and `operator` to get more information.
    For example, `this.field("name").value` will return the value of the field name,
    if it is set. |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `this.field("<field-name>")` | 这是一个返回对象的函数。它获取正在修改的字段的对象表示。从这个对象中，你可以使用 `isSet`、`value`
    和 `operator` 来获取更多信息。例如，`this.field("name").value` 将返回字段名称的值，如果它被设置的话。|'
- en: With these functions, we can add custom validators and custom automatic values
    depending on the state of the modification. Also, we can check what the values
    of other fields are and react to them if we need to. If your validation requires
    complex queries with other collections, DO NOT RELY ON THIS PACKAGE!. This tool
    is strictly to control collection-specific values and not relationships. Remember
    that not all our collections are available on the client side, and therefore,
    are incapable of being validated properly. We will address these kinds of validations
    in the next topic.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些函数，我们可以根据修改的状态添加自定义验证器和自定义自动值。我们还可以检查其他字段的值，并在需要时对其做出反应。如果你的验证需要与其他集合的复杂查询，请不要依赖这个包！这个工具严格用于控制特定集合的值，而不是关系。请记住，并非我们所有的集合都在客户端可用，因此无法正确验证。我们将在下一个主题中解决这类验证。
- en: 'Let''s secure all our collections. We will only show the `Orders` and `OrderDetails`
    collections schemas:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们保护所有我们的集合。我们将只显示 `Orders` 和 `OrderDetails` 集合的模式：
- en: '[PRE16]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'As you can see, the pattern for white-listing a field within our collection
    is a simple object that contains the `Collection2` parameters. Notice that we
    can define rules for subobjects using MongoDB''s dot notation. This means that
    we can set rules for arrays and object arrays in the same fashion as well:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在我们的集合中为字段设置白名单的模式是一个包含 `Collection2` 参数的简单对象。请注意，我们可以使用 MongoDB 的点表示法来定义子对象的规则。这意味着我们也可以以相同的方式为数组和对象数组设置规则：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Still, you do not have to set complex rules often since they are clear indicators
    that a new collection should be created.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，你不必经常设置复杂的规则，因为它们是创建新集合的明确指标。
- en: Notice that we are not using any complex custom validation in our schema besides
    `name` and `type`. Why? Should we check whether the user is an admin, or whether
    the modification originated from the server-side code, or whether the order belongs
    to the customer?
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，除了`name`和`type`之外，在我们的模式中我们没有使用任何复杂的自定义验证。为什么？我们应该检查用户是否是管理员，或者修改是否来自服务器端代码，或者订单是否属于客户？
- en: While we could start adding a few lists of checks for each field, the true source
    of the problem stems from allowing users to modify our collection directly from
    the console. To fully secure our orders, we need to modify the allow/deny rules
    and use trusted code.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们可以开始为每个字段添加一些检查列表，但问题的真正根源在于允许用户直接从控制台修改我们的集合。为了完全保护我们的订单，我们需要修改允许/拒绝规则并使用可信代码。
- en: It is important to understand that these schemas are used by server-side code
    too. This makes sure that neither the client nor the server can mess up our keys.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 理解这些模式也被服务器端代码使用是很重要的。这确保了客户端和服务器都无法破坏我们的键。
- en: Deny rules
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 拒绝规则
- en: Now that we know the fields that will be in our collections, we need to make
    sure that the server allows the right people to modify these collections. To do
    this, we first need to understand exactly how the allow/deny rules work.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了将在我们的集合中出现的字段，我们需要确保服务器允许正确的人修改这些集合。为此，我们首先需要确切了解允许/拒绝规则是如何工作的。
- en: 'Meteor has two core functions that control whether a collection modification
    is allowed or not: `Meteor.allow` and `Meteor.deny`.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 有两个核心函数控制集合修改是否允许：`Meteor.allow` 和 `Meteor.deny`。
- en: The `Meteor.allow` functions allow a collection to be modified as soon as one
    of the rules resolves to `true`. Also, this means that the other allow rules are
    not evaluated! Knowing this, some developers cram logic into a single allow rule
    that could easily fail. This is bad practice because the code will be difficult
    to maintain.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meteor.allow` 函数允许在其中一个规则解析为 `true` 时立即修改集合。这也意味着其他允许规则不会被评估！了解这一点后，一些开发者将逻辑塞入单个允许规则中，这很容易失败。这是不好的做法，因为代码将难以维护。'
- en: On the other hand, the `Meteor.deny` functions will always run and trump a `Meteor.allow`
    rule that resolves to `true`. To manage our deny rules effectively, we are going
    to use the `ongoworks:security` package. With this package, we can easily build
    reusable and readable rules to be set on our collections.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`Meteor.deny` 函数将始终运行，并覆盖解析为 `true` 的 `Meteor.allow` 规则。为了有效地管理我们的拒绝规则，我们将使用
    `ongoworks:security` 包。使用这个包，我们可以轻松地构建可重用且易于阅读的规则，并将其设置在我们的集合上。
- en: 'Let''s begin by removing all the allow rules from our project. Then we can
    set some rules for our `Orders` collection:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从移除我们项目中的所有允许规则开始。然后我们可以为我们的 `Orders` 集合设置一些规则：
- en: '[PRE18]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With this simple rule, we have denied anything that does not match this rule.
    This package integrates directly with our `roles` package, so we can easily use
    the `ifHasRole` function. This rule makes sure that only an admin user can update
    an order's `status` field via the console. To make sure that the rule is applied,
    we have used the `apply` function.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个简单的规则，我们拒绝了所有不符合此规则的任何内容。此包直接与我们的 `roles` 包集成，因此我们可以轻松使用 `ifHasRole` 函数。此规则确保只有管理员用户可以通过控制台更新订单的
    `status` 字段。为了确保规则被应用，我们使用了 `apply` 函数。
- en: 'There are three things that we need to understand about the deny rules: logic,
    integrated functions, and custom functions.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要了解关于拒绝规则的三件事：逻辑、内置函数和自定义函数。
- en: 'Logic in rules decides whether they act as ANDs or ORs. If we have multiple
    functions inside a rule, then we define AND rules. The function that we have defined
    for our orders is an AND rule because this checks `ifLoggedIn` AND `ifHasRole`
    AND `onlyProp` before allowing a modification to pass. If we want to create an
    OR rule, we simply create a new rule. Let''s try this:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 规则中的逻辑决定了它们是作为 AND 还是 OR 操作符来执行。如果我们在一个规则中包含多个函数，那么我们定义 AND 规则。我们为我们的订单定义的函数是一个
    AND 规则，因为它在允许修改通过之前会检查 `ifLoggedIn` AND `ifHasRole` AND `onlyProp`。如果我们想创建一个 OR
    规则，我们只需创建一个新的规则。让我们试试这个：
- en: '[PRE19]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are stating that a user may `update` `ifLoggedIn` AND `ifHasRole` AND
    `onlyProp` OR never `insert`/`remove`.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们声明用户可以 `update` `ifLoggedIn` AND `ifHasRole` AND `onlyProp` 或永远不允许 `insert`/`remove`。
- en: 'The package comes with a handful of integrated functions to help in applying
    the rules:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 该包包含一些内置函数，有助于应用规则：
- en: '| Function | Use |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 用途 |'
- en: '| --- | --- |'
  id: totrans-124
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `never()` | This prevents DB operations |'
  id: totrans-125
  prefs: []
  type: TYPE_TB
  zh: '| `never()` | 这阻止数据库操作 |'
- en: '| `ifLoggedIn()` | This allows DB operations if logged in |'
  id: totrans-126
  prefs: []
  type: TYPE_TB
  zh: '| `ifLoggedIn()` | 如果用户已登录，则允许数据库操作 |'
- en: '| `ifHasUserId(<user-id>)` | This allows DB operations if user ID is a particular
    string |'
  id: totrans-127
  prefs: []
  type: TYPE_TB
  zh: '| `ifHasUserId(<用户ID>)` | 如果用户ID是特定字符串，则允许数据库操作 |'
- en: '| `ifHasRole(<role string>)``ifHasRole({role:<role string>,group:<group>})`
    | This allows DB operations if user belongs to a particular role |'
  id: totrans-128
  prefs: []
  type: TYPE_TB
  zh: '| `ifHasRole(<角色字符串>)` `ifHasRole({role:<角色字符串>,group:<组>})` | 如果用户属于特定角色，则允许数据库操作
    |'
- en: '| `onlyProps(<string or array of strings>)` | This allows DB operations on
    certain top-level fields only (this will not identify arrays and subobjects) |'
  id: totrans-129
  prefs: []
  type: TYPE_TB
  zh: '| `onlyProps(<字符串或字符串数组>)` | 这仅允许对某些顶级字段进行数据库操作（这不会识别数组和子对象） |'
- en: '| `exceptProps(<string or array of strings>)` | This allows DB operations on
    all top-level fields except these (this will not identify arrays and subobjects)
    |'
  id: totrans-130
  prefs: []
  type: TYPE_TB
  zh: '| `exceptProps(<字符串或字符串数组>)` | 这允许对除了这些之外的所有顶级字段进行数据库操作（这不会识别数组和子对象） |'
- en: Custom deny rules
  id: totrans-131
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自定义拒绝规则
- en: 'While the `security` package functions are useful, you may find yourself needing
    custom functions for more precise handling of your security. To build a custom
    function, you need to use the `Security.defineMethod` function:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `security` 包的函数很有用，但你可能需要自定义函数来更精确地处理你的安全。要构建自定义函数，你需要使用 `Security.defineMethod`
    函数：
- en: '[PRE20]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This function accepts two parameters: `transform` and `deny`. The `transform`
    function allows the modification of fields before they enter the `deny` function,
    while the `deny` function is an extended version of `Meteor.deny`. The `deny`
    function passes several arguments that include information about the document
    being modified and the user. These arguments are: `type`, `arguments`, `userId`,
    `document`, `fields`, and `modifier`. The last two arguments (`fields` and `modifier`)
    are only passed if `type` is equal to `update`.'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个参数：`transform` 和 `deny`。`transform` 函数允许在它们进入 `deny` 函数之前修改字段，而 `deny`
    函数是 `Meteor.deny` 的扩展版本。`deny` 函数传递多个参数，包括有关正在修改的文档和用户的信息。这些参数是：`type`、`arguments`、`userId`、`document`、`fields`
    和 `modifier`。最后两个参数（`fields` 和 `modifier`）仅在 `type` 等于 `update` 时传递。
- en: 'Let''s add a custom function:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个自定义函数：
- en: '[PRE21]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we are defining an `ifUserIsOwner` function that checks whether the ID
    of the currently logged in user is equal to the `user` field or the `_id` field
    on the modified document.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们定义了一个`ifUserIsOwner`函数，该函数检查当前登录用户的ID是否等于修改的文档上的`用户`字段或`_id`字段。
- en: Tip
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Notice that the logic of the rule denies a database operation if the user is
    not the owner of the document.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，规则逻辑拒绝非文档所有者的用户进行数据库操作。
- en: 'Now we can use this rule to secure our `users` collection:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用这个规则来保护我们的`用户`集合：
- en: '[PRE22]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Notice that we are attaching rules to the `Meteor.users` collection in a different
    way. We do this because the `Meteor.users` collection is a special collection
    that is initialized in a different way than the rest of our collections, with
    this we have ensured that the rules are properly attached.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们以不同的方式将规则附加到`Meteor.users`集合上。我们这样做是因为`Meteor.users`集合是一个特殊的集合，它的初始化方式与我们的其他集合不同，这样我们就确保了规则被正确附加。
- en: In this example, we are allowing our users freely to modify the `email` field
    from the console, and only the admin user can modify all users from the console.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们允许用户从控制台自由修改`电子邮件`字段，而只有管理员用户可以从控制台修改所有用户。
- en: 'However, now that we have locked the code from the client, how are we supposed
    to make things work? Running code directly from an event on the client will fail
    because the code is untrusted. We need to build a trusted code that will handle
    changes to the database. The solution is simple: Meteor methods.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在我们已经从客户端锁定代码，我们该如何使事情正常工作呢？直接从客户端的事件运行代码将会失败，因为代码是不可信的。我们需要构建一个可信的代码来处理对数据库的更改。解决方案很简单：Meteor方法。
- en: The Meteor methods – round 2
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Meteor方法 – 第二轮
- en: We have already covered how `Meteor.methods` work, but we have not discussed
    the difference between trusted and untrusted code.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经介绍了`Meteor.methods`的工作方式，但我们还没有讨论可信代码和不可信代码之间的区别。
- en: Trusted code can modify multiple documents at once by setting `multi` to `true`
    and can use an arbitrary Mongo selector to find the documents to modify. It bypasses
    any access control rules set up by allow and deny. Trusted code includes all server
    code and `Meteor.methods`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 可信代码可以通过将`multi`设置为`true`一次修改多个文档，并可以使用任意的Mongo选择器来查找要修改的文档。它绕过了由允许和拒绝设置的任何访问控制规则。可信代码包括所有服务器端代码和`Meteor.methods`。
- en: Untrusted code can modify only a single document at once that is specified by
    its `_id`. The modification is allowed only after checking any applicable allow
    and deny rules. Untrusted code cannot perform upserts. Untrusted code includes
    client code such as event handlers and the console.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 不可信代码一次只能修改一个指定的`_id`的单个文档。修改只有在检查了任何适用的允许和拒绝规则之后才允许。不可信代码不能执行更新插入操作。不可信代码包括客户端代码，如事件处理程序和控制台。
- en: This means that whenever we directly modify a collection on the client, we are
    running untrusted code that is limited by our deny rules. Knowing this, it becomes
    obvious that most code, especially complex code with relationships, should run
    on a Meteor method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着每次我们直接在客户端修改集合时，我们都在运行受限于我们的拒绝规则的不可信代码。了解这一点后，很明显，大多数代码，尤其是具有关系的复杂代码，应该在Meteor方法上运行。
- en: But wait. Can a user modify the code of the method on the client side? They
    most certainly can, but remember that the code runs in a stub. The stub makes
    sure that the correct code runs on the server, while the client-side code updates
    the collections temporarily until the server responds. This is what Meteor calls
    **Optimistic UI**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 但等等。用户能否在客户端修改方法的代码？他们当然可以，但请记住代码是在一个存根中运行的。存根确保正确的代码在服务器上运行，而客户端代码在服务器响应之前临时更新集合。这就是Meteor所说的**乐观UI**。
- en: So, if someone tampers with the client-side version of our Meteor method, the
    server-side version will still run normally and the UI will update correctly.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果有人篡改了我们Meteor方法的客户端版本，服务器端版本仍然会正常运行，UI也会正确更新。
- en: It's important to understand though that `Meteor.methods` will still be bound
    to the rules we had set on `Collection2`, which is a great feature inside a team
    environment where not everyone understands the structure of all data models.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 但重要的是要理解，`Meteor.methods`仍然绑定到我们在`Collection2`上设置的规则，这对于团队环境中的团队来说是一个很好的功能，因为不是每个人都了解所有数据模型的结构。
- en: So where should we use untrusted code? The answer depends greatly on your application,
    but for the most part, you will want everything to run on trusted code because
    it is easier to maintain and safer. Untrusted code should be used mostly to control
    things that the database is not connected to, or information that is allowed to
    be just about anything that the user wants.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 那么我们应该在哪里使用不受信任的代码？答案很大程度上取决于你的应用程序，但大部分情况下，你希望所有内容都在受信任的代码上运行，因为它更容易维护且更安全。不受信任的代码主要用于控制数据库未连接的事物，或允许用户几乎可以要求任何信息。
- en: 'In order to use `Meteor.methods` properly, we need to run validation on `Meteor.methods`
    as well. We do this using Meteor''s core `check` package. Let''s upgrade our `cart.add-to-cart`
    method:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确使用 `Meteor.methods`，我们需要对 `Meteor.methods` 进行验证。我们使用 Meteor 的核心 `check`
    包来完成此操作。让我们升级我们的 `cart.add-to-cart` 方法：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: First, we have used the `check` function to validate the structure of the `ops`
    object and to ensure that each key inside the object matches the correct type
    of data primitive. When the validation fails, the function will automatically
    stop and return a **404 Match Failed** error to the client.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用了 `check` 函数来验证 `ops` 对象的结构，并确保对象中的每个键都匹配正确的数据原语类型。当验证失败时，函数将自动停止并返回一个
    **404 Match Failed** 错误给客户端。
- en: Next, we have checked the status of the order. If the order is not new, then
    we throw a `Meteor.Error`. This will short circuit the function as well and return
    the `error` object to the client. When you are settings errors inside the Meteor
    methods, you will always use `throw new Meteor.Error(<error message>)` to communicate
    the error.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们检查了订单的状态。如果订单不是新的，则抛出 `Meteor.Error`。这将同样短路函数并返回 `error` 对象给客户端。当你设置 Meteor
    方法中的错误时，你将始终使用 `throw new Meteor.Error(<error message>)` 来传达错误。
- en: We do not need to worry about doing anything else with our errors. We will see
    how to keep track of our application errors in a different topic.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要担心对错误做任何事情。我们将在不同的主题中看到如何跟踪应用程序错误。
- en: 'The `check` function takes only two variables:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`check` 函数只接受两个变量：'
- en: '[PRE24]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The `value` parameter takes the variable that will be analyzed, while the `pattern`
    parameter takes the validator. The pattern can be as simple as a JavaScript primitive
    such as `String`, `Number`, and `Boolean`, an array of validators, an object of
    validators, or as complex as a function. The pattern simply needs to return `true`
    for the validation to pass.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`value` 参数接受将被分析的变量，而 `pattern` 参数接受验证器。模式可以是像 `String`、`Number` 和 `Boolean`
    这样的 JavaScript 原始类型，验证器的数组，验证器的对象，或者像函数一样复杂。模式只需返回 `true` 以使验证通过。'
- en: 'Meteor includes a handful of useful `pattern` functions through the `Match`
    object:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: Meteor 通过 `Match` 对象包含了一些有用的 `pattern` 函数：
- en: '| Pattern function | Use |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| 模式函数 | 使用 |'
- en: '| --- | --- |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `Match.Any()` | This allows any value to pass validation. |'
  id: totrans-165
  prefs: []
  type: TYPE_TB
  zh: '| `Match.Any()` | 这允许任何值通过验证。 |'
- en: '| `Match.Integer()` | This allows any 32-bit integer. `Infinity` and `NaN`
    are not allowed. |'
  id: totrans-166
  prefs: []
  type: TYPE_TB
  zh: '| `Match.Integer()` | 这允许任何 32 位整数。不允许 `Infinity` 和 `NaN`。 |'
- en: '| `Match.ObjectIncluding(<object>:<pattern>)` | This allows an object to include
    key/value pairs that are not defined in the object. The example that we used does
    not allow other key/value pairs from entering the method. |'
  id: totrans-167
  prefs: []
  type: TYPE_TB
  zh: '| `Match.ObjectIncluding(<object>:<pattern>)` | 这允许一个对象包含不在对象中定义的键/值对。我们使用的示例不允许其他键/值对进入方法。
    |'
- en: '| `Match.Optional(<second-pattern>)` | This allows a value to be `undefined`.
    If the value is defined, then the `second-pattern` will be evaluated instead.
    |'
  id: totrans-168
  prefs: []
  type: TYPE_TB
  zh: '| `Match.Optional(<second-pattern>)` | 这允许一个值可以是 `undefined`。如果值已定义，则将评估 `second-pattern`。
    |'
- en: '| `Match.OneOf(<pattern1>, <pattern2>,...)` | This allows a value to pass if
    it matches any of the defined patterns. |'
  id: totrans-169
  prefs: []
  type: TYPE_TB
  zh: '| `Match.OneOf(<pattern1>, <pattern2>,...)` | 这允许一个值通过如果它与定义的任何模式匹配。 |'
- en: '| `Match.Where(<function(value){}>)` | This runs `function` and passes the
    defined value as the first parameter. If the function returns `true`, then validation
    passes. |'
  id: totrans-170
  prefs: []
  type: TYPE_TB
  zh: '| `Match.Where(<function(value){}>)` | 这将运行 `function` 并将定义的值作为第一个参数传递。如果函数返回
    `true`，则验证通过。 |'
- en: Now this is all grand and makes us feel much more secure, but the fact of the
    matter is that we are sharing our server-side logic on the client. This means
    that we absolutely cannot include sensitive data inside a Meteor method. If we
    do want to pass sensitive data, it is best to store it in a server-side variable
    and call it, or if you want to go an extra mile, you can separate the client-side
    method from the server using folders.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在这一切都很棒，让我们感觉更加安全，但事实上，我们正在将服务器端逻辑共享到客户端。这意味着我们绝对不能在Meteor方法中包含敏感数据。如果我们想传递敏感数据，最好将其存储在服务器端变量中并调用它，或者如果您想走得更远，可以使用文件夹将客户端方法与服务器分离。
- en: Managing the wait time
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 管理等待时间
- en: The first chapter gave us a brief explanation of the impact that blocking can
    have on our client. To summarize this, if a function is waiting for a third-party
    or doing something that takes long, you should unblock the function. However,
    what impact can this have?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 第一章简要解释了阻止对客户端可能产生的影响。总结来说，如果一个函数正在等待第三方或执行耗时操作，你应该解除该函数的阻止。然而，这会产生什么影响呢？
- en: Remember that methods are placed on a conveyor belt. When we unblock a function,
    we place the method in a different conveyor belt where we cannot put other methods.
    This means that if another method depends on the unblocked method to complete,
    there can be a serious issue because the method can run before, during, or after
    the unblocked method.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，方法被放置在传送带上。当我们解除一个函数的阻止时，我们将方法放置在另一个传送带上，我们无法在其中放置其他方法。这意味着如果另一个方法依赖于解除阻止的方法来完成，可能会出现严重问题，因为该方法可以在解除阻止的方法之前、期间或之后运行。
- en: Notice that our `cart.add-to-cart` method does not have an unblock function.
    This is to make sure that the server adds items to the cart in the same order
    as the client. So what do we do if we have something inside the method that can
    be placed in a separate conveyor belt? Can there be something that can happen
    in parallel and the user does not have to wait to continue?
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们的`cart.add-to-cart`方法没有解除阻止的函数。这是为了保证服务器按照客户端的顺序将项目添加到购物车中。那么，如果我们方法内部有可以放在单独传送带上的内容，我们该怎么办？是否可以并行执行某些操作，而用户不必等待继续？
- en: '`Meteor.defer(<function>)` is a special, undocumented function that can take
    a particular snippet of code and run it in a separate conveyor without blocking
    the function from which it was called. Suppose we want to notify the admin every
    time a new order has been created, as shown here:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`Meteor.defer(<function>)`是一个特殊且未记录的函数，它可以接受一段特定的代码片段并在不阻止调用它的函数的情况下在单独的传送带上运行。假设我们想在每次创建新订单时通知管理员，如下所示：'
- en: '[PRE25]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In this example, we have wrapped the `Email.send` function in a `Meteor.defer`
    function to make the e-mail run in parallel. This benefits the performance of
    your code by running deferred functions in parallel and focusing on producing
    only the results that matter to the user. By doing this, we ensure that the e-mail,
    a process that we know takes a long time to finish, does not block the server
    as well.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将`Email.send`函数包裹在`Meteor.defer`函数中，以便并行运行电子邮件。通过并行运行延迟函数并专注于产生对用户真正重要的结果，这样做提高了代码的性能。通过这种方式，我们确保了电子邮件，一个我们知道需要很长时间才能完成的进程，不会阻塞服务器。
- en: Browser policy
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 浏览器策略
- en: 'Now that we can secure our collections and functions, we need to protect our
    application as a whole. We can achieve this protection using the `browser-policy`
    package. Let''s install it now:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够保护我们的集合和函数，我们需要保护整个应用程序。我们可以使用`browser-policy`包来实现这种保护。现在让我们安装它：
- en: '[PRE26]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: So what exactly does this package do? By adding this, we are opening an access
    to a series of configuration options that will help us to set our application
    headers and content security policies to protect from cross-site scripting and
    data injection attacks.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这个包究竟做了什么？通过添加这个包，我们打开了访问一系列配置选项的途径，这将帮助我们设置应用程序头和内容安全策略，以防止跨站脚本和数据注入攻击。
- en: These kinds of attacks are often used to steal your data (data theft), change
    the way your site looks (website defacement), and distribute malware. We definitely
    want to avoid all these attacks.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这类攻击通常被用来窃取您的数据（数据盗窃）、改变您网站的外观（网站篡改）以及分发恶意软件。我们肯定希望避免所有这些攻击。
- en: 'So how does this work? By adding the package, we have already protected our
    application against many attacks by default, but we need to be able to control
    this. To do this, the package exposes two objects each with a particular set of
    functions: `BrowserPolicy.framing` and `BrowserPolicy.content`. Both these functions
    must be set in the server.'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，这是如何工作的呢？通过添加包，我们默认已经保护了我们的应用程序免受许多攻击，但我们需要能够控制这一点。为此，该包公开了两个对象，每个对象都有特定的一组函数：`BrowserPolicy.framing`和`BrowserPolicy.content`。这两个函数都必须在服务器上设置。
- en: Framing
  id: totrans-185
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: 'With `BrowserPolicy.framing`, we can control whether our web application can
    be rendered inside an iframe or not. We have three functions to control this:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BrowserPolicy.framing`，我们可以控制我们的Web应用程序是否可以在iframe中渲染。我们有三个函数来控制这一点：
- en: '| Function | Use |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 用途 |'
- en: '| --- | --- |'
  id: totrans-188
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*.framing.disallow()` | This will never render in an iframe regardless of
    the origin. |'
  id: totrans-189
  prefs: []
  type: TYPE_TB
  zh: '| `*.framing.disallow()` | 这将永远不会在iframe中渲染，无论来源如何。 |'
- en: '| `*.framing.restrictToOrigin(origin)` | This will only render in iframes created
    by the specified origin. This may take only one `origin` string and may be called
    only once. Also, it is not fully supported in WebKit. |'
  id: totrans-190
  prefs: []
  type: TYPE_TB
  zh: '| `*.framing.restrictToOrigin(origin)` | 这将仅在由指定来源创建的iframe中渲染。这可能只需要一个`origin`字符串，并且只能调用一次。此外，它在WebKit中并不完全受支持。
    |'
- en: '| `*framing.allowAll()` | This will render in any iframe. |'
  id: totrans-191
  prefs: []
  type: TYPE_TB
  zh: '| `*framing.allowAll()` | 这将在任何iframe中渲染。 |'
- en: You will find yourself using `BrowserPolicy.framing.disallow()` most of the
    time, but it is important to understand that you will still be able to iframe
    your app if origins are the same.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现自己在大多数情况下使用`BrowserPolicy.framing.disallow()`，但重要的是要理解，如果来源相同，你仍然可以将你的应用程序iframe化。
- en: Content
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容
- en: 'With `BrowserPolicy.content`, we can control exactly how the content will be
    loaded into our web application. We have many functions for this. However, we
    will actually end up using only a few. The functions are:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`BrowserPolicy.content`，我们可以精确控制内容将如何加载到我们的Web应用程序中。我们为此有很多函数。然而，我们实际上最终只会使用其中的一些。这些函数是：
- en: '| Function | Use |'
  id: totrans-195
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 用途 |'
- en: '| --- | --- |'
  id: totrans-196
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*.content.allowInlineScripts()` | This allows DOM script tags to run.`DEFAULT`.
    |'
  id: totrans-197
  prefs: []
  type: TYPE_TB
  zh: '| `*.content.allowInlineScripts()` | 这允许DOM脚本标签运行。`DEFAULT`。 |'
- en: '| `*.content.disallowInlineScripts()` | This does not allow DOM script tags
    to run. |'
  id: totrans-198
  prefs: []
  type: TYPE_TB
  zh: '| `*.content.disallowInlineScripts()` | 这不允许DOM脚本标签运行。 |'
- en: '| `*.content.allowEval()` | This allows the building of JavaScript from strings
    by using the `eval` function. |'
  id: totrans-199
  prefs: []
  type: TYPE_TB
  zh: '| `*.content.allowEval()` | 这允许通过使用`eval`函数从字符串构建JavaScript。 |'
- en: '| `*.content.disallowEval()` | This does not allow the building of JavaScript
    from strings by using the `eval` function.`DEFAULT`. |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '| `*.content.disallowEval()` | 这不允许通过使用`eval`函数从字符串构建JavaScript。`DEFAULT`。
    |'
- en: '| `*.content.allowInlineStyles()` | This allows inline styles and style DOM
    elements to run.`DEFAULT`. |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| `*.content.allowInlineStyles()` | 这允许内联样式和样式DOM元素运行。`DEFAULT`。 |'
- en: '| `*.content.disallowInlineStyles()` | This does not allow inline styles and
    style DOM elements to run. |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| `*.content.disallowInlineStyles()` | 这不允许内联样式和样式DOM元素运行。 |'
- en: 'There are more! The next set of functions defines a white-list of content types
    and how they are allowed to load. `ContentType` can take the value of: `Script`,
    `Object`, `Image`, `Media`, `Font`, `Frame`, and `Connect`.'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 还有更多！下一组函数定义了内容类型的白名单以及它们如何被允许加载。`ContentType`可以取以下值：`Script`、`Object`、`Image`、`Media`、`Font`、`Frame`和`Connect`。
- en: '| Function | Use |'
  id: totrans-204
  prefs: []
  type: TYPE_TB
  zh: '| 函数 | 用途 |'
- en: '| --- | --- |'
  id: totrans-205
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `*.allow<ContentType>Origin(origin)``*.allowScriptOrigin(origin)``*.allowObjectOrigin(origin)``*.allowImageOrigin(origin)``*.allowMediaOrigin(origin)``*.allowFontOrigin(origin)``*.allowFrameOrigin(origin)``*.allowConnectOrigin(origin)`
    | This allows the `ContentType` to be loaded from the `origin` string. This function
    can be called multiple times and has a support for wildcards. If a protocol (`http`
    / `https`) is not specified, then BOTH are allowed. |'
  id: totrans-206
  prefs: []
  type: TYPE_TB
  zh: '| `*.allow<ContentType>Origin(origin)``*.allowScriptOrigin(origin)``*.allowObjectOrigin(origin)``*.allowImageOrigin(origin)``*.allowMediaOrigin(origin)``*.allowFontOrigin(origin)``*.allowFrameOrigin(origin)``*.allowConnectOrigin(origin)`
    | 这允许从`origin`字符串加载`ContentType`。此函数可以多次调用，并支持通配符。如果没有指定协议（`http` / `https`），则两者都允许。
    |'
- en: '| `*.allow<ContentType>DataUrl()` | This allows the `ContentType` to be loaded
    from a `data:` URL. This will allow base64-encoded images to render. |'
  id: totrans-207
  prefs: []
  type: TYPE_TB
  zh: '| `*.allow<ContentType>DataUrl()` | 这允许从`data:` URL加载`ContentType`。这将允许以base64编码的图像渲染。
    |'
- en: '| `*.allow<ContentType>SameOrigin()` | This allows the `ContentType` to be
    loaded from the same origin as the webapp. |'
  id: totrans-208
  prefs: []
  type: TYPE_TB
  zh: '| `*.allow<ContentType>SameOrigin()` | 这允许从与Web应用程序相同的来源加载`ContentType`。 |'
- en: '| `*.disallow<ContentType>()` | This does not allow `ContentType` to be loaded.
    |'
  id: totrans-209
  prefs: []
  type: TYPE_TB
  zh: '| `*.disallow<ContentType>()` | 这不允许加载 `ContentType`。 |'
- en: '| `*.allowSameOriginForAll()` | This allows all types of content to be loaded
    from the same origin as the webapp. |'
  id: totrans-210
  prefs: []
  type: TYPE_TB
  zh: '| `*.allowSameOriginForAll()` | 这允许从与webapp相同的源加载所有类型的内容。 |'
- en: '| `*.allowDataUrlForAll()` | This allows all types of content to be loaded
    from a `data:` URL. |'
  id: totrans-211
  prefs: []
  type: TYPE_TB
  zh: '| `*.allowDataUrlForAll()` | 这允许从 `data:` URL加载所有类型的内容。 |'
- en: '| `*.allowOriginForAll(origin)` | This allows all types of content to be loaded
    from the specified `origin`. |'
  id: totrans-212
  prefs: []
  type: TYPE_TB
  zh: '| `*.allowOriginForAll(origin)` | 这允许从指定的 `origin` 加载所有类型的内容。 |'
- en: '| `*.disallowAll()` | This does not allow any type of content to be loaded
    from anywhere. |'
  id: totrans-213
  prefs: []
  type: TYPE_TB
  zh: '| `*.disallowAll()` | 这不允许从任何地方加载任何类型的内容。 |'
- en: 'Depending on what we want our application to achieve, we may have to tweak
    our rules. Let''s configure our security policy to the recommended options:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 根据我们想要我们的应用程序实现的目标，我们可能需要调整我们的规则。让我们将我们的安全策略配置为推荐选项：
- en: '[PRE27]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: External APIs
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 外部API
- en: 'Now that we know how to secure our application, we need to understand how to
    keep external data sources up to date. There are two patterns that we can use
    to ensure that the information on our server is recent: **synchronization** and
    **webhooks**.'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们知道了如何保护我们的应用程序，我们需要了解如何保持外部数据源是最新的。我们可以使用两种模式来确保我们服务器上的信息是最新的：**同步**和**webhooks**。
- en: Synchronization
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 同步
- en: Synchronization will, basically, get data from our source continuously and refresh
    the database. This type of technique is useful when we need to save information
    from our data source and use that information to produce analytical data via the
    aggregation framework.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 同步基本上会从我们的数据源持续获取数据并刷新数据库。这种技术在我们需要从数据源保存信息并使用这些信息通过聚合框架生成分析数据时非常有用。
- en: To keep our servers synchronized, we need to make sure that the process that
    fetches information does not block the server. We can ensure that this happens
    using nonblocking functions like `Meteor.setInterval`.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 为了保持我们的服务器同步，我们需要确保获取信息的进程不会阻塞服务器。我们可以使用非阻塞函数，如 `Meteor.setInterval` 来确保这一点。
- en: 'Let''s synchronize with Stripe. First, we will need to create a collection
    to capture payments, then we will have to set permissions and our Stripe secret,
    and finally, we will build the HTTP `GET` function:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们与Stripe进行同步。首先，我们需要创建一个集合来捕获支付，然后我们必须设置权限和我们的Stripe密钥，最后，我们将构建HTTP `GET`
    函数：
- en: '[PRE28]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Notice that when we created our collection, we did not give it a schema. We
    did this because we wanted to make sure that our collection is flexible in case
    the data from our endpoint changes. To secure our collection, we need to make
    sure that nobody can modify this in any way except for trusted code. Then we have
    created a configuration object that is going to hold our Stripe secret and public
    key.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当我们创建我们的集合时，我们没有给它一个模式。我们这样做是因为我们想要确保我们的集合在端点数据发生变化时具有灵活性。为了保护我们的集合，我们需要确保没有人能够以任何方式修改它，除非是受信任的代码。然后我们创建了一个配置对象，它将保存我们的Stripe密钥和公钥。
- en: Also, we have created a `/stripe/server/payments.coffee` directory. Here, we
    have added the `get_payments` function to the `Stripe` object that we had defined
    in our _`globals` directory. To have this work properly, we had to pass a `params`
    object to control the way we are requesting data from Stripe's servers. Expect
    to pass `params` for every `GET` request you build since this controls the endpoints'
    `pagination`. Stripe explains in their documentation that we can get the next
    page of data by first checking whether there is more data via the `has_more` key
    and then passing in the last object ID from which to start via the `starting_after`
    parameter.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还创建了一个 `/stripe/server/payments.coffee` 目录。在这里，我们将 `get_payments` 函数添加到了我们在
    `_` `globals` 目录中定义的 `Stripe` 对象。为了使这正常工作，我们必须传递一个 `params` 对象来控制我们从Stripe服务器请求数据的方式。预期在构建每个
    `GET` 请求时都会传递 `params`，因为这将控制端点的 `分页`。Stripe在其文档中解释说，我们可以通过首先检查是否存在更多数据（通过 `has_more`
    键）然后通过 `starting_after` 参数传递最后一个对象ID来获取数据的下一页。
- en: At the end of this all, we have used the `Meteor.setInterval(<function>,<delay
    in milliseconds>)` function to make sure that the function runs every hour. Are
    we done yet? Not quite. While this code will definitely populate our `Payments`
    collection, it could potentially crash our server as well. Why? The request always
    queries from the beginning of time up to today, which makes the server progressively
    take longer. Another important issue is that if there is one `GET` request being
    processed and it has not finished within the hour, another request could start
    in parallel and consume even more resources.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一切结束时，我们使用了`Meteor.setInterval(<function>,<delay in milliseconds>)`函数来确保函数每小时运行一次。我们完成了吗？还没有。虽然这段代码确实会填充我们的`Payments`集合，但它也可能导致我们的服务器崩溃。为什么？请求总是从时间的开始查询到今天，这使得服务器逐渐花费更长的时间。另一个重要的问题是，如果有一个`GET`请求正在处理，并且在一小时内没有完成，另一个请求可能会并行开始，消耗更多的资源。
- en: We can prevent this by controlling our intervals and limiting the time frame
    our interval uses to get the data.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过控制我们的间隔和限制间隔获取数据的时间范围来防止这种情况。
- en: 'First, let''s make sure that we only have one interval running at a time:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们确保一次只有一个间隔在运行：
- en: '[PRE29]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Notice that we are keeping payments together under a `payments` object now.
    Then we have simply set and checked a `is_running` Boolean key to see whether
    the process is running or not. Now if we were to reduce the interval to 1 millisecond,
    it would only GET from the external API after the previous request is done processing.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们现在将支付一起放在一个`payments`对象下。然后我们简单地设置并检查了一个`is_running`布尔键，以查看该过程是否正在运行。现在，如果我们把间隔减少到1毫秒，它将在前一个请求处理完毕后才会从外部API获取数据。
- en: 'Now, we can use the `starting_after` parameter to ensure that we only get the
    latest information. To do this, we will have to use the `moment` function to filter
    data by time and get the latest payment information:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用`starting_after`参数来确保我们只获取最新的信息。为此，我们必须使用`moment`函数按时间过滤数据，并获取最新的支付信息：
- en: '[PRE30]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this example, we have simply used `moment` to identify a Unix timestamp from
    10 days ago. The `moment` object is made available using the `momentjs:moment`
    package. Notice that we are using the `utc()` function to set `startOf("day")`
    consistently between our development and production environments. Then we have
    queried the server, and if the payment exists, we will use the ID of the payment
    as our `starting_after` parameter.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们只是使用`moment`来识别10天前的Unix时间戳。`moment`对象是通过`momentjs:moment`包提供的。请注意，我们正在使用`utc()`函数来在开发和生产环境中一致地设置`startOf("day")`。然后我们查询了服务器，如果支付存在，我们将使用支付ID作为我们的`starting_after`参数。
- en: It is important to understand that we can make this query easily only because
    the information that Stripe sends includes a Unix timestamp. Not every API has
    a Unix timestamp. Most likely, you will end up inserting or transforming their
    data to fit your own. This can be easily addressed by extending their response
    when needed.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要理解，我们之所以能够轻松地进行此查询，仅仅是因为Stripe发送的信息中包含Unix时间戳。并非每个API都有Unix时间戳。很可能会让你插入或转换他们的数据以适应自己的需求。这可以通过在需要时扩展他们的响应来解决。
- en: Webhooks
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Webhooks
- en: Webhooks are the way through which other servers can communicate directly with
    ours. They, basically, make a `POST` request to one of our endpoints to inform
    our server that something has happened.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: Webhooks是通过其他服务器直接与我们通信的方式。它们基本上会向我们的一个端点发送一个`POST`请求，通知我们的服务器发生了某些事情。
- en: In the case of Stripe, we are going to add an endpoint that will catch all of
    Stripe's charge webhooks. To do this, we will use the `nimble:restivus` package.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 在Stripe的情况下，我们将添加一个端点来捕获Stripe的所有收费webhooks。为此，我们将使用`nimble:restivus`包。
- en: '`Restivus` is an excellent package that makes it easy to maintain a RESTful
    API with version control and user authentication. It runs only on the server side
    for security.'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: '`Restivus`是一个优秀的包，它使得维护带有版本控制和用户认证的RESTful API变得容易。它只在服务器端运行，以确保安全性。'
- en: 'First, we need to create an instance of `Restivus`. This instance will hold
    the routes for the first version of our endpoint:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个`Restivus`的实例。这个实例将持有我们端点的第一个版本的路线：
- en: '[PRE31]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Here, we have attached our new server-side endpoint to the global `Stripe`
    object under the `hooks` and `v1` keys. This will make it easy to create new routes
    for version 1 anywhere in our server. The `Restivus` instance takes in a handful
    of parameters, the ones that you will end up using the most are:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将我们的新服务器端端点附加到全局`Stripe`对象下的`hooks`和`v1`键下。这将使得在服务器中的任何位置创建版本1的新路由变得容易。`Restivus`实例接受一些参数，你最终会用到的最常见参数包括：
- en: '| Parameter | Use |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 使用 |'
- en: '| --- | --- |'
  id: totrans-242
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `apiPath` | String defines the parent route of all the endpoints. If we define
    `apiPath` as `"stripe"` and a route as `"charge"`, then the path for the route
    will be `ROOT_URL/stripe/charge`. |'
  id: totrans-243
  prefs: []
  type: TYPE_TB
  zh: '| `apiPath` | 字符串定义了所有端点的父路由。如果我们定义`apiPath`为`"stripe"`，并且一个路由为`"charge"`，那么该路由的路径将是`ROOT_URL/stripe/charge`。|'
- en: '| `version` | String defines the version number of the API and adds it to the
    parent route. If we define `version` as `"v1"`, then all the routes will take
    this form: `ROOT_URL/<apiPath>/v1/<route>`. |'
  id: totrans-244
  prefs: []
  type: TYPE_TB
  zh: '| `version` | 字符串定义API的版本号并将其添加到父路由。如果我们定义`version`为`"v1"`，那么所有路由都将采用以下形式：`ROOT_URL/<apiPath>/v1/<route>`。|'
- en: '| `enableCors` | Boolean sets whether the route is accessible from external
    domains. Default: `true`. |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
  zh: '| `enableCors` | 布尔值设置路由是否可以从外部域名访问。默认：`true`。|'
- en: 'Now let''s create an endpoint that updates the `Payments` collection. To create
    an endpoint, we need to define a route on our `Restivus` instance. To do this,
    we simply call the global object that we had defined and use the `addRoute` function:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们创建一个更新`Payments`集合的端点。要创建一个端点，我们需要在`Restivus`实例上定义一个路由。为此，我们只需调用我们定义的全局对象并使用`addRoute`函数：
- en: '[PRE32]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Now our endpoint can catch Stripe's webhook notifications. Notice that the information
    that the `POST` request contains is located in the `@request.body` object. After
    analyzing this object, we can see that the object that Stripe is sending. In this
    case, Stripe sends an object with a `data` key, which in turn contains an `object`
    key that holds the information of the payment. If you want to see the information
    that Stripe is responding with, simply log in to the console.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的端点可以捕获Stripe的webhook通知。注意，`POST`请求中包含的信息位于`@request.body`对象中。在分析此对象后，我们可以看到Stripe发送的对象。在这种情况下，Stripe发送一个包含`data`键的对象，该键又包含一个`object`键，它包含支付信息。如果你想看到Stripe响应的信息，只需在控制台中登录即可。
- en: Also, we are returning a `@done()` function, which notifies Stripe that the
    request was processed. This makes sure that Stripe does not have to make a second
    attempt to notify our server.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们正在返回一个`@done()`函数，该函数通知Stripe请求已被处理。这确保Stripe不需要再次尝试通知我们的服务器。
- en: 'The `addRoute` function can handle all types of HTTP requests including `get`,
    `put`, `delete`, `patch`, and `options`. The endpoints have these variables in
    their context to help handle requests:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: '`addRoute`函数可以处理所有类型的HTTP请求，包括`get`、`put`、`delete`、`patch`和`options`。端点在其上下文中包含这些变量以帮助处理请求：'
- en: '| Context variable | Use |'
  id: totrans-251
  prefs: []
  type: TYPE_TB
  zh: '| 上下文变量 | 使用 |'
- en: '| --- | --- |'
  id: totrans-252
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `this.user` | The `Meteor.user` object after authentication passes. |'
  id: totrans-253
  prefs: []
  type: TYPE_TB
  zh: '| `this.user` | 认证通过后的`Meteor.user`对象。|'
- en: '| `this.userId` | The `Meteor.userId` string after authentication passes. |'
  id: totrans-254
  prefs: []
  type: TYPE_TB
  zh: '| `this.userId` | 认证通过后的`Meteor.userId`字符串。|'
- en: '| `this.urlParams` | Parameters defined in the URL string:`ROOT_URL/stripe/v1/charge/:more`To
    access the `more` parameter, you would call `@urlParams.more`. |'
  id: totrans-255
  prefs: []
  type: TYPE_TB
  zh: '| `this.urlParams` | 在URL字符串中定义的参数:`ROOT_URL/stripe/v1/charge/:more`要访问`more`参数，你需要调用`@urlParams.more`。|'
- en: '| `this.queryParams` | Query parameters defined in the URL string:`ROOT_URL/stripe/v1/charge?more=data`To
    access the `more` parameter, you would call `@urlQueryParams.more`. |'
  id: totrans-256
  prefs: []
  type: TYPE_TB
  zh: '| `this.queryParams` | 在URL字符串中定义的查询参数:`ROOT_URL/stripe/v1/charge?more=data`要访问`more`参数，你需要调用`@urlQueryParams.more`。|'
- en: '| `this.bodyParams` | The body of the request. This is the equivalent to `@request.body`.
    |'
  id: totrans-257
  prefs: []
  type: TYPE_TB
  zh: '| `this.bodyParams` | 请求的主体。这相当于`@request.body`。|'
- en: '| `this.request` | A NodeJS request object. |'
  id: totrans-258
  prefs: []
  type: TYPE_TB
  zh: '| `this.request` | 一个NodeJS请求对象。|'
- en: '| `this.response` | A NodeJS response object. |'
  id: totrans-259
  prefs: []
  type: TYPE_TB
  zh: '| `this.response` | 一个NodeJS响应对象。|'
- en: '| `this.done()` | This function must be called after handling a response. |'
  id: totrans-260
  prefs: []
  type: TYPE_TB
  zh: '| `this.done()` | 在处理响应后必须调用此函数。|'
- en: Now, we can set up webhooks from Stripe by going to their settings page and
    creating a webhook. Make sure to point their URL to the one that we built.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以通过访问Stripe的设置页面并创建一个webhook来设置Stripe的webhooks。确保将它们的URL指向我们构建的URL。
- en: '![Webhooks](img/00002.jpeg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![Webhooks](img/00002.jpeg)'
- en: We can send a couple of test hooks, too, to make sure that everything works
    as intended. By using both the synchronization pattern and the webhooks pattern,
    we are able to keep our data up to date. You should always use both patterns if
    the API allows you to. Why? This is because their webhooks server could potentially
    fail.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们也可以发送几个测试钩子，以确保一切按预期工作。通过使用同步模式和webhooks模式，我们能够保持我们的数据是最新的。如果API允许，你应该始终使用这两种模式。为什么？这是因为他们的webhooks服务器可能会失败。
- en: Summary
  id: totrans-264
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'This chapter covered three important things: how to control the amount of data
    that we publish, how to secure our app, and how to better integrate with an external
    API. We learned a pattern to build pagination that functions with filters as well.
    Then we learned how to build user roles and schemas to secure access to our application
    better. Next, we understood the limitations of allow/deny rules and addressed
    these limitations by writing effective deny rules. We quickly realized these deny
    rules were blocking functions from all the event handlers because they are insecure.
    To get around this limitation, we learned how to build trusted code. Towards the
    end, integrating Stripe taught us how to create a nonblocking synchronization
    function and how to use `restivus` to catch incoming messages from external servers.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 本章涵盖了三个重要内容：如何控制我们发布的数据量，如何保护我们的应用，以及如何更好地与外部API集成。我们学习了一种构建具有过滤功能的分页模式。然后我们学习了如何构建用户角色和模式以更好地保护我们的应用程序的访问。接下来，我们了解了允许/拒绝规则的限制，并通过编写有效的拒绝规则来解决这些限制。我们很快意识到这些拒绝规则因为不安全而阻止了所有事件处理程序的功能。为了克服这一限制，我们学习了如何构建可信代码。在最后，集成Stripe教会了我们如何创建非阻塞的同步函数，以及如何使用`restivus`来捕获来自外部服务器的传入消息。
- en: The next chapter is going to cover the basics of how to test and maintain our
    code. With the next chapter, we will be able to share our code without fearing
    that someone else will break it.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将介绍如何测试和维护我们的代码的基础知识。有了下一章，我们就可以分享我们的代码，而不用担心其他人会破坏它。
