<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Working with Events, Sync, and Storage"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Working with Events, Sync, and Storage</h1></div></div></div><p>In the previous chapters, we discussed each Backbone component (view, model, collection, and router) separately and in detail. In this chapter, we are going to talk about the custom events, <code class="literal">Backbone.sync()</code> method and <code class="literal">Backbone.LocalStorage</code>. Though these topics are not exactly related to each other, we placed them in a single chapter as we need to cover each one of them before we move on to application architecture and patterns in the next chapter.</p><p>Events are always considered as one of the most powerful concepts in JavaScript. They are a representation of the observer pattern (a well-known design pattern for loose coupling) and are used by most JavaScript libraries. In Backbone, <code class="literal">Backbone.Events</code> is a nontrivial module that can be used with any object to have event-related functionality. This is how <code class="literal">Backbone.Events</code> is defined in the Backbone documentation (<a class="ulink" href="http://backbonejs.org/#Events">http://backbonejs.org/#Events</a>):</p><div class="blockquote"><blockquote class="blockquote"><p>Event is a module that can be mixed in to any object, giving the object the ability to bind and trigger custom named events.</p></blockquote></div><p>In this chapter, we will discuss why events are important for Backbone application development and how we can use them to achieve higher reusability and a more structured application architecture. The main topics to be covered in this chapter are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Custom events</strong></span>: Custom events<a id="id215" class="indexterm"/> are initialized by an application for a certain purpose that is not served by the base library we are using. We will learn how to create and use custom events in Backbone.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Event dispatcher</strong></span>: Sometimes,<a id="id216" class="indexterm"/> we seek an application-level event manager that can work as the centralized tool for event-based communication. Different components of the application can interact with each other via this event manager, without directly communicating among themselves. In this section, we will learn how to create and use such an event dispatcher with our application.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Method overriding</strong></span>: In this topic, we will learn how overriding the <code class="literal">sync()</code> method of Backbone lets us create different persistent strategies for public REST APIs or <code class="literal">LocalStorage</code>.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Offline storage</strong></span>: The <code class="literal">Backbone.LocalStorage</code> adapter can be used with any Backbone model or collection to save the data onto a <code class="literal">LocalStorage</code> database.</li></ul></div><div class="section" title="Understanding custom events"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec35"/>Understanding custom events</h1></div></div></div><p>Creating and<a id="id217" class="indexterm"/> using custom events are not a big deal in JavaScript—all of the <a id="id218" class="indexterm"/>major JavaScript libraries heavily depend on their own events to make their components loosely coupled. Each component possesses a set of custom events for better reusability and integration with the application.</p><p>Creating a <a id="id219" class="indexterm"/>custom event in Backbone is quite simple—any object that extends the <code class="literal">Backbone.Events</code> class gets all of the event-related functionality, that is, listening to, triggering, and removing events. Backbone's <code class="literal">View</code>, <code class="literal">Model</code>, <code class="literal">Collection</code>, and <code class="literal">Router</code> are the major components that extend the <code class="literal">Backbone.Events</code> class<a id="id220" class="indexterm"/>, and you can fire a custom event on any one of them when needed:</p><div class="informalexample"><pre class="programlisting">var myView = new Backbone.View();
myView.on('myevent', function () {
  console.log('"myevent" is fired');
});

myView.trigger('myevent');</pre></div><p>Here we create a Backbone view instance, register a custom event to it, and fire the event. Once the event is fired, the registered function runs immediately as expected.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>
<span class="strong"><strong>Avoid callbacks, use custom events</strong></span>
</p><p>This heading doesn't imply that you should always use events instead of callback methods. It depends on what the coder intends to achieve, it's absolutely an architectural choice. We intend to discuss this point to understand the cases in which events give much more flexibility than callbacks. Whenever there is a scenario when you need to notify others about a certain condition of any task, you will find that a custom event is a better choice than a callback function. Beginner-level developers often fall into this trap and end up using a callback method, which generally provides a more private and isolated approach.</p></div></div><p>In the following section, we will demonstrate the necessity of custom events with a simple example.</p><div class="section" title="A simple case study on custom events"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec39"/>A simple case study on custom events</h2></div></div></div><p>Assume <a id="id221" class="indexterm"/>we have a <code class="literal">Login</code> dialog box, and once the user inputs the username-password combination and clicks on the <span class="strong"><strong>Submit</strong></span> button, a request is sent to the server to validate the login. On successful validation, the user closes the dialog box and does some other tasks, such as storing cookies, changing the page title, and so on. In such a case, we generally use a callback method and place all the post-login functionality in it. What if there are 10 different functions each to be called on separate objects once the login is successful? You may need all of these object references within that callback method to call the methods one by one. While this can be achieved without any issue, why not just fire a custom event <code class="literal">loggedin</code> once the user login is successful? The 10 objects that are already listening to the <code class="literal">loggedin</code> event can then call the related methods accordingly:</p><div class="informalexample"><pre class="programlisting">var Login = Backbone.View.extend({
  'click #login-btn': 'doLogin',
  doLogin: function () {
    var me = this;

    // send a login request
    $.ajax({
      url: '/login',
      method: 'POST',
      data: {
        username: 'foo',
        password: 'foo'
      },
      success: function (response) {
        me.trigger('loggedin', response);
      }
    });
  }
});

var loginView = new Login();
login.doLogin();</pre></div><p>The other components that need to do those post-login tasks should already be listening to the <code class="literal">loggedin</code> event of that <code class="literal">loginView</code>, and the callback function will execute as soon as the event is fired:</p><div class="informalexample"><pre class="programlisting">// in some other component
loginView.on('loggedin', function(response){
  // Do something
});</pre></div><p>You can<a id="id222" class="indexterm"/> pass some parameters while triggering the event too; this data will be available in the event callback method as arguments:</p><div class="informalexample"><pre class="programlisting">// Pass multiple data
me.trigger('loggedin', response, 'foo', 'bar');

// All the passed params will be available as function arguments
loginView.on('loggedin', function(response, foo, bar){
  console.log(response, foo, bar);
});</pre></div></div></div></div>
<div class="section" title="Using an event dispatcher"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec36"/>Using an event dispatcher</h1></div></div></div><p>Notice one<a id="id223" class="indexterm"/> thing in the previous scenario: to listen to the <code class="literal">loggedin</code> event<a id="id224" class="indexterm"/>, all <a id="id225" class="indexterm"/>the other components of the application should have a reference to that <code class="literal">loginView</code>. Is this really required? It may seem to a few components that keeping a reference to <code class="literal">loginView</code> is irrelevant, but they have to do so because they need to listen to the <code class="literal">loggedin</code> event on this <code class="literal">loginView</code> object. Dependency injection in such a way can be painful even when you are developing a simple application. Sometimes we may need a common object that will play the role of a central event manager and can be used throughout the application to trigger and listen to events. The simplest event dispatcher can be defined in the following way:</p><div class="informalexample"><pre class="programlisting">var vent = _.extend({}, Backbone.Events);

// Listen to a custom event
vent.on('customevent', function(){
  console.log('Custom event fired');
});

// Fire the event
vent.trigger('customevent');</pre></div><p>When we make the <code class="literal">vent</code> variable available at the application-level, it can work as a centralized event dispatcher to publish and subscribe to events. This pattern is called PubSub pattern and is quite beneficial for use in a module- or widget-based application architecture.</p><div class="tip" title="Tip" style=""><div class="inner"><h3 class="title"><a id="tip10"/>Tip</h3><p>You should understand the context where this will be a good choice. An event dispatcher should be used when you either have too many components to listen to (as we saw in the case of the login example) or when you have some completely unrelated objects that need to communicate with each other.</p></div></div><p>The main problem that you may face while working with a common event dispatcher is that the number of publishers and subscribers may get out of control when too many events<a id="id226" class="indexterm"/> are registered through a single event dispatcher. For example, say we have two modules, <code class="literal">User</code> and <code class="literal">Company</code>, and both the modules are subscribed to an event named <code class="literal">addcomment</code> on the event dispatcher separately; they are defined as follows:</p><div class="informalexample"><pre class="programlisting">vent.on('addcomment', user.addComment);
vent.on('addcomment', company.addComment);</pre></div><p>Notice that the event name is the same, but the functions to be called are different. So, if you want another subscriber to be notified for the same event, you need to clear up all the other subscribers of that event first and then publish the event. However, there are a few other simple solutions to this issue, such as creating multiple event dispatchers or using different event namespaces.</p><div class="section" title="Creating multiple event dispatchers"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec40"/>Creating multiple event dispatchers</h2></div></div></div><p>Defining a <a id="id227" class="indexterm"/>separate event dispatcher for individual modules<a id="id228" class="indexterm"/> or functionality can provide a solution to the problem we described previously:</p><div class="informalexample"><pre class="programlisting">App.userVent = _.extend({}, Backbone.Events);
App.documentVent = extend({}, Backbone.Events);</pre></div><p>Now, the same event names for different dispatchers will never clash:</p><div class="informalexample"><pre class="programlisting">App.userVent.on('addcomment', user.addComment);
App.documentVent.on('addcomment', company.addComment);</pre></div></div><div class="section" title="Using different event namespaces"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec41"/>Using different event namespaces</h2></div></div></div><p>This is as<a id="id229" class="indexterm"/> simple as following a specific naming convention while using custom events:</p><div class="informalexample"><pre class="programlisting">App.vent.trigger('before:login');
App.vent.trigger('after:login');
App.vent.trigger('user:add:comment');</pre></div><p>Adding a colon in the event name doesn't make the event special, but makes it different and unique because it now relates to some specific modules of the application. This is a convention heavily used by JavaScript developers and we encourage you to use it whenever required.</p></div></div>
<div class="section" title="Avoiding memory leaks with the listenTo() method"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec37"/>Avoiding memory leaks with the listenTo() method</h1></div></div></div><p>Memory management<a id="id230" class="indexterm"/> is a very important part of any application. Generally, for frontend development, developers do not bother much about memory leaks; <a id="id231" class="indexterm"/>however,<a id="id232" class="indexterm"/> this doesn't hold true when we develop<a id="id233" class="indexterm"/> single page frontend-heavy applications. These types of applications deal with many frontend components and the lowest number of page refreshes, which can create several opportunities for memory leaks. While developing such applications, we should always be careful to clean up events when an object is destroyed. To understand this with an example, assume we have a view that displays its model's data. The <code class="literal">render()</code> method of the view is called whenever the <code class="literal">change</code> event is fired on that model:</p><div class="informalexample"><pre class="programlisting">// Memory leak
var MyView = Backbone.View.extend({
  tpl: '&lt;%= name %&gt;',
  model: new Backbone.Model({
    name: 'Suramya'
  }),

  initialize: function () {
    this.model.on('change', this.render, this);
  },

  render: function () {
    var html = _.template(this.tpl, this.model.toJSON());
    this.$el.html(html);
    return this;  
  }
});

var myView = new MyView();
$(document.body).append(myView.render().el);

myView.model.set('name', 'Arup');
myView.remove();</pre></div><p>Now, as you can see, we registered a <code class="literal">change</code> event on the model so that whenever any of its attributes change, the <code class="literal">render</code> method will be called. Then we created an instance of the view, changed the <code class="literal">name</code> attribute of the model, and destroyed the view. The <code class="literal">remove()</code> method<a id="id234" class="indexterm"/> destroys the <code class="literal">view</code> instance and removes the view from the DOM.</p><p>The whole process works as expected, though with a slight problem. When you create a view in JavaScript, you create DOM nodes and bind event listeners to them. When you remove nodes from the DOM, their event listeners hold references to them. As a result, your JavaScript engine will not automatically garbage collect the nodes as there are still references to them in the scope. In our case too, even if the view is destroyed, the <code class="literal">change</code> event listener on<a id="id235" class="indexterm"/> the model persists and we need to take care of it explicitly. How can we do this? We can add a <code class="literal">close()</code> method<a id="id236" class="indexterm"/> to the view and unbind all such events in this method before destroying the view:</p><div class="informalexample"><pre class="programlisting">close: function () {
  this.model.off('change', this.render, this);
  this.remove();
}</pre></div><p>Now everything<a id="id237" class="indexterm"/> is cleaned up properly. But do we need to keep doing this for all of our views? No, because Backbone V9.9 introduced a <code class="literal">listenTo()</code> method that tells an object to listen to an event of another object:</p><div class="informalexample"><pre class="programlisting">this.listenTo(this.model, 'change', this.render);</pre></div><p>This works exactly the same way, but the advantage of this over the <code class="literal">on()</code> method is that it allows the object to keep track of events, and they can be removed all at once later on. So, we will not need an extra <code class="literal">close()</code> method to unbind all the events before destroying the view. Rather, the <code class="literal">remove()</code> method of Backbone view will now clean up any bound event by calling the <code class="literal">stopListening()</code> method.</p><p>So, use the <code class="literal">on()</code> method when you want to take care of the handler yourself and where scenarios like event cleanup or zombie handling will not arise. Otherwise, go for <code class="literal">listenTo()</code>, which we will mostly find useful in the context of Backbone views.</p></div>
<div class="section" title="Overriding the Backbone.sync() method"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec38"/>Overriding the Backbone.sync() method</h1></div></div></div><p>Backbone <a id="id238" class="indexterm"/>provides a single gateway for all its data communication. All the data requests are sent via the <code class="literal">sync()</code> method that gets called whenever any <code class="literal">CRUD</code> operation is processed. This <code class="literal">sync()</code> method does a number of jobs, such as setting the URL, parameters and content type, and mimicking HTTP requests for old browsers that do not support <code class="literal">PUT</code> and <code class="literal">DELETE</code> requests. Whenever we call a <code class="literal">fetch()</code> or <code class="literal">save()</code> method on a model or collection, the <code class="literal">sync()</code> method is executed.</p><p>But when do we need to override this method? Sometimes, you may need a separate implementation of the REST API method, which Backbone does not provide. This can be for a certain model or collection, or the implementation can persist for the complete project. This is how the method map is written in Backbone by default:</p><div class="informalexample"><pre class="programlisting">var methodMap = {
  'create': 'POST',
  'update': 'PUT',
  'patch': 'PATCH',
  'delete': 'DELETE',
  'read': 'GET'
};</pre></div><p>Now, you may have a particular model or collection that will listen to a separate API other than<a id="id239" class="indexterm"/> the default one, say the Google or Twitter API, which you cannot change. Or, you may want to implement an offline storage that will use the browser's local storage to operate on the data. In such cases, you need to override the <code class="literal">sync()</code> method of that collection or model, or if it is common throughout the application, you need to override the <code class="literal">Backbone.sync()</code> method. Let's understand its importance with an example. Here we want our <code class="literal">User</code> module to interact directly with the public API <code class="literal">FooApi</code>:</p><div class="informalexample"><pre class="programlisting">// FooApi is a public api with 'add', 'edit', 'read' 
// and 'delete' methods
var User = Backbone.Model.extend({
  sync: function (method, model, options) {
    options || (options = {});

    switch (method) {
    case 'create':
      FooApi.add(options.data);
      break;

    case 'update':
      FooApi.edit(options.data);
      break;

    case 'delete':
      FooApi.delete({
        id: options.data.id
      });
      break;

    case 'read':
      FooApi.read({
        id: options.data.id
      });
      break;
    }
    // Other stuff
  }
});

var user = new User({
  name: 'Manali',
  age: 29
});

// This will call FooApi.add() method
user.save();</pre></div><p>Look how <a id="id240" class="indexterm"/>we used a <code class="literal">switch</code> case to call the <code class="literal">FooApi</code> method for each of the data operation methods. Now, when you call the <code class="literal">save()</code> method on the user instance, it will call the <code class="literal">FooApi.add()</code> method directly. You can use the other data operations similarly. So, this is the way in which Backbone's <code class="literal">sync()</code> method is overridden to create a wrapper that maps the models and methods of another API.</p></div>
<div class="section" title="Offline storage using the Backbone.LocalStorage adapter"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec39"/>Offline storage using the Backbone.LocalStorage adapter</h1></div></div></div><p>In the <a id="id241" class="indexterm"/>previous section, we saw how overriding the <code class="literal">Backbone.sync()</code> method provides you with customized data operations, <a id="id242" class="indexterm"/>including models and collections. Most of the time, we use the HTML5 <code class="literal">LocalStorage</code> functionality to store our data in the browser for offline browsing. This is a pretty common requirement for storing small data in a browser while developing mobile websites and mobile web applications. The <code class="literal">LocalStorage</code> communication can also be done with the help of the <code class="literal">sync()</code> method in a way that is exactly the same as the technique used in the previous section by overriding the <code class="literal">sync()</code> method.</p><p>Rather than creating this solution ourselves, we will look into an excellent adapter, <code class="literal">Backbone.LocalStorage</code> (<a class="ulink" href="http://documentup.com/jeromegn/backbone.localStorage">http://documentup.com/jeromegn/backbone.localStorage</a>), which was developed by Jerome Gravel-Niquet and widely used by the Backbone.js developer community for interacting with <code class="literal">LocalStorage</code>. This adapter can be plugged into any model or collection, and thus enables them to communicate with <code class="literal">LocalStorage</code> using the <code class="literal">save()</code> or <code class="literal">fetch()</code> methods as follows:</p><div class="informalexample"><pre class="programlisting">var Users = Backbone.Collection.extend({
  model: Backbone.Model,
  localStorage: new Backbone.LocalStorage("users")
});

var users = new Users();

// Add items to collection
users.add([{
  name: 'Soumendu De'
}, {
  name: 'Bikash Debroy'
}])

// Sync collection data to localstorage
users.each(function (user) {
  user.save();
}); </pre></div><p>Here we<a id="id243" class="indexterm"/> defined a collection by passing an instance of <code class="literal">Backbone.LocalStorage</code> to the <code class="literal">LocalStorage</code> property. <a id="id244" class="indexterm"/>This is the only configuration that is requires to attach the collection to <code class="literal">LocalStorage</code> and perform all of the data operations on it. Also, this configuration works for both the model and the collection. If you want to know how the <code class="literal">sync()</code> functionality has been implemented within this adapter, go ahead and look into the adapter code—it's small and pretty well-written.</p><p>Another popular <code class="literal">LocalStorage</code> adapter is <code class="literal">Backbone.dualStorage</code> (<a class="ulink" href="https://github.com/nilbus/Backbone.dualStorage">https://github.com/nilbus/Backbone.dualStorage</a>). There are quite a few adapters available online and all of them provide a similar functionality. So, if you want to follow some tool other than the one we mentioned, you are free to do so.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>Summary</h1></div></div></div><p>Events in JavaScript are one of the most interesting concepts; lots of articles and books are available on this subject. We didn't try to look into all the details in this chapter, but we analyzed how using custom events and an event dispatcher in your Backbone application can provide enormous flexibility and scalability to the application architecture. We encourage you to explore JavaScript events, function scopes, and an event dispatcher or PubSub pattern if you need a more detailed idea about it.</p><p>In this chapter, we also learned about Backbone's <code class="literal">sync()</code> method and how we can override the <code class="literal">sync()</code> method to get custom data operations for public APIs or the HTML5 <code class="literal">LocalStorage</code>.</p><p>Also, we have looked at various components of Backbone and discussed their best practices, few plugins and extensions related to them, and some common issues. In the next chapter, we will see how we can organize Backbone applications with different design patterns and architecture.</p></div></body></html>