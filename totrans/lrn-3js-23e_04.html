<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch04"/>Chapter 4. Working with Three.js Materials</h1></div></div></div><p>In the previous chapters, we talked a bit about materials. You learned that a material, together with <code class="literal">THREE.Geometry</code>, forms <code class="literal">THREE.Mesh</code>. The<a id="id301" class="indexterm"/> material is like the skin of the object that defines what the outside of a geometry looks like. For example, a skin defines whether a geometry is metallic-looking, transparent, or shown as a wireframe. The resulting <code class="literal">THREE.Mesh</code> object can then be added to the scene to be rendered by Three.js. Until now, we haven't really looked at materials in much detail. In this chapter, we'll dive into all the materials Three.js has to offer, and you'll learn how you can use these materials to create good-looking 3D objects. The materials we'll explore in this chapter are shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MeshBasicMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id302" class="indexterm"/> is a basic material that you can use to give your geometries a simple color or show the wireframe of your geometries.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MeshDepthMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is <a id="id303" class="indexterm"/>a material that uses the distance from the camera to determine how to color your mesh.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MeshNormalMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a<a id="id304" class="indexterm"/> simple material that bases the color of a face on its normal vector.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MeshFacematerial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a <a id="id305" class="indexterm"/>container that allows you to specify a unique material for each face of the geometry.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MeshLambertMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id306" class="indexterm"/> a material that takes lighting into account and is used to create <em>dull</em> non-shiny-looking objects.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">MeshPhongMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id307" class="indexterm"/> is a material that also takes lighting into account and can be used to create shiny objects.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ShaderMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id308" class="indexterm"/>material allows you to specify your own shader programs to directly control how vertices are positioned and pixels are colored.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LineBasicMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id309" class="indexterm"/> is a material that can be used on the <code class="literal">THREE.Line</code> geometry to create colored lines.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LineDashMaterial</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id310" class="indexterm"/> is the same as <code class="literal">LineBasicMaterial</code>, but this material also allows you to create a dashed effect.</p>
</td></tr></tbody></table></div><p>If you look through the source code of Three.js, you might run into <code class="literal">THREE.RawShaderMaterial</code>. This is a specialized material that can only be used together with <code class="literal">THREE.BufferedGeometry</code>. This geometry is a specialized form that is optimized for static geometries (for instance, vertices and faces don't change). We won't explore this material in this chapter, but we will use it in <a class="link" href="ch11.html" title="Chapter 11. Custom Shaders and Render Postprocessing">Chapter 11</a>, <em>Custom Shaders and Render Postprocessing</em>, when we talk about creating custom shaders. In the code, you can also find <code class="literal">THREE.SpriteCanvasMaterial</code>, <code class="literal">THREE.SpriteMaterial</code>, and <code class="literal">THREE.PointCloudMaterial</code>. These are materials you use when styling individual points. We won't discuss those in this chapter, but we'll explore them in <a class="link" href="ch07.html" title="Chapter 7. Particles, Sprites, and the Point Cloud">Chapter 7</a>, <em>Particles, Sprites, and the Point Cloud</em>.</p><p>Materials have a number of common properties, so before we look at the first material, <code class="literal">MeshBasicMaterial</code>, we'll look at the properties shared by all the materials.</p><div><div><div><div><h1 class="title"><a id="ch04lvl1sec25"/>Understanding common material properties</h1></div></div></div><p>You can quickly see for yourself which properties are shared between all the materials. Three.js provides a material base class, <code class="literal">THREE.Material</code>, that lists all the common properties. We've divided these <a id="id311" class="indexterm"/>common material properties into the following three categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Basic properties</strong>: These <a id="id312" class="indexterm"/>are the<a id="id313" class="indexterm"/> properties you'll use most often. With these properties, you can, for instance, control the opacity of the object, whether it is visible, and how it is referenced (by ID or custom name).</li><li class="listitem" style="list-style-type: disc"><strong>Blending properties</strong>: Every<a id="id314" class="indexterm"/> object <a id="id315" class="indexterm"/>has a set of blending properties. These properties define how the object is combined with its background.</li><li class="listitem" style="list-style-type: disc"><strong>Advanced properties</strong>: There <a id="id316" class="indexterm"/>are a<a id="id317" class="indexterm"/> number of advanced properties that control how the low-level WebGL context renders objects. In most cases, you won't need to mess with these properties.</li></ul></div><p>Note that in this chapter, we skip any properties related to textures and maps. Most materials allow you to use images as textures (for instance, a wood-like or stone-like texture). In <a class="link" href="ch10.html" title="Chapter 10. Loading and Working with Textures">Chapter 10</a>, <em>Loading and Working with Textures</em>, we will dive into the various texture and mapping options that are available. Some materials also have specific properties related to animation (skinning and <code class="literal">morphTargets</code>); we'll also skip those properties. These will be addressed in <a class="link" href="ch09.html" title="Chapter 9. Animations and Moving the Camera">Chapter 9</a>, <em>Animations and Moving the Camera</em>.</p><p>We start with the first one from the list: the basic properties.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec28"/>Basic properties</h2></div></div></div><p>The <a id="id318" class="indexterm"/>basic properties of the <code class="literal">THREE.Material</code> object are<a id="id319" class="indexterm"/> listed in the following table (you can see these properties in action in the section on <code class="literal">THREE.BasicMeshMaterial</code>):</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Property</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">id</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id320" class="indexterm"/>is used to identify a material and is assigned when you create a material. This starts at <code class="literal">0</code> for the first material and is increased by <code class="literal">1</code> for each additional material that is created.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">uuid</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is a<a id="id321" class="indexterm"/> uniquely generated ID and is used internally.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">name</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You<a id="id322" class="indexterm"/> can assign a name to a material with this property. This can be used for debugging purposes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">opacity</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id323" class="indexterm"/>defines how transparent an object is. Use this together with the <code class="literal">transparent</code> property. The range of this property is from <code class="literal">0</code> to <code class="literal">1</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">transparent</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If this<a id="id324" class="indexterm"/> is set to <code class="literal">true</code>, Three.js will render this object with the set opacity. If this is set to <code class="literal">false</code>, the object won't be transparent—just more lightly colored. This property should also be set to <code class="literal">true</code> if you use a texture that uses an alpha (transparency) channel.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">overdraw</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When<a id="id325" class="indexterm"/> you use <code class="literal">THREE.CanvasRenderer</code>, the polygons will be rendered a bit bigger. Set this to <code class="literal">true</code> when you see gaps when using this renderer.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">visible</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id326" class="indexterm"/>defines whether this material is visible. If you set this to <code class="literal">false</code>, you won't see the object in the scene.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Side</code>
</p>
</td><td style="text-align: left" valign="top">
<p>With<a id="id327" class="indexterm"/> this property, you can define to which side of the geometry a material is applied. The default is <code class="literal">THREE.Frontside</code>, which applies the material to the front (outside) of an object. You can also set this to <code class="literal">THREE.BackSide</code>, which applies is to the back (inside), or <code class="literal">THREE.DoubleSide</code>, which applies it to both sides. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">needsUpdate</code>
</p>
</td><td style="text-align: left" valign="top">
<p>For<a id="id328" class="indexterm"/> some updates to the material, you need to tell Three.js that the material has been changed. If this property is set to <code class="literal">true</code>, Three.js will update its cache with the new material properties. </p>
</td></tr></tbody></table></div><p>For each material, you can also set a number of blending properties.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec29"/>Blending properties</h2></div></div></div><p>Materials<a id="id329" class="indexterm"/> have a couple of generic <a id="id330" class="indexterm"/>blending-related properties. Blending determines how the colors we render interact with the colors that are behind them. We'll touch upon this subject a little bit when we talk about combining materials. The blending properties are listed in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blending</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id331" class="indexterm"/>determines how the material on this object blends with the background. The normal mode is <code class="literal">THREE.NormalBlending</code>, which only shows the top layer.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blendsrc</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Besides <a id="id332" class="indexterm"/>using the standard blending modes, you can also create custom blend modes by setting <code class="literal">blendsrc</code>, <code class="literal">blenddst</code>, and <code class="literal">blendequation</code>. This property defines how this object (the source) is blended into the background (the destination). The default <code class="literal">THREE.SrcAlphaFactor</code> setting uses the alpha (transparency) channel for blending.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blenddst</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id333" class="indexterm"/> property defines how the background (the destination) is used in blending and defaults to <code class="literal">THREE.OneMinusSrcAlphaFactor</code>, which means this property too uses the alpha channel of the source for blending but uses <code class="literal">1</code> (alpha channel of the source) as the value.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">blendequation</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This defines <a id="id334" class="indexterm"/>how the <code class="literal">blendsrc</code> and <code class="literal">blenddst</code> values are used. The default is to add them (<code class="literal">AddEquation</code>). With these three properties, you can create your own custom blend modes.</p>
</td></tr></tbody></table></div><p>The last set of properties is mostly used internally and controls the specifics of how WebGL is used to render the scene.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec30"/>Advanced properties</h2></div></div></div><p>We<a id="id335" class="indexterm"/> won't go<a id="id336" class="indexterm"/> into the details of these properties. These are related to how WebGL works internally. If you do want to know more about these properties, the <a id="id337" class="indexterm"/>OpenGL specification is a good starting point. You can find this specification at <a class="ulink" href="http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf">http://www.khronos.org/registry/gles/specs/2.0/es_full_spec_2.0.25.pdf</a>. The following table provides a brief description of these advanced properties:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">depthTest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id338" class="indexterm"/>is an advanced WebGL property. With this property, you can enable or disable the <code class="literal">GL_DEPTH_TEST</code> parameter. This parameter controls whether the <em>depth</em> of a pixel is used to determine a new pixel's value. Normally, you wouldn't need to change this. More information can be found in the OpenGL specifications we mentioned earlier.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">depthWrite</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id339" class="indexterm"/> is another internal property. This property can be used to determine whether this material affects the WebGL depth buffer. If you use an object for a 2D overlay (for example, a hub), you should set this property to <code class="literal">false</code>. Usually, though, you shouldn't need to change this property.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">polygonOffset</code>, <code class="literal">polygonOffsetFactor</code>, and <code class="literal">polygonOffsetUnits</code>
</p>
</td><td style="text-align: left" valign="top">
<p>With<a id="id340" class="indexterm"/> these <a id="id341" class="indexterm"/>properties, you can <a id="id342" class="indexterm"/>control the <code class="literal">POLYGON_OFFSET_FILL</code> WebGL feature. These are normally not needed. For an explanation of what they do in detail, you can look at the OpenGL specifications.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">alphatest</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id343" class="indexterm"/>value can be set to a specific value (<code class="literal">0</code> to <code class="literal">1</code>). Whenever a pixel has an alpha value smaller than this value, it won't be drawn. You can use this property to remove some transparency-related artifacts.</p>
</td></tr></tbody></table></div><p>Now, let's look at all the available materials so that you can see the effect these properties have on the rendered output.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec26"/>Starting with a simple mesh</h1></div></div></div><p>In this<a id="id344" class="indexterm"/> section, we'll look at a few simple materials: <code class="literal">MeshBasicMaterial</code>, <code class="literal">MeshDepthMaterial</code>, <code class="literal">MeshNormalMaterial</code>, and <code class="literal">MeshFaceMaterial</code>. We start with <code class="literal">MeshBasicMaterial</code>.</p><p>Before we look into the <a id="id345" class="indexterm"/>properties of these materials, here's a quick note on how you can pass in properties to configure the materials. There are two options:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">You can pass in the arguments in the constructor as a parameters object, like this:<div><pre class="programlisting">var material = new THREE.MeshBasicMaterial(
{
  color: 0xff0000, name: 'material-1', opacity: 0.5, transparency: true, ...
});</pre></div></li><li class="listitem" style="list-style-type: disc">Alternatively, you can also create an instance and set the properties individually, like this:<div><pre class="programlisting">var material = new THREE.MeshBasicMaterial();
material.color = new THREE.Color(0xff0000);
material.name = 'material-1';
material.opacity = 0.5;
material.transparency = true;</pre></div></li></ul></div><p>Usually, the best way is to use the constructor if we know all the properties' values while creating the material. The arguments used in both these styles use the same format. The only exception to this rule is the <code class="literal">color</code> property. In the first style, we can just pass in the hex value, and Three.js will create a <code class="literal">THREE.Color</code> object itself. In the second style, we have to explicitly create a <code class="literal">THREE.Color</code> object. In this book, we'll use both of these styles.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec31"/>THREE.MeshBasicMaterial</h2></div></div></div><p>
<code class="literal">MeshBasicMaterial</code> is<a id="id346" class="indexterm"/> a very<a id="id347" class="indexterm"/> simple material that doesn't take into account the lights that are available in the scene. Meshes with this material will be rendered as simple, flat polygons, and you also have the option to show the geometry's wireframe. Besides the common properties we saw in the earlier section on this material, we can set the following properties:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">color</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id348" class="indexterm"/>property allows you to set the color of the material.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wireframe</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id349" class="indexterm"/> allows you to render the material as a wireframe. This is great for debugging purposes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Wireframelinewidth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If you<a id="id350" class="indexterm"/> enable the wireframe, this property defines the width of the wires from the wireframe.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Wireframelinecap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id351" class="indexterm"/>property defines how the ends of lines look in wireframe mode. The possible values are <code class="literal">butt</code>, <code class="literal">round</code>, and <code class="literal">square</code>. The default value is <code class="literal">round</code>. In practice, the results from changing this property are very difficult to see. This property isn't supported on <code class="literal">WebGLRenderer</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wireframeLinejoin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id352" class="indexterm"/> defines how the line joints are visualized. The possible values are <code class="literal">round</code>, <code class="literal">bevel</code>, and <code class="literal">miter</code>. The default value is <code class="literal">round</code>. If you look very closely, you can see this in the example using low <code class="literal">opacity</code> and a very large <code class="literal">wireframeLinewidth</code> value. This property isn't supported on <code class="literal">WebGLRenderer</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Shading</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id353" class="indexterm"/> defines how shading is applied. The possible values are <code class="literal">THREE.SmoothShading</code>, <code class="literal">THREE.NoShading</code>, and <code class="literal">THREE.FlatShading</code>. The default value is <code class="literal">THREE.SmoothShading</code>, which results in a smooth object where you won't see the individual faces. This property isn't enabled in the example for this material. For an example, look at the section on <code class="literal">MeshNormalMaterial</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">vertexColors</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You can<a id="id354" class="indexterm"/> define individual colors to be applied to each vertex with this property. The default value is <code class="literal">THREE.NoColors</code>. If you set this value to <code class="literal">THREE.VertexColors</code>, the renderer will take the colors set on the colors property of <code class="literal">THREE.Geometry</code> into account.</p>
<p>This property doesn't work on <code class="literal">CanvasRenderer</code> but does work on <code class="literal">WebGLRenderer</code>. Look at the <code class="literal">LineBasicMaterial</code> example, where we use this property to color the various parts of a line. You can also use this property to create a gradient effect for this material type.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fog</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id355" class="indexterm"/> property determines whether this material is affected by global fog settings. This is not shown in action, but if this is set to <code class="literal">false</code>, the global fog we saw in <a class="link" href="ch02.html" title="Chapter 2. Basic Components That Make Up a Three.js Scene">Chapter 2</a>, <em>Basic Components That Make Up a Three.js Scene</em>, doesn't affect how this object is rendered.</p>
</td></tr></tbody></table></div><p>In the previous chapters, we saw how to create materials and assign them to objects. For <code class="literal">THREE.MeshBasicMaterial</code>, we do it like this:</p><div><pre class="programlisting">var meshMaterial = new THREE.MeshBasicMaterial({color: 0x7777ff});</pre></div><p>This creates a new <code class="literal">THREE.MeshBasicMaterial</code> and initializes the <code class="literal">color</code> property to <code class="literal">0x7777ff</code> (which is purple).</p><p>I've added an example<a id="id356" class="indexterm"/> that you can use to play around with the <code class="literal">THREE.MeshBasicMaterial</code> properties and the basic properties we discussed in the previous section. If you open up the <code class="literal">01-basic-mesh-material.html</code> example in the <code class="literal">chapter-04</code> folder, you'll see a rotating cube like the one shown in the following screenshot:</p><div><img src="img/2215OS_04_01.jpg" alt="THREE.MeshBasicMaterial"/></div><p>This is a very simple object. With the menu in the upper-right corner, you can play around with the properties and select different meshes (you can also change the renderer). For instance, a sphere with <code class="literal">opacity</code> of <code class="literal">0.2</code>, <code class="literal">transparent</code> set to <code class="literal">true</code>, <code class="literal">wireframe</code> set to <code class="literal">true</code>, <code class="literal">wireframeLinewidth</code> of <code class="literal">9</code>, and using <code class="literal">CanvasRenderer</code> is rendered like this:</p><div><img src="img/2215OS_04_02.jpg" alt="THREE.MeshBasicMaterial"/></div><p>One of the <a id="id357" class="indexterm"/>properties you can set in this example is the <code class="literal">side</code> property. With this property, you define to which side of <code class="literal">THREE.Geometry</code> the material is applied. You can test how this property works when you select the plane mesh. Since normally a material is only applied to the front side of a material, the rotating plane will be invisible half the time (when it shows it's back to you). If you set the <code class="literal">side</code> property to <code class="literal">double</code>, the plane will be visible the whole time, since the material is applied to both sides of the geometry. Note, though, that the renderer will need to do more work when the <code class="literal">side</code> property is set to <code class="literal">double</code>, so this could have an impact on the performance of your scene.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec32"/>THREE.MeshDepthMaterial</h2></div></div></div><p>The <a id="id358" class="indexterm"/>next material on the list is <code class="literal">THREE.MeshDepthMaterial</code>. With this material, the way an object looks isn't defined by lights or <a id="id359" class="indexterm"/>by a specific material property; it is defined by the distance from the object to the camera. You can combine this with other materials to easily create fading effects. The only relevant properties this material has are the following two that control whether you want to show a wireframe:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wireframe</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id360" class="indexterm"/> determines whether or not to show the wireframe.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wireframeLineWidth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id361" class="indexterm"/> determines the width of the wireframe.</p>
</td></tr></tbody></table></div><p>To demonstrate this, we<a id="id362" class="indexterm"/> modified the cubes example from <a class="link" href="ch02.html" title="Chapter 2. Basic Components That Make Up a Three.js Scene">Chapter 2</a>, <em>Basic Components That Make Up a Three.js Scene</em> (<code class="literal">02-depth-material</code> from the <code class="literal">chapter-04</code> folder). Remember that you have to click on the <strong>addCube</strong> button to populate the scene. The following screenshot shows the modified example:</p><div><img src="img/2215OS_04_03.jpg" alt="THREE.MeshDepthMaterial"/></div><p>Even though the material doesn't have many additional properties to control how an object is rendered, we can still control how fast the object's color fades out. In this example, we exposed the <code class="literal">near</code> and <code class="literal">far</code> properties of the camera. As you probably remember from <a class="link" href="ch02.html" title="Chapter 2. Basic Components That Make Up a Three.js Scene">Chapter 2</a>, <em>Basic Components That Make Up a Three.js Scene</em>, with these two properties, we set the visible area for the camera. Any objects that are nearer to the camera than the <code class="literal">near</code> property aren't shown, and any objects further away than the <code class="literal">far</code> property also fall outside the camera's visible area.</p><p>The distance between the <code class="literal">near</code> and <code class="literal">far</code> properties of the camera defines the brightness and the rate at which objects fade out. If the distance is very large, objects will only fade out a little as they move away from the camera. If the distance is small, the fadeout will be much more notable (as you can see in the following screenshot):</p><div><img src="img/2215OS_04_04.jpg" alt="THREE.MeshDepthMaterial"/></div><p>Creating <code class="literal">THREE.MeshDepthMaterial</code> is very easy and the object doesn't require any arguments. For<a id="id363" class="indexterm"/> this example, we've used the <code class="literal">scene.overrideMaterial</code> property to make sure all the objects in the scene use this material without having to explicitly specify it for each <code class="literal">THREE.Mesh</code> object:</p><div><pre class="programlisting">var scene = new THREE.Scene();
scene.overrideMaterial = new THREE.MeshDepthMaterial();</pre></div><p>The next part in this chapter isn't really about a specific material, but shows a way in which you can combine multiple materials together.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec33"/>Combining materials</h2></div></div></div><p>If you<a id="id364" class="indexterm"/> look back at the properties of <code class="literal">THREE.MeshDepthMaterial</code>, you can see that there isn't an option to set the color of the cubes. Everything<a id="id365" class="indexterm"/> was decided for you by the default properties of the material. Three.js, however, has the option to combine materials together to create new effects (this is also where blending comes into play). The following code shows how we can combine materials together:</p><div><pre class="programlisting">var cubeMaterial = new THREE.MeshDepthMaterial();
var colorMaterial = new THREE.MeshBasicMaterial({color: 0x00ff00, transparent: true, blending: THREE.MultiplyBlending})
var cube = new THREE.SceneUtils.createMultiMaterialObject(cubeGeometry, [colorMaterial, cubeMaterial]);
cube.children[1].scale.set(0.99, 0.99, 0.99);</pre></div><p>We get the following green-colored cubes that use the brightness from <code class="literal">THREE.MeshDepthMaterial</code> and the color from <code class="literal">THREE.MeshBasicMaterial</code> (open <code class="literal">03-combined-material.html</code> for this example). The following screenshot shows the example:</p><div><img src="img/2215OS_04_05.jpg" alt="Combining materials"/></div><p>Let's look at the steps you need to take to get this specific result.</p><p>First, we need<a id="id366" class="indexterm"/> to create our two materials. For <code class="literal">THREE.MeshDepthMaterial</code>, we don't do anything special; for <code class="literal">THREE.MeshBasicMaterial</code>, however, we set <code class="literal">transparent</code> to <code class="literal">true</code> and define a <code class="literal">blending</code> mode. If we don't set the <code class="literal">transparent</code> property to <code class="literal">true</code>, we'll just have solid, green objects since Three.js won't know to take the already-rendered colors into account. With <code class="literal">transparent</code> set to <code class="literal">true</code>, Three.js will check the <code class="literal">blending</code> property to see how the green <code class="literal">THREE.MeshBasicMaterial</code> object should interact with the background. The background in this case is the cube rendered with <code class="literal">THREE.MeshDepthMaterial</code>. In <a class="link" href="ch09.html" title="Chapter 9. Animations and Moving the Camera">Chapter 9</a>, <em>Animations and Moving the Camera</em>, we'll discuss in greater detail the various blend modes that are available.</p><p>For this<a id="id367" class="indexterm"/> example, though, we used <code class="literal">THREE.MultiplyBlending</code>. This blend mode multiplies the foreground color with the background color and gives you the desired effect. The last line in this code fragment is also an important one. What happens when we create a mesh with the <code class="literal">THREE.SceneUtils.createMultiMaterialObject()</code> function is that the geometry gets copied and two exactly the same meshes are returned in a group. If we render these without the last line, you should see a flickering effect. This can happen sometimes when objects are rendered one on top of the other and one of them is transparent. By scaling down the mesh created with <code class="literal">THREE.MeshDepthMaterial</code>, we can avoid this. To do so, use the following code:</p><div><pre class="programlisting">cube.children[1].scale.set(0.99, 0.99, 0.99);</pre></div><p>The next material is also one where we won't have any influence on the colors used in rendering.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec34"/>THREE.MeshNormalMaterial</h2></div></div></div><p>The <a id="id368" class="indexterm"/>easiest way to understand how <a id="id369" class="indexterm"/>this material is rendered is by first looking at an example. Open up the <code class="literal">04-mesh-normal-material.html</code> example from the <code class="literal">chapter-04</code> folder. If <a id="id370" class="indexterm"/>you select the sphere as the mesh, you'll see something like this:</p><div><img src="img/2215OS_04_06.jpg" alt="THREE.MeshNormalMaterial"/></div><p>As you can <a id="id371" class="indexterm"/>see, each face of the mesh is rendered in a slightly different color, and even though the sphere rotates, the colors stay pretty much at the same place. This happens because the color of each face is based on the <em>normal</em> pointing out from the face. This normal is the vector perpendicular to the face. The normal vector is used in many different parts of Three.js. It is used to determine light reflections, helps in mapping textures to 3D models, and gives information on how to light, shade, and color pixels on a surface. Luckily, though, Three.js handles the computation of these vectors and uses them internally, so you don't have to calculate them yourselves. The following screenshot shows all the normal vectors of <code class="literal">THREE.SphereGeometry</code>:</p><div><img src="img/2215OS_04_07.jpg" alt="THREE.MeshNormalMaterial"/></div><p>The direction<a id="id372" class="indexterm"/> this normal points in determines the color a face gets when you use <code class="literal">THREE.MeshNormalMaterial</code>. Since all normals for the faces of a sphere point in a different direction, we get the colorful sphere you can see in the examples. As a quick side note, to add these normal arrows, you can use <code class="literal">THREE.ArrowHelper</code> like this:</p><div><pre class="programlisting">for (var f = 0, fl = sphere.geometry.faces.length; f &lt; fl; f++) {
  var face = sphere.geometry.faces[ f ];
  var centroid = new THREE.Vector3(0, 0, 0);
  centroid.add(sphere.geometry.vertices[face.a]);
  centroid.add(sphere.geometry.vertices[face.b]);
  centroid.add(sphere.geometry.vertices[face.c]);
  centroid.divideScalar(3);

  var arrow = new THREE.ArrowHelper(face.normal, centroid, 2, 0x3333FF, 0.5, 0.5);
  sphere.add(arrow);
}</pre></div><p>In this code snippet, we iterate through all the faces of <code class="literal">THREE.SphereGeometry</code>. For each of these <code class="literal">THREE.Face3</code> objects, we calculate the center (the centroid) by adding the vertices that <a id="id373" class="indexterm"/>make up this face and dividing the result by 3. We use this centroid, together with the normal vector of the face, to draw an arrow. The <code class="literal">THREE.ArrowHelper</code> takes the following arguments: <code class="literal">direction</code>, <code class="literal">origin</code>, <code class="literal">length</code>, <code class="literal">color</code>, <code class="literal">headLength</code>, and <code class="literal">headWidth</code>.</p><p>There are a couple of other properties that you can set on <code class="literal">THREE.MeshNormalMaterial</code>:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wireframe</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id374" class="indexterm"/>determines whether or not to show the wireframe.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wireframeLineWidth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id375" class="indexterm"/>determines the width of the wireframe.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">shading</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id376" class="indexterm"/> configures shading in the form of flat shading with <code class="literal">THREE.FlatShading</code> and smooth shading with <code class="literal">THREE.SmoothShading</code>.</p>
</td></tr></tbody></table></div><p>We've already seen <code class="literal">wireframe</code> and <code class="literal">wireframeLinewidth</code> but skipped the <code class="literal">shading</code> property in our <code class="literal">THREE.MeshBasicMaterial</code> example. With the <code class="literal">shading</code> property, we can tell Three.js how to render our objects. If you use <code class="literal">THREE.FlatShading</code>, each face will be rendered as is (as you can see in the previous couple of screenshots), or you can use <code class="literal">THREE.SmoothShading</code>, which smoothens out the faces of our object. For instance, if we render the sphere using <code class="literal">THREE.SmoothShading</code>, the result looks like this:</p><div><img src="img/2215OS_04_08.jpg" alt="THREE.MeshNormalMaterial"/></div><p>We're almost done with the simple materials. The last one is <code class="literal">THREE.MeshFaceMaterial</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec35"/>THREE.MeshFaceMaterial</h2></div></div></div><p>The <a id="id377" class="indexterm"/>last of the basic materials isn't<a id="id378" class="indexterm"/> really a material but much more a container of other materials. <code class="literal">THREE.MeshFaceMaterial</code> allows you to assign a different material to each<a id="id379" class="indexterm"/> face of your geometry. For instance, if you have a cube, which has 12 faces (remember, Three.js only works with triangles), you can use this material to assign a different material (for example, with a different color) to each side of the cube. Using this material is really simple, as you can see from the following piece of code:</p><div><pre class="programlisting">var matArray = [];
matArray.push(new THREE.MeshBasicMaterial( { color: 0x009e60 }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0x009e60 }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0x0051ba }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0x0051ba }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0xffd500 }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0xffd500 }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0xff5800 }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0xff5800 }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0xC41E3A }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0xC41E3A }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0xffffff }));
matArray.push(new THREE.MeshBasicMaterial( { color: 0xffffff }));

var faceMaterial = new THREE.MeshFaceMaterial(matArray);

var cubeGeom = new THREE.BoxGeometry(3,3,3);
var cube = new THREE.Mesh(cubeGeom, faceMaterial);</pre></div><p>We first <a id="id380" class="indexterm"/>create an array, named <code class="literal">matArray</code>, to hold all the materials. Next, we create a new material, <code class="literal">THREE.MeshBasicMaterial</code> in this example, with a different color for each face. With this array, we instantiate <code class="literal">THREE.MeshFaceMaterial</code> and use it together with the cube geometry to create the mesh. Let's dive a bit deeper into the code and see what you need to do to recreate the following example: a simple 3D Rubik's cube. You can find this example in <code class="literal">05-mesh-face-material.html</code>. The following screenshot shows this example:</p><div><img src="img/2215OS_04_09.jpg" alt="THREE.MeshFaceMaterial"/></div><p>This Rubik's cube consists of a number of smaller cubes: three cubes along the <em>x</em> axis, three along the <em>y</em> axis, and three along the <em>z</em> axis. Here's how this is done:</p><div><pre class="programlisting">var group = new THREE.Mesh();
// add all the rubik cube elements
var mats = [];
mats.push(new THREE.MeshBasicMaterial({ color: 0x009e60 }));
mats.push(new THREE.MeshBasicMaterial({ color: 0x009e60 }));
mats.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }));
mats.push(new THREE.MeshBasicMaterial({ color: 0x0051ba }));
mats.push(new THREE.MeshBasicMaterial({ color: 0xffd500 }));
mats.push(new THREE.MeshBasicMaterial({ color: 0xffd500 }));
mats.push(new THREE.MeshBasicMaterial({ color: 0xff5800 }));
mats.push(new THREE.MeshBasicMaterial({ color: 0xff5800 }));
mats.push(new THREE.MeshBasicMaterial({ color: 0xC41E3A }));
mats.push(new THREE.MeshBasicMaterial({ color: 0xC41E3A }));
mats.push(new THREE.MeshBasicMaterial({ color: 0xffffff }));
mats.push(new THREE.MeshBasicMaterial({ color: 0xffffff }));

var faceMaterial = new THREE.MeshFaceMaterial(mats);

for (var x = 0; x &lt; 3; x++) {
  for (var y = 0; y &lt; 3; y++) {
    for (var z = 0; z &lt; 3; z++) {
      var cubeGeom = new THREE.BoxGeometry(2.9, 2.9, 2.9);
      var cube = new THREE.Mesh(cubeGeom, faceMaterial);
      cube.position.set(x * 3 - 3, y * 3, z * 3 - 3);

      group.add(cube);
    }
  }
}</pre></div><p>In this piece<a id="id381" class="indexterm"/> of code, we first create <code class="literal">THREE.Mesh</code>, which will hold all the individual cubes (<code class="literal">group</code>); next, we create the materials for each face and push them to the <code class="literal">mats</code> array. Remember, each side of the cube consists of two faces, so we need 12 materials. From these materials, we create <code class="literal">THREE.MeshFaceMaterial</code>. Then, we create three loops to make sure we create the right number of cubes. In this loop, we create each of the individual cubes, assign the material, position them, and add them to the group. What you should remember is that the position of the cubes is relative to the position of this group. If we move or rotate the group, all the cubes will move and rotate with it. For more information on how to work with groups, look at <a class="link" href="ch08.html" title="Chapter 8. Creating and Loading Advanced Meshes and Geometries">Chapter 8</a>, <em>Creating and Loading Advanced Meshes and Geometries</em>.</p><p>If you've opened the example in your browser, you can see that the complete Rubik's cube rotates, and not the individual cubes. This happens because we use the following in our rendering loop:</p><div><pre class="programlisting">group.rotation.y=step+=0.01;</pre></div><p>This causes <a id="id382" class="indexterm"/>the complete group to rotate around its center (0,0,0). When we positioned the individual cubes, we made sure they were positioned around this center point. That's why you see the -3 offset in the <code class="literal">cube.position.set(x * 3 - 3, y * 3, z * 3 - 3);</code> line of the preceding code.</p><div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>If you look at this code, you might wonder how Three.js determines which material to use for a specific face. For this, Three.js uses the <code class="literal">materialIndex</code> property, which you can set on each individual face of the <code class="literal">geometry.faces</code> array. The property points to the array index of the materials we add in the constructor of the <code class="literal">THREE.FaceMaterial</code> object. When you create a geometry using one of the standard Three.js geometries, Three.js provides sensible defaults. If you want other behavior, you can just set the <code class="literal">materialIndex</code> property yourself for each face to point at one of the provided materials.</p></div></div><p>
<code class="literal">THREE.MeshFaceMaterial</code> was the last of our basic materials. In the next section, we'll look at some of the more advanced materials available in Three.js.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec27"/>Advanced materials</h1></div></div></div><p>In this <a id="id383" class="indexterm"/>section, we'll look at the more advanced materials Three.js has to offer. We'll first look at <code class="literal">THREE.MeshPhongMaterial</code> and <code class="literal">THREE.MeshLambertMaterial</code>. These two materials react to light sources and can be used to create shiny and dull-looking materials, respectively. In this section, we'll also look at one of the most versatile, but most difficult to use, materials: <code class="literal">THREE.ShaderMaterial</code>. With <code class="literal">THREE.ShaderMaterial</code>, you can create your own shader programs that define how the material and object should be shown.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec36"/>THREE.MeshLambertMaterial</h2></div></div></div><p>This <a id="id384" class="indexterm"/>material can be used to create <a id="id385" class="indexterm"/>dull-looking, non-shiny surfaces. This is a very easy-to-use material that responds to the lighting sources in the scene. This material can be configured with a number of properties we've seen before: <code class="literal">color</code>, <code class="literal">opacity</code>, <code class="literal">shading</code>, <code class="literal">blending</code>, <code class="literal">depthTest</code>, <code class="literal">depthWrite</code>, <code class="literal">wireframe</code>, <code class="literal">wireframeLinewidth</code>, <code class="literal">wireframeLinecap</code>, <code class="literal">wireframeLineJoin</code>, <code class="literal">vertexColors</code>, and <code class="literal">fog</code>. We won't go into the details of those properties, but will focus on the ones specific to this material. That just leaves us with the following four properties:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ambient</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id386" class="indexterm"/> is the <em>ambient</em> color of the material. This works together with the ambient light we saw in the previous chapter. This color is multiplied with the color provided by the ambient light. This defaults to white.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">emissive</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This is<a id="id387" class="indexterm"/> the color this material emits. It doesn't really act as a light source, but this is a solid color that is unaffected by other lighting. This defaults to black.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wrapAround</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If <a id="id388" class="indexterm"/>this property is set to <code class="literal">true</code>, you enable the half-lambert lighting technique. With half-lambert lighting, the drop-off of light is more subtle. If you have a mesh with harsh, dark areas, enabling this property will soften the shadows and more evenly distribute the light.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wrapRGB</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When<a id="id389" class="indexterm"/> <code class="literal">wrapAround</code> is set to true, you can use <code class="literal">THREE.Vector3</code> to control how fast the light is dropped off.</p>
</td></tr></tbody></table></div><p>This material is created just like all the other ones. Here's how it's done:</p><div><pre class="programlisting">var meshMaterial = new THREE.MeshLambertMaterial({color: 0x7777ff});</pre></div><p>For an example of this material, look at <code class="literal">06-mesh-lambert-material.html</code>. The following screenshot shows this example:</p><div><img src="img/2215OS_04_10.jpg" alt="THREE.MeshLambertMaterial"/></div><p>As you can see in the preceding screenshot, the material looks rather dull. There is another material we can use to create shiny surfaces.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec37"/>THREE.MeshPhongMaterial</h2></div></div></div><p>With <a id="id390" class="indexterm"/>
<code class="literal">THREE.MeshPhongMaterial</code>, we can <a id="id391" class="indexterm"/>create a material that is shiny. The properties you can use for that are pretty much the same as for a non-shiny <code class="literal">THREE.MeshLambertMaterial</code> object. We'll once again skip the basic properties and those already discussed: <code class="literal">color</code>, <code class="literal">opacity</code>, <code class="literal">shading</code>, <code class="literal">blending</code>, <code class="literal">depthTest</code>, <code class="literal">depthWrite</code>, <code class="literal">wireframe</code>, <code class="literal">wireframeLinewidth</code>, <code class="literal">wireframeLinecap</code>, <code class="literal">wireframelineJoin</code>, and <code class="literal">vertexColors</code>.</p><p>The interesting properties for this material are shown in the following table:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">ambient</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id392" class="indexterm"/>is the <em>ambient</em> color of the material. This works together with the ambient light we saw in the previous chapter. This color is multiplied with the color provided by the ambient light. This defaults to white.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">emissive</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id393" class="indexterm"/> is the color this material emits. It doesn't really act as a light source, but this is a solid color that is unaffected by other lighting. This defaults to black.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">specular</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id394" class="indexterm"/>property defines how shiny the materials are and with what color it shines. If this is set to the same color as the <code class="literal">color</code> property, you get a more metallic-looking material. If this is set to grey, it results in a more plastic-looking material.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">shininess</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id395" class="indexterm"/> property defines how shiny the specular highlight is. The default value for the shininess is <code class="literal">30</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">metal</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When<a id="id396" class="indexterm"/> this property is set to <code class="literal">true</code>, Three.js uses a slightly different way of calculating the color of a pixel to make the object look more like a metal. Note that the effect is very minimal.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wrapAround</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If this <a id="id397" class="indexterm"/>property is set to <code class="literal">true</code>, you enable the half-lambert lighting technique. With half-lambert lighting, the drop-off of light is more subtle. If you have a mesh with harsh, dark areas, enabling this property will soften the shadows and more evenly distribute the light.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wrapRGB</code>
</p>
</td><td style="text-align: left" valign="top">
<p>When <a id="id398" class="indexterm"/>
<code class="literal">wrapAround</code> is set to <code class="literal">true</code>, you can use <code class="literal">THREE.Vector3</code> to control how fast the light is dropped off.</p>
</td></tr></tbody></table></div><p>Initializing a <code class="literal">THREE.MeshPhongMaterial</code> object is done in the same way as we've already seen for all the other materials and is shown in the following line of code:</p><div><pre class="programlisting">var meshMaterial = new THREE.MeshPhongMaterial({color: 0x7777ff});</pre></div><p>To give you the best comparison, we've created the same example for this material as we did for <code class="literal">THREE.MeshLambertMaterial</code>. You can use the control GUI to play around with this material. For instance, the following settings create a plastic-looking material. You can find this example in <code class="literal">07-mesh-phong-material.html</code>. The following screenshot shows this example:</p><div><img src="img/2215OS_04_11.jpg" alt="THREE.MeshPhongMaterial"/></div><p>The last one of the advanced materials we'll explore is <code class="literal">THREE.ShaderMaterial</code>.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec38"/>Creating your own shaders with THREE.ShaderMaterial</h2></div></div></div><p>
<code class="literal">THREE.ShaderMaterial</code> <a id="id399" class="indexterm"/>is one of the most <a id="id400" class="indexterm"/>versatile <a id="id401" class="indexterm"/>and complex materials available in Three.js. With this material, you can pass in your own custom shaders that are directly run in the WebGL context. A shader converts Three.js JavaScript meshes to pixels on screen. With these custom shaders, you can define exactly how your object should be rendered and how <a id="id402" class="indexterm"/>to override or alter the defaults from Three.js. In this section, we won't go into the details yet of how to write custom shaders. For more information on that, see <a class="link" href="ch11.html" title="Chapter 11. Custom Shaders and Render Postprocessing">Chapter 11</a>, <em>Custom Shaders and Render Postprocessing</em>. For now, we'll just look at a very basic example that shows how you can configure this material.</p><p>
<code class="literal">THREE.ShaderMaterial</code> has a number of properties you can set that we've already seen. With <code class="literal">THREE.ShaderMaterial</code>, Three.js passes in all the information regarding these properties, but you still have to process the information in your own shader programs. The following are the properties of <code class="literal">THREE.ShaderMaterial</code> that we have already seen:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">wireframe</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id403" class="indexterm"/> renders the material as a wireframe. This is great for debugging purposes.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Wireframelinewidth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>If you<a id="id404" class="indexterm"/> enable the wireframe, this property defines the width of the wires from the wireframe.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">linewidth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id405" class="indexterm"/>defines the width of the line to be drawn.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Shading</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id406" class="indexterm"/>defines how shading is applied. The possible values are <code class="literal">THREE.SmoothShading</code> and <code class="literal">THREE.FlatShading</code>. This property isn't enabled in the example for this material. For example, look at the section on <code class="literal">MeshNormalMaterial</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">vertexColors</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You <a id="id407" class="indexterm"/>can define individual colors to be applied to each vertex with this property. This property doesn't work on <code class="literal">CanvasRenderer</code> but does work on <code class="literal">WebGLRenderer</code>. Look at the <code class="literal">LineBasicMaterial</code> example, where we use this property to color the various parts of a line.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fog</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id408" class="indexterm"/> determines whether this material is affected by global fog settings. This is not shown in action. If this is set to <code class="literal">false</code>, the global fog we saw in <a class="link" href="ch02.html" title="Chapter 2. Basic Components That Make Up a Three.js Scene">Chapter 2</a>, <em>Basic Components That Make Up a Three.js Scene</em>, doesn't affect how this object is rendered.</p>
</td></tr></tbody></table></div><p>Besides these properties that are passed into the shader, <code class="literal">THREE.ShaderMaterial</code> also provides a number of specific properties you can use to pass in additional information into your custom shader (they might seem a bit obscure at the moment; for more details, see <a class="link" href="ch11.html" title="Chapter 11. Custom Shaders and Render Postprocessing">Chapter 11</a>, <em>Custom Shaders and Render Postprocessing</em>), which are as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fragmentShader</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id409" class="indexterm"/> shader defines the color of each pixel that is passed in. Here, you need to pass in the string value of your fragment shader program.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">vertexShader</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id410" class="indexterm"/> shader allows you to change the position of each vertex that is passed in. Here, you need to pass in the string value of your vertex shader program.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">uniforms</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id411" class="indexterm"/> allows you to send information to your shader. The same information is sent to each vertex and fragment.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">defines</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Converts to #define code fragments. With these fragments, you can set some additional global variables in the shader programs.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">attributes</code>
</p>
</td><td style="text-align: left" valign="top">
<p>These<a id="id412" class="indexterm"/> can change between each vertex and fragment. They are usually used to pass positional and normal-related data. If you want to use this, you need to provide information for all the vertices of the geometry.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">lights</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id413" class="indexterm"/>determines whether light data should be passed into the shaders. This defaults to <code class="literal">false</code>.</p>
</td></tr></tbody></table></div><p>Before we look at an example, we'll give a quick explanation about the most important parts of <code class="literal">ShaderMaterial</code>. To work with this material, we have to pass in two different shaders:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">vertexShader</code>: This<a id="id414" class="indexterm"/> is run on each<a id="id415" class="indexterm"/> vertex of the geometry. You can use this shader to transform the geometry by moving the position of the vertices around.</li><li class="listitem" style="list-style-type: disc"><code class="literal">fragmentShader</code>: This<a id="id416" class="indexterm"/> is run on <a id="id417" class="indexterm"/>each fragment of the geometry. In <code class="literal">vertexShader</code>, we return the color that should be shown for this specific fragment.</li></ul></div><p>For all the materials we've discussed until now in this chapter, Three.js provides <code class="literal">fragmentShader</code> and <code class="literal">vertexShader</code>, so you don't have to worry about those.</p><p>For this <a id="id418" class="indexterm"/>section, we'll look at a simple example that uses a very simple <code class="literal">vertexShader</code> program that changes the <em>x</em>, <em>y</em>, and <em>z</em> coordinates of the vertices of a cube and a <code class="literal">fragmentShader</code> program that uses<a id="id419" class="indexterm"/> shaders from <a class="ulink" href="http://glslsandbox.com/">http://glslsandbox.com/</a> to create an animating material.</p><p>Up next, you can see the complete code for <code class="literal">vertexShader</code> that we'll use. Note that writing shaders isn't done in JavaScript. You write shaders in a C-like language<a id="id420" class="indexterm"/> called <strong>GLSL</strong> (WebGL supports OpenGL ES Shading Language 1.0—for more information on<a id="id421" class="indexterm"/> GLSL, see <a class="ulink" href="https://www.khronos.org/webgl/">https://www.khronos.org/webgl/</a>), as follows:</p><div><pre class="programlisting">&lt;script id="vertex-shader" type="x-shader/x-vertex"&gt;
  uniform float time;

  void main()
  {
    vec3 posChanged = position;
    posChanged.x = posChanged.x*(abs(sin(time*1.0)));
    posChanged.y = posChanged.y*(abs(cos(time*1.0)));
    posChanged.z = posChanged.z*(abs(sin(time*1.0)));

    gl_Position = projectionMatrix * modelViewMatrix * vec4(posChanged,1.0);
  }
&lt;/script&gt;</pre></div><p>We won't go<a id="id422" class="indexterm"/> into too much detail here and just focus on the most important parts of this code. To communicate with the shaders from JavaScript, we use something called uniforms. In this example, we use the <code class="literal">uniform float time;</code> statement to pass in an external value. Based on this value, we change the <em>x</em>, <em>y</em>, and <em>z</em> coordinates of the passed-in vertex (which is passed in as the position variable):</p><div><pre class="programlisting">vec3 posChanged = position;
posChanged.x = posChanged.x*(abs(sin(time*1.0)));
posChanged.y = posChanged.y*(abs(cos(time*1.0)));
posChanged.z = posChanged.z*(abs(sin(time*1.0)));</pre></div><p>The <code class="literal">posChanged</code> vector now contains the new coordinate for this vertex based on the passed-in time variable. The last step we need to perform is pass this new position back to Three.js, which is always done like this:</p><div><pre class="programlisting">gl_Position = projectionMatrix * modelViewMatrix * vec4(posChanged,1.0);</pre></div><p>The <code class="literal">gl_Position</code> variable is a special variable that is used to return the final position. Next, we need to create <code class="literal">shaderMaterial</code> and pass in <code class="literal">vertexShader</code>. For this, we've created a simple helper function, which we use like this: <code class="literal">var meshMaterial1 = createMaterial("vertex-shader","fragment-shader-1");</code> in the following code:</p><div><pre class="programlisting">function createMaterial(vertexShader, fragmentShader) {
  var vertShader = document.getElementById(vertexShader).innerHTML;
  var fragShader = document.getElementById(fragmentShader).innerHTML;

  var attributes = {};
  var uniforms = {
    time: {type: 'f', value: 0.2},
    scale: {type: 'f', value: 0.2},
    alpha: {type: 'f', value: 0.6},
    resolution: { type: "v2", value: new THREE.Vector2() }
  };

  uniforms.resolution.value.x = window.innerWidth;
  uniforms.resolution.value.y = window.innerHeight;

  var meshMaterial = new THREE.ShaderMaterial({
    uniforms: uniforms,
    attributes: attributes,
    vertexShader: vertShader,
    fragmentShader: fragShader,
    transparent: true

  });
  return meshMaterial;
}</pre></div><p>The <a id="id423" class="indexterm"/>arguments point to the ID of the <code class="literal">script</code> element in the HTML page. Here, you can also see that we set up a uniforms variable. This variable is used to pass information from our renderer into our shader. Our complete render loop for this example is shown in the following code snippet:</p><div><pre class="programlisting">function render() {
  stats.update();

  cube.rotation.y = step += 0.01;
  cube.rotation.x = step;
  cube.rotation.z = step;

  cube.material.materials.forEach(function (e) {
    e.uniforms.time.value += 0.01;
  });

  // render using requestAnimationFrame
  requestAnimationFrame(render);
  renderer.render(scene, camera);
}</pre></div><p>You can see that we increase the time variable by 0.01 each time the render loop is run. This information is passed into <code class="literal">vertexShader</code> and used to calculate the new position of the vertices of our cube. Now open up the <code class="literal">08-shader-material.html</code> example, and you'll see that the cube shrinks and grows around its axis. The following screenshot gives a still image of this example:</p><div><img src="img/2215OS_04_12.jpg" alt="Creating your own shaders with THREE.ShaderMaterial"/></div><p>In this <a id="id424" class="indexterm"/>example, you can see that each of the cube's faces has an animating pattern. The fragment shader that is assigned to each face of the cube creates these patterns. As you might have guessed, we've used <code class="literal">THREE.MeshFaceMaterial</code> (and the <code class="literal">createMaterial</code> function we explained earlier) for this:</p><div><pre class="programlisting">var cubeGeometry = new THREE.CubeGeometry(20, 20, 20);

var meshMaterial1 = createMaterial("vertex-shader", "fragment-shader-1");
var meshMaterial2 = createMaterial("vertex-shader", "fragment-shader-2");
var meshMaterial3 = createMaterial("vertex-shader", "fragment-shader-3");
var meshMaterial4 = createMaterial("vertex-shader", "fragment-shader-4");
var meshMaterial5 = createMaterial("vertex-shader", "fragment-shader-5");
var meshMaterial6 = createMaterial("vertex-shader", "fragment-shader-6");

var material = new THREE.MeshFaceMaterial([meshMaterial1, meshMaterial2, meshMaterial3, meshMaterial4, meshMaterial5, meshMaterial6]);

var cube = new THREE.Mesh(cubeGeometry, material);</pre></div><p>The only <a id="id425" class="indexterm"/>part we haven't explained yet is about <code class="literal">fragmentShader</code>. For this example, all the <code class="literal">fragmentShader</code> objects were copied from <a class="ulink" href="http://glslsandbox.com/">http://glslsandbox.com/</a>. This site provides an experimental playground where you can write and share <code class="literal">fragmentShader</code> objects. I won't go into the details here, but <code class="literal">fragment-shader-6</code> used in this example looks like this:</p><div><pre class="programlisting">&lt;script id="fragment-shader-6" type="x-shader/x-fragment"&gt;
  #ifdef GL_ES
  precision mediump float;
  #endif

  uniform float time;
  uniform vec2 resolution;


  void main( void )
  {

    vec2 uPos = ( gl_FragCoord.xy / resolution.xy );

    uPos.x -= 1.0;
    uPos.y -= 0.5;

    vec3 color = vec3(0.0);
    float vertColor = 2.0;
    for( float i = 0.0; i &lt; 15.0; ++i ) {
      float t = time * (0.9);

      uPos.y += sin( uPos.x*i + t+i/2.0 ) * 0.1;
      float fTemp = abs(1.0 / uPos.y / 100.0);
      vertColor += fTemp;
      color += vec3( fTemp*(10.0-i)/10.0, fTemp*i/10.0, pow(fTemp,1.5)*1.5 );
    }

    vec4 color_final = vec4(color, 1.0);
    gl_FragColor = color_final;
  }
&lt;/script&gt;</pre></div><p>The color that <a id="id426" class="indexterm"/>finally gets passed back to Three.js is the one set with <code class="literal">gl_FragColor = color_final</code>. A good way to get a bit more of a feeling for <code class="literal">fragmentShader</code> is to explore what's available at <a class="ulink" href="http://glslsandbox.com/">http://glslsandbox.com/</a> and to use the code for your own objects. Before we move to the next set of materials, here is one more example of what is possible<a id="id427" class="indexterm"/> with a custom <code class="literal">vertexShader</code> program (<a class="ulink" href="https://www.shadertoy.com/view/4dXGR4">https://www.shadertoy.com/view/4dXGR4</a>):</p><div><img src="img/2215OS_04_13.jpg" alt="Creating your own shaders with THREE.ShaderMaterial"/></div><p>Much more on the subject of fragment and vertex shaders can be found in <a class="link" href="ch11.html" title="Chapter 11. Custom Shaders and Render Postprocessing">Chapter 11</a>, <em>Custom Shaders and Render Postprocessing</em>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec28"/>Materials you can use for a line geometry</h1></div></div></div><p>The last couple of materials we're going to look at can only be used on one specific geometry: <code class="literal">THREE.Line</code>. As the name implies, this is just a single line that only consists of vertices and doesn't contain any faces. Three.js provides two different materials you can use on a line, which are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">THREE.LineBasicMaterial</code>: The <a id="id428" class="indexterm"/>basic material for a line allows you to set the <code class="literal">colors</code>, <code class="literal">linewidth</code>, <code class="literal">linecap</code>, and <code class="literal">linejoin</code> properties</li><li class="listitem" style="list-style-type: disc"><code class="literal">THREE.LineDashedMaterial</code>: This<a id="id429" class="indexterm"/> has the same properties as <code class="literal">THREE.LineBasicMaterial</code> but allows you to create a <em>dash</em> effect by specifying dash and spacing sizes</li></ul></div><p>We'll start with the basic variant and after that look at the dashed variant.</p><div><div><div><div><h2 class="title"><a id="ch04lvl2sec39"/>THREE.LineBasicMaterial</h2></div></div></div><p>The materials <a id="id430" class="indexterm"/>available for the <code class="literal">THREE.Line</code> geometry are very simple. The following table shows the properties available to this material:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">color</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id431" class="indexterm"/>determines the color of the line. If you specify <code class="literal">vertexColors</code>, this property is ignored.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">linewidth</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id432" class="indexterm"/>determines the width of the line.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">linecap</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id433" class="indexterm"/> property defines how the ends of lines look in the wireframe mode. The possible values are <code class="literal">butt</code>, <code class="literal">round</code>, and <code class="literal">square</code>. The default is <code class="literal">round</code>. In practice, the results from changing this property are very difficult to see. This property isn't supported on <code class="literal">WebGLRenderer</code>. </p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">linejoin</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Define <a id="id434" class="indexterm"/>how the line joints are visualized. The possible values are <code class="literal">round</code>, <code class="literal">bevel</code>, and <code class="literal">miter</code>. The default value is <code class="literal">round</code>. If you look very closely, you can see this in the example using low <code class="literal">opacity</code> and a very large <code class="literal">wireframeLinewidth</code>. This property isn't supported on <code class="literal">WebGLRenderer</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">vertexColors</code>
</p>
</td><td style="text-align: left" valign="top">
<p>You<a id="id435" class="indexterm"/> can supply a specific color for each vertex by setting this property to the <code class="literal">THREE.VertexColors</code> value.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">fog</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id436" class="indexterm"/>determines whether this object is affected by the global fog property.</p>
</td></tr></tbody></table></div><p>Before we look at<a id="id437" class="indexterm"/> an example of <code class="literal">LineBasicMaterial</code>, let's first have a quick look at how we can create a <code class="literal">THREE.Line</code> mesh from a set of vertices and combine that with <code class="literal">LineMaterial</code> to create the mesh, as shown in the following code:</p><div><pre class="programlisting">var points = gosper(4, 60);
var lines = new THREE.Geometry();
var colors = [];
var i = 0;
points.forEach(function (e) {
  lines.vertices.push(new THREE.Vector3(e.x, e.z, e.y));
  colors[ i ] = new THREE.Color(0xffffff);
  colors[ i ].setHSL(e.x / 100 + 0.5, (  e.y * 20 ) / 300, 0.8);
  i++;
});

lines.colors = colors;
var material = new THREE.LineBasicMaterial({
  opacity: 1.0,
  linewidth: 1,
  vertexColors: THREE.VertexColors });

var line = new THREE.Line(lines, material);</pre></div><p>The first <a id="id438" class="indexterm"/><a id="id439" class="indexterm"/>part of this code fragment, <code class="literal">var points = gosper(4, 60);</code>, is used as an example to get a set of <em>x</em> and <em>y</em> coordinates. This function returns a <a id="id440" class="indexterm"/>gosper curve (for more information, check out <a class="ulink" href="http://en.wikipedia.org/wiki/Gosper_curve">http://en.wikipedia.org/wiki/Gosper_curve</a>), which is a simple algorithm that fills a 2D space. What we do next is we create a <code class="literal">THREE.Geometry</code> instance, and for each coordinate, we create a new vertex, which we push into the lines property of this instance. For each coordinate, we also calculate a color value that we use to set the <code class="literal">colors</code> property.</p><div><div><h3 class="title"><a id="tip12"/>Tip</h3><p>In this example, we've set the color using the <code class="literal">setHSL()</code> method. Instead of providing values for red, green, and blue, with HSL, we provide the hue, saturation, and lightness. Using HSL is much more intuitive than RGB, and it is much easier to create sets of matching colors. A very good explanation of HSL can be found in the <a id="id441" class="indexterm"/>CSS specification: <a class="ulink" href="http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color">http://www.w3.org/TR/2003/CR-css3-color-20030514/#hsl-color</a>.</p></div></div><p>Now that we have our geometry, we can create <code class="literal">THREE.LineBasicMaterial</code> and use this together with the geometry to create a <code class="literal">THREE.Line</code> mesh. You can see the result in the <code class="literal">09-line-material.html</code> example. The following screenshot shows this example:</p><div><img src="img/2215OS_04_14.jpg" alt="THREE.LineBasicMaterial"/></div><p>The next and <a id="id442" class="indexterm"/>last material we'll discuss in this chapter is only slightly different from <code class="literal">THREE.LineBasicMaterial</code>. With <code class="literal">THREE.LineDashedMaterial</code>, not only can we color lines, but we can also add a <em>dash</em> effect.</p></div><div><div><div><div><h2 class="title"><a id="ch04lvl2sec40"/>THREE.LineDashedMaterial</h2></div></div></div><p>This<a id="id443" class="indexterm"/> material<a id="id444" class="indexterm"/> has the same properties as <code class="literal">THREE.LineBasicMaterial</code> and two additional ones you can use to define the dash width and the width of the gaps between the dashes, which are as follows:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name</p>
</th><th style="text-align: left" valign="bottom">
<p>Description</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">scale</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id445" class="indexterm"/>scales <code class="literal">dashSize</code> and <code class="literal">gapSize</code>. If the scale is smaller than <code class="literal">1</code>, <code class="literal">dashSize</code> and <code class="literal">gapSize</code> increase, and if the scale is larger than <code class="literal">1</code>, <code class="literal">dashSize</code> and <code class="literal">gapSize</code> decrease.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">dashSize</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This<a id="id446" class="indexterm"/> is the size of the dash.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">gapSize</code>
</p>
</td><td style="text-align: left" valign="top">
<p>This <a id="id447" class="indexterm"/>is the size of the gap.</p>
</td></tr></tbody></table></div><p>This material works almost exactly like <code class="literal">THREE.LineBasicMaterial</code>. Here's how it works:</p><div><pre class="programlisting">lines.computeLineDistances();
var material = new THREE.LineDashedMaterial({ vertexColors: true, color: 0xffffff, dashSize: 10, gapSize: 1, scale: 0.1 });</pre></div><p>The only<a id="id448" class="indexterm"/> difference is that you have to call <code class="literal">computeLineDistances()</code> (which is used to determine the distance between the vertices that make up a line). If you don't do this, the gaps won't be shown correctly. An example of this material can be found in <code class="literal">10-line-material-dashed.html</code> and looks like the following screenshot:</p><div><img src="img/2215OS_04_15.jpg" alt="THREE.LineDashedMaterial"/></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch04lvl1sec29"/>Summary</h1></div></div></div><p>Three.js gives you a lot of materials you can use to skin your geometries. The materials range from the very simple <code class="literal">(THREE.MeshBasicMaterial</code>) to the complex <code class="literal">(THREE.ShaderMaterial</code>), where you can provide your own <code class="literal">vertexShader</code> and <code class="literal">fragmentShader</code> programs. Materials share a lot of basic properties. If you know how to use a single material, you'll probably also know how to use the other materials. Note that not all materials respond to the lights in your scene. If you want a material that takes lighting into effect, use <code class="literal">THREE.MeshPhongMaterial</code> or <code class="literal">THREE.MeshLamberMaterial</code>. Determining the effect of certain material properties just from code is very hard. Often, a good idea is to use a dat.GUI approach to experiment with these properties.</p><p>Also, remember that most of the properties of a material can be modified at runtime. Some though (for example, <code class="literal">side</code>) can't be modified at runtime. If you change such a value, you need to set the <code class="literal">needsUpdate</code> property to <code class="literal">true</code>. For a complete overview of what can and cannot be changed at runtime, see the following page: <a class="ulink" href="https://github.com/mrdoob/three.js/wiki/Updates">https://github.com/mrdoob/three.js/wiki/Updates</a>.</p><p>In this and the previous chapters, we talked about geometries. We used these in our examples and explored a couple of them. In the next chapter, you'll learn everything about geometries and how you can work with them.</p></div></body></html>