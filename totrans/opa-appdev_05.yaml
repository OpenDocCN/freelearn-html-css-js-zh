- en: Chapter 5. Communicating between Client and Server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An important difference between Opa and most other web development languages
    is that other technologies typically require the use of multiple languages in
    order to write client-side and server-side code, whereas in Opa we can do both
    using a single language. This gives us the ability to invoke a remote procedure
    just like a local function. We do not need to send Ajax requests and parse response
    data ourselves. In this chapter, we will first talk about how to slice server
    and client code using Opa and what we can do to help the slicer when automatic
    slicing is not enough. Then, we will introduce three primitives for communication
    between clients and the server: session, cell, and network.'
  prefs: []
  type: TYPE_NORMAL
- en: Client and server slicing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Opa allows developers to write the server and client code both in the same language
    within the same module. And even better, the Opa slicer automates the calls between
    the client and the server. No more manually written Ajax calls or value serialization
    is needed!
  prefs: []
  type: TYPE_NORMAL
- en: A simple example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started with a simple example. Suppose we want to send our name
    to the server and request the server to respond with the words "Say hello to [name]
    from server":'
  prefs: []
  type: TYPE_NORMAL
- en: '![A simple example](img/3749OS_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This is quite simple and can be accomplished with almost any language that
    we are familiar with. Typically, you would send an Ajax request to the server
    with name as request data, and the server will respond with a JSON object containing
    the string we want. The following code fragment demonstrates how we can do this
    using jQuery for the client-side code and ASP as server-side code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'With Opa, things become even easier. We can skip the step of sending an Ajax
    request, and we also don''t need to parse the JSON response data ourselves. We
    only need to write a normal function with a server tag and invoke the function
    from the client. Here is the complete code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we add a `server` tag before the `sayhello` function
    to indicate that it is a function on the server side, and we invoke this function
    on the client as a normal client-side function. If the `server` tag is removed,
    the `sayhello` function will be a client-side function in this example, and there
    will be no communication between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: Slicing annotations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `server` tag tells the Opa complier to put the `sayhello` function on the
    server side. Opa is a language that can be executed both on a client and a server,
    but at some point during the compilation process, it must be decided on which
    side does the code actually end up, and whether there are any remote calls.
  prefs: []
  type: TYPE_NORMAL
- en: If the developer does not provide the slicing information by adding the slicing
    annotations (server, client, and both) before a function or a module, then Opa
    will perform the slicing job automatically. The rules for slicing that Opa follows
    by default are quite simple. Opa will implement the function on both the server
    as well as the client if possible. If it is not possible to implement the function
    both on the server and the client, then Opa will implement the function either
    on the server or on the client, depending on where it is possible to implement
    the function. For instance, if we remove the `server` tag from the `sayhello`
    function in the previous example, then Opa's slicer will implement the function
    twice, once on the server and once on the client. As a result, the invocation
    is no longer a remote call but a local call.
  prefs: []
  type: TYPE_NORMAL
- en: 'When automatic slicing is not enough, for example, if we want a function to
    only be available on the server side or client side, we can add slicing annotations
    before the function keyword to tell the slicer where a declaration should end
    up. There are three slicing annotations: **server**, **client** and **both**.'
  prefs: []
  type: TYPE_NORMAL
- en: '**server**: Opa will implement the function on the server (but it does not
    mean that it will not be visible for the code running on the client)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**client**: Opa will implement the code on the client (but it does not mean
    that it will not be visible for the code running on the server)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**both**: The function is implemented both on the server as well as the client'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is easy to understand what the **server** and **client** mean, but the **both**
    keyword is less intuitive. The problem is that a definition can have arbitrary
    side effects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Side effect**: In computer science, a function or expression is said to have
    a side effect if, in addition to returning a value, it also modifies some state
    or has an observable interaction with calling functions or the outside world.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, there are two possible meanings: either the side effect is executed
    on both sides or the side effect is executed once on the server and the resulting
    value is shared between the two sides. By default, the slicer duplicates some
    side effects such as printing and avoids duplicating the allocation of mutable
    structures.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If we compile and run the preceding code, it will print "Hello Opa!" on the
    server and the client both, but will create only one unique mutable variable called
    `counter` that is shared between the client and the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, we sometimes do want to duplicate the declaration on both sides. In that
    case, we can use the `@both_implem` directive. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This will create a mutable variable `counter` at the startup of the server and
    in each client.
  prefs: []
  type: TYPE_NORMAL
- en: Module slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When a slicing annotation refers to a module, it becomes the default slicing
    annotation for its components, but can be overridden by annotating the component
    with another annotation. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Because we put `server` before the `Logic` module, function `f1` will end up
    on the server side. But we override the slicing annotation of function `f2` with
    `client`, so function `f2` will be on the client side. We invoke both `f1` and
    `f2` when the page is ready, `f1` will print **function1** on the server side
    while `f2` will print **function2** on the client side. The following screenshot
    shows the result as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Module slicing](img/3749OS_05_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Expression slicing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, we want to have a different behavior on the server and on the client.
    We can use the `@sliced_expr` directive to do this. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will print "server" on the server side and "client" on the
    client side.
  prefs: []
  type: TYPE_NORMAL
- en: Client and server communication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Opa provides three primitives for communicating between clients and the server:
    session, cell, and network. We can use these three primitives to exchange messages
    between clients and servers.'
  prefs: []
  type: TYPE_NORMAL
- en: Session
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A session is a one-way asynchronous communication between the client and the
    server. A session can be created on a server or on a client, and can be shared
    between several servers.
  prefs: []
  type: TYPE_NORMAL
- en: To create a session, use either `Session.make` or `Session.NonBlocking.make`.
    The `Session.make` function creates a session that handles all messages in the
    background, but only one message at a time. This ensures absolute consistency
    on the state of the session, but may not be appropriate for all applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'In contrast, the `Session.NonBlocking.make` function creates a session that
    can handle any number of messages simultaneously. This ensures maximal responsiveness,
    but the message handler cannot be certain that it is holding the latest value
    of the state. Let''s have a look at how `Session.make` is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first parameter `state` is the initial state of the session. The second
    parameter is a message handler for this session. The message handler will be invoked
    when messages are sent to this session. The return value of this function is a
    channel, which we can use to send messages to the session by using the `Session.send`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example: suppose we want to send a string to the server
    through a session such that if the state of this session is an odd number, then
    whatever we send to the server is printed in uppercase. In contrast, if the state
    of this session is even then we print in lowercase. The code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile and run the preceding code, then we will see the following result
    on the server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Session](img/3749OS_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Cell
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A cell is a session in which sending messages produces return values. It''s
    a two-way synchronous communication between the client and the server. We can
    create a cell with `Cell.make` and call it with `Cell.call`. In the following
    example, the cell does almost the same thing as we had described in the previous
    example, but it returns the string to the client instead of printing it on the
    server. Here is the code fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Network
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A network is an infrastructure for broadcasting information to observers. Observers
    may be sessions or functions located on the same machine or on any client or server.
  prefs: []
  type: TYPE_NORMAL
- en: We can create a network with the `Network.empty()` function or construct a network
    that is automatically shared between servers with the `Network.cloud(key)` function.
  prefs: []
  type: TYPE_NORMAL
- en: We can observe a network with the `Network.observe(cb,network)` function, where
    `cb` is a callback function that is executed when a message is received on the
    network. To send a message to all observers of a network, use `Network.broadcast(msg,network)`.
  prefs: []
  type: TYPE_NORMAL
- en: The following example is a very simple chat application; the client will observe
    the network when its page is ready, and it will broadcast a message when the send
    button is triggered. We will learn to build a more sophisticated web chat application
    in [Chapter 9](ch09.html "Chapter 9. Building a Chat Application"), *Building
    a Chat Application*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Compile and run the preceding code, then open the web application in several
    browsers. We can communicate between browsers by sending the messages that we
    input. Here is a screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Network](img/3749OS_05_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we first talked about the Opa slicer. If we do not provide
    slicing information, the slicer will try to put the code on both sides whenever
    it is possible and will put the code on only one side when there is no way to
    put the code on both sides. When this automatic slicing is not enough, we can
    add slicing annotations (server, client, and both) before functions and modules
    to tell the slicer on which side we want our code to end. Then, we talked about
    the three primitives for communicating between clients and servers. Session is
    a one-way asynchronous communication, cell is a two-way synchronous communication,
    and network is for broadcasting messages to any number of observers.
  prefs: []
  type: TYPE_NORMAL
