- en: Chapter 6. User Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we developed mechanisms to provide login and logout
    capabilities and client-side session monitoring, and we also implemented a dynamic
    menu based on the user permissions. However, all the users, groups, and permissions
    were added manually to the database until now. We cannot do this every time we
    need to grant access to the application to a new user or change the user permissions.
    For this reason, we will implement a screen where we can create new users and
    grant or change the permissions. So in this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Listing all the users from the system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating, editing and deleting users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picture preview of a file upload (user's picture)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Managing users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So the first module we are going to develop is user management. In this module,
    we will be able to see all the users that are registered on the system, add new
    users, edit, and delete current users.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user clicks on the **Users** menu option, a new tab will open with
    the list of all users from the system as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing users](img/0457OT_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'When the user clicks on the **Add** or **Edit** button, the system will display
    a window so that the user can create a new user or edit a current user (based
    on the record selected on the GridPanel). The **Edit** window will look like the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Managing users](img/0457OT_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Some capabilities of creating or editing a user: we can edit the **User Information**
    such as **Name**, **Username**, and so on and we can also upload a **Photo** representing
    the user. But there is an extra feature; using the HTML5 API, we are going to
    display a preview of the **Photo** right after the user selects the picture from
    the computer and before the user uploads to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: Listing all the users using a simple GridPanel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We need to implement a screen similar to the first screenshot present in this
    chapter. It is a simple GridPanel. So to implement a simple GridPanel**,** we
    need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A Model to represent the information that is stored on the `user` table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A Store to load the information and a Proxy to tell Ext JS to read the information
    from the server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A GridPanel component representing the View
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A ViewController to listen to the events, as we are going to develop this module
    using MVVM
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a User Model
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So the first step is to create a Model to represent the `user` table. We are
    going to create a new file named `User.js` under the `app/model/security` directory.
    This Model is going to represent all the fields from the `user` table, except
    the `password` field, because as the password is something very personal to the
    user, we cannot display the user''s password to any other user, including the
    administrator. So the User Model is going to look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: And as we mentioned before, all the fields from the `user` table are mapped
    into this Model, except the `password` field.
  prefs: []
  type: TYPE_NORMAL
- en: In line `#1` we are not extending the default `Ext.data.Model` class. We are
    extending a class that we created. Let's see its declaration next.
  prefs: []
  type: TYPE_NORMAL
- en: Working with schemas
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: When we designed the database tables, we also added a foreign key to the `user`
    table. This means the `user` table has a relationship with the `groups` table.
    Ext JS 5 introduced the concept of schemas. A schema (`Ext.data.schema.Schema`)
    is a collection of related entities and their respective associations. We know
    that the `User` and `Group` Model classes are related entities, so we can create
    a schema to represent them.
  prefs: []
  type: TYPE_NORMAL
- en: 'So let''s see what''s inside the `Packt.model.security.Base` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `security.Base` model will work as a super Model that the `User` and `Group`
    (which will be defined later in this chapter in the section *Declaring the User
    ViewModel*) classes and contains the common code for both models.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing the `User` and `Group` Model classes have in common is the `id`
    field (`#1`). So to reuse this field in both classes, we can declare it here.
  prefs: []
  type: TYPE_NORMAL
- en: Next, `config` is the `schema`. Inside the `schema`, we can configure some options.
    The first one is `namespace` (`#2`). In some cases, we want to use a short name
    for the Model entities. We will use the short name of the `User` and `Group` classes
    when declaring associations and in the **ViewController** later. The short name
    is also known in Ext JS as `entityName` of the Model (we can declare this `config`
    in the Model as well). By default, `entityName` is the full class name, but this
    is exactly what we are trying to avoid. However, if `namespace` is used (in a
    `schema` declaration), the common portion can be discarded, and we can derive
    a shorter name. For example, the full name of the `User` class is `Packt.model.security.User`,
    and its schema namespace is `Packt.model.security`, so `entityName` will result
    in `User`. Using only `User` instead of `Packt.model.security.User` is much better.
  prefs: []
  type: TYPE_NORMAL
- en: We also have the `urlPrefix` (`#3`), which is the URL prefix used for all requests
    to the server. We are going to use this information when configuring `proxy` (in
    [Chapter 5](ch05.html "Chapter 5. Advanced Dynamic Menu"), *Advanced Dynamic Menu*,
    we used `proxy` inside the Store; now we are going to use it inside the Model).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we are going to configure `proxy` as follows. As we are using `proxy`
    inside the `schema` declaration, the configuration will be available for all classes
    extending the `Packt.model.security.Base` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: When we want to specify a different `url` for each of the CRUD operations, instead
    of using the `url` config we use the `api` config. Inside the `api` config, we
    define a `url` config for each CRUD action. When using schemas, we can use a template
    in the `proxy` to configure the URLs. For example, we use `prefix`, which refers
    to `urlPrefix` that we configured before. The `entityName` attribute refers to
    the Model `entityName` (and in this example, we also ask to transform the `entityName`
    to lowercase). In line `#4`, for the `User` Model class, the read `url` will be
    `php/user/list.php`. This is very useful when we want to follow a pattern and
    share (reuse) the `schema` configuration between different models.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to configure `reader` already. We can also specify `writer` (`#5`)
    when we want to send information to the server (create, update, or delete records).
    In this case, we are telling Ext JS we want to send a JSON back to the server.
    The `writeAllFields` configuration specifies whether we want the Model (and all
    its fields) to be sent to the server or only the fields that were modified (plus
    the `id` field). To make our life easier on the server-side code, we set `writeAllFields`
    as true. Just as with `reader`, we are also going to configure `rootProperty`
    to be a wrapper of the records. Then, we have the `encode` configuration set to
    `true` to send record data (all record fields if `writeAllFields` is `true`) as
    a JSON-encoded HTTP parameter named by the `rootProperty` configuration. The encode
    option should only be set to `true` when `rootProperty` is defined, because the
    values will be sent as part of the request parameters as opposed to a raw post.
    And at last, we have `allowSingle` set to `false`. This will force `proxy` to
    get all the modified records (to be created, updated, or deleted) and send them
    in an array (wrapped by `rootProperty` if configured). This will make `proxy`
    send only one request to the server (one request for creating, updating, or deleting
    records) instead of one request for each modification.
  prefs: []
  type: TYPE_NORMAL
- en: At last, we have the proxy `exception` `listener` (`#6`), which we are already
    familiar with from previous chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Defining store-less grids with Users GridPanel
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The next step is to create the views we are going to use to manage the users
    of our application. But before we get our hands on the code, we need to keep one
    thing in mind; when we implement the **Manage Groups** module and on the **Edit
    Group** screen, we want to display all the users that belong to that group. And
    for that, we will need to use a **Users** grid as well. So that being said, we
    need to create a component that will list the users (in this case all the users
    from the application) that we can reuse later. For this reason, the component
    that we are going to create will only contain the list of users and will not contain
    the **Add**/**Edit**/**Delete** buttons. We will add a toolbar with these buttons
    and also wrap the **Users** grid in another component.
  prefs: []
  type: TYPE_NORMAL
- en: 'So we are going to create a GridPanel. To do so, let''s create a new class
    named `Packt.view.security.UsersGrid`. To create this class, we will create a
    new file named `UsersGrid.js` under the `app/view/security` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'As usual, we are going to start with `xtype`. An alternative to `xtype` is
    using the `alias` (`#1`). When using `xtype`, we can declare it directly (for
    example `xtype: ''user-grid''`). When using `alias`, we need to specify what type
    of alias we are creating. For components we use "`widget.`" and for plugins, we
    use "`plugin.`", followed by the `xtype`.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's go ahead and also create `reference` so that we can refer to this component
    later in the ViewModel (`#2`).
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we declare a grid, there are two mandatory configurations we need to
    specify. The first one is the `columns` (`#3`) configuration, and the second one
    is the `store` configuration.
  prefs: []
  type: TYPE_NORMAL
- en: The `columns` (`#3`) configuration is an array of column definition objects
    that define all columns that appear in the grid. Each column definition provides
    the header `text` (`text` configuration) for the column, and a definition of where
    the data for that column comes from ((`dataIndex`) `#4`).
  prefs: []
  type: TYPE_NORMAL
- en: As a Grid is going to display a collection of data represented by a Model, each
    column needs to have the `dataIndex` (`#4`) configured matching the Model field
    that it represents.
  prefs: []
  type: TYPE_NORMAL
- en: We can define a `width` for each column. But we do not know the monitor resolution
    the user will be using, and we might end up with some extra space. We can choose
    a column to use all the available space by specifying the `flex` configuration
    (`#5`).
  prefs: []
  type: TYPE_NORMAL
- en: At last, on line `#6`, we have a column with `dataIndex` `groups_id` (`#6`),
    which will render the `groups_id` foreign key from the `groups` table. When we
    display associated data in a grid, we do not want to display the foreign key,
    but the description or name of the information. For now, we will leave the `groups_id`
    configured, but we will come back here and change this.
  prefs: []
  type: TYPE_NORMAL
- en: The `store` configuration is also required when declaring a Grid. But this configuration
    is missing in this class. Ext JS 5 introduced the ViewModel, and because of this
    new architecture and the data-binding concept, we can declare a store-less Grid
    and configure this later.
  prefs: []
  type: TYPE_NORMAL
- en: The Users screen
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Now that we have the **Users** GridPanel ready, we still need to create another
    component that is going to wrap the **User** GridPanel and will also contain the
    toolbar with the **Add**/**Edit**/**Delete** buttons. The simplest component that
    supports Docked Items is the panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to create a new class named `Packt.view.security.User` that is
    going to extend from the `Ext.panel.Panel` class. To do so, we need to create
    a new file named `User.js` under the `app/view/security` directory, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In this class, we will have only one component being rendered in the panel's
    body for now. It is the `users-grid` (`#6`). And as we are using its `xtype` to
    instantiate it, we need to make sure the `UsersGrid` class is already loaded,
    and that is why we need to add the class in the `requires` declaration (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: Later, we are going to create a window (popup) with a form that is going to
    allow us to create or edit a user. Because of some ViewModel concepts and limitations,
    we will add the window as an item of this class. For this reason, we are not going
    to use the Fit Layout (renders a single child), but we are going to use the `VBox`
    layout (`#5`).
  prefs: []
  type: TYPE_NORMAL
- en: The `VBox` layout aligns the child items vertically. It divides the available
    vertical space between the child items using the `flex` configuration (`#7`).
    In this example, the window will be displayed as a popup, so the Grid will continue
    being the only child component.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using the `VBox` layout, we can also define the alignment of the items.
    We are going to use `align: ''stretch''`. According to Ext JS documentation, the
    possible options are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`begin`: Child items are aligned vertically at the top of the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`middle`: Child items are vertically centered in the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`end`: Child items are aligned vertically at the bottom of the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretch`: Child items are stretched vertically to fill the height of the container'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`stretchmax`: Child items are stretched vertically to the height of the largest
    item'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add a border around the screen, we are going to set `frame:true` (`#4`).
    We are also specifying a `controller` (`#2`) and a `ViewModel` (`#3`) for this
    `View` that we are going to create later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is also the `border` configuration that we can set for any panel subclass.
    The `border` configuration when specified as `false` (default value) renders the
    panel with zero width borders. The `frame` configuration when specified as `true`
    applies a frame to the panel.
  prefs: []
  type: TYPE_NORMAL
- en: Working with docked items
  prefs:
  - PREF_H5
  type: TYPE_NORMAL
- en: 'The next step is to add the toolbar with the **Add**, **Edit**, and **Delete**
    buttons, so we are going to `dock` this toolbar on the `top`, and we are going
    to declare it inside the `dockedItems` declaration of the `Packt.view.security.User`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `dockedItems` configuration, we can add a component or a collection
    of components to be added as docked items to the panel or any of its subclasses.
    The docked items can be docked to either the `top`, `right`, `left`, or `bottom`
    of a panel. We can have as many as needed, and it is usually used to declare toolbar
    inside a panel (or any of its subclasses).
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we are adding a toolbar at the `top` (`#1`) of the panel. The
    toolbar has three buttons. For each button, we are going to configure an icon
    with the help of a `glyph` (`#2`) and also the event listener we are going to
    create inside the ViewController (`#3`).
  prefs: []
  type: TYPE_NORMAL
- en: If we take another look at line `#2`, we can see that we have not implemented
    the `Packt.util.Glyphs` class yet. Let's work on it before we dive into the ViewModel
    and ViewController code.
  prefs: []
  type: TYPE_NORMAL
- en: Working with singletons – Ext JS class system
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Let's enjoy the opportunity to create a new utility class for our project and
    dive into some class system concepts of Ext JS.
  prefs: []
  type: TYPE_NORMAL
- en: We already know we can use the Font Awesome CSS in the `iconCls` configuration
    of a button (or any other component that supports it), and we also learned we
    can use the `glyph` configuration as an alternative. The con of using `glyph`
    is declaring code as value (`xf067`), and if we decide to read this code in the
    future or another developer decides to maintain it, it is not very helpful; after
    all, what does `'xf067'` mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can take advantage of the Ext JS class system—most specifically the `singleton`
    classes—to create a utility class that will take care of this for us. Let''s take
    a look at the code of the `Packt.util.Glyphs` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The idea is to declare the glyph code inside configurations of the class (`#2`)
    and use them as a key to retrieve a `glyph` code. `Packt.util.Glyphs.getIcon('add')`
    is easier to understand than `'xf067'`. We can reuse it throughout the application,
    and if we want to change the code for the **Add** button, we can change the `Glyphs`
    class, and the code is changed for the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: Let's understand the previous code. We started declaring a class, but in line
    `#1`, we have `singleton:true`. This means the class will be instantiated as a
    singleton, which means only one instance of this class can be created.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about singletons, please visit [http://en.wikipedia.org/wiki/Singleton_pattern](http://en.wikipedia.org/wiki/Singleton_pattern).
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have the `config` of the class (`#2`). Inside `config`, we can declare
    the attributes of the class. For each attribute, Ext JS is going to generate a
    getter method and a setter method. For example, the `webFont` attribute can be
    retrieved as `this.getWebFont()` as showed in line `#5`.
  prefs: []
  type: TYPE_NORMAL
- en: The method `getGlyph` (`#4`) will be the responsible for returning a string
    with the `glyph` code + `'@'` + name of the font. If the `glyphFontFamily` is
    set, we do not need to specify the font.
  prefs: []
  type: TYPE_NORMAL
- en: In line `#3`, we have `constructor`. A class constructor is the class method
    that gets invoked immediately when a new instance of that class is created. Inside
    the constructor, we call the `initConfig` method. Calling `initConfig` inside
    the constructor initializes the configuration for the class.
  prefs: []
  type: TYPE_NORMAL
- en: This class can be modified if we need to work with different font icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'We cannot forget to add the `requires` in the classes where we are going to
    use this class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Panel versus Container versus Component
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Before we continue, let's take a look back on what we have learned so far. We
    have created a few views. In some of them we used the component class, in others
    we used container, and in others, still we used panel. Can you tell the difference
    between them? When do you use component, container, or panel?
  prefs: []
  type: TYPE_NORMAL
- en: The component is the base class for all Ext JS components (widgets). It has
    built-in support for basic hide/show, enable/disable, and size control behavior.
    Visually speaking, there is no style. We can set HTML content and set styles using
    one or more `'cls'` configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The container is the base class that can contain other components (`items` configuration).
    It is also the base class that uses the layouts we are covering in this book (border,
    fit, VBox, anchor, accordion, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: The panel class is a container with more capabilities. The panel has a header
    that we can set a title and add tools (useful buttons, such as collapse and expand,
    among others) to and it also support docked items (toolbars).
  prefs: []
  type: TYPE_NORMAL
- en: So, whenever you want to create a new Ext JS widget, you need to ask yourself,
    "What do I need to have in this widget?". If it is HTML content, we use a component.
    If we need to have items, or if we need a container to organize the layout of
    the children items, we can use a container. If we need to set a `title` or have
    a toolbar inside it, then we use a panel. Because the panel class has more capabilities,
    it is also a heavier component.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Using the right widget can also help to boost the application performance.
  prefs: []
  type: TYPE_NORMAL
- en: In this example, we could `move` the toolbar inside the `UserGrid` class. To
    organize the layout, we could transform the `User` class in a container. If we
    only wanted to display the `UserGrid` class, we would not need the `User` class
    at all. This could avoid a bad practice called over-nesting. Over-nesting is using
    an additional container that does not do anything besides containing another component.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring the User ViewModel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we use the MVVM architecture, we declare the Model, and then we declare the
    View. The next step would be declaring the ViewModel. To do so, we are going to
    create the class `Packt.view.security.UserModel`, which is the ViewModel for the
    `Packt.view.security.User` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the naming convention we are using. The View name is `User`, so the ViewModel
    will be the name of the View + '`Model`'.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the `ViewModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: You learned that we can set the predefined data in the `ViewModel` class in
    [Chapter 3](ch03.html "Chapter 3. The Login Page"), *The Login Page*. Now we are
    configuring ViewModel to load data from a `store` (`#1`) that we are declaring
    and creating (`#2`) at the same time. The Store `users` (this would be the Store
    ID) is a collection of the Model User, and we are also asking the Store to load
    automatically (`#3`) (we do not need to call the method load manually).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the ViewModel will be created when the View is created, the Store will be
    loaded when the View is created as well. It is a different approach than declaring
    the Store as a standalone Store with `autoLoad true`—in this case, the Store will
    be created when the application is loaded and will retrieve the information from
    the server as well.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of creating the Store inside the ViewModel, we could create the file
    representing the Store inside the store package and make a reference here. This
    Store also does not have a proxy since we declared it inside the Model (specifically
    inside the schema for reuse purposes).
  prefs: []
  type: TYPE_NORMAL
- en: Working with ViewModel data binding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let's go back to the `UsersGrid` class. We have not declared a store, which
    is required. We will do it using data binding and referencing the user's Store
    created in the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `UsersGrid` class, we are going to add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This means the `UsersGrid` will be bound to the users Store. As the `UsersGrid`
    is a child component of the `User` class that refers the User ViewModel, the `UsersGrid`
    class will also have access to the ViewModel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we will go back to the `User` view class to add another data binding.
    We will add the following code to the **Edit** and **Delete** buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We want the **Edit** and **Delete** buttons to be enabled only when the user
    selects a row from the Grid. If no row is selected, there is no point in clicking
    on the **Edit** or **Delete** buttons. So we are going to enable or disable the
    button according to this constraint. It is bound with the `usersGrid` (`reference`
    of the `UsersGrid` class) and the attribute selection of the Grid.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also cannot forget to add the ViewModel to the `requires` from the `User`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Our code is complete so far. Time to listen to some events!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the User ViewController
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next step is creating the ViewController for the `User` class, so we are
    going to create the `Packt.view.security.UserController` class.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note the naming convention we are using. The View name is `User`, so the ViewController
    will be the name of the View + '`Controller`'.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the following code to the ViewController class. It contains the
    method signature of all events and internal methods we are going to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we dive into each method, go back to the `User` View, and add the ViewController
    to the `requires` declaration as well so that we can run and test what we coded
    so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To be able to execute the code, we also need to execute `UPDATE` on the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This will update the `className` column from `menu table` to match the `xtype`
    configuration we created for the `User` class, which is the View we want to be
    opened when a user clicks on the **Users** option from the menu.
  prefs: []
  type: TYPE_NORMAL
- en: 'Reloading the project, we will be able to see the list of all users from the
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the User ViewController](img/0457OT_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Adding and editing a new user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that we are capable of listing all the users of the application, we can
    implement the **Add** and **Edit** buttons capability. But before we start adding
    new event listeners to the controller, we need to create the new view that we
    are going to display to the user to edit or add a new user.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Edit View – form within a window
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This new view is going to be a window since we want to display it as a popup,
    and inside this window, we will have a form with the user''s information, and
    then, we will have a toolbar at the bottom with two buttons: **Cancel** and **Save**.
    It is very similar to the Login window that we developed in [Chapter 3](ch03.html
    "Chapter 3. The Login Page"), *The Login Page*, but we will add new capabilities
    to this new form, such as file upload and also a preview file using HTML5 features.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The view we are going to create looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the Edit View – form within a window](img/0457OT_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'So, let''s get started and create a new class named `Packt.view.security.UserForm`
    that is going to `extend` from the window class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'There are three very important things that we need to notice in this class:
    the first one is that we are not using the `autoShow` attribute. And the purpose
    is that we can create the window, and then we display it calling the method `show()`
    manually.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The second one is the data binding in line `#1`. We want to use data binding
    to automatically set the `title` of the window (Add new user or Edit: name of
    user). This is one of the advantages of the MVVM architecture.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The third thing is the `layout` that we are using on the form. It is not the
    default `layout` used by the form component (which is the Anchor layout). We are
    going to use the `hbox` layout (`#3`) because we want to organize the form''s
    items horizontally. And we want the items to occupy all the available vertical
    space, so we will use the `align: ''stretch''`—we do not want to set `height`
    for each form `items`.'
  prefs: []
  type: TYPE_NORMAL
- en: And at last, we learned in [Chapter 3](ch03.html "Chapter 3. The Login Page"),
    *The Login Page*, how to validate the form using form validations. In this chapter,
    we will validate the form using `modelvalidations` (`#2`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the first item to our form. If we take a look at the window screenshot
    at the beginning of this topic, we will notice that we are going to use two fieldsets
    to organize the form `items`. So the first one will be a `fieldset` to organize
    all the "`User Information`", as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As the form is using the `hbox` layout, we need to specify how much space this
    component will occupy (`#4`). When working with the HBox or VBox layouts, the
    space occupied by the child component is calculated based on the proportional
    space configured. If we have five items with `flex: 1` each, then the total sum
    will be five; each item will occupy one-fifth of the available space. Or, we can
    also set `width` (HBox) or `height` (VBox) for some items, and the remaining space
    will be divided among the items with the `flex` configuration. In this example,
    we will use `flex: 1` for this `fieldset`, and for the next one we are going declare,
    we will use a fix width, so this `fieldset` will occupy all the remaining available
    space.'
  prefs: []
  type: TYPE_NORMAL
- en: The `fieldset` will also use the `anchor` layout (`#5`), which allows you to
    anchor the items relative to the container's dimensions. The `anchor` layout is
    the default layout for forms, but as we are using a fieldset, we need to specify
    the layout as well. For each item, we can specify the `anchor` configuration (`#7`).
    As we want the child items occupying all the available width within the fieldset,
    we set the `anchor` configuration to `100%`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For all required items, we will add a red asterisk (`#6`). Instead of adding
    the HTML for each form we use, we can add this value to our `Util` class and reuse
    it among other forms as well. Inside the `Packt.Util.util` class, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We are also telling the fieldset that the default `xtype` of the items will
    be `textfield`. If any of the declared fields does not need these default configurations,
    we will override them with other values. So, let''s declare the fields that will
    be part of the `items` configuration of the "`User Information`" fieldset:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `id` field will be `hidden` because we do not want the user to see it (we
    will use it only internally), and the `userName`, `name`, and `email` are simple
    textfields. Note that for each field, we declared a `name` (`#8`) and the `bind`
    (`#9`) configuration. As we are going to use a file upload capability, we will
    need to send the form information using the Ajax submit, and that is why we need
    to set a `name` configuration for each field. To avoid having to set the values
    of the form manually, we are going to use data binding from the ViewModel. We
    will set a variable named `currentUser` in the ViewModel that will refer to the
    current selected row of the `UsersGrid`.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we have a combobox. When working with comboboxes, we need to set a Store
    to feed the information to it. In this case, we will bind (`#16`), the `store`
    of this combobox, with Store `groups` from the ViewModel. We will create the Store
    in a minute. The Store can represent a Model that has different fields. We can
    specify which field from the Model will be used as an internal value (`#11`) and
    which field will be displayed to the user (`#10`).
  prefs: []
  type: TYPE_NORMAL
- en: We can also specify other options such as forcing the user to select a value
    from the combobox (`#13`) and not allowing the user to write anything on it (`#14`)—as
    writing is autocomplete. As we will have the Store already loaded for this combobox,
    we can set the query mode to be `local` (`#15`). The default behavior is that
    whenever the user clicks on the combobox trigger, the Store is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the binding for this field is more complex than for the other ones.
    We have three values bound; the store that we already mentioned (`#16`); the value,
    which refers to the `groups_id` foreign key (`#15`) of the `User` Model and the
    `selection` (`#17`), which will refer to the `group` object from the `User` Model
    (referring to the `Group` selected).
  prefs: []
  type: TYPE_NORMAL
- en: Then we have the file upload field. This field will not be mandatory, so we
    do not want it to display that red asterisk (`#18`) by overriding the `defaults`
    configuration. We also want to use a preview capability, so we are also going
    to add a `listener` declaration to this field (`#19`). Whenever the user selects
    a new picture, we will display it in the fieldset we are going to declare next
    (we are going to talk about the preview capability later in this chapter).
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the first `fieldset` that will be displayed on the left-hand side of
    the form. Next, we need to declare the other `fieldset` that is going to wrap
    the `Photo` and will be displayed on the right-hand side of the form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this `fieldset`, we will declare a fixed `width` (`#19`). As the form uses
    the HBox layout, when a component has a fixed `width`, the layout will respect
    and apply the specified `width`. Then, the first `fieldset`, which has the `flex`
    configuration, will occupy all the remaining horizontal space.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the picture fieldset, we will use an `Ext.Image Component`. The `Ext.Image`
    (`#20`) class helps us to create and render images. It also creates an `<image>`
    tag on the DOM with `src` (`#21`) specified. The `src` attribute is also bound
    to the picture field of the `User` Model. We also declared a reference to work
    with the preview capability later (`#20`).
  prefs: []
  type: TYPE_NORMAL
- en: When we load an existing `User` and try to edit the form, we will display the
    user's image on this component (if any). Also, if the user uploads a new image,
    the preview will also be rendered in this component.
  prefs: []
  type: TYPE_NORMAL
- en: 'And now, the last step is to declare the bottom toolbar with the **Save** and
    **Cancel** buttons, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: As we want to align the buttons on the right-hand side of the toolbar, we will
    use the `hbox` layout as well and organize (`#22`) the buttons to the right toolbar.
    The Edit/Add window is now ready. However, there are a few other details that
    we still need to take care of before implementing the Add and Edit listeners on
    the Controller.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Group Model
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'On the `Group` combobox, we declared a `groups` Store used to load all the
    `Groups` from the database. Now, we need to implement this missing Store, and
    the first step to do so is create the Model that is going to represent a Group
    record from the `group` table. So we are going to create a new Model named `Packt.model.security.Group`,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As the `group` table is very simple, it only contains two columns, `id` and
    `name`; our `Group` Model is also simple with only these two fields. As the `Group`
    Model is extending from the `Base` Model we created in the beginning of this chapter,
    the `id` column will come from the `Base`, `schema`, and `proxy` configurations.
  prefs: []
  type: TYPE_NORMAL
- en: The Groups Store
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we already created the `Group` Model, now we need to create the `groups`
    Store.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Always remember the naming convention: the Model name is the singular name
    of the entity you want to represent and the Store is the plural of the name of
    the Model/entity.'
  prefs: []
  type: TYPE_NORMAL
- en: 'So we will create a new `Store` inside the `UserModel` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Following the same pattern as the other stores, the `groups` information will
    be sent by the server within a data attribute in the JSON as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Now all the views, models, and stores needed for our user management module
    are created. We can focus on the ViewController to handle all the events we are
    interested in listening to and implementing all the magic!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For all the server-side code of this chapter, and the group management code,
    please download the source code bundle of this book or go to [https://github.com/loiane/masteringextjs](https://github.com/loiane/masteringextjs).
  prefs: []
  type: TYPE_NORMAL
- en: Controller – listening to the Add button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first event that we will implement for the Edit or Add Window is the Add
    event. When the user clicks on the **Add** button, we want to display the **Edit**
    user window (the `Packt.view.security.UserForm` class).
  prefs: []
  type: TYPE_NORMAL
- en: 'The button **Add** already has a listener. So all we need to do is add the
    code in the ViewController:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'If the user clicks on the **Add** button, we want to open a blank popup so
    that user can enter the new record information and save it. If the user clicks
    on the **Edit** button, we want to open the same popup with the data from the
    selected row from the Grid. So, for the **Add** button, we will open the popup
    passing null (no row selected). The `createDialog` method is listed in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We start getting a reference (`#1`) to the `User` View class reference, since
    the ModelView was declared inside it.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to create the `UserForm` window (`#2`) and assign it to a
    variable dialog that belongs to the ViewModel scope (the method add returns the
    instance of the component created). We are also adding the `UserForm` window to
    the `User` View (you might remember that we used the VBox layout instead of the
    Fit layout; this is the reason). When adding the `UserForm` window as an item
    of the `User` View, this item will also have access to the ViewModel associated
    to its parent. In this case, we want to add more details to the Window's ViewModel
    (as a child ViewModel—(`#3`)). We are going to add a predefined field named `title`
    (that we used to set the window's title—(`#4`)). And we are also going to create
    a `link` (`#5`). Links provide a way to assign a simple name to a more complex
    bind. The primary use for this is to assign names to records in the data model.
    If there is an existing `record` (from `Edit`—(`#6`)), it uses a copy of it, and
    if not, it creates a new phantom record (`#7`).
  prefs: []
  type: TYPE_NORMAL
- en: Controller – listening to the Edit button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to edit an existing user, the **Edit** button will fire the click
    event, and the ViewController will listen to it through the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we are going to get the selected `records` from the Grid (`#1`). If a
    record (`#2`) was selected, we are going to create the window passing the record
    (`#3`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The method `getRecordSelected` is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We are going to get a reference of the `UsersGrid` (`#4`), and by accessing
    its `getSelection` method, we can get the rows selected (`#5`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The `getSelection` method returns an array of the selected records. That is
    why we are using `records[0]` to access the selected row. By default, a Grid allows
    you to select only one row at a time. This can be changed by setting the following
    configuration in the Grid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, a Grid allows you to select only one row at a time; this can be
    changed using the `selType: ''checkboxmodel''` (`Ext.selection.CheckboxModel`).'
  prefs: []
  type: TYPE_NORMAL
- en: The validation in `#2` is an extra step as we are binding the **Edit** button
    directly to the `selection` configuration of the Grid, but to be careful and avoid
    exceptions in the code is never too much!
  prefs: []
  type: TYPE_NORMAL
- en: Controller – listening to the Cancel button
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the user decides not to save the user information, it is possible to click
    on the **Cancel** button that is going to fire the click event to execute the
    following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'What we want to do is very simple: if the user wants to cancel all the changes
    made to an existing user or wants to cancel the creation of a user, the system
    will `destroy` the window. We can use `Ext.destroy` to destroy it or call the
    method `destroy` as well. At the same time, `me.dialog` will lose the reference
    as well.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about JavaScript memory leaks, go to [http://javascript.info/tutorial/memory-leaks](http://javascript.info/tutorial/memory-leaks).
    To learn more about the importance of the garbage collector (freeing up memory)
    go to [http://goo.gl/qDdwwt](http://goo.gl/qDdwwt).
  prefs: []
  type: TYPE_NORMAL
- en: Controller – saving a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now that the user is able to open the window to create or edit a `User`, we
    need to implement the **Save** button logic. No matter if the user is creating
    a new user or editing an existing user, we will use the same logic to save the
    user. We will let the server side handle this if it needs to use an `UPDATE` or
    `INSERT` query.
  prefs: []
  type: TYPE_NORMAL
- en: 'The ViewController will execute the following method to save the information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The first step is to get the form reference (`#1`). Then, we will verify that
    the form is valid ((`#2`) the user filled the form with valid values following
    all the rules of the model validations (`#4`) that we are going to implement),
    after which we will submit the form to the given `url` (`#5`).
  prefs: []
  type: TYPE_NORMAL
- en: We could use the Store features to create and edit the User (as we will see
    later in this book). However, we are using a different approach, which is the
    form submit method to directly send the values to the server, because we are also
    uploading a document to the server. When uploading a document to the server, it
    is not possible to use the Store capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Before we list the success and failure callbacks, take a look at the code again
    at the line `var me = this`. Whenever we have more than one reference to this
    or we work with callbacks, we do this assignment.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are two reasons to use `me` instead of `this` (or you can create other
    variable names according to your preference (`that`, `self`)). The first one is
    when "`this`" is used a lot in a method, using "`me`" can save 16 bits each reference.
    After we do the production build, Sencha Cmd will replace `me` with `a`, `b`,
    or any other letter. The keyword `this` cannot be replaced with `a`, `b`, or any
    other value, therefore it will use four characters instead of only one.
  prefs: []
  type: TYPE_NORMAL
- en: The second reason is that we can keep a reference to `this` inside a scope in
    which `this` refers to something else (like a callback function, for example,
    the form `submit`—if we used `this` inside the `submit`, it would make a reference
    to the `submit` method itself and not the ViewController).
  prefs: []
  type: TYPE_NORMAL
- en: This way a callback function can refer to a function or variable that was declared
    in the outer function (ViewController in this example). This is called closure.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn about how to handle file upload in PHP by downloading the source
    code from this book. If you are using another language or for some reason a form
    submit is not working, always inspect the request in the *Developer Tools* of
    the browser you are using to see what is being sent to the server. The following
    screenshot exemplifies what is being sent while creating a new user:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controller – saving a user](img/0457OT_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The next steps now are to implement the `success` and `failure` callbacks.
    Let''s implement the `success` callback first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'If the server returns success as `true`, we will call the method `onCancel`
    that is responsible for closing and destroying the window (`#7`) that we implemented
    in the previous topic. As we are using a form submit to send the information to
    the server, we need to refresh (`#8`) the Store to get the new information from
    the server. And at last, we will display a toast (introduced in Ext JS 5) with
    a success message (`#9`) as shown by the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controller – saving a user](img/0457OT_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The refresh method is listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Inside the `refresh` method, we get the reference to the `users` Store and call
    its method `load` to get the information from the server again.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the `showToast` static method from the `Packt.util.Util` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `Ext.Toast` class provides lightweight, auto-dismissing pop-up notifications
    called toasts. We can set its content (`html`), a title, a **close** button, the
    alignment (in our example, it will be displayed at the top), how many seconds
    it will be displayed (4 seconds) and its width, among other options that we can
    check in the Ext JS documentation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let''s implement the `failure` callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'In [Chapter 3](ch03.html "Chapter 3. The Login Page"), *The Login Page*, we
    also handled a form failure callback. The code we are going to use here is exactly
    the same. As we are starting to repeat code, we can create another static function
    in the `Util` class so that we can reuse it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: The difference is now that this code is inside the `Packt.util.Util` class,
    we can refer to it to call the `showErrorMsg` method (`#1`).
  prefs: []
  type: TYPE_NORMAL
- en: We can also go back to `LoginController` and replace the failure callback code
    with the call of the `handleFormFailure` function.
  prefs: []
  type: TYPE_NORMAL
- en: Our save code is now ready.
  prefs: []
  type: TYPE_NORMAL
- en: Using Model validators
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: As we implemented the save method, let's use the opportunity to complete the
    code to validate the form with Model validators.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to add the following code to the `User` Model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can have the following types of Model validators:'
  prefs: []
  type: TYPE_NORMAL
- en: '`presence`: This ensures that the field has a value. Zero counts as a valid
    value, but empty strings do not.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`length`: This ensures that a string is between `min` length and `max` length.
    Both constraints are optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: This ensures that a string matches a regular expression format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`inclusion`: This ensures that a value is within a specific set of values (for
    example, ensuring gender is either male or female).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`exclusion`: This ensures that a value is not one of the specific set of values
    (for example, blacklisting usernames like "admin").'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`email`: This ensures that the value is a valid e-mail.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`range`: This ensures that the value is between a `min` and a `max`. Both constraints
    are optional.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each validator has a default `message` just in case the validation is not met.
    We can also override it.
  prefs: []
  type: TYPE_NORMAL
- en: Previewing a file before uploading
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'One last thing that we will implement related to the window: the file upload
    preview. This is something that is not that hard to implement, and it will bring
    a sparkle to the application user''s eyes!'
  prefs: []
  type: TYPE_NORMAL
- en: 'So what we want to do when the user selects a new file using the file upload
    component is read the file using the HTML5 FileReader API. Unfortunately, not
    every browser supports the FileReader API; only the following versions do: Chrome
    6+, Firefox 4+, Safari 6+, Opera 12+, Explorer 10+, iOS Safari 6+, Android 3+,
    and Opera Mobile 12+. But do not worry, we will verify that the browser supports
    it first, and if it does not, we will not use it, which means that the file preview
    will not happen.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about the FileReader API, please read its specification at [http://www.w3.org/TR/file-upload/](http://www.w3.org/TR/file-upload/),
    and to learn more about this and other HTML5 features, go to [http://www.html5rocks.com/](http://www.html5rocks.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'When the user selects a new file using the Ext JS file upload component, the
    change event is fired, so we need to listen to it in our ViewController. The following
    code exemplifies what was discussed in this paragraph:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So first, we need to get the file (`#1`) object that is stored inside the file
    input element of the Ext JS File field component (also passed as a parameter to
    our method). Then, we will get a reference of the `Ext.Image` component that is
    inside our form so that we can update its `source` to the file preview.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will also test whether the FileReader API is available on the browser and
    also whether the file that the user chose is an image (`#3`). If positive, we
    will instantiate a `FileReader` method (`#4`); we will add a listener to it (`#4`),
    so when the FileReader is done reading the file, we can set its contents to the
    `Ext.Image` source (`#6`). And of course, to fire the `onload` event, the FileReader
    instance needs to read the contents of the file (`#7`). One very important note:
    we are displaying the contents of the file before we upload to the server. If
    the user saves the changes made to the form, the new user information will be
    sent to the server (including the file upload), and the next time we open the
    window, the picture will be displayed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How do you get the full path of the file that is being uploaded? For example,
    the Ext JS file upload component displays `C:\fakepath\nameOfTheFile.jpg`, and
    we want to get its real path, such as `C:\Program Files\nameOfTheFile.jpg`. The
    answer is: it is not possible to do it with JavaScript (and Ext JS is a JavaScript
    framework).'
  prefs: []
  type: TYPE_NORMAL
- en: This is not a restriction from Ext JS; if we try it with any other JavaScript
    framework or library, such as jQuery, it is not going to be possible because this
    is a browser security restriction. Imagine if it was possible. Someone could develop
    a malicious JavaScript file and run it while you are navigating on the web and
    get all the information that you have on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another really nice thing: if the file that the user chose is not an image
    (`#8`), we will display a message saying that only images can be uploaded, and
    we will reset the file upload component. Unfortunately, it is not possible to
    filter the file types on the browse window (the one that opens so we can choose
    a file from the computer), and this is a wayaround, so we can do this validation
    on the Ext JS side and not leave it to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: And if the FileReader is not available, nothing is going to happen. The file
    preview is simply not going to work. The user will select the file and that's
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The file size limit that you can upload depends on the upload limit that is
    set on the web server that you are going to deploy the Ext JS application in.
    For example, Apache supports a limit of 2GB. IIS has a default value of 4MB, but
    you can increase it to 2GB as well. Likewise for Apache Tomcat and other web servers.
    So the size limit is not on Ext JS; it is on the web server, and you just need
    to configure it.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting a user
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last CRUD operation that we need to implement is the delete user. So let''s
    add the delete listener to the ViewController, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The idea of this method is to verify that the user selected any row from the
    grid to be deleted (`record[0]` exists—(`#1`)) and also, we will only delete a
    user if there are more than two users on the application (`#3`). If yes, we will
    delete the user. If not, this means there is only one user in the application
    (`#8`), and we cannot delete the only user that exists.
  prefs: []
  type: TYPE_NORMAL
- en: If it is possible to delete the user, the system will display a question asking
    whether we really want to delete the selected user (`#4`). If the answer is `yes`
    (`#5`), we will get the `store` reference (`#2`) and use its `remove` method (`#6`)
    passing the records to be deleted, and will send this request to the server (`#7`).
    The `proxy` will call the `destroy` URL when the `sync` method is called.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Just remember that on the server, you can execute a `DELETE` query on the database,
    but in most cases we do a logical deletion, which means we will perform an `UPDATE`
    on a column active (in this case update the user to inactive).
  prefs: []
  type: TYPE_NORMAL
- en: Displaying the group name in the Grid
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a few ways we can display associated data in the Grid. We will use
    one approach in this example, and in other chapters, we will use different ones.
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach we are going to use is to add a `hasOne` association to the `User`
    Model as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we are using the same schema in the `User` and `Group` models, we can refer
    to the `Group` Model only by its `entityName` (`#1`). We can also give a name
    of the object that is going to come from the server with the `Group` information
    (`#2`). And at last, Ext JS also needs to know which field contains the foreign
    key to the `Group` Model (`#3`).
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we are going to add a new field in the user Model as well, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This field will be created in runtime when a `User` Model is created. We are
    not going to persist this information, which means that whenever the Store sends
    a create, update, or destroy request to the server, this field will not be included.
    For this field, we are also going to declare a `convert` function, which means
    that the information for this field will be created from another existing field.
    If there is `group` information available, we will return its `name`; otherwise,
    we return the `groups_id` anyway.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, in the `UsersGrid` class, we will replace the current `dataIndex` of
    the `groups_id` column with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: And the Grid will display the name of the group instead of its ID.
  prefs: []
  type: TYPE_NORMAL
- en: We can refresh the application and test all functionalities from this chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered how to create, update, delete, and list all the
    users from our application.
  prefs: []
  type: TYPE_NORMAL
- en: While we developed this module, we covered some important Ext JS concepts and
    some features introduced in Ext JS 5\. We developed this module using MVVM, and
    we covered some other ModelView capabilities, such as data binding. We learned
    how to use a schema in the Model and validate a form using Model validation. We
    also explored a new HTML5 feature for the file upload preview capability, which
    is another example of how we can use other technologies along with Ext JS.
  prefs: []
  type: TYPE_NORMAL
- en: In this next chapter, we will implement the MySQL table management module, which
    means we will implement a screen very similar to the **Edit** table data screen
    that we find in the MySQL Workbench application.
  prefs: []
  type: TYPE_NORMAL
