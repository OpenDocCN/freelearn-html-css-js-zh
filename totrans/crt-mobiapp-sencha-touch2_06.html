<html><head></head><body><div class="chapter" title="Chapter&#xA0;6.&#xA0;Catalog Application and API"><div class="titlepage"><div><div><h1 class="title"><a id="ch06"/>Chapter 6. Catalog Application and API</h1></div></div></div><p>In this chapter we are creating a simple catalog application that allows you to enter in items for sale and assign them to a category. From an interface and functionality aspect, this will be similar to the previous applications we have created. The difference here is that we are going to explore creating our own API to create, read, update, and delete data from your application.</p><p>In this chapter we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">What is an API?</li><li class="listitem" style="list-style-type: disc">Creating the basic application</li><li class="listitem" style="list-style-type: disc">Getting started with an API</li><li class="listitem" style="list-style-type: disc">Using PHP to create an API</li><li class="listitem" style="list-style-type: disc">Connecting the API and the application</li></ul></div><div class="section" title="What is an API?"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec40"/>What is an API?</h1></div></div></div><p>An <span class="strong"><strong>API</strong></span>
<a id="id571" class="indexterm"/> is an <span class="strong"><strong>Application Programming Interface</strong></span>, which is simply a way to make data stored in one place available to a remote application.</p><p>Remember our first problem with local storage? The data is stored on the device, which limits its usefulness in a number of ways. If we store the data separately from the device (on a server), we can allow multiple devices to access the data, we can limit and secure the data through authentication, and we can back up the entire data set for all our users.</p><p>When we store data separately from the application, we need a way to get to it and make changes. This is where the API comes in. In the last chapter, we used the Sencha.io API to store and retrieve data. In this chapter, we will explore how to create your own API.</p><p>The API is a set of code files written in a server-side language such as <a id="id572" class="indexterm"/>PHP, Ruby<a id="id573" class="indexterm"/>, <a id="id574" class="indexterm"/>ASP, or Perl<a id="id575" class="indexterm"/>. The JavaScript code sends data to these files as part of an HTTP request (<code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, or <code class="literal">DELETE</code>). In the case of <a id="id576" class="indexterm"/>Sencha Touch, this data is typically sent formatted either as JSON<a id="id577" class="indexterm"/> or<a id="id578" class="indexterm"/> XML. The server-side language will then parse the data and send it to the database as SQL statement. The database returns a result, which gets translated by the server-side language back into JSON and returned to the browser.</p><p>The entire process would look like this:</p><div class="mediaobject"><img src="graphics/8901OS_06_01.jpg" alt="What is an API?"/></div><p>That's a lot <a id="id579" class="indexterm"/>of acronyms for a single paragraph, so let's break this down into smaller pieces. Let's assume that you want to add some new user data: a name, an email address, and a phone number. In its most basic form, we can use a browser URL to send this information as:</p><p>
<a class="ulink" href="http://mydomain.com/myapifile.php?action=add&amp;&amp;name=john&amp;&amp;email=john@mydomain.com&amp;&amp;phone=555-1212">http://mydomain.com/myapifile.php?action=add&amp;&amp;name=john&amp;&amp;email=john@mydomain.com&amp;&amp;phone=555-1212</a>
</p><p>This would allow our server-side language (we will use PHP for this example) to grab the data we sent and process it correctly. This might look something like this:</p><div class="informalexample"><pre class="programlisting">&lt;?php
 $action = $_GET["action"];
 $name = $_GET["name"];
 $email = $_GET["email"];
 $phone = $_GET["phone"];
?&gt;</pre></div><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note30"/>Note</h3><p>Please note this is only an example; you would almost certainly want to filter and sanity check any incoming data. Since we are not going to cover all of PHP here, we will only talk about the server-side code in very general terms. It is not intended for actual use, just as a general idea of how things work.</p></div></div><p>Now that the PHP has our variables it can convert them into something our server-side database can understand:</p><div class="informalexample"><pre class="programlisting">if($action == "add") {
 $sql = "INSERT INTO users VALUES($name, $email, $phone)";
 $results = $db-&gt;query($sql);
}</pre></div><p>This would pass the data from PHP to a database (like MySQL). The database then returns a result, which we can then loop through to create a new array that matches the format we need. We can then format the results as JSON and echo it back:</p><div class="informalexample"><pre class="programlisting">foreach($results as $result) {
  $newArray[$result['key']] = $result['value'];
}
json_encode($newArray);

print $result;</pre></div><p>As previously noted, this is a very raw general example and APIs can get very complex, very quickly. Fortunately for us, Sencha Touch handles some of this work automatically.</p><div class="section" title="Using a remote API in Sencha Touch"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec64"/>Using a remote API in Sencha Touch</h2></div></div></div><p>When using Sencha Touch, the <a id="id580" class="indexterm"/>JavaScript side of an API becomes a lot easier<a id="id581" class="indexterm"/> to manage. We can accomplish most of what we need using the store and a model. Following our previous example, we would create a model that looks like this:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.model.User', {
    extend: 'Ext.data.Model',
    config: {
        idProperty: 'id',
        fields: [
            {name: 'id', type: 'int'},
            {name: 'name', type: 'string'},
            {name: 'email', type: 'string'},
            {name: 'phone', type: 'string'}
        ]
    }
});</pre></div><p>This sets up our simple model with a unique <code class="literal">id</code>, <code class="literal">name</code>, <code class="literal">email</code>, and <code class="literal">phone</code> fields. However, we can also add a <code class="literal">proxy</code> setting <a id="id582" class="indexterm"/>and <code class="literal">api</code> definition to this (right after we finish declaring the fields):</p><div class="informalexample"><pre class="programlisting">proxy: {
  type: 'scripttag',
  url: 'api/Users.php',
  reader: {
    type: 'json',
    root: 'children'
  },
  api: {
    create: 'api/Users.php?action=create',
    read: 'api/ Users.php?action=read',
    update: 'api/ Users.php?action=update',
    destroy: 'api/ Users.php?action=destroy'
  }
}</pre></div><p>In this example, <a id="id583" class="indexterm"/>we are using a <code class="literal">scripttag</code> proxy. Later on in the chapter <a id="id584" class="indexterm"/>we are going to use a different proxy, called a <code class="literal">rest</code> proxy<a id="id585" class="indexterm"/> for the actual application. You should get a feel for the various types of proxies provided by Sencha Touch, and use the one that best suits your application and needs.</p><p>The <code class="literal">scripttag</code> proxy<a id="id586" class="indexterm"/> allows us to communicate with another domain (if the PHP and Sencha Touch code are running on the same domain, an <code class="literal">ajax</code> proxy<a id="id587" class="indexterm"/> should be used instead).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note31"/>Note</h3><p>As we mentioned in <a class="link" href="ch02.html" title="Chapter 2. A Feed Reader">Chapter 2</a>, <span class="emphasis"><em>A Feed Reader</em></span>, this is due to the same origin policy, which prevents cross-domain attacks in JavaScript. If you would like to learn more about this origin policy, this Wikipedia article is a good place to start:</p><p>
<a class="ulink" href="http://en.wikipedia.org/wiki/Same_origin_policy">http://en.wikipedia.org/wiki/Same_origin_policy</a>
</p></div></div><p>The <code class="literal">url</code> property<a id="id588" class="indexterm"/> tells the model where to send information for creating, reading, updating, and destroying users (often referred to as<a id="id589" class="indexterm"/> <span class="strong"><strong>CRUD</strong></span> functions).</p><p>The <code class="literal">reader</code> property<a id="id590" class="indexterm"/> tells the model where to look for the data when it gets back a JSON encoded list of users.</p><p>Finally, the <code class="literal">api</code> section tells the model which URLs to use for each of our CRUD functions. This API setup allows us to do things such as:</p><div class="informalexample"><pre class="programlisting">var user = Ext.create('User', {
    name : 'Stacy McClendon',
    email  : 'stacy@superhappyfuntimego.com',
    phone: '555-555-5555'
});

user.save();</pre></div><p>We create a new user with all of our information and then call <code class="literal">save</code>. By calling <code class="literal">save</code>, the information is submitted to the <code class="literal">create</code> URL we set up previously in our model.</p><p>Notice that we didn't send an ID. When we create a new user, the database will actually set the unique ID. A properly written API should return this value along with the rest of the user information if the transaction is successful. The JSON that comes back to us should look something like this:</p><div class="informalexample"><pre class="programlisting">{
"totalCount":1,
"children":[
  {
      id:1,
      name : 'Stacy McClendon',
      email  : 'stacy@superhappyfuntimego.com',
      phone: '555-555-5555'
  }
 ]
}</pre></div><p>We can then use this information for any post processing we require.</p><p>We can <a id="id591" class="indexterm"/>also save <a id="id592" class="indexterm"/>changes to an existing user, or delete the user by calling:</p><div class="informalexample"><pre class="programlisting">user.destroy();</pre></div><p>We also use the same proxy when we set up a user store:</p><div class="informalexample"><pre class="programlisting">Ext.define('MyApp.store.UserStore', {
  extend: 'Ext.data.Store',
  model: ' MyApp.model.User',
  requires: [' MyApp.model.User'],
  storeID: 'UserStore',
  emptyText: 'No Users To List',
  proxy: {
    type: 'ajax',
    url: 'api/users.php',
    reader: {
      type: 'json',
      root: 'children'
    },
    api: {
      create: 'api/users.php?action=create',
      read: 'api/users.php?action=read',
      update: 'api/users.php?action=update',
      destroy: 'api/users.php?action=destroy'
    }
  }
});</pre></div><p>This will let us create, read, update, and delete multiple users at once.</p><p>The <code class="literal">api</code> section will be called when we load or sync the store, as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Calling <code class="literal">load()</code> on the store will contact <code class="literal">users.php</code> which should return a list of users</li><li class="listitem" style="list-style-type: disc">Adding new user records to the store and calling <code class="literal">sync()</code> <a id="id593" class="indexterm"/>will contact <code class="literal">users.php</code> and save the new users</li><li class="listitem" style="list-style-type: disc">Updating existing user records in the store and calling <code class="literal">sync()</code> will contact <code class="literal">users.php</code>, and update the records for each user</li><li class="listitem" style="list-style-type: disc">Removing users from the store and calling <code class="literal">sync()</code> will contact <code class="literal">users.php</code>, and destroy the specified user records in the database<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>Defining a <code class="literal">proxy</code> setting on both the model and the store isn't strictly necessary. If your model has a <code class="literal">proxy</code> setting defined and your store does not, then the store will automatically use the model's <code class="literal">proxy</code>.</p></div></div></li></ul></div><p>If you are <a id="id594" class="indexterm"/>using an API you didn't write, you would need to make <a id="id595" class="indexterm"/>sure that you are sending the data and requests in the correct format. Check the documentation for the API you are using to see if there are any additional requirements.</p><p>As you may have noticed, we have been a bit vague on what is happening at the API end of things. This is because each API is a little different in terms of the data they expect, and the data they return.</p><p>Most publicly accessible APIs are fairly well documented, but it is also helpful to have a general idea of what goes into making an API.</p></div><div class="section" title="Creating your own API"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec65"/>Creating your own API</h2></div></div></div><p>At their most basic, APIs perform <a id="id596" class="indexterm"/>three core functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Receive data from a remote source</li><li class="listitem" style="list-style-type: disc">Connect to and modify a database (or other data source)</li><li class="listitem" style="list-style-type: disc">Transmit data to the remote application</li></ul></div><p>When you<a id="id597" class="indexterm"/> create your own API, you will need to account for each of these functions. You can create your API in any server-side language you want, as long as it can handle these three basic things. Let's take a high-level view at each of these functions.</p><div class="section" title="Receiving data"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec09"/>Receiving data</h3></div></div></div><p>When you receive <a id="id598" class="indexterm"/>data <a id="id599" class="indexterm"/>from <a id="id600" class="indexterm"/>an application, you need to figure out what the user is asking for and how they are expecting the answer to be returned.</p><p>When you use the standard Sencha Touch API requests for models and stores, the <code class="literal">create</code>, <code class="literal">read</code>, <code class="literal">update</code>, and <code class="literal">destroy</code> functions are triggered, causing requests to be transmitted to the URLs you specify in the proxy configuration, along with any relevant data for the transaction. You can also send additional data using the <code class="literal">params</code> configuration like so:</p><div class="informalexample"><pre class="programlisting">store.load({
 params:{paramName: paramValue}
});</pre></div><p>Your API will <a id="id601" class="indexterm"/>need to be set up to receive and translate the data and any extra parameters, so that it <a id="id602" class="indexterm"/>can decide what actions to take <a id="id603" class="indexterm"/>and what data to return.</p><p>The first thing you will need to do is determine if the variables are being sent as part of a <code class="literal">GET</code> or <code class="literal">POST</code> request. The server-side language you choose should have methods for dealing with either of these two transmission types.</p><p>As mentioned before, PHP can collect this data using <code class="literal">$_GET["variableName"]</code> and <code class="literal">$_POST["variableName"]</code>. Your chosen language will have similar functions. This data will also be encoded as JSON, so you will need to decode it before you can get to the individual pieces.</p><p>Most server-side languages have functions for dealing with this. For example, PHP uses <code class="literal">json_decode($myJSONData)</code> to transform the JSON data into a PHP array.</p><p>Once the data is collected, it should be checked to make sure that it is something we expected. For example, if our API receives an <code class="literal">action</code> value as <code class="literal">read</code> and an <code class="literal">id</code> value as <code class="literal">DELETE * FROM users</code>, we might not want to send this on to our database. Most languages also have ways to validate data types and sanitize any potentially hostile values.</p><p>Additionally, a store can often combine multiple requests into an array of data. Your code will need to check and see if the data being passed is an array or a single item, and deal with each appropriately.</p></div><div class="section" title="Communicating with the database"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec10"/>Communicating with the database</h3></div></div></div><p>Once you have <a id="id604" class="indexterm"/>your variables and you understand what the user needs to accomplish, you will likely need to make a connection to your database to get or modify the data. For example, if you get an <code class="literal">action</code> value of <code class="literal">read</code> and an <code class="literal">id</code> value of <code class="literal">45</code>, you will likely want to query the database for any users with an <code class="literal">id</code> value of <code class="literal">45</code>.</p><p>Performing this action will require knowledge of how the server-side language you are using connects to a database, and how your database accepts queries for information. You will need to consult the reference guides for your language and database to determine how this is<a id="id605" class="indexterm"/> done.</p></div><div class="section" title="Sending data back to the application"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec11"/>Sending data back to the application</h3></div></div></div><p>Once you have <a id="id606" class="indexterm"/>communicated with the database and you are <a id="id607" class="indexterm"/>ready to send information back to the application, you <a id="id608" class="indexterm"/>will need to encode it correctly in order for Sencha Touch to process it.</p><p>Something to keep in mind is that Sencha Touch expects to receive data encoded as JSON. Most server-side languages have functions for dealing with this. For example, PHP uses <code class="literal">json_encode($myArrayOfData)</code> to bundle up the information into a JSON format.</p><p>Once you have the JSON-encoded data, you can output it directly to the browser using something like PHP's <code class="literal">print</code> or <code class="literal">echo</code> functions.</p></div><div class="section" title="More information on APIs"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec12"/>More information on APIs</h3></div></div></div><p>Now that you have some<a id="id609" class="indexterm"/> idea of how APIs function you can gather some specific data for the server-side language you want to use. For more specific information, take a look at:</p><p>
<a class="ulink" href="http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/">http://www.webresourcesdepot.com/how-to-create-an-api-10-tutorials/</a>
</p></div></div></div></div>
<div class="section" title="Building the basic application"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec41"/>Building the basic application</h1></div></div></div><p>For this chapter, we <a id="id610" class="indexterm"/>will not be going through the entire build process of the application. Instead, we will be focusing mainly on the models, stores, and the basic API. The application itself is composed of a tabbed layout with two tabs. Each of our two tabs is a panel with a Card Layout, one for Items and one for Categories. In turn, these two panels have their own subpanels for listing, showing details, and editing (a list, a panel, and a form panel respectively).</p><div class="mediaobject"><img src="graphics/8901OS_06_02.jpg" alt="Building the basic application"/></div><p>You can take a <a id="id611" class="indexterm"/>look at the application code to see how these components are laid out. The Main Tab Panel and the two Card Layout panels for Items and Categories are part of the <code class="literal">Main.js</code> file. The List, Details, and Edit panels are all separate views inside the <code class="literal">app/views</code> folder. We will come back to the views a bit later, but what we are really interested in for this chapter is the stores and models.</p><div class="section" title="Creating the item model"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec66"/>Creating the item model</h2></div></div></div><p>The model is where <a id="id612" class="indexterm"/>most of the interesting stuff is going on. In the model we will be using two new options: a <code class="literal">rest</code> proxy and model relations.</p><div class="informalexample"><pre class="programlisting">Ext.define('CatHerder.model.Item', {
    extend: 'Ext.data.Model',
    uses: [
        'CatHerder.model.Category'
    ],
    config: {
        idProperty: 'itemID',
        fields: [
            {
                name: 'itemID',
                type: 'int'
            },
            {
                name: 'name'
            },
            {
                name: 'description'
            },
            {
                name: 'price',
                type: 'float'
            },
            {
                name: 'photoURL'
            },
            {
                name: 'categoryID',
                type: 'int'
            }
        ],
        hasOne: {
         model: 'CatHerder.model.Category',
         name: 'category',
         primaryKey: 'categoryID'
           },
            proxy: {
             type: 'rest',
        url: '/api/item'
       }
    }
});</pre></div><p>This starts out in the <a id="id613" class="indexterm"/>same manner as our previous models, but we have a new configuration option called <code class="literal">uses</code>. This option is set to our other model, <code class="literal">CatHerder.model.Category</code>, and tells us that we will have a relationship between our <code class="literal">Item</code> model and our <code class="literal">Category</code> model.</p><p>Below our <code class="literal">fields</code>, we have another new option called <code class="literal">hasOne</code>. This option tells us that each <code class="literal">Item</code> is related to a single <code class="literal">Category</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note32"/>Note</h3><p>You can also use the option <code class="literal">hasMany</code>. This would allow you to set several categories on an item. For the sake of simplicity, we will be going with <code class="literal">hasOne</code> for this example. To see some examples of <code class="literal">hasMany</code>, take a look at <a class="ulink" href="http://docs.sencha.com/touch/2-0/#!/api/Ext.data.association.HasMany">http://docs.sencha.com/touch/2-0/#!/api/Ext.data.association.HasMany</a>.</p></div></div><p>The <code class="literal">hasOne</code> option<a id="id614" class="indexterm"/> includes:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The model we are relating to: <code class="literal">CatHerder.model.Category</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">name</code> property<a id="id615" class="indexterm"/> we will reference to get the related information: <code class="literal">category</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">primaryKey</code> property<a id="id616" class="indexterm"/> indicates the field that is part of our <code class="literal">Item</code> model, which we will use to match the <code class="literal">id</code> property set for our related model, <code class="literal">categoryID</code></li></ul></div><p>This configuration will <a id="id617" class="indexterm"/>let us use the fields in the <code class="literal">Category</code> model the same way as we would use any of the <code class="literal">Item</code> model's other attributes.</p><p>We also have a new type of proxy called a <code class="literal">rest</code> proxy. Unlike the <code class="literal">scripttag</code> proxy we covered earlier, the <code class="literal">rest</code> proxy uses different types of HTTP requests to denote if we are creating, reading, updating, or deleting data.</p><p>The different types of requests include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating a new record will be sent as a <code class="literal">POST</code> request</li><li class="listitem" style="list-style-type: disc">Reading data will be sent as a <code class="literal">GET</code> request</li><li class="listitem" style="list-style-type: disc">Updating an existing record will be sent as a <code class="literal">PUT</code> request</li><li class="listitem" style="list-style-type: disc">Deleting records will be sent as a <code class="literal">DELETE</code> request</li></ul></div><p>Each of these request types will be sent to <code class="literal">api/item</code> for processing. We have done a bit of trickery here with the URLs to make them look a bit cleaner to the user.</p><div class="section" title="RewriteRule and .htaccess"><div class="titlepage"><div><div><h3 class="title"><a id="ch06lvl3sec13"/>RewriteRule and .htaccess</h3></div></div></div><p>Normally we <a id="id618" class="indexterm"/>would <a id="id619" class="indexterm"/>point our model at a particular file as we did in the earlier <code class="literal">scripttag</code> proxy example. In that case we would have done something like:</p><div class="informalexample"><pre class="programlisting">proxy: {
  type: 'rest',
  url: '/api/item.php'
}</pre></div><p>When we want to view a particular item, the URL looks like:</p><p>
<a class="ulink" href="http://myapp.com/api/item.php?item=143">http://myapp.com/api/item.php?item=143</a>
</p><p>However, with a little bit of configuration, we can change that so the URL would look like this:</p><p><a class="ulink" href="http://myapp.com/api/item/143">http://myapp.com/api/item/143</a>
</p><p>This is shorter and much easier to read. It just requires a <code class="literal">RewriteRule</code> directive and a <code class="literal">.htaccess</code> file.</p><p>The <code class="literal">.htaccess</code> file<a id="id620" class="indexterm"/> is used by the Apache web server to determine a number of options and configurations for the server you are using. These options can be set by creating or editing the <code class="literal">.htaccess</code> file in the <code class="literal">api</code> directory of your application. In this case, we will create one with the following information:</p><div class="informalexample"><pre class="programlisting">RewriteEngine on
# Send item requests to item.php
RewriteRule ^item(/.*)?$ /api/item.php [L]

# Send category requests to category.php
RewriteRule ^category(/.*)?$ /api/category.php [L]</pre></div><p>The first <a id="id621" class="indexterm"/>line turns on the ability to rewrite a URL. This <a id="id622" class="indexterm"/>means that while the user's <a id="id623" class="indexterm"/>address bar shows one thing, we direct the request to a different file. As the previous comments state, the next block sends any requests for <code class="literal">item</code> to <code class="literal">item.php</code> and the next block sends requests for <code class="literal">category</code> to <code class="literal">category.php</code>. The <code class="literal">[L]</code> directive says that if a rule matches the currently requested URL, no more rules should be checked, as this is the last rule to match against. This is a very simple change that gives a more professional and friendly feel to an application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note33"/>Note</h3><p>If you would like to learn more about <code class="literal">.htaccess</code> and Apache, a good place to start is at <a class="ulink" href="http://www.addedbytes.com/for-beginners/url-rewriting-for-beginners/">http://www.addedbytes.com/for-beginners/url-rewriting-for-beginners/</a>.</p></div></div><p>Save the file and close it. Now all of our different HTTP requests will be sent to <code class="literal">api/item</code> and <code class="literal">api/category</code>.</p><p>Our API will need to be able to distinguish the different HTTP request types in order to understand what to do with the data. We will get to how that works in a second, but first let's take a quick look at the store.</p></div></div><div class="section" title="The item store"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec67"/>The item store</h2></div></div></div><p>The item store <a id="id624" class="indexterm"/>is extremely simple for this one:</p><div class="informalexample"><pre class="programlisting">Ext.define('CatHerder.store.itemStore', {
    extend: 'Ext.data.Store',
    requires: [
        'CatHerder.model.Item'
    ],

    config: {
        model: 'CatHerder.model.Item',
        storeId: 'itemStore',
        autoLoad: true
    }
});</pre></div><p>Since we don't declare a<a id="id625" class="indexterm"/> proxy, the store will automatically use the one we set on our model. Other than that, we simply require our model to give the store a <code class="literal">storeId</code> value and set <code class="literal">autoLoad</code> to <code class="literal">true</code>.</p></div><div class="section" title="Creating the category model and store"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec68"/>Creating the category model and store</h2></div></div></div><p>Our category model and<a id="id626" class="indexterm"/> store are just variations of our item model and store. The <a id="id627" class="indexterm"/>model uses <code class="literal">hasMany</code> instead of <code class="literal">hasOne</code>:</p><div class="informalexample"><pre class="programlisting">Ext.define('CatHerder.model.Category', {
    extend:'Ext.data.Model',
    config:{
        idProperty:'categoryID',
        fields:[
            {
                name:'categoryID',
                type:'int'
            },
            {
                name:'name'
            }
        ],
        hasMany:{
            model:'CatHerder.model.Item',
            name:'items',
            autoLoad:false
        },
        proxy:{
            type:'rest',
            url:'/api/category'
        }
    }
});</pre></div><p>We use <code class="literal">hasMany</code> because we are going to have multiple items in a single category. Other than that, the basic structure of the model is the same as our item model, using the <code class="literal">rest</code> proxy and contacting our PHP API at <code class="literal">/api/category</code>.</p><p>Our <code class="literal">categoryStore</code> is also a virtual duplicate of the <code class="literal">itemStore</code>:</p><div class="informalexample"><pre class="programlisting">Ext.define('CatHerder.store.categoryStore', {
    extend: 'Ext.data.Store',
    requires: [
        'CatHerder.model.Category'
    ],
    config: {
        model: 'CatHerder.model.Category',
        storeId: 'categoryStore',
        autoLoad: true
    }
});</pre></div><p>As before we just extend the<a id="id628" class="indexterm"/> basic store component, declare which model we are <a id="id629" class="indexterm"/>using (<code class="literal">'CatHerder.model.Category'</code>), and give the store an ID we can reference later.</p><p>Once we have these two pieces in place, it's time for a bit of testing.</p></div><div class="section" title="Testing the store and the model"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec69"/>Testing the store and the model</h2></div></div></div><p>When creating an<a id="id630" class="indexterm"/>
<a id="id631" class="indexterm"/> API for your application, it's usually a good idea to begin with just a flat text file. This will let you test the read abilities of the store and help you better understand how the data will need to be formatted for your API.</p><p>For this test file, we are going to create a couple of very basic PHP files. These files will simply create a static array of data, encode it as JSON, and echo it back to the application.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note34"/>Note</h3><p>You can use any server-side language you would like; Sencha Touch doesn't care as long as it can accept and return JSON. If you'd like to use PHP for your server code, but need a place to get started, try <a class="ulink" href="http://phpmaster.com/">http://phpmaster.com/</a>. PHP Master<a id="id632" class="indexterm"/> has lots of tutorials for all levels of PHP programmers.</p></div></div><p>We will start with the <code class="literal">item.php</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;?PHP

$test = array(
  array(
    'itemID' =&gt; 1,
    'name' =&gt; 'Test Item 1',
    'description' =&gt; 'Lorem Ipsum',
    'price' =&gt; 1.00,
    'photoURL' =&gt; 'http://placekitten.com/200/300',
    'categoryID' =&gt; 1,
    'category' =&gt; array(
      'categoryID' =&gt; 1, 'name' =&gt; 'Category 1', 'itemID' =&gt; 1
    )
  ),
  array(
    'itemID' =&gt; 2,
    'name' =&gt; 'Test Item 2',
    'description' =&gt; 'Lorem Ipsum',
    'price' =&gt; 2.00,
    'photoURL' =&gt; 'http://placekitten.com/400/300',
    'categoryID' =&gt; 2,
    'category' =&gt; array(
      'categoryID' =&gt; 2, 'name' =&gt; 'Category 2', 'itemID' =&gt; 2
    )
  ),
  array(
    'itemID' =&gt; 3,
    'name' =&gt; 'Test Item 3',
    'description' =&gt; 'Lorem Ipsum',
    'price' =&gt; 3.50,
    'photoURL' =&gt; 'http://placekitten.com/200/200',
    'categoryID' =&gt; 1,
    'category' =&gt; array(
      'categoryID' =&gt; 1, 'name' =&gt; 'Category 1', 'itemID' =&gt; 3
    )
  )
);

echo json_encode($test);
?&gt;</pre></div><p>This file <a id="id633" class="indexterm"/>
<a id="id634" class="indexterm"/>creates an array called <code class="literal">$test</code>. The <code class="literal">$test</code> array<a id="id635" class="indexterm"/> has three arrays nested inside of it, one for each of our items. These arrays each contain various fields such as <code class="literal">itemID</code>, <code class="literal">name</code>, <code class="literal">description</code>, <code class="literal">price</code>, <code class="literal">photoURL</code>, and <code class="literal">categoryID</code>. They also contain the category data as part of an additional nested array. We include the category data as part of the item data so that our stores can access it via the <code class="literal">hasOne</code> relationship without requiring an extra AJAX call per item to the server to load the category data.</p><p>When you write the final PHP code for your application, it will query a database to get this information for both the items and the categories. The PHP will then need to format it in just this fashion.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note35"/>Note</h3><p>PHP formats an array in a similar fashion to Sencha Touch, where Sencha Touch uses <code class="literal">key: value</code>, and PHP uses <code class="literal">'key' =&gt; value</code>.</p></div></div><p>The last line of the PHP file takes our array and encodes it as JSON. We then use <code class="literal">echo</code> to send the data back to our application.</p><p>We do the exact same<a id="id636" class="indexterm"/>
<a id="id637" class="indexterm"/> thing for our categories array in <code class="literal">category.php</code>:</p><div class="informalexample"><pre class="programlisting">&lt;?PHP

$test = array(
  array(
    'categoryID' =&gt; 1,
    'name' =&gt; 'Category 1',
    'items' =&gt; array(
      array(
        'itemID' =&gt; 1,
        'name' =&gt; 'Test Item 1',
        'description' =&gt; 'Lorem Ipsum',
        'price' =&gt; 1.00,
        'photoURL' =&gt; 'http://placekitten.com/200/300',
        'categoryID' =&gt; 1
      ),
      array(
        'itemID' =&gt; 3,
        'name' =&gt; 'Test Item 3',
        'description' =&gt; 'Lorem Ipsum',
        'price' =&gt; 3.50,
        'photoURL' =&gt; 'http://placekitten.com/200/200',
        'categoryID' =&gt; 1
      )
    )
  ),
  array(
    'categoryID' =&gt; 2,
    'name' =&gt; 'Category 2',
    'items' =&gt; array(
      array(
        'itemID' =&gt; 2,
        'name' =&gt; 'Test Item 2',
        'description' =&gt; 'Lorem Ipsum',
        'price' =&gt; 2.00,
        'photoURL' =&gt; 'http://placekitten.com/400/300',
        'categoryID' =&gt; 2	
      )
    )
  ) 
);

echo json_encode($test);
?&gt;</pre></div><p>Notice that in this case, we only have two categories, but we also include the items associated with each category. This lets us do a lot more with the data later on (such as showing the number of items in a category).</p><p>While these may look like large and messy arrays, the final PHP code is going to do most of the work for you. This is simply for testing and making sure you have the initial data formatting <a id="id638" class="indexterm"/>
<a id="id639" class="indexterm"/>correct.</p><div class="mediaobject"><img src="graphics/8901OS_06_03.jpg" alt="Testing the store and the model"/></div><p>When you load the application you can now see the two lists with our flat data. Let's take a quick look at the XTemplates we are using for this data.</p></div><div class="section" title="Creating the XTemplates"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec70"/>Creating the XTemplates</h2></div></div></div><p>Now that we have seen how the data is being sent to the application, we need to understand how we can use it in our <a id="id640" class="indexterm"/>XTemplates. In our list view, the <code class="literal">itemTpl</code> looks <a id="id641" class="indexterm"/>like this:</p><div class="informalexample"><pre class="programlisting">itemTpl: [
  '{category.name}: {name}',
  '&lt;p class="delete hidden" style="position: absolute; right: 10px; top: 12px;"&gt;',
  '&lt;img src="resources/images/delete.png" alt="delete" /&gt;',
  '&lt;/p&gt;'
]</pre></div><p>Both our category and our item include field values for name. Since the item is our main piece of data here, we can refer to the item's name value as <code class="literal">{name}</code>. Since category is related to item (and our PHP passes back as a nested array within each item), we refer to the category name value as <code class="literal">category.name</code>.</p><p>Our category list XTemplate uses a similar format to provide us with the category name, but it uses a slightly different method to get the number of items in each category:</p><div class="informalexample"><pre class="programlisting">itemTpl:[
    '&lt;div&gt;{name} -- {[values.items.length]} item(s)&lt;/div&gt;'
]</pre></div><p>Since the category is our main piece of data here, name refers to the category name. We can get to any of the item properties by doing <code class="literal">item.propertyName</code>, but what we really want to know is the number of items in the category.</p><p>Remember in our PHP flat file we included the individual items as part of a nested array in our category. This nested array was called <code class="literal">items</code>. We can print the name of the first item by using <code class="literal">items[0].name</code> or the second item by using <code class="literal">items[1].name</code> and so on for each of the various items and properties. We can also use the JavaScript <code class="literal">length</code> property to find out how many individual items are in our <code class="literal">items</code> array.</p><p>In order to do this we need to use JavaScript code inline in our template. That's why we use both curly braces and brackets: <code class="literal">{[function goes here]}</code>. When you're using inline code in your template, you have to access the template variables via the <code class="literal">values</code> array rather than by name.</p><p>In this case, <code class="literal">values.items.length</code> returns the number of elements in the <code class="literal">items</code> array.</p><p>Now that we can see how the values are formatted by PHP and displayed in the XTemplate, let's take a look at how we work within a database to store and retrieve this data.</p></div></div>
<div class="section" title="The API and the database"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec42"/>The API and the database</h1></div></div></div><p>To begin with, we need to replace our flat<a id="id642" class="indexterm"/> PHP file with some new code. This code will have three basic tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Decide what kind of request is coming in</li><li class="listitem" style="list-style-type: disc">Contact the database and make the appropriate request</li><li class="listitem" style="list-style-type: disc">Format the data to be returned to the Sencha Touch application<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note36"/>Note</h3><p>Please note that from this point on, we are looking at PHP code. While some of it looks similar to JavaScript, this code is completely separate from both JavaScript and Sencha Touch.</p></div></div></li></ul></div><p>These three basic functions will hold true no matter what language your API is written in, though the implementation will vary. In PHP our first task would look something like this:</p><div class="informalexample"><pre class="programlisting">include_once 'dbSetup.inc';

switch ($_SERVER['REQUEST_METHOD']) {
case "GET":
    doGet();
    break;
case "POST":
    doPost();
    break;
case "PUT":
    doPut();
    break;
case "DELETE":
    doDelete();
    break;
default:
    doGet();
}</pre></div><p>Here we include our database setup file, which handles the basics of our connection between the database and our code. Next we use a special variable <code class="literal">$_SERVER['REQUEST_METHOD']</code>, which tells us whether the request was sent via <code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, or <code class="literal">DELETE</code>.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note37"/>Note</h3><p>
<code class="literal">GET</code>, <code class="literal">POST</code>, <code class="literal">PUT</code>, and <code class="literal">DELETE</code> are known as <span class="strong"><strong>HTTP methods</strong></span>, or <a id="id643" class="indexterm"/>
<span class="strong"><strong>verbs</strong></span>, and are used to represent a user's interactions with the web server. To learn more about HTTP verbs, check out the RFC at <a class="ulink" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html</a>.</p></div></div><p>We use a <code class="literal">switch</code> statement<a id="id644" class="indexterm"/> (just like the one in JavaScript) to send the different requests out to different functions. Each function will contact the database and perform the request.</p><p>We are not going to <a id="id645" class="indexterm"/>go too deeply into the details of the PHP code to do this, but we will take a look at the basic operations for our different requests.</p><div class="section" title="The GET request"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec71"/>The GET request</h2></div></div></div><p>The <code class="literal">GET</code> request <a id="id646" class="indexterm"/>is used to read from the database and it has two basic uses in the <a id="id647" class="indexterm"/>API: get a single item or get a list of items. First we need to figure out if the request is for a single item or all the items.</p><p>In a REST API, a request for a single item would look like this:</p><p>
<a class="ulink" href="http://mydomain.com/api/items/123">http://mydomain.com/api/items/123</a></p><p>In this case, we want to send back a single item with an ID of 123. However, if we get a request that looks like:</p><p><a class="ulink" href="http://mydomain.com/api/items/">http://mydomain.com/api/items/</a></p><p>We just send back all the items in the database.</p><p>So, the first thing our <code class="literal">doGet()</code> function<a id="id648" class="indexterm"/> needs to do is check the URL and see if we have some extra numbers at the end of our request URL:</p><div class="informalexample"><pre class="programlisting">function doGet() {
    $db = dbSetup();

    if (preg_match('/item\/(\d+)[\/]*$/', $_SERVER['REQUEST_URI'], $matches)) {
        /* We've got a single item to grab. */
        $itemID = array($matches[1]); // execute() expects an array.
        $stmt = $db-&gt;prepare("select * from `items` where itemID = ?");
        if (is_object($stmt) &amp;&amp; $stmt-&gt;execute($itemID)) {
            /* We only asked for one. */
            $row = $stmt-&gt;fetch();
            $row['category'] = getCategory($row['categoryID'], $db);
            doJson($row);
        } else {
            doJson(array(), false, $stmt-&gt;errorInfo());
        }
    }</pre></div><p>The first line sets up our database so we can make requests.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note38"/>Note</h3><p>We have included setup files for the database in with the sample code for this chapter. For this application we are assuming a MySQL database, which is freely available. There is a <code class="literal">dbSetup.inc</code> file<a id="id649" class="indexterm"/> to handle the basic setup and configuration of the database, and a <code class="literal">setup.sql</code> file<a id="id650" class="indexterm"/> that can be imported into MySQL to set up the initial tables for the application. More information can be found at <a class="ulink" href="http://dev.mysql.com/doc/">http://dev.mysql.com/doc/</a>.</p></div></div><p>The next part of the <a id="id651" class="indexterm"/>
<a id="id652" class="indexterm"/>PHP code uses regular expression matching to check the URL that we received as part of our request (<code class="literal">$_SERVER['REQUEST_URI']</code>).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note39"/>Note</h3><p>Regular Expressions <a id="id653" class="indexterm"/>are an extremely powerful tool for matching strings, numbers, and characters. You can use it to find not just words or letters, but patterns within any string. For more <a id="id654" class="indexterm"/>information, go to:</p><p>
<a class="ulink" href="http://www.regular-expressions.info/">http://www.regular-expressions.info/</a>.</p></div></div><p>If we get a match, it means that we are looking for a single item. We then take our single item and use it to send a request to MySQL for the relevant data. We grab the <code class="literal">row</code> data that gets returned from MySQL. We use the <code class="literal">categoryID</code> value in the <code class="literal">row</code> data to attach category data to row data using another function called<a id="id655" class="indexterm"/> <code class="literal">getCategory()</code>. The whole thing then gets passed to a function called <code class="literal">doJson()</code> for final formatting.</p><p>This <code class="literal">doJson()</code> function<a id="id656" class="indexterm"/> will be used in multiple places in our code. It simply takes an array, an option success value, and an optional message, and turns them into the JSON encoded format that Sencha Touch can process:</p><div class="informalexample"><pre class="programlisting">function doJson($data, $success = true, $message = '') {
    $output = array('success' =&gt; $success, 'data' =&gt; $data);
    if ($message != '') {
        $output['message'] = $message;
    }
    echo json_encode($output);
}</pre></div><p>Back in our <code class="literal">doGet()</code> function, we have taken care of the request for single item, and now we need to handle the request for all items. This means that in addition to our original <code class="literal">if</code> <a id="id657" class="indexterm"/>
<a id="id658" class="indexterm"/>statement (that handled our request for one item) we need an <code class="literal">else</code> statement:</p><div class="informalexample"><pre class="programlisting">} else {
        $data = array();
        $categories = array();
        $filters = json_decode($_GET['filter'], TRUE);
        $start = intval($_GET['start']);
        $limit = intval($_GET['limit']);
        /* For simplicity, just use one filter */
        $filterColumn = $filters[0]['property'];
        $filterValue = $filters[0]['value'];
        $sql = "select * from `items`";
        if (!is_null($filterValue) &amp;&amp; $filterValue != 'null' &amp;&amp; $filterValue != "") {
            $sql .= " where `$filterColumn` = '$filterValue'";
        }
        if ($limit &gt; 0) {
            $sql .= " limit $start,$limit";
        }
        foreach ($db-&gt;query($sql) as $row) {
            /* Only fetch categories once. */
            if (!isset($categories[$row['categoryID']])) {
                $categories[$row['categoryID']] = getCategory($row['categoryID'], $db);
            }
            $row['category'] = $categories[$row['categoryID']];

            $data[] = $row;
        }
        
        echo json_encode($data);
        exit;
    }</pre></div><p>This one works a bit differently because we are getting back multiple results. This means we need to loop through our results (using <code class="literal">foreach</code>), and get them into a single array we can process using <code class="literal">json_encode()</code>. We also have to use our <code class="literal">getCategory()</code> function on each round of the loop to grab the <code class="literal">category</code> data and add it to each of our items.</p><p>Once we have everything, we echo back the encoded array and exit. This will send the JSON back to our application for display in our XTemplate.</p><p>We have also included a few optional pieces that we can use later on: filters and start/limit. This will let us pass values for filters (as an array), and for start and limit as individual values. We can then pass these to MySQL and control the number of results we get back or filter the results by a particular column. It's always a good idea to build this kind of flexibility into an API. It can really save you some time when you start adding new features to <a id="id659" class="indexterm"/>
<a id="id660" class="indexterm"/>your application.</p></div><div class="section" title="The POST request"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec72"/>The POST request</h2></div></div></div><p>The <code class="literal">POST</code> request<a id="id661" class="indexterm"/> is where we will need to handle the creation of new <a id="id662" class="indexterm"/>items. The variables get passed to us as a <code class="literal">POST</code> request this time instead of as part of the URL (like our previous <code class="literal">GET</code> method).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>
<span class="strong"><strong>Using zero when sending a POST for new items</strong></span>
</p><p>In our <code class="literal">item</code> model, we have set the <code class="literal">itemID</code> as our <code class="literal">id</code> property. This is the unique <code class="literal">id</code> for our data record. There is an old programming habit of setting the <code class="literal">id</code> to <code class="literal">0</code> when you want to create a new data record. However, if you set an <code class="literal">id</code> of <code class="literal">0</code> on your model, Sencha Touch sees that as a valid ID and determines that you are updating a record, which sends your request as a <code class="literal">PUT</code>, not a <code class="literal">POST</code> request.</p></div></div><p>Our <code class="literal">doPost()</code> function<a id="id663" class="indexterm"/> needs to grab the data sent by the request and decode the JSON sent by Sencha Touch. Since we need to do this for our <code class="literal">doPut()</code> and <code class="literal">doDelete()</code> functions, we will create a separate function to do our decoding:</p><div class="informalexample"><pre class="programlisting">function getJsonPayload() {
    return json_decode(file_get_contents('php://input'), true);
}</pre></div><p>In PHP, we can grab the raw data stream of the request with <code class="literal">file_get_contents('php://input')</code>. We can then decode this stream from JSON to an associative array <code class="literal">('key' =&gt; 'val')</code> using <code class="literal">json_decode()</code>. We simply return the associative array whenever the function gets called.</p><p>This new function gets called right at the top of our <code class="literal">doPost()</code> function:</p><div class="informalexample"><pre class="programlisting">function doPost() {
    $data = getJsonPayload();
    $sql = "insert into `items` (`itemID`, `name`, `description`, `price`, `photoURL`, `categoryID`) values (NULL, :name, :description, :price, :photoURL, :categoryID)";

    $db = dbSetup();
    /* Prepare our data. Here is where you should add filtering, etc. */
    $insert = array();
    foreach ($data as $key =&gt; $val) {
        if ($key != "category_id") {
            $insert[':'.$key] = $val;
        }
    }

    $stmt = $db-&gt;prepare($sql);
    $stmt-&gt;execute($insert);
    $data['itemID'] = $db-&gt;lastInsertId();
    $data['category'] = getCategory($data['categoryID'],$db);
    doJson($data);
}</pre></div><p>Next we create the <a id="id664" class="indexterm"/>
<a id="id665" class="indexterm"/>SQL statement that we will use to place the data into our database. Then we need to format our data so that it will correctly fit with our MySQL statement.</p><p>We do this by looping through our data and creating a modified array that will work with the <code class="literal">execute()</code> command<a id="id666" class="indexterm"/> to combine the data with the <code class="literal">sql</code> statement and <code class="literal">insert</code> our new data record.</p><p>We then grab the unique ID for the new data row with <code class="literal">$db-&gt;lastInsertId()</code> and add it to our data array so we can pass it back to the Sencha Touch application. We do this with our<a id="id667" class="indexterm"/> <code class="literal">doJson()</code> function.</p><p>Our <code class="literal">PUT</code> request follows a very similar format.</p></div><div class="section" title="The PUT request"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec73"/>The PUT request</h2></div></div></div><p>The <code class="literal">PUT</code> request<a id="id668" class="indexterm"/> is<a id="id669" class="indexterm"/> executed when we save an object in Sencha Touch that has a valid <code class="literal">id</code> property, in this case, an <code class="literal">itemID</code> value. When Sencha Touch sends a <code class="literal">save</code> request for this type of pre-existing object, it uses the <code class="literal">PUT</code> request.</p><p>Our API function <code class="literal">doPut()</code> <a id="id670" class="indexterm"/>does the same basic thing as our<a id="id671" class="indexterm"/> <code class="literal">doPost()</code> function:</p><div class="informalexample"><pre class="programlisting">function doPut() {
    $data = getJsonPayload();
    $sql = "update `items` set `itemID` = :itemID, `name` = :name, `description` = :description, `price` = :price, `photoURL` = :photoURL, `categoryID` = :categoryID where `itemID` = :itemID";

    $db = dbSetup();

    /* Prepare our data. Here is where you should add filtering, etc. */
    $insert = array();
    foreach ($data as $key =&gt; $val) {
        if ($key != "category_id") {
            $insert[':'.$key] = $val;
        }
    }

    $stmt = $db-&gt;prepare($sql);
    $stmt-&gt;execute($insert);
   ata['category'] = getCategory($data['categoryID'],$db);
    doJson($data);
}</pre></div><p>Since we already have<a id="id672" class="indexterm"/> <a id="id673" class="indexterm"/>the unique <code class="literal">itemID</code> we don't need to grab it from the database after we update the row. Other than that, the basic structure is the same. We simply type an <code class="literal">update</code> command instead of <code class="literal">insert</code> in MySQL.</p></div><div class="section" title="The DELETE request"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec74"/>The DELETE request</h2></div></div></div><p>A <code class="literal">DELETE</code> request is<a id="id674" class="indexterm"/> sent<a id="id675" class="indexterm"/> when we call <code class="literal">erase()</code> on our model record in Sencha Touch. In this case, our API only cares about the unique <code class="literal">itemID</code>, so we don't need to create a new array to use with our<a id="id676" class="indexterm"/> <code class="literal">execute()</code> statement. We still use <code class="literal">getJsonPayload()</code> to grab the data and after we execute, we echo the JSON encoded data.</p><div class="informalexample"><pre class="programlisting">function doDelete() {
    $db = dbSetup();
    $data = getJsonPayload();
    $itemID = array($data['itemID']);
    $sql = 'delete from items where itemID = ?';
    $stmt = $db-&gt;prepare($sql);
    $stmt-&gt;execute($itemID);
    echo json_encode($data);
} </pre></div><p>Back on the Sencha Touch side of things, you will need to reload the store in order to see the record removed from the list.</p></div><div class="section" title="The rest of the API"><div class="titlepage"><div><div><h2 class="title"><a id="ch06lvl2sec75"/>The rest of the API</h2></div></div></div><p>The Category side of the API works in exactly the same way as the Item part we just covered. You can look things over in the sample code for this chapter, but the logic is all the same. There is a <code class="literal">switch</code> statement<a id="id677" class="indexterm"/> at the top, which determines how the request was received. We then have the same basic functions set to respond to each type of request.</p><p>This simple repeatable structure can be used to generate a basic API for use with any application.</p><p>If you need additional functionality in your API beyond the basic CRUD functions you can also use AJAX stores to send requests to an API file, where it can be processed appropriately. The API would need to perform the same basic functions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Determine the type of request either from the variables that are sent or the type of request being made</li><li class="listitem" style="list-style-type: disc">Process the request through the database</li><li class="listitem" style="list-style-type: disc">Encode the necessary request into JSON and send it back to the Sencha Touch application</li><li class="listitem" style="list-style-type: disc">A message should also be sent in the event of failure to help with debugging or offer the user some information to help fix the problem</li></ul></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch06lvl1sec43"/>Summary</h1></div></div></div><p>In this chapter we used a simple catalog application in order to build our own API. In addition we covered:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">How to set up Sencha Model associations</li><li class="listitem" style="list-style-type: disc">Tricks using <code class="literal">.htaccess</code> and <code class="literal">mod_rewrite</code> to make prettier URLs for our API</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">Ext.data.proxy.Rest</code> to communicate with an API via basic CRUD interactions</li></ul></div><p>In the next chapter we will use the data from several third party APIs to enhance our application.</p></div></body></html>