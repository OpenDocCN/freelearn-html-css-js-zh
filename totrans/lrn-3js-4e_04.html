<html><head></head><body>
		<div><h1 id="_idParaDest-57" class="chapter-number"><a id="_idTextAnchor056"/>4</h1>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Working with Three.js Materials</h1>
			<p>In <a href="B18726_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Light Sources in Three.js</em>, we talked a bit about materials. You learned that a material, together with a <code>THREE.Geometry</code> instance, forms a <code>THREE.Mesh</code> object. A material is like the skin of an object that defines what the outside of a geometry looks like. For example, a skin defines whether a geometry is metallic-looking, transparent, or shown as a wireframe. The resulting <code>THREE.Mesh</code> object can then be added to the scene to be rendered by Three.js.</p>
			<p>So far, we haven’t looked at materials in much detail. In this chapter, we’ll dive into all the materials Three.js has to offer, and you’ll learn how you can use these materials to create good-looking 3D objects. The materials we’ll explore in this chapter are shown in the following list:</p>
			<ul>
				<li><code>MeshBasicMaterial</code>: This is a basic material that you can use to give your geometries a simple color or show the wireframe of your geometries. This material isn’t influenced by lights.</li>
				<li><code>MeshDepthMaterial</code>: This is a material that uses the distance from the camera to determine how to color your mesh.</li>
				<li><code>MeshNormalMaterial</code>: This is a simple material that bases the color of a face on its normal vector.</li>
				<li><code>MeshLambertMaterial</code>: This is a material that takes lighting into account and is used to create dull, non-shiny-looking objects.</li>
				<li><code>MeshPhongMaterial</code>: This is a material that also takes lighting into account and can be used to create shiny objects.</li>
				<li><code>MeshStandardMaterial</code>: This is a material that uses physical-based rendering to render the object. With physical-based rendering, a physically correct model is used to determine how light interacts with a surface. This allows you to create more accurate and realistic-looking objects.</li>
				<li><code>MeshPhysicalMaterial</code>: This is an extension of <code>MeshStandardMaterial</code> that allows more control over the reflection.</li>
				<li><code>MeshToonMaterial</code>: This is an extension of <code>MeshPhongMaterial</code> that tries to make objects look hand-drawn.</li>
				<li><code>ShadowMaterial</code>: This is a specific material that can receive shadows, but otherwise, it is rendered transparent.</li>
				<li><code>ShaderMaterial</code>: This material allows you to specify shader programs to directly control how vertices are positioned and pixels are colored.</li>
				<li><code>LineBasicMaterial</code>: This is a material that can be used on the <code>THREE.Line</code> geometry to create colored lines.</li>
				<li><code>LineDashMaterial</code>: This is the same as <code>LineBasicMaterial</code>, but this material also allows you to create a dashed effect.</li>
			</ul>
			<p>In the sources of Three.js, you can also find <code>THREE.SpriteMaterial</code> and <code>THREE.PointsMaterial</code>. These are materials you can use when styling individual points. We won’t discuss those in this chapter, but we’ll explore them in <a href="B18726_07.xhtml#_idTextAnchor122"><em class="italic">Chapter 7</em></a>, <em class="italic">Points </em><em class="italic">and Sprites</em>.</p>
			<p>Materials have several common properties, so before we look at the first material, <code>THREE.MeshBasicMaterial</code>, we’ll look at the properties shared by all the materials.</p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Understanding common material properties</h1>
			<p>You can quickly see for yourself which properties<a id="_idIndexMarker283"/> are shared between all the materials. Three.js provides a material base class, <code>THREE.Material</code>, that lists all these common properties. We’ve divided these common material properties into the following three categories:</p>
			<ul>
				<li><strong class="bold">Basic properties</strong>: These are the properties you’ll use most<a id="_idIndexMarker284"/> often. With these properties, you can, for instance, control the opacity of the object, whether it is visible, and how it is referenced (by ID or custom name).</li>
				<li><strong class="bold">Blending properties</strong>: Every object has a set of blending<a id="_idIndexMarker285"/> properties. These properties define how the color of each point of the material is combined with the color behind it.</li>
				<li><strong class="bold">Advanced properties</strong>: Several advanced properties control how <a id="_idIndexMarker286"/>the low-level WebGL context renders objects. In most cases, you won’t need to deal with these properties.</li>
			</ul>
			<p>Note that, in this chapter, we will skip most of the properties related to textures and maps. Most materials allow you to use images as textures (for instance, a wood-like or stone-like texture). In <a href="B18726_10.xhtml#_idTextAnchor171"><em class="italic">Chapter 10</em></a>, <em class="italic">Loading and Working with Textures</em>, we will dive into the various available texture and mapping options. Some materials also have specific properties related to animation (for example, <code>skinning</code>, <code>morpNormals</code>, and <code>morphTargets</code>); we’ll also skip those properties. These will be addressed in <a href="B18726_09.xhtml#_idTextAnchor148"><em class="italic">Chapter 9</em></a>, <em class="italic">Animations and Moving the Camera</em>. The <code>clipIntersection</code>, <code>clippingPlanes</code>, and <code>clipShadows</code> properties will be addressed in <a href="B18726_06.xhtml#_idTextAnchor101"><em class="italic">Chapter 6</em></a>, <em class="italic">Exploring </em><em class="italic">Advanced Geometries</em>.</p>
			<p>We will start with the first set shown in the list: the basic properties.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Basic properties</h2>
			<p>The basic properties<a id="_idIndexMarker287"/> of the <code>THREE.Material</code> object are listed here (you will see these properties in action in the <em class="italic">THREE.MeshBasicMaterial</em> section):</p>
			<ul>
				<li><code>id</code>: This is used to identify a material and is assigned when you create a material. This starts at <code>0</code> for the first material and is increased by <code>1</code> for each additional material that is created.</li>
				<li><code>uuid</code>: This is a uniquely generated ID and is used internally.</li>
				<li><code>name</code>: You can assign a name to a material with this property. This can be used for debugging purposes.</li>
				<li><code>opacity</code>: This defines how transparent an object is. Use this together with the <code>transparent</code> property. The range of this property is from <code>0</code> to <code>1</code>.</li>
				<li><code>transparent</code>: If this is set to <code>true</code>, Three.js will render this object with the set opacity. If this is set to <code>false</code>, the object won’t be transparent, just more lightly colored. This property should also be set to <code>true</code> if you use a texture that uses an alpha (transparency) channel.</li>
				<li><code>visible</code>: This defines whether this material is visible. If you set this to <code>false</code>, you won’t see the object in the scene.</li>
				<li><code>side</code>: With this property, you can define to which side of the geometry a material is applied. The default is <code>THREE.Frontside</code>, which applies the material to the front (outside) of an object. You can also set this to <code>THREE.BackSide</code>, which applies it to the back (inside), or <code>THREE.DoubleSide</code>, which applies it to both sides.</li>
				<li><code>needsUpdate</code>: When Three.js creates<a id="_idIndexMarker288"/> a material, it converts it into a set of WebGL instructions. When you want the changes you made in the material to also result in an update to the WebGL instructions, you can set this property to <code>true</code>.</li>
				<li><code>colorWrite</code>: If set to <code>false</code>, the color of this material won’t be shown (in effect, you’ll create invisible objects, which occlude objects behind them).</li>
				<li><code>flatShading</code>: This determines whether this material is rendered using flat shading. With flat shading, the individual triangles that make up an object are rendered separately and aren’t combined into a smooth surface.</li>
				<li><code>lights</code>: This is a Boolean value that determines whether this material is affected by lights. The default value is <code>true</code>.</li>
				<li><code>premultipliedAlpha</code>: This changes the way the transparency of an object is rendered. The default value is <code>false</code>.</li>
				<li><code>dithering</code>: This applies a dithering effect to the rendering material. This can be used to avoid banding. The default value is <code>false</code>.</li>
				<li><code>shadowSide</code>: This is just like the <code>side</code> property but determines which side of the faces casts the shadows. If not set, this follows the value set on the <code>side</code> property.</li>
				<li><code>vertexColors</code>: With this property, you can define individual colors to be applied to each vertex. If set to <code>true</code>, any color set on a vertex is used in rendering, while if set to <code>false</code>, the colors of the vertices aren’t used.</li>
				<li><code>fog</code>: This property determines<a id="_idIndexMarker289"/> whether this material is affected by global fog settings. This is not shown in action, but if this is set to <code>false</code>, the global fog we saw in <a href="B18726_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a>, <em class="italic">Basic Components that Make up a Three.js Scene</em>, is disabled.</li>
			</ul>
			<p>For each material, you can also set several blending properties.</p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Blending properties</h2>
			<p>Materials have a couple<a id="_idIndexMarker290"/> of generic blending-related properties. Blending determines how the colors we render interact with the colors that are behind them. We’ll touch upon this subject a little bit when we talk about combining materials. The blending properties are listed here:</p>
			<ul>
				<li><code>blending</code>: This determines how the material on this object blends with the background. The normal mode is <code>THREE.NormalBlending</code>, which only shows the top layer.</li>
				<li><code>blendSrc</code>: Besides using the standard blending modes, you can also create custom blend modes by setting <code>blendsrc</code>, <code>blenddst</code>, and <code>blendequation</code>. This property defines how an object (the source) is blended into the background (the destination). The default <code>THREE.SrcAlphaFactor</code> setting uses the alpha (transparency) channel for blending.</li>
				<li><code>blendSrcAlpha</code>: This is the transparency of <code>blendSrc</code>. The default is <code>null</code>.</li>
				<li><code>blendDst</code>: This property defines how the background (the destination) is used in blending and defaults to <code>THREE.OneMinusSrcAlphaFactor</code>, which means this property also uses the alpha channel of the source for blending but uses <code>1</code> ( the alpha channel of the source) as the value.</li>
				<li><code>blendDstAlpha</code>: This is the transparency of <code>blendDst</code>. The default is <code>null</code>.</li>
				<li><code>blendEquation</code>: This defines how the <code>blendsrc</code> and <code>blenddst</code> values are used. The default is to add them (<code>AddEquation</code>). With these three properties, you can create<a id="_idIndexMarker291"/> your own custom blend modes.</li>
			</ul>
			<p>The last set of properties is mostly used internally and controls the specifics of how WebGL is used to render the scene.</p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Advanced properties</h2>
			<p>We won’t go into the details<a id="_idIndexMarker292"/> of these properties. These are related to how WebGL works internally. If you do want to know more about these properties, the OpenGL<a id="_idIndexMarker293"/> specification is a good starting point. You can find this specification at <a href="https://www.khronos.org/opengl/wiki">https://www.khronos.org/opengl/wiki</a>. The following list provides a brief description of these advanced properties:</p>
			<ul>
				<li><code>depthTest</code>: This is an advanced WebGL property. With this property, you can enable or disable the <code>GL_DEPTH_TEST</code> parameter. This parameter controls whether the depth of a pixel is used to determine a new pixel’s value. Normally, you wouldn’t need to change this. More information can be found in the OpenGL specification we mentioned earlier.</li>
				<li><code>depthWrite</code>: This is another internal property. This property can be used to determine whether this material affects the WebGL depth buffer. If you use an object for a 2D overlay (for example, a hub), you should set this property to <code>false</code>. Usually, though, you shouldn’t need to change this property.</li>
				<li><code>depthFunc</code>: This function compares a pixel’s depth. This corresponds to <code>glDepthFunc</code> from the WebGL specifications.</li>
				<li><code>polygonOffset</code>, <code>polygonOffsetFactor</code>, and <code>polygonOffsetUnits</code>: With these properties, you can control the <code>POLYGON_OFFSET_FILL</code> WebGL feature. These are normally not needed. For an explanation of what they do in detail, you can look at the OpenGL specification.</li>
				<li><code>Alphatest</code>: This value can be set to a specific value (<code>0</code> to <code>1</code>). Whenever a pixel has an alpha value smaller than this value, it won’t be drawn. You can use this property to remove some transparency-related artifacts. You can set the precision for this material to one<a id="_idIndexMarker294"/> of the following WebGL values: <code>highp</code>, <code>mediump</code>, or <code>lowp</code>.</li>
			</ul>
			<p>Now, let’s look at all the available materials so that you can see the effect these properties have on the rendered output.</p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Starting with simple materials</h1>
			<p>In this section, we’ll look<a id="_idIndexMarker295"/> at a few simple materials: <code>MeshBasicMaterial</code>, <code>MeshDepthMaterial</code>, and <code>MeshNormalMaterial</code>.</p>
			<p>Before we look into the properties of these materials, here’s a quick note on how you can pass in properties to configure the materials. There are two options:</p>
			<ul>
				<li>You can pass in the arguments in the constructor as a parameter object, like this:<pre class="console">
const material = new THREE.MeshBasicMaterial({</pre><pre class="console">
  color: 0xff0000,</pre><pre class="console">
  name: 'material-1',</pre><pre class="console">
  opacity: 0.5,</pre><pre class="console">
  transparency: true,</pre><pre class="console">
  ...</pre><pre class="console">
})</pre></li>
				<li>Alternatively, you can create an instance and set the properties individually, like this:<pre class="console">
const material = new THREE.MeshBasicMaterial();</pre><pre class="console">
material.color = new THREE.Color(0xff0000);</pre><pre class="console">
material.name = 'material-1'; material.opacity = 0.5;</pre><pre class="console">
material.transparency = true;</pre></li>
			</ul>
			<p>Usually, the best way is to use the constructor if we know all the properties’ values while creating the material. The arguments used in both of these styles use the same format. The only exception to this rule is the <code>color</code> property. In the first style, we can just pass in the hex<a id="_idIndexMarker296"/> value, and Three.js will create a <code>THREE.Color</code> object itself. In the second style, we have to explicitly create a <code>THREE.Color</code> object. In this book, we’ll use both of these styles.</p>
			<p>Now, let’s look at the first of the simple materials: <code>THREE.MeshBasicMaterial</code>.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>THREE.MeshBasicMaterial</h2>
			<p><code>MeshBasicMaterial</code> is a very simple material<a id="_idIndexMarker297"/> that doesn’t take into account<a id="_idIndexMarker298"/> the lights that are available in the scene. Meshes with this material will be rendered as simple, flat polygons, and you also have the option to show the geometry’s wireframe. Besides the common properties we saw earlier regarding this material, we can set the following properties (once again, we will ignore the properties that are used for textures since we’ll discuss those in the chapter on textures):</p>
			<ul>
				<li><code>color</code>: This property allows<a id="_idIndexMarker299"/> you to set the color of the material.</li>
				<li><code>wireframe</code>: This allows you to render the material as a wireframe. This is great for debugging purposes.</li>
				<li><code>vertexColors</code>: When set to <code>true</code>, this will take the color of the individual vertices into account when rendering<a id="_idIndexMarker300"/> the model.</li>
			</ul>
			<p>In the previous chapters, we saw how to create materials and assign them to objects. For <code>THREE.MeshBasicMaterial</code>, we can do so like this:</p>
			<pre class="source-code">
const meshMaterial = new THREE.MeshBasicMaterial({color:
  0x7777ff});</pre>
			<p>This creates a new <code>THREE.MeshBasicMaterial</code> and initializes the <code>color</code> property to <code>0x7777ff</code> (which is purple).</p>
			<p>We’ve added an example<a id="_idIndexMarker301"/> that you can use to play<a id="_idIndexMarker302"/> around with the <code>THREE.MeshBasicMaterial</code> properties and the basic properties we discussed in the previous sections. If you open up the <code>basic-mesh-material.html</code> example in the <code>chapter-04</code> folder, you’ll see a simple mesh on screen and a set of properties on the right of the scene that you can use to change models, add a simple texture, and change any of the material properties to see the effect immediately:</p>
			<div><div><img src="img/Figure_4.01_B18726.jpg" alt="Figure 4.1 – Start screen for the basic material example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Start screen for the basic material example</p>
			<p>What you can see in this screenshot is a basic simple<a id="_idIndexMarker303"/> gray sphere. We already mentioned that <code>THREE.MeshBasicMaterial</code> doesn’t respond to lights, so you don’t see any depth; all the faces<a id="_idIndexMarker304"/> are the same color. Even with this material, though, you can still create nice-looking models. If you, for instance, enable the reflection by selecting the <code>reflection</code> property in the <code>envMaps</code> dropdown, set the background of the scene, and change the model to the <code>torus</code> model, you can already create great-looking models:</p>
			<div><div><img src="img/Figure_4.02_B18726.jpg" alt="Figure 4.2 – Torus knot with an environment map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Torus knot with an environment map</p>
			<p>The <code>wireframe</code> property is a great<a id="_idIndexMarker305"/> one for looking at the underlying<a id="_idIndexMarker306"/> geometry of <code>THREE.Mesh</code> and works great for debugging:</p>
			<div><div><img src="img/Figure_4.03_B18726.jpg" alt="Figure 4.3 – Model showing its wireframe"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Model showing its wireframe</p>
			<p>The final property that we want<a id="_idIndexMarker307"/> to look a bit closer at is <code>vertexColors</code>. If you enable<a id="_idIndexMarker308"/> this property, the colors of the individual vertices are used in rendering the model. If you select <code>vertexColor</code> from the model dropdown in the menu, you’ll see a model that has colored vertices. The easiest way to see this is by also enabling the wireframe:</p>
			<div><div><img src="img/Figure_4.04_B18726.jpg" alt="Figure 4.4 – Model showing wireframe and vertex colors"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Model showing wireframe and vertex colors</p>
			<p>Vertex colors can be used to color different parts of the mesh in different colors without having to use textures or multiple materials.</p>
			<p>In this example, you can also <a id="_idIndexMarker309"/>play around with the standard material properties<a id="_idIndexMarker310"/> we discussed at the beginning of this chapter by looking at the <strong class="bold">THREE.Material</strong> section of the menu in <em class="italic">Figure 4</em><em class="italic">.4</em>.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>THREE.MeshDepthMaterial</h2>
			<p>The next material<a id="_idIndexMarker311"/> on the list is <code>THREE.MeshDepthMaterial</code>. With this material, the way<a id="_idIndexMarker312"/> an object looks isn’t defined by lights or by a specific material property – it is defined by the distance from the object to the camera. You can, for instance, combine this with other materials to easily create fading effects. The only additional property this material has is one we saw in <code>THREE.MeshBasicMaterial</code>: the <code>wireframe</code> property.</p>
			<p>To demonstrate this material, we created<a id="_idIndexMarker313"/> an example that you can<a id="_idIndexMarker314"/> view by opening the <code>mesh-depth-material</code> example:</p>
			<div><div><img src="img/Figure_4.04_B18726.jpg" alt="Figure 4.5 – Mesh depth material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Mesh depth material</p>
			<p>In this example, you can add and remove cubes by clicking on the relevant buttons in the menu. What you’ll see is that the cubes that are close to the camera are rendered very bright, and those farther away from the camera are rendered less bright. In this example, you can see how this works by playing around with the properties of the <code>Perspective Camera</code> settings. By playing around with the <code>far</code> and <code>near</code> properties of the camera, you can change the brightness of all the cubes in the scene.</p>
			<p>Normally, you wouldn’t use this material as the only material for a mesh; instead, you’d combine it with a different material. We’ll see how that works in the next section.</p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Combining materials</h2>
			<p>If you look back at the properties of <code>THREE.MeshDepthMaterial</code>, you will see that there isn’t an option<a id="_idIndexMarker315"/> to set the color of the cubes. Everything was decided for you by the default properties of the material. Three.js, however, has the option to combine materials to create new effects (this is also where blending comes into play). The following code shows how we can combine materials:</p>
			<pre class="source-code">
import * as SceneUtils from 'three/examples/jsm/
  utils/SceneUtils'
const material1 = new THREE.MeshDepthMaterial()
const material2 = new THREE.MeshBasicMaterial({ color:
  0xffff00 })
const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5)
const cube = SceneUtils.createMultiMaterialObject(geometry,
  [material2, material1])</pre>
			<p>First, we create our two materials. For <code>THREE.MeshDepthMaterial</code>, we don’t do anything special; for <code>THREE.MeshBasicMaterial</code>, we just set the color. The last line in this code fragment is also an important one. When we create a mesh with the <code>SceneUtils.createMultiMaterialObject()</code> function, the geometry gets copied and two of the same meshes are returned in a group.</p>
			<p>We get the following green-colored cubes that use the brightness from <code>THREE.MeshDepthMaterial</code> and the color from <code>THREE.MeshBasicMaterial</code>. You can see how this works by opening the <code>combining-materials.html</code> example in the <code>chapter-4</code> folder in your browser:</p>
			<div><div><img src="img/Figure_4.06_B18726.jpg" alt="Figure 4.6 – Combining materials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Combining materials</p>
			<p>When you open this example for the first time, you’ll just see the solid objects, without any effect from <code>THREE.MeshDepthMaterial</code>. To combine the colors, we also need to specify how these colors blend. In the menu on the right in <em class="italic">Figure 4</em><em class="italic">.6</em>, you can specify this using the <code>blending</code> property. For this example, we’ve used the <code>THREE.AdditiveBlending</code> mode, which means<a id="_idIndexMarker316"/> the colors are added together, and the resulting color is shown. This example is a great way to play around with the different blending options, and see how they affect the final color of the material.</p>
			<p>The next material is also one where we won’t have any influence on the colors used in rendering.</p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>THREE.MeshNormalMaterial</h2>
			<p>The easiest way to understand<a id="_idIndexMarker317"/> how this material<a id="_idIndexMarker318"/> is rendered is by first looking at an example. Open up the <code>mesh-normal-material.html</code> example in the <code>chapter-4</code> folder and enable <code>flatShading</code>:</p>
			<div><div><img src="img/Figure_4.07_B18726.jpg" alt="Figure 4.7 – Mesh normal material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Mesh normal material</p>
			<p>As you can see, each face of the mesh is rendered in a slightly different color. This happens because the color of each face is based on the normals pointing out from the face. And this face normal is based on the normal vector of the individual vertices that make up the face. A normal vector is perpendicular to the face of a vertex. The normal vector is used in many different parts of Three.js. It is used to determine light reflections, helps with mapping textures to 3D models, and provides information on how to light, shade, and color pixels on the surface. Luckily, though, Three.js handles the computation of these vectors and uses them internally, so you don’t have to calculate or deal with them yourselves.</p>
			<p>Three.js comes with a helper<a id="_idIndexMarker319"/> to visualize this normal, and you can show<a id="_idIndexMarker320"/> this by enabling the <code>vertexHelpers</code> property in the menu:</p>
			<div><div><img src="img/Figure_4.08_B18726.jpg" alt="Figure 4.8 – Mesh normal helpers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Mesh normal helpers</p>
			<p>Adding this helper yourself can be done in a couple of lines of code:</p>
			<pre class="source-code">
Import { VertexNormalsHelper } from 'three/examples/jsm/
  helpers/VertexNormalsHelper'
...
const helper = new VertexNormalsHelper(mesh, 0.1, 0xff0000)
helper.name = 'VertexNormalHelper'
scene.add(helper)</pre>
			<p><code>VertexNormalsHelper</code> takes three<a id="_idIndexMarker321"/> parameters. The first one is <code>THREE.Mesh</code>, for which you want<a id="_idIndexMarker322"/> to see the helpers, the second one is the length of the arrow, and the last one is the color.</p>
			<p>Let’s take this example as an opportunity to look at the <code>shading</code> property. With the <code>shading</code> property, we can tell Three.js how to render our objects. If you use <code>THREE.FlatShading</code>, each face will be rendered as-is (as you can see in the previous following screenshot), or you can use <code>THREE.SmoothShading</code>, which smooths out the faces of our objects. For instance, if we render the same sphere using <code>THREE.SmoothShading</code>, the result will look like this:</p>
			<div><div><img src="img/Figure_4.09_B18726.jpg" alt="Figure 4.9 – Mesh normal smooth shading"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Mesh normal smooth shading</p>
			<p>We’re done with the simple materials, but let’s look at one additional subject before moving on. In the next section, we’ll look at how you can use different materials for specific faces of a geometry.</p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Multiple materials for a single mesh</h2>
			<p>When creating <code>THREE.Mesh</code>, so far, we’ve used a single<a id="_idIndexMarker323"/> material. It is also <a id="_idIndexMarker324"/>possible to define a specific material for each of the faces of a geometry. For instance, if you have a cube that has 12 faces (remember, Three.js works with triangles), you can assign a different material (for example, with a different color) to each side of the cube. Doing this is straightforward, as shown in the following piece of code:</p>
			<pre class="source-code">
const mat1 = new THREE.MeshBasicMaterial({ color: 0x777777
  })
const mat2 = new THREE.MeshBasicMaterial({ color: 0xff0000
  })
const mat3 = new THREE.MeshBasicMaterial({ color: 0x00ff00
  })
const mat4 = new THREE.MeshBasicMaterial({ color: 0x0000ff
  })
const mat5 = new THREE.MeshBasicMaterial({ color: 0x66aaff
  })
const mat6 = new THREE.MeshBasicMaterial({ color: 0xffaa66
  })
const matArray = [mat1, mat2, mat3, mat4, mat5, mat6]
const cubeGeom = new THREE.BoxGeometry(1, 1, 1, 10, 10, 10)
const cubeMesh = new THREE.Mesh(cubeGeom, material)</pre>
			<p>We create an array, named <code>matArray</code>, to hold all the materials, and use that array to create <code>THREE.Mesh</code>. What you might notice is that we only create six materials, even though we’ve got 12 faces. To understand<a id="_idIndexMarker325"/> how this works, we have<a id="_idIndexMarker326"/> to look at how Three.js assigns a material to a face. Three.js uses the <code>groups</code> property for this. To see this yourself, open up the source code for <code>multi-material.js</code> and add the <code>debugger</code> statement, like this:</p>
			<pre class="source-code">
  const group = new THREE.Group()
  for (let x = 0; x &lt; 3; x++) {
    for (let y = 0; y &lt; 3; y++) {
      for (let z = 0; z &lt; 3; z++) {
        const cubeMesh = sampleCube([mat1, mat2, mat3,
          mat4, mat5, mat6], 0.95)
        cubeMesh.position.set(x - 1.5, y - 1.5, z - 1.5)
        group.add(cubeMesh)
        debugger
      }
    }
  }</pre>
			<p>This will cause the browser to stop executing, and allows you to inspect all the objects from the console of the browser:</p>
			<div><div><img src="img/Figure_4.10_B18726.jpg" alt="Figure 4.10 – Using the debugger statement to stop execution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Using the debugger statement to stop execution</p>
			<p>In the browser, if you open<a id="_idIndexMarker327"/> the <code>cubeMesh</code>, we can use <code>console.log(cubeMesh)</code>:</p>
			<div><div><img src="img/Figure_4.11_B18726.jpg" alt="Figure 4.11 – Printing out information about an object"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Printing out information about an object</p>
			<p>If you look further into the <code>geometry</code> property of <code>cubeMesh</code>, you will see <code>groups</code>. This property is an array<a id="_idIndexMarker329"/> that consists of six elements, where each<a id="_idIndexMarker330"/> element contains the range of vertices that belong to that group, and an additional property called <code>materialIndex</code> that specifies which of the passed-in materials should be used for that group of vertices:</p>
			<pre class="source-code">
[{ "start": 0,    "count": 600, "materialIndex": 0 },
 { "start": 600,  "count": 600, "materialIndex": 1 },
 { "start": 1200, "count": 600, "materialIndex": 2 },
 { "start": 1800, "count": 600, "materialIndex": 3 },
 { "start": 2400, "count": 600, "materialIndex": 4 },
 { "start": 3000, "count": 600, "materialIndex": 5 }]</pre>
			<p>So, if you create your own objects from scratch, and want to apply different materials to different vertices groups, you have to make sure you set the <code>groups</code> property correctly. For the objects created by Three.js, you don’t have to do this manually, since Three.js already does this.</p>
			<p>With this approach, it’s very simple<a id="_idIndexMarker331"/> to create interesting<a id="_idIndexMarker332"/> models. For instance, we can easily create a simple 3D Rubik’s Cube, as you can see in the <code>multi-materials.html</code> example:</p>
			<div><div><img src="img/Figure_4.12_B18726.jpg" alt="Figure 4.12 – Multi-material with six different materials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Multi-material with six different materials</p>
			<p>We’ve also added controls for the materials that are applied to each side to experiment with. Creating this cube is not much different than what we saw in the <em class="italic">Multiple materials for a single </em><em class="italic">mesh</em> section:</p>
			<pre class="source-code">
const group = new THREE.Group()
const mat1 = new THREE.MeshBasicMaterial({ color: 0x777777
  })
const mat2 = new THREE.MeshBasicMaterial({ color: 0xff0000
  })
const mat3 = new THREE.MeshBasicMaterial({ color: 0x00ff00
  })
const mat4 = new THREE.MeshBasicMaterial({ color: 0x0000ff
  })
const mat5 = new THREE.MeshBasicMaterial({ color: 0x66aaff
  })
const mat6 = new THREE.MeshBasicMaterial({ color: 0xffaa66
  })
for (let x = 0; x &lt; 3; x++) {
  for (let y = 0; y &lt; 3; y++) {
    for (let z = 0; z &lt; 3; z++) {
      const cubeMesh = sampleCube([mat1, mat2, mat3, mat4,
        mat5, mat6], 0.95)
      cubeMesh.position.set(x - 1.5, y - 1.5, z - 1.5)
      group.add(cubeMesh)
    }
  }
}</pre>
			<p>In this piece of code, first, we create <code>THREE.Group</code>, which will hold all the individual cubes (group); next, we create<a id="_idIndexMarker333"/> the materials for each side<a id="_idIndexMarker334"/> of the cube. Then, we create three loops to make sure we create the right number of cubes. In this loop, we create each of the individual cubes, assign the materials, position them, and add them to the group. What you should remember is that the position of the cubes is relative to the position of this group. If we move or rotate the group, all the cubes will move and rotate with it. For more<a id="_idIndexMarker335"/> information on how<a id="_idIndexMarker336"/> to work with groups, look at <a href="B18726_08.xhtml#_idTextAnchor132"><em class="italic">Chapter 8</em></a>, <em class="italic">Creating and Loading Advanced Meshes </em><em class="italic">and Geometries</em>.</p>
			<p>And that wraps up this section on basic materials and how to combine them. In the following section, we’ll look at more advanced materials.</p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Advanced materials</h1>
			<p>In this section, we’ll look at the more<a id="_idIndexMarker337"/> advanced materials Three.js has to offer. We’ll look at the following materials:</p>
			<ul>
				<li><code>THREE.MeshLambertMaterial</code>: A material for rough-looking surfaces</li>
				<li><code>THREE.MeshPhongMaterial</code>: A material for shiny-looking surfaces</li>
				<li><code>THREE.MeshToonMaterial</code>: Renders the mesh in a cartoon-like fashion</li>
				<li><code>THREE.ShadowMaterial</code>: A material that only shows shadows cast on it; the material is otherwise is transparent</li>
				<li><code>THREE.MeshStandardMaterial</code>: A versatile material that can be used to represent many different kinds of surfaces</li>
				<li><code>THREE.MeshPhysicalMaterial</code>: Similar to <code>THREE.MeshStandardMaterial</code> but provides additional properties for more real-world-like surfaces</li>
				<li><code>THREE.ShaderMaterial</code>: A material where you can define for yourself how to render the object by writing your own shaders</li>
			</ul>
			<p>We’ll start with <code>THREE.MeshLambertMaterial</code>.</p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>THREE.MeshLambertMaterial</h2>
			<p>This material<a id="_idIndexMarker338"/> can be used to create<a id="_idIndexMarker339"/> dull-looking, non-shiny surfaces. This is a very easy-to-use material that responds to the lighting sources in the scene. This material can be configured with the basic properties we’ve already seen, so we won’t go into the details of those properties; instead, we will focus on the ones specific to this material. That just leaves us with the<a id="_idIndexMarker340"/> following properties:</p>
			<ul>
				<li><code>color</code>: This is the color of the material.</li>
				<li><code>emissive</code>: This is the color the material emits. It doesn’t act as a light source, but this is a solid color that is unaffected by other lighting. This defaults to black. You can use this to create objects that look like they glow.</li>
				<li><code>emissiveIntensity</code>: The intensity with which the object seems to glow.</li>
			</ul>
			<p>Creating this object follows<a id="_idIndexMarker341"/> the same approach we’ve seen<a id="_idIndexMarker342"/> for the other materials:</p>
			<pre class="source-code">
const material = new THREE.MeshLambertMaterial({color:
  0x7777ff});</pre>
			<p>For an example of this material, look at the <code>mesh-lambert-material.html</code> example:</p>
			<div><div><img src="img/Figure_4.13_B18726.jpg" alt="Figure 4.13 – Mesh lambert material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Mesh lambert material</p>
			<p>This screenshot shows<a id="_idIndexMarker343"/> a torus knot, in white, with a very light red emissive<a id="_idIndexMarker344"/> glow. One of the interesting features of <code>THREE.LambertMaterial</code> is that it also supports the wireframe properties, so you can render a wireframe that responds to the lights in the scene:</p>
			<div><div><img src="img/Figure_4.14_B18726.jpg" alt="Figure 4.14 – Mesh Lambert material with a wireframe"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Mesh Lambert material with a wireframe</p>
			<p>The next material works in pretty much the same way but can be used to create shiny objects.</p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>THREE.MeshPhongMaterial</h2>
			<p>With <code>THREE.MeshPhongMaterial</code>, we can create<a id="_idIndexMarker345"/> a shiny material. The properties you can use for that are pretty<a id="_idIndexMarker346"/> much the same as for a non-shiny <code>THREE.MeshLambertMaterial</code> object. In older versions, this was the only material that you could use to make shiny, plastic, or metal-like objects. With newer versions of Three.js, if you want more control, you can also use <code>THREE.MeshStandardMaterial</code> and <code>THREE.MeshPhysicalMaterial</code>. We’ll discuss both of these materials after we look at <code>THREE.MeshPhongMaterial</code>.</p>
			<p>We’ll once again skip the basic properties and focus on the properties specific to this material. The properties<a id="_idIndexMarker347"/> of this material are listed here:</p>
			<ul>
				<li><code>emissive</code>: This is the color this material emits. It doesn’t act as a light source, but this is a solid color that is unaffected by other lighting. This defaults to black.</li>
				<li><code>emissiveIntensity</code>: The intensity with which the object seems to glow.</li>
				<li><code>specular</code>: This property defines how shiny the material is and with what color it shines. If this is set to the same color as the <code>color</code> property, you get a more metallic-looking material. If this is set to gray, it results in a more plastic-looking material.</li>
				<li><code>shininess</code>: This property defines how shiny the specular highlight is. The default value for <code>shininess</code> is <code>30</code>. The higher this value is, the shinier the object is.</li>
			</ul>
			<p>Initializing a <code>THREE.MeshPhongMaterial</code> material is done<a id="_idIndexMarker348"/> in the same way as we’ve already seen for all the other materials <a id="_idIndexMarker349"/>and is shown in the following line of code:</p>
			<pre class="source-code">
const meshMaterial = new THREE.MeshPhongMaterial({color:
  0x7777ff});</pre>
			<p>To give you the best comparison, we will keep using the same models for this material as we did for <code>THREE.MeshLambertMaterial</code> and the other materials in this chapter. You can use the control GUI to play around with this material. For instance, the following settings create a plastic-looking material. You can find this example in <code>mesh-phong-material.html</code>:</p>
			<div><div><img src="img/Figure_4.15_B18726.jpg" alt="Figure 4.15 – Mesh Phong material with high shininess"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Mesh Phong material with high shininess</p>
			<p>As you can see from this screenshot, the object is more shiny and plastic compared to what we saw with <code>THREE.MeshLambertMaterial</code>.</p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>THREE.MeshToonMaterial</h2>
			<p>Not all the materials<a id="_idIndexMarker350"/> Three.js provides<a id="_idIndexMarker351"/> are practical. For instance, <code>THREE.MeshToonMaterial</code> allows you to render an object in a cartoon-like style (see the <code>mesh-toon-material.html</code> example):</p>
			<div><div><img src="img/Figure_4.16_B18726.jpg" alt="Figure 4.16 – The fox model rendered with MeshToonMaterial"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – The fox model rendered with MeshToonMaterial</p>
			<p>As you can see, it looks a little bit like what<a id="_idIndexMarker352"/> we saw with <code>THREE.MeshBasicMaterial</code>, but this material responds<a id="_idIndexMarker353"/> to the lights in the scene and supports shadows. It just bands colors together to create a cartoon-like effect.</p>
			<p>If you want more realistic materials, <code>THREE.MeshStandardMaterial</code> is a good choice.</p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>THREE.MeshStandardMaterial</h2>
			<p><code>THREE.MeshStandardMaterial</code> is a material<a id="_idIndexMarker354"/> that takes a physics<a id="_idIndexMarker355"/> approach to determine how to react to the lighting in the scene. It is a great material for shiny and metal-like materials, and provides<a id="_idIndexMarker356"/> several properties you can use to configure this material:</p>
			<ul>
				<li><code>metalness</code>: This property determines how metal-like a material is. Non-metallic materials should use a value of <code>0</code>, whereas metallic materials should use a value close to 1. The default is <code>0.5</code>.</li>
				<li><code>roughness</code>: You can also set how rough the material is. This determines how the light that hits this material is diffused. The default is <code>0.5</code>. A value of <code>0</code> is a mirror-like reflection, whereas a value of <code>1</code> diffuses all the light.</li>
			</ul>
			<p>Besides these properties, you can also<a id="_idIndexMarker357"/> use the <code>color</code> and <code>emissive</code> properties, as well as the<a id="_idIndexMarker358"/> properties from <code>THREE.Material</code>, to alter this material. As you can see in the following screenshot, we can use these properties to simulate a kind of brushed metal look by playing around with the <code>metalness</code> and <code>roughness</code> parameters:</p>
			<div><div><img src="img/Figure_4.17_B18726.jpg" alt="Figure 4.17 – Creating a brushed metal effect with MeshStandardMaterial"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Creating a brushed metal effect with MeshStandardMaterial</p>
			<p>Three.js provides a material that provides even more settings to render real-looking objects: <code>THREE.MeshPhysicalMaterial</code>.</p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>THREE.MeshPhysicalMaterial</h2>
			<p>A material very<a id="_idIndexMarker359"/> close to <code>THREE.MeshStandardMaterial</code> is <code>THREE.MeshPhysicalMaterial</code>. With this material, you have more control<a id="_idIndexMarker360"/> over the reflectivity of the material. This material provides, besides the properties we’ve already seen for <code>THREE.MeshPhysicalMaterial</code>, the following properties to help you control what the material looks like:</p>
			<ul>
				<li><code>clearCoat</code>: A value indicating a coating layer on top of the material. The higher this value is, the more coating<a id="_idIndexMarker361"/> is applied, and the more effective the <code>clearCoatRoughness</code> parameter is. This value ranges from <code>0</code> to <code>1</code> with a default of <code>0</code>.</li>
				<li><code>clearCoatRoughness</code>: The roughness used for the coating of the material. The rougher it is, the more light is diffused. This is used together with the <code>clearCoat</code> property. This value ranges from <code>0</code> to <code>1</code> with a default of <code>0</code>.</li>
			</ul>
			<p>As we’ve seen for other<a id="_idIndexMarker362"/> materials, it is quite hard to reason about the values you should use for your specific requirements. It’s often the best choice<a id="_idIndexMarker363"/> to add a simple UI (as we do in the examples) and play around with the values to get to a combination that best reflects your needs. You can see this example in action by looking at the <code>mesh-physical-material.html</code> example:</p>
			<div><div><img src="img/Figure_4.18_B18726.jpg" alt="Figure 4.18 – Mesh physical material using a clear coat to control reflection"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – Mesh physical material using a clear coat to control reflection</p>
			<p>Most of the advanced materials cast and receive shadows. The next material we’re going to have a quick look at is a bit different than most. This material doesn’t render the object itself, but only shows the shadows.</p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>THREE.ShadowMaterial</h2>
			<p><code>THREE.ShadowMaterial</code> is a special material that doesn’t have<a id="_idIndexMarker364"/> any properties. You can’t set<a id="_idIndexMarker365"/> the color or the shininess, or anything else. The only thing this material does is render the shadow the mesh would receive. The following screenshot should explain this:</p>
			<div><div><img src="img/Figure_4.19_B18726.jpg" alt="Figure 4.19 – Shadow material just rendering the shadows the mesh receives"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – Shadow material just rendering the shadows the mesh receives</p>
			<p>Here, the only thing<a id="_idIndexMarker366"/> we can see are the shadows the object receives, nothing<a id="_idIndexMarker367"/> else. This material can, for instance, be combined with your own materials without you having to determine how to receive shadows.</p>
			<p>The last of the advanced materials we’ll explore is <code>THREE.ShaderMaterial</code>.</p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Using your own shaders with THREE.ShaderMaterial</h2>
			<p><code>THREE.ShaderMaterial</code> is one of the most versatile<a id="_idIndexMarker368"/> and complex materials<a id="_idIndexMarker369"/> available in Three.js. With this material, you can pass in your own custom shaders that are directly run in the WebGL context. A shader converts Three.js JavaScript meshes into pixels on the screen. With these custom shaders, you can define exactly how your object should be rendered and how to override or alter the defaults from Three.js. In this section, we won’t go into too much detail on how to write custom shaders; instead, we will just show you a couple of examples.</p>
			<p>As we’ve already seen, <code>THREE.ShaderMaterial</code> has several properties<a id="_idIndexMarker370"/> you can set. With <code>THREE.ShaderMaterial</code>, Three.js passes<a id="_idIndexMarker371"/> in all the information regarding these properties to your custom shaders, but you still have to process the information to create colors and vertex positions. The following are the properties of <code>THREE.Material</code> that are passed into the shader, and that you can interpret for yourself:</p>
			<ul>
				<li><code>wireframe</code>: This renders <a id="_idIndexMarker372"/>the material as a wireframe. This is great for debugging purposes.</li>
				<li><code>shading</code>: This defines how shading is applied. The possible values are <code>THREE.SmoothShading</code> and <code>THREE.FlatShading</code>. This property isn’t enabled in the example for this material. For an example, look at the <em class="italic">THREE. </em><em class="italic">MeshNormalMaterial</em> section.</li>
				<li><code>vertexColors</code>: You can define individual colors to be applied to each vertex with this property. Look at the <code>LineBasicMaterial</code> example in the <em class="italic">THREE.LineBasicMaterial</em> section, where we use this property to color the various parts of a line.</li>
				<li><code>fog</code>: This determines whether this material is affected by global fog settings. This is not shown in action. If this is set to <code>false</code>, the global fog we saw in <a href="B18726_02.xhtml#_idTextAnchor028"><em class="italic">Chapter 2</em></a> doesn’t affect how this object is rendered.</li>
			</ul>
			<p>Besides these properties that are passed into the shader, <code>THREE.ShaderMaterial</code> also provides several specific properties you can use to pass in additional information into your custom shader. Once again, we won’t go into too much detail on how you can write your own shaders, since that would be a book on its own, so we’ll just cover the basics:</p>
			<ul>
				<li><code>fragmentShader</code>: This shader defines the color of each pixel that is passed in. Here, you need to pass in the string value of your fragment shader program.</li>
				<li><code>vertextShader</code>: This shader allows you to change the position of each vertex that is passed in. Here, you need to pass in the string value of your vertex shader program.</li>
				<li><code>uniforms</code>: This allows you to send information to your shader. The same information is sent to each vertex and fragment.</li>
				<li><code>defines</code>: Converts custom key value pairs as <code>#define</code> code fragments. With these fragments, you can set some additional global variables in the shader programs or define your own custom global constants.</li>
				<li><code>attributes</code>: These can change between each vertex and fragment. They are usually used to pass positional and normal-related data. If you want to use this property, you need to provide information for all the vertices of the geometry.</li>
				<li><code>lights</code>: This determines whether light data should be passed into the shaders. This defaults to <code>false</code>.</li>
			</ul>
			<p>Before we look at an example, we’ll provide<a id="_idIndexMarker373"/> a quick explanation<a id="_idIndexMarker374"/> of the most important parts of <code>THREE.ShaderMaterial</code>. To work with this material, we have to pass in two different shaders:</p>
			<ul>
				<li><code>vertexShader</code>: This is run on each vertex of the geometry. You can use this shader to transform the geometry by moving the position of the vertices around.</li>
				<li><code>fragmentShader</code>: This is run on each fragment of the geometry. In <code>fragmentShader</code>, we return the color that should be shown for this specific fragment.</li>
			</ul>
			<p>For all the materials we’ve discussed so far in this chapter, Three.js provides <code>fragmentShader</code> and <code>vertexShader</code>, so you don’t have to worry about them and pass them in explicitly.</p>
			<p>In this section, we’ll look at a simple example that uses a very simple <code>vertexShader</code> program that changes the <code>x</code> and <code>y</code> coordinates of the vertices of a simple <code>THREE.PlainGeometry</code> and a <code>fragmentShader</code> program that changes the color based on some input.</p>
			<p>Up next, you can see the complete<a id="_idIndexMarker375"/> code for our <code>vertexShader</code>. Note that writing shaders isn’t done in JavaScript. You write shaders in a C-like<a id="_idIndexMarker376"/> language<a id="_idIndexMarker377"/> called GLSL (WebGL supports OpenGL ES Shading Language 1.0 — for more information<a id="_idIndexMarker378"/> on GLSL, see <a href="https://www.khronos.org/webgl/">https://www.khronos.org/webgl/</a>). The code for our simple shader looks like this:</p>
			<pre class="source-code">
uniform float time;
void main(){
  vec3 posChanged=position;
  posChanged.x=posChanged.x*(abs(sin(time*2.)));
  posChanged.y=posChanged.y*(abs(cos(time*1.)));
  posChanged.z=posChanged.z*(abs(sin(time*.5)));
  gl_Position=projectionMatrix*modelViewMatrix*vec4
    (posChanged,1.);
}</pre>
			<p>We won’t go into too much detail here and just focus on the most important parts of this code. To communicate with the shaders from JavaScript, we use something called uniforms. In this example, we use the <code>uniform float time;</code> statement to pass in an external value.</p>
			<p>Based on this value, we change the <code>x</code>, <code>y</code>, and <code>z</code> coordinates of the passed-in vertex (which is passed in as the position variable):</p>
			<pre class="source-code">
  posChanged.x=posChanged.x*(abs(sin(time*2.)));
  posChanged.y=posChanged.y*(abs(cos(time*1.)));
  posChanged.z=posChanged.z*(abs(sin(time*.5)));</pre>
			<p>The <code>posChanged</code> vector now contains the new coordinate for this vertex based on the passed-in time variable. The last step we need to perform is to pass this new position back to the renderer, which is always done like this for Three.js:</p>
			<pre class="source-code">
  gl_Position=projectionMatrix*modelViewMatrix*vec4
    (posChanged,1.);</pre>
			<p>The <code>gl_Position</code> variable is a special variable<a id="_idIndexMarker379"/> that is used to return<a id="_idIndexMarker380"/> the final position. This program is passed as a string value to the <code>vertexShader</code> property of <code>THREE.ShaderMaterial</code>. For <code>fragmentShader</code>, we do something similar. We’ve created a very simple fragment shader that just flips through colors based on the passed-in <code>time</code> uniform:</p>
			<pre class="source-code">
uniform float time;
void main(){
  float c1=mod(time,.5);
  float c2=mod(time,.7);
  float c3=mod(time,.9);
  gl_FragColor=vec4(c1,c2,c3,1.);
}</pre>
			<p>What we do in a <code>fragmentShader</code> is determine the color of a passed-in fragment (a pixel). The real shader programs take a lot into account, such as lights, the position of the vertex on the face, normals, and more. In this example, though, we just determine the <code>rgb</code> values of a color and return that in <code>gl_FragColor</code>, which is then shown on the final rendered mesh.</p>
			<p>Now, we need to glue the geometry, the material, and the two shaders together. In Three.js, we can do that like this:</p>
			<pre class="source-code">
const geometry = new THREE.PlaneGeometry(10, 10, 100, 100)
const material = new THREE.ShaderMaterial({
  uniforms: {
    time: { value: 1.0 }
  },
  vertexShader: vs_simple,
  fragmentShader: fs_simple
})
const mesh = new THREE.Mesh(geometry, material)</pre>
			<p>Here, we define the <code>time</code> uniform, which will contain a value<a id="_idIndexMarker381"/> available in the<a id="_idIndexMarker382"/> shaders, and define <code>vertexShader</code> and <code>fragmentShader</code> as strings that we want to use. The only thing we need to do is make sure we change the <code>time</code> uniform in the render loop, and that’s it:</p>
			<pre class="source-code">
// in the renderloop
material.uniforms.time.value += 0.005</pre>
			<p>In the examples for this chapter, we’ve added a couple of simple shaders to experiment with. You will see the results if you open up the <code>shader-material-vertex.html</code> example in the <code>chapter-4</code> folder:</p>
			<div><div><img src="img/Figure_4.20_B18726.jpg" alt="Figure 4.20 – A shader material that shows a plane with the two example shader programs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – A shader material that shows a plane with the two example shader programs</p>
			<p>In the dropdown menu, you can also find<a id="_idIndexMarker383"/> a couple of other<a id="_idIndexMarker384"/> shaders. For instance, the <code>fs_night_sky</code> fragment shader<a id="_idIndexMarker385"/> shows a starry night (based on the shader from <a href="https://www.shadertoy.com/view/Nlffzj">https://www.shadertoy.com/view/Nlffzj</a>). When combined with <code>vs_ripple</code>, you get a very nice-looking effect, completely running on the GPU, as shown here:</p>
			<div><div><img src="img/Figure_4.21_B18726.jpg" alt="Figure 4.21 – Rippling effect with a starry night fragment shader"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21 – Rippling effect with a starry night fragment shader</p>
			<p>It is possible to combine existing materials<a id="_idIndexMarker386"/> and reuse their fragment <a id="_idIndexMarker387"/>and vertex shaders with your own shaders. That way, you can, for instance, extend <code>THREE.MeshStandardMaterial</code> with some custom effects. Doing this in plain Three.js, however, is rather difficult to do and very error prone. Luckily, there is an open source project that provides us with a custom material that makes it very easy to wrap existing materials and add our own custom shaders. In the next section, we’ll have a quick look at how that works.</p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Customizing existing shaders with CustomShaderMaterial</h2>
			<p><code>THREE.CustomShader</code> doesn’t come with<a id="_idIndexMarker388"/> the default Three.js<a id="_idIndexMarker389"/> distribution, but since we’re using <code>yarn</code>, it is really easy to install (this is what you did when running the relevant commands from <a href="B18726_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Creating Your First 3D Scene wth Three.js</em>). If you want more information on this module, you can check out <a href="https://github.com/FarazzShaikh/THREE-CustomShaderMaterial">https://github.com/FarazzShaikh/THREE-CustomShaderMaterial</a>, where you can find documentation and additional examples.</p>
			<p>First, let’s have a quick look at the code before we show some examples. Using <code>THREE.CustomShader</code> is the same as using the other materials:</p>
			<pre class="source-code">
const material = new CustomShaderMaterial({
  baseMaterial: THREE.MeshStandardMaterial,
  vertexShader: ...,
  fragmentShader: ...,
  uniforms: {
    time: { value: 0.2 },
    resolution: { value: new THREE.Vector2() }
  },
  flatShading: true,
  color: 0xffffff
})</pre>
			<p>As you can see, it is a bit of a combination of a normal material and a <code>THREE.ShaderMaterial</code>. The main thing to look at is the <code>baseMaterial</code> property. Here, you can add any of the standard Three.js materials. Any additional property you add, besides <code>vertexShader</code>, <code>fragmentShader</code>, and <code>uniforms</code>, gets applied to this <code>baseMaterial</code>. The <code>vertexshader</code>, <code>fragmentShader</code>, and <code>uniforms</code> properties work in the same way as we’ve seen for <code>THREE.ShaderMaterial</code>.</p>
			<p>Out of the box, we need to make a couple of small changes to our shaders themselves. Recall the <em class="italic">Using your own shaders with THREE.ShaderMaterial</em> section, where we used <code>gl_Position</code> and <code>gl_FragColor</code> to set the final output<a id="_idIndexMarker390"/> of the position of a vertex and the color<a id="_idIndexMarker391"/> of a fragment. With this material, we use <code>csm_Position</code> for the final position and <code>csm_DiffuseColor</code> for the color. There are a couple more output variables you can use, which are explained in more detail here: <a href="https://github.com/FarazzShaikh/THREE-CustomShaderMaterial#output-variables">https://github.com/FarazzShaikh/THREE-CustomShaderMaterial#output-variables</a>.</p>
			<p>If you open the <code>custom-shader-material</code> example, you will see how our simple shaders can be used together with the default materials from Three.js:</p>
			<div><div><img src="img/Figure_4.22_B18726.jpg" alt="Figure 4.22 – Ripple effect with an environment map using MeshStandardMaterials as the base"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22 – Ripple effect with an environment map using MeshStandardMaterials as the base</p>
			<p>This approach gives you a relatively easy way to create your custom shaders, without having to start completely from scratch. You can just reuse the lights and shadow effects from the default shaders<a id="_idIndexMarker392"/> and extend them with<a id="_idIndexMarker393"/> your custom-needed functionality.</p>
			<p>So far, we’ve looked at materials that work with meshes. Three.js also provides materials that can be used together with line geometries. In the next section, we’ll explore those materials.</p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Materials you can use for a line geometry</h1>
			<p>The last couple<a id="_idIndexMarker394"/> of materials<a id="_idIndexMarker395"/> we’re going to look at can only be used on one specific mesh: <code>THREE.Line</code>. As the name implies, this is just a single line that only consists of lines and doesn’t contain any faces. Three.js provides two different materials you can use on a <code>THREE.Line</code> geometry, as follows:</p>
			<ul>
				<li><code>THREE.LineBasicMaterial</code>: This basic material for a line allows you to set the <code>color</code> and <code>vertexColors</code> properties.</li>
				<li><code>THREE.LineDashedMaterial</code>: This has the same properties as <code>THREE.LineBasicMaterial</code> but allows you to create a dashed line effect by specifying <code>dash</code> and <code>spacing</code> sizes.</li>
			</ul>
			<p>We’ll start with the basic variant; after that, we’ll look at the dashed variant.</p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>THREE.LineBasicMaterial</h2>
			<p>The materials<a id="_idIndexMarker396"/> that are available<a id="_idIndexMarker397"/> for the <code>THREE.Line</code> geometry are very simple. It inherits all of the properties from <code>THREE.Material</code>, but the following are the properties that are most important for this material:</p>
			<ul>
				<li><code>color</code>: This determines the color<a id="_idIndexMarker398"/> of the line. If you specify <code>vertexColors</code>, this property is ignored. An example of how to do this is shown in the following code fragment.</li>
				<li><code>vertexColors</code>: You can supply a specific color for each vertex by setting this property to the <code>THREE.VertexColors</code> value.</li>
			</ul>
			<p>Before we look at an example of <code>THREE.LineBasicMaterial</code>, let’s have a quick look at how we can create a <code>THREE.Line</code> mesh from a set of vertices and combine that with <code>THREE.LineMaterial</code> to create the mesh, as shown in the following code:</p>
			<pre class="source-code">
const points = gosper(4, 50)
const lineGeometry = new THREE.BufferGeometry().
  setFromPoints(points)
const colors = new Float32Array(points.length * 3)
points.forEach((e, i) =&gt; {
  const color = new THREE.Color(0xffffff)
  color.setHSL(e.x / 100 + 0.2, (e.y * 20) / 300, 0.8)
  colors[i * 3] = color.r
  colors[i * 3 + 1] = color.g
  colors[i * 3 + 2] = color.b
})
lineGeometry.setAttribute('color', new THREE.
  BufferAttribute(colors, 3, true))
const material = new THREE.LineBasicMaterial(0xff0000);
const mesh = new THREE.Line(lineGeometry, material)
mesh.computeLineDistances()</pre>
			<p>The first part<a id="_idIndexMarker399"/> of this code fragment, <code>const points = gosper(4, 60)</code>, is used as an example<a id="_idIndexMarker400"/> to get a set of <code>x</code>, <code>y</code>, and <code>z</code> coordinates. This function returns<a id="_idIndexMarker401"/> a Gosper curve (for more information, check out <a href="https://mathworld.wolfram.com/Peano-GosperCurve.html">https://mathworld.wolfram.com/Peano-GosperCurve.html</a>), which is a simple algorithm that fills a 2D space. What we do next is create a <code>THREE.BufferGeometry</code> instance and call the <code>setFromPoints</code> function to add the generated points. For each coordinate, we also calculate a color value that we use to set the <code>color</code> attribute of the geometry. Note <code>mesh.computeLineDistances</code> at the end of this code fragment. This is needed when you want to have dashed lines when using <code>THREE.LineDashedMaterial</code>.</p>
			<p>Now that we have our geometry, we can create <code>THREE.LineBasicMaterial</code> and use this together with the geometry<a id="_idIndexMarker402"/> to create a <code>THREE.Line</code> mesh. You can see<a id="_idIndexMarker403"/> the result in the <code>line-basic-material.html</code> example. The following screenshot shows this example:</p>
			<div><div><img src="img/Figure_4.23_B18726.jpg" alt="Figure 4.23 – Line basic material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23 – Line basic material</p>
			<p>This is a line geometry created with <code>THREE.LineBasicMaterial</code>. If we enable the <code>vertexColors</code> property, we will see that the individual line segments are colored:</p>
			<div><div><img src="img/Figure_4.24_B18726.jpg" alt="Figure 4.24 – Line basic material with vertex colors"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24 – Line basic material with vertex colors</p>
			<p>The next and last material we’ll discuss in this chapter is only slightly different from <code>THREE.LineBasicMaterial</code>. With <code>THREE.LineDashedMaterial</code>, not only can we color lines, but we can also add spaces to those lines.</p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>THREE.LineDashedMaterial</h2>
			<p>This material has the same<a id="_idIndexMarker404"/> properties as <code>THREE.LineBasicMaterial</code> and three additional<a id="_idIndexMarker405"/> ones you can use to define the dash width and the width of the gaps between the dashes:</p>
			<ul>
				<li><code>scale</code>: This scales <code>dashSize</code> and <code>gapSize</code>. If the scale is smaller than <code>1</code>, <code>dashSize</code> and <code>gapSize</code> increase, whereas if the scale is larger than <code>1</code>, <code>dashSize</code> and <code>gapSize</code> decrease.</li>
				<li><code>dashSize</code>: This is the size of the dash.</li>
				<li><code>gapSize</code>: This is the size of the gap.</li>
			</ul>
			<p>This material works almost exactly like <code>THREE.LineBasicMaterial</code>. The only difference is that you have to call <code>computeLineDistances()</code> (which is used to determine the distance<a id="_idIndexMarker406"/> between the vertices that make up a line). If you don’t do this, the gaps<a id="_idIndexMarker407"/> won’t be shown correctly. An example of this material can be found in <code>line-dashed-material.html</code> and looks like this:</p>
			<div><div><img src="img/Figure_4.25_B18726.jpg" alt="Figure 4.25 – A Gosper mesh with the line dashed material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25 – A Gosper mesh with the line dashed material</p>
			<p>That’s it for this section on materials used for lines. You’ve seen that Three.js only provides a few materials specifically for line geometries, but with these materials, especially in combination with <code>vertexColors</code>, you should be able to style<a id="_idIndexMarker408"/> the line geometries<a id="_idIndexMarker409"/> any way you want.</p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Summary</h1>
			<p>Three.js gives you a lot of materials you can use to skin your geometries. The materials range from the very simple (<code>THREE.MeshBasicMaterial</code>) to the complex (<code>THREE.ShaderMaterial</code>), where you can provide your own <code>vertexShader</code> and <code>fragmentShader</code> programs. Materials share a lot of basic properties. If you know how to use a single material, you’ll probably also know how to use the other materials. Note that not all materials respond to the lights in your scene. If you want a material that takes lighting into effect, you can usually just use <code>THREE.MeshStandardMaterial</code>. If you need more control, you can also look at <code>THREE.MeshPhysicalMaterial</code>, <code>THREE.MeshPhongMaterial</code>, or <code>THREE.MeshLamberMaterial</code>. Determining the effect of certain material properties from just code is very hard. Often, a good idea is to use the control GUI approach to experiment with these properties, as we showed in this chapter.</p>
			<p>Also, remember that most of the properties of a material can be modified at runtime. Some, though (for example, <code>side</code>), can’t be modified at runtime. If you change such a value, you need to set the <code>needsUpdate</code> property to <code>true</code>. For a complete overview of what can and cannot be changed at runtime, see the following page: <a href="https://threejs.org/docs/#manual/en/introduction/How-to-update-things">https://threejs.org/docs/#manual/en/introduction/How-to-update-things</a>.</p>
			<p>In this and the previous chapters, we talked about geometries. We used these in our examples and explored a couple of them. In the next chapter, you’ll learn everything about geometries and how you can work with them.</p>
		</div>
	</body></html>