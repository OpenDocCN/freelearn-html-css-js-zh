<html><head></head><body>
		<div id="_idContainer097">
			<h1 id="_idParaDest-57" class="chapter-number"><a id="_idTextAnchor056"/>4</h1>
			<h1 id="_idParaDest-58"><a id="_idTextAnchor057"/>Working with Three.js Materials</h1>
			<p>In <a href="B18726_03.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Working with Light Sources in Three.js</em>, we talked a bit about materials. You learned that a material, together with a <strong class="source-inline">THREE.Geometry</strong> instance, forms a <strong class="source-inline">THREE.Mesh</strong> object. A material is like the skin of an object that defines what the outside of a geometry looks like. For example, a skin defines whether a geometry is metallic-looking, transparent, or shown as a wireframe. The resulting <strong class="source-inline">THREE.Mesh</strong> object can then be added to the scene to be rendered <span class="No-Break">by Three.js.</span></p>
			<p>So far, we haven’t looked at materials in much detail. In this chapter, we’ll dive into all the materials Three.js has to offer, and you’ll learn how you can use these materials to create good-looking 3D objects. The materials we’ll explore in this chapter are shown in the <span class="No-Break">following list:</span></p>
			<ul>
				<li><strong class="source-inline">MeshBasicMaterial</strong>: This is a basic material that you can use to give your geometries a simple color or show the wireframe of your geometries. This material isn’t influenced <span class="No-Break">by lights.</span></li>
				<li><strong class="source-inline">MeshDepthMaterial</strong>: This is a material that uses the distance from the camera to determine how to color <span class="No-Break">your mesh.</span></li>
				<li><strong class="source-inline">MeshNormalMaterial</strong>: This is a simple material that bases the color of a face on its <span class="No-Break">normal vector.</span></li>
				<li><strong class="source-inline">MeshLambertMaterial</strong>: This is a material that takes lighting into account and is used to create dull, <span class="No-Break">non-shiny-looking objects.</span></li>
				<li><strong class="source-inline">MeshPhongMaterial</strong>: This is a material that also takes lighting into account and can be used to create <span class="No-Break">shiny objects.</span></li>
				<li><strong class="source-inline">MeshStandardMaterial</strong>: This is a material that uses physical-based rendering to render the object. With physical-based rendering, a physically correct model is used to determine how light interacts with a surface. This allows you to create more accurate and <span class="No-Break">realistic-looking objects.</span></li>
				<li><strong class="source-inline">MeshPhysicalMaterial</strong>: This is an extension of <strong class="source-inline">MeshStandardMaterial</strong> that allows more control over <span class="No-Break">the reflection.</span></li>
				<li><strong class="source-inline">MeshToonMaterial</strong>: This is an extension of <strong class="source-inline">MeshPhongMaterial</strong> that tries to make objects <span class="No-Break">look hand-drawn.</span></li>
				<li><strong class="source-inline">ShadowMaterial</strong>: This is a specific material that can receive shadows, but otherwise, it is <span class="No-Break">rendered transparent.</span></li>
				<li><strong class="source-inline">ShaderMaterial</strong>: This material allows you to specify shader programs to directly control how vertices are positioned and pixels <span class="No-Break">are colored.</span></li>
				<li><strong class="source-inline">LineBasicMaterial</strong>: This is a material that can be used on the <strong class="source-inline">THREE.Line</strong> geometry to create <span class="No-Break">colored lines.</span></li>
				<li><strong class="source-inline">LineDashMaterial</strong>: This is the same as <strong class="source-inline">LineBasicMaterial</strong>, but this material also allows you to create a <span class="No-Break">dashed effect.</span></li>
			</ul>
			<p>In the sources of Three.js, you can also find <strong class="source-inline">THREE.SpriteMaterial</strong> and <strong class="source-inline">THREE.PointsMaterial</strong>. These are materials you can use when styling individual points. We won’t discuss those in this chapter, but we’ll explore them in <a href="B18726_07.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Points </em><span class="No-Break"><em class="italic">and Sprites</em></span><span class="No-Break">.</span></p>
			<p>Materials have several common properties, so before we look at the first material, <strong class="source-inline">THREE.MeshBasicMaterial</strong>, we’ll look at the properties shared by all <span class="No-Break">the materials.</span></p>
			<h1 id="_idParaDest-59"><a id="_idTextAnchor058"/>Understanding common material properties</h1>
			<p>You can quickly see for yourself which properties<a id="_idIndexMarker283"/> are shared between all the materials. Three.js provides a material base class, <strong class="source-inline">THREE.Material</strong>, that lists all these common properties. We’ve divided these common material properties into the following <span class="No-Break">three categories:</span></p>
			<ul>
				<li><strong class="bold">Basic properties</strong>: These are the properties you’ll use most<a id="_idIndexMarker284"/> often. With these properties, you can, for instance, control the opacity of the object, whether it is visible, and how it is referenced (by ID or <span class="No-Break">custom name).</span></li>
				<li><strong class="bold">Blending properties</strong>: Every object has a set of blending<a id="_idIndexMarker285"/> properties. These properties define how the color of each point of the material is combined with the color <span class="No-Break">behind it.</span></li>
				<li><strong class="bold">Advanced properties</strong>: Several advanced properties control how <a id="_idIndexMarker286"/>the low-level WebGL context renders objects. In most cases, you won’t need to deal with <span class="No-Break">these properties.</span></li>
			</ul>
			<p>Note that, in this chapter, we will skip most of the properties related to textures and maps. Most materials allow you to use images as textures (for instance, a wood-like or stone-like texture). In <a href="B18726_10.xhtml#_idTextAnchor171"><span class="No-Break"><em class="italic">Chapter 10</em></span></a>, <em class="italic">Loading and Working with Textures</em>, we will dive into the various available texture and mapping options. Some materials also have specific properties related to animation (for example, <strong class="source-inline">skinning</strong>, <strong class="source-inline">morpNormals</strong>, and <strong class="source-inline">morphTargets</strong>); we’ll also skip those properties. These will be addressed in <a href="B18726_09.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Animations and Moving the Camera</em>. The <strong class="source-inline">clipIntersection</strong>, <strong class="source-inline">clippingPlanes</strong>, and <strong class="source-inline">clipShadows</strong> properties will be addressed in <a href="B18726_06.xhtml#_idTextAnchor101"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Exploring </em><span class="No-Break"><em class="italic">Advanced Geometries</em></span><span class="No-Break">.</span></p>
			<p>We will start with the first set shown in the list: the <span class="No-Break">basic properties.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Basic properties</h2>
			<p>The basic properties<a id="_idIndexMarker287"/> of the <strong class="source-inline">THREE.Material</strong> object are listed here (you will see these properties in action in the <span class="No-Break"><em class="italic">THREE.MeshBasicMaterial</em></span><span class="No-Break"> section):</span></p>
			<ul>
				<li><strong class="source-inline">id</strong>: This is used to identify a material and is assigned when you create a material. This starts at <strong class="source-inline">0</strong> for the first material and is increased by <strong class="source-inline">1</strong> for each additional material that <span class="No-Break">is created.</span></li>
				<li><strong class="source-inline">uuid</strong>: This is a uniquely generated ID and is <span class="No-Break">used internally.</span></li>
				<li><strong class="source-inline">name</strong>: You can assign a name to a material with this property. This can be used for <span class="No-Break">debugging purposes.</span></li>
				<li><strong class="source-inline">opacity</strong>: This defines how transparent an object is. Use this together with the <strong class="source-inline">transparent</strong> property. The range of this property is from <strong class="source-inline">0</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">transparent</strong>: If this is set to <strong class="source-inline">true</strong>, Three.js will render this object with the set opacity. If this is set to <strong class="source-inline">false</strong>, the object won’t be transparent, just more lightly colored. This property should also be set to <strong class="source-inline">true</strong> if you use a texture that uses an alpha (<span class="No-Break">transparency) channel.</span></li>
				<li><strong class="source-inline">visible</strong>: This defines whether this material is visible. If you set this to <strong class="source-inline">false</strong>, you won’t see the object in <span class="No-Break">the scene.</span></li>
				<li><strong class="source-inline">side</strong>: With this property, you can define to which side of the geometry a material is applied. The default is <strong class="source-inline">THREE.Frontside</strong>, which applies the material to the front (outside) of an object. You can also set this to <strong class="source-inline">THREE.BackSide</strong>, which applies it to the back (inside), or <strong class="source-inline">THREE.DoubleSide</strong>, which applies it to <span class="No-Break">both sides.</span></li>
				<li><strong class="source-inline">needsUpdate</strong>: When Three.js creates<a id="_idIndexMarker288"/> a material, it converts it into a set of WebGL instructions. When you want the changes you made in the material to also result in an update to the WebGL instructions, you can set this property <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">colorWrite</strong>: If set to <strong class="source-inline">false</strong>, the color of this material won’t be shown (in effect, you’ll create invisible objects, which occlude objects <span class="No-Break">behind them).</span></li>
				<li><strong class="source-inline">flatShading</strong>: This determines whether this material is rendered using flat shading. With flat shading, the individual triangles that make up an object are rendered separately and aren’t combined into a <span class="No-Break">smooth surface.</span></li>
				<li><strong class="source-inline">lights</strong>: This is a Boolean value that determines whether this material is affected by lights. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">true</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">premultipliedAlpha</strong>: This changes the way the transparency of an object is rendered. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">dithering</strong>: This applies a dithering effect to the rendering material. This can be used to avoid banding. The default value <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">shadowSide</strong>: This is just like the <strong class="source-inline">side</strong> property but determines which side of the faces casts the shadows. If not set, this follows the value set on the <span class="No-Break"><strong class="source-inline">side</strong></span><span class="No-Break"> property.</span></li>
				<li><strong class="source-inline">vertexColors</strong>: With this property, you can define individual colors to be applied to each vertex. If set to <strong class="source-inline">true</strong>, any color set on a vertex is used in rendering, while if set to <strong class="source-inline">false</strong>, the colors of the vertices <span class="No-Break">aren’t used.</span></li>
				<li><strong class="source-inline">fog</strong>: This property determines<a id="_idIndexMarker289"/> whether this material is affected by global fog settings. This is not shown in action, but if this is set to <strong class="source-inline">false</strong>, the global fog we saw in <a href="B18726_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Basic Components that Make up a Three.js Scene</em>, <span class="No-Break">is disabled.</span></li>
			</ul>
			<p>For each material, you can also set several <span class="No-Break">blending properties.</span></p>
			<h2 id="_idParaDest-61"><a id="_idTextAnchor060"/>Blending properties</h2>
			<p>Materials have a couple<a id="_idIndexMarker290"/> of generic blending-related properties. Blending determines how the colors we render interact with the colors that are behind them. We’ll touch upon this subject a little bit when we talk about combining materials. The blending properties are <span class="No-Break">listed here:</span></p>
			<ul>
				<li><strong class="source-inline">blending</strong>: This determines how the material on this object blends with the background. The normal mode is <strong class="source-inline">THREE.NormalBlending</strong>, which only shows the <span class="No-Break">top layer.</span></li>
				<li><strong class="source-inline">blendSrc</strong>: Besides using the standard blending modes, you can also create custom blend modes by setting <strong class="source-inline">blendsrc</strong>, <strong class="source-inline">blenddst</strong>, and <strong class="source-inline">blendequation</strong>. This property defines how an object (the source) is blended into the background (the destination). The default <strong class="source-inline">THREE.SrcAlphaFactor</strong> setting uses the alpha (transparency) channel <span class="No-Break">for blending.</span></li>
				<li><strong class="source-inline">blendSrcAlpha</strong>: This is the transparency of <strong class="source-inline">blendSrc</strong>. The default <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">blendDst</strong>: This property defines how the background (the destination) is used in blending and defaults to <strong class="source-inline">THREE.OneMinusSrcAlphaFactor</strong>, which means this property also uses the alpha channel of the source for blending but uses <strong class="source-inline">1</strong> ( the alpha channel of the source) as <span class="No-Break">the value.</span></li>
				<li><strong class="source-inline">blendDstAlpha</strong>: This is the transparency of <strong class="source-inline">blendDst</strong>. The default <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">null</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">blendEquation</strong>: This defines how the <strong class="source-inline">blendsrc</strong> and <strong class="source-inline">blenddst</strong> values are used. The default is to add them (<strong class="source-inline">AddEquation</strong>). With these three properties, you can create<a id="_idIndexMarker291"/> your own custom <span class="No-Break">blend modes.</span></li>
			</ul>
			<p>The last set of properties is mostly used internally and controls the specifics of how WebGL is used to render <span class="No-Break">the scene.</span></p>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Advanced properties</h2>
			<p>We won’t go into the details<a id="_idIndexMarker292"/> of these properties. These are related to how WebGL works internally. If you do want to know more about these properties, the OpenGL<a id="_idIndexMarker293"/> specification is a good starting point. You can find this specification at <a href="https://www.khronos.org/opengl/wiki">https://www.khronos.org/opengl/wiki</a>. The following list provides a brief description of these <span class="No-Break">advanced properties:</span></p>
			<ul>
				<li><strong class="source-inline">depthTest</strong>: This is an advanced WebGL property. With this property, you can enable or disable the <strong class="source-inline">GL_DEPTH_TEST</strong> parameter. This parameter controls whether the depth of a pixel is used to determine a new pixel’s value. Normally, you wouldn’t need to change this. More information can be found in the OpenGL specification we <span class="No-Break">mentioned earlier.</span></li>
				<li><strong class="source-inline">depthWrite</strong>: This is another internal property. This property can be used to determine whether this material affects the WebGL depth buffer. If you use an object for a 2D overlay (for example, a hub), you should set this property to <strong class="source-inline">false</strong>. Usually, though, you shouldn’t need to change <span class="No-Break">this property.</span></li>
				<li><strong class="source-inline">depthFunc</strong>: This function compares a pixel’s depth. This corresponds to <strong class="source-inline">glDepthFunc</strong> from the <span class="No-Break">WebGL specifications.</span></li>
				<li><strong class="source-inline">polygonOffset</strong>, <strong class="source-inline">polygonOffsetFactor</strong>, and <strong class="source-inline">polygonOffsetUnits</strong>: With these properties, you can control the <strong class="source-inline">POLYGON_OFFSET_FILL</strong> WebGL feature. These are normally not needed. For an explanation of what they do in detail, you can look at the <span class="No-Break">OpenGL specification.</span></li>
				<li><strong class="source-inline">Alphatest</strong>: This value can be set to a specific value (<strong class="source-inline">0</strong> to <strong class="source-inline">1</strong>). Whenever a pixel has an alpha value smaller than this value, it won’t be drawn. You can use this property to remove some transparency-related artifacts. You can set the precision for this material to one<a id="_idIndexMarker294"/> of the following WebGL values: <strong class="source-inline">highp</strong>, <strong class="source-inline">mediump</strong>, <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">lowp</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Now, let’s look at all the available materials so that you can see the effect these properties have on the <span class="No-Break">rendered output.</span></p>
			<h1 id="_idParaDest-63"><a id="_idTextAnchor062"/>Starting with simple materials</h1>
			<p>In this section, we’ll look<a id="_idIndexMarker295"/> at a few simple materials: <strong class="source-inline">MeshBasicMaterial</strong>, <strong class="source-inline">MeshDepthMaterial</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">MeshNormalMaterial</strong></span><span class="No-Break">.</span></p>
			<p>Before we look into the properties of these materials, here’s a quick note on how you can pass in properties to configure the materials. There are <span class="No-Break">two options:</span></p>
			<ul>
				<li>You can pass in the arguments in the constructor as a parameter object, <span class="No-Break">like this:</span><pre class="console">
const material = new THREE.MeshBasicMaterial({</pre><pre class="console">
  color: 0xff0000,</pre><pre class="console">
  name: 'material-1',</pre><pre class="console">
  opacity: 0.5,</pre><pre class="console">
  transparency: true,</pre><pre class="console">
  ...</pre><pre class="console">
})</pre></li>
				<li>Alternatively, you can create an instance and set the properties individually, <span class="No-Break">like this:</span><pre class="console">
const material = new THREE.MeshBasicMaterial();</pre><pre class="console">
material.color = new THREE.Color(0xff0000);</pre><pre class="console">
material.name = 'material-1'; material.opacity = 0.5;</pre><pre class="console">
material.transparency = true;</pre></li>
			</ul>
			<p>Usually, the best way is to use the constructor if we know all the properties’ values while creating the material. The arguments used in both of these styles use the same format. The only exception to this rule is the <strong class="source-inline">color</strong> property. In the first style, we can just pass in the hex<a id="_idIndexMarker296"/> value, and Three.js will create a <strong class="source-inline">THREE.Color</strong> object itself. In the second style, we have to explicitly create a <strong class="source-inline">THREE.Color</strong> object. In this book, we’ll use both of <span class="No-Break">these styles.</span></p>
			<p>Now, let’s look at the first of the simple <span class="No-Break">materials: </span><span class="No-Break"><strong class="source-inline">THREE.MeshBasicMaterial</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>THREE.MeshBasicMaterial</h2>
			<p><strong class="source-inline">MeshBasicMaterial</strong> is a very simple material<a id="_idIndexMarker297"/> that doesn’t take into account<a id="_idIndexMarker298"/> the lights that are available in the scene. Meshes with this material will be rendered as simple, flat polygons, and you also have the option to show the geometry’s wireframe. Besides the common properties we saw earlier regarding this material, we can set the following properties (once again, we will ignore the properties that are used for textures since we’ll discuss those in the chapter <span class="No-Break">on textures):</span></p>
			<ul>
				<li><strong class="source-inline">color</strong>: This property allows<a id="_idIndexMarker299"/> you to set the color of <span class="No-Break">the material.</span></li>
				<li><strong class="source-inline">wireframe</strong>: This allows you to render the material as a wireframe. This is great for <span class="No-Break">debugging purposes.</span></li>
				<li><strong class="source-inline">vertexColors</strong>: When set to <strong class="source-inline">true</strong>, this will take the color of the individual vertices into account when rendering<a id="_idIndexMarker300"/> <span class="No-Break">the model.</span></li>
			</ul>
			<p>In the previous chapters, we saw how to create materials and assign them to objects. For <strong class="source-inline">THREE.MeshBasicMaterial</strong>, we can do so <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const meshMaterial = new THREE.MeshBasicMaterial({color:
  0x7777ff});</pre>
			<p>This creates a new <strong class="source-inline">THREE.MeshBasicMaterial</strong> and initializes the <strong class="source-inline">color</strong> property to <strong class="source-inline">0x7777ff</strong> (which <span class="No-Break">is purple).</span></p>
			<p>We’ve added an example<a id="_idIndexMarker301"/> that you can use to play<a id="_idIndexMarker302"/> around with the <strong class="source-inline">THREE.MeshBasicMaterial</strong> properties and the basic properties we discussed in the previous sections. If you open up the <strong class="source-inline">basic-mesh-material.html</strong> example in the <strong class="source-inline">chapter-04</strong> folder, you’ll see a simple mesh on screen and a set of properties on the right of the scene that you can use to change models, add a simple texture, and change any of the material properties to see the <span class="No-Break">effect immediately:</span></p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_4.01_B18726.jpg" alt="Figure 4.1 – Start screen for the basic material example"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – Start screen for the basic material example</p>
			<p>What you can see in this screenshot is a basic simple<a id="_idIndexMarker303"/> gray sphere. We already mentioned that <strong class="source-inline">THREE.MeshBasicMaterial</strong> doesn’t respond to lights, so you don’t see any depth; all the faces<a id="_idIndexMarker304"/> are the same color. Even with this material, though, you can still create nice-looking models. If you, for instance, enable the reflection by selecting the <strong class="source-inline">reflection</strong> property in the <strong class="source-inline">envMaps</strong> dropdown, set the background of the scene, and change the model to the <strong class="source-inline">torus</strong> model, you can already create <span class="No-Break">great-looking models:</span></p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_4.02_B18726.jpg" alt="Figure 4.2 – Torus knot with an environment map"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Torus knot with an environment map</p>
			<p>The <strong class="source-inline">wireframe</strong> property is a great<a id="_idIndexMarker305"/> one for looking at the underlying<a id="_idIndexMarker306"/> geometry of <strong class="source-inline">THREE.Mesh</strong> and works great <span class="No-Break">for debugging:</span></p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_4.03_B18726.jpg" alt="Figure 4.3 – Model showing its wireframe"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Model showing its wireframe</p>
			<p>The final property that we want<a id="_idIndexMarker307"/> to look a bit closer at is <strong class="source-inline">vertexColors</strong>. If you enable<a id="_idIndexMarker308"/> this property, the colors of the individual vertices are used in rendering the model. If you select <strong class="source-inline">vertexColor</strong> from the model dropdown in the menu, you’ll see a model that has colored vertices. The easiest way to see this is by also enabling <span class="No-Break">the wireframe:</span></p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_4.04_B18726.jpg" alt="Figure 4.4 – Model showing wireframe and vertex colors"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Model showing wireframe and vertex colors</p>
			<p>Vertex colors can be used to color different parts of the mesh in different colors without having to use textures or <span class="No-Break">multiple materials.</span></p>
			<p>In this example, you can also <a id="_idIndexMarker309"/>play around with the standard material properties<a id="_idIndexMarker310"/> we discussed at the beginning of this chapter by looking at the <strong class="bold">THREE.Material</strong> section of the menu in <span class="No-Break"><em class="italic">Figure 4</em></span><span class="No-Break"><em class="italic">.4</em></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>THREE.MeshDepthMaterial</h2>
			<p>The next material<a id="_idIndexMarker311"/> on the list is <strong class="source-inline">THREE.MeshDepthMaterial</strong>. With this material, the way<a id="_idIndexMarker312"/> an object looks isn’t defined by lights or by a specific material property – it is defined by the distance from the object to the camera. You can, for instance, combine this with other materials to easily create fading effects. The only additional property this material has is one we saw in <strong class="source-inline">THREE.MeshBasicMaterial</strong>: the <span class="No-Break"><strong class="source-inline">wireframe</strong></span><span class="No-Break"> property.</span></p>
			<p>To demonstrate this material, we created<a id="_idIndexMarker313"/> an example that you can<a id="_idIndexMarker314"/> view by opening the <span class="No-Break"><strong class="source-inline">mesh-depth-material</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_4.04_B18726.jpg" alt="Figure 4.5 – Mesh depth material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Mesh depth material</p>
			<p>In this example, you can add and remove cubes by clicking on the relevant buttons in the menu. What you’ll see is that the cubes that are close to the camera are rendered very bright, and those farther away from the camera are rendered less bright. In this example, you can see how this works by playing around with the properties of the <strong class="source-inline">Perspective Camera</strong> settings. By playing around with the <strong class="source-inline">far</strong> and <strong class="source-inline">near</strong> properties of the camera, you can change the brightness of all the cubes in <span class="No-Break">the scene.</span></p>
			<p>Normally, you wouldn’t use this material as the only material for a mesh; instead, you’d combine it with a different material. We’ll see how that works in the <span class="No-Break">next section.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Combining materials</h2>
			<p>If you look back at the properties of <strong class="source-inline">THREE.MeshDepthMaterial</strong>, you will see that there isn’t an option<a id="_idIndexMarker315"/> to set the color of the cubes. Everything was decided for you by the default properties of the material. Three.js, however, has the option to combine materials to create new effects (this is also where blending comes into play). The following code shows how we can <span class="No-Break">combine materials:</span></p>
			<pre class="source-code">
import * as SceneUtils from 'three/examples/jsm/
  utils/SceneUtils'
const material1 = new THREE.MeshDepthMaterial()
const material2 = new THREE.MeshBasicMaterial({ color:
  0xffff00 })
const geometry = new THREE.BoxGeometry(0.5, 0.5, 0.5)
const cube = SceneUtils.createMultiMaterialObject(geometry,
  [material2, material1])</pre>
			<p>First, we create our two materials. For <strong class="source-inline">THREE.MeshDepthMaterial</strong>, we don’t do anything special; for <strong class="source-inline">THREE.MeshBasicMaterial</strong>, we just set the color. The last line in this code fragment is also an important one. When we create a mesh with the <strong class="source-inline">SceneUtils.createMultiMaterialObject()</strong> function, the geometry gets copied and two of the same meshes are returned in <span class="No-Break">a group.</span></p>
			<p>We get the following green-colored cubes that use the brightness from <strong class="source-inline">THREE.MeshDepthMaterial</strong> and the color from <strong class="source-inline">THREE.MeshBasicMaterial</strong>. You can see how this works by opening the <strong class="source-inline">combining-materials.html</strong> example in the <strong class="source-inline">chapter-4</strong> folder in <span class="No-Break">your browser:</span></p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_4.06_B18726.jpg" alt="Figure 4.6 – Combining materials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Combining materials</p>
			<p>When you open this example for the first time, you’ll just see the solid objects, without any effect from <strong class="source-inline">THREE.MeshDepthMaterial</strong>. To combine the colors, we also need to specify how these colors blend. In the menu on the right in <span class="No-Break"><em class="italic">Figure 4</em></span><em class="italic">.6</em>, you can specify this using the <strong class="source-inline">blending</strong> property. For this example, we’ve used the <strong class="source-inline">THREE.AdditiveBlending</strong> mode, which means<a id="_idIndexMarker316"/> the colors are added together, and the resulting color is shown. This example is a great way to play around with the different blending options, and see how they affect the final color of <span class="No-Break">the material.</span></p>
			<p>The next material is also one where we won’t have any influence on the colors used <span class="No-Break">in rendering.</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>THREE.MeshNormalMaterial</h2>
			<p>The easiest way to understand<a id="_idIndexMarker317"/> how this material<a id="_idIndexMarker318"/> is rendered is by first looking at an example. Open up the <strong class="source-inline">mesh-normal-material.html</strong> example in the <strong class="source-inline">chapter-4</strong> folder and <span class="No-Break">enable </span><span class="No-Break"><strong class="source-inline">flatShading</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_4.07_B18726.jpg" alt="Figure 4.7 – Mesh normal material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Mesh normal material</p>
			<p>As you can see, each face of the mesh is rendered in a slightly different color. This happens because the color of each face is based on the normals pointing out from the face. And this face normal is based on the normal vector of the individual vertices that make up the face. A normal vector is perpendicular to the face of a vertex. The normal vector is used in many different parts of Three.js. It is used to determine light reflections, helps with mapping textures to 3D models, and provides information on how to light, shade, and color pixels on the surface. Luckily, though, Three.js handles the computation of these vectors and uses them internally, so you don’t have to calculate or deal with <span class="No-Break">them yourselves.</span></p>
			<p>Three.js comes with a helper<a id="_idIndexMarker319"/> to visualize this normal, and you can show<a id="_idIndexMarker320"/> this by enabling the <strong class="source-inline">vertexHelpers</strong> property in <span class="No-Break">the menu:</span></p>
			<div>
				<div id="_idContainer079" class="IMG---Figure">
					<img src="image/Figure_4.08_B18726.jpg" alt="Figure 4.8 – Mesh normal helpers"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.8 – Mesh normal helpers</p>
			<p>Adding this helper yourself can be done in a couple of lines <span class="No-Break">of code:</span></p>
			<pre class="source-code">
Import { VertexNormalsHelper } from 'three/examples/jsm/
  helpers/VertexNormalsHelper'
...
const helper = new VertexNormalsHelper(mesh, 0.1, 0xff0000)
helper.name = 'VertexNormalHelper'
scene.add(helper)</pre>
			<p><strong class="source-inline">VertexNormalsHelper</strong> takes three<a id="_idIndexMarker321"/> parameters. The first one is <strong class="source-inline">THREE.Mesh</strong>, for which you want<a id="_idIndexMarker322"/> to see the helpers, the second one is the length of the arrow, and the last one is <span class="No-Break">the color.</span></p>
			<p>Let’s take this example as an opportunity to look at the <strong class="source-inline">shading</strong> property. With the <strong class="source-inline">shading</strong> property, we can tell Three.js how to render our objects. If you use <strong class="source-inline">THREE.FlatShading</strong>, each face will be rendered as-is (as you can see in the previous following screenshot), or you can use <strong class="source-inline">THREE.SmoothShading</strong>, which smooths out the faces of our objects. For instance, if we render the same sphere using <strong class="source-inline">THREE.SmoothShading</strong>, the result will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer080" class="IMG---Figure">
					<img src="image/Figure_4.09_B18726.jpg" alt="Figure 4.9 – Mesh normal smooth shading"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.9 – Mesh normal smooth shading</p>
			<p>We’re done with the simple materials, but let’s look at one additional subject before moving on. In the next section, we’ll look at how you can use different materials for specific faces of <span class="No-Break">a geometry.</span></p>
			<h2 id="_idParaDest-68"><a id="_idTextAnchor067"/>Multiple materials for a single mesh</h2>
			<p>When creating <strong class="source-inline">THREE.Mesh</strong>, so far, we’ve used a single<a id="_idIndexMarker323"/> material. It is also <a id="_idIndexMarker324"/>possible to define a specific material for each of the faces of a geometry. For instance, if you have a cube that has 12 faces (remember, Three.js works with triangles), you can assign a different material (for example, with a different color) to each side of the cube. Doing this is straightforward, as shown in the following piece <span class="No-Break">of code:</span></p>
			<pre class="source-code">
const mat1 = new THREE.MeshBasicMaterial({ color: 0x777777
  })
const mat2 = new THREE.MeshBasicMaterial({ color: 0xff0000
  })
const mat3 = new THREE.MeshBasicMaterial({ color: 0x00ff00
  })
const mat4 = new THREE.MeshBasicMaterial({ color: 0x0000ff
  })
const mat5 = new THREE.MeshBasicMaterial({ color: 0x66aaff
  })
const mat6 = new THREE.MeshBasicMaterial({ color: 0xffaa66
  })
const matArray = [mat1, mat2, mat3, mat4, mat5, mat6]
const cubeGeom = new THREE.BoxGeometry(1, 1, 1, 10, 10, 10)
const cubeMesh = new THREE.Mesh(cubeGeom, material)</pre>
			<p>We create an array, named <strong class="source-inline">matArray</strong>, to hold all the materials, and use that array to create <strong class="source-inline">THREE.Mesh</strong>. What you might notice is that we only create six materials, even though we’ve got 12 faces. To understand<a id="_idIndexMarker325"/> how this works, we have<a id="_idIndexMarker326"/> to look at how Three.js assigns a material to a face. Three.js uses the <strong class="source-inline">groups</strong> property for this. To see this yourself, open up the source code for <strong class="source-inline">multi-material.js</strong> and add the <strong class="source-inline">debugger</strong> statement, <span class="No-Break">like this:</span></p>
			<pre class="source-code">
  const group = new THREE.Group()
  for (let x = 0; x &lt; 3; x++) {
    for (let y = 0; y &lt; 3; y++) {
      for (let z = 0; z &lt; 3; z++) {
        const cubeMesh = sampleCube([mat1, mat2, mat3,
          mat4, mat5, mat6], 0.95)
        cubeMesh.position.set(x - 1.5, y - 1.5, z - 1.5)
        group.add(cubeMesh)
        debugger
      }
    }
  }</pre>
			<p>This will cause the browser to stop executing, and allows you to inspect all the objects from the console of <span class="No-Break">the browser:</span></p>
			<div>
				<div id="_idContainer081" class="IMG---Figure">
					<img src="image/Figure_4.10_B18726.jpg" alt="Figure 4.10 – Using the debugger statement to stop execution"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.10 – Using the debugger statement to stop execution</p>
			<p>In the browser, if you open<a id="_idIndexMarker327"/> the <strong class="bold">Console</strong> tab, you can print<a id="_idIndexMarker328"/> our information about all different kinds of objects. So, if we want to see the details of <strong class="source-inline">cubeMesh</strong>, we can <span class="No-Break">use </span><span class="No-Break"><strong class="source-inline">console.log(cubeMesh)</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer082" class="IMG---Figure">
					<img src="image/Figure_4.11_B18726.jpg" alt="Figure 4.11 – Printing out information about an object"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.11 – Printing out information about an object</p>
			<p>If you look further into the <strong class="source-inline">geometry</strong> property of <strong class="source-inline">cubeMesh</strong>, you will see <strong class="source-inline">groups</strong>. This property is an array<a id="_idIndexMarker329"/> that consists of six elements, where each<a id="_idIndexMarker330"/> element contains the range of vertices that belong to that group, and an additional property called <strong class="source-inline">materialIndex</strong> that specifies which of the passed-in materials should be used for that group <span class="No-Break">of vertices:</span></p>
			<pre class="source-code">
[{ "start": 0,    "count": 600, "materialIndex": 0 },
 { "start": 600,  "count": 600, "materialIndex": 1 },
 { "start": 1200, "count": 600, "materialIndex": 2 },
 { "start": 1800, "count": 600, "materialIndex": 3 },
 { "start": 2400, "count": 600, "materialIndex": 4 },
 { "start": 3000, "count": 600, "materialIndex": 5 }]</pre>
			<p>So, if you create your own objects from scratch, and want to apply different materials to different vertices groups, you have to make sure you set the <strong class="source-inline">groups</strong> property correctly. For the objects created by Three.js, you don’t have to do this manually, since Three.js already <span class="No-Break">does this.</span></p>
			<p>With this approach, it’s very simple<a id="_idIndexMarker331"/> to create interesting<a id="_idIndexMarker332"/> models. For instance, we can easily create a simple 3D Rubik’s Cube, as you can see in the <span class="No-Break"><strong class="source-inline">multi-materials.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer083" class="IMG---Figure">
					<img src="image/Figure_4.12_B18726.jpg" alt="Figure 4.12 – Multi-material with six different materials"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.12 – Multi-material with six different materials</p>
			<p>We’ve also added controls for the materials that are applied to each side to experiment with. Creating this cube is not much different than what we saw in the <em class="italic">Multiple materials for a single </em><span class="No-Break"><em class="italic">mesh</em></span><span class="No-Break"> section:</span></p>
			<pre class="source-code">
const group = new THREE.Group()
const mat1 = new THREE.MeshBasicMaterial({ color: 0x777777
  })
const mat2 = new THREE.MeshBasicMaterial({ color: 0xff0000
  })
const mat3 = new THREE.MeshBasicMaterial({ color: 0x00ff00
  })
const mat4 = new THREE.MeshBasicMaterial({ color: 0x0000ff
  })
const mat5 = new THREE.MeshBasicMaterial({ color: 0x66aaff
  })
const mat6 = new THREE.MeshBasicMaterial({ color: 0xffaa66
  })
for (let x = 0; x &lt; 3; x++) {
  for (let y = 0; y &lt; 3; y++) {
    for (let z = 0; z &lt; 3; z++) {
      const cubeMesh = sampleCube([mat1, mat2, mat3, mat4,
        mat5, mat6], 0.95)
      cubeMesh.position.set(x - 1.5, y - 1.5, z - 1.5)
      group.add(cubeMesh)
    }
  }
}</pre>
			<p>In this piece of code, first, we create <strong class="source-inline">THREE.Group</strong>, which will hold all the individual cubes (group); next, we create<a id="_idIndexMarker333"/> the materials for each side<a id="_idIndexMarker334"/> of the cube. Then, we create three loops to make sure we create the right number of cubes. In this loop, we create each of the individual cubes, assign the materials, position them, and add them to the group. What you should remember is that the position of the cubes is relative to the position of this group. If we move or rotate the group, all the cubes will move and rotate with it. For more<a id="_idIndexMarker335"/> information on how<a id="_idIndexMarker336"/> to work with groups, look at <a href="B18726_08.xhtml#_idTextAnchor132"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Creating and Loading Advanced Meshes </em><span class="No-Break"><em class="italic">and Geometries</em></span><span class="No-Break">.</span></p>
			<p>And that wraps up this section on basic materials and how to combine them. In the following section, we’ll look at more <span class="No-Break">advanced materials.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Advanced materials</h1>
			<p>In this section, we’ll look at the more<a id="_idIndexMarker337"/> advanced materials Three.js has to offer. We’ll look at the <span class="No-Break">following materials:</span></p>
			<ul>
				<li><strong class="source-inline">THREE.MeshLambertMaterial</strong>: A material for <span class="No-Break">rough-looking surfaces</span></li>
				<li><strong class="source-inline">THREE.MeshPhongMaterial</strong>: A material for <span class="No-Break">shiny-looking surfaces</span></li>
				<li><strong class="source-inline">THREE.MeshToonMaterial</strong>: Renders the mesh in a <span class="No-Break">cartoon-like fashion</span></li>
				<li><strong class="source-inline">THREE.ShadowMaterial</strong>: A material that only shows shadows cast on it; the material is otherwise <span class="No-Break">is transparent</span></li>
				<li><strong class="source-inline">THREE.MeshStandardMaterial</strong>: A versatile material that can be used to represent many different kinds <span class="No-Break">of surfaces</span></li>
				<li><strong class="source-inline">THREE.MeshPhysicalMaterial</strong>: Similar to <strong class="source-inline">THREE.MeshStandardMaterial</strong> but provides additional properties for more <span class="No-Break">real-world-like surfaces</span></li>
				<li><strong class="source-inline">THREE.ShaderMaterial</strong>: A material where you can define for yourself how to render the object by writing your <span class="No-Break">own shaders</span></li>
			</ul>
			<p>We’ll start <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">THREE.MeshLambertMaterial</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-70"><a id="_idTextAnchor069"/>THREE.MeshLambertMaterial</h2>
			<p>This material<a id="_idIndexMarker338"/> can be used to create<a id="_idIndexMarker339"/> dull-looking, non-shiny surfaces. This is a very easy-to-use material that responds to the lighting sources in the scene. This material can be configured with the basic properties we’ve already seen, so we won’t go into the details of those properties; instead, we will focus on the ones specific to this material. That just leaves us with the<a id="_idIndexMarker340"/> <span class="No-Break">following properties:</span></p>
			<ul>
				<li><strong class="source-inline">color</strong>: This is the color of <span class="No-Break">the material.</span></li>
				<li><strong class="source-inline">emissive</strong>: This is the color the material emits. It doesn’t act as a light source, but this is a solid color that is unaffected by other lighting. This defaults to black. You can use this to create objects that look like <span class="No-Break">they glow.</span></li>
				<li><strong class="source-inline">emissiveIntensity</strong>: The intensity with which the object seems <span class="No-Break">to glow.</span></li>
			</ul>
			<p>Creating this object follows<a id="_idIndexMarker341"/> the same approach we’ve seen<a id="_idIndexMarker342"/> for the <span class="No-Break">other materials:</span></p>
			<pre class="source-code">
const material = new THREE.MeshLambertMaterial({color:
  0x7777ff});</pre>
			<p>For an example of this material, look at the <span class="No-Break"><strong class="source-inline">mesh-lambert-material.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer084" class="IMG---Figure">
					<img src="image/Figure_4.13_B18726.jpg" alt="Figure 4.13 – Mesh lambert material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.13 – Mesh lambert material</p>
			<p>This screenshot shows<a id="_idIndexMarker343"/> a torus knot, in white, with a very light red emissive<a id="_idIndexMarker344"/> glow. One of the interesting features of <strong class="source-inline">THREE.LambertMaterial</strong> is that it also supports the wireframe properties, so you can render a wireframe that responds to the lights in <span class="No-Break">the scene:</span></p>
			<div>
				<div id="_idContainer085" class="IMG---Figure">
					<img src="image/Figure_4.14_B18726.jpg" alt="Figure 4.14 – Mesh Lambert material with a wireframe"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.14 – Mesh Lambert material with a wireframe</p>
			<p>The next material works in pretty much the same way but can be used to create <span class="No-Break">shiny objects.</span></p>
			<h2 id="_idParaDest-71"><a id="_idTextAnchor070"/>THREE.MeshPhongMaterial</h2>
			<p>With <strong class="source-inline">THREE.MeshPhongMaterial</strong>, we can create<a id="_idIndexMarker345"/> a shiny material. The properties you can use for that are pretty<a id="_idIndexMarker346"/> much the same as for a non-shiny <strong class="source-inline">THREE.MeshLambertMaterial</strong> object. In older versions, this was the only material that you could use to make shiny, plastic, or metal-like objects. With newer versions of Three.js, if you want more control, you can also use <strong class="source-inline">THREE.MeshStandardMaterial</strong> and <strong class="source-inline">THREE.MeshPhysicalMaterial</strong>. We’ll discuss both of these materials after we look <span class="No-Break">at </span><span class="No-Break"><strong class="source-inline">THREE.MeshPhongMaterial</strong></span><span class="No-Break">.</span></p>
			<p>We’ll once again skip the basic properties and focus on the properties specific to this material. The properties<a id="_idIndexMarker347"/> of this material are <span class="No-Break">listed here:</span></p>
			<ul>
				<li><strong class="source-inline">emissive</strong>: This is the color this material emits. It doesn’t act as a light source, but this is a solid color that is unaffected by other lighting. This defaults <span class="No-Break">to black.</span></li>
				<li><strong class="source-inline">emissiveIntensity</strong>: The intensity with which the object seems <span class="No-Break">to glow.</span></li>
				<li><strong class="source-inline">specular</strong>: This property defines how shiny the material is and with what color it shines. If this is set to the same color as the <strong class="source-inline">color</strong> property, you get a more metallic-looking material. If this is set to gray, it results in a more <span class="No-Break">plastic-looking material.</span></li>
				<li><strong class="source-inline">shininess</strong>: This property defines how shiny the specular highlight is. The default value for <strong class="source-inline">shininess</strong> is <strong class="source-inline">30</strong>. The higher this value is, the shinier the <span class="No-Break">object is.</span></li>
			</ul>
			<p>Initializing a <strong class="source-inline">THREE.MeshPhongMaterial</strong> material is done<a id="_idIndexMarker348"/> in the same way as we’ve already seen for all the other materials <a id="_idIndexMarker349"/>and is shown in the following line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
const meshMaterial = new THREE.MeshPhongMaterial({color:
  0x7777ff});</pre>
			<p>To give you the best comparison, we will keep using the same models for this material as we did for <strong class="source-inline">THREE.MeshLambertMaterial</strong> and the other materials in this chapter. You can use the control GUI to play around with this material. For instance, the following settings create a plastic-looking material. You can find this example <span class="No-Break">in </span><span class="No-Break"><strong class="source-inline">mesh-phong-material.html</strong></span><span class="No-Break">:</span></p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_4.15_B18726.jpg" alt="Figure 4.15 – Mesh Phong material with high shininess"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.15 – Mesh Phong material with high shininess</p>
			<p>As you can see from this screenshot, the object is more shiny and plastic compared to what we saw <span class="No-Break">with </span><span class="No-Break"><strong class="source-inline">THREE.MeshLambertMaterial</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-72"><a id="_idTextAnchor071"/>THREE.MeshToonMaterial</h2>
			<p>Not all the materials<a id="_idIndexMarker350"/> Three.js provides<a id="_idIndexMarker351"/> are practical. For instance, <strong class="source-inline">THREE.MeshToonMaterial</strong> allows you to render an object in a cartoon-like style (see the <span class="No-Break"><strong class="source-inline">mesh-toon-material.html</strong></span><span class="No-Break"> example):</span></p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/Figure_4.16_B18726.jpg" alt="Figure 4.16 – The fox model rendered with MeshToonMaterial"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.16 – The fox model rendered with MeshToonMaterial</p>
			<p>As you can see, it looks a little bit like what<a id="_idIndexMarker352"/> we saw with <strong class="source-inline">THREE.MeshBasicMaterial</strong>, but this material responds<a id="_idIndexMarker353"/> to the lights in the scene and supports shadows. It just bands colors together to create a <span class="No-Break">cartoon-like effect.</span></p>
			<p>If you want more realistic materials, <strong class="source-inline">THREE.MeshStandardMaterial</strong> is a <span class="No-Break">good choice.</span></p>
			<h2 id="_idParaDest-73"><a id="_idTextAnchor072"/>THREE.MeshStandardMaterial</h2>
			<p><strong class="source-inline">THREE.MeshStandardMaterial</strong> is a material<a id="_idIndexMarker354"/> that takes a physics<a id="_idIndexMarker355"/> approach to determine how to react to the lighting in the scene. It is a great material for shiny and metal-like materials, and provides<a id="_idIndexMarker356"/> several properties you can use to configure <span class="No-Break">this material:</span></p>
			<ul>
				<li><strong class="source-inline">metalness</strong>: This property determines how metal-like a material is. Non-metallic materials should use a value of <strong class="source-inline">0</strong>, whereas metallic materials should use a value close to 1. The default <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0.5</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">roughness</strong>: You can also set how rough the material is. This determines how the light that hits this material is diffused. The default is <strong class="source-inline">0.5</strong>. A value of <strong class="source-inline">0</strong> is a mirror-like reflection, whereas a value of <strong class="source-inline">1</strong> diffuses all <span class="No-Break">the light.</span></li>
			</ul>
			<p>Besides these properties, you can also<a id="_idIndexMarker357"/> use the <strong class="source-inline">color</strong> and <strong class="source-inline">emissive</strong> properties, as well as the<a id="_idIndexMarker358"/> properties from <strong class="source-inline">THREE.Material</strong>, to alter this material. As you can see in the following screenshot, we can use these properties to simulate a kind of brushed metal look by playing around with the <strong class="source-inline">metalness</strong> and <span class="No-Break"><strong class="source-inline">roughness</strong></span><span class="No-Break"> parameters:</span></p>
			<div>
				<div id="_idContainer088" class="IMG---Figure">
					<img src="image/Figure_4.17_B18726.jpg" alt="Figure 4.17 – Creating a brushed metal effect with MeshStandardMaterial"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.17 – Creating a brushed metal effect with MeshStandardMaterial</p>
			<p>Three.js provides a material that provides even more settings to render real-looking <span class="No-Break">objects: </span><span class="No-Break"><strong class="source-inline">THREE.MeshPhysicalMaterial</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-74"><a id="_idTextAnchor073"/>THREE.MeshPhysicalMaterial</h2>
			<p>A material very<a id="_idIndexMarker359"/> close to <strong class="source-inline">THREE.MeshStandardMaterial</strong> is <strong class="source-inline">THREE.MeshPhysicalMaterial</strong>. With this material, you have more control<a id="_idIndexMarker360"/> over the reflectivity of the material. This material provides, besides the properties we’ve already seen for <strong class="source-inline">THREE.MeshPhysicalMaterial</strong>, the following properties to help you control what the material <span class="No-Break">looks like:</span></p>
			<ul>
				<li><strong class="source-inline">clearCoat</strong>: A value indicating a coating layer on top of the material. The higher this value is, the more coating<a id="_idIndexMarker361"/> is applied, and the more effective the <strong class="source-inline">clearCoatRoughness</strong> parameter is. This value ranges from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> with a default <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
				<li><strong class="source-inline">clearCoatRoughness</strong>: The roughness used for the coating of the material. The rougher it is, the more light is diffused. This is used together with the <strong class="source-inline">clearCoat</strong> property. This value ranges from <strong class="source-inline">0</strong> to <strong class="source-inline">1</strong> with a default <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>As we’ve seen for other<a id="_idIndexMarker362"/> materials, it is quite hard to reason about the values you should use for your specific requirements. It’s often the best choice<a id="_idIndexMarker363"/> to add a simple UI (as we do in the examples) and play around with the values to get to a combination that best reflects your needs. You can see this example in action by looking at the <span class="No-Break"><strong class="source-inline">mesh-physical-material.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer089" class="IMG---Figure">
					<img src="image/Figure_4.18_B18726.jpg" alt="Figure 4.18 – Mesh physical material using a clear coat to control reflection"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.18 – Mesh physical material using a clear coat to control reflection</p>
			<p>Most of the advanced materials cast and receive shadows. The next material we’re going to have a quick look at is a bit different than most. This material doesn’t render the object itself, but only shows <span class="No-Break">the shadows.</span></p>
			<h2 id="_idParaDest-75"><a id="_idTextAnchor074"/>THREE.ShadowMaterial</h2>
			<p><strong class="source-inline">THREE.ShadowMaterial</strong> is a special material that doesn’t have<a id="_idIndexMarker364"/> any properties. You can’t set<a id="_idIndexMarker365"/> the color or the shininess, or anything else. The only thing this material does is render the shadow the mesh would receive. The following screenshot should <span class="No-Break">explain this:</span></p>
			<div>
				<div id="_idContainer090" class="IMG---Figure">
					<img src="image/Figure_4.19_B18726.jpg" alt="Figure 4.19 – Shadow material just rendering the shadows the mesh receives"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.19 – Shadow material just rendering the shadows the mesh receives</p>
			<p>Here, the only thing<a id="_idIndexMarker366"/> we can see are the shadows the object receives, nothing<a id="_idIndexMarker367"/> else. This material can, for instance, be combined with your own materials without you having to determine how to <span class="No-Break">receive shadows.</span></p>
			<p>The last of the advanced materials we’ll explore <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">THREE.ShaderMaterial</strong></span><span class="No-Break">.</span></p>
			<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/>Using your own shaders with THREE.ShaderMaterial</h2>
			<p><strong class="source-inline">THREE.ShaderMaterial</strong> is one of the most versatile<a id="_idIndexMarker368"/> and complex materials<a id="_idIndexMarker369"/> available in Three.js. With this material, you can pass in your own custom shaders that are directly run in the WebGL context. A shader converts Three.js JavaScript meshes into pixels on the screen. With these custom shaders, you can define exactly how your object should be rendered and how to override or alter the defaults from Three.js. In this section, we won’t go into too much detail on how to write custom shaders; instead, we will just show you a couple <span class="No-Break">of examples.</span></p>
			<p>As we’ve already seen, <strong class="source-inline">THREE.ShaderMaterial</strong> has several properties<a id="_idIndexMarker370"/> you can set. With <strong class="source-inline">THREE.ShaderMaterial</strong>, Three.js passes<a id="_idIndexMarker371"/> in all the information regarding these properties to your custom shaders, but you still have to process the information to create colors and vertex positions. The following are the properties of <strong class="source-inline">THREE.Material</strong> that are passed into the shader, and that you can interpret <span class="No-Break">for yourself:</span></p>
			<ul>
				<li><strong class="source-inline">wireframe</strong>: This renders <a id="_idIndexMarker372"/>the material as a wireframe. This is great for <span class="No-Break">debugging purposes.</span></li>
				<li><strong class="source-inline">shading</strong>: This defines how shading is applied. The possible values are <strong class="source-inline">THREE.SmoothShading</strong> and <strong class="source-inline">THREE.FlatShading</strong>. This property isn’t enabled in the example for this material. For an example, look at the <em class="italic">THREE. </em><span class="No-Break"><em class="italic">MeshNormalMaterial</em></span><span class="No-Break"> section.</span></li>
				<li><strong class="source-inline">vertexColors</strong>: You can define individual colors to be applied to each vertex with this property. Look at the <strong class="source-inline">LineBasicMaterial</strong> example in the <em class="italic">THREE.LineBasicMaterial</em> section, where we use this property to color the various parts of <span class="No-Break">a line.</span></li>
				<li><strong class="source-inline">fog</strong>: This determines whether this material is affected by global fog settings. This is not shown in action. If this is set to <strong class="source-inline">false</strong>, the global fog we saw in <a href="B18726_02.xhtml#_idTextAnchor028"><span class="No-Break"><em class="italic">Chapter 2</em></span></a> doesn’t affect how this object <span class="No-Break">is rendered.</span></li>
			</ul>
			<p>Besides these properties that are passed into the shader, <strong class="source-inline">THREE.ShaderMaterial</strong> also provides several specific properties you can use to pass in additional information into your custom shader. Once again, we won’t go into too much detail on how you can write your own shaders, since that would be a book on its own, so we’ll just cover <span class="No-Break">the basics:</span></p>
			<ul>
				<li><strong class="source-inline">fragmentShader</strong>: This shader defines the color of each pixel that is passed in. Here, you need to pass in the string value of your fragment <span class="No-Break">shader program.</span></li>
				<li><strong class="source-inline">vertextShader</strong>: This shader allows you to change the position of each vertex that is passed in. Here, you need to pass in the string value of your vertex <span class="No-Break">shader program.</span></li>
				<li><strong class="source-inline">uniforms</strong>: This allows you to send information to your shader. The same information is sent to each vertex <span class="No-Break">and fragment.</span></li>
				<li><strong class="source-inline">defines</strong>: Converts custom key value pairs as <strong class="source-inline">#define</strong> code fragments. With these fragments, you can set some additional global variables in the shader programs or define your own custom <span class="No-Break">global constants.</span></li>
				<li><strong class="source-inline">attributes</strong>: These can change between each vertex and fragment. They are usually used to pass positional and normal-related data. If you want to use this property, you need to provide information for all the vertices of <span class="No-Break">the geometry.</span></li>
				<li><strong class="source-inline">lights</strong>: This determines whether light data should be passed into the shaders. This defaults <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">false</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Before we look at an example, we’ll provide<a id="_idIndexMarker373"/> a quick explanation<a id="_idIndexMarker374"/> of the most important parts of <strong class="source-inline">THREE.ShaderMaterial</strong>. To work with this material, we have to pass in two <span class="No-Break">different shaders:</span></p>
			<ul>
				<li><strong class="source-inline">vertexShader</strong>: This is run on each vertex of the geometry. You can use this shader to transform the geometry by moving the position of the <span class="No-Break">vertices around.</span></li>
				<li><strong class="source-inline">fragmentShader</strong>: This is run on each fragment of the geometry. In <strong class="source-inline">fragmentShader</strong>, we return the color that should be shown for this <span class="No-Break">specific fragment.</span></li>
			</ul>
			<p>For all the materials we’ve discussed so far in this chapter, Three.js provides <strong class="source-inline">fragmentShader</strong> and <strong class="source-inline">vertexShader</strong>, so you don’t have to worry about them and pass them <span class="No-Break">in explicitly.</span></p>
			<p>In this section, we’ll look at a simple example that uses a very simple <strong class="source-inline">vertexShader</strong> program that changes the <strong class="source-inline">x</strong> and <strong class="source-inline">y</strong> coordinates of the vertices of a simple <strong class="source-inline">THREE.PlainGeometry</strong> and a <strong class="source-inline">fragmentShader</strong> program that changes the color based on <span class="No-Break">some input.</span></p>
			<p>Up next, you can see the complete<a id="_idIndexMarker375"/> code for our <strong class="source-inline">vertexShader</strong>. Note that writing shaders isn’t done in JavaScript. You write shaders in a C-like<a id="_idIndexMarker376"/> language<a id="_idIndexMarker377"/> called GLSL (WebGL supports OpenGL ES Shading Language 1.0 — for more information<a id="_idIndexMarker378"/> on GLSL, see <a href="https://www.khronos.org/webgl/">https://www.khronos.org/webgl/</a>). The code for our simple shader looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
uniform float time;
void main(){
  vec3 posChanged=position;
  posChanged.x=posChanged.x*(abs(sin(time*2.)));
  posChanged.y=posChanged.y*(abs(cos(time*1.)));
  posChanged.z=posChanged.z*(abs(sin(time*.5)));
  gl_Position=projectionMatrix*modelViewMatrix*vec4
    (posChanged,1.);
}</pre>
			<p>We won’t go into too much detail here and just focus on the most important parts of this code. To communicate with the shaders from JavaScript, we use something called uniforms. In this example, we use the <strong class="source-inline">uniform float time;</strong> statement to pass in an <span class="No-Break">external value.</span></p>
			<p>Based on this value, we change the <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <strong class="source-inline">z</strong> coordinates of the passed-in vertex (which is passed in as the <span class="No-Break">position variable):</span></p>
			<pre class="source-code">
  posChanged.x=posChanged.x*(abs(sin(time*2.)));
  posChanged.y=posChanged.y*(abs(cos(time*1.)));
  posChanged.z=posChanged.z*(abs(sin(time*.5)));</pre>
			<p>The <strong class="source-inline">posChanged</strong> vector now contains the new coordinate for this vertex based on the passed-in time variable. The last step we need to perform is to pass this new position back to the renderer, which is always done like this <span class="No-Break">for Three.js:</span></p>
			<pre class="source-code">
  gl_Position=projectionMatrix*modelViewMatrix*vec4
    (posChanged,1.);</pre>
			<p>The <strong class="source-inline">gl_Position</strong> variable is a special variable<a id="_idIndexMarker379"/> that is used to return<a id="_idIndexMarker380"/> the final position. This program is passed as a string value to the <strong class="source-inline">vertexShader</strong> property of <strong class="source-inline">THREE.ShaderMaterial</strong>. For <strong class="source-inline">fragmentShader</strong>, we do something similar. We’ve created a very simple fragment shader that just flips through colors based on the passed-in <span class="No-Break"><strong class="source-inline">time</strong></span><span class="No-Break"> uniform:</span></p>
			<pre class="source-code">
uniform float time;
void main(){
  float c1=mod(time,.5);
  float c2=mod(time,.7);
  float c3=mod(time,.9);
  gl_FragColor=vec4(c1,c2,c3,1.);
}</pre>
			<p>What we do in a <strong class="source-inline">fragmentShader</strong> is determine the color of a passed-in fragment (a pixel). The real shader programs take a lot into account, such as lights, the position of the vertex on the face, normals, and more. In this example, though, we just determine the <strong class="source-inline">rgb</strong> values of a color and return that in <strong class="source-inline">gl_FragColor</strong>, which is then shown on the final <span class="No-Break">rendered mesh.</span></p>
			<p>Now, we need to glue the geometry, the material, and the two shaders together. In Three.js, we can do that <span class="No-Break">like this:</span></p>
			<pre class="source-code">
const geometry = new THREE.PlaneGeometry(10, 10, 100, 100)
const material = new THREE.ShaderMaterial({
  uniforms: {
    time: { value: 1.0 }
  },
  vertexShader: vs_simple,
  fragmentShader: fs_simple
})
const mesh = new THREE.Mesh(geometry, material)</pre>
			<p>Here, we define the <strong class="source-inline">time</strong> uniform, which will contain a value<a id="_idIndexMarker381"/> available in the<a id="_idIndexMarker382"/> shaders, and define <strong class="source-inline">vertexShader</strong> and <strong class="source-inline">fragmentShader</strong> as strings that we want to use. The only thing we need to do is make sure we change the <strong class="source-inline">time</strong> uniform in the render loop, and <span class="No-Break">that’s it:</span></p>
			<pre class="source-code">
// in the renderloop
material.uniforms.time.value += 0.005</pre>
			<p>In the examples for this chapter, we’ve added a couple of simple shaders to experiment with. You will see the results if you open up the <strong class="source-inline">shader-material-vertex.html</strong> example in the <span class="No-Break"><strong class="source-inline">chapter-4</strong></span><span class="No-Break"> folder:</span></p>
			<div>
				<div id="_idContainer091" class="IMG---Figure">
					<img src="image/Figure_4.20_B18726.jpg" alt="Figure 4.20 – A shader material that shows a plane with the two example shader programs"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.20 – A shader material that shows a plane with the two example shader programs</p>
			<p>In the dropdown menu, you can also find<a id="_idIndexMarker383"/> a couple of other<a id="_idIndexMarker384"/> shaders. For instance, the <strong class="source-inline">fs_night_sky</strong> fragment shader<a id="_idIndexMarker385"/> shows a starry night (based on the shader from <a href="https://www.shadertoy.com/view/Nlffzj">https://www.shadertoy.com/view/Nlffzj</a>). When combined with <strong class="source-inline">vs_ripple</strong>, you get a very nice-looking effect, completely running on the GPU, as <span class="No-Break">shown here:</span></p>
			<div>
				<div id="_idContainer092" class="IMG---Figure">
					<img src="image/Figure_4.21_B18726.jpg" alt="Figure 4.21 – Rippling effect with a starry night fragment shader"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.21 – Rippling effect with a starry night fragment shader</p>
			<p>It is possible to combine existing materials<a id="_idIndexMarker386"/> and reuse their fragment <a id="_idIndexMarker387"/>and vertex shaders with your own shaders. That way, you can, for instance, extend <strong class="source-inline">THREE.MeshStandardMaterial</strong> with some custom effects. Doing this in plain Three.js, however, is rather difficult to do and very error prone. Luckily, there is an open source project that provides us with a custom material that makes it very easy to wrap existing materials and add our own custom shaders. In the next section, we’ll have a quick look at how <span class="No-Break">that works.</span></p>
			<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/>Customizing existing shaders with CustomShaderMaterial</h2>
			<p><strong class="source-inline">THREE.CustomShader</strong> doesn’t come with<a id="_idIndexMarker388"/> the default Three.js<a id="_idIndexMarker389"/> distribution, but since we’re using <strong class="source-inline">yarn</strong>, it is really easy to install (this is what you did when running the relevant commands from <a href="B18726_01.xhtml#_idTextAnchor014"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Creating Your First 3D Scene wth Three.js</em>). If you want more information on this module, you can check out <a href="https://github.com/FarazzShaikh/THREE-CustomShaderMaterial">https://github.com/FarazzShaikh/THREE-CustomShaderMaterial</a>, where you can find documentation and <span class="No-Break">additional examples.</span></p>
			<p>First, let’s have a quick look at the code before we show some examples. Using <strong class="source-inline">THREE.CustomShader</strong> is the same as using the <span class="No-Break">other materials:</span></p>
			<pre class="source-code">
const material = new CustomShaderMaterial({
  baseMaterial: THREE.MeshStandardMaterial,
  vertexShader: ...,
  fragmentShader: ...,
  uniforms: {
    time: { value: 0.2 },
    resolution: { value: new THREE.Vector2() }
  },
  flatShading: true,
  color: 0xffffff
})</pre>
			<p>As you can see, it is a bit of a combination of a normal material and a <strong class="source-inline">THREE.ShaderMaterial</strong>. The main thing to look at is the <strong class="source-inline">baseMaterial</strong> property. Here, you can add any of the standard Three.js materials. Any additional property you add, besides <strong class="source-inline">vertexShader</strong>, <strong class="source-inline">fragmentShader</strong>, and <strong class="source-inline">uniforms</strong>, gets applied to this <strong class="source-inline">baseMaterial</strong>. The <strong class="source-inline">vertexshader</strong>, <strong class="source-inline">fragmentShader</strong>, and <strong class="source-inline">uniforms</strong> properties work in the same way as we’ve seen <span class="No-Break">for </span><span class="No-Break"><strong class="source-inline">THREE.ShaderMaterial</strong></span><span class="No-Break">.</span></p>
			<p>Out of the box, we need to make a couple of small changes to our shaders themselves. Recall the <em class="italic">Using your own shaders with THREE.ShaderMaterial</em> section, where we used <strong class="source-inline">gl_Position</strong> and <strong class="source-inline">gl_FragColor</strong> to set the final output<a id="_idIndexMarker390"/> of the position of a vertex and the color<a id="_idIndexMarker391"/> of a fragment. With this material, we use <strong class="source-inline">csm_Position</strong> for the final position and <strong class="source-inline">csm_DiffuseColor</strong> for the color. There are a couple more output variables you can use, which are explained in more detail <span class="No-Break">here: </span><a href="https://github.com/FarazzShaikh/THREE-CustomShaderMaterial#output-variables"><span class="No-Break">https://github.com/FarazzShaikh/THREE-CustomShaderMaterial#output-variables</span></a><span class="No-Break">.</span></p>
			<p>If you open the <strong class="source-inline">custom-shader-material</strong> example, you will see how our simple shaders can be used together with the default materials <span class="No-Break">from Three.js:</span></p>
			<div>
				<div id="_idContainer093" class="IMG---Figure">
					<img src="image/Figure_4.22_B18726.jpg" alt="Figure 4.22 – Ripple effect with an environment map using MeshStandardMaterials as the base"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.22 – Ripple effect with an environment map using MeshStandardMaterials as the base</p>
			<p>This approach gives you a relatively easy way to create your custom shaders, without having to start completely from scratch. You can just reuse the lights and shadow effects from the default shaders<a id="_idIndexMarker392"/> and extend them with<a id="_idIndexMarker393"/> your <span class="No-Break">custom-needed functionality.</span></p>
			<p>So far, we’ve looked at materials that work with meshes. Three.js also provides materials that can be used together with line geometries. In the next section, we’ll explore <span class="No-Break">those materials.</span></p>
			<h1 id="_idParaDest-78"><a id="_idTextAnchor077"/>Materials you can use for a line geometry</h1>
			<p>The last couple<a id="_idIndexMarker394"/> of materials<a id="_idIndexMarker395"/> we’re going to look at can only be used on one specific mesh: <strong class="source-inline">THREE.Line</strong>. As the name implies, this is just a single line that only consists of lines and doesn’t contain any faces. Three.js provides two different materials you can use on a <strong class="source-inline">THREE.Line</strong> geometry, <span class="No-Break">as follows:</span></p>
			<ul>
				<li><strong class="source-inline">THREE.LineBasicMaterial</strong>: This basic material for a line allows you to set the <strong class="source-inline">color</strong> and <span class="No-Break"><strong class="source-inline">vertexColors</strong></span><span class="No-Break"> properties.</span></li>
				<li><strong class="source-inline">THREE.LineDashedMaterial</strong>: This has the same properties as <strong class="source-inline">THREE.LineBasicMaterial</strong> but allows you to create a dashed line effect by specifying <strong class="source-inline">dash</strong> and <span class="No-Break"><strong class="source-inline">spacing</strong></span><span class="No-Break"> sizes.</span></li>
			</ul>
			<p>We’ll start with the basic variant; after that, we’ll look at the <span class="No-Break">dashed variant.</span></p>
			<h2 id="_idParaDest-79"><a id="_idTextAnchor078"/>THREE.LineBasicMaterial</h2>
			<p>The materials<a id="_idIndexMarker396"/> that are available<a id="_idIndexMarker397"/> for the <strong class="source-inline">THREE.Line</strong> geometry are very simple. It inherits all of the properties from <strong class="source-inline">THREE.Material</strong>, but the following are the properties that are most important for <span class="No-Break">this material:</span></p>
			<ul>
				<li><strong class="source-inline">color</strong>: This determines the color<a id="_idIndexMarker398"/> of the line. If you specify <strong class="source-inline">vertexColors</strong>, this property is ignored. An example of how to do this is shown in the following <span class="No-Break">code fragment.</span></li>
				<li><strong class="source-inline">vertexColors</strong>: You can supply a specific color for each vertex by setting this property to the <span class="No-Break"><strong class="source-inline">THREE.VertexColors</strong></span><span class="No-Break"> value.</span></li>
			</ul>
			<p>Before we look at an example of <strong class="source-inline">THREE.LineBasicMaterial</strong>, let’s have a quick look at how we can create a <strong class="source-inline">THREE.Line</strong> mesh from a set of vertices and combine that with <strong class="source-inline">THREE.LineMaterial</strong> to create the mesh, as shown in the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
const points = gosper(4, 50)
const lineGeometry = new THREE.BufferGeometry().
  setFromPoints(points)
const colors = new Float32Array(points.length * 3)
points.forEach((e, i) =&gt; {
  const color = new THREE.Color(0xffffff)
  color.setHSL(e.x / 100 + 0.2, (e.y * 20) / 300, 0.8)
  colors[i * 3] = color.r
  colors[i * 3 + 1] = color.g
  colors[i * 3 + 2] = color.b
})
lineGeometry.setAttribute('color', new THREE.
  BufferAttribute(colors, 3, true))
const material = new THREE.LineBasicMaterial(0xff0000);
const mesh = new THREE.Line(lineGeometry, material)
mesh.computeLineDistances()</pre>
			<p>The first part<a id="_idIndexMarker399"/> of this code fragment, <strong class="source-inline">const points = gosper(4, 60)</strong>, is used as an example<a id="_idIndexMarker400"/> to get a set of <strong class="source-inline">x</strong>, <strong class="source-inline">y</strong>, and <strong class="source-inline">z</strong> coordinates. This function returns<a id="_idIndexMarker401"/> a Gosper curve (for more information, check out <a href="https://mathworld.wolfram.com/Peano-GosperCurve.html">https://mathworld.wolfram.com/Peano-GosperCurve.html</a>), which is a simple algorithm that fills a 2D space. What we do next is create a <strong class="source-inline">THREE.BufferGeometry</strong> instance and call the <strong class="source-inline">setFromPoints</strong> function to add the generated points. For each coordinate, we also calculate a color value that we use to set the <strong class="source-inline">color</strong> attribute of the geometry. Note <strong class="source-inline">mesh.computeLineDistances</strong> at the end of this code fragment. This is needed when you want to have dashed lines when <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">THREE.LineDashedMaterial</strong></span><span class="No-Break">.</span></p>
			<p>Now that we have our geometry, we can create <strong class="source-inline">THREE.LineBasicMaterial</strong> and use this together with the geometry<a id="_idIndexMarker402"/> to create a <strong class="source-inline">THREE.Line</strong> mesh. You can see<a id="_idIndexMarker403"/> the result in the <strong class="source-inline">line-basic-material.html</strong> example. The following screenshot shows <span class="No-Break">this example:</span></p>
			<div>
				<div id="_idContainer094" class="IMG---Figure">
					<img src="image/Figure_4.23_B18726.jpg" alt="Figure 4.23 – Line basic material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.23 – Line basic material</p>
			<p>This is a line geometry created with <strong class="source-inline">THREE.LineBasicMaterial</strong>. If we enable the <strong class="source-inline">vertexColors</strong> property, we will see that the individual line segments <span class="No-Break">are colored:</span></p>
			<div>
				<div id="_idContainer095" class="IMG---Figure">
					<img src="image/Figure_4.24_B18726.jpg" alt="Figure 4.24 – Line basic material with vertex colors"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.24 – Line basic material with vertex colors</p>
			<p>The next and last material we’ll discuss in this chapter is only slightly different from <strong class="source-inline">THREE.LineBasicMaterial</strong>. With <strong class="source-inline">THREE.LineDashedMaterial</strong>, not only can we color lines, but we can also add spaces to <span class="No-Break">those lines.</span></p>
			<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/>THREE.LineDashedMaterial</h2>
			<p>This material has the same<a id="_idIndexMarker404"/> properties as <strong class="source-inline">THREE.LineBasicMaterial</strong> and three additional<a id="_idIndexMarker405"/> ones you can use to define the dash width and the width of the gaps between <span class="No-Break">the dashes:</span></p>
			<ul>
				<li><strong class="source-inline">scale</strong>: This scales <strong class="source-inline">dashSize</strong> and <strong class="source-inline">gapSize</strong>. If the scale is smaller than <strong class="source-inline">1</strong>, <strong class="source-inline">dashSize</strong> and <strong class="source-inline">gapSize</strong> increase, whereas if the scale is larger than <strong class="source-inline">1</strong>, <strong class="source-inline">dashSize</strong> and <span class="No-Break"><strong class="source-inline">gapSize</strong></span><span class="No-Break"> decrease.</span></li>
				<li><strong class="source-inline">dashSize</strong>: This is the size of <span class="No-Break">the dash.</span></li>
				<li><strong class="source-inline">gapSize</strong>: This is the size of <span class="No-Break">the gap.</span></li>
			</ul>
			<p>This material works almost exactly like <strong class="source-inline">THREE.LineBasicMaterial</strong>. The only difference is that you have to call <strong class="source-inline">computeLineDistances()</strong> (which is used to determine the distance<a id="_idIndexMarker406"/> between the vertices that make up a line). If you don’t do this, the gaps<a id="_idIndexMarker407"/> won’t be shown correctly. An example of this material can be found in <strong class="source-inline">line-dashed-material.html</strong> and looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer096" class="IMG---Figure">
					<img src="image/Figure_4.25_B18726.jpg" alt="Figure 4.25 – A Gosper mesh with the line dashed material"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.25 – A Gosper mesh with the line dashed material</p>
			<p>That’s it for this section on materials used for lines. You’ve seen that Three.js only provides a few materials specifically for line geometries, but with these materials, especially in combination with <strong class="source-inline">vertexColors</strong>, you should be able to style<a id="_idIndexMarker408"/> the line geometries<a id="_idIndexMarker409"/> any way <span class="No-Break">you want.</span></p>
			<h1 id="_idParaDest-81"><a id="_idTextAnchor080"/>Summary</h1>
			<p>Three.js gives you a lot of materials you can use to skin your geometries. The materials range from the very simple (<strong class="source-inline">THREE.MeshBasicMaterial</strong>) to the complex (<strong class="source-inline">THREE.ShaderMaterial</strong>), where you can provide your own <strong class="source-inline">vertexShader</strong> and <strong class="source-inline">fragmentShader</strong> programs. Materials share a lot of basic properties. If you know how to use a single material, you’ll probably also know how to use the other materials. Note that not all materials respond to the lights in your scene. If you want a material that takes lighting into effect, you can usually just use <strong class="source-inline">THREE.MeshStandardMaterial</strong>. If you need more control, you can also look at <strong class="source-inline">THREE.MeshPhysicalMaterial</strong>, <strong class="source-inline">THREE.MeshPhongMaterial</strong>, or <strong class="source-inline">THREE.MeshLamberMaterial</strong>. Determining the effect of certain material properties from just code is very hard. Often, a good idea is to use the control GUI approach to experiment with these properties, as we showed in <span class="No-Break">this chapter.</span></p>
			<p>Also, remember that most of the properties of a material can be modified at runtime. Some, though (for example, <strong class="source-inline">side</strong>), can’t be modified at runtime. If you change such a value, you need to set the <strong class="source-inline">needsUpdate</strong> property to <strong class="source-inline">true</strong>. For a complete overview of what can and cannot be changed at runtime, see the following <span class="No-Break">page: </span><a href="https://threejs.org/docs/#manual/en/introduction/How-to-update-things"><span class="No-Break">https://threejs.org/docs/#manual/en/introduction/How-to-update-things</span></a><span class="No-Break">.</span></p>
			<p>In this and the previous chapters, we talked about geometries. We used these in our examples and explored a couple of them. In the next chapter, you’ll learn everything about geometries and how you can work <span class="No-Break">with them.</span></p>
		</div>
	</body></html>