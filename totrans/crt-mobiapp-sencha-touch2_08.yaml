- en: 'Chapter 8. Evolver: Using Profiles'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the growing popularity of mobile devices, web designers have had to deal
    with a wide variety of screen sizes. This is even tougher on web application developers
    who also need to allow for different functionality between devices. Sencha Touch
    offers an easy way of dealing with multiple devices, called profiles.
  prefs: []
  type: TYPE_NORMAL
- en: Since the Sencha Touch framework is aware of which device it is running on,
    we can set up individual profiles for each device we want to support. Sencha Touch
    will then swap out components and functionality based on the device.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter we will look at:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading custom CSS by device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will create an application that reads pages and posts from a WordPress website
    and translates them into a custom application for mobile devices. We call this
    application, Evolver.
  prefs: []
  type: TYPE_NORMAL
- en: Evolver will use separate profiles to create a view for iPhone and a different
    view for iPad. These views will have their own functionality and can be customized
    to suit the needs of the user and the device.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we get too far ahead of ourselves, we should probably talk a
    little bit about what profiles do and when to use them.
  prefs: []
  type: TYPE_NORMAL
- en: An overview of profiles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiles in Sencha Touch act much like a director, or a traffic cop. When the
    application loads, the profiles determine what kind of device they are being run
    on and load a different set of controllers and views based on the device (the
    stores and models typically do not change).
  prefs: []
  type: TYPE_NORMAL
- en: 'As you may have guessed, this means that each profile (device) needs its own
    set of controllers and views. While they can, and do share elements such as stores
    and models, most of the display logic is unique to the device. This can seem like
    a lot of extra work, which leads to the question: when and why should you use
    profiles?'
  prefs: []
  type: TYPE_NORMAL
- en: Profile basics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a general rule, it is usually a good idea to design an application specifically
    for a device or screen size. A smaller screen requires bigger fonts in order to
    be readable, but it also has less space for information. This means that it usually
    relies on multiple screens to get the information across to the user. A similar
    interface on a tablet device would be clunky and frustrating in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: However, with a few simple applications, a change in CSS stylesheets will accomplish
    the necessary changes to the interface. A profile is not needed in this case and
    the stylesheet can simply be loaded based on the device being used. This method
    allows us to use the classes and IDs of our individual elements to control the
    overall appearance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: 'For most professional applications, a combination of profiles and stylesheet
    changes will better serve the end user. We can demonstrate this using some drawings
    of our Evolver application. Let''s start with our tablet version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profile basics](img/8901OS_08_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Here we have a lot of screen real estate we can put to use. We can easily show
    our list of pages and posts, and still show the content of the selected item at
    the same time. We have room for multiple tabs and even a website logo.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were to view this kind of layout on a phone-sized screen, it would be
    far too small to effectively use or even read. As we noted before, a phone-sized
    screen needs larger fonts and multiple screens to display the data the user needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Profile basics](img/8901OS_08_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this case we have two screens. The first is for our list of pages or posts.
    Our tabs at the bottom will determine which list the user sees. When the user
    selects an item from the list, we will use a second screen to display the content
    for the page or post. We will also provide a back button to allow the user to
    return to the mail list.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Sketches or Wireframes**'
  prefs: []
  type: TYPE_NORMAL
- en: Sketches like these are often called **wireframes**. It is a really good idea
    to draw out these types of ideas before you begin coding the application. They
    don't have to be fancy, they just need to make you think about how the application
    will be organized and how the user will get from one screen to the next. Wireframes
    can quickly highlight any issues you hadn't thought of yet, and they will save
    you a huge amount of time later on when you begin coding. It's also a good idea
    to show these wireframes to potential users. Non-technical people can often reveal
    areas of confusion for a user, and their questions and feedback will make your
    application more useful.
  prefs: []
  type: TYPE_NORMAL
- en: From looking at the two sketches, we can determine the views that we need and
    the different functions we will need in our controllers. For example, clicking
    on an item in the phone version will need to add a panel to a navigation view,
    while in the tablet version, clicking on an item will just replace the content
    in our main panel.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have some idea of the different views and functions we want, we
    can take a look at how the profiles actually work.
  prefs: []
  type: TYPE_NORMAL
- en: Using profiles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first part of our profile setup takes place in `app.js`. This file is typically
    where we load our initial stores and models, as well as set up a launch function
    to start the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'With profiles, things work a bit differently. We start by declaring the profiles
    we wish to use like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The names for our two profiles are arbitrary and we can have as many as we like.
    They can be specific to an OS as well as device type. When we use profiles such
    as these, we typically do not use a launch function inside our `app.js` file.
    Since the profiles will have different starting screens, we place the launch function
    inside the individual profiles.
  prefs: []
  type: TYPE_NORMAL
- en: The profiles should be placed in a directory called `profile`, inside the `app`
    directory of your application. They should be named the way you named them in
    your `app.js` file (in our case this would be `Phone.js` and `Tablet.js`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If it helps, you can think of the profile files as a way to have multiple `app.js`
    files, one per device.
  prefs: []
  type: TYPE_NORMAL
- en: 'These individual profiles will load our views and controllers, and they will
    launch our initial screen. However, the first thing we need to do is figure out
    which profile is active. We do this by creating an `isActive` function in our
    `Phone.js` file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This `isActive` function will return true if the application is running on
    a phone. We use a similar function in our `Tablet.js` profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Our `app.js` file will load one of these profiles, if the `isActive` function
    returns true. Only one of these profiles should ever return true.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find more information about the `Ext.os.is` function in the Sencha Touch
    developer documentation located at [http://docs.sencha.com/touch/2-1/#!/api/Ext.env.OS-method-is](http://docs.sencha.com/touch/2-1/#!/api/Ext.env.OS-method-is).
  prefs: []
  type: TYPE_NORMAL
- en: Each profile will also contain its own views and controllers, as well as its
    own launch function. However, it is important to note that the `Ext.loader` function
    will automatically look for these items in a subfolder named after the profile.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, our tablet profile has a controller called `Main.js`. We include
    this in our profile the same way we normally would in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, since this controller is inside a profile, the `Ext.loader` function
    will look for the file as `app/controllers/tablet/Main.js`. Conversely, in our
    phone profile, we still include the controller as `controllers: [''Main'']`, but
    the loader will automatically look for the file as `app/controllers/phone/Main.js`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can override this behavior in a profile by using the full name of the controller
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This would look for the `Main.js` file in the `app/controller` folder. This
    works the same for views, models, and stores as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will also find that some files are common to both profiles. Rather than
    including them in our individual profiles, we can include these common files in
    `app.js`. For example, in our Evolver application, we will have models and stores
    for pages and posts. These will be common to both profiles, so we can add them
    as normal in `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Since these load from `app.js` (and not from one of our profiles), the loader
    will look for them in the `app/model` and `app/store` folders respectively.
  prefs: []
  type: TYPE_NORMAL
- en: As we noted before, the profiles also have individual launch functions in addition
    to the optional `launch` function in `app.js`. In a profile-based application,
    the `app.js launch` function is typically ignored since the profiles will likely
    launch different components to create the main screen. However, if the application
    requires it, you can use the `app.js launch` function as well, to perform clean
    up or load stores if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order works something like this (when the application starts):'
  prefs: []
  type: TYPE_NORMAL
- en: The active profile is determined.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Any controllers in the profile or in `app.js` are instantiated (meaning the
    `init` function is fired).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The launch function in the profile fires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The launch function in `app.js` fires.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It should be noted that both the profile and `app.js launch` functions are optional
    and will only be called if they are defined.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have the profile basics out of the way, let's get a little more
    specific about our application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Evolver application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Evolver application takes an RSS feed from a WordPress website and translates
    the feed into data in a Sencha Touch store. We did something similar in our previous
    Feedback application with the RSS feed. However, we are going to need a bit of
    extra help to get all of the information we need out of WordPress.
  prefs: []
  type: TYPE_NORMAL
- en: About WordPress
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For those of you who don't know about WordPress, it is a content management
    system that was initially designed for blogging. WordPress allows a user to easily
    create posts and pages using simple web-based forms. Posts tend to be shorter,
    time-sensitive items, while pages contain longer, more general information.
  prefs: []
  type: TYPE_NORMAL
- en: When WordPress began to gain popularity, users quickly began to use it for all
    kinds of websites from personal, to business and shopping. Current estimates are
    that the WordPress site numbers somewhere north of 55 million, comprising an estimated
    15 to 20 percent of the active websites on the Internet.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the ease of installation and massive amounts of customization, WordPress
    has become a darling of the small business community. The one drawback is that
    the design complexity of a typical WordPress website doesn''t always lend itself
    to a mobile-sized screen and platform. The following screenshot is an example
    of a standard WordPress style website:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About WordPress](img/8901OS_08_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'While this kind of layout appears fine on a desktop or laptop screen, it''s
    not a great use of space for a tablet, and way too much information for a phone-sized
    screen. We need a mobile-friendly version of the site that makes effective use
    of the advantages and limitations of tablet and phone platforms. The following
    screenshot is an example of the approach we want to take:'
  prefs: []
  type: TYPE_NORMAL
- en: '![About WordPress](img/8901OS_08_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since the data behind the WordPress website already lives in a MySQL database,
    we just need a way to get it into a data store so we can use it in Sencha Touch.
  prefs: []
  type: TYPE_NORMAL
- en: The posts from WordPress are available in RSS format, but the pages are not.
    We are going to need to use a plugin for WordPress in order to get the pages we
    want as well. You will need to use your own WordPress website to make this work.
  prefs: []
  type: TYPE_NORMAL
- en: Using the plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: WordPress plugins allow you to extend the basic functions and features of WordPress.
    In most cases this process is as simple as searching and clicking on the install
    button. In this case, we will be installing Dan Phiffer's JSON API plugin. This
    plugin will allow us to make standard API calls into our WordPress site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s install the plugin and then we can see how it works with a bit of testing:'
  prefs: []
  type: TYPE_NORMAL
- en: From your WordPress admin page, select **Plugins** from the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Plugins** page, click on the **Add New** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enter `JSON API` in the **Search** field and click on **Search Plugins**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on **Install** next to the **JSON API** plugin (it should be the first
    one in the list).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can test to see if the plugin has been installed correctly by checking
    the following URL in your web browser(replace `yourwordpressdomain.com` with the
    address of your WordPress installation):'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://yourwordpressdomain.com/api/get_page_index/](http://yourwordpressdomain.com/api/get_page_index/)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should get back a JSON response string with the pages for your site. Note
    that this string comes back as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We need to keep in mind that the `pages` array actually contains the data we
    are looking for. This will get set as `rootProperty` of the store's reader component
    when we create our store.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the profiles and app.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with a basic Sencha Touch application, set up from our command-line
    SDK tools (as we did in some of our earlier chapters). This creates our application
    shell and our view, model, store, and controller folders.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our `app.js` file, we will add lines for our profiles. We also have some
    common elements in both profiles, specifically, the models and stores for pages
    and profiles. Since these will need to load for both profiles, we can add them
    in our `Ext.application` declaration, rather than adding them twice, once in each
    profile file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have our `app.js` file set up, we need to create a `profile` folder
    in our `app` directory. This is where our two profiles will go.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Phone.js` profile looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'We have three pieces here: the `config` section, our `isActive` function, and
    our `launch` function.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `config` section has the profile `name`, `controllers` and `views` values.
    Remember that since we are in the profile, the loader will be looking for these
    files in `app/controller/phone` and `app/view/phone` respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that we also have two of our views listed with the full names: `Evolver.view.PostList`
    and `Evolver.view.PageList`. These views will actually be shared by both profiles,
    so we put them in the `app/views` folder. We could also just put them in `app.js`
    and it would accomplish the same thing. We included them here to demonstrate that
    the file location can be overridden if required.'
  prefs: []
  type: TYPE_NORMAL
- en: Our `isActive` function will return true if we are running on a phone.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**isActive, device types, and Safari**'
  prefs: []
  type: TYPE_NORMAL
- en: If you are testing on Safari with a desktop or laptop, you will run into some
    issues using this function. Despite the ability to set the user agent in Safari
    to iPad or iPod, the browser does not correctly report the device type to Sencha
    Touch.
  prefs: []
  type: TYPE_NORMAL
- en: When you are testing, you will need to comment out the `return Ext.os.is.Phone`
    or `return Ext.os.is.Tablet` lines in the `isActive` function. Then you can set
    the `isActive` function in the profile you want to test to `return true;` and
    the other one to `return false;`. Just remember to uncomment the correct functions
    before moving to production.
  prefs: []
  type: TYPE_NORMAL
- en: If you are testing with the iOS or Android simulators, this is not an issue.
  prefs: []
  type: TYPE_NORMAL
- en: The `launch` function removes our loading indicator and creates an instance
    of our `Evolver.view.phone.Main` view at full screen size.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Tablet.js` profile follows the same pattern as our phone profile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Much like the phone profile, the controllers and views will be loaded from a
    `tablet` folder in our `app/controllers` and `app/views` folders.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to take a very brief look at the stores, models, and views for
    the application as there isn't much new here. Then, we will finish up with the
    controllers, where the action really happens.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the models and stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our models are very basic, and they are taken from the data that is sent back
    from the RSS feed for posts and the JSON API plugin for pages. We are only using
    some of that data, but you can easily look through the values that are returned
    from `yoursite/feeds/rss/` (posts) and `yoursite/api/get_page_index/` (pages)
    to see if there is any other interesting data you might want to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our post model looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The only thing new here is the use of mapping to indicate that, while we will
    refer to the strings as `author` and `content`, the data is actually received
    as `creator` and `encoded` respectively. This is often helpful to keep values
    consistent across the application, avoid naming conflicts, or simply preserve
    a coder's sanity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `postStore` attribute for this model is configured to run from the same
    server as the WordPress website you are using. This means we can use an `ajax`
    store instead of a `jsonp` store. If you want to use this from a different server,
    you will need to change the proxy to `jsonp` and use the JSON API to grab the
    posts instead of the standard WordPress RSS feed (which is in XML):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `record: ''item''` configuration tells the reader to look in the XML for
    a collection of items to be used as the data for its records.'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**WordPress RSS feeds**'
  prefs: []
  type: TYPE_NORMAL
- en: By default, RSS feeds in WordPress are set to only show a partial text of the
    post. You can change this in the **Admin** control panel of your WordPress site.
    In the **Admin** menu select **Settings** | **Reading** and change the feed settings
    from **Summary** to **Full Text**.
  prefs: []
  type: TYPE_NORMAL
- en: Since this store is not a JSONP store, it has to be run on the same server as
    the WordPress site it is pulling from. There is not an equivalent XMLP store,
    so testing on a local machine will require a bit of a workaround. During testing,
    you can download the RSS feed from your WordPress site to your local machine and
    read from the local XML file. Later, when you move to production, you can change
    the URL to the live link.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `pageStore` is designed to use the JSON API plugin, so we will be taking
    in JSON instead of XML:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: With this store we are reading JSON from our API. The `get_page_index` function
    will return a hierarchical list of the pages for the website.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The JSON API plugin for WordPress has a number of helpful functions you can
    use to read and write data to your WordPress website. A full list of functions
    can be found here at [http://wordpress.org/extend/plugins/json-api/other_notes/](http://wordpress.org/extend/plugins/json-api/other_notes/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Our data model for the pages is using a limited set of the data supplied by
    the JSON API plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: You can see a full list of all the data available by going to the API URL for
    your WordPress site ([http://yourWordPressSite.com/api/get_page_index/?dev=1](http://yourWordPressSite.com/api/get_page_index/?dev=1)).
    The `dev1` argument will format the JSON response and make it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our stores and models, we can work on our views for displaying
    the data.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we will be sharing the list views for our post and pages between our two
    profiles, let's start there. We will be using a data view instead of a list view,
    as this provides us with a few more display options than a simple list.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `PostList.js` file looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Much like our standard list, `DataView` takes a data store and displays the
    items in order from the store. However, `DataView` is more flexible from a styling
    point of view, allowing the creation of tiled lists and other more interesting
    layouts.
  prefs: []
  type: TYPE_NORMAL
- en: This view reads from `postStore` and uses `itemTpl` to display the title, author,
    and date from each post. Each of our data items is styled with a particular class,
    which means we can display them in different ways depending on which stylesheet
    we load, or even turn them off completely. We will talk about these kinds of conditional
    stylesheets towards the end of the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `PageList` view follows a similar structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This shared view reads from our `pageStore` and displays just the title and
    date. As noted, you can add any of the other data generated by the WordPress JSON
    API, and then use a conditional stylesheet to show it or hide it, based on the
    device the user is viewing from.
  prefs: []
  type: TYPE_NORMAL
- en: Our other views will be unique to either the phone or tablet profile. For the
    purposes of this chapter, each of the views are similar, each is a simple container
    with a template to format the record for display. Let's start with our phone details
    container.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the phone details view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Since this details container is part of our phone profile, it is named `Evolver.view.phone.PageDetails`
    and it will be in the `app/view/phone/` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We also set a configuration for `scrollable` in this view. Since we are in a
    navigation view, which can be triggered with a swipe, we set the direction and
    direction lock to keep the swipe from triggering a page change.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tablet details view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The tablet version of our `PageDetails.js` view looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The only differences between the two are the name (`Evolver.view.tablet.PageDetails`)
    and the URL for the page which we include at the bottom of `tpl`. While a **View
    Original Page** link is common in most tablet-based apps, it's not really needed
    for a phone app since we are trying to avoid the original site in the first place.
  prefs: []
  type: TYPE_NORMAL
- en: We will be handling the scrolling differently in the tablet version, so we do
    not include a `scrollable` configuration here.
  prefs: []
  type: TYPE_NORMAL
- en: As previously noted, you could make these two containers as different as you
    want. You could make one of them a panel and the other a container if you prefer.
    Since only one of them will actually be included, we can even keep the same value
    for our `alias` attribute of `widget.pageDetails`. There will not be an `xtype`
    conflict because only the phone version or the tablet version will ever be active
    at one time.
  prefs: []
  type: TYPE_NORMAL
- en: Our `postDetails` object for phone and tablet follow the same format, so we
    won't bother covering them here. You can see them in the sample code for the chapter.
    Just remember that the phone versions go in `app/view/phone` and the tablet versions
    go in `app/view/tablet`. Also, the view naming conventions will follow the format
    of `Evolver.view.phone.viewName` and `Evolver.view.tablet.viewName`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need to put the individual pieces together into a main container for
    each of our profiles.
  prefs: []
  type: TYPE_NORMAL
- en: The main views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'From our original sketches, we have two different interfaces. The first one
    we will look at is the phone interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The main views](img/8901OS_08_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Since a phone screen has limited size, we need to create a more compact and
    layered interface. This will allow us to display all of our data, while still
    providing the user with readable text.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the phone main view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The phone `Main.js` interface will consist of a tab view with two DataViews
    (one for pages and one for posts). Each DataView is inside a navigation view.
    When we click an item in the DataView, the controller will pop our details container
    onto the navigation view, creating a back button automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We give this view an `id` value of `mainView` to make it easy to address within
    our controller. You will notice that the navigation views have a `title` configuration,
    and the DataView inside each navigation view has its own `title` configuration
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: The two navigation views are direct children of the overall tab panel. This
    means that the title on the tabs at the bottom of our main tab panel will use
    this title. The DataViews inside the navigation views each have a title bar component,
    which will display the title for each DataView at the top.
  prefs: []
  type: TYPE_NORMAL
- en: By using a two-list strategy with the navigation view for popping on the details,
    we make the best use of our limited phone screen area. With our tablet profile,
    we have a bit more room to work with, so we can take a different approach.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the tablet main view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Since we have additional room available on a tablet-sized screen, we can use
    a different view to take advantage of the extra space:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the tablet main view](img/8901OS_08_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Our tablet `Main.js` view has the two DataViews in a tab panel much like our
    phone profile version. However, the tablet version keeps a visible main content
    area where we can display the currently selected item. We also include an area
    above the content where we can place the website logo using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We start by extending the basic `Ext.Panel` component and giving it a `fit`
    layout. Inside this panel are a tab panel and two containers.
  prefs: []
  type: TYPE_NORMAL
- en: The `tabpanel` component contains our two DataViews (pages and posts), just
    as we had them in the phone version of the application. We set this up to have
    a `width` value of `200`.
  prefs: []
  type: TYPE_NORMAL
- en: The content container is set to a `vbox` layout with three child containers.
    The top container for our logo will have a `height` value of `140` and an HTML
    link to the logo from our WordPress site. The `vbox` layout means that our other
    containers, with our content for posts and pages, will automatically resize to
    fit the rest of the available space.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our `postdetails` container is hidden by default and the page details
    are visible. We will swap these two containers based on which DataView is selected
    in our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the controllers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Evolver application uses a pair of DataViews (one for posts and one for
    pages), which are shared between both the phone and tablet profiles. In the case
    of the phone profile, the DataView needs to listen for the tap event and add a
    new details component to the navigation container. In the case of the tablet profile,
    the DataView is still listening for the tap event, but it needs to swap the two
    details containers based on which the DataView is selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'By isolating the functionality from the display logic, we can make a single
    DataView perform two different actions (one in the phone version and another in
    the tablet version). We start this out in both our `phone.js` and `main.js` controllers,
    and our `tablet.js` and `main.js` controllers like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The phone profile version is shown here, but at this point the tablet version
    is actually the same, just named `Evolver.controller.tablet.Main`.
  prefs: []
  type: TYPE_NORMAL
- en: Our references set up our short hand pointers to our components. Since `postList`
    and `pageList` are the same for both applications, and we consistently named our
    main container for both profiles, the references are the same in both controllers.
  prefs: []
  type: TYPE_NORMAL
- en: We also use the same code for our `control` configurations, where both lists
    need to listen for the `itemTap` event to trigger our function. To make our lives
    easier, we also make the DataViews trigger the same function called `onListItemTap`.
    We can decide what needs to happen based on which list got tapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is where our two controllers diverge. Let''s start with the phone version
    of the `onListItemTap` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We do some interesting manipulations with the first part of this function to
    modify our content to display better on a phone-sized screen. Since the content
    coming back to us has full-sized images, it will often take up a huge amount of
    space on a phone-sized screen, making the layout kind of crummy.
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this problem, we first grab the content out of the record with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we make two passes through the content to find and replace some of the
    image information so that we can manipulate the sizes the way we want. The first
    pass looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This will take an image tag with a `src` link that looks like [http://mydomain.com/images/image15.png](http://mydomain.com/images/image15.png)
    and turn it into `http://src.sencha.io/120/http://mydomain.com/images/image15.png`.
  prefs: []
  type: TYPE_NORMAL
- en: This format will grab the image and run it through `src.sencha.io` for processing
    before it is displayed. The value of 120 indicates that the image will be automatically
    resized to a maximum width of 120 pixels or about half the size of a typical phone
    screen.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**src.sencha.io**'
  prefs: []
  type: TYPE_NORMAL
- en: src.sencha.io can be used to resize any image on the fly. There are a number
    of useful features to this service and more information can be found here at [http://docs.sencha.io/current/index.html#!/guide/src](http://docs.sencha.io/current/index.html#!/guide/src).
  prefs: []
  type: TYPE_NORMAL
- en: 'The third and final transformation removes the original height and width configurations
    from the `<img>` tags using a regular expression to match and remove the values.
    By default, WordPress will insert `height` and `width` tags when an image is included
    as part of a post or a page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If we just used our first bit of code to resize the actual image without removing
    the height and width configurations, the image will actually appear at the original
    size, just pixelated and ugly looking.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Regular expressions**'
  prefs: []
  type: TYPE_NORMAL
- en: Regular Expressions, or **Regexes**, are an incredibly valuable tool for matching
    patterns in strings. You can find out more information on Regexes at [http://www.rexv.org/](http://www.rexv.org/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once, we have done all of our conversions, we set the content value of our
    record to our new and improved value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'With the conversion out of the way, we need to figure out which details container
    we need. Fortunately, we are passed the view that was clicked as part of our `itemTap`
    handler. We can use this to check to see which DataView is active:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'If we have `postList`, we need to create a new post details container, and
    if not, we want to create a new page details container. Once we have the new container,
    we push it onto the active item with this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We use `this.getMainView()` to grab our main view using the reference we created
    earlier. By using `getActiveItem()`, we are assured of getting the DataView the
    user is looking at and pushing the container onto the correct navigation view.
  prefs: []
  type: TYPE_NORMAL
- en: 'That''s all there is to the phone profile''s `Main.js` controller file. The
    tablet version of the `Main.js` controller is exactly the same except for the
    `onListItemTap()` function, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: In this function we do our conversion the way we did before in the phone version.
    This time we increase the maximum width to 240 pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we grab our two details containers with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Once we have those, we use the `dataview id` just as we did before to get the
    currently active DataView. We then hide one and show the other after adding our
    record to it for display.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the two controllers, we can completely dictate the functions
    in the application, regardless of whether or not the view itself is shared between
    profiles. Combined with the ability to include different views based on a particular
    profile, we can easily target the application to a particular platform's strengths
    and overcome any potential weaknesses.
  prefs: []
  type: TYPE_NORMAL
- en: However, as powerful as this is, there is still one other trick we can use to
    further customize our application based on platform or device, that is, conditional
    styling.
  prefs: []
  type: TYPE_NORMAL
- en: Conditional styling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should be familiar with the use of CSS stylesheets to control the look of
    elements of your web page based on `id` or `class`. Since these can be applied
    to Sencha components and within xTemplates, we can use these classes and IDs to
    control the look of our application as well. We do this by checking the device's
    width using a media query.
  prefs: []
  type: TYPE_NORMAL
- en: Media queries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Media queries are actually a part of the CSS standards and not a direct part
    of Sencha Touch. However, since Sencha Touch uses CSS, we can inherit this tool
    and use it as an easy way to make decisions based on the environment that the
    web page is being displayed in. While this functionality has been around for quite
    some time, it was not standard across all web browsers until recently. Fortunately
    for us, Sencha Touch is only supported on modern web browsers, so the late adoption
    of the standard does not affect us.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you have used a lot of CSS in the past few years, you may have noticed the
    use of media in stylesheet links like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This setup would use `main.css` for displaying in the browser and `print.css`
    when printing the page out to a printer. This was typically used to remove navigation
    and extraneous page elements during printing.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, these same media queries can be used to include stylesheets based
    on the screen size like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This media query will load the stylesheet if the device is using a web browser
    (screen) with a maximum screen width of 480px (like an iPhone 3G).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can even take this a step further and change the stylesheet based on the
    orientation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: These two links will include `iPhonePortrait.css` when the iPhone is held in
    portrait orientation and `iPhoneLandscape.css` when held in landscape orientation.
  prefs: []
  type: TYPE_NORMAL
- en: Combining these CSS media queries with Sencha Touch's profiles allows us to
    target a particular device at a very granular level.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When designing applications for a mobile environment, it is extremely important
    to take advantage of any special features of the device and avoid any potential
    shortfalls the device may have. By tailoring an application directly to the device,
    you provide a better overall user experience. In this chapter, we showed you how
    to make the most of this ability by covering the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: The basics and usage of profiles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up WordPress to work with Sencha Touch
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the basic Evolver application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the controllers to manage functionality on both phone and tablet
    devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using media queries to further style your applications for a particular device
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter we will take a look how to access some of the hardware capabilities
    of your device, specifically the camera. We also show you how to compile your
    application to take advantage of more of your device's features.
  prefs: []
  type: TYPE_NORMAL
