- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are starting to get a good basic grasp of JavaScript. This chapter will
    focus on a very important control flow concept: loops. Loops execute a code block
    a certain number of times. We can use loops to do many things, such as repeating
    operations a number of times and iterating over data sets, arrays, and objects.
    Whenever you feel the need to copy a little piece of code and place it right underneath
    where you copied it from, you should probably be using a loop instead.'
  prefs: []
  type: TYPE_NORMAL
- en: We will first discuss the basics of loops, then continue to discuss nesting
    loops, which is basically using loops inside loops. Also, we will explain looping
    over two complex constructs we have seen, arrays and objects. And finally, we
    will introduce two keywords related to loops, `break` and `continue`, to control
    the flow of the loop even more.
  prefs: []
  type: TYPE_NORMAL
- en: There is one topic that is closely related to loops that is not in this chapter.
    This is the built-in `foreach` method. We can use this method to loop over arrays,
    when we can use an arrow function. Since we won't discuss these until the next
    chapter, `foreach` is not included here.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the different loops we will be discussing in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`while` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`do` `while` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for` `in`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`for of` loop'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Note: exercise, project, and self-check quiz answers can be found in the *Appendix*.'
  prefs: []
  type: TYPE_NORMAL
- en: while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `while` loop will only be executed as long as the condition is `true`, so
    if the condition is `false` to begin with, the code inside will be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a very simple example of a `while` loop printing the numbers 0 to 10
    (excluding 10) to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'These are the steps happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a variable, `i`, and set its value to zero
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start the `while` loop and check the condition that the value of `i` is smaller
    than 10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the condition is true, the code logs `i` and increases `i` by 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The condition gets evaluated again; 1 is still smaller than 10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since the condition is true, the code logs `i` and increases `i` by 1
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The logging and increasing continues until `i` becomes 10
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 10 is not smaller than 10, so the loop ends
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can have a `while` loop that looks for a value in an array, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'It checks whether the first value of the array is a certain value, and when
    it is not, it deletes that value from the array using the `shift` method. Remember
    this method? It removes the first element of the array. So, by the next iteration,
    the first value has changed and is checked again. If it stumbles upon the value,
    it will log this to the console and change the Boolean `notFound` to `false`,
    because it has found it. That was the last iteration and the loop is done. It
    will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Why do you think the `&& someArray.length > 0` is added in the `while` condition?
    If we were to leave it out, and the value we were looking for was not in the array,
    we would get stuck in an infinite loop. This is why we make sure that we also
    end things if our value is not present, so our code can continue.
  prefs: []
  type: TYPE_NORMAL
- en: 'But we can also do more sophisticated things very easily with loops. Let''s
    see how easy it is to fill an array with the Fibonacci sequence using a loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: In the Fibonacci sequence, each value is the sum of the two previous values,
    starting with the values 0 and 1\. We can do this in a `while` loop as stated
    above. We create two numbers and they change every iteration. We have limited
    our number of iterations to the length of the `fibonacciArray`, because we don't
    want an infinite loop. In this case the loop will be done as soon as the length
    of the array is no longer smaller than 25\.
  prefs: []
  type: TYPE_NORMAL
- en: We need a temporary variable that stores the next value for `nr2`. And every
    iteration we push the value of the first number to the array. If we log the array,
    you can see the numbers getting rather high very quickly. Imagine having to generate
    these values one by one in your code!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Practice exercise 5.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise we will create a number guessing game that takes user input
    and replies based on how accurate the user's guess was.
  prefs: []
  type: TYPE_NORMAL
- en: Create a variable to be used as the max value for the number guessing game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Generate a random number for the solution using `Math.random()` and `Math.floor()`.
    You will also need to add 1 so that the value is returned as 1-[whatever the set
    max value is]. You can log this value to the console for development to see the
    value as you create the game, then when the game is complete you can comment out
    this console output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable that will be used for tracking whether the answer is correct
    or not and set it to a default Boolean value of `false`. We can update it to be
    `true` if the user guess is a match.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a `while` loop to iterate a prompt that asks the user to enter a number
    between 1 and 5, and convert the response into a number in order to match the
    data type of the random number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the `while` loop, check using a condition to see if the prompt value
    is equal to the solution number. Apply logic such that if the number is correct,
    you set the status to `true` and break out of the loop. Provide the player with
    some feedback as to whether the guess was high or low, and initiate another prompt
    until the user guesses correctly. In this way we use the loop to keep asking until
    the solution is correct, and at that point we can stop the iteration of the block
    of code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: do while loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In some cases, you really need the code block to be executed at least once.
    For example, if you need valid user input, you need to ask at least once. The
    same goes for trying to connect with a database or some other external source:
    you will have to do so at least once in order for it to be successful. And you
    will probably need to do so as long as you did not get the result you needed.
    In these cases, you can use a **do while loop**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the syntax looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It executes what is within the `do` block, and then after that it evaluates
    the `while`. If the condition is `true`, it will execute what is in the `do` block
    again. It will continue to do so until the condition in the `while` changes to
    `false`.
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `prompt()` method to get user input. Let's use a `do while` loop
    to ask the user for a number between 0 and 100.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here is the output; you will have to enter the number in the console yourself
    here.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Everything behind the `>` is user input here. The `>` is part of the code; it
    is added by the console to make the distinction between console output (`Please
    enter a number between 0 and 100`) and the console input (`-50`, `150`, and `34`)
    clearer.
  prefs: []
  type: TYPE_NORMAL
- en: It asks three times, because the first two times the number was not between
    0 and 100 and the condition in the `while` block was true. With `34`, the condition
    in the `while` block became false and the loop ended.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 5.2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we will create a basic counter that will increase a dynamic
    variable by a consistent step value, up to an upper limit.
  prefs: []
  type: TYPE_NORMAL
- en: Set the starting counter to 0
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a variable, `step`, to increase your counter by
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `do while` loop, printing the counter to the console and incrementing
    it by the `step` amount each loop
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Continue to loop until the counter is equal to 100 or more than 100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: for loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**for loops** are special loops. The syntax might be a little bit confusing
    at first, but you will find yourself using them soon, because they are very useful.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the syntax looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Between the parentheses following the `for` statement, there are three parts,
    separated by semi-colons. The first one initializes the variables that can be
    used in the `for` loop. The second one is a condition: as long as this condition
    is true, the loop will keep on iterating. This condition gets checked after initializing
    the variables before the first iteration (this will only take place when the condition
    evaluates to true). The last one is a statement. This statement gets executed
    after every iteration. Here is the flow of a `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: Initialize the variables.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Check the condition.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the condition is true, execute the code block. If the condition is false,
    the loop will end here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Perform the statement (the third part, for example, `i++`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back to step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This is a simple example that logs the numbers 0 to 10 (excluding 10) to the
    console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: It starts by creating a variable, `i`, and sets this to `0`. Then it checks
    whether `i` is smaller than 10\. If it is, it will execute the log statement.
    After this, it will execute `i++` and increase `i` by one.
  prefs: []
  type: TYPE_NORMAL
- en: If we don't increase `i`, we will get stuck in an infinite loop, since the value
    of `i` would not change and it would be smaller than 10 forever. This is something
    to look out for in all loops!
  prefs: []
  type: TYPE_NORMAL
- en: The condition gets checked again. And this goes on until `i` reaches a value
    of 10\. 10 is not smaller than 10, so the loop is done executing and the numbers
    0 to 9 have been logged to the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also use a `for` loop to create a sequence and add values to an array,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what the array looks like after this loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Since the loop ran the block of code 100 times, starting with an initial value
    of 0 for `i`, the block of code will add the incrementing value into the array
    at the end of the array. This results in an array that has a count of 0–99 and
    a length of 100 items. Since arrays start with an index value of zero, the values
    in the array will actually match up with the index values of the items in the
    array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Or we could create an array containing only even values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Resulting in this array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Most commonly, you will see `i++` as the third part of the `for` loop, but please
    note that you can write any statement there. In this case, we are using `i = i
    + 2` to add 2 to the previous value every time, creating an array with only even
    numbers.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 5.3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise we will use a `for` loop to create an array that holds objects.
    Starting with creating a blank array, the block of code within the loop will create
    an object that gets inserted into the array.
  prefs: []
  type: TYPE_NORMAL
- en: Setup a blank array, `myWork`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using a `for` loop, create a list of 10 objects, each of which is a numbered
    lesson (e.g. Lesson 1, Lesson 2, Lesson 3….) with an alternating `true`/`false`
    status for every other item to indicate whether the class will be running this
    year. For example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can specify the status by using a ternary operator that checks whether the
    modulo of the given lesson value is equal to zero and by setting up a Boolean
    value to alternate the values each iteration.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a lesson using a temporary object variable, containing the name (`lesson`
    with the numeric value) and predefined status (which we set up in the previous
    step).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the objects to the `myWork` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the array to the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nested loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes it can be necessary to use a loop inside a loop. A loop inside a loop
    is called a nested loop. Often it is not the best solution to the problem. It
    could even be a sign of poorly written code (sometimes called "code smell" among
    programmers), but every now and then it is a perfectly fine solution to a problem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what it would look like for `while` loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Nesting can also be used with `for` loops, or with a combination of both `for`
    and `while`, or even with all kinds of loops; they can go several levels deep.
  prefs: []
  type: TYPE_NORMAL
- en: An example in which we might use nested loops would be when we want to create
    an array of arrays. With the outer loop, we create the top-level array, and with
    the inner loop we add the values to the array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When we log this array like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We can see that the output is an array of arrays with values from `0` up to
    `6`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We used the nested loops to create an array in an array, meaning we can work
    with rows and columns after having created this loop. This means nested loops
    can be used to create tabular data. We can show this output as a table using the
    `console.table()` method instead, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Let's put this into practice in the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 5.4
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise we will be generating a table of values. We will be using loops
    to generate rows and also columns, which will be nested within the rows. Nested
    arrays can be used to represent rows in a table. This is a common structure in
    spreadsheets, where each row is a nested array within a table and the contents
    of these rows are the cells in the table. The columns will align as we are creating
    an equal number of cells in each row.
  prefs: []
  type: TYPE_NORMAL
- en: To create a table generator, first create an empty array, `myTable`, to hold
    your table data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set variable values for the number of rows and columns. This will allow us to
    dynamically control how many rows and columns we want within the table. Separating
    the values from the main code helps make updates to the dimensions easier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a `counter` variable with an initial value of `0`. The counter will be
    used to set the content and count the values of the cells within the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `for` loop with conditions to set the number of iterations, and to
    construct each row of the table. Within it, set up a new temporary array (`tempTable`)
    to hold each row of data. The columns will be nested within the rows, generating
    each cell needed for the column.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Nest a second loop within the first to count the columns. Columns are run within
    the row loop so that we have a uniform number of columns within the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Increment the main counter each iteration of the inner loop, so that we track
    a master count of each one of the cells and how many cells are created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the counter values to the temporary array, `tempTable`. Since the array
    is a nested array representing a table, the values of the counter can also be
    used to illustrate the cell values next to each other in the table. Although these
    are separate arrays representing new rows, the value of the counter will help
    illustrate the overall sequence of cells in the final table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the temporary array to the main table. As each iteration builds a new row
    of array items, this will continue to build the main table in the array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output into the console with `console.table(myTable)`. This will show you a
    visual representation of the table structure.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loops and arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are not convinced of how extremely useful loops are by now, have a look
    at loops and arrays. Loops make life with arrays a lot more comfortable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can combine the `length` property and the condition part of the `for` loop
    or `while` loop to loop over arrays. It would look like this in the case of a
    `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s start with a simple example that is going to log every value of the
    array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: We use the `length` property to determine the maximum value of our index. The
    index starts counting at 0, but the length does not. The index is always one smaller
    than the length. Hence, we loop over the values of the array by increasing the
    length.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case we aren''t doing very interesting things yet; we are simply printing
    the values. But we could be changing the values of the array in a loop, for example,
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'We have concatenated `hello` with the beginnings of our names. The array is
    changed in the loop and the array will have this content after the loop has executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The possibilities are endless here. When an array comes in somewhere in the
    application, data can be sent to the database per value. Data can be modified
    by value, or even filtered, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `startsWith()` method just checks whether the string starts with a certain
    character. In this case it checks whether the name starts with the string `M`.
  prefs: []
  type: TYPE_NORMAL
- en: Don't worry, we will cover this function and many more in detail in *Chapter
    8*, *Built-in JavaScript Methods*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You'll have to be careful here though. If we were to remove the item instead
    of deleting it and leaving an empty value, we would accidentally skip the next
    value, since that value gets the index of the recently deleted one and `i` is
    incremented and moves on to the next index.
  prefs: []
  type: TYPE_NORMAL
- en: 'What do you think this one does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Your program gets stuck in an infinite loop here. Since a value gets added every
    iteration, the length of the loop grows with every iteration and `i` will never
    be bigger than or equal to `length`.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 5.5
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Explore how to create a table grid that contains nested arrays as rows within
    a table. The rows will each contain the number of cells needed for the number
    of columns set in the variables. This grid table will dynamically adjust depending
    on the values for the variables.
  prefs: []
  type: TYPE_NORMAL
- en: Create a grid array variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a value of `64` for the number of cells.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a counter to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a global variable to be used for the `row` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a loop that will iterate up to the number of cells you want in the array,
    plus one to include the zero value. In our example, we would use 64+1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an outer `if` statement, which uses modulo to check if the main counter
    is divisible by 8 or whatever number of columns you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Inside the preceding `if` statement, add another `if` statement to check if
    the row is undefined, indicating whether it is the first run or whether the row
    is complete. If the row has been defined, then add the row to the main grid array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To finish off the outer `if` statement, if the counter is divisible by 8, clear
    the `row` array—it has already been added to the grid by the inner `if` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the end of the for loop, increment of the main counter by 1.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up a temporary variable to hold the value of the counter and push it to
    the `row` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Within the loop iteration, check if the value of the counter is equal to the
    total number of columns you want; if it is, then add the current row to the grid.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please note that the extra cell will not be added to the grid since there aren't
    enough cells to make a new row within the condition that adds the rows to the
    grid. An alternative solution would be to remove the +1 from the loop condition
    and add `grid.push(row)` after the loop is completed, both of which will provide
    the same solution output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the grid into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: for of loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There is another loop we can use to iterate over the elements of an array:
    the **for of loop**. It cannot be used to change the value associated with the
    index as we can do with the regular loop, but for processing values it is a very
    nice and readable loop.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is what the syntax looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'So you can read it like this: "For every value of the array, call it `variableName`
    and do the following." We can log our `names` array using this loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to specify a temporary variable; in this case we called it `name`.
    This is used to put the value of the current iteration in, and after the iteration,
    it gets replaced with the `next` value. This code results in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: There are some limitations here; we cannot modify the array, but we could write
    all the elements to a database or a file, or send it somewhere else. The advantage
    of this is that we cannot accidentally get stuck in an infinite loop or skip values.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 5.6
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This exercise will construct an array as it loops through the incrementing values
    of x. Once the array is done, this exercise also will demonstrate several ways
    to output array contents.
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Run a loop 10 times, adding a new incrementing value to the array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Log the array into the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `for` loop to iterate through the array (adjust the number of iterations
    to however many values are in your array) and output into the console
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `for of` loop to output the value into the console from the array
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loops and objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have just seen how to loop over the values of an array, but we can also loop
    over the properties of an object. This can be helpful when we need to go over
    all the properties but don't know the exact properties of the object we are iterating
    over.
  prefs: []
  type: TYPE_NORMAL
- en: Looping over an object can be done in a few ways. We can use the `for in` loop
    to loop over the object directly, or we can convert the object to an array and
    loop over the array. We'll consider both in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: for in loop
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Manipulating objects with loops can also be done with another variation of
    the `for` loop, the **for in loop**. The `for in` loop is somewhat similar to
    the `for of` loop. Again here, we need to specify a temporary name, also referred
    to as a key, to store each property name in. We can see it in action here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to use the prop of each loop iteration to get the value out of the
    `car` object. The output then becomes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we just logged the prop, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what our output would look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, all the names of the properties get printed, and not the values.
    This is because the `for in` loop is getting the property names (keys) and not
    the values. The `for of` is doing the opposite; it is getting the values and not
    the keys.
  prefs: []
  type: TYPE_NORMAL
- en: This `for in` loop can also be used on arrays, but it is not really useful.
    It will only return the indices, since these are the "keys" of the values of the
    arrays. Also, it should be noted that the order of execution cannot be guaranteed,
    even though this is usually important for arrays. It is therefore better to use
    the approaches mentioned in the section on loops and arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 5.7
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this exercise, we will experiment with looping over objects and internal
    arrays.
  prefs: []
  type: TYPE_NORMAL
- en: Create a simple object with three items in it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Using the `for in` loop, get the properties' names and values from the object
    and output them into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an array containing the same three items. Using either the `for` loop
    or the `for in` loop, output the values from the array into the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Looping over objects by converting to an array
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can use any loop on objects, as soon as you convert the object to an array.
    This can be done in three ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Convert the keys of the object to an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Convert the values of the object to an array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Convert the key-value entries to an array (containing arrays with two elements:
    object key and object value)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s use this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: If we want to loop over the keys of the object, we can use the `for in` loop,
    as we saw in the previous section, but we can also use the `for of` loop if we
    convert it to an array first. We do so by using the `Object.keys(nameOfObject)`
    built-in function. This takes an object and grabs all the properties of this object
    and converts them to an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'To demonstrate how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'We can loop over the properties of this array like this using the `for of`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And this is what it will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, we can use the `for of` loop to loop over the values of the object
    by converting the values to an array. The main difference here is that we use
    `Object.values(nameOfObject)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'You can loop over these arrays in the same way you loop over any array. You
    can use the length and index strategy like this in a regular `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'And this will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'More interesting is how to loop over both arrays at the same time using the
    `for of` loop. In order to do so, we will have to use `Object.entries()`. Let''s
    demonstrate what it does:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it is returning a two-dimensional array, containing key-value
    pairs. We can loop over it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'And this will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Alright, you have seen many ways to loop over objects now. Most of them come
    down to converting the object to an array. We can imagine that at this point you
    could use a break. Or maybe you'd just like to continue?
  prefs: []
  type: TYPE_NORMAL
- en: break and continue
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**break** and **continue** are two keywords that we can use to control the
    flow of execution of the loop. `break` will stop the loop and move on to the code
    below the loop. `continue` will stop the current iteration and move back to the
    top of the loop, checking the condition (or in the case of a `for` loop, performing
    the statement and then checking the condition).'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using this array of `car` objects to demonstrate `break` and `continue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: We will first have a closer look at `break`.
  prefs: []
  type: TYPE_NORMAL
- en: break
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen **break** in the `switch` statement. When `break` was
    executed, the `switch` statement ended. This is not very different when it comes
    to loops: when the `break` statement is executed, the loop will end, even when
    the condition is still true.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a silly example to demonstrate how `break` works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like a loop that will log the numbers 0 to 10 (again excluding 10)
    to the console. There is a catch here though: as soon as `i` equals `4`, we execute
    the `break` command. `break` ends the loop immediately, so no more loop code gets
    executed afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: We can also use `break` to stop looping through the array of cars when we have
    found a car that matches our demands.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'As soon as we run into a car with the year 2020 or later and the car is black,
    we will stop looking for other cars and just buy that one. The last car in the
    array would also have been an option, but we did not even consider it because
    we found one already. The code snippet will output this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: However, often it is not a best practice to use `break`. If you can manage to
    work with the condition of the loop to break out of the loop instead, this is
    a much better practice. It prevents you getting stuck in an infinite loop, and
    the code is easier to read.
  prefs: []
  type: TYPE_NORMAL
- en: If the condition of the loop is not an actual condition, but pretty much a run-forever
    kind of statement, the code gets hard to read.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be better to write without `break` and without something terrible
    like `while(true)`; you could do it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: With the second example, we can see the conditions of the loop easily, namely
    the length of the array and a `notFound` flag. However, with `while(true)` we
    are kind of misusing the while concept. You want to specify the condition, and
    it should evaluate to `true` or `false`; this way your code is nice to read. If
    you say `while(true)`, you're actually saying forever, and the reader of your
    code will have to interpret it line by line to see what is going on and when the
    loop is ended by a workaround `break` statement.
  prefs: []
  type: TYPE_NORMAL
- en: continue
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`break` can be used to quit the loop, and **continue** can be used to move
    on to the next iteration of the loop. It quits the current iteration and moves
    back up to check the condition and start a new iteration.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here you can see an example of `continue`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: 'The approach here is to just skip every car that is not black and consider
    all the others that are not older than make year 2020 or later. The code will
    output this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Be careful with `continue` in a `while` loop. Without running it, what do you
    think the next code snippet does?
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'It logs `1`, and then it gets you stuck in an infinite loop, because `continue`
    gets hit before the value of `i` changes, so it will run into `continue` again,
    and again, and so on. This can be fixed by moving the `i++` up and subtracting
    1 from `i`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'But again, there is a better way without `continue` here. The chance of error
    is a lot smaller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: And as you can see it is even shorter and more readable. The value of `break`
    and `continue` usually comes in when you are looping over large data sets, possibly
    coming from outside your application. Here you'll have less influence to apply
    other types of control. Using `break` and `continue` is not a best practice for
    simple basic examples, but it's a great way to get familiar with the concepts.
  prefs: []
  type: TYPE_NORMAL
- en: Practice exercise 5.8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This exercise will demonstrate how to create a string with all the digits as
    it loops through them. We can also set a value to skip by adding a condition that
    will use `continue`, skipping the matching condition. A second option is to do
    the same exercise and use the `break` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Set up a string variable to use as output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select a number to skip, and set that number as a variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `for` loop that counts to 10.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a condition to check if the value of the looped variable is equal to the
    number that should be skipped.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the number is to be skipped in the condition, `continue` to the next number.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As you iterate through the values, append the new count value to the end of
    the main output variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Output the main variable after the loop completes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reuse the code, but change the `continue` to `break` and see the difference.
    It should now stop at the skip value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: break, continue, and nested loops
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`break` and `continue` can be used in nested loops as well, but it is important
    to know that when `break` or `continue` is used in a nested loop, the outer loop
    will not break.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use this array of arrays to discuss `break` and `continue` in nested
    loops:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Let's break down this example. We are looking for all the groups that have two
    names starting with an `M`. If we find such a group, we will log it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: We first loop over the top-level arrays and set a counter, `matches`, with a
    start value of `0`, and for each of these top-level arrays, we are going to loop
    over the values. When a value starts with an M, we increase `matches` by one and
    check whether we have found two matches already. If we find two Ms, we break out
    of the inner loop and continue in our outer loop. This one will move on to the
    next top-level array, since nothing is happening after the inner loop.
  prefs: []
  type: TYPE_NORMAL
- en: If the name does not start with an M, we do not need to check for `matches`
    being `2`, and we can continue to the next value in the inner array.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at this example: what do you think it will log?'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: It will loop over the arrays, and for every array it will check the value to
    see if it starts with an M. If it does, the inner loop will break. So, if one
    of the arrays in the array contains multiple values starting with M, only the
    first one will be found, since the iteration over that array breaks and we continue
    to the next array.
  prefs: []
  type: TYPE_NORMAL
- en: 'This one will output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: We can see that it finds Margot, the first one from the second array, but it
    skips Marina, because it is the second one in the array. And it breaks after having
    found one group, so it won't loop over the other elements in the inner array.
    It will continue with the next array, which doesn't contain names starting with
    an M.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: If we want to see whether only one of all the names in the array of arrays starts
    with an M, we would have to break out of the outer loop. This is something we
    can do with labeled loops.
  prefs: []
  type: TYPE_NORMAL
- en: break and continue and labeled blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can break out of the outer loop from inside the inner loop, but only if
    we give a label to our loop. This can be done like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We are giving our block a label by putting a word and a colon in front of a
    code block. These words can be pretty much anything (in our case, "outer" and
    "inner"), but not JavaScript's own reserved words, such as `for`, `if`, `break`,
    `else`, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'This will only log the first name starting with an `M`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: It will only log one, because it is breaking out of the outer loop and all the
    loops end as soon as they find one. In a similar fashion you can continue the
    outer loop as well.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you want to be done as soon as you find one hit, this is the option
    to use. So, for example, if you want check for errors and quit if there aren't
    any, this would be the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: Chapter project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Math multiplication table
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this project, you will create a math multiplication table using loops. You
    can do this using your own creativity or by following some of the following suggested
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Set up a blank array to contain the final multiplication table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set a `value` variable to specify how many values you want to multiply with
    one another and show the results for.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an outer `for` loop to iterate through each row and a `temp` array to
    store the row values. Each row will be an array of cells that will be nested into
    the final table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an inner `for` loop for the column values, which will push the multiplied
    row and column values to the `temp` array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the temporary row data that contains the calculated solutions to the main
    array of the final table. The final result will add a row of values for the calculations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Self-check quiz
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the expected output for the following code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What is the final value for `myArray`, and what is expected in the console?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter we introduced the concept of loops. Loops enable us to repeat
    a certain block of code. We need some sort of condition when we loop, and as long
    as that condition is true, we'll keep looping. As soon as it changes to false,
    we end our loop.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen the `while` loop, in which we just insert a condition, and as long
    as that condition is true we keep looping. If the condition is never true, we
    won't even execute the loop code once.
  prefs: []
  type: TYPE_NORMAL
- en: This is different for the `do while` loop. We always execute the code once,
    and then we start to check a condition. If this condition is true, we execute
    the code again and do so until the condition becomes false. This can be useful
    when working with input from outside, such as user input. We would need to request
    it once, and then we can keep on requesting it again until it is valid.
  prefs: []
  type: TYPE_NORMAL
- en: Then we saw the `for` loop, which has a slightly different syntax. We have to
    specify a variable, check a condition (preferably using that variable, but this
    is not mandatory), and then specify an action to be executed after every iteration.
    Again, it's preferable for the action to include the variable from the first part
    of the `for` loop. This gives us code that is to be executed as long as a condition
    is true.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also saw two ways to loop over arrays and objects, `for in` and `for of`.
    The `for in` loop loops over keys and `for of` loops over values. They go over
    every element in a collection. The advantage of these loops is that JavaScript
    controls the execution: you can''t miss an element or get stuck in an infinite
    loop.'
  prefs: []
  type: TYPE_NORMAL
- en: Lastly, we saw `break` and `continue`. We can use the `break` keyword to end
    a loop immediately and the `continue` keyword to end the current iteration and
    go back to the top and start the next iteration, if the condition is still true,
    that is.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next chapter we are going to be adding a really powerful tool to our
    JavaScript toolbox: functions! They allow us to take our coding skills to the
    next level and structure our code better.'
  prefs: []
  type: TYPE_NORMAL
