- en: Chapter 7. Working with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Database queries are also written directly with Opa. Opa currently (Opa 1.1.1)
    supports the NoSQL databases MongoDB and CouchDB as well as the SQL database Postgres.
    Postgres is still a work in progress and more databases are planned for future
    releases. Opa provides many unique advanced operators and automates the database
    queries for maximal productivity. In this chapter, we will talk briefly about
    how to work with MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: A quick start to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we need to download ([http://www.mongodb.org/downloads](http://www.mongodb.org/downloads)),
    install, and run ([http://docs.mongodb.org/manual/installation/](http://docs.mongodb.org/manual/installation/))
    the MongoDB server. After MongoDB has been installed properly, let''s get started
    with a simple example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the first line of the preceding code, we define a `/counter` database path
    that holds an integer. A database path describes a position in the database, and
    we can read, write, update, and delete the data through a database path. Note
    that the data type of the path cannot be omitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding database is unnamed; we can give a name to the database, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In this way, we should read data from the path `/testdb/counter`. Now, let''s
    compile and run the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'When the application starts, it will try to launch the MongoDB server if the
    server is not already running, and it will store data on the default location
    `~/.opa/mongo/data`. If the server is already running, the application will try
    to connect to the server. However, we can also use the options `--db-local` and
    `--db-remote` to let the program connect to specific databases as we want:'
  prefs: []
  type: TYPE_NORMAL
- en: '`--db-local:dbname [/path/to/db]`: This uses a local database stored at the
    specified location in the file-system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`--db-remote:dbname [username:password@]hostname[:port]`: This uses a remote
    database accessible at a given remote location'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Database manipulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can manipulate data through database paths. The following piece of code
    declares a `testdb` database and defines several paths:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Type student that we defined ourselves. In addition to this type, our example
    covers the datatypes that are most frequently used in databases.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each database path has a default value. Whenever we attempt to read a value
    that does not exist (either because it was never initialized or it has been removed),
    the default value is returned. The following list shows the default values for
    different types:'
  prefs: []
  type: TYPE_NORMAL
- en: The default value for an integer (int) is 0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value for a floating-point number (float) is 0.0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value for a string is ""
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value for a record is the record of default values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The default value for a sum type is the value that best resembles the empty
    case (for example, {none} for option, {nil} for list, and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can define an application-specific default value by assigning a value when
    we declare a path, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To read data from the database, just use a database path, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can prefix the path with a question mark (`?`) then give the path a value
    that is one of two options, whereby `{some: x}` indicates that the value of that
    path is `x`, and `{none}` indicates that the path has not been written to yet,
    for instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example prints **unknown** if the path `/testdb/basic/i` has not
    been written to yet or has been removed, otherwise it prints the value of the
    path.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write or update the database path, use a operator `=`. We can also use `<-`
    to assign the value, it''s the same as `=`. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'To delete data held at a path, use the `Db.remove(@path)` function, where `@path`
    is a reference to a path. We can get a path reference by adding an `@` sign before
    the path, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Records
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With records, we can do complete reads and updates in the same manner as for
    basic types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, we need to enforce that the record should be modified only as a
    whole. This is known as **full modification**. If a record is declared as being
    subject to full modification, we must update all fields at once when performing
    modifications. We add the `full` keyword after a database path in order to indicate
    that this path is subject to full modification. If a given path has not been declared
    for full modification, we can cross record boundaries and access or update only
    chosen fields by including them in the path. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We declared `/stu2` for full modification by adding the `/stu2 full` statement.
    Therefore, the compiler reported an error for the last line (`/testdb/stu2/name
    = "Li"`) of the preceding code, in which we tried modifying a single field of
    the record, namely the `name` field.
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned in the *Lists* section of [Chapter 2](ch02.html "Chapter 2. Basic
    Syntax"), *Basic Syntax*, lists in Opa are just recursive records. We can manipulate
    lists in the same manner as records. However, as the datatype list is used frequently,
    Opa provides shortcuts that are specific to lists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Sets and maps
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can update sets and maps in the same way as lists, however, the way we access
    the elements is different. We can fetch a single value from a given set or map
    by referencing it by its primary key, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can query a set of values by adding the query condition inside
    the square bracket, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will look at queries in more detail in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Querying data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we mentioned in the previous section, database sets and maps are two types
    of collections that allows the organization of multiple instances of data in the
    database. We can query a set of values using the following operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can specify some querying options as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`skip n`: Here `expr` should be an expression of type `int` and it skip the
    first *n* results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`limit n`: Here `expr` should be an expression of type `int`, returns a maximum
    of *n* results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`order fld (, fld)+`: Here `fld` specifies an order. `fld` can be a single
    identifier or a list of identifiers specifying the fields on which the ordering
    should be based. Identifiers can optionally be prefixed with `+` or `-` to specify
    the ascending or descending order. Finally, it is possible to choose the order
    dynamically with `<ident>=<expr>`, where `<expr>` should be of type `{up}` or
    `{down}`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following piece of code gets the next 50 results for students whose age
    is above 20 and below 45, and they will be ordered by age (ascending) first and
    then ordered by `id` (descending):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create even more complicated query conditions by combining query expressions
    together. The query operation returns a `dbset`. A `dbset` is a collection that
    holds the query result. Therefore, we can iterate over the `dbset`. Consider the
    following code fragment. It queries all students whose name is `Li` and prints
    them out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we toured the basic techniques of working with databases. We
    first gave a very simple example. Then, we discussed how to manipulate data, including
    retrieving data from databases, writing or updating data, and removing data. We
    covered both basic types and complex types such as record, list, map, and set.
    Finally, we talked about how to query data from sets and maps.
  prefs: []
  type: TYPE_NORMAL
