- en: Chapter 9. Persisting Data
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第九章. 持久化数据
- en: Most applications need to persist some kind of data. In this chapter, we'll
    be looking at some approaches to data persistence for Node.js applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数应用程序都需要持久化某种类型的数据。在本章中，我们将探讨Node.js应用程序的数据持久化的一些方法。
- en: The default choice for persistence for a long time has been the traditional
    relational database. You may have used **RDBMS**s (relational database management
    systems) such as Microsoft SQL Server, Oracle, MySQL or PostgreSQL. These systems
    are often categorized as *SQL databases* since they all use SQL as their primary
    query language.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在很长一段时间内，持久化的默认选择一直是传统的数据库。你可能使用过**RDBMS**（关系型数据库管理系统），例如Microsoft SQL Server、Oracle、MySQL或PostgreSQL。这些系统通常被归类为*SQL数据库*，因为它们都使用SQL作为它们的查询语言。
- en: More recently, there has been a proliferation of so-called **NoSQL** databases.
    This umbrella term isn't particularly useful as a category. Some NoSQL databases
    have no more in common with each other than with traditional relational databases.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，所谓的**NoSQL**数据库的数量激增。这个总称作为分类并不特别有用。一些NoSQL数据库与传统的关系型数据库没有更多的共同之处。
- en: What's interesting is the range of databases available and the use cases they
    fulfil. Traditional RDBMSs are as powerful and flexible as ever and the right
    choice for many situations. In this chapter, we'll consider two other types of
    database, along with how and when to make use of them.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最有趣的是可用的数据库范围以及它们所满足的使用案例。传统的RDBMS（关系型数据库管理系统）依然强大且灵活，是许多情况下的正确选择。在本章中，我们将考虑其他两种类型的数据库，以及如何和何时使用它们。
- en: The systems we'll be looking at are **MongoDB** and **Redis**. Both of these
    had their initial release in 2009 and are now widely-used. Covering either of
    them in depth would justify a book in itself. The aim of this chapter is to provide
    an introduction to and high-level overview of each.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要探讨的系统是**MongoDB**和**Redis**。这两个系统都于2009年首次发布，现在被广泛使用。深入探讨其中的任何一个都足以写成一本书。本章的目标是提供一个对每个系统的介绍和高级概述。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The conceptual data model used by each of these systems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些系统使用的概念数据模型
- en: The use cases for which they provide the most benefit
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们提供最大利益的用例
- en: Integrating them with an Express application
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将它们与Express应用程序集成
- en: Testing data persistence code
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 测试数据持久化代码
- en: Introducing MongoDB
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍MongoDB
- en: MongoDB is a **document-oriented** DBMS. MongoDB documents are stored as **binary
    JSON** (**BSON**). This is similar to JSON, but with support for additional data
    types. JSON field values can only be strings, numbers, objects, arrays, Booleans,
    or null. BSON supports more specific numeric types, dates and timestamps, regular
    expressions, and binary data. As the name suggests, BSON documents are stored
    and transferred as binary data. This can be more efficient than JSON's string
    representation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB是一个**面向文档**的DBMS。MongoDB文档以**二进制JSON**（**BSON**）的形式存储。这类似于JSON，但支持更多的数据类型。JSON字段值只能是字符串、数字、对象、数组、布尔值或null。BSON支持更具体的数值类型、日期和时间戳、正则表达式和二进制数据。正如其名所示，BSON文档以二进制数据的形式存储和传输。这比JSON的字符串表示可能更高效。
- en: 'MongoDB documents are stored in **collections**. These work very much like
    tables in a traditional relational database. Documents can be inserted, updated,
    and queried. There are two key differences from a traditional relational database:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB文档存储在**集合**中。它们在传统的关系型数据库中的工作方式非常相似。文档可以被插入、更新和查询。与传统的关系型数据库有两个关键的区别：
- en: MongoDB does not support server-side joins. In a traditional RDBMS, you would
    normalize data into multiple tables and join across them using foreign keys. In
    MongoDB, you instead use BSON's nested structure to denormalize data about each
    entity into a single document.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MongoDB不支持服务器端连接。在传统的RDBMS中，你会将数据规范化到多个表中，并通过外键在它们之间进行连接。在MongoDB中，你相反地使用BSON的嵌套结构将每个实体的数据非规范化到一个单独的文档中。
- en: The *relational* property of a relational database is that all rows in a table
    contain the same fields with the same meaning. In MongoDB, documents can have
    any set of fields.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关系型数据库的*关系*属性是表中的所有行都包含相同字段，且具有相同的意义。在MongoDB中，文档可以拥有任何一组字段。
- en: In practice, documents in the same collection typically have the same fields
    or at least a common core set of fields. MongoDB supports the creation of indexes
    on common fields in a collection to make querying more efficient.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，同一集合中的文档通常具有相同的字段，或者至少有一个共同的字段集。MongoDB支持在集合的常用字段上创建索引，以提高查询效率。
- en: Why choose MongoDB?
  id: totrans-17
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么选择MongoDB？
- en: There are several properties of MongoDB that make it an appealing choice for
    some use cases, especially in Node.js-based applications. We'll cover these in
    this section.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB有一些特性使其在某些用例中具有吸引力，尤其是在基于Node.js的应用程序中。我们将在本节中介绍这些内容。
- en: Object modeling
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象建模
- en: MongoDB's document-based approach can be a good fit for persisting domain entities.
    You may have experience of storing domain entities in a relational database using
    an **Object-Relational Mapper** (**ORM**). Hibernate and Entity Framework are
    popular examples of ORMs. One of the jobs performed by an ORM is mapping a single
    entity to multiple tables in a normalized schema. When an entity is loaded from
    the database, it is reconstructed via `JOIN` queries between these tables. This
    is one of the key features of ORMs. It is also one of the most common sources
    of configuration problems and performance issues when using an ORM. MongoDB persists
    each entity as a single document, which can be much simpler.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的基于文档的方法非常适合持久化领域实体。你可能有过在关系型数据库中使用**对象关系映射器**（**ORM**）存储领域实体的经验。Hibernate和Entity
    Framework是ORM的流行例子。ORM执行的一项工作是将单个实体映射到规范化模式中的多个表。当实体从数据库加载时，它通过这些表之间的`JOIN`查询重建。这是ORM的关键特性之一。这也是使用ORM时配置问题和性能问题最常见的原因之一。MongoDB将每个实体持久化为单个文档，这可以简单得多。
- en: Of course, cross-table joins can also be useful for traversing relationships
    between entities. While ORMs typically make this easy, this can itself be a source
    of performance problems. Implicit loading of related entities often causes *N+1*
    problems, issuing thousands of DB queries. Handling these relationships well requires
    careful thought, whatever kind of database you are using.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，跨表连接也可以用于遍历实体之间的关系。虽然ORM通常使这变得容易，但这本身也可能成为性能问题的来源。相关实体的隐式加载经常导致*N+1*问题，发出数千个数据库查询。无论使用哪种类型的数据库，妥善处理这些关系都需要仔细思考。
- en: When using an ORM and an RDBMS, all inter-entity relationships are foreign keys,
    but you need to think carefully about how to load them. When modeling data in
    MongoDB, you must choose between embedded documents or document references for
    inter-entity relationships. Under either tech stack, the design decisions depend
    on the data access requirements of your application and designing the data model
    to reduce the prevalence of inter-entity relationships will simplify matters.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用ORM和RDBMS时，所有实体间的关系都是外键，但你需要仔细考虑如何加载它们。在MongoDB中建模数据时，你必须选择嵌入文档或文档引用来表示实体间的关系。在任一技术栈下，设计决策取决于应用程序的数据访问需求，以及设计数据模型以减少实体间关系的普遍性将简化问题。
- en: JavaScript
  id: totrans-23
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: JavaScript
- en: MongoDB is a good fit for Node.js in particular. The use of a JSON-like format
    maps well to a JavaScript-based programming environment. MongoDB itself also runs
    JavaScript natively. Database operations can make use of custom JavaScript functions
    that execute on the server.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB特别适合Node.js。JSON-like格式的使用很好地映射到基于JavaScript的编程环境。MongoDB本身也原生支持JavaScript。数据库操作可以利用在服务器上执行的定制JavaScript函数。
- en: Scalability
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可扩展性
- en: MongoDB also scales in a similar manner to Node.js. It uses partitioning and
    replication to support horizontal scaling on commodity hardware. There is no technical
    reason why your application and database have to scale in the same way, but it
    may be easier to plan for scalability from a business perspective.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB的扩展方式与Node.js类似。它使用分区和复制来支持在通用硬件上的水平扩展。没有技术原因要求你的应用程序和数据库必须以相同的方式扩展，但从业务角度来看，这可能更容易规划可扩展性。
- en: When using an RDBMS, it is more straightforward to scale the database vertically.
    That means provisioning a high-powered database server that can support multiple
    application servers. This requires more careful planning and more up-front investment
    than linearly scaling application and database servers horizontally together.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用RDBMS时，垂直扩展数据库更为直接。这意味着提供一台高性能的数据库服务器，它可以支持多个应用程序服务器。这比水平扩展应用程序和数据库服务器需要更仔细的计划和更多的前期投资。
- en: Getting started with MongoDB
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用MongoDB
- en: Visit [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)
    to download and install the latest version of the MongoDB Community Server edition
    for your operating system. There are more detailed installation instructions in
    the user manual at [https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 访问 [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads) 下载并安装适用于您操作系统的最新版本的MongoDB社区服务器版。用户手册中有更详细的安装说明，请参阅
    [https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/)。
- en: The commands in the rest of this section make use of executables in MongoDB's
    `/bin` directory. You can run the commands in this directory or, better still,
    add it to your `PATH`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 本节余下的命令使用了MongoDB `/bin` 目录中的可执行文件。您可以在该目录中运行这些命令，或者更好的做法是将它添加到您的 `PATH`。
- en: 'Create a directory for MongoDB to store its data. Then start the MongoDB daemon
    process (that is, service), providing the path of that directory as follows:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 为MongoDB创建一个目录以存储其数据。然后启动MongoDB守护进程（即服务），如下提供该目录的路径：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Using the MongoDB shell
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用MongoDB shell
- en: 'You can interact with MongoDB from the console using its built-in shell application.
    You can launch the MongoDB shell by running the `mongo` command, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以使用MongoDB的内置shell应用程序从控制台与MongoDB交互。您可以通过运行 `mongo` 命令来启动MongoDB shell，如下所示：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will connect to a database named `demo` (creating it, if necessary) on
    the local server. If you don't specify a database, then the shell connects to
    a database named `test`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这将连接到本地服务器上名为 `demo` 的数据库（如果需要则创建它）。如果您没有指定数据库，则shell将连接到名为 `test` 的数据库。
- en: The first thing to notice is that the shell is just another JavaScript environment.
    We can try running some of the same commands as at the beginning of [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Getting Started with Node.js"), *Getting Started with Node.js*.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，shell只是另一个JavaScript环境。我们可以尝试运行与[第2章](part0018.xhtml#aid-H5A41 "第2章。Node.js入门")开头相同的某些命令，*Node.js入门*。
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Just as Node.js builds on JavaScript in ways that make it more suitable for
    server-side application development, MongoDB adds features more useful to data
    persistence. Note that `new Date()` in the preceding code returns an ISODate,
    MongoDB's standard datatype for representing dates in BSON documents.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 正如Node.js通过在服务器端应用程序开发中构建在JavaScript之上，使其更适合服务器端应用程序开发一样，MongoDB添加了更多对数据持久性有用的功能。请注意，前面代码中的
    `new Date()` 返回一个ISODate，这是MongoDB在BSON文档中表示日期的标准数据类型。
- en: You can quit the console by typing `exit` at any time.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以随时通过输入 `exit` 来退出控制台。
- en: 'MongoDB also adds some new global variables for interacting with the database.
    The most important of these is the `db` object. Let''s try adding some documents
    to our database. Recall that MongoDB stores documents in collections. To create
    a new collection, we just need to start inserting documents into it. For a simple
    example, we''ll use the UK bank holidays for 2016\. We can populate this collection
    using the following script:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB还添加了一些新的全局变量，用于与数据库交互。其中最重要的是 `db` 对象。让我们尝试向我们的数据库添加一些文档。回想一下，MongoDB将文档存储在集合中。要创建一个新的集合，我们只需要开始向其中插入文档。作为一个简单的例子，我们将使用2016年的英国银行假日。我们可以使用以下脚本填充这个集合：
- en: '[PRE3]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that Christmas Day falls on a Sunday in 2016, so the bank holiday occurs
    on the next working day. This gives us a reason to have another field that is
    only relevant to some documents in the collection.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，2016年的圣诞节在星期日，因此银行假日发生在下一个工作日。这给了我们一个理由来有一个只与集合中某些文档相关的字段。
- en: 'You could type these `insert` commands into the console manually, but it''s
    easier to tell MongoDB to load them from a script file:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以将这些 `insert` 命令手动输入到控制台中，但告诉MongoDB从脚本文件中加载它们会更简单：
- en: '[PRE4]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The previous command connects to a database named demo, runs the `holiday.js`
    script (available in the book''s companion code), then opens a shell to allow
    us to interact with the database. We can view the complete contents of the collection
    by running the following command in the MongoDB console:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的命令连接到名为demo的数据库，运行了（书中配套代码中的）`holiday.js` 脚本，然后打开一个shell以允许我们与数据库交互。我们可以在MongoDB控制台中运行以下命令来查看集合的完整内容：
- en: '[PRE5]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note that MongoDB has automatically added an `_id` field to each document for
    us.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，MongoDB已经为我们自动在每个文档中添加了一个 `_id` 字段。
- en: Tip
  id: totrans-49
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can see how MongoDB does this by viewing the source of the `insert` method.
    Just type `db.holidays.insert` into the shell (with no parentheses).
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过查看 `insert` 方法的源代码来了解MongoDB是如何做到这一点的。只需在shell中输入 `db.holidays.insert`（不带括号）即可。
- en: 'We can pull out records by their `_id` or other single fields:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过 `_id` 或其他单个字段提取记录：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This will return any objects that match the object passed to `find`. To look
    up documents by something other than exact equality, we can use MongoDB''s query
    operators. These are prefixed with the dollar symbol and specified as object properties.
    For example, to find holidays in the second half of the year, we can use the *greater
    than or equal to* operator as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将返回与传递给 `find` 的对象匹配的所有对象。要按除精确相等之外的其他方式查找文档，我们可以使用 MongoDB 的查询运算符。这些运算符以美元符号为前缀，并指定为对象属性。例如，要查找下半年的假日，我们可以使用如下所示的
    *大于等于* 运算符：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'MongoDB''s **aggregation pipeline** allows us to build complex queries from
    a sequence of operations called **pipeline stages**. It is the closest thing in
    MongoDB to complex querying in SQL. Here, we count the number of bank holidays
    in each month using MongoDB''s `$group` pipeline stage, which is similar to SQL''s
    `GROUP BY` clause:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 的 **聚合管道** 允许我们通过一系列称为 **管道阶段** 的操作构建复杂的查询。这是 MongoDB 中与 SQL 中的复杂查询最接近的东西。在这里，我们使用
    MongoDB 的 `$group` 管道阶段来计算每个月的银行假日数量，这与 SQL 的 `GROUP BY` 子句类似：
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'An odd quirk of the calendar in 2016 means that the Christmas Day Bank Holiday
    actually comes after Boxing Day (since Christmas Day itself is on a Sunday). In
    the following example, we order bank holidays by the date of the occasion that
    they mark (stored in the `$substitute_for` field if different from the date of
    the bank holiday):'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 2016 年日历的一个奇怪特性意味着圣诞节银行假日实际上是在节礼日之后（因为圣诞节本身是在星期日）。在以下示例中，我们按标记的节日日期（如果与银行假日日期不同，则存储在
    `$substitute_for` 字段中）对银行假日进行排序：
- en: '[PRE9]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The previous pipeline consists of two stages:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的管道由两个阶段组成：
- en: The `$project` stage specifies a set of fields based on the underlying data
    (similar to `SELECT` in SQL). Note that the `_id` field is included by default,
    but we exclude it here.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$project` 阶段指定一组基于底层数据的字段（类似于 SQL 中的 `SELECT`）。请注意，`_id` 字段默认包含在内，但在这里我们将其排除。'
- en: The `$sort` stage specifies a sort field and direction (similar to SQL's `SORT
    BY` clause). The `1` here indicates an ascending sort order.
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$sort` 阶段指定一个排序字段和方向（类似于 SQL 的 `SORT BY` 子句）。这里的 `1` 表示升序排序。'
- en: We have just scratched the surface here. There are many more pipeline phases
    available in MongoDB. You can find out more about aggregation in the MongoDB documentation
    at [https://docs.mongodb.com/manual/core/aggregation-pipeline/](https://docs.mongodb.com/manual/core/aggregation-pipeline/).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里只是触及了表面。MongoDB 中还有许多其他管道阶段可用。您可以在 MongoDB 文档中了解更多关于聚合的信息，请参阅 [https://docs.mongodb.com/manual/core/aggregation-pipeline/](https://docs.mongodb.com/manual/core/aggregation-pipeline/)。
- en: MongoDB also has a built-in Map-Reduce function for powerful aggregate data
    processing using arbitrary JavaScript functions. This is beyond the scope of this
    book, but you can find out more about Map-Reduce and MongoDB's implementation
    of it at [https://docs.mongodb.com/manual/core/map-reduce/](https://docs.mongodb.com/manual/core/map-reduce/).
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: MongoDB 还有一个内置的 Map-Reduce 函数，用于使用任意 JavaScript 函数进行强大的聚合数据处理。这超出了本书的范围，但您可以在
    [https://docs.mongodb.com/manual/core/map-reduce/](https://docs.mongodb.com/manual/core/map-reduce/)
    中了解更多关于 Map-Reduce 和 MongoDB 对其的实现。
- en: Using MongoDB with Express
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MongoDB 与 Express
- en: The games service module in our application currently stores all its data in
    memory. This worked well enough for demo purposes, but isn't suitable for a real
    application. We lose all the data whenever the application restarts. It also prevents
    us from scaling our application across multiple processes. Each instance would
    have its own game service with different data. Users would see different data
    depending on which server happened to handle their request.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应用程序中的游戏服务模块目前将其所有数据存储在内存中。这对于演示目的来说已经足够好了，但并不适合实际应用。每次应用程序重启时，我们都会丢失所有数据。这也阻止了我们跨多个进程扩展应用程序。每个实例都会有自己的游戏服务，具有不同的数据。用户会看到不同的数据，这取决于哪个服务器恰好处理了他们的请求。
- en: We're going to update our games service to store its data in MongoDB. For this,
    we're going to make use of a library called **Mongoose**.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将更新我们的游戏服务，以便将其数据存储在 MongoDB 中。为此，我们将使用一个名为 **Mongoose** 的库。
- en: Persisting objects with Mongoose
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Mongoose 持久化对象
- en: Recall that, unlike a relational database, MongoDB does not require documents
    in the same collection to have the same fields. However, we do typically expect
    most items within a collection to share at least a common core of fields.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，与关系型数据库不同，MongoDB 不要求同一集合中的文档具有相同的字段。然而，我们通常期望集合中的大多数项目至少共享一个共同的字段核心。
- en: Mongoose is an object modeling library for storing entities in MongoDB. It helps
    with writing common functionality such as validation, query building, and type
    casting. It also provides hooks for associating business logic with our entities.
    These are similar to some of the features provided by ORMs such as Entity Framework
    or Hibernate. Mongoose itself is not an ORM, though. Recall that object-relational
    mapping is not relevant for document-oriented databases such as MongoDB.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose是一个用于在MongoDB中存储实体的对象建模库。它帮助编写常见的功能，如验证、查询构建和类型转换。它还提供了将业务逻辑与我们的实体关联的钩子。这些功能与ORM（如Entity
    Framework或Hibernate）提供的一些功能类似。然而，Mongoose本身不是一个ORM。回想一下，对象关系映射对于文档数据库（如MongoDB）来说是不相关的。
- en: 'To use Mongoose, we start by defining a **schema**. This defines the common
    fields for documents within a MongoDB collection. Returning to our demo application
    from the preceding chapters, let''s install Mongoose and define a schema for our
    games collection:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Mongoose，我们首先定义一个**模式**。这定义了MongoDB集合中文档的常见字段。回到前几章的演示应用程序，让我们安装Mongoose并为我们的游戏集合定义一个模式：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The following code is added to `src/services/games.js`:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码添加到`src/services/games.js`中：
- en: '[PRE11]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The schema defines document fields and specifies the type of each field. To
    start persisting documents with this schema, we need to create a **model**.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 模式定义了文档字段并指定了每个字段的类型。为了使用此模式开始持久化文档，我们需要创建一个**模型**。
- en: 'Models are constructors that correspond to a MongoDB collection. Instances
    of a Mongoose model correspond to documents in that collection. Models also provide
    functions for modifying the collection. We create a model by specifying the schema
    and (singular) collection name:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 模型是与MongoDB集合对应的构造函数。Mongoose模型的实例对应于该集合中的文档。模型还提供了修改集合的函数。我们通过指定模式和（单数）集合名称来创建模型：
- en: '[PRE12]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The Model constructor replaces our Game class and constructor from before.
    This class also contained two instance methods: `positionsOf` and `remove`. We
    can define custom instance methods on a schema, which will be available on all
    model instances. These must be defined before creating the model:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 模型构造函数替换了之前的游戏类及其构造函数。这个类还包含两个实例方法：`positionsOf`和`remove`。我们可以在模式上定义自定义实例方法，这些方法将在所有模型实例上可用。这些方法必须在创建模型之前定义：
- en: '[PRE13]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we use a traditional function definition rather than an arrow function
    in the preceding code. This is necessary in order for the `this` keyword inside
    the function to work correctly. See [http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/](http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/)
    for more details.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在前面的代码中，我们使用的是传统的函数定义，而不是箭头函数。这对于函数内部的`this`关键字正确工作来说是必要的。更多详情请见[http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/](http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/)。
- en: 'We don''t need to define a `remove` method anymore, because Mongoose provides
    this automatically. It also provides a `save` method, which we can use for persisting
    new games:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要定义`remove`方法，因为Mongoose会自动提供这个方法。它还提供了一个`save`方法，我们可以用它来持久化新的游戏：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We don't need to specify an ID anymore, since this is also provided by Mongoose.
    Note that we do need to specify `word.toUpperCase()`, which used to be in the
    Game constructor. This isn't a problem, since the constructor is private to our
    module. No code outside the module can invoke the constructor directly. Where
    the `toUpperCase` call takes place is just an implementation detail.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要指定ID，因为Mongoose也会提供这个ID。注意，我们确实需要指定`word.toUpperCase()`，这曾经位于游戏构造函数中。这不是问题，因为构造函数是模块私有的。模块外部的代码不能直接调用构造函数。`toUpperCase`调用发生的地方只是一个实现细节。
- en: 'Also note that Mongoose''s async operations all return promises as an alternative
    to using callbacks. Mongoose supports both of the asynchronous programming patterns
    discussed in the previous chapter. Mongoose uses its own implementation of promises.
    We can configure Mongoose to use ECMAScript 6 promises, though. We also need to
    tell Mongoose to connect to a MongoDB database. For now, we will hardcode the
    URL, but we''ll see how to make this configurable shortly:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，Mongoose的所有异步操作都返回承诺作为使用回调的替代方案。Mongoose支持前一章中讨论的两种异步编程模式。Mongoose使用自己的承诺实现。尽管如此，我们可以配置Mongoose使用ECMAScript
    6承诺。我们还需要告诉Mongoose连接到MongoDB数据库。目前，我们将硬编码URL，但我们将很快看到如何使其可配置：
- en: '[PRE15]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, we need to implement our three methods for retrieving games from the
    database. We can do this using Mongoose''s `find` method:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要实现从数据库检索游戏的三种方法。我们可以使用 Mongoose 的 `find` 方法来完成此操作：
- en: '[PRE16]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The Mongoose `find` method works like the MongoDB `find` method we saw in the
    previous section, *Using the MongoDB shell*. It takes a set of MongoDB query conditions
    and asynchronously provides a list of documents. `findById` takes an ID and asynchronously
    provides a single document, or null.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 的 `find` 方法与我们在上一节中在 *使用 MongoDB shell* 中看到的 MongoDB `find` 方法类似。它接受一组
    MongoDB 查询条件，并异步提供文档列表。`findById` 接受一个 ID 并异步提供一个单独的文档，或 null。
- en: 'Mongoose also provides a `where` method for building up conditions through
    function calls. The `availableTo` function can be rewritten as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: Mongoose 还提供了一个 `where` 方法，可以通过函数调用构建条件。`availableTo` 函数可以重写如下：
- en: '[PRE17]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: As long as you still have MongoDB running locally (as described in *Getting
    started with MongoDB* earlier in the chapter), you should now be able to run the
    application. Try stopping and restarting the application and notice that games
    are now persisted between restarts.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 只要您仍然在本地上运行 MongoDB（如本章前面在 *MongoDB 入门* 中所述），现在应该能够运行应用程序。尝试停止并重新启动应用程序，并注意游戏现在可以在重启之间持久化。
- en: Isolating persistence code
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 隔离持久化代码
- en: It's useful to integrate with a real database to make sure our persistence code
    is working. But it's not always appropriate for our tests to be dependent on an
    external MongoDB instance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 将代码与真实数据库集成以验证我们的持久化代码是否正常工作是有用的。但并非总是适合让我们的测试依赖于外部 MongoDB 实例。
- en: We want developers to be able to check out the code and run the application
    without needing to run a database instance. Also, external dependencies slow down
    our tests. MongoDB stores data on disk, so introduces additional I/O work into
    our tests.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望开发者能够检出代码并运行应用程序，而无需运行数据库实例。此外，外部依赖项会减慢我们的测试速度。MongoDB 在磁盘上存储数据，因此给我们的测试引入了额外的
    I/O 工作。
- en: The application should depend on an external database in production. In integration,
    we want to use a real database on the local server. On development machines, it
    would be better to use an in-memory database by default. So we need to be able
    to configure a database URL and fall back to an in-memory database in development
    environments.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序在生产中应依赖于外部数据库。在集成测试中，我们希望在本地服务器上使用真实数据库。在开发机器上，默认使用内存数据库会更好。因此，我们需要能够配置数据库
    URL，并在开发环境中回退到内存数据库。
- en: Finally, we need to initialize Mongoose before using it in our games service.
    This includes specifying the database URL and waiting for a connection to be established.
    This happens asynchronously, so can't be part of the games service module definition.
    We also don't want clients of the games service to have to pass in a Mongoose
    instance to each function call.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在使用我们的游戏服务之前初始化 Mongoose。这包括指定数据库 URL 并等待建立连接。这是异步发生的，因此不能成为游戏服务模块定义的一部分。我们也不想让游戏服务的客户端在每个函数调用中传递
    Mongoose 实例。
- en: We can address all of these issues by introducing dependency injection to our
    application. We'll pass in the game service as a dependency to the modules that
    need it and pass in Mongoose as a dependency to the games service.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在我们的应用程序中引入依赖注入，我们可以解决所有这些问题。我们将把游戏服务作为依赖项传递给需要它的模块，并将 Mongoose 作为依赖项传递给游戏服务。
- en: Tip
  id: totrans-98
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: This would also give us the option of writing unit tests for other modules that
    pass in a test double for the games service itself, so don't use MongoDB at all.
    In larger applications, this kind of test isolation is important for writing fast
    and maintainable tests.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这也将给我们提供为传递给游戏服务本身的测试双胞胎的模块编写单元测试的选项，因此不要使用 MongoDB。在更大的应用程序中，这种测试隔离对于编写快速且可维护的测试非常重要。
- en: Dependency injection in Node.js
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Node.js 中的依赖注入
- en: You may have used **dependency injection** (**DI**) frameworks such as Unity,
    Autofac, NInject, or Spring in .NET or Java. These provide features such as declarative
    configuration and auto wiring of dependencies. There are similar DI containers
    available for JavaScript. However, it is more common to pass around dependencies
    explicitly. JavaScript's module pattern makes this approach more natural than
    in other languages. We don't need to add a lot of fields and constructors/properties
    to set up dependencies. We can just wrap modules in an initialization function
    that takes dependencies as parameters.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经使用过 .NET 或 Java 中的 **依赖注入**（**DI**）框架，如 Unity、Autofac、NInject 或 Spring。这些框架提供了声明性配置和自动绑定依赖项的功能。JavaScript
    也有类似的 DI 容器。然而，在 JavaScript 中，显式传递依赖项更为常见。JavaScript 的模块模式使这种方法比其他语言更自然。我们不需要添加很多字段和构造函数/属性来设置依赖项。我们只需将模块包裹在一个初始化函数中，该函数接受依赖项作为参数。
- en: 'In our application, the `app` module will wire everything together. The application
    as a whole depends on the database. The games and index routes depend on the game
    service. To allow the routes to take a dependency on the game service, we just
    need to top and tail them with a function:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，`app` 模块将连接一切。整个应用程序依赖于数据库。游戏和索引路由依赖于游戏服务。为了允许路由依赖游戏服务，我们只需要用函数来首尾包裹它们：
- en: '[PRE18]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The games service itself is slightly more complicated. We previously added
    several functions to `module.exports`, so we need to put these on an object instead.
    However, this actually results in shorter code. Also, note that we only create
    the `Game` schema if it hasn''t already been defined, to defend against our exported
    function being called multiple times:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏服务本身稍微复杂一些。我们之前向`module.exports`添加了几个函数，所以我们需要将这些函数放在一个对象上。然而，这实际上使代码更短。此外，请注意，我们只在`Game`模式尚未定义的情况下创建它，以防止我们的导出函数被多次调用：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, the application itself depends on the database connection and wires
    up the other dependencies:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，应用程序本身依赖于数据库连接，并连接其他依赖项：
- en: '[PRE20]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Providing dependencies
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 提供依赖项
- en: We can specify the database URL in an environment variable. When this isn't
    present, our application will instead make use of an in-memory instance of MongoDB.
    This will be provided by a library called **Mockgoose**. We install this as a
    dev dependency, in case we forget to set our environment variable on a production
    server. We'll get an error rather than quietly using a non-persistent database.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在环境变量中指定数据库 URL。如果这个变量不存在，我们的应用程序将使用 MongoDB 的内存实例。这将由一个名为 **Mockgoose**
    的库提供。我们将它作为一个开发依赖项安装，以防我们在生产服务器上忘记设置环境变量。如果发生错误，我们将不会安静地使用非持久性数据库。
- en: '[PRE21]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We create a new module under `src/config/mongoose.js` to initialize Mongoose
    and return a promise that will be fulfilled when it has connected to the database:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`src/config/mongoose.js`下创建一个新的模块来初始化 Mongoose，并返回一个当它连接到数据库时将解决的承诺：
- en: '[PRE22]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now we just need to pass this into our application. The following is the code
    from `bin/www`:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们只需要将这个模块传递给我们的应用程序。以下是从`bin/www`的代码：
- en: '[PRE23]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'To allow our tests to run, we''ll also need to add new `before` functions to
    make use of this module. The following code is from `test/services/games.js`:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了允许我们的测试运行，我们还需要添加新的`before`函数来使用这个模块。以下代码来自`test/services/games.js`：
- en: '[PRE24]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code is from `test/routes/games.js`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自`test/routes/games.js`：
- en: '[PRE25]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We''ll also add a global teardown function to close the database connection
    after all tests have finished. This is just a Mocha `after` hook outside the context
    of any `describe` block. We add this in a new file under `test/global.js`:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还会添加一个全局清理函数，在所有测试完成后关闭数据库连接。这只是一个在任意`describe`块上下文之外的 Mocha `after` 钩子。我们在`test/global.js`下的一个新文件中添加这个函数：
- en: '[PRE26]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Finally, we need to update our `gulpfile.js`, to allow our integration tests
    to run with the new dependency:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新我们的`gulpfile.js`，以便我们的集成测试能够运行新的依赖项：
- en: '[PRE27]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: We can now run our application and tests on a local development machine without
    needing to have MongoDB running, or we can specify the `MONGO_DB` environment
    variable if and when we want to use a real MongoDB instance.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以在本地开发机器上运行我们的应用程序和测试，而无需运行 MongoDB，或者如果我们想使用真实的 MongoDB 实例，可以指定`MONGO_DB`环境变量。
- en: Running database integration tests on Travis CI
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 Travis CI 上运行数据库集成测试
- en: 'We do want to regularly integration test our application against a real MongoDB
    instance. Fortunately, Travis CI provides various data stores as part of its environment.
    We just need to tell it that our build requires MongoDB by adding it to our `travis.yml`
    file. We also need to set the `MONGODB_URL` environment variable for tests to
    be able to connect to the database:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实希望定期对我们的应用程序进行集成测试，以针对真实的MongoDB实例。幸运的是，Travis CI作为其环境的一部分提供了各种数据存储。我们只需要将其添加到我们的`travis.yml`文件中，告诉它我们的构建需要MongoDB。我们还需要设置`MONGODB_URL`环境变量，以便测试能够连接到数据库：
- en: '[PRE28]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now we can run our application as well as our unit and integration tests with
    a suitable MongoDB instance on development machines and on the CI server.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以使用适合开发机器和CI服务器的合适MongoDB实例来运行我们的应用程序以及单元和集成测试。
- en: Introducing Redis
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Redis
- en: Redis is often classified as a **key-value** data store. Redis describes itself
    as a data-structure store. It offers storage types similar to the basic data structures
    found in most programming languages.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: Redis通常被归类为**键值**数据存储。Redis将自己描述为数据结构存储。它提供了与大多数编程语言中找到的基本数据结构类似的数据存储类型。
- en: Why use Redis?
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用Redis？
- en: Redis operates entirely in memory, allowing it to be very fast. This, together
    with its key-value nature, makes it well-suited for use as a cache. It also supports
    publish/subscribe channels, which allows it to function as a message broker. We'll
    look at this further in [Chapter 10](part0058.xhtml#aid-1NA0K1 "Chapter 10. Creating
    Real-time Web Apps"), *Real-time Web Apps in Node.js*.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Redis完全在内存中运行，这使得它非常快。这一点，加上其键值特性，使其非常适合用作缓存。它还支持发布/订阅通道，这使得它可以作为一个消息代理。我们将在第10章[创建实时Web应用](part0058.xhtml#aid-1NA0K1
    "第10章。创建实时Web应用")中进一步探讨。
- en: More generally, Redis can be a useful backend to allow multiple Node.js processes
    to co-ordinate with one another. Node.js scales horizontally and most websites
    will run multiple Node.js processes. Many websites have "working" data that doesn't
    need to be persisted long term, but does need to be available quickly and consistently
    across all processes. Redis's in-memory nature and range of atomic operations
    make it very useful for this purpose.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 更普遍地，Redis可以作为有用的后端，允许多个Node.js进程相互协调。Node.js水平扩展，大多数网站都会运行多个Node.js进程。许多网站有“工作”数据，这些数据不需要长期持久化，但需要在所有进程中快速且一致地可用。Redis的内存特性和一系列原子操作使其非常适合这个用途。
- en: Redis is built more for speed than durability. There are various options to
    configure it, but all expect some amount of data loss in the event of an outage.
    This is a compromise of Redis working entirely in-memory for speed. It is possible
    to reduce data loss to no more than the last second of writes before an outage,
    without significantly compromising on speed. Redis can be configured to completely
    minimize data loss by syncing to disk after each operation. However, this has
    a more significant impact on performance and negates the advantages of Redis's
    in-memory nature.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: Redis更注重速度而不是持久性。有多种配置选项，但所有选项都预期在故障发生时会有一定程度的数据丢失。这是Redis为了速度而在内存中完全运行所做的妥协。可以通过在故障前不显著影响速度的情况下将数据丢失减少到最多一秒前的写入，来减少数据丢失。Redis可以通过在每次操作后同步到磁盘来完全最小化数据丢失，但这会对性能产生更大的影响，并抵消了Redis内存特性的优势。
- en: Installing Redis
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装Redis
- en: Source distributions of Redis are available from [http://redis.io/download](http://redis.io/download).
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: Redis的源代码分发可以从[http://redis.io/download](http://redis.io/download)获取。
- en: 'For Windows, it is more useful to download a pre-built binary. It is available
    as a signed package via NuGet and Chocolatey. If you have Chocolatey available,
    you can install Redis by running the following command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows系统，下载预构建的二进制文件更有用。它可以通过NuGet和Chocolatey作为签名包提供。如果你有Chocolatey，可以通过运行以下命令来安装Redis：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Alternatively, you can download an unsigned version of the installer from [https://github.com/MSOpenTech/redis/releases](https://github.com/MSOpenTech/redis/releases)
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你可以从[https://github.com/MSOpenTech/redis/releases](https://github.com/MSOpenTech/redis/releases)下载未签名的安装程序版本。
- en: Once installed, you can start Redis by running `redis-server`. In a separate
    window, run `redis-cli` to connect to the server and run commands.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，可以通过运行`redis-server`来启动Redis。在另一个窗口中，运行`redis-cli`以连接到服务器并运行命令。
- en: Using Redis as a key-value store
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将Redis用作键值存储
- en: Everything in Redis is stored against a key. Keys in Redis can be any binary
    data, but it's best to think of them as strings. Various types of value can be
    stored against each key.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: Redis中的所有内容都是针对键进行存储的。Redis中的键可以是任何二进制数据，但最好将它们视为字符串。各种类型的值可以存储在每个键下。
- en: 'Redis refers to simple scalar values as **Strings**. Redis also has special
    treatment for scalar integers. The following example sets and updates a key named
    `counter`:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Redis将简单的标量值称为**字符串**。Redis还对标量整数有特殊处理。以下示例设置和更新名为`counter`的键：
- en: '[PRE30]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This increment operation is atomic. Redis also supports setting values atomically.
    The following command will fail because the key already exists:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个增量操作是原子的。Redis还支持原子地设置值。以下命令将失败，因为键已经存在：
- en: '[PRE31]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: These features can help coordinating between servers. Redis also supports setting
    expiry times for keys. This makes it possible to offer caching behavior similar
    to memcache. Redis has even more flexibility, though, as we'll see in the next
    section.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能可以帮助服务器之间的协调。Redis还支持为键设置过期时间。这使得提供类似于memcache的缓存行为成为可能。然而，Redis的灵活性更大，我们将在下一节中看到。
- en: Storing structured data in Redis
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在Redis中存储结构化数据
- en: In addition to simple key-value pairs, Redis supports other more structured
    data types.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 除了简单的键值对之外，Redis还支持其他更结构化的数据类型。
- en: '**Lists** are ordered collections of values. They are stored as a linked list
    rather than as arrays. This makes adding/removing elements at the ends of the
    list efficient (at the cost of slower retrieval of items from the list by index),
    for example:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**列表**是有序的值集合。它们作为链表而不是数组存储。这使得在列表的末尾添加/删除元素效率更高（以牺牲通过索引检索列表项的速度为代价），例如：'
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Note that `lrange` takes start and end indices. Negative values count backwards
    from the end of the list, so `-1` refers to the last element. Being able to push/pop
    from either end of a list means that they can be used as stacks or queues, for
    example, for allowing processes to communicate in a producer-consumer arrangement.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`lrange`接受起始和结束索引。负值从列表的末尾开始计数，因此`-1`指的是最后一个元素。能够从列表的两端进行push/pop意味着它们可以用作栈或队列，例如，允许进程以生产者-消费者模式进行通信。
- en: '**Hashes** are a set of field-value pairs. These are not as rich as MongoDB
    documents, but allow us to associate some data together. For example, we could
    have implemented our game service using Redis:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '**哈希**是一组字段-值对。它们不如MongoDB文档丰富，但允许我们将一些数据关联在一起。例如，我们可以使用Redis实现我们的游戏服务：'
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note that the top-level key `game:2` here is just a convention. It can be useful
    for developers to namespace keys in this way, but Redis only understands them
    as strings.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里的顶级键`game:2`只是一个约定。对于开发者来说，以这种方式对键进行命名空间可能很有用，但Redis只将它们视为字符串。
- en: '**Sets** are unordered collections of values, for example:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '**集合**是无序的值集合，例如：'
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Sets support mathematical operations such as unions and intersections. They
    also support the retrieval (with optional atomic removal) of random elements.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 集合支持数学运算，如并集和交集。它们还支持检索（可选原子删除）随机元素。
- en: '**Sorted sets** are collections of values, each associated with a numerical
    score:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '**有序集合**是带有数值分数的值集合：'
- en: '[PRE35]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that the ranges are ordered smallest to largest by default. We request
    a reverse range above to get the element with the highest score first. Sorted
    sets are useful for implementing voting systems (as previously shown) or ranking
    systems.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，默认情况下，范围是有序的最小到最大。我们请求一个反向范围，以首先获取具有最高分数的元素。有序集合对于实现投票系统（如前所述）或排名系统很有用。
- en: Building a user ranking system with Redis
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Redis构建用户排名系统
- en: 'We want to be able to rank users based on how many games they have completed.
    We will create a user service, implemented in Redis, that provides the following
    functionality:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够根据用户完成的游戏数量来对用户进行排名。我们将创建一个用户服务，该服务在Redis中实现，并提供以下功能：
- en: Record when a user successfully completes a game
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录用户成功完成游戏的时间
- en: Return the top three users across the site
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回网站上的前三个用户
- en: Return the rank of a given user
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 返回指定用户的排名
- en: We will first add a feature to make the site a bit more user-friendly by allowing
    users to choose a screen name.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加一个功能，通过允许用户选择一个屏幕名来使网站更加用户友好。
- en: Using Redis from Node.js
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从Node.js使用Redis
- en: 'First, we''ll need to install a Node.js client library for Redis. We''ll also
    use the promise library Bluebird to convert the Redis client library to promises:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要安装一个用于Redis的Node.js客户端库。我们还将使用promise库Bluebird将Redis客户端库转换为promise：
- en: '[PRE36]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'First, we''ll create a module for configuring the Redis client as shown here
    in `src/config/redis.js`:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个模块来配置 Redis 客户端，如下所示在 `src/config/redis.js`：
- en: '[PRE37]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Now we can create a new user service with methods for getting and setting a
    username, in `src/services/users.js`:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以在 `src/services/users.js` 中创建一个新的用户服务，其中包含获取和设置用户名的方法：
- en: '[PRE38]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that the Redis client provides functions for each Redis command (such as
    `get` and `set`). Bluebird provides promise-based versions of each function suffixed
    with `Async`.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，Redis 客户端为每个 Redis 命令提供了函数（如 `get` 和 `set`）。Bluebird 提供了每个函数的基于 promise 的版本，后缀为
    `Async`。
- en: 'Of course, now that we have test infrastructure for our project, we should
    add tests for new code as we go as shown here `test/services/users.js`:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在我们为我们的项目有了测试基础设施，我们应该在编写新代码时添加测试，如下所示 `test/services/users.js`：
- en: '[PRE39]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Testing with redis-js
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 redis-js 进行测试
- en: 'As with the tests for our games service, we want to be able to integrate with
    a Redis instance on our CI server. But we don''t want to introduce any new dependencies
    for development. This time, we will make use of a library called redis-js for
    local testing. Unlike Mockgoose, this does not use an in-memory version of the
    real DB engine (Redis is already in-memory). This is instead a re-implementation
    of the Node.js Redis client that stores all of its data in-process:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们对游戏服务的测试一样，我们希望能够与 CI 服务器上的 Redis 实例集成。但我们不希望为开发引入任何新的依赖项。这次，我们将使用一个名为 redis-js
    的库进行本地测试。与 Mockgoose 不同，它不使用真实 DB 引擎的内存版本（Redis 已经是内存中的）。相反，这是一个 Node.js Redis
    客户端的重新实现，它将所有数据存储在进程内：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Now we can create a module for obtaining the environment-appropriate Redis
    reference as shown here `src/config/redis.js`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以创建一个模块来获取适合环境的 Redis 引用，如下所示 `src/config/redis.js`：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Note that, unlike Mongoose, the Node.js Redis client can be used immediately.
    Any commands issued before it has connected are actually queued up internally.
    This means we can just return the client from the module and require it directly.
    There wouldn't be any benefit in this case to the dependency injection we used
    with Mongoose.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与 Mongoose 不同，Node.js Redis 客户端可以立即使用。在它连接之前发出的任何命令实际上都是内部排队。这意味着我们只需从模块中返回客户端并直接
    require 它。在这种情况下使用 Mongoose 的依赖注入不会有任何好处。
- en: 'We also need to add Redis to our `.travis.yml` file so it runs on the CI server:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将 Redis 添加到我们的 `.travis.yml` 文件中，以便它在 CI 服务器上运行：
- en: '[PRE42]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Finally, we need to close the client once our tests have completed, as we did
    with Mongoose. We also ensure we empty the database on startup (as we don''t have
    a way of deleting user data via the service interface, as we do with games). The
    following code is from `test/global.js`:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，一旦我们的测试完成，我们需要关闭客户端，就像我们使用 Mongoose 一样。我们还确保在启动时清空数据库（因为我们没有通过服务接口删除用户数据的方法，就像我们在游戏中做的那样）。以下代码来自
    `test/global.js`：
- en: '[PRE43]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The following code is from `gulpfile.js`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码来自 `gulpfile.js`：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Implementing user rankings with Redis
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Redis 实现用户排名
- en: 'Now we are ready to add the user ranking functionality to our service. The
    following code is from `src/services/users.js`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好将用户排名功能添加到我们的服务中。以下代码来自 `src/services/users.js`：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Most of the Redis commands used here will be familiar from earlier in the chapter.
    The most interesting function is `getTopPlayers`. This makes use of `zrevrange`
    with the `withscores` option. This returns an array of user IDs and scores (interleaved
    together). We make a second request to the database using `mget` (multivalued
    get) to retrieve the names of all the users. Once this returns we can combine
    all the data for each user together into an object.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里使用的 Redis 命令大多数都来自本章前面的内容。最有趣的功能是 `getTopPlayers`。它使用带有 `withscores` 选项的
    `zrevrange`。这返回一个包含用户 ID 和分数的数组（交错在一起）。我们使用 `mget`（多值获取）向数据库发出第二个请求，以检索所有用户的名称。一旦返回，我们就可以将每个用户的所有数据组合成一个对象。
- en: Making use of the users service
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 利用用户服务
- en: Wiring this functionality up to the rest of our application doesn't use any
    techniques we haven't seen before, so is omitted from the printed code listings
    for brevity. The full implementation can be found in the companion code for this
    chapter, along with tests for the rest of the user service methods, at [https://github.com/NodeJsForDevelopers/chapter09](https://github.com/NodeJsForDevelopers/chapter09).
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 将此功能连接到我们的应用程序的其他部分不使用我们之前没有见过的技术，因此为了简洁起见，省略了打印的代码列表。完整的实现可以在本章的配套代码中找到，包括对用户服务其他方法的测试，在
    [https://github.com/NodeJsForDevelopers/chapter09](https://github.com/NodeJsForDevelopers/chapter09)。
- en: A note on security
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于安全性的说明
- en: We have been running MongoDB and Redis with their default out-of-the-box settings.
    This is fine for development purposes. Deploying these services into production
    requires additional consideration around security. You can find more resources
    on this at [https://docs.mongodb.com/manual/administration/security-checklist/](https://docs.mongodb.com/manual/administration/security-checklist/)
    and [http://redis.io/topics/security](http://redis.io/topics/security).
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直使用MongoDB和Redis的默认出厂设置运行。这对于开发目的来说是不错的。将这些服务部署到生产环境中需要考虑额外的安全问题。您可以在[https://docs.mongodb.com/manual/administration/security-checklist/](https://docs.mongodb.com/manual/administration/security-checklist/)和[http://redis.io/topics/security](http://redis.io/topics/security)找到更多资源。
- en: Summary
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have understood the difference between different types of
    database and learned about the key features of MongoDB and Redis. We also persisted
    our application's data using these databases and used dependency injection to
    make our application more flexible. We also learned how to configure our development
    and integration environments to use appropriate database instances.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了不同类型数据库之间的区别，并学习了MongoDB和Redis的关键特性。我们还使用这些数据库持久化我们的应用程序数据，并使用依赖注入使我们的应用程序更加灵活。我们还学习了如何配置我们的开发和集成环境以使用适当的数据库实例。
- en: Persistence may be considered the bottom layer of our system. In the next chapter,
    we'll introduce real-time client/server communication into our application. This
    frontend functionality means focusing more on the top layer of our system. However,
    we'll also see Redis playing an important role in supporting this functionality.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 持久性可能被视为我们系统的底层。在下一章中，我们将引入实时客户端/服务器通信到我们的应用程序中。这种前端功能意味着更多地关注我们系统的顶层。然而，我们也会看到Redis在支持这一功能中扮演着重要的角色。
