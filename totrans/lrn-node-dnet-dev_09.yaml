- en: Chapter 9. Persisting Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Most applications need to persist some kind of data. In this chapter, we'll
    be looking at some approaches to data persistence for Node.js applications.
  prefs: []
  type: TYPE_NORMAL
- en: The default choice for persistence for a long time has been the traditional
    relational database. You may have used **RDBMS**s (relational database management
    systems) such as Microsoft SQL Server, Oracle, MySQL or PostgreSQL. These systems
    are often categorized as *SQL databases* since they all use SQL as their primary
    query language.
  prefs: []
  type: TYPE_NORMAL
- en: More recently, there has been a proliferation of so-called **NoSQL** databases.
    This umbrella term isn't particularly useful as a category. Some NoSQL databases
    have no more in common with each other than with traditional relational databases.
  prefs: []
  type: TYPE_NORMAL
- en: What's interesting is the range of databases available and the use cases they
    fulfil. Traditional RDBMSs are as powerful and flexible as ever and the right
    choice for many situations. In this chapter, we'll consider two other types of
    database, along with how and when to make use of them.
  prefs: []
  type: TYPE_NORMAL
- en: The systems we'll be looking at are **MongoDB** and **Redis**. Both of these
    had their initial release in 2009 and are now widely-used. Covering either of
    them in depth would justify a book in itself. The aim of this chapter is to provide
    an introduction to and high-level overview of each.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: The conceptual data model used by each of these systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use cases for which they provide the most benefit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating them with an Express application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing data persistence code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB is a **document-oriented** DBMS. MongoDB documents are stored as **binary
    JSON** (**BSON**). This is similar to JSON, but with support for additional data
    types. JSON field values can only be strings, numbers, objects, arrays, Booleans,
    or null. BSON supports more specific numeric types, dates and timestamps, regular
    expressions, and binary data. As the name suggests, BSON documents are stored
    and transferred as binary data. This can be more efficient than JSON's string
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB documents are stored in **collections**. These work very much like
    tables in a traditional relational database. Documents can be inserted, updated,
    and queried. There are two key differences from a traditional relational database:'
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB does not support server-side joins. In a traditional RDBMS, you would
    normalize data into multiple tables and join across them using foreign keys. In
    MongoDB, you instead use BSON's nested structure to denormalize data about each
    entity into a single document.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *relational* property of a relational database is that all rows in a table
    contain the same fields with the same meaning. In MongoDB, documents can have
    any set of fields.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In practice, documents in the same collection typically have the same fields
    or at least a common core set of fields. MongoDB supports the creation of indexes
    on common fields in a collection to make querying more efficient.
  prefs: []
  type: TYPE_NORMAL
- en: Why choose MongoDB?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several properties of MongoDB that make it an appealing choice for
    some use cases, especially in Node.js-based applications. We'll cover these in
    this section.
  prefs: []
  type: TYPE_NORMAL
- en: Object modeling
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB's document-based approach can be a good fit for persisting domain entities.
    You may have experience of storing domain entities in a relational database using
    an **Object-Relational Mapper** (**ORM**). Hibernate and Entity Framework are
    popular examples of ORMs. One of the jobs performed by an ORM is mapping a single
    entity to multiple tables in a normalized schema. When an entity is loaded from
    the database, it is reconstructed via `JOIN` queries between these tables. This
    is one of the key features of ORMs. It is also one of the most common sources
    of configuration problems and performance issues when using an ORM. MongoDB persists
    each entity as a single document, which can be much simpler.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, cross-table joins can also be useful for traversing relationships
    between entities. While ORMs typically make this easy, this can itself be a source
    of performance problems. Implicit loading of related entities often causes *N+1*
    problems, issuing thousands of DB queries. Handling these relationships well requires
    careful thought, whatever kind of database you are using.
  prefs: []
  type: TYPE_NORMAL
- en: When using an ORM and an RDBMS, all inter-entity relationships are foreign keys,
    but you need to think carefully about how to load them. When modeling data in
    MongoDB, you must choose between embedded documents or document references for
    inter-entity relationships. Under either tech stack, the design decisions depend
    on the data access requirements of your application and designing the data model
    to reduce the prevalence of inter-entity relationships will simplify matters.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB is a good fit for Node.js in particular. The use of a JSON-like format
    maps well to a JavaScript-based programming environment. MongoDB itself also runs
    JavaScript natively. Database operations can make use of custom JavaScript functions
    that execute on the server.
  prefs: []
  type: TYPE_NORMAL
- en: Scalability
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MongoDB also scales in a similar manner to Node.js. It uses partitioning and
    replication to support horizontal scaling on commodity hardware. There is no technical
    reason why your application and database have to scale in the same way, but it
    may be easier to plan for scalability from a business perspective.
  prefs: []
  type: TYPE_NORMAL
- en: When using an RDBMS, it is more straightforward to scale the database vertically.
    That means provisioning a high-powered database server that can support multiple
    application servers. This requires more careful planning and more up-front investment
    than linearly scaling application and database servers horizontally together.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with MongoDB
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visit [https://www.mongodb.org/downloads](https://www.mongodb.org/downloads)
    to download and install the latest version of the MongoDB Community Server edition
    for your operating system. There are more detailed installation instructions in
    the user manual at [https://docs.mongodb.org/manual/installation/](https://docs.mongodb.org/manual/installation/).
  prefs: []
  type: TYPE_NORMAL
- en: The commands in the rest of this section make use of executables in MongoDB's
    `/bin` directory. You can run the commands in this directory or, better still,
    add it to your `PATH`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory for MongoDB to store its data. Then start the MongoDB daemon
    process (that is, service), providing the path of that directory as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Using the MongoDB shell
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can interact with MongoDB from the console using its built-in shell application.
    You can launch the MongoDB shell by running the `mongo` command, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This will connect to a database named `demo` (creating it, if necessary) on
    the local server. If you don't specify a database, then the shell connects to
    a database named `test`.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing to notice is that the shell is just another JavaScript environment.
    We can try running some of the same commands as at the beginning of [Chapter 2](part0018.xhtml#aid-H5A41
    "Chapter 2. Getting Started with Node.js"), *Getting Started with Node.js*.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Just as Node.js builds on JavaScript in ways that make it more suitable for
    server-side application development, MongoDB adds features more useful to data
    persistence. Note that `new Date()` in the preceding code returns an ISODate,
    MongoDB's standard datatype for representing dates in BSON documents.
  prefs: []
  type: TYPE_NORMAL
- en: You can quit the console by typing `exit` at any time.
  prefs: []
  type: TYPE_NORMAL
- en: 'MongoDB also adds some new global variables for interacting with the database.
    The most important of these is the `db` object. Let''s try adding some documents
    to our database. Recall that MongoDB stores documents in collections. To create
    a new collection, we just need to start inserting documents into it. For a simple
    example, we''ll use the UK bank holidays for 2016\. We can populate this collection
    using the following script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Note that Christmas Day falls on a Sunday in 2016, so the bank holiday occurs
    on the next working day. This gives us a reason to have another field that is
    only relevant to some documents in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'You could type these `insert` commands into the console manually, but it''s
    easier to tell MongoDB to load them from a script file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous command connects to a database named demo, runs the `holiday.js`
    script (available in the book''s companion code), then opens a shell to allow
    us to interact with the database. We can view the complete contents of the collection
    by running the following command in the MongoDB console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that MongoDB has automatically added an `_id` field to each document for
    us.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can see how MongoDB does this by viewing the source of the `insert` method.
    Just type `db.holidays.insert` into the shell (with no parentheses).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can pull out records by their `_id` or other single fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This will return any objects that match the object passed to `find`. To look
    up documents by something other than exact equality, we can use MongoDB''s query
    operators. These are prefixed with the dollar symbol and specified as object properties.
    For example, to find holidays in the second half of the year, we can use the *greater
    than or equal to* operator as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'MongoDB''s **aggregation pipeline** allows us to build complex queries from
    a sequence of operations called **pipeline stages**. It is the closest thing in
    MongoDB to complex querying in SQL. Here, we count the number of bank holidays
    in each month using MongoDB''s `$group` pipeline stage, which is similar to SQL''s
    `GROUP BY` clause:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'An odd quirk of the calendar in 2016 means that the Christmas Day Bank Holiday
    actually comes after Boxing Day (since Christmas Day itself is on a Sunday). In
    the following example, we order bank holidays by the date of the occasion that
    they mark (stored in the `$substitute_for` field if different from the date of
    the bank holiday):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous pipeline consists of two stages:'
  prefs: []
  type: TYPE_NORMAL
- en: The `$project` stage specifies a set of fields based on the underlying data
    (similar to `SELECT` in SQL). Note that the `_id` field is included by default,
    but we exclude it here.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `$sort` stage specifies a sort field and direction (similar to SQL's `SORT
    BY` clause). The `1` here indicates an ascending sort order.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have just scratched the surface here. There are many more pipeline phases
    available in MongoDB. You can find out more about aggregation in the MongoDB documentation
    at [https://docs.mongodb.com/manual/core/aggregation-pipeline/](https://docs.mongodb.com/manual/core/aggregation-pipeline/).
  prefs: []
  type: TYPE_NORMAL
- en: MongoDB also has a built-in Map-Reduce function for powerful aggregate data
    processing using arbitrary JavaScript functions. This is beyond the scope of this
    book, but you can find out more about Map-Reduce and MongoDB's implementation
    of it at [https://docs.mongodb.com/manual/core/map-reduce/](https://docs.mongodb.com/manual/core/map-reduce/).
  prefs: []
  type: TYPE_NORMAL
- en: Using MongoDB with Express
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The games service module in our application currently stores all its data in
    memory. This worked well enough for demo purposes, but isn't suitable for a real
    application. We lose all the data whenever the application restarts. It also prevents
    us from scaling our application across multiple processes. Each instance would
    have its own game service with different data. Users would see different data
    depending on which server happened to handle their request.
  prefs: []
  type: TYPE_NORMAL
- en: We're going to update our games service to store its data in MongoDB. For this,
    we're going to make use of a library called **Mongoose**.
  prefs: []
  type: TYPE_NORMAL
- en: Persisting objects with Mongoose
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recall that, unlike a relational database, MongoDB does not require documents
    in the same collection to have the same fields. However, we do typically expect
    most items within a collection to share at least a common core of fields.
  prefs: []
  type: TYPE_NORMAL
- en: Mongoose is an object modeling library for storing entities in MongoDB. It helps
    with writing common functionality such as validation, query building, and type
    casting. It also provides hooks for associating business logic with our entities.
    These are similar to some of the features provided by ORMs such as Entity Framework
    or Hibernate. Mongoose itself is not an ORM, though. Recall that object-relational
    mapping is not relevant for document-oriented databases such as MongoDB.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use Mongoose, we start by defining a **schema**. This defines the common
    fields for documents within a MongoDB collection. Returning to our demo application
    from the preceding chapters, let''s install Mongoose and define a schema for our
    games collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is added to `src/services/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The schema defines document fields and specifies the type of each field. To
    start persisting documents with this schema, we need to create a **model**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Models are constructors that correspond to a MongoDB collection. Instances
    of a Mongoose model correspond to documents in that collection. Models also provide
    functions for modifying the collection. We create a model by specifying the schema
    and (singular) collection name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The Model constructor replaces our Game class and constructor from before.
    This class also contained two instance methods: `positionsOf` and `remove`. We
    can define custom instance methods on a schema, which will be available on all
    model instances. These must be defined before creating the model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we use a traditional function definition rather than an arrow function
    in the preceding code. This is necessary in order for the `this` keyword inside
    the function to work correctly. See [http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/](http://derickbailey.com/2015/09/28/do-es6-arrow-functions-really-solve-this-in-javascript/)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: 'We don''t need to define a `remove` method anymore, because Mongoose provides
    this automatically. It also provides a `save` method, which we can use for persisting
    new games:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We don't need to specify an ID anymore, since this is also provided by Mongoose.
    Note that we do need to specify `word.toUpperCase()`, which used to be in the
    Game constructor. This isn't a problem, since the constructor is private to our
    module. No code outside the module can invoke the constructor directly. Where
    the `toUpperCase` call takes place is just an implementation detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also note that Mongoose''s async operations all return promises as an alternative
    to using callbacks. Mongoose supports both of the asynchronous programming patterns
    discussed in the previous chapter. Mongoose uses its own implementation of promises.
    We can configure Mongoose to use ECMAScript 6 promises, though. We also need to
    tell Mongoose to connect to a MongoDB database. For now, we will hardcode the
    URL, but we''ll see how to make this configurable shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to implement our three methods for retrieving games from the
    database. We can do this using Mongoose''s `find` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The Mongoose `find` method works like the MongoDB `find` method we saw in the
    previous section, *Using the MongoDB shell*. It takes a set of MongoDB query conditions
    and asynchronously provides a list of documents. `findById` takes an ID and asynchronously
    provides a single document, or null.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mongoose also provides a `where` method for building up conditions through
    function calls. The `availableTo` function can be rewritten as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: As long as you still have MongoDB running locally (as described in *Getting
    started with MongoDB* earlier in the chapter), you should now be able to run the
    application. Try stopping and restarting the application and notice that games
    are now persisted between restarts.
  prefs: []
  type: TYPE_NORMAL
- en: Isolating persistence code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It's useful to integrate with a real database to make sure our persistence code
    is working. But it's not always appropriate for our tests to be dependent on an
    external MongoDB instance.
  prefs: []
  type: TYPE_NORMAL
- en: We want developers to be able to check out the code and run the application
    without needing to run a database instance. Also, external dependencies slow down
    our tests. MongoDB stores data on disk, so introduces additional I/O work into
    our tests.
  prefs: []
  type: TYPE_NORMAL
- en: The application should depend on an external database in production. In integration,
    we want to use a real database on the local server. On development machines, it
    would be better to use an in-memory database by default. So we need to be able
    to configure a database URL and fall back to an in-memory database in development
    environments.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we need to initialize Mongoose before using it in our games service.
    This includes specifying the database URL and waiting for a connection to be established.
    This happens asynchronously, so can't be part of the games service module definition.
    We also don't want clients of the games service to have to pass in a Mongoose
    instance to each function call.
  prefs: []
  type: TYPE_NORMAL
- en: We can address all of these issues by introducing dependency injection to our
    application. We'll pass in the game service as a dependency to the modules that
    need it and pass in Mongoose as a dependency to the games service.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This would also give us the option of writing unit tests for other modules that
    pass in a test double for the games service itself, so don't use MongoDB at all.
    In larger applications, this kind of test isolation is important for writing fast
    and maintainable tests.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency injection in Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You may have used **dependency injection** (**DI**) frameworks such as Unity,
    Autofac, NInject, or Spring in .NET or Java. These provide features such as declarative
    configuration and auto wiring of dependencies. There are similar DI containers
    available for JavaScript. However, it is more common to pass around dependencies
    explicitly. JavaScript's module pattern makes this approach more natural than
    in other languages. We don't need to add a lot of fields and constructors/properties
    to set up dependencies. We can just wrap modules in an initialization function
    that takes dependencies as parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application, the `app` module will wire everything together. The application
    as a whole depends on the database. The games and index routes depend on the game
    service. To allow the routes to take a dependency on the game service, we just
    need to top and tail them with a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The games service itself is slightly more complicated. We previously added
    several functions to `module.exports`, so we need to put these on an object instead.
    However, this actually results in shorter code. Also, note that we only create
    the `Game` schema if it hasn''t already been defined, to defend against our exported
    function being called multiple times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the application itself depends on the database connection and wires
    up the other dependencies:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Providing dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can specify the database URL in an environment variable. When this isn't
    present, our application will instead make use of an in-memory instance of MongoDB.
    This will be provided by a library called **Mockgoose**. We install this as a
    dev dependency, in case we forget to set our environment variable on a production
    server. We'll get an error rather than quietly using a non-persistent database.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a new module under `src/config/mongoose.js` to initialize Mongoose
    and return a promise that will be fulfilled when it has connected to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we just need to pass this into our application. The following is the code
    from `bin/www`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To allow our tests to run, we''ll also need to add new `before` functions to
    make use of this module. The following code is from `test/services/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is from `test/routes/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll also add a global teardown function to close the database connection
    after all tests have finished. This is just a Mocha `after` hook outside the context
    of any `describe` block. We add this in a new file under `test/global.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to update our `gulpfile.js`, to allow our integration tests
    to run with the new dependency:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We can now run our application and tests on a local development machine without
    needing to have MongoDB running, or we can specify the `MONGO_DB` environment
    variable if and when we want to use a real MongoDB instance.
  prefs: []
  type: TYPE_NORMAL
- en: Running database integration tests on Travis CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We do want to regularly integration test our application against a real MongoDB
    instance. Fortunately, Travis CI provides various data stores as part of its environment.
    We just need to tell it that our build requires MongoDB by adding it to our `travis.yml`
    file. We also need to set the `MONGODB_URL` environment variable for tests to
    be able to connect to the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now we can run our application as well as our unit and integration tests with
    a suitable MongoDB instance on development machines and on the CI server.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Redis is often classified as a **key-value** data store. Redis describes itself
    as a data-structure store. It offers storage types similar to the basic data structures
    found in most programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Why use Redis?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Redis operates entirely in memory, allowing it to be very fast. This, together
    with its key-value nature, makes it well-suited for use as a cache. It also supports
    publish/subscribe channels, which allows it to function as a message broker. We'll
    look at this further in [Chapter 10](part0058.xhtml#aid-1NA0K1 "Chapter 10. Creating
    Real-time Web Apps"), *Real-time Web Apps in Node.js*.
  prefs: []
  type: TYPE_NORMAL
- en: More generally, Redis can be a useful backend to allow multiple Node.js processes
    to co-ordinate with one another. Node.js scales horizontally and most websites
    will run multiple Node.js processes. Many websites have "working" data that doesn't
    need to be persisted long term, but does need to be available quickly and consistently
    across all processes. Redis's in-memory nature and range of atomic operations
    make it very useful for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: Redis is built more for speed than durability. There are various options to
    configure it, but all expect some amount of data loss in the event of an outage.
    This is a compromise of Redis working entirely in-memory for speed. It is possible
    to reduce data loss to no more than the last second of writes before an outage,
    without significantly compromising on speed. Redis can be configured to completely
    minimize data loss by syncing to disk after each operation. However, this has
    a more significant impact on performance and negates the advantages of Redis's
    in-memory nature.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Source distributions of Redis are available from [http://redis.io/download](http://redis.io/download).
  prefs: []
  type: TYPE_NORMAL
- en: 'For Windows, it is more useful to download a pre-built binary. It is available
    as a signed package via NuGet and Chocolatey. If you have Chocolatey available,
    you can install Redis by running the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, you can download an unsigned version of the installer from [https://github.com/MSOpenTech/redis/releases](https://github.com/MSOpenTech/redis/releases)
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can start Redis by running `redis-server`. In a separate
    window, run `redis-cli` to connect to the server and run commands.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis as a key-value store
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Everything in Redis is stored against a key. Keys in Redis can be any binary
    data, but it's best to think of them as strings. Various types of value can be
    stored against each key.
  prefs: []
  type: TYPE_NORMAL
- en: 'Redis refers to simple scalar values as **Strings**. Redis also has special
    treatment for scalar integers. The following example sets and updates a key named
    `counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This increment operation is atomic. Redis also supports setting values atomically.
    The following command will fail because the key already exists:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: These features can help coordinating between servers. Redis also supports setting
    expiry times for keys. This makes it possible to offer caching behavior similar
    to memcache. Redis has even more flexibility, though, as we'll see in the next
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Storing structured data in Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to simple key-value pairs, Redis supports other more structured
    data types.
  prefs: []
  type: TYPE_NORMAL
- en: '**Lists** are ordered collections of values. They are stored as a linked list
    rather than as arrays. This makes adding/removing elements at the ends of the
    list efficient (at the cost of slower retrieval of items from the list by index),
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Note that `lrange` takes start and end indices. Negative values count backwards
    from the end of the list, so `-1` refers to the last element. Being able to push/pop
    from either end of a list means that they can be used as stacks or queues, for
    example, for allowing processes to communicate in a producer-consumer arrangement.
  prefs: []
  type: TYPE_NORMAL
- en: '**Hashes** are a set of field-value pairs. These are not as rich as MongoDB
    documents, but allow us to associate some data together. For example, we could
    have implemented our game service using Redis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Note that the top-level key `game:2` here is just a convention. It can be useful
    for developers to namespace keys in this way, but Redis only understands them
    as strings.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sets** are unordered collections of values, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Sets support mathematical operations such as unions and intersections. They
    also support the retrieval (with optional atomic removal) of random elements.
  prefs: []
  type: TYPE_NORMAL
- en: '**Sorted sets** are collections of values, each associated with a numerical
    score:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Note that the ranges are ordered smallest to largest by default. We request
    a reverse range above to get the element with the highest score first. Sorted
    sets are useful for implementing voting systems (as previously shown) or ranking
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Building a user ranking system with Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We want to be able to rank users based on how many games they have completed.
    We will create a user service, implemented in Redis, that provides the following
    functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: Record when a user successfully completes a game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the top three users across the site
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Return the rank of a given user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will first add a feature to make the site a bit more user-friendly by allowing
    users to choose a screen name.
  prefs: []
  type: TYPE_NORMAL
- en: Using Redis from Node.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we''ll need to install a Node.js client library for Redis. We''ll also
    use the promise library Bluebird to convert the Redis client library to promises:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we''ll create a module for configuring the Redis client as shown here
    in `src/config/redis.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a new user service with methods for getting and setting a
    username, in `src/services/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Note that the Redis client provides functions for each Redis command (such as
    `get` and `set`). Bluebird provides promise-based versions of each function suffixed
    with `Async`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, now that we have test infrastructure for our project, we should
    add tests for new code as we go as shown here `test/services/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Testing with redis-js
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'As with the tests for our games service, we want to be able to integrate with
    a Redis instance on our CI server. But we don''t want to introduce any new dependencies
    for development. This time, we will make use of a library called redis-js for
    local testing. Unlike Mockgoose, this does not use an in-memory version of the
    real DB engine (Redis is already in-memory). This is instead a re-implementation
    of the Node.js Redis client that stores all of its data in-process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we can create a module for obtaining the environment-appropriate Redis
    reference as shown here `src/config/redis.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Note that, unlike Mongoose, the Node.js Redis client can be used immediately.
    Any commands issued before it has connected are actually queued up internally.
    This means we can just return the client from the module and require it directly.
    There wouldn't be any benefit in this case to the dependency injection we used
    with Mongoose.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also need to add Redis to our `.travis.yml` file so it runs on the CI server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we need to close the client once our tests have completed, as we did
    with Mongoose. We also ensure we empty the database on startup (as we don''t have
    a way of deleting user data via the service interface, as we do with games). The
    following code is from `test/global.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code is from `gulpfile.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Implementing user rankings with Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now we are ready to add the user ranking functionality to our service. The
    following code is from `src/services/users.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Most of the Redis commands used here will be familiar from earlier in the chapter.
    The most interesting function is `getTopPlayers`. This makes use of `zrevrange`
    with the `withscores` option. This returns an array of user IDs and scores (interleaved
    together). We make a second request to the database using `mget` (multivalued
    get) to retrieve the names of all the users. Once this returns we can combine
    all the data for each user together into an object.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of the users service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wiring this functionality up to the rest of our application doesn't use any
    techniques we haven't seen before, so is omitted from the printed code listings
    for brevity. The full implementation can be found in the companion code for this
    chapter, along with tests for the rest of the user service methods, at [https://github.com/NodeJsForDevelopers/chapter09](https://github.com/NodeJsForDevelopers/chapter09).
  prefs: []
  type: TYPE_NORMAL
- en: A note on security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have been running MongoDB and Redis with their default out-of-the-box settings.
    This is fine for development purposes. Deploying these services into production
    requires additional consideration around security. You can find more resources
    on this at [https://docs.mongodb.com/manual/administration/security-checklist/](https://docs.mongodb.com/manual/administration/security-checklist/)
    and [http://redis.io/topics/security](http://redis.io/topics/security).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have understood the difference between different types of
    database and learned about the key features of MongoDB and Redis. We also persisted
    our application's data using these databases and used dependency injection to
    make our application more flexible. We also learned how to configure our development
    and integration environments to use appropriate database instances.
  prefs: []
  type: TYPE_NORMAL
- en: Persistence may be considered the bottom layer of our system. In the next chapter,
    we'll introduce real-time client/server communication into our application. This
    frontend functionality means focusing more on the top layer of our system. However,
    we'll also see Redis playing an important role in supporting this functionality.
  prefs: []
  type: TYPE_NORMAL
