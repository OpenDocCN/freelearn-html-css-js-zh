<html><head></head><body><div class="chapter" title="Chapter&#xA0;2.&#xA0;Managing Views"><div class="titlepage"><div><div><h1 class="title"><a id="ch02"/>Chapter 2. Managing Views</h1></div></div></div><p>As we have seen in the previous chapter, Backbone views are responsible for managing <span class="strong"><strong>DOM</strong></span> (<span class="strong"><strong>Document Object Model</strong></span>) interactions between users and applications. A typical Backbone application is composed of many views with a very specific behavior; for instance, we can have a view to show contact data and another view to edit it. As you know, rendering a single view is a trivial task, but orchestrating a complex layout with multiple views can be a pain.</p><p>It's important to develop <a id="id33" class="indexterm"/>a better strategy to deal with complex view interactions to make the project easier to maintain and fun to develop. If you don't put the necessary attention into the organization of your views you can end up with a dirty DOM and messy code, which makes it hard to introduce new features or change existing ones.</p><p>As we did in the previous chapter, we are going to separate responsibilities by identifying common view use cases and then will learn how to compose layouts by using small views.</p><p>In this chapter you will learn to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Identify common view types</li><li class="listitem" style="list-style-type: disc">Implement reusable views for common types</li><li class="listitem" style="list-style-type: disc">Use the reusable view types to compose complex views easily</li></ul></div><div class="section" title="Identifying view types"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec13"/>Identifying view types</h1></div></div></div><p>After working with <a id="id34" class="indexterm"/>Backbone for a while you can see common use cases for views emerge; they are so common they can be used for different unrelated projects. These views can be extracted and can be used on any project if they are built correctly. Looking at the Backbone documentation, Views do not implement a default render method, so the trick here is to define a set of views with a default render method for different use cases:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>View with model</strong></span> – Render a<a id="id35" class="indexterm"/> template with model data.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>View with collection</strong></span> – Render a collection of views with collection data; it should update the list of views automatically when the collection<a id="id36" class="indexterm"/> changes.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Region</strong></span> – This<a id="id37" class="indexterm"/> view acts like a container; it points to a particular DOM node and manages the content for that node. It's used to render other views.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Layout</strong></span> – A layout is<a id="id38" class="indexterm"/> composed of one or more regions; it defines an HTML structure to organize where the regions will be placed.</li></ul></div><p>Figure 2.1 shows a<a id="id39" class="indexterm"/> simple wireframe for an application; as you can see, it is a very common layout found on web applications and is very useful to understand how the common view types are related.</p><div class="mediaobject"><img src="graphics/B01962_02_01.jpg" alt="Identifying view types"/><div class="caption"><p>Figure 2.1: Views, Regions, and Layout relationship</p></div></div><p>With these foundation views you will have a simple but powerful framework to manage your views, so you won't need to implement the <code class="literal">render()</code> method anymore.</p></div></div>
<div class="section" title="ModelView"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec14"/>ModelView</h1></div></div></div><p>The simplest<a id="id40" class="indexterm"/> implementation is to render a single model; it's a very straightforward algorithm. Extract data<a id="id41" class="indexterm"/> from the model and use a template engine to make the actual render with the data; finally, attach the result in the DOM:</p><div class="informalexample"><pre class="programlisting">class MyView extends Backbone.View {
  constructor(options) {
    super(options);
    template: _.template($("#my-template").html());
  }
  
  render() {
       var data = this.model.toJSON();
    var renderedHtml = this.template(data);
    this.$el.html(renderedHtml);
    return this;
  }
}</pre></div><p>In the following code we can identify five steps to rendering the view.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Get the template:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$("#my-template").html()</strong></span>
</pre></div></li><li class="listitem">Compile the template:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>_.template($("#my-template").html())</strong></span>
</pre></div></li><li class="listitem">Get data from the model:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>var data = this.model.toJSON()</strong></span>
</pre></div></li><li class="listitem">Render the template with model data:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>renderedHtml = this.template(data)</strong></span>
</pre></div></li><li class="listitem">Put the result on the DOM:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>this.$el.html(renderedHtml)</strong></span>
</pre></div></li></ol></div><p>Note that we return this in the <code class="literal">render()</code> method; this is useful for chaining calls. These steps are common for all views that need to render a model, so we can extract that behavior in a new view type. This view will own the generic algorithm and let the specific parts open to extend:</p><div class="informalexample"><pre class="programlisting">class ModelView extends Backbone.View {
  render() {
    var data = this.serializeData();

    // Compile the template
    var renderedHtml = _.template(this.template, data);

    // Put the result in the DOM
    this.$el.html(renderedHtml);
    return this;
  }

  serializeData() {
    var data;

    // Serialize only if a model is present
    if (this.model) {
      data = this.model.toJSON();
    }

    return data;
  }
});</pre></div><p>The model data now is done in a separated method, <code class="literal">serializeData()</code>, allowing us to implement a different way to provide data to the view; however, it implements a default behavior that is needed in most cases.</p><p>The template is<a id="id42" class="indexterm"/> now compiled in the process using the Underscore template engine, so that you have to provide the template text and let it make the rest. But this leaves the view highly coupled with a template engine; what if you need to use a different one such as Handlebars?</p><p>We can use the same strategy as before in the <code class="literal">serializedData()</code> method, and put this behavior in a separated method. All template engines need two things: template text and data. Template text can be obtained by a jQuery selector, a string variable, pre-compiled template, and so on. So we will leave this open to the final implementation:</p><div class="informalexample"><pre class="programlisting">  class ModelView extends Backbone.View {  
    // Compile template with underscore templates. This method
    // can be redefined to implemente another template engine
    // like Handlebars or Jade
    compileTemplate() {
      var $el = $(this.template);
      return _.template($el.html());
    }

    // ...
  }</pre></div><p>And, as we did with <code class="literal">serializedData()</code>, a default behavior is implemented.</p><div class="informalexample"><pre class="programlisting">class ModelView extends Backbone.View {
  render() {
    // Get JSON representation of the model
    var data = this.serializeData();
    var renderedHtml;

    // If template is a function assume that is a compiled
    // template, if not assume that is a CSS selector where
    // the template is defined and is compatible with
    // underscore templates
    if (_.isFunction(this.template)) {
      renderedHtml = this.template(data);
    } else if (_.isString(this.template)) {
      var compiledTemplate = this.compileTemplate();
      renderedHtml = compiledTemplate(data);
    }

    this.$el.html(renderedHtml);
    return this;
  }

  // …
}</pre></div><p>In this case, the<a id="id43" class="indexterm"/> <code class="literal">template</code> property can be either a function or a string. If a string is used, the default behavior will be to use the Underscore template engine. If a function is used, the function gives us the freedom to use any template engine.</p><p>If we want to render a model in a view, we can do something like this:</p><div class="informalexample"><pre class="programlisting">var contact = new Backbone.Model({
  name: 'John Doe',
  phone: '5555555'
});

var ContactView extends ModelView {
  constructor(options) {
    super(options);
    this.template = $('#contact-template').html();
  }
  
  // ... anything else like event handlers
}

var contactView = new ContactView({
  model: contact,
  el: 'body'
});
contactView.render();</pre></div><p>You only need to<a id="id44" class="indexterm"/> specify the template and the model, and you're done!</p></div>
<div class="section" title="CollectionView"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec15"/>CollectionView</h1></div></div></div><p>Backbone Collections are <a id="id45" class="indexterm"/>composed of many models, so when rendering a<a id="id46" class="indexterm"/> collection what we need is to render a list of <code class="literal">Views</code>:</p><div class="informalexample"><pre class="programlisting">class CollectionView extends Backbone.View {
  render() {
    // Render a view for each model in the collection
    var html = this.collection.map(model =&gt; {
      var view = new this.modelView(model);
      view.render();
      return view.$el;
    });

    // Put the rendered items in the DOM
    this.$el.html(html);
    return this;
  }
}</pre></div><p>Note that the <code class="literal">modelView</code> property should be a View class; it could be our <code class="literal">ModelView</code> class of the previous section or any other view. See how for each model in the collection it instantiates and renders a <code class="literal">this.modelView</code> with the current model. As a result, an <code class="literal">html</code> variable will contain an array of all rendered views. Finally the <code class="literal">html</code> array can be attached easily to the <code class="literal">$el</code> element.</p><p>For an example of how to use <code class="literal">CollectionView</code>, see the following example:</p><div class="informalexample"><pre class="programlisting">class MyModelView extends ModelView {
  // …
)

class MyView extends CollectionView {
  constructor(options) {
    super(options);
    this.el = '#main';
    this.modelView = MyModelView;
  }
}

var view = new MyView({collection: someCollection});
view.render();</pre></div><p>This snippet will do the job, it will render a <code class="literal">MyModelView</code> for each model in the <code class="literal">someCollection</code> object and put the result list in the <code class="literal">#main</code> element.</p><p>However, if you add models to the collection or remove them, the view will not be updated. That's not a desirable behavior. When a model is added, it should add a new view at the end <a id="id47" class="indexterm"/>of the list; if a model is deleted from the collection, the view associated with that model should be deleted.</p><p>A quick and dirty way to sync collection changes and views is to re-render the entire view on every change in the collection, but this approach is very inefficient because client resources are consumed when re-rendering views that don't need to change. A better approach should exist.</p><div class="section" title="Adding new models"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec15"/>Adding new models</h2></div></div></div><p>When a model is<a id="id48" class="indexterm"/> added to the collection an <code class="literal">add</code> event is triggered; we <a id="id49" class="indexterm"/>can create an event handler to update the view:</p><div class="informalexample"><pre class="programlisting">class CollectionView extends Backbone.View {
  initialize() {
    this.listenTo(this.collection, 'add', this.addModel);
  }

  // ...
}</pre></div><p>When the <code class="literal">addModel</code> method is called, it should create and render a new view with the data of the model added <a id="id50" class="indexterm"/>and put it at the end <a id="id51" class="indexterm"/>of the list.</p><div class="informalexample"><pre class="programlisting">var CollectionView = Backbone.View.extend({
  // ...
  // Render a model when is added to the collection
  modelAdded(model) {
    var view = this.renderModel(model);
    this.$el.append(view.$el);
  }

  render() {
    // Render a view for each model in the collection
    var html = this.collection.map(model =&gt; {
      var view = this.renderModel(model);
      return view.$el;
    });

    // Put the rendered items in the DOM
    this.$el.html(html);
    return this;
  }

  renderModel(model) {
    // Create a new view instance, modelView should be
    // redefined as a subclass of Backbone.View
    var view = new this.modelView({model: model});

    // Keep track of which view belongs to a model
    this.children[model.cid] = view;

    // Re-trigger all events in the children views, so that
    // you can listen events of the children views from the
    // collection view
    this.listenTo(view, 'all', eventName =&gt; {
      this.trigger('item:' + eventName, view, model);
    });

    view.render();
    return view;
  }
}</pre></div><p>A <code class="literal">renderModel()</code> method was added since both methods, <code class="literal">render()</code> and <code class="literal">modelAdded()</code>, need to render the model in the same way. The DRY principle was applied.</p><p>When a child view is rendered, it is useful to listen for all the events for the given view, so that we can listen for child events from the collection.</p><div class="informalexample"><pre class="programlisting">var myCollectionView = new CollectionView({...});

myCollectionView.on('item:does:something', (view, model) =&gt; {
  // Do something with the model or the view
});</pre></div><p>Our event handler is <a id="id52" class="indexterm"/>very simple; it renders the added model with the <code class="literal">renderModel()</code> method, attaches an event handler for any event in the view, and <a id="id53" class="indexterm"/>appends the result at the end of the DOM element.</p></div><div class="section" title="Deleting models"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec16"/>Deleting models</h2></div></div></div><p>When a model is<a id="id54" class="indexterm"/> removed from the collection, the view that contains that model should be deleted from<a id="id55" class="indexterm"/> the DOM to reflect the current state of the collection. Consider an event handler for the <code class="literal">removed</code> event:</p><div class="informalexample"><pre class="programlisting">function modelRemoved(model) {
  var view = getViewForModel(model); // Find view for this model
  view.destroy();
}</pre></div><p>How can we obtain the view associated with the model? There is no easy way to do it with the code that we have. To make it easy, we can keep track of model-view associations; in this way, getting the view is very easy:</p><div class="informalexample"><pre class="programlisting">class CollectionView extends Backbone.View {
  initialize() {
    this.children = {};
    this.listenTo(this.collection, 'add', this.modelAdded);
    this.listenTo(this.collection, 'remove', this.modelRemoved);
  }

  // ...

  // Close view of model when is removed from the collection
  modelRemoved(model) {
    var view = this.children[model.cid];

    if (view) {
      view.remove();
      this.children[model.cid] = undefined;
    }
  }

  // ...

  renderModel(model) {
    // Create a new view instance, modelView should be
    // redefined as a subclass of Backbone.View
    var view = new this.modelView({model: model});

    // Keep track of which view belongs to a model
    this.children[model.cid] = view;

    // Re-trigger all events in the children views, so that
    // you can listen events of the children views from the
    // collection view
    this.listenTo(view, 'all', eventName =&gt; {
      this.trigger('item:' + eventName, view, model);
    });

    view.render();
    return view;
  }
}</pre></div><p>At rendering time, we<a id="id56" class="indexterm"/> store a reference to the view in the <code class="literal">this.children</code> hash table for future reference, since <code class="literal">render()</code> and <code class="literal">modelAdded()</code> use the same method to render; this change is done in<a id="id57" class="indexterm"/> one place, the <code class="literal">renderModel()</code> method.</p><p>When a model is removed, the <code class="literal">modelRemoved()</code> method can easily find the view and remove it by calling the standard <code class="literal">remove()</code> method and destroying the reference in the <code class="literal">this.children</code> hash.</p></div><div class="section" title="Destroying views"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec17"/>Destroying views</h2></div></div></div><p>When a <code class="literal">CollectionView</code> is destroyed, it should remove all children views to clean the memory properly. This <a id="id58" class="indexterm"/>should be done by extending the <code class="literal">remove()</code> method:</p><div class="informalexample"><pre class="programlisting">class CollectionView extends Backbone.View {
  // ...
 
  // Close view of model when is removed from the collection
  modelRemoved(model) {
    if (!model) return;

    var view = this.children[model.cid];
    this.closeChildView(view);
  }

  // ...

  // Called to close the collection view, should close
  // itself and all the live childrens
  remove() {
    Backbone.View.prototype.remove.call(this);
    this.closeChildren();
  }

  // Close all the live childrens
  closeChildren() {
    var children = this.children || {};

    // Use the arrow function to bind correctly the "this" object
    _.each(children, child =&gt; this.closeChildView(child));
  }

  closeChildView(view) {
    // Ignore if view is not valid
    if (!view) return;

    // Call the remove function only if available
    if (_.isFunction(view.remove)) {
      view.remove();
    }

    // Remove event handlers for the view
    this.stopListening(view);

    // Stop tracking the model-view relationship for the
    // closed view
    if (view.model) {
      this.children[view.model.cid] = undefined;
    }
  }
}</pre></div><p>Now, when the view<a id="id59" class="indexterm"/> needs to be removed, it will do it and clean all the children views.</p></div><div class="section" title="Resetting the collection"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec18"/>Resetting the collection</h2></div></div></div><p>When a<a id="id60" class="indexterm"/> collection is wiped, the view should re-render the entire collection, because all items were replaced:</p><div class="informalexample"><pre class="programlisting">class CollectionView extends Backbone.View {
  initialize() {
    // ...
    this.listenTo(this.collection, 'reset', this.render);
  }

  // ...
}</pre></div><p>This works, but previous views should be closed too; as we saw in the previous section, the best place to do it is in the render method:</p><div class="informalexample"><pre class="programlisting">class CollectionView extends Backbone.View.extend({
  // ...
  render () {
    // Clean up any previous elements rendered
    this.closeChildren();

    // Render a view for each model in the collection
    var html = this.collection.map(model =&gt; {
      var view = this.renderModel(model);
      return view.$el;
    });

    // Put the rendered items in the DOM
    this.$el.html(html);
    return this;
  }

  // ...
}</pre></div><p>If a view has no<a id="id61" class="indexterm"/> items yet, the <code class="literal">closeChildren()</code> method will not do anything.</p></div></div>
<div class="section" title="Region"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec16"/>Region</h1></div></div></div><p>A common use case<a id="id62" class="indexterm"/> is to swap between views in a common DOM element; this can be done by using the same <code class="literal">el</code> property in both views and calling the <code class="literal">render()</code> method on the view you want to see. But this way doesn't clean the memory and event bindings<a id="id63" class="indexterm"/> because both views will remain live in memory, even if they are not in the DOM.</p><p>A particularly useful scenario is when you need to switch between sub-applications, because sub-applications are rendered in the same DOM element normally. For example, when a user wants to edit contact information, he/she will click on an <span class="strong"><strong>Edit</strong></span> button, and the current view will be replaced with an edit form.</p><div class="mediaobject"><img src="graphics/B01962_02_02.jpg" alt="Region"/><div class="caption"><p>Figure 2.2: Swapping views with regions</p></div></div><p>To switch <a id="id64" class="indexterm"/>between views, a <code class="literal">Region</code> class could be used as shown next:</p><div class="informalexample"><pre class="programlisting">var mainRegion = new Region({el: '#main'});
var contactViewer = new ContactViewer({model: contact});

contactViewer.on('edit:contact', function(contact) {
  var editContact = new EditContactView({ model: contact });
  mainRegion.show(editContact);
});

mainRegion.show(contactViewer);</pre></div><p>The <code class="literal">Region</code> object points to an existing DOM element; to show a view on that element, the <code class="literal">show()</code> method should be called on the <code class="literal">Region</code> object. Note that views don't have the <code class="literal">el</code> property set because regions will put the element in the DOM and not the View itself. This gives us an extra feature, views don't need to set an <code class="literal">el</code> property anymore and can be rendered on any available region.</p><p>A basic region <a id="id65" class="indexterm"/>manager can be implemented with this code:</p><div class="informalexample"><pre class="programlisting">class Region {
  constructor(options) {
    this.el = options.el;
  }

  // Closes any active view and render a new one
  show(view) {
    this.closeView(this.currentView);
    this.currentView = view;
    this.openView(view);
  }

  closeView(view) {
    // Only remove the view when the remove function
    // is available
    if (view &amp;&amp; view.remove) {
      view.remove();
    }
  }

  openView(view) {
    // Be sure that this.$el exists
    this.ensureEl();

    // Render the view on the this.$el element
    view.render();
    this.$el.html(view.el);
  }

  // Create the this.$el attribute if do not exists
  ensureEl() {
    if (this.$el) return;
    this.$el = $(this.el);
  }

  // Close the Region and any view on it
  remove() {
    this.closeView(this.currentView);
  }
}</pre></div><p>When the <code class="literal">show()</code> method is called, it closes the current view, if any, then assigns a new <code class="literal">currentView</code> and opens the view. When a view is open, <code class="literal">Region</code> ensures that the <code class="literal">$el</code> property exists, first calling the <code class="literal">ensureEl()</code> method. Then the interesting part happens:</p><div class="informalexample"><pre class="programlisting">view.render();
this.$el.html(view.el);</pre></div><p>The Backbone documentation<a id="id66" class="indexterm"/> explains how views works:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>All views have a DOM element at all times (the el property), whether they've already been inserted into the page or not. In this fashion, views can be rendered at any time, and inserted into the DOM all at once [...]</em></span></p></blockquote></div><p>And that's what happens here: we render the view in memory first, calling <code class="literal">view.render()</code>, and then insert the result in the DOM pointed by the Region <code class="literal">$el</code> property.</p><p>A <code class="literal">remove()</code> method is implemented too, to make regions compatible with Backbone Views. When a region is removed, it needs to close the owned view too, so this allows us to do this easily.</p><p>Imagine that we have a region that owns a <code class="literal">CollectionView</code> with many views inside; when the <code class="literal">remove()</code> method is called on the region, it will call the <code class="literal">remove()</code> method on the <code class="literal">CollectionView</code>, which will call the <code class="literal">remove()</code> method on every child view.</p></div>
<div class="section" title="Layout"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec17"/>Layout</h1></div></div></div><p>A Layout is used to define<a id="id67" class="indexterm"/> structure; its intention is to create a skeleton where other views will be placed. A common web application layout is composed of a header, a sidebar, footer, and a<a id="id68" class="indexterm"/> common area, for example. With layouts we can define regions, in a declarative way, where these elements will be placed. After the layout is rendered, we can show the views we want on those views.</p><p>In the following figure, we can see a layout; each of these elements is a region, so other views should be created to fill the regions—for example, a HeaderView class for the header region:</p><div class="mediaobject"><img src="graphics/B01962_02_03.jpg" alt="Layout"/><div class="caption"><p>Figure 2.3: A common web application layout</p></div></div><p>An implementation of this example could be something like this:</p><div class="informalexample"><pre class="programlisting">var AppLayout = new Layout({
  template: $('#app-layout').html(),
  regions: {
    header: 'header',
    sicebar: '#sidebar',
    footer: 'footer',
    main: '#main'
  }
});

Var layout = new AppLayout({ el: 'body' });
var header = new HeaderView();

layout.render();
layout.getRegion('header').show(header);</pre></div><p>See how regions <a id="id69" class="indexterm"/>are declared: a pair of names and a selector. The layout will<a id="id70" class="indexterm"/> expose the regions through the <code class="literal">getRegion()</code> method, which receives the name of the region and returns an instance of the <code class="literal">Region</code> class that can be used as seen in the previous section. </p><p>Also note that the layout needs to define a <code class="literal">template</code> property; it should follow the same rules used in the <code class="literal">ModelView</code> implementation. That template will define the HTML where regions will be pointed.</p><p>The following <a id="id71" class="indexterm"/>code shows how to create a Layout view:</p><div class="informalexample"><pre class="programlisting">class Layout extends ModelView {
  render() {
    // Clean up any rendered DOM
    this.closeRegions();

    // Render the layout template
    var result = ModelView.prototype.render.call(this);

    // Creand and expose the configurated regions
    this.configureRegions();
    return result;
  }

  configureRegions() {
    var regionDefinitions = this.regions || {};

    if (!this._regions) {
      this._regions = {};
    }

    // Create the configurated regions and save a reference
    // in the this._regions attribute
    _.each(regionDefinitions, (selector, name) =&gt; {
      let $el = this.$(selector);
      this._regions[name] = new Region({el: $el});
    });
  }

  // Get a Region instance for a named region
  getRegion(regionName) {
    // Ensure that regions is a valid object
    var regions = this._regions || {};
    return regions[regionName];
  }

  // Close the layout and all the regions on it
  remove(options) {
    ModelView.prototype.remove.call(this, options);
    this.closeRegions();
  }

  closeRegions() {
    var regions = this._regions || {};

    // Close each active region
    _.each(regions, region =&gt; {
      if (region &amp;&amp; region.remove) region.remove();
    });
  }
}</pre></div><p>The layout extends directly from <code class="literal">ModelView</code> so the <code class="literal">render()</code> method acts like in <code class="literal">ModelView</code>, but extends its behavior creating the necessary regions after rendering. The <code class="literal">configurateRegions()</code> method creates a region for every region declared on the <code class="literal">regions</code> property. Associations between region names and <code class="literal">Region</code> instances are stored in the _<code class="literal">regions</code> <a id="id72" class="indexterm"/>property, to be used on future references.</p><p>When a layout is removed, it should close any region opened, so that all resources are released cleanly. That's the job of the <code class="literal">closeRegions()</code> method; it iterates over all regions created with <code class="literal">configurateRegions()</code> and calls the <code class="literal">remove()</code> method for every region.</p><p>As the regions are stored in a private property called _<code class="literal">regions</code>, a method for accessing the regions is required; the <code class="literal">getRegion()</code> method returns the region instance associated with the name of the region.</p></div>
<div class="section" title="Putting it all together"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec18"/>Putting it all together</h1></div></div></div><p>We have created four <a id="id73" class="indexterm"/>simple but powerful new views types that can be used easily on projects, minimizing the effort and making less redundant code. In the next section, we will convert our contacts project into a more complex project, using what we have learned here:</p><div class="mediaobject"><img src="graphics/B01962_02_04.jpg" alt="Putting it all together"/><div class="caption"><p>Figure 2.4: Application root layout</p></div></div><p>Our application will <a id="id74" class="indexterm"/>have a root layout with three sections:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Header – Will contain a navigation bar</li><li class="listitem" style="list-style-type: disc">Footer – Copyright information</li><li class="listitem" style="list-style-type: disc">Main – This element shows all sub-applications on demand</li></ul></div><p>This layout description is not a Layout object; instead, it describes the HTM root content:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html lang=""&gt;
  &lt;head&gt;
    &lt;meta charset="utf-8"&gt;
    &lt;title&gt;mastering backbone design&lt;/title&gt;
    &lt;meta name="description" content=""&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt;

    &lt;link rel="shortcut icon" href="/favicon.ico"&gt;
    &lt;link rel="apple-touch-icon" href="/apple-touch-icon.png"&gt;
    &lt;!-- Place favicon.ico and apple-touch-icon.png in the root directory --&gt;

    &lt;link rel="stylesheet" href="css/bootstrap.min.css"&gt;
    &lt;link rel="stylesheet" href="css/sweetalert.css"&gt;
    &lt;link rel="stylesheet" href="css/pnotify.custom.min.css"&gt;
    &lt;link rel="stylesheet" href="css/font-awesome.min.css"&gt;
    &lt;link rel="stylesheet" href="css/main.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;!--[if lt IE 10]&gt;
      &lt;p class="browsehappy"&gt;You are using an &lt;strong&gt;outdated&lt;/strong&gt; browser. Please &lt;a href="http://browsehappy.com/"&gt;upgrade your browser&lt;/a&gt; to improve your experience.&lt;/p&gt;
    &lt;![endif]--&gt;

    &lt;nav class="navbar"&gt;
      &lt;div class="container"&gt;
        &lt;div class="navbar-header"&gt;
          &lt;a class="navbar-brand" href="#"&gt;
            Mastering Backbone.js
          &lt;/a&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/nav&gt;

    &lt;div id="main" class="container"&gt;&lt;/div&gt;

    &lt;script src="js/vendor/jquery-2.1.4.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/vendor/bootstrap.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/vendor/sweetalert.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/vendor/pnotify.custom.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/vendor/underscore-min.js"&gt;&lt;/script&gt;
    &lt;script src="js/vendor/backbone-min.js"&gt;&lt;/script&gt;

  &lt;/body&gt;
&lt;/html&gt;</pre></div><p>In this root layout, the<a id="id75" class="indexterm"/> header and footer are very straightforward, so is not necessary to create a separate view for them. There is a <code class="literal">main</code> div that will be our main region, for the whole application.</p><div class="section" title="Showing a list"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec19"/>Showing a list</h2></div></div></div><p>The <code class="literal">ContactList</code> subapplication is<a id="id76" class="indexterm"/> responsible for rendering the collection in the DOM. Thus, the <code class="literal">ContactList</code> object will instantiate the necessary views:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactList.js
showList(contacts) {
  // Create the views
  var layout = new ContactListLayout();
  var actionBar = new ContactListActionBar();
  var contactList = new ContactListView({collection: contacts});

  // Show the views
  this.region.show(layout);
  layout.getRegion('actions').show(actionBar);
  layout.getRegion('list').show(contactList);

  this.listenTo(contactList, 'item:contact:delete',
    this.deleteContact);
}</pre></div><p>A layout is created to put the <code class="literal">CollectionView</code> inside; the layout template has a <code class="literal">div</code> with a <code class="literal">contact-list-layout</code> id that will be used as the target region:</p><div class="informalexample"><pre class="programlisting">// index.html
&lt;script id="contact-list-layout" type="text/template"&gt;
  &lt;div class="actions-bar-container"&gt;&lt;/div&gt;
  &lt;div class="list-container"&gt;&lt;/div&gt;
  &lt;div class="footer text-muted"&gt;
    © 2015. &lt;a href="#"&gt;Mastering Backbone.js&lt;/a&gt; by &lt;a href="https://twitter.com/abieealejandro" target="_blank"&gt;Abiee Alejandro&lt;/a&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p>And the layout code is very simple:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactList.js
class ContactListLayout extends Layout {
  constructor(options) {
    super(options);
    this.template = '#contact-list-layout';
    this.regions = {
      actions: '.actions-bar-container',
      list: '.list-container'
    };
  }

  get className() {
    return 'row page-container';
  }
}</pre></div><p>The view that renders<a id="id77" class="indexterm"/> the collection of contacts is very straightforward because it just need to specify the <code class="literal">modelView </code>attribute:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactList.js
class ContactListView extends CollectionView {
  constructor(options) {
    super(options);
    this.modelView = ContactListItemView;
  }

  get className() {
    return 'contact-list';
  }
}</pre></div><p>The contact card template shows the contact name, phone number, email, and its social networks:</p><div class="informalexample"><pre class="programlisting">// index.html
&lt;script id="contact-list-item" type="text/template"&gt;
  &lt;div class="box thumbnail"&gt;
    &lt;div class="photo"&gt;
      &lt;img src="http://placehold.it/250x250"
        alt="Contact photo" /&gt;
      &lt;div class="action-bar clearfix"&gt;
        &lt;div class="action-buttons pull-right"&gt;
          &lt;button id="delete"
            class="btn btn-danger btn-xs"&gt;delete&lt;/button&gt;
          &lt;button id="view"
            class="btn btn-primary btn-xs"&gt;view&lt;/button&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
    &lt;div class="caption-container"&gt;
      &lt;div class="caption"&gt;
        &lt;h5&gt;&lt;%= name %&gt;&lt;/h5&gt;
        &lt;% if (phone) { %&gt;
          &lt;p class="phone no-margin"&gt;&lt;%= phone %&gt;&lt;/p&gt;
        &lt;% } %&gt;
        &lt;% if (email) { %&gt;
          &lt;p class="email no-margin"&gt;&lt;%= email %&gt;&lt;/p&gt;
        &lt;% } %&gt;
        &lt;div class="bottom"&gt;
          &lt;ul class="social-networks"&gt;
            &lt;% if (facebook) { %&gt;
            &lt;li&gt;
              &lt;a href="&lt;%= facebook %&gt;" title="Google Drive"&gt;
                &lt;i class="fa fa-facebook"&gt;&lt;/i&gt;
              &lt;/a&gt;
            &lt;/li&gt;
            &lt;% } %&gt;
            &lt;% if (twitter) { %&gt;
            &lt;li&gt;
              &lt;a href="&lt;%= twitter %&gt;" title="Twitter"&gt;
                &lt;i class="fa fa-twitter"&gt;&lt;/i&gt;
              &lt;/a&gt;
            &lt;/li&gt;
            &lt;% } %&gt;
            &lt;% if (google) { %&gt;
            &lt;li&gt;
              &lt;a href="&lt;%= google %&gt;" title="Google Drive"&gt;
                &lt;i class="fa fa-google-plus"&gt;&lt;/i&gt;
              &lt;/a&gt;
            &lt;/li&gt;
            &lt;% } %&gt;
            &lt;% if (github) { %&gt;
            &lt;li&gt;
              &lt;a href="&lt;%= github %&gt;" title="Github"&gt;
                &lt;i class="fa fa-github"&gt;&lt;/i&gt;
              &lt;/a&gt;
            &lt;/li&gt;
            &lt;% } %&gt;
          &lt;/ul&gt;
        &lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p>The <code class="literal">ContactListItemView</code> class should<a id="id78" class="indexterm"/> handle the delete and view events:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactList.js
class ContactListItemView extends ModelView {
  constructor(options) {
    super(options);
    this.template = '#contact-list-item';
  }

  get className() {
    return 'col-xs-12 col-sm-6 col-md-3';
  }

  get events() {
    return {
      'click #delete': 'deleteContact',
      'click #view': 'viewContact'
    };
  }

  initialize(options) {
    this.listenTo(options.model, 'change', this.render);
  }

  deleteContact() {
    this.trigger('contact:delete', this.model);
  }

  viewContact() {
    var contactId = this.model.get('id');
    App.router.navigate(`contacts/view/${contactId}`, true);
  }
}</pre></div><p>When the user clicks on the <span class="strong"><strong>Delete</strong></span> button, the view triggers a <code class="literal">contact:delete</code> event and lets the controller handle the deletion process. Because the <span class="strong"><strong>View</strong></span> button is simpler than the <span class="strong"><strong>Delete</strong></span>, we can redirect the user to the contact list from the view; note that delegating this very<a id="id79" class="indexterm"/> simple task to the controller will add more overhead without benefit.</p><p>The action bar allow the user to add new users.</p><div class="informalexample"><pre class="programlisting">&lt;script id="contact-list-action-bar" type="text/template"&gt;
  &lt;button class="btn btn-lg btn-success"&gt;
    Create a new contact
  &lt;/button&gt;
&lt;/script&gt;</pre></div><p>
<code class="literal">ContactListActionBar</code> just renders its template and waits for a click on its button.</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactList.js
class ContactListActionBar extends ModelView {
  constructor(options) {
    super(options);
    this.template = '#contact-list-action-bar';
  }

  get className() {
    return 'options-bar col-xs-12';
  }

  get events() {
    return {
      'click button': 'createContact'
    };
  }

  createContact() {
    App.router.navigate('contacts/new', true);
  }
}</pre></div><p>When the button is clicked, we redirect the user to the contact form to create a new user.</p></div><div class="section" title="Showing the details"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec20"/>Showing the details</h2></div></div></div><p>The contact details <a id="id80" class="indexterm"/>show a read-only version of a single contact; here you can see all the details of a given contact but no edition. The following screenshots shows how it looks:</p><div class="mediaobject"><img src="graphics/B01962_02_05.jpg" alt="Showing the details"/><div class="caption"><p>Figure 2.5: Contact details</p></div></div><p>To show a read-only version of a contact, we need to first define a layout:</p><div class="informalexample"><pre class="programlisting">&lt;script id="contact-view-layout" type="text/template"&gt;
  &lt;div class="row page-container"&gt;
    &lt;div id="contact-widget"
      class="col-xs-12 col-sm-4 col-md-3"&gt;&lt;/div&gt;
    &lt;div class="col-xs-12 col-sm-8 col-md-9"&gt;
      &lt;div class="row"&gt;
        &lt;div id="about-container"&gt;&lt;/div&gt;
        &lt;div id="call-log-container"&gt;&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
  &lt;div class="footer text-muted"&gt;
    © 2015. &lt;a href="#"&gt;Mastering Backbone.js&lt;/a&gt; by &lt;a href="https://twitter.com/abieealejandro" target="_blank"&gt;Abiee Alejandro&lt;/a&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p>The layout defines two regions, one for the widget at the left and another one for the main content:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactViewer.js
class ContactViewLayout extends Layout {
  constructor(options) {
    super(options);
    this.template = '#contact-view-layout';
    this.regions = {
      widget: '#contact-widget',
      about: '#about-container'
    };
  }

  get className() {
    return 'row page-container';
  }
}</pre></div><p>When <code class="literal">ContactViewLayout</code> is rendered, the widget and the about information should be rendered. The<a id="id81" class="indexterm"/> templates for these views are very simple, so for space reasons will not be shown here; if you want to see the details of the implementation, please go to the GitHub repo for this book.</p><p>The <code class="literal">ContactAbout</code> view includes three buttons to go back to the list, another to delete the contact, and a final one to edit it.</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactViewer.js
class ContactAbout extends ModelView {
  constructor(options) {
    super(options);
    this.template = '#contact-view-about';
  }

  get className() {
    return 'panel panel-simple';
  }

  get events() {
    return {
      'click #back': 'goToList',
      'click #delete': 'deleteContact',
      'click #edit': 'editContact'
    };
  }

  goToList() {
    App.router.navigate('contacts', true);
  }

  deleteContact() {
    this.trigger('contact:delete', this.model);
  }

  editContact() {
    var contactId = this.model.get('id');
    App.router.navigate(`contacts/edit/${contactId}`, true);
  }
}</pre></div><p>As we did in the <code class="literal">ContactList</code>, we will delegate the deletion process to the controller; views should not handle that business logic. However, the edit and go back button are simple URL redirections<a id="id82" class="indexterm"/> and can be implemented directly in the view.</p></div><div class="section" title="Editing information"><div class="titlepage"><div><div><h2 class="title"><a id="ch02lvl2sec21"/>Editing information</h2></div></div></div><p>Figure 2.6 shows<a id="id83" class="indexterm"/> how the edit form for the contacts should looks. The form view should be able to grab information from the input boxes and update the Contact model passed to it.</p><p>A layout template should be created here to separate the widget at the left from the form view at the right:</p><div class="informalexample"><pre class="programlisting">&lt;script id="contact-form-layout" type="text/template"&gt;
  &lt;div id="preview-container"
    class="col-xs-12 col-sm-4 col-md-3"&gt;&lt;/div&gt;
  &lt;div id="form-container"
    class="col-xs-12 col-sm-8 col-md-9"&gt;&lt;/div&gt;

  &lt;div class="footer text-muted"&gt;
    © 2015. &lt;a href="#"&gt;Mastering Backbone.js&lt;/a&gt; by &lt;a href="http://themeforest.net/user/Kopyov" target="_blank"&gt;Abiee Alejandro&lt;/a&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><div class="mediaobject"><img src="graphics/B01962_02_06.jpg" alt="Editing information"/><div class="caption"><p>Figure 2.6: Edit contact form</p></div></div><p>The layout <a id="id84" class="indexterm"/>defines two regions:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactFormLayout extends Layout {
  constructor(options) {
    super(options);
    this.template = '#contact-form-layout';
    this.regions = {
      preview: '#preview-container',
      form: '#form-container'
    };
  }

  get className() {
    return 'row page-container';
  }
}</pre></div><p>In order to edit a <a id="id85" class="indexterm"/>contact, we need to define a form:</p><div class="informalexample"><pre class="programlisting">// index.html
&lt;script id="contact-form" type="text/template"&gt;
  &lt;div class="panel panel-simple"&gt;
    &lt;div class="panel-heading"&gt;Edit contact&lt;/div&gt;
    &lt;div class="panel-body"&gt;
      &lt;form class="form-horizontal"&gt;
        &lt;div class="form-group"&gt;
          &lt;label for="name"
            class="col-sm-2 control-label"&gt;Name&lt;/label&gt;
          &lt;div class="col-sm-10"&gt;
            &lt;input id="name" type="text"
              class="form-control" placeholder="Full name"
              value="&lt;%= name %&gt;" /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        // ...
        
        &lt;hr /&gt;
        
        &lt;h4&gt;Contact info&lt;/h4&gt;
        &lt;div class="form-group"&gt;
          &lt;label for="name"
            class="col-sm-2 control-label"&gt;Phone&lt;/label&gt;
          &lt;div class="col-sm-10"&gt;
            &lt;input id="name" type="text"
              class="form-control"
              placeholder="(123) 456 7890" value="&lt;%= phone %&gt;" /&gt;
          &lt;/div&gt;
        &lt;/div&gt;
        // ...
      &lt;/form&gt;
    &lt;/div&gt;
    &lt;div class="panel-footer clearfix"&gt;
      &lt;div class="panel-buttons"&gt;
        &lt;button id="cancel" class="btn btn-default"&gt;Cancel&lt;/button&gt;
        &lt;button id="save" class="btn btn-success"&gt;Save&lt;/button&gt;
      &lt;/div&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p>For space reasons, I have eliminated the duplicated code in the book, but you can see the complete code in<a id="id86" class="indexterm"/> the GitHub repo. Please note that this form will be used for editing and creating new contacts. For each attribute in the model, an input is rendered with the contents of the attribute:</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js 
class ContactForm extends ModelView {
  constructor(options) {
    super(options);
    this.template = '#contact-form';
  }

  get className() {
    return 'form-horizontal';
  }

  get events() {
    return {
      'click #save': 'saveContact',
      'click #cancel': 'cancel'
    };
  }

  serializeData() {
    return _.defaults(this.model.toJSON(), {
      name: '',
      age: '',
      phone: '',
      email: '',
      address1: '',
      address2: ''
    });
  }

  saveContact(event) {
    event.preventDefault();
    this.model.set('name', this.getInput('#name'));
    this.model.set('phone', this.getInput('#phone'));
    this.model.set('email', this.getInput('#email'));
    this.model.set('address1', this.getInput('#address1'));
    this.model.set('address2', this.getInput('#address2'));
    this.model.set('facebook', this.getInput('#facebook'));
    this.model.set('twitter', this.getInput('#twitter'));
    this.model.set('google', this.getInput('#google'));
    this.model.set('github', this.getInput('#github'));
    this.trigger('form:save', this.model);
  }

  getInput(selector) {
    return this.$el.find(selector).val();
  }

  cancel() {
    this.trigger('form:cancel');
  }
}</pre></div><p>When the user <a id="id87" class="indexterm"/>clicks on the <span class="strong"><strong>Cancel</strong></span> button, it triggers a <code class="literal">form:cancel</code> event that is processed by the <code class="literal">ContactEditor</code> subapplication controller.</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js 
  cancel() {
    // Warn user before make redirection to prevent accidental
    // cencel
    App.askConfirmation('Changes will be lost', isConfirm =&gt; {
      if (isConfirm) {
        App.router.navigate('contacts', true);
      }
    });
  }</pre></div><p>When the model is rendered, it may or may not contain attributes due to the server response; for this reason, we extend the <code class="literal">serializeData()</code> method to assign default values.</p><p>When the user clicks on the <span class="strong"><strong>Save</strong></span> button, the <code class="literal">saveContact()</code> is called, it gets the data from the inputs and assigns new <a id="id88" class="indexterm"/>values to the model, then triggers a <code class="literal">form:save</code> event to be processed by the <code class="literal">ContactEditor </code>subapplication controller.</p><div class="informalexample"><pre class="programlisting">// apps/contacts/edit-contact.js 
  saveContact(contact) {
    contact.save(null, {
      success() {
        // Redirect user to contact list after save
        App.notifySuccess('Contact saved');
        App.router.navigate('contacts', true);
      },
      error() {
        // Show error message if something goes wrong
        App.notifyError('Something goes wrong');
      }
    });
  }</pre></div></div></div>
<div class="section" title="Rendering third-party plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec19"/>Rendering third-party plugins</h1></div></div></div><p>A common issue <a id="id89" class="indexterm"/>when rendering views is not rendering plugins from others because they are designed to work with traditional web applications but not with SPA; this is because many plugins are DOM-dependent, which means that the target element should exist in the actual DOM. To see this issue more clearly, let me show you an example with the jQueryUI Calendar plugin. Let's add a <code class="literal">birthdate</code> field to our <code class="literal">ContactEditor</code>, replacing the age field.</p><div class="informalexample"><pre class="programlisting">// index.html
// ...
&lt;div class="form-group"&gt;
  &lt;label for="birthdate"&gt;Birth date&lt;/label&gt;
  &lt;input id="birthdate " type="text"
    class="form-control" value="&lt;%= birthdate %&gt;" /&gt;
//...</pre></div><p>And make the proper changes in the view:</p><div class="informalexample"><pre class="programlisting">class ContactForm extends ModelView {
  // ...
  serializeData() {
    return _.defaults(this.model.toJSON(), {
      name: '',
      birthdate: '',
      // ...
    });
  },
  saveContact(event) {
    event.preventDefault();
    this.model.set('name', this.$el.find('#name').val());
    this.model.set('birthdate',
      this.$el.find('#birthdate').val()
    );
    // ...
  },
// ...
});</pre></div><p>To show a calendar on<a id="id90" class="indexterm"/> the <code class="literal">birthdate</code> field we need to call <code class="literal">$('#birthdate').datepicker()</code>somewhere, but what is the best place to do that?</p><div class="informalexample"><pre class="programlisting">// ... edit-contact.js
class ContactEditor {
  // ...

  showEditor(contact) {
    var contactForm = new ContactForm({model: contact});
    this.region.show(contactForm);
    contactForm.$('#birthdate').datepicker();

    this.listenTo(contactForm, 'form:save', this.saveContact);
    this.listenTo(contactForm, 'form:cancel', this.cancel);
  };
};</pre></div><p>After calling the <code class="literal">show()</code> method on the <code class="literal">region</code> object, the <code class="literal">contactForm</code> view is live in the DOM, so it makes sense to call the <code class="literal">datepicker()</code> method after that. However this is not a good strategy because our controller object knows about DOM elements, which are not its responsibility.</p><p>Views should be responsible for dealing with the DOM, so rendering third-party plugins is included. Another approach could be to extend the <code class="literal">render()</code> method on the <code class="literal">FormView</code> class but we already have the <code class="literal">onRender()</code> callback, which is called after the rendering process.</p><div class="informalexample"><pre class="programlisting">// ... edit-contact.js
var ContactForm extends ModelView {
  // ...
  onRender() {
    this.$('#birthdate').datepicker();
  },
  //...
});</pre></div><p>But this is not <a id="id91" class="indexterm"/>going to work because we are rendering the view on a region. Did you remember the <code class="literal">show()</code> method?</p><div class="informalexample"><pre class="programlisting">class Region {
// ...
  openView(view) {
    this.ensureEl();
    view.render();
    this.$el.html(view.el);
  }
// ...
}</pre></div><p>The showing process first renders the view in memory and after that makes it available on the DOM. That's why this doesn't work. The intent of the <code class="literal">onRender()</code> method is to make template changes before making them available on the DOM. We need to add a new callback method that will be called when the view is in the DOM.</p><div class="informalexample"><pre class="programlisting">class Region {
// ...
  openView(view) {
    this.ensureEl();
    view.render();
    this.$el.html(view.el);

    // Callback when the view is in the DOM
    if (view.onShow) {
      view.onShow();
    }
  }
// ...
}</pre></div><p>Remember to make this feature available in <code class="literal">CollectionView</code> too.</p><div class="informalexample"><pre class="programlisting">// common.js
class CollectionView extends Backbone.View {
  // ...
  onShow() {
    var children = this.children || {};
    _.each(children, child =&gt; {
      if (child.onShow) {
        child.onShow();
      }
    });
  }
}</pre></div><p>So, our <code class="literal">ContactForm</code> will end<a id="id92" class="indexterm"/> with something like this.</p><div class="informalexample"><pre class="programlisting">// apps/contacts/contactEditor.js
class ContactForm extends ModelView {
  // ...

  // Call the onShow method for each children
  onShow() {
    // Ensure that children exists
    var children = this.children || {};

    _.each(children, child =&gt; {
      if (child.onShow) {
        child.onShow();
      }
    });
  }
  //...
}</pre></div><p>Remember, most third-party plugins need to have the element in the DOM or they will not work, so you should call the plugin only after rendering the view. The best place to call plugins is in the extended view class so the responsibility for DOM manipulation is encapsulated in the view.</p></div>
<div class="section" title="Conclusions"><div class="titlepage"><div><div><h1 class="title"><a id="ch02lvl1sec20"/>Conclusions</h1></div></div></div><p>We started by creating common view types that are common for almost every project. Those views are simple in principle but powerful; we can effectively manage nested views without worrying about insufficient memory.</p><p>We learned that, by encapsulating common patterns in the <code class="literal">render()</code> method, we can create useful view types; in this chapter, we have seen four of them but if you are curious I encourage you to take a look at the Marionette framework, which works on top of Backbone.</p><p>Marionette includes all the views exposed here: <code class="literal">ItemView</code>, <code class="literal">CollectionView</code>, <code class="literal">LayoutView</code>, Regions. and other useful view types. Marionette objects behave very similarly to what we see here, so that you can easily interchange Marionette objects with those described in this chapter.</p><p>Plugins should be called only after the view is on the DOM, because most plugins are DOM-dependent. When rendering plugins, remember to do it in the view not outside it; the <code class="literal">onShow()</code> callback strategy ensures that the view is available on the DOM, and so is the best place to render third-party plugins.</p><p>In the next chapter, you will learn more about how to sync views and models. You will see how to manage complex data and render it effectively in views. Validation is an important feature for your application; you will learn how to validate models and use that information to display error messages on your views.</p></div></body></html>