- en: Picking
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拾取
- en: In the previous chapter, we covered how to use textures to add more detail to
    our 3D application. In this chapter, we'll learn how to interact with our WebGL
    application through a technique called **picking**. Picking refers to the ability
    to select objects in a 3D scene. The most common device used for picking is a
    computer mouse. However, picking can also be performed using other human computer
    interfaces, such as tactile screens and haptic devices. In this chapter, we will
    learn how picking can be implemented in WebGL.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了如何使用纹理来为我们的3D应用程序添加更多细节。在本章中，我们将学习如何通过一种称为**拾取**的技术与我们的WebGL应用程序进行交互。拾取指的是在3D场景中选择对象的能力。最常用的拾取设备是计算机鼠标。然而，拾取也可以使用其他人机界面进行，例如触觉屏幕和触觉设备。在本章中，我们将学习如何在WebGL中实现拾取。
- en: 'In this chapter, you will:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，您将：
- en: Learn how to select objects in a WebGL scene using the mouse.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用鼠标在WebGL场景中选择对象。
- en: Create and use offscreen framebuffers.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和使用离屏帧缓冲区。
- en: Learn what renderbuffers are and how they are used by framebuffers.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习渲染缓冲区是什么以及它们是如何被帧缓冲区使用的。
- en: Read pixels from framebuffers.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从帧缓冲区读取像素。
- en: Use color labels to perform object selection based on color.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用颜色标签根据颜色进行对象选择。
- en: Picking
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拾取
- en: Virtually any 3D computer-graphics application needs to provide mechanisms for
    the user to interact with the scene. For instance, in a game, you may want to
    point at your target and perform an action upon it. Or in a CAD system, you may
    want to be able to select an object in your scene and modify its properties. In
    this chapter, we’ll learn the basics of implementing these kinds of interactions
    in WebGL.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎任何3D计算机图形应用程序都需要提供用户与场景交互的机制。例如，在游戏中，您可能想要指向您的目标并对其执行操作。或者在CAD系统中，您可能想要能够选择场景中的对象并修改其属性。在本章中，我们将学习在WebGL中实现这些类型交互的基础知识。
- en: To start, we should point out that we can select objects by casting a ray (vector)
    from the camera position (also known as the eye position) into the scene and calculate
    the objects that lie along its path. This is known as **ray-casting** and involves
    detecting intersections between the ray and object surfaces in the scene.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们应该指出，我们可以通过从摄像机位置（也称为眼睛位置）向场景投射一条光线（向量）来选择对象，并计算沿其路径的对象。这被称为**光线投射**，涉及到检测场景中光线与对象表面的交点。
- en: '**Ray-Casting**'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**光线投射**'
- en: Ray-casting is the use of ray–surface intersection tests to solve a variety
    of problems in computer graphics and computational geometry. The term was first
    used in computer graphics in a 1982 paper by Scott Roth to describe a method for
    rendering constructive solid geometry models. If you're interested in learning
    more, check out [https://en.wikipedia.org/wiki/Ray_casting](https://en.wikipedia.org/wiki/Ray_casting).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 光线投射是使用光线-表面交点测试来解决计算机图形和计算几何中各种问题的方法。这个术语最早在1982年由Scott Roth在计算机图形学中使用，用来描述渲染构造实体几何模型的方法。如果您想了解更多信息，请查看[https://en.wikipedia.org/wiki/Ray_casting](https://en.wikipedia.org/wiki/Ray_casting)。
- en: That being said, in this chapter, we’ll implement picking based on object colors
    in an offscreen framebuffer, as it is a simpler and more foundational technique
    to help you understand how to interact with objects in a 3D application. If you're
    interested in ray-casting, you’ll find a section dedicated to this technique in
    [Chapter 10](7100b7e4-1a63-43f4-93ea-f109ca911607.xhtml), *Advanced Techniques*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，在本章中，我们将基于离屏帧缓冲区中的对象颜色实现拾取，因为这是一种更简单、更基础的技术，有助于您了解如何在3D应用程序中与对象交互。如果您对光线投射感兴趣，您将在第10章“高级技术”中找到一个专门介绍这一技术的部分。
- en: 'The basic idea behind picking is to assign a different identifier to every
    object in the scene and render the scene to an offscreen framebuffer. We will
    start by identifying objects with a unique color. When the user clicks on `canvas`,
    we go to the offscreen framebuffer and read the color of the pixel at the location
    of the click action. Since we assigned a unique color to each object in the offscreen
    buffer, we can use this color to identify the object that has been selected and
    perform an action upon it. The following diagram illustrates this concept:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 拾取背后的基本思想是为场景中的每个对象分配一个不同的标识符，并将场景渲染到离屏帧缓冲区中。我们将首先通过唯一颜色来识别对象。当用户点击`canvas`时，我们转到离屏帧缓冲区并读取点击动作位置的像素颜色。由于我们在离屏缓冲区中为每个对象分配了唯一颜色，我们可以使用这种颜色来识别被选中的对象并对其执行操作。以下图表说明了这个概念：
- en: '![](img/8e4b2ac5-0b64-464c-a786-6fe9a9c219c0.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/8e4b2ac5-0b64-464c-a786-6fe9a9c219c0.png)'
- en: 'An interesting example that may help explain picking is Duck Hunt, the popular
    Nintendo game from the 90s, where players used a physical plastic gun controller
    to hunt ducks:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 一个可能有助于解释拾取的有趣例子是90年代的流行任天堂游戏《鸭子射击》，玩家使用物理塑料枪控制器来射击鸭子：
- en: '![](img/0519b7af-6de7-43d2-9924-896a8fa9424d.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0519b7af-6de7-43d2-9924-896a8fa9424d.png)'
- en: Can you guess how the game determined whether the player hit a duck? That's
    right, picking! When the player points at a duck and pulls the trigger, the computer
    in the NES blacks out the screen and the Zapper diode in the gun begins reception.
    Then, the computer flashes a solid white block around the targets you’re supposed
    to be shooting at. The photodiode in the Zapper detects the change in light intensity
    and tells the computer that it’s pointed at a lit target block—in other words,
    you should receive a point because you hit the target. Of course, when you’re
    playing the game, you don’t notice the blackout and the targets flashing because
    it all happens in a fraction of a second. Pretty clever, right?
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 你能猜到游戏是如何确定玩家是否击中了一只鸭子吗？没错，是拾取！当玩家指向一只鸭子并拉动扳机时，NES中的计算机将屏幕变黑，枪中的Zapper二极管开始接收信号。然后，计算机在目标周围闪烁一个实心的白色方块。Zapper中的光电二极管检测到光强度的变化，并告诉计算机它指向了一个发光的目标方块——换句话说，你应该得分，因为你击中了目标。当然，当你玩游戏时，你不会注意到屏幕变黑和目标闪烁，因为这一切都在一秒钟内发生。非常聪明，对吧？
- en: Let's break down the steps for implementing our own form of picking in WebGL.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解在WebGL中实现我们自己的拾取形式的步骤。
- en: Setting up an Offscreen Framebuffer
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置离屏帧缓冲区
- en: As shown in [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*,
    the framebuffer is the final rendering destination in WebGL. The results of the
    rendering on your screen are the contents of the framebuffer. Assuming that `gl` is
    our WebGL context, every call to `gl.drawArrays`, `gl.drawElements`, and `gl.clear` will
    change the contents of the framebuffer.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如[第2章](d2019a49-9e84-448c-8799-e296187476d1.xhtml)中所示，*渲染*，帧缓冲区是WebGL中的最终渲染目的地。屏幕上渲染的结果是帧缓冲区的内容。假设`gl`是我们的WebGL上下文，每次调用`gl.drawArrays`、`gl.drawElements`和`gl.clear`都会改变帧缓冲区的内容。
- en: Instead of rendering to the default framebuffer, we can also render to a scene
    that is offscreen – we call this the offscreen framebuffer. This is the first
    step in implementing picking. To do so, we need to set up a new framebuffer and
    tell WebGL that we want to use it instead of the default one. Let's see how we
    can do that.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不仅可以渲染到默认帧缓冲区，还可以渲染到屏幕外的场景——我们称之为离屏帧缓冲区。这是实现拾取的第一步。为了做到这一点，我们需要设置一个新的帧缓冲区，并告诉WebGL我们想要使用它而不是默认的。让我们看看我们如何做到这一点。
- en: 'To set up a framebuffer, we need to create storage for at least two things:
    colors and depth information. We need to store the color for every fragment that
    is rendered in the framebuffer so we can create an image. Additionally, we need
    depth information to make sure that we have a scene where overlapping objects
    look consistent. If we do not have depth information, then we would not be able
    to tell, in the case of two overlapping objects, which object is at front and
    which one is at the back.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置帧缓冲区，我们需要为至少两件事创建存储：颜色和深度信息。我们需要存储帧缓冲区中渲染的每个片段的颜色，以便我们可以创建一个图像。此外，我们需要深度信息来确保场景中重叠的对象看起来是一致的。如果没有深度信息，那么在两个重叠对象的情况下，我们就无法判断哪个对象在前，哪个对象在后。
- en: To store colors, we will use a WebGL texture; to store depth information, we
    will use a renderbuffer.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为了存储颜色，我们将使用WebGL纹理；为了存储深度信息，我们将使用渲染缓冲区。
- en: Creating a Texture to Store Colors
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建纹理以存储颜色
- en: 'The code to create a texture should be pretty straightforward after reading [Chapter
    7](1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml), *Textures*:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读了第7章[纹理](1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml)之后，创建纹理的代码应该相当直接：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The only difference is that we do not have an image to bind to the texture,
    so when we call `gl.texImage2D`, the last argument is `null`. This is because
    we are allocating space to store colors for the offscreen framebuffer.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一的区别是我们没有图像绑定到纹理上，因此当我们调用`gl.texImage2D`时，最后一个参数是`null`。这是因为我们在为存储离屏帧缓冲区的颜色分配空间。
- en: It's important to note that the `width` and `height` of the texture are set
    to the `canvas` size. This is because we want to ensure that the offscreen framebuffer
    resembles the dimensions of our 3D scene.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，纹理的`width`和`height`被设置为`canvas`的大小。这是因为我们想要确保离屏帧缓冲区与我们的3D场景的尺寸相似。
- en: Creating a Renderbuffer to Store Depth Information
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建渲染缓冲区以存储深度信息
- en: Renderbuffers are used to provide storage for the individual buffers used in
    a framebuffer. The depth buffer (z-buffer) is an example of a renderbuffer. It
    is always attached to the screen framebuffer, which is the default rendering destination
    in WebGL.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 渲染缓冲区用于为帧缓冲区中使用的单个缓冲区提供存储。深度缓冲区（z缓冲区）是渲染缓冲区的一个例子。它始终附加到屏幕帧缓冲区，这是WebGL中的默认渲染目标。
- en: 'The code to create a renderbuffer looks like the following code:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 创建渲染缓冲区的代码如下：
- en: '[PRE1]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The first line of code creates the renderbuffer. Similar to other WebGL buffers,
    the renderbuffer needs to be bound before we can operate on it. The third line
    of code determines the storage size of the renderbuffer.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 第一行代码创建渲染缓冲区。类似于其他WebGL缓冲区，在我们可以操作它之前，需要绑定渲染缓冲区。第三行代码确定渲染缓冲区的存储大小。
- en: Please note that the size of the storage is the same as with the texture. Similar
    to before, we need to ensure that for every fragment (pixel) in the framebuffer,
    we have a color (stored in the texture) and a depth value (stored in the renderbuffer).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，存储的大小与纹理相同。类似于之前的情况，我们需要确保对于帧缓冲区中的每个片段（像素），我们都有一个颜色（存储在纹理中）和一个深度值（存储在渲染缓冲区中）。
- en: Creating a Framebuffer for Offscreen Rendering
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为离屏渲染创建帧缓冲区
- en: We need to create a framebuffer and attach the texture and the renderbuffer
    that we created in the previous example. Let's see how this works in code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要创建一个帧缓冲区，并附加我们在上一个示例中创建的纹理和渲染缓冲区。让我们看看这在代码中是如何工作的。
- en: 'First, we need to create a new framebuffer:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要创建一个新的帧缓冲区：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Similar to the VBO manipulation, we tell WebGL that we’re going to operate
    on this framebuffer by making it the currently bound framebuffer. We do so with
    the following instruction:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 与VBO操作类似，我们通过将帧缓冲区设置为当前绑定的帧缓冲区来告诉WebGL我们将要操作这个帧缓冲区。我们通过以下指令来完成：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With the framebuffer bound, the texture is attached by calling the following
    method:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在绑定帧缓冲区后，通过调用以下方法附加纹理：
- en: '[PRE4]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, the renderbuffer is attached to the bound framebuffer using the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下方式将渲染缓冲区附加到已绑定的帧缓冲区：
- en: '[PRE5]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, we clean up the bound buffers as usual with the following code:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们使用以下代码以通常的方式清理已绑定的缓冲区：
- en: '[PRE6]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: When the previously created framebuffer is unbound, the WebGL state machine
    goes back to rendering into the default screen framebuffer.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 当之前创建的帧缓冲区解除绑定时，WebGL状态机会回到渲染到默认屏幕帧缓冲区。
- en: Assigning One Color per Object in the Scene
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 场景中每个对象分配一种颜色
- en: To keep things simple, we will pick an object based on its primitive color.
    That is, we discard the shiny reflections or shadows, and render the object with
    its uniform color. This is important, because to pick an object based on a color,
    we need to make sure that the color is constant per object and that each object
    has a different unique color.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简化问题，我们将根据对象的原始颜色选择一个对象。也就是说，我们丢弃了闪亮的反射或阴影，并以均匀的颜色渲染对象。这很重要，因为要基于颜色选择对象，我们需要确保颜色对每个对象是恒定的，并且每个对象都有不同的独特颜色。
- en: We achieve constant coloring by telling the fragment shader to use only the
    material diffuse property to set the ESSL output color variable. We are assuming
    that each object has a unique diffuse property.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过告诉片段着色器只使用材料的漫反射属性来设置ESSL输出颜色变量，从而实现恒定着色。我们假设每个对象都有一个独特的漫反射属性。
- en: In situations where objects may share the same diffuse color, we can create
    a new ESSL uniform to store the picking color and make it unique for every object
    that's rendered into the offscreen framebuffer. This way, the objects will look
    the same when they are rendered on the screen, but their colors will be unique
    every time they are rendered into the offscreen framebuffer. Later in this chapter,
    we will implement this strategy along with other approaches for uniquely identifying
    objects.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在可能存在共享相同漫反射颜色的对象的情况下，我们可以创建一个新的ESSL统一变量来存储选择颜色，并使其对每个渲染到离屏帧缓冲区的对象都是唯一的。这样，当对象在屏幕上渲染时，它们看起来是相同的，但每次它们渲染到离屏帧缓冲区时，它们的颜色都是唯一的。在本章的后面部分，我们将实现这一策略，以及其他用于唯一识别对象的方案。
- en: 'For now, let''s assume that the objects in our scene have unique diffuse colors,
    as shown in the following diagram:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们假设场景中的对象具有独特的漫反射颜色，如下面的图所示：
- en: '![](img/782a5cbf-3790-45b8-a185-9ba22c6a21b8.png)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/782a5cbf-3790-45b8-a185-9ba22c6a21b8.png)'
- en: Let's see how to render the scene offscreen by using the framebuffer we just
    set up.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用我们刚刚设置的帧缓冲区来离屏渲染场景。
- en: Rendering to an Offscreen Framebuffer
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 渲染到离屏帧缓冲区
- en: In order to perform object selection using the offscreen framebuffer, we need
    to ensure that both framebuffers are synchronized. If the onscreen framebuffer
    and the offscreen framebuffer are not synchronized, we could miss crucial data,
    which may make our picking strategy inconsistent.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使用离屏帧缓冲区进行对象选择，我们需要确保两个帧缓冲区同步。如果屏幕帧缓冲区和离屏帧缓冲区不同步，我们可能会错过关键数据，这可能会使我们的选择策略不一致。
- en: A lack of consistency will limit the ability to read colors from the offscreen
    framebuffer and use them to identify objects in the scene.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性的缺乏将限制从离屏帧缓冲区读取颜色并用于识别场景中对象的能力。
- en: 'To ensure that the buffers are synchronized, we will create a custom `render` function.
    This function calls the `draw` function twice. First, when the offscreen buffer
    is bound, and a second time when the onscreen default framebuffer is bound. The
    code looks like this:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保缓冲区同步，我们将创建一个自定义的`render`函数。这个函数调用`draw`函数两次。首先，当离屏缓冲区绑定时，然后当屏幕默认帧缓冲区绑定时。代码如下：
- en: '[PRE7]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We tell our ESSL program to use only diffuse colors when rendering into the
    offscreen framebuffer using the `uOffscreen` uniform. The fragment shader contains
    the following code:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 我们告诉我们的ESSL程序在将渲染到离屏帧缓冲区时只使用漫反射颜色，使用`uOffscreen`统一变量。片段着色器包含以下代码：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The following diagram shows the behavior of the `render` function:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了`render`函数的行为：
- en: '![](img/a1e526e4-2fb8-4cd7-a463-630d3ec909f5.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a1e526e4-2fb8-4cd7-a463-630d3ec909f5.png)'
- en: Therefore, every time the scene updates, the `render` function is called instead
    of calling the `draw` function.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，每次场景更新时，都会调用`render`函数而不是调用`draw`函数。
- en: 'We change this in the `init` function:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在`init`函数中修改这一点：
- en: '[PRE9]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This way, the `scene` will be periodically updated using the `render` function
    instead of the original `draw` function.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，`scene`将使用`render`函数而不是原始的`draw`函数定期更新。
- en: Clicking on the Canvas
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 点击画布
- en: 'The next step is to capture and read the mouse coordinates of a user click
    from the offscreen framebuffer. We can use the standard `onmouseup` event from
    the `canvas` element in our webpage:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是从离屏帧缓冲区捕获并读取用户点击的鼠标坐标。我们可以使用网页中的`canvas`元素的标准的`onmouseup`事件：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Since the given `event` returns the mouse coordinates (`clientX` and `clientY`) from
    the top-left rather than the coordinates with respect to the `canvas`, we need
    to leverage the DOM hierarchy to know the total offset that we have around the
    `canvas` element.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 由于给定的`event`返回的是从左上角开始的鼠标坐标（`clientX`和`clientY`），而不是相对于`canvas`的坐标，我们需要利用DOM层次结构来了解围绕`canvas`元素的总偏移量。
- en: 'We can do this with a code fragment inside the `canvas.onmouseup` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`canvas.onmouseup`函数内的代码片段中这样做：
- en: '[PRE11]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The following diagram shows how we use the offset calculation to obtain the
    clicked `canvas` coordinates:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图显示了我们是如何使用偏移计算来获得点击的`canvas`坐标的：
- en: '![](img/aa7b4f9f-bf5b-47db-9d26-bf7bfa9c39a3.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/aa7b4f9f-bf5b-47db-9d26-bf7bfa9c39a3.png)'
- en: '[PRE12]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Also, we should take any possible page offset into account. The page offset
    is the result of scrolling, which affects the calculation of the coordinates.
    We want to obtain the same coordinates for the `canvas` every time, regardless
    of any scrolling. To do so, we add the following two lines of code just before
    calculating the clicked `canvas` coordinates:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还应该考虑任何可能的页面偏移。页面偏移是滚动的结果，它会影响坐标的计算。我们希望每次都能获得相同的`canvas`坐标，无论是否滚动。为此，我们在计算点击的`canvas`坐标之前添加以下两行代码：
- en: '[PRE13]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we calculate the `canvas` coordinates:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们计算`canvas`坐标：
- en: '[PRE14]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Remember that unlike the browser window, the `canvas` coordinates (and also
    the framebuffer coordinates for this purpose) start in the lower-left corner.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，与浏览器窗口不同，`canvas`坐标（以及为此目的的帧缓冲区坐标）从左下角开始。
- en: Reading Pixels from the Offscreen Framebuffer
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从离屏帧缓冲区读取像素
- en: 'We can now go to the offscreen buffer and read the color from the appropriate
    coordinates:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以转到离屏缓冲区并从适当的坐标读取颜色：
- en: '![](img/bf13007d-f3f2-452c-bdc7-9b4d40ad0772.png)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bf13007d-f3f2-452c-bdc7-9b4d40ad0772.png)'
- en: 'WebGL allows us to read back from a framebuffer using the `readPixels` function.
    As usual, having `gl` as the WebGL context variable within our context:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: WebGL允许我们使用`readPixels`函数从帧缓冲区读取。像往常一样，在我们的上下文中使用`gl`作为WebGL上下文变量：
- en: '| **Function** | **Description** |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| **函数** | **描述** |'
- en: '| `gl.readPixels(x, y, width, height, format, type, pixels)` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `gl.readPixels(x, y, width, height, format, type, pixels)` |'
- en: '`x` and `y`: Starting coordinates.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`和`y`：起始坐标。'
- en: '`width` and `height`: The extent of pixels to read from the framebuffer. In
    our example, we are just reading one pixel (where the user clicks), so this will
    be `1`, `1`.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`width`和`height`：从帧缓冲区读取的像素范围。在我们的例子中，我们只读取一个像素（用户点击的位置），所以这将会是`1`，`1`。'
- en: '`format`: Supports the `gl.RGBA` format.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`format`：支持`gl.RGBA`格式。'
- en: '`type:`: Supports the `gl.UNSIGNED_BYTE` type.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`type`：支持`gl.UNSIGNED_BYTE`类型。'
- en: '`pixels`: A typed array that will contain the results of querying the framebuffer.
    It needs to have sufficient space to store the results depending on the extent
    of the query (`x`, `y`, `width`, `height`). It supports the `Uint8Array` type.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`pixels`: 一个将包含查询帧缓冲区结果的类型化数组。它需要足够的空间来存储结果，这取决于查询的范围（`x`，`y`，`width`，`height`）。它支持`Uint8Array`类型。'
- en: '|'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Remember that WebGL works as a state machine; thus, many operations depend
    on the validity of its state. In this case, we need to ensure that the offscreen
    framebuffer that we want to read from is the currently bound one. To do so, we
    bind it by using `bindFramebuffer`. Putting everything together, the code looks
    like this:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，WebGL作为一个状态机工作；因此，许多操作都依赖于其状态的有效性。在这种情况下，我们需要确保我们想要从中读取的离屏帧缓冲区是当前绑定的。为此，我们使用`bindFramebuffer`来绑定它。将所有这些放在一起，代码看起来是这样的：
- en: '[PRE15]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Here, the size of the readout array is `1 * 1 * 4`. This means that it has one
    pixel of width times one pixel height times four channels, since the format is RGBA.
    You do not need to specify the size this way; this was done to demonstrate why
    the size is `4` when we are just retrieving one pixel.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，读取数组的尺寸是`1 * 1 * 4`。这意味着它有一个像素的宽度乘以一个像素的高度乘以四个通道，因为格式是RGBA。您不需要以这种方式指定大小；这样做是为了演示当我们只检索一个像素时，为什么大小是`4`。
- en: Looking for Hits
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 寻找命中
- en: Now, we will check whether the color obtained from the offscreen framebuffer
    matches any of the objects in our scene. Remember here that we are using colors
    as object labels. If the color matches one of the objects, then we call it a **hit**.
    If it does not, we call it a **miss**.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将检查从离屏帧缓冲区获取的颜色是否与场景中的任何对象匹配。记住，在这里我们使用颜色作为对象标签。如果颜色与其中一个对象匹配，那么我们称之为**命中**。如果不匹配，我们称之为**未命中**。
- en: 'When looking for hits, we compare each object''s diffuse color with the label
    obtained from the offscreen framebuffer. There is, however, an additional step
    to consider: each color channel comes back in a `[0, 255]` range while the object
    diffuse colors are in a `[0, 1]` range. We need to update this before we check
    for any possible hits. We can do so with a compare function:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在寻找命中点时，我们比较每个对象的漫反射颜色与从离屏帧缓冲区获得的标签。然而，还有一个需要考虑的额外步骤：每个颜色通道的返回范围是`[0, 255]`，而对象的漫反射颜色在`[0,
    1]`范围内。在我们检查任何可能的命中之前，我们需要更新这一点。我们可以使用比较函数来完成：
- en: '[PRE16]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the preceding code, we scale the diffuse property to a `[0, 255]` range and
    then compare each channel individually. We do not need to compare the alpha channel.
    If we had two objects with the same color but a different alpha channel, we could
    use the alpha channel in the comparison, but this is not the case in our example.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们将漫反射属性缩放到`[0, 255]`范围内，然后逐个比较每个通道。我们不需要比较alpha通道。如果我们有两个颜色相同但alpha通道不同的对象，我们可以在比较中使用alpha通道，但这种情况在我们的例子中并不适用。
- en: Also, it’s important to note that the comparison is not precise, as we are dealing
    with decimal values in the `[0, 1]` range. Because of that, we introduce a fudge
    factor by assuming that we have a hit after rescaling the colors and subtract
    the readout (object label) – the difference is less than one.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，需要注意的是，比较并不精确，因为我们正在处理`[0, 1]`范围内的十进制值。因此，我们通过假设在重新缩放颜色并减去读取（对象标签）后我们有一个命中，引入了一个调整因子——差异小于一。
- en: 'Then, we just iterate through the object list in our `scene` and check whether
    we have a hit or miss with the following code:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需遍历`scene`中的对象列表，并使用以下代码检查是否有命中或未命中：
- en: '[PRE17]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This code iterates through every object in our `scene` and assigns `pickedObject` to
    the matching object if we have a hit.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码遍历`scene`中的每个对象，并在我们有命中时将`pickedObject`分配给匹配的对象。
- en: Processing Hits
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理命中
- en: Processing a hit is a large concept that heavily depends on the type of application
    you’re using. For instance, if your application is a CAD system, you may want
    to retrieve the properties of the selected object so that you can edit or delete
    it. In contrast, if you’re developing a game, selecting an object may involve
    setting it as a target your character should fight next. As you would expect,
    this part needs to be adaptable to a variety of uses. That being said, we will
    soon cover a practical example where you can drag and drop objects in our scene.
    But first, we need to review some of the architectural updates of our application.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 处理碰撞是一个很大的概念，这很大程度上取决于您所使用的应用程序类型。例如，如果您的应用程序是一个CAD系统，您可能希望检索所选对象的属性，以便您可以编辑或删除它。相反，如果您正在开发一个游戏，选择一个对象可能涉及将其设置为角色接下来应该与之战斗的目标。正如您所预期的，这部分需要适应各种用途。话虽如此，我们很快就会提供一个实际例子，您可以在我们的场景中拖放对象。但首先，我们需要回顾一下我们应用程序的一些架构更新。
- en: Architectural Updates
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构更新
- en: We have replaced the `draw` function with the `render` function, as described earlier
    in this chapter.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经用`render`函数替换了`draw`函数，正如本章前面所描述的。
- en: There is now a new class: **Picker**. The source code for this class can be
    obtained from `common/js/Picker.js`. This class encapsulates the offscreen framebuffer
    and the code necessary to create, configure, and read from it. We’ve also updated
    the `Controls` class to notify the picker when the user clicks on the `canvas`.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有一个新的类：**Picker**。这个类的源代码可以从`common/js/Picker.js`获取。这个类封装了离屏帧缓冲区以及创建、配置和从中读取所需的代码。我们还更新了`Controls`类，以便在用户点击`canvas`时通知选择器。
- en: Now, let's see picking in action!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看选择操作的实际应用！
- en: 'Time for Action: Picking'
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：选择操作
- en: 'Let''s cover an example of this technique in action:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个这个技术实际应用的例子：
- en: 'Open the `ch08_01_picking.html` file using your browser. You will see a screen
    similar to this:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用您的浏览器打开`ch08_01_picking.html`文件。您将看到一个类似于以下的屏幕：
- en: '![](img/0f499544-cff5-4e56-b5c5-da397d1bb492.png)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![](img/0f499544-cff5-4e56-b5c5-da397d1bb492.png)'
- en: Here, you have a set of objects, each one of which has a unique diffuse color
    property. As was the case in previous examples, you can move the camera around
    the scene. Also, note that the cube has a texture and that the flat disk is translucent.
    As you may expect, the code in the `draw` function handles textures, coordinates,
    and also transparencies, so it looks a bit more complex than before (you can check
    it out in the source code). This is a more realistic `draw` function. In a real
    application, you will have to handle these cases.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，您有一组对象，每个对象都有一个独特的漫反射颜色属性。与之前的示例一样，您可以围绕场景移动相机。请注意，立方体有一个纹理，而扁平的圆盘是半透明的。正如您所期望的，`draw`函数中的代码处理纹理、坐标以及透明度，因此看起来比之前复杂一些（您可以在源代码中查看）。这是一个更现实的`draw`函数。在实际应用中，您将不得不处理这些情况。
- en: 'Click on the sphere and drag it around the scene. Notice that the object becomes
    translucent. Also, note that the displacement occurs along the axis of the camera.
    To make this evident, please go to your web browser''s `console` and type in the
    following:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击球体并在场景中拖动它。请注意，对象变得半透明。此外，请注意位移沿着相机的轴线发生。为了使这一点更加明显，请前往您的网页浏览器的`控制台`并输入以下内容：
- en: '[PRE18]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Once you resume the clock by clicking inside of the scene, you will see that
    the camera updates its position to an elevation of zero degrees, as shown in the
    following screenshot:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您通过在场景内点击来恢复时钟时，您将看到相机更新其位置到零度仰角，如下面的截图所示：
- en: '![](img/099b8e82-7e3e-4a57-926e-98feb259148b.png)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![](img/099b8e82-7e3e-4a57-926e-98feb259148b.png)'
- en: JavaScript Console
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 控制台
- en: 'Firefox: Tools | WebDeveloper | WebConsole'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Firefox：工具 | 网页开发者 | 网页控制台
- en: 'Safari: Develop | Show Web Inspector'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: Safari：开发 | 显示网页检查器
- en: 'Chrome: Tools | Javascript Console'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: Chrome：工具 | JavaScript 控制台
- en: When you click and drag objects in the scene from this perspective, you will
    see that they change their position according to the camera's axis. In this case,
    the up axis of the camera is aligned with the scene's y-axis. If you move an object
    up and down, you will see that they change their position in the `y` coordinate.
    If you change the camera position (by clicking on the background and dragging
    the mouse around), and then move a different object, you will see that the object
    moves according to the camera’s new y-axis.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您从这一视角点击并拖动场景中的对象时，您会看到它们根据摄像机的轴线改变位置。在这种情况下，摄像机的向上轴线与场景的y轴线对齐。如果您上下移动一个对象，您会看到它们在`y`坐标上的位置发生变化。如果您更改摄像机位置（通过点击背景并拖动鼠标），然后移动不同的对象，您会看到对象根据摄像机的新y轴线移动。
- en: Try different camera angles and see what happens.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试不同的摄像机角度，看看会发生什么。
- en: Let's see what the offscreen framebuffer looks like. Click on the Show Picking
    Imagebutton. Here, we are instructing the fragment shader to use each of the object
    diffuse properties to color the fragments. You can also rotate the scene and pick
    objects in this mode. If you want to go back to the original shading method, click
    on Show Picking Image again to deactivate it.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们看看离屏帧缓冲区看起来像什么。点击“显示拾取图像”按钮。在这里，我们指示片段着色器使用每个对象的漫反射属性来着色片段。您也可以在这种方式下旋转场景并拾取对象。如果您想回到原始着色方法，再次点击“显示拾取图像”以取消激活它。
- en: To reset the scene, click on **Reset Scene**.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重置场景，请点击**重置场景**。
- en: '***What just happened?***'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '***刚才发生了什么？***'
- en: We have seen an example of picking in action. The source code uses the `Picker` class
    that we previously described in the *Architectural Updates* section. Let's examine
    it a bit closer.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一个拾取操作的示例。源代码使用了我们在*架构更新*部分之前描述的`Picker`类。让我们更仔细地看看它。
- en: Picker Architecture
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 拾取架构
- en: 'As you may have noticed, every picker state has a callback function associated
    with it. The following process outlines what happens in the `Picker` class when
    the user clicks the mouse on the `canvas`, drags it, and releases it:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您可能已经注意到的，每个拾取状态都与一个回调函数相关联。以下过程概述了当用户在`canvas`上点击鼠标、拖动它并释放时，`Picker`类中发生的情况：
- en: '| **State** | **Callback** |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **状态** | **回调** |'
- en: '| `Picker` searches for a hit | `hitPropertyCallback(object)`: This callback
    informs the picker about which object property to use to make the comparison with
    the retrieved color from the offscreen framebuffer. |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| `Picker`搜索命中项 | `hitPropertyCallback(object)`: 此回调通知拾取器使用哪个对象属性来与从离屏帧缓冲区检索到的颜色进行比较。
    |'
- en: '| User drags mouse in picking mode | `moveCallback(dx, dy)`: When the picking
    mode is activated (by having picked at least one object), this callback allows
    us to move the objects in the picking list (hits). This list is maintained internally
    by the `Picker` class. |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| 用户在拾取模式下拖动鼠标 | `moveCallback(dx, dy)`: 当拾取模式被激活（通过至少拾取一个对象）时，此回调允许我们移动拾取列表（命中项）中的对象。此列表由`Picker`类内部维护。
    |'
- en: '| Remove hit from picking list | `addHitCallback(object)`: If we click on an
    object and this object is not in the picking list, the picker notifies the application
    by triggering this callback. |'
  id: totrans-137
  prefs: []
  type: TYPE_TB
  zh: '| 从拾取列表中移除命中项 | `addHitCallback(object)`: 如果我们点击一个对象，而这个对象不在拾取列表中，拾取器将通过触发此回调来通知应用程序。
    |'
- en: '| Add hit to picking list | `removeHitCallback(object)`: If we click on an
    object and this object is already in the picking list, the picker will remove
    it from the list and then it will inform the application by triggering this callback.
    |'
  id: totrans-138
  prefs: []
  type: TYPE_TB
  zh: '| 将命中项添加到拾取列表 | `removeHitCallback(object)`: 如果我们点击一个对象，而这个对象已经在拾取列表中，拾取器将将其从列表中移除，然后通过触发此回调来通知应用程序。
    |'
- en: '| End Picking Mode | `processHitsCallback(hits)`: If the user releases the
    mouse button while the *Shift *key is not pressed, the picking mode finishes and
    the application is notified by triggering this callback. If the *Shift* key is
    pressed, then the picking mode continues, and the picker waits for a new click
    to continue looking for hits. |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| 结束拾取模式 | `processHitsCallback(hits)`: 如果用户在未按下*Shift*键的情况下释放鼠标按钮，拾取模式结束，并且应用程序将通过触发此回调来得到通知。如果按下*Shift*键，则拾取模式继续，拾取器等待新的点击以继续寻找命中项。
    |'
- en: Implementing Unique Object Labels
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现独特的对象标签
- en: We previously mentioned that picking based on the diffuse property could be
    difficult if two or more objects in the scene share the same diffuse color. If
    that were the case and you selected one of them, how could you determine which
    one is picked based on its color? In the following *Time for Action* section,
    we will implement unique object labels. The objects will be rendered in the offscreen
    framebuffer using these color labels instead of the diffuse colors. The scene
    will still be rendered on the screen using the non-unique diffuse colors.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，如果场景中的两个或多个对象具有相同的漫反射颜色，基于漫反射属性进行选择可能会很困难。如果情况如此，并且你选择了其中之一，你将如何确定基于其颜色选择的是哪一个？在下面的*行动时间*部分，我们将实现独特的对象标签。对象将使用这些颜色标签而不是漫反射颜色在离屏帧缓冲区中渲染。场景仍然将使用非独特的漫反射颜色在屏幕上渲染。
- en: 'Time for Action: Unique Object Labels'
  id: totrans-142
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间：独特的对象标签
- en: 'This section is divided into two parts. In the first part, you will develop
    code to generate a random scene with cones and cylinders. Each object will be
    assigned a unique object label that will be used for coloring the object in the
    offscreen renderbuffer. In the second part, we will configure the picker to work
    with unique labels. Let''s get started:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 本节分为两部分。在第一部分，你将开发代码以生成包含圆锥体和圆柱体的随机场景。每个对象将被分配一个独特的对象标签，该标签将用于在离屏渲染缓冲区中着色对象。在第二部分，我们将配置选择器以使用独特的标签。让我们开始吧：
- en: Open the `ch08_02_picking-initial.html` file in your browser. This is a scene
    that is only showing the floor object. We are going to create a scene that contains
    multiple objects that can be either balls or cylinders.
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`ch08_02_picking-initial.html`文件。这是一个只显示地板对象的场景。我们将创建一个包含多个对象（可以是球体或圆柱体）的场景。
- en: Open `ch08_02_picking-initial.html` in a source code editor.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在源代码编辑器中打开`ch08_02_picking-initial.html`。
- en: 'We will write code so that each object in the scene can have the following:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将编写代码，以便场景中的每个对象都可以具有以下属性：
- en: A position assigned randomly
  id: totrans-147
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 随机分配的位置
- en: A unique object label color
  id: totrans-148
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 独特的对象标签颜色
- en: A non-unique diffuse color
  id: totrans-149
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非独特的漫反射颜色
- en: A scale factor that will determine the size of the object
  id: totrans-150
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定对象大小的比例因子
- en: We have provided empty functions that you will implement in this section.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经提供了空函数，你将在本节中实现它们。
- en: 'Let''s write the `positionGenerator` function. Scroll down to it and add the
    following code:'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写`positionGenerator`函数。向下滚动到它并添加以下代码：
- en: '[PRE19]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, we are using the `Math.random` function to generate the `x` and `z` coordinates
    for an object in the scene. Since `Math.random` always returns a positive number,
    we use the `flagX` and `flagZ` variables to randomly distribute the objects on
    the `x`-`z` plane (floor). Also, because we want all of the objects to be on the
    `x`-`z` plane, the `y` component is always set to `0` in the `return` statement.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，我们使用`Math.random`函数生成场景中对象的`x`和`z`坐标。由于`Math.random`始终返回一个正数，我们使用`flagX`和`flagZ`变量在`x`-`z`平面（地板）上随机分布对象。此外，因为我们希望所有对象都在`x`-`z`平面上，所以在`return`语句中将`y`分量始终设置为`0`。
- en: 'Let''s write a unique object label generator function. Scroll to the empty
    `objectLabelGenerator` function and add the following code:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个独特的对象标签生成函数。滚动到空的`objectLabelGenerator`函数并添加以下代码：
- en: '[PRE20]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We create a random color using the `Math.random` function. If the `key` variable
    is already a property of the `colorset` object, then we call the `objectLabelGenerator` function
    recursively to get a new value; otherwise, we make `key` a property of `colorset` and
    then `return` the respective color. Notice how well the handling of JavaScript
    objects as sets allows us to resolve any possible key collision.
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用`Math.random`函数创建一个随机颜色。如果`key`变量已经是`colorset`对象的属性，那么我们将递归调用`objectLabelGenerator`函数以获取新值；否则，我们将`key`作为`colorset`的属性，然后`return`相应的颜色。注意，JavaScript对象作为集合的处理方式如何使我们能够解决任何可能的关键冲突。
- en: 'Write the `diffuseColorGenerator` function. We will use this function to assign
    diffuse properties to the objects:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`diffuseColorGenerator`函数。我们将使用此函数为对象分配漫反射属性：
- en: '[PRE21]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This function represents the case where we want to generate colors that are
    not unique. The index parameter represents the index of the object in the `scene.objects` list
    to which we are assigning the diffuse color. In this function, we are creating
    a gray-level color since the `r`, `g`, and `b` components in the `return` statement
    all have the same `color` value.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数表示我们想要生成非唯一颜色的情形。`index`参数表示我们正在分配漫反射颜色的`scene.objects`列表中对象的索引。在此函数中，我们创建了一个灰度颜色，因为`return`语句中的`r`、`g`和`b`组件都具有相同的`color`值。
- en: 'The `diffuseColorGenerator` function will create collisions every `30` indices.
    The remainder of the division of the index by `30` will create a loop in the sequence:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`diffuseColorGenerator`函数将在每个`30`个索引处创建碰撞。索引除以`30`的余数将在序列中创建循环：'
- en: '[PRE22]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Since this result is being divided by `60`, the result will be a number in the `[0,
    0.5]` range. Then, we add `0.2` to make sure that the minimum value that `color`
    has is `0.2`. This way, the objects will not look too dark during the onscreen
    rendering (they would be black if the calculated diffuse color were `0`).
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于此结果被除以`60`，结果将是一个在`[0, 0.5]`范围内的数字。然后，我们添加`0.2`以确保`color`的最小值是`0.2`。这样，在屏幕渲染期间对象看起来不会太暗（如果计算的漫反射颜色是`0`，它们将是黑色的）。
- en: 'The last auxiliary function we will write is the `scaleGenerator` function:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将要编写的最后一个辅助函数是`scaleGenerator`函数：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This function will allow us to have objects of different sizes. `0.3` is added
    to control the minimum scaling factor that any object will have in the scene.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数将允许我们拥有不同大小的对象。`0.3`被添加以控制场景中任何对象的最小缩放因子。
- en: Let's load `100` objects to our scene. By the end of this section, you will
    be able to test picking on any of them!
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在场景中加载`100`个对象。到本节结束时，你将能够测试它们中的任何一个的拾取！
- en: 'Go to the `load` function and edit it so that it looks like this:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往`load`函数并编辑它，使其看起来像这样：
- en: '[PRE24]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The picking color is represented by the `pcolor` attribute. This attribute is
    passed in a list of attributes to the `scene.load` function. Once the object is
    loaded (using **JSON/Ajax**), `load` uses this list of attributes and adds them
    as object properties.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择颜色由`pcolor`属性表示。此属性作为属性列表传递给`scene.load`函数。一旦对象被加载（使用**JSON/Ajax**），`load`将使用此属性列表并将它们添加为对象属性。
- en: 'The shaders in this exercise have already been set up for you. The `pcolor` property
    that corresponds to the unique object label is mapped to the `uPickingColor` uniform,
    and the `uOffscreen` uniform determines whether it is used in the fragment shader:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 本练习中的着色器已经为你设置好了。与唯一对象标签对应的`pcolor`属性映射到`uPickingColor`统一变量，而`uOffscreen`统一变量确定是否在片段着色器中使用：
- en: '[PRE25]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'As described previously, we keep the offscreen and onscreen buffers in sync
    by using the `render` function as follows:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如前所述，我们通过使用以下`render`函数来保持离屏和屏幕缓冲区同步：
- en: '[PRE26]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Save your work as `ch08_03_picking-no-picker.html`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将你的工作保存为`ch08_03_picking-no-picker.html`。
- en: Open `ch08_03_picking-no-picker.html` in your browser.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的浏览器中打开`ch08_03_picking-no-picker.html`。
- en: Click on Show Picking Image. What happens?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“显示拾取图像”。会发生什么？
- en: The scene is being rendered to both the offscreen and default onscreen framebuffer.
    However, we have not configured the `Picker` callbacks yet.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 场景正在被渲染到离屏和默认的屏幕帧缓冲区。然而，我们尚未配置`Picker`回调。
- en: Open `ch08_03_picking-no-picker.html` in your source code editor.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的源代码编辑器中打开`ch08_03_picking-no-picker.html`。
- en: 'Scroll down to the `configure` function. The picker is already set up for you:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到`configure`函数。拾取器已经为你设置好了：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code fragment maps functions in the web page to picker callback hooks.
    These callbacks are invoked according to the picking state.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码片段将网页中的函数映射到拾取回调钩子。这些回调根据拾取状态被调用。
- en: We will now implement the necessary callbacks. Again, we have provided empty
    functions that you will need to code.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将实现必要的回调。同样，我们提供了空函数，你需要编写代码。
- en: 'Let''s create the `hitProperty` function. Scroll down to the empty `hitProperty` function
    and add the following code:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们创建`hitProperty`函数。滚动到空的`hitProperty`函数并添加以下代码：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We are returning the `pcolor` property to make the comparison with the color
    that will be read from the offscreen framebuffer. If these colors match, then
    we have a hit.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们正在返回`pcolor`属性，以便与从离屏帧缓冲区读取的颜色进行比较。如果这些颜色匹配，那么我们就有一个碰撞。
- en: 'Write the `addHit` and `removeHit` functions. We want to create the effect
    where the diffuse color is changed to the picking color during picking. We need
    an extra property to temporarily save the original diffuse color so that we can
    restore it later:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写`addHit`和`removeHit`函数。我们想要创建在拾取期间将漫反射颜色更改为拾取颜色的效果。我们需要一个额外的属性来临时保存原始漫反射颜色，以便我们可以在稍后恢复它：
- en: '[PRE29]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `addHit` function stores the current diffuse color in an auxiliary property
    named `previous`. Then, it changes the diffuse color to `pcolor`, the object-picking
    label:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`addHit`函数将当前漫反射颜色存储在一个名为`previous`的辅助属性中。然后，它将漫反射颜色更改为`pcolor`，即对象拾取标签：'
- en: '[PRE30]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The `removeHit` function restores the diffuse color.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`removeHit`函数会恢复漫反射颜色。'
- en: 'Now, let''s write the code for `processHits`:'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编写`processHits`的代码：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Remember that `processHits` is called upon exiting picking mode. This function
    will receive one parameter: the `hits` that the `picker` detected. Each element
    of the `hits` list is an object in `scene`. In this case, we want to give the
    hits their diffuse color back. For that, we use the previous property that we
    set in the `addHit` function.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请记住，`processHits`在退出拾取模式时被调用。此函数将接收一个参数：`picker`检测到的`hits`。`hits`列表中的每个元素都是`scene`中的一个对象。在这种情况下，我们希望将漫反射颜色还给击中点。为此，我们使用在`addHit`函数中设置的`previous`属性。
- en: 'The last picker callback we need to implement is the `movePickedObjects` function:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要实现的最后一个拾取回调函数是`movePickedObjects`函数：
- en: '[PRE32]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This function allows us to move the objects in the hits list interactively.
    The parameters that this callback function receives are as follows:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此函数允许我们交互式地移动`hits`列表中的对象。此回调函数接收的参数如下：
- en: '`dx`: Displacement in the horizontal direction obtained from the mouse when
    it is dragged on `canvas`'
  id: totrans-198
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dx`：当鼠标在`canvas`上拖动时从鼠标获得的水平方向位移'
- en: '`dy`: Displacement in the vertical direction obtained from the mouse when it
    is dragged on `canvas`'
  id: totrans-199
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dy`：当鼠标在`canvas`上拖动时从鼠标获得的垂直方向位移'
- en: 'Let''s analyze the code. First, we retrieve all of the hits from the picker
    instance:'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们分析一下代码。首先，我们从拾取实例中检索所有击中点：
- en: '[PRE33]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'If there are no hits, the function `returns` immediately:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果没有击中点，函数将立即返回：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'We calculate a weighing factor that we will use later (the fudge factor):'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们计算一个将在以后使用的加权因子（调整因子）：
- en: '[PRE35]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We create a loop to go through the hits list so that we can update each object''s
    position:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们创建一个循环来遍历击中点列表，以便我们可以更新每个对象的位置：
- en: '[PRE36]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `scaleX` and `scaleY` variables are initialized for every hit.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个击中点，`scaleX`和`scaleY`变量都会被初始化。
- en: The *Alt* key is being used to perform dollying (moving the camera along its
    normal path). In this case, we want to move the objects that are in the picking
    list along the camera's normal direction when the user is pressing the *Alt* key
    to provide a consistent user experience.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*Alt*键正在被用来执行推拉（沿着相机的法线路径移动相机）。在这种情况下，当用户按下*Alt*键以提供一致的用户体验时，我们希望沿着相机的法线方向移动拾取列表中的对象。'
- en: 'To move the hits along the camera normal, we use the `dy` (up-down) displacement,
    as follows:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要沿着相机的法线移动击中点，我们使用`dy`（上下）位移，如下所示：
- en: '[PRE37]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This creates a scaled version of `camera.normal` and stores it into the `scaleY` variable.
    Notice that `vec3.scale` is an operation that's available in the **glMatrix** library.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这创建了一个`camera.normal`的缩放版本，并将其存储到`scaleY`变量中。请注意，`vec3.scale`是**glMatrix**库中可用的一种操作。
- en: 'If the user is not pressing the *Alt* key, then we use `dx` (left-right) and `dy` (up-down)
    to move the hits in the camera plane. Here, we use the camera''s up and right vectors
    to calculate the `scaleX` and `scaleY` parameters:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果用户没有按下*Alt*键，则我们使用`dx`（左右）和`dy`（上下）在相机平面内移动击中点。在这里，我们使用相机的向上和向右向量来计算`scaleX`和`scaleY`参数：
- en: '[PRE38]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We update the position of the hit:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们更新击中点的位置：
- en: '[PRE39]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Save the page as `ch08_04_picking-final.html` and open it using your browser.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面保存为`ch08_04_picking-final.html`，并使用您的浏览器打开它。
- en: 'You will see a scene like the one shown in the following screenshot:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您将看到如下截图所示的场景：
- en: '![](img/2bd69814-1dd5-46af-999e-fd484bdd46ca.png)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2bd69814-1dd5-46af-999e-fd484bdd46ca.png)'
- en: Click on Reset Sceneseveral times and verify that you get a new scene every
    time.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 多次点击“重置场景”，并验证每次都得到一个新的场景。
- en: 'In this scene, all of the objects have very similar colors. However, each one
    has a unique picking color. To verify this, click on the Show Picking Imagebutton.
    You will see on the screen what is being rendered in the offscreen buffer:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个场景中，所有对象的颜色非常相似。然而，每个对象都有一个独特的拾取颜色。为了验证这一点，点击“显示拾取图像”按钮。您将在屏幕上看到在离屏缓冲区中渲染的内容：
- en: '![](img/dfb44a14-ec34-468b-943f-c7a6dda3fe47.png)'
  id: totrans-222
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/dfb44a14-ec34-468b-943f-c7a6dda3fe47.png)'
- en: 'Let''s validate the changes that we made to the picker callbacks. Let''s start
    by picking one object. As you can see, the object diffuse color becomes its picking
    color (this was the change you implemented in the `addHit` function):'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们验证我们对选择器回调所做的更改。让我们先选择一个对象。正如你所看到的，对象的漫反射颜色变成了选择颜色（这是你在`addHit`函数中实现的变化）：
- en: '![](img/25e09a6f-fd71-4710-bd82-b4883b0ebcd5.png)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/25e09a6f-fd71-4710-bd82-b4883b0ebcd5.png)'
- en: When the mouse is released, the object goes back to the original color. This
    is the change that was implemented in the `processHits` function.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当鼠标释放时，对象会恢复到原始颜色。这是在`processHits`函数中实现的变化。
- en: While the mouse button is held down over an object, you can drag it around.
    When this is done, `movePickedObjects` is being invoked.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当鼠标按钮压在对象上时，你可以拖动它。当这样做完成后，`movePickedObjects`将被调用。
- en: 'Pressing the *Shift* key while objects are being selected will tell the picker
    not to exit **picking mode**. This way, you can select and move more than one
    object at once:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择对象时按下*Shift*键将告诉选择器不要退出**选择模式**。这样，你可以一次选择并移动多个对象：
- en: '![](img/ac02ecf1-a6fa-4aaf-a67c-c10dcb844700.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ac02ecf1-a6fa-4aaf-a67c-c10dcb844700.png)'
- en: You will exit picking mode if you select an object and the *Shift* key is no
    longer pressed or if your next click does not produce any hits (in other words,
    clicking anywhere else).
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你选择了一个对象并且没有按下*Shift*键，或者你的下一次点击没有产生任何击中（换句话说，点击其他任何地方），你将退出选择模式。
- en: If you have any problems with this exercise or missed one of the steps, we have
    included the complete exercise in the `ch08_03_picking-no-picker.html` and `ch08_04_picking-final.html` files.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你在这个练习中遇到任何问题或遗漏了某个步骤，我们已经在`ch08_03_picking-no-picker.html`和`ch08_04_picking-final.html`文件中包含了完整的练习。
- en: '***What just happened?***'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '***发生了什么？***'
- en: 'We have done the following:'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 我们做了以下几步：
- en: Created the property-picking color. This property is unique for every object
    in the scene and allows us to implement picking based on it.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了属性选择颜色。这个属性对于场景中的每个对象都是唯一的，并允许我们根据它实现选择。
- en: Modified the fragment shader to use the picking color property by including
    a new uniform, `uPickingColor`, and mapping this uniform to the `pcolor` object
    property.
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 修改了片段着色器以使用选择颜色属性，通过包含一个新的统一变量`uPickingColor`并将此统一变量映射到`pcolor`对象属性。
- en: Learned about the different picking states. We have also learned how to modify
    the `Picker` callbacks to perform specific application logic such as removing
    picked objects from the scene.
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习了不同的选择状态。我们还学习了如何修改`Picker`回调以执行特定的应用程序逻辑，例如从场景中移除被选择的对象。
- en: 'Have a Go: Clearing the Scene'
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试：清除场景
- en: Rewrite the `processHits` function to remove the balls in the hit list from
    the scene. If the user has removed all of the balls from the scene, display a
    message with the elapsed time for accomplishing this task.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 重新编写`processHits`函数以从场景中移除被击中的球体。如果用户已经从场景中移除了所有的球体，显示完成此任务所需的时间信息。
- en: Hint
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use `scene.remove(objectName)` in the `processHits` function if the alias starts
    with `ball_`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 如果别名以`ball_`开头，在`processHits`函数中使用`scene.remove(objectName)`退出选择模式。
- en: Hint
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Once the hits are removed from the scene, revisit the `scene.objects` list and
    make sure that there are no objects whose alias starts with `ball_`.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从场景中移除击中，重新访问`scene.objects`列表，确保没有对象的别名以`ball_`开头。
- en: Hint
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: Use a JavaScript timer to measure and display the elapsed time until task completion.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 使用JavaScript计时器来测量和显示完成任务所需的时间。
- en: 'Have a Go: Using Alternative Identifiers for Picking'
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试：使用替代标识符进行选择
- en: How would you uniquely identify objects without using colors? Since we are leveraging
    an offscreen framebuffer, we could identify each object with a unique ID rather
    than a color since the visuals of our offscreen render do not matter. Go ahead
    and implement an ID-based strategy for identifying each object.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 你会如何在不使用颜色的情况下唯一标识对象？由于我们正在利用离屏帧缓冲区，我们可以用唯一的ID而不是颜色来标识每个对象，因为我们的离屏渲染的视觉效果并不重要。继续实现一个基于ID的策略来标识每个对象。
- en: Packing Indices into RGBA Channels
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 将索引打包到RGBA通道中
- en: You can think of object `1` as being the index (or color) `[0, 0, 0, 1]`, object
    `2` as `[0, 0, 0, 2]`, all the way up to where object `1020` (that is, `255 *
    4`) would be `[255, 255, 255, 255]`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将对象`1`视为索引（或颜色）`[0, 0, 0, 1]`，对象`2`为`[0, 0, 0, 2]`，以此类推，直到对象`1020`（即`255
    * 4`）为`[255, 255, 255, 255]`。
- en: Since our RGBA channel is bound to a range of `[0-255]`, how could we pack more
    IDs into our four-based vector?
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的RGBA通道绑定在`[0-255]`的范围内，我们如何将更多的ID打包到基于四位的向量中呢？
- en: Different Base Numeral System
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 不同的数制系统
- en: You may first think of leveraging decimals instead of whole numbers. This is
    a viable solution, especially after you account for the accuracy of floating points
    in ESSL. Another viable solution would be to use a `255` based numeral system
    rather than our traditional base `10`. With this approach, you could uniquely
    identify 4+ billions objects without decimals.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会首先想到利用小数而不是整数。这是一个可行的解决方案，尤其是在你考虑到ESSL中浮点数的精度之后。另一个可行的解决方案是使用基于`255`的数制而不是我们传统的基`10`。采用这种方法，你可以唯一地识别超过40亿个对象，而不需要小数。
- en: 'Have a Go: Decoupling WebGL Components'
  id: totrans-251
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 尝试：解耦WebGL组件
- en: Although we can implement `Controls` and `Picker` by decoupling them with a
    more scalable architecture, we opted for a simpler implementation for educational
    purposes.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们可以通过使用更可扩展的架构将`Controls`和`Picker`解耦来实现它们，但出于教育目的，我们选择了更简单的实现方式。
- en: That being said, how would you rebuild the examples in this chapter with the
    goal of decoupling classes from one another to minimize component interdependence?
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你将如何重新构建本章中的示例，目标是解耦类以最小化组件之间的相互依赖？
- en: Hint
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 提示
- en: One approach would be to leverage the pub/sub pattern discussed earlier for
    our `Clock`. That is, each component can extend the `EventEmitter` class – similar
    to `Clock` – to publish events that other components may subscribe to.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 一种方法是将之前讨论的pub/sub模式用于我们的`Clock`。也就是说，每个组件都可以扩展`EventEmitter`类——类似于`Clock`——来发布其他组件可能订阅的事件。
- en: Summary
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'Let’s summarize what we learned in this chapter:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下在本章中学到的内容：
- en: We studied the difference between a framebuffer and a renderbuffer. A renderbuffer
    is a special buffer that is attached to a framebuffer.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们研究了帧缓冲区和渲染缓冲区之间的区别。渲染缓冲区是一个特殊的缓冲区，它附加到帧缓冲区上。
- en: We learned that WebGL provides mechanisms to create offscreen framebuffers that
    differ from the default onscreen framebuffer.
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解到WebGL提供了创建与默认屏幕帧缓冲区不同的离屏帧缓冲区的机制。
- en: We covered how a framebuffer needs to have at least one texture to store colors
    and a renderbuffer to store depth information.
  id: totrans-260
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了帧缓冲区至少需要一个纹理来存储颜色，以及一个渲染缓冲区来存储深度信息。
- en: We discussed how to convert user click coordinates to `canvas` coordinates so
    that we can map them to values in the offscreen framebuffer.
  id: totrans-261
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了如何将用户点击坐标转换为`canvas`坐标，以便我们可以将它们映射到离屏帧缓冲区中的值。
- en: We discussed the `Picker` architecture. Picking can have different states, and
    each state is associated with a callback function. Picker callbacks allow custom
    application logic to determine what happens when picking is in progress.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了`Picker`架构。选择可以有不同的状态，每个状态都与一个回调函数相关联。Picker回调允许自定义应用程序逻辑确定选择进行时会发生什么。
- en: We learned how to implement color-based picking in WebGL. Picking purely based
    on a diffuse color is limited, because there could be scenarios where several
    objects have the same diffuse color.
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们学习了如何在WebGL中实现基于颜色的选择。仅基于漫反射颜色进行选择是有限的，因为可能存在多个对象具有相同漫反射颜色的情况。
- en: We learned that it’s better to assign a new color property that is unique for
    every object to perform picking. This property is known as picking the color/object
    label.
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们了解到，为每个对象分配一个独特的颜色属性以执行选择是更好的选择。这个属性被称为颜色/对象标签的选择。
- en: We discussed encoding unique IDs rather than unique colors into the four-based
    vector, RGBA.
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们讨论了将唯一的ID而不是唯一的颜色编码到基于四位的向量RGBA中。
- en: In the next chapter, we will bring all of the concepts we've covered in the
    previous chapters together and build a 3D virtual car showroom. Additionally,
    we will see how to import car models from Blender, a 3D editing tool, into a WebGL
    application.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把之前章节中涵盖的所有概念结合起来，构建一个3D虚拟汽车展厅。此外，我们还将了解如何将来自3D编辑工具Blender的汽车模型导入WebGL应用程序。
