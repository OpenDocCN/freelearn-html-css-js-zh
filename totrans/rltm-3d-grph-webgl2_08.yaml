- en: Picking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered how to use textures to add more detail to
    our 3D application. In this chapter, we'll learn how to interact with our WebGL
    application through a technique called **picking**. Picking refers to the ability
    to select objects in a 3D scene. The most common device used for picking is a
    computer mouse. However, picking can also be performed using other human computer
    interfaces, such as tactile screens and haptic devices. In this chapter, we will
    learn how picking can be implemented in WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Learn how to select objects in a WebGL scene using the mouse.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create and use offscreen framebuffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn what renderbuffers are and how they are used by framebuffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Read pixels from framebuffers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use color labels to perform object selection based on color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Picking
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Virtually any 3D computer-graphics application needs to provide mechanisms for
    the user to interact with the scene. For instance, in a game, you may want to
    point at your target and perform an action upon it. Or in a CAD system, you may
    want to be able to select an object in your scene and modify its properties. In
    this chapter, we’ll learn the basics of implementing these kinds of interactions
    in WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: To start, we should point out that we can select objects by casting a ray (vector)
    from the camera position (also known as the eye position) into the scene and calculate
    the objects that lie along its path. This is known as **ray-casting** and involves
    detecting intersections between the ray and object surfaces in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: '**Ray-Casting**'
  prefs: []
  type: TYPE_NORMAL
- en: Ray-casting is the use of ray–surface intersection tests to solve a variety
    of problems in computer graphics and computational geometry. The term was first
    used in computer graphics in a 1982 paper by Scott Roth to describe a method for
    rendering constructive solid geometry models. If you're interested in learning
    more, check out [https://en.wikipedia.org/wiki/Ray_casting](https://en.wikipedia.org/wiki/Ray_casting).
  prefs: []
  type: TYPE_NORMAL
- en: That being said, in this chapter, we’ll implement picking based on object colors
    in an offscreen framebuffer, as it is a simpler and more foundational technique
    to help you understand how to interact with objects in a 3D application. If you're
    interested in ray-casting, you’ll find a section dedicated to this technique in
    [Chapter 10](7100b7e4-1a63-43f4-93ea-f109ca911607.xhtml), *Advanced Techniques*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The basic idea behind picking is to assign a different identifier to every
    object in the scene and render the scene to an offscreen framebuffer. We will
    start by identifying objects with a unique color. When the user clicks on `canvas`,
    we go to the offscreen framebuffer and read the color of the pixel at the location
    of the click action. Since we assigned a unique color to each object in the offscreen
    buffer, we can use this color to identify the object that has been selected and
    perform an action upon it. The following diagram illustrates this concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8e4b2ac5-0b64-464c-a786-6fe9a9c219c0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'An interesting example that may help explain picking is Duck Hunt, the popular
    Nintendo game from the 90s, where players used a physical plastic gun controller
    to hunt ducks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0519b7af-6de7-43d2-9924-896a8fa9424d.png)'
  prefs: []
  type: TYPE_IMG
- en: Can you guess how the game determined whether the player hit a duck? That's
    right, picking! When the player points at a duck and pulls the trigger, the computer
    in the NES blacks out the screen and the Zapper diode in the gun begins reception.
    Then, the computer flashes a solid white block around the targets you’re supposed
    to be shooting at. The photodiode in the Zapper detects the change in light intensity
    and tells the computer that it’s pointed at a lit target block—in other words,
    you should receive a point because you hit the target. Of course, when you’re
    playing the game, you don’t notice the blackout and the targets flashing because
    it all happens in a fraction of a second. Pretty clever, right?
  prefs: []
  type: TYPE_NORMAL
- en: Let's break down the steps for implementing our own form of picking in WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up an Offscreen Framebuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As shown in [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*,
    the framebuffer is the final rendering destination in WebGL. The results of the
    rendering on your screen are the contents of the framebuffer. Assuming that `gl` is
    our WebGL context, every call to `gl.drawArrays`, `gl.drawElements`, and `gl.clear` will
    change the contents of the framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: Instead of rendering to the default framebuffer, we can also render to a scene
    that is offscreen – we call this the offscreen framebuffer. This is the first
    step in implementing picking. To do so, we need to set up a new framebuffer and
    tell WebGL that we want to use it instead of the default one. Let's see how we
    can do that.
  prefs: []
  type: TYPE_NORMAL
- en: 'To set up a framebuffer, we need to create storage for at least two things:
    colors and depth information. We need to store the color for every fragment that
    is rendered in the framebuffer so we can create an image. Additionally, we need
    depth information to make sure that we have a scene where overlapping objects
    look consistent. If we do not have depth information, then we would not be able
    to tell, in the case of two overlapping objects, which object is at front and
    which one is at the back.'
  prefs: []
  type: TYPE_NORMAL
- en: To store colors, we will use a WebGL texture; to store depth information, we
    will use a renderbuffer.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Texture to Store Colors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code to create a texture should be pretty straightforward after reading [Chapter
    7](1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml), *Textures*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The only difference is that we do not have an image to bind to the texture,
    so when we call `gl.texImage2D`, the last argument is `null`. This is because
    we are allocating space to store colors for the offscreen framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: It's important to note that the `width` and `height` of the texture are set
    to the `canvas` size. This is because we want to ensure that the offscreen framebuffer
    resembles the dimensions of our 3D scene.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Renderbuffer to Store Depth Information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Renderbuffers are used to provide storage for the individual buffers used in
    a framebuffer. The depth buffer (z-buffer) is an example of a renderbuffer. It
    is always attached to the screen framebuffer, which is the default rendering destination
    in WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code to create a renderbuffer looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The first line of code creates the renderbuffer. Similar to other WebGL buffers,
    the renderbuffer needs to be bound before we can operate on it. The third line
    of code determines the storage size of the renderbuffer.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that the size of the storage is the same as with the texture. Similar
    to before, we need to ensure that for every fragment (pixel) in the framebuffer,
    we have a color (stored in the texture) and a depth value (stored in the renderbuffer).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Framebuffer for Offscreen Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We need to create a framebuffer and attach the texture and the renderbuffer
    that we created in the previous example. Let's see how this works in code.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to create a new framebuffer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Similar to the VBO manipulation, we tell WebGL that we’re going to operate
    on this framebuffer by making it the currently bound framebuffer. We do so with
    the following instruction:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With the framebuffer bound, the texture is attached by calling the following
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the renderbuffer is attached to the bound framebuffer using the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we clean up the bound buffers as usual with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: When the previously created framebuffer is unbound, the WebGL state machine
    goes back to rendering into the default screen framebuffer.
  prefs: []
  type: TYPE_NORMAL
- en: Assigning One Color per Object in the Scene
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To keep things simple, we will pick an object based on its primitive color.
    That is, we discard the shiny reflections or shadows, and render the object with
    its uniform color. This is important, because to pick an object based on a color,
    we need to make sure that the color is constant per object and that each object
    has a different unique color.
  prefs: []
  type: TYPE_NORMAL
- en: We achieve constant coloring by telling the fragment shader to use only the
    material diffuse property to set the ESSL output color variable. We are assuming
    that each object has a unique diffuse property.
  prefs: []
  type: TYPE_NORMAL
- en: In situations where objects may share the same diffuse color, we can create
    a new ESSL uniform to store the picking color and make it unique for every object
    that's rendered into the offscreen framebuffer. This way, the objects will look
    the same when they are rendered on the screen, but their colors will be unique
    every time they are rendered into the offscreen framebuffer. Later in this chapter,
    we will implement this strategy along with other approaches for uniquely identifying
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For now, let''s assume that the objects in our scene have unique diffuse colors,
    as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/782a5cbf-3790-45b8-a185-9ba22c6a21b8.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's see how to render the scene offscreen by using the framebuffer we just
    set up.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering to an Offscreen Framebuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to perform object selection using the offscreen framebuffer, we need
    to ensure that both framebuffers are synchronized. If the onscreen framebuffer
    and the offscreen framebuffer are not synchronized, we could miss crucial data,
    which may make our picking strategy inconsistent.
  prefs: []
  type: TYPE_NORMAL
- en: A lack of consistency will limit the ability to read colors from the offscreen
    framebuffer and use them to identify objects in the scene.
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that the buffers are synchronized, we will create a custom `render` function.
    This function calls the `draw` function twice. First, when the offscreen buffer
    is bound, and a second time when the onscreen default framebuffer is bound. The
    code looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We tell our ESSL program to use only diffuse colors when rendering into the
    offscreen framebuffer using the `uOffscreen` uniform. The fragment shader contains
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows the behavior of the `render` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a1e526e4-2fb8-4cd7-a463-630d3ec909f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Therefore, every time the scene updates, the `render` function is called instead
    of calling the `draw` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We change this in the `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This way, the `scene` will be periodically updated using the `render` function
    instead of the original `draw` function.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking on the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The next step is to capture and read the mouse coordinates of a user click
    from the offscreen framebuffer. We can use the standard `onmouseup` event from
    the `canvas` element in our webpage:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Since the given `event` returns the mouse coordinates (`clientX` and `clientY`) from
    the top-left rather than the coordinates with respect to the `canvas`, we need
    to leverage the DOM hierarchy to know the total offset that we have around the
    `canvas` element.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this with a code fragment inside the `canvas.onmouseup` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The following diagram shows how we use the offset calculation to obtain the
    clicked `canvas` coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/aa7b4f9f-bf5b-47db-9d26-bf7bfa9c39a3.png)'
  prefs: []
  type: TYPE_IMG
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we should take any possible page offset into account. The page offset
    is the result of scrolling, which affects the calculation of the coordinates.
    We want to obtain the same coordinates for the `canvas` every time, regardless
    of any scrolling. To do so, we add the following two lines of code just before
    calculating the clicked `canvas` coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we calculate the `canvas` coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Remember that unlike the browser window, the `canvas` coordinates (and also
    the framebuffer coordinates for this purpose) start in the lower-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: Reading Pixels from the Offscreen Framebuffer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can now go to the offscreen buffer and read the color from the appropriate
    coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bf13007d-f3f2-452c-bdc7-9b4d40ad0772.png)'
  prefs: []
  type: TYPE_IMG
- en: 'WebGL allows us to read back from a framebuffer using the `readPixels` function.
    As usual, having `gl` as the WebGL context variable within our context:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Description** |'
  prefs: []
  type: TYPE_TB
- en: '| `gl.readPixels(x, y, width, height, format, type, pixels)` |'
  prefs: []
  type: TYPE_TB
- en: '`x` and `y`: Starting coordinates.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`width` and `height`: The extent of pixels to read from the framebuffer. In
    our example, we are just reading one pixel (where the user clicks), so this will
    be `1`, `1`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`format`: Supports the `gl.RGBA` format.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`type:`: Supports the `gl.UNSIGNED_BYTE` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pixels`: A typed array that will contain the results of querying the framebuffer.
    It needs to have sufficient space to store the results depending on the extent
    of the query (`x`, `y`, `width`, `height`). It supports the `Uint8Array` type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember that WebGL works as a state machine; thus, many operations depend
    on the validity of its state. In this case, we need to ensure that the offscreen
    framebuffer that we want to read from is the currently bound one. To do so, we
    bind it by using `bindFramebuffer`. Putting everything together, the code looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the size of the readout array is `1 * 1 * 4`. This means that it has one
    pixel of width times one pixel height times four channels, since the format is RGBA.
    You do not need to specify the size this way; this was done to demonstrate why
    the size is `4` when we are just retrieving one pixel.
  prefs: []
  type: TYPE_NORMAL
- en: Looking for Hits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we will check whether the color obtained from the offscreen framebuffer
    matches any of the objects in our scene. Remember here that we are using colors
    as object labels. If the color matches one of the objects, then we call it a **hit**.
    If it does not, we call it a **miss**.
  prefs: []
  type: TYPE_NORMAL
- en: 'When looking for hits, we compare each object''s diffuse color with the label
    obtained from the offscreen framebuffer. There is, however, an additional step
    to consider: each color channel comes back in a `[0, 255]` range while the object
    diffuse colors are in a `[0, 1]` range. We need to update this before we check
    for any possible hits. We can do so with a compare function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we scale the diffuse property to a `[0, 255]` range and
    then compare each channel individually. We do not need to compare the alpha channel.
    If we had two objects with the same color but a different alpha channel, we could
    use the alpha channel in the comparison, but this is not the case in our example.
  prefs: []
  type: TYPE_NORMAL
- en: Also, it’s important to note that the comparison is not precise, as we are dealing
    with decimal values in the `[0, 1]` range. Because of that, we introduce a fudge
    factor by assuming that we have a hit after rescaling the colors and subtract
    the readout (object label) – the difference is less than one.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, we just iterate through the object list in our `scene` and check whether
    we have a hit or miss with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This code iterates through every object in our `scene` and assigns `pickedObject` to
    the matching object if we have a hit.
  prefs: []
  type: TYPE_NORMAL
- en: Processing Hits
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Processing a hit is a large concept that heavily depends on the type of application
    you’re using. For instance, if your application is a CAD system, you may want
    to retrieve the properties of the selected object so that you can edit or delete
    it. In contrast, if you’re developing a game, selecting an object may involve
    setting it as a target your character should fight next. As you would expect,
    this part needs to be adaptable to a variety of uses. That being said, we will
    soon cover a practical example where you can drag and drop objects in our scene.
    But first, we need to review some of the architectural updates of our application.
  prefs: []
  type: TYPE_NORMAL
- en: Architectural Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have replaced the `draw` function with the `render` function, as described earlier
    in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There is now a new class: **Picker**. The source code for this class can be
    obtained from `common/js/Picker.js`. This class encapsulates the offscreen framebuffer
    and the code necessary to create, configure, and read from it. We’ve also updated
    the `Controls` class to notify the picker when the user clicks on the `canvas`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's see picking in action!
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Picking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s cover an example of this technique in action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `ch08_01_picking.html` file using your browser. You will see a screen
    similar to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0f499544-cff5-4e56-b5c5-da397d1bb492.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, you have a set of objects, each one of which has a unique diffuse color
    property. As was the case in previous examples, you can move the camera around
    the scene. Also, note that the cube has a texture and that the flat disk is translucent.
    As you may expect, the code in the `draw` function handles textures, coordinates,
    and also transparencies, so it looks a bit more complex than before (you can check
    it out in the source code). This is a more realistic `draw` function. In a real
    application, you will have to handle these cases.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on the sphere and drag it around the scene. Notice that the object becomes
    translucent. Also, note that the displacement occurs along the axis of the camera.
    To make this evident, please go to your web browser''s `console` and type in the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you resume the clock by clicking inside of the scene, you will see that
    the camera updates its position to an elevation of zero degrees, as shown in the
    following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/099b8e82-7e3e-4a57-926e-98feb259148b.png)'
  prefs: []
  type: TYPE_IMG
- en: JavaScript Console
  prefs: []
  type: TYPE_NORMAL
- en: 'Firefox: Tools | WebDeveloper | WebConsole'
  prefs: []
  type: TYPE_NORMAL
- en: 'Safari: Develop | Show Web Inspector'
  prefs: []
  type: TYPE_NORMAL
- en: 'Chrome: Tools | Javascript Console'
  prefs: []
  type: TYPE_NORMAL
- en: When you click and drag objects in the scene from this perspective, you will
    see that they change their position according to the camera's axis. In this case,
    the up axis of the camera is aligned with the scene's y-axis. If you move an object
    up and down, you will see that they change their position in the `y` coordinate.
    If you change the camera position (by clicking on the background and dragging
    the mouse around), and then move a different object, you will see that the object
    moves according to the camera’s new y-axis.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try different camera angles and see what happens.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's see what the offscreen framebuffer looks like. Click on the Show Picking
    Imagebutton. Here, we are instructing the fragment shader to use each of the object
    diffuse properties to color the fragments. You can also rotate the scene and pick
    objects in this mode. If you want to go back to the original shading method, click
    on Show Picking Image again to deactivate it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To reset the scene, click on **Reset Scene**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: We have seen an example of picking in action. The source code uses the `Picker` class
    that we previously described in the *Architectural Updates* section. Let's examine
    it a bit closer.
  prefs: []
  type: TYPE_NORMAL
- en: Picker Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As you may have noticed, every picker state has a callback function associated
    with it. The following process outlines what happens in the `Picker` class when
    the user clicks the mouse on the `canvas`, drags it, and releases it:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **State** | **Callback** |'
  prefs: []
  type: TYPE_TB
- en: '| `Picker` searches for a hit | `hitPropertyCallback(object)`: This callback
    informs the picker about which object property to use to make the comparison with
    the retrieved color from the offscreen framebuffer. |'
  prefs: []
  type: TYPE_TB
- en: '| User drags mouse in picking mode | `moveCallback(dx, dy)`: When the picking
    mode is activated (by having picked at least one object), this callback allows
    us to move the objects in the picking list (hits). This list is maintained internally
    by the `Picker` class. |'
  prefs: []
  type: TYPE_TB
- en: '| Remove hit from picking list | `addHitCallback(object)`: If we click on an
    object and this object is not in the picking list, the picker notifies the application
    by triggering this callback. |'
  prefs: []
  type: TYPE_TB
- en: '| Add hit to picking list | `removeHitCallback(object)`: If we click on an
    object and this object is already in the picking list, the picker will remove
    it from the list and then it will inform the application by triggering this callback.
    |'
  prefs: []
  type: TYPE_TB
- en: '| End Picking Mode | `processHitsCallback(hits)`: If the user releases the
    mouse button while the *Shift *key is not pressed, the picking mode finishes and
    the application is notified by triggering this callback. If the *Shift* key is
    pressed, then the picking mode continues, and the picker waits for a new click
    to continue looking for hits. |'
  prefs: []
  type: TYPE_TB
- en: Implementing Unique Object Labels
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We previously mentioned that picking based on the diffuse property could be
    difficult if two or more objects in the scene share the same diffuse color. If
    that were the case and you selected one of them, how could you determine which
    one is picked based on its color? In the following *Time for Action* section,
    we will implement unique object labels. The objects will be rendered in the offscreen
    framebuffer using these color labels instead of the diffuse colors. The scene
    will still be rendered on the screen using the non-unique diffuse colors.
  prefs: []
  type: TYPE_NORMAL
- en: 'Time for Action: Unique Object Labels'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section is divided into two parts. In the first part, you will develop
    code to generate a random scene with cones and cylinders. Each object will be
    assigned a unique object label that will be used for coloring the object in the
    offscreen renderbuffer. In the second part, we will configure the picker to work
    with unique labels. Let''s get started:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ch08_02_picking-initial.html` file in your browser. This is a scene
    that is only showing the floor object. We are going to create a scene that contains
    multiple objects that can be either balls or cylinders.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `ch08_02_picking-initial.html` in a source code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will write code so that each object in the scene can have the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A position assigned randomly
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique object label color
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A non-unique diffuse color
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A scale factor that will determine the size of the object
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: We have provided empty functions that you will implement in this section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s write the `positionGenerator` function. Scroll down to it and add the
    following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `Math.random` function to generate the `x` and `z` coordinates
    for an object in the scene. Since `Math.random` always returns a positive number,
    we use the `flagX` and `flagZ` variables to randomly distribute the objects on
    the `x`-`z` plane (floor). Also, because we want all of the objects to be on the
    `x`-`z` plane, the `y` component is always set to `0` in the `return` statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s write a unique object label generator function. Scroll to the empty
    `objectLabelGenerator` function and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: We create a random color using the `Math.random` function. If the `key` variable
    is already a property of the `colorset` object, then we call the `objectLabelGenerator` function
    recursively to get a new value; otherwise, we make `key` a property of `colorset` and
    then `return` the respective color. Notice how well the handling of JavaScript
    objects as sets allows us to resolve any possible key collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the `diffuseColorGenerator` function. We will use this function to assign
    diffuse properties to the objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This function represents the case where we want to generate colors that are
    not unique. The index parameter represents the index of the object in the `scene.objects` list
    to which we are assigning the diffuse color. In this function, we are creating
    a gray-level color since the `r`, `g`, and `b` components in the `return` statement
    all have the same `color` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `diffuseColorGenerator` function will create collisions every `30` indices.
    The remainder of the division of the index by `30` will create a loop in the sequence:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Since this result is being divided by `60`, the result will be a number in the `[0,
    0.5]` range. Then, we add `0.2` to make sure that the minimum value that `color`
    has is `0.2`. This way, the objects will not look too dark during the onscreen
    rendering (they would be black if the calculated diffuse color were `0`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last auxiliary function we will write is the `scaleGenerator` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This function will allow us to have objects of different sizes. `0.3` is added
    to control the minimum scaling factor that any object will have in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Let's load `100` objects to our scene. By the end of this section, you will
    be able to test picking on any of them!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go to the `load` function and edit it so that it looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The picking color is represented by the `pcolor` attribute. This attribute is
    passed in a list of attributes to the `scene.load` function. Once the object is
    loaded (using **JSON/Ajax**), `load` uses this list of attributes and adds them
    as object properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The shaders in this exercise have already been set up for you. The `pcolor` property
    that corresponds to the unique object label is mapped to the `uPickingColor` uniform,
    and the `uOffscreen` uniform determines whether it is used in the fragment shader:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As described previously, we keep the offscreen and onscreen buffers in sync
    by using the `render` function as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Save your work as `ch08_03_picking-no-picker.html`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `ch08_03_picking-no-picker.html` in your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click on Show Picking Image. What happens?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The scene is being rendered to both the offscreen and default onscreen framebuffer.
    However, we have not configured the `Picker` callbacks yet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open `ch08_03_picking-no-picker.html` in your source code editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll down to the `configure` function. The picker is already set up for you:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: This code fragment maps functions in the web page to picker callback hooks.
    These callbacks are invoked according to the picking state.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will now implement the necessary callbacks. Again, we have provided empty
    functions that you will need to code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s create the `hitProperty` function. Scroll down to the empty `hitProperty` function
    and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We are returning the `pcolor` property to make the comparison with the color
    that will be read from the offscreen framebuffer. If these colors match, then
    we have a hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Write the `addHit` and `removeHit` functions. We want to create the effect
    where the diffuse color is changed to the picking color during picking. We need
    an extra property to temporarily save the original diffuse color so that we can
    restore it later:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `addHit` function stores the current diffuse color in an auxiliary property
    named `previous`. Then, it changes the diffuse color to `pcolor`, the object-picking
    label:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `removeHit` function restores the diffuse color.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s write the code for `processHits`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Remember that `processHits` is called upon exiting picking mode. This function
    will receive one parameter: the `hits` that the `picker` detected. Each element
    of the `hits` list is an object in `scene`. In this case, we want to give the
    hits their diffuse color back. For that, we use the previous property that we
    set in the `addHit` function.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The last picker callback we need to implement is the `movePickedObjects` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This function allows us to move the objects in the hits list interactively.
    The parameters that this callback function receives are as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`dx`: Displacement in the horizontal direction obtained from the mouse when
    it is dragged on `canvas`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`dy`: Displacement in the vertical direction obtained from the mouse when it
    is dragged on `canvas`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s analyze the code. First, we retrieve all of the hits from the picker
    instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no hits, the function `returns` immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We calculate a weighing factor that we will use later (the fudge factor):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We create a loop to go through the hits list so that we can update each object''s
    position:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `scaleX` and `scaleY` variables are initialized for every hit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The *Alt* key is being used to perform dollying (moving the camera along its
    normal path). In this case, we want to move the objects that are in the picking
    list along the camera's normal direction when the user is pressing the *Alt* key
    to provide a consistent user experience.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To move the hits along the camera normal, we use the `dy` (up-down) displacement,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This creates a scaled version of `camera.normal` and stores it into the `scaleY` variable.
    Notice that `vec3.scale` is an operation that's available in the **glMatrix** library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If the user is not pressing the *Alt* key, then we use `dx` (left-right) and `dy` (up-down)
    to move the hits in the camera plane. Here, we use the camera''s up and right vectors
    to calculate the `scaleX` and `scaleY` parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'We update the position of the hit:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Save the page as `ch08_04_picking-final.html` and open it using your browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You will see a scene like the one shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/2bd69814-1dd5-46af-999e-fd484bdd46ca.png)'
  prefs: []
  type: TYPE_IMG
- en: Click on Reset Sceneseveral times and verify that you get a new scene every
    time.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In this scene, all of the objects have very similar colors. However, each one
    has a unique picking color. To verify this, click on the Show Picking Imagebutton.
    You will see on the screen what is being rendered in the offscreen buffer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/dfb44a14-ec34-468b-943f-c7a6dda3fe47.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s validate the changes that we made to the picker callbacks. Let''s start
    by picking one object. As you can see, the object diffuse color becomes its picking
    color (this was the change you implemented in the `addHit` function):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/25e09a6f-fd71-4710-bd82-b4883b0ebcd5.png)'
  prefs: []
  type: TYPE_IMG
- en: When the mouse is released, the object goes back to the original color. This
    is the change that was implemented in the `processHits` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: While the mouse button is held down over an object, you can drag it around.
    When this is done, `movePickedObjects` is being invoked.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Pressing the *Shift* key while objects are being selected will tell the picker
    not to exit **picking mode**. This way, you can select and move more than one
    object at once:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/ac02ecf1-a6fa-4aaf-a67c-c10dcb844700.png)'
  prefs: []
  type: TYPE_IMG
- en: You will exit picking mode if you select an object and the *Shift* key is no
    longer pressed or if your next click does not produce any hits (in other words,
    clicking anywhere else).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you have any problems with this exercise or missed one of the steps, we have
    included the complete exercise in the `ch08_03_picking-no-picker.html` and `ch08_04_picking-final.html` files.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '***What just happened?***'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have done the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Created the property-picking color. This property is unique for every object
    in the scene and allows us to implement picking based on it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Modified the fragment shader to use the picking color property by including
    a new uniform, `uPickingColor`, and mapping this uniform to the `pcolor` object
    property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learned about the different picking states. We have also learned how to modify
    the `Picker` callbacks to perform specific application logic such as removing
    picked objects from the scene.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Have a Go: Clearing the Scene'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Rewrite the `processHits` function to remove the balls in the hit list from
    the scene. If the user has removed all of the balls from the scene, display a
    message with the elapsed time for accomplishing this task.
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: Use `scene.remove(objectName)` in the `processHits` function if the alias starts
    with `ball_`.
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: Once the hits are removed from the scene, revisit the `scene.objects` list and
    make sure that there are no objects whose alias starts with `ball_`.
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: Use a JavaScript timer to measure and display the elapsed time until task completion.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Using Alternative Identifiers for Picking'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: How would you uniquely identify objects without using colors? Since we are leveraging
    an offscreen framebuffer, we could identify each object with a unique ID rather
    than a color since the visuals of our offscreen render do not matter. Go ahead
    and implement an ID-based strategy for identifying each object.
  prefs: []
  type: TYPE_NORMAL
- en: Packing Indices into RGBA Channels
  prefs: []
  type: TYPE_NORMAL
- en: You can think of object `1` as being the index (or color) `[0, 0, 0, 1]`, object
    `2` as `[0, 0, 0, 2]`, all the way up to where object `1020` (that is, `255 *
    4`) would be `[255, 255, 255, 255]`.
  prefs: []
  type: TYPE_NORMAL
- en: Since our RGBA channel is bound to a range of `[0-255]`, how could we pack more
    IDs into our four-based vector?
  prefs: []
  type: TYPE_NORMAL
- en: Different Base Numeral System
  prefs: []
  type: TYPE_NORMAL
- en: You may first think of leveraging decimals instead of whole numbers. This is
    a viable solution, especially after you account for the accuracy of floating points
    in ESSL. Another viable solution would be to use a `255` based numeral system
    rather than our traditional base `10`. With this approach, you could uniquely
    identify 4+ billions objects without decimals.
  prefs: []
  type: TYPE_NORMAL
- en: 'Have a Go: Decoupling WebGL Components'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we can implement `Controls` and `Picker` by decoupling them with a
    more scalable architecture, we opted for a simpler implementation for educational
    purposes.
  prefs: []
  type: TYPE_NORMAL
- en: That being said, how would you rebuild the examples in this chapter with the
    goal of decoupling classes from one another to minimize component interdependence?
  prefs: []
  type: TYPE_NORMAL
- en: Hint
  prefs: []
  type: TYPE_NORMAL
- en: One approach would be to leverage the pub/sub pattern discussed earlier for
    our `Clock`. That is, each component can extend the `EventEmitter` class – similar
    to `Clock` – to publish events that other components may subscribe to.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s summarize what we learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We studied the difference between a framebuffer and a renderbuffer. A renderbuffer
    is a special buffer that is attached to a framebuffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned that WebGL provides mechanisms to create offscreen framebuffers that
    differ from the default onscreen framebuffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We covered how a framebuffer needs to have at least one texture to store colors
    and a renderbuffer to store depth information.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed how to convert user click coordinates to `canvas` coordinates so
    that we can map them to values in the offscreen framebuffer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed the `Picker` architecture. Picking can have different states, and
    each state is associated with a callback function. Picker callbacks allow custom
    application logic to determine what happens when picking is in progress.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned how to implement color-based picking in WebGL. Picking purely based
    on a diffuse color is limited, because there could be scenarios where several
    objects have the same diffuse color.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned that it’s better to assign a new color property that is unique for
    every object to perform picking. This property is known as picking the color/object
    label.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed encoding unique IDs rather than unique colors into the four-based
    vector, RGBA.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the next chapter, we will bring all of the concepts we've covered in the
    previous chapters together and build a 3D virtual car showroom. Additionally,
    we will see how to import car models from Blender, a 3D editing tool, into a WebGL
    application.
  prefs: []
  type: TYPE_NORMAL
