- en: Chapter 9. Creating Your Own Blockbuster Game – A Complete Match 3 Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is the last chapter of this book, and I really hope you have enjoyed reading
    it as much as I enjoyed writing it. When I drafted the initial outline for this
    book, I planned to dedicate the last chapter to a Match 3 game such as Candy Crush
    Saga or Farm Heroes Saga.
  prefs: []
  type: TYPE_NORMAL
- en: I then realized that there are tons of tutorials about these games available
    around the Web. Hence, I decided to show y'all something new, the engine of the
    Dungeon Raid game (available at [https://itunes.apple.com/us/app/dungeon-raid/id403090531](https://itunes.apple.com/us/app/dungeon-raid/id403090531)),
    which I adapted to create Globez (available at [http://www.mindjolt.com/globez.html](http://www.mindjolt.com/globez.html)),
    a game that has been played millions of times.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating Your Own Blockbuster Game – A Complete Match 3 Game](img/0075OS_09_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: During the making of this game, you will not only use most of the concepts described
    in this book in the creation of a real game engine, but you will also learn the
    bare bones of the Cocos2d-JS drawing API.
  prefs: []
  type: TYPE_NORMAL
- en: Follow the steps carefully; this is a complete game engine, and there's a lot
    to do.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since it''s a basic game with no physics, we don''t need to include external
    libraries; so, `project.json` returns to its original content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, the content of `main.js` is basically the same as always:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Just have a look at the resolution: 300x300 is the main game area. For now,
    we''ll only focus on the main game area, and believe me, you''ll have enough to
    do!'
  prefs: []
  type: TYPE_NORMAL
- en: '`loadassets.js` is loading a sprite sheet created with **TexturePacker**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`globes.png` is just one single file with all colored globes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Setting up the game](img/0075OS_09_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And `globes.plist` defines various images this way, with each color name assigned
    the `key` node. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now that we are done with the settings, we can start coding the game itself.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the board
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we''ll do is create the board in `gamescript.js` on which we''ll
    be playing the game. Trying to make the engine as customizable as we can, we''ll
    start with some global variables. Changing most of them will result in a quick
    gameplay change. It is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`fieldSize`: This variable is the width and height of the field size, in tiles.
    This means we will play on a 6 x 6 tile field.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tileTypes`: This is an array with the keys of the sprites defined in the `globes.plist`
    file. I used only five different kinds of globez because I like the game to offer
    the opportunity to make big combos. You can choose how many colors you want; just
    keep in mind the more the colors in the game, the harder the gameplay.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tileSize`: This variable is the size of a tile, in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`tileArray`: This is the array that will contain all globez objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`globezLayer`: This variable will be the layer where globez tiles will be placed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `gameScene` definition does not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s have a look at the game definition, the core of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing new here; we load the sprite sheet, create and place a background
    layer, create and place the layer that will contain all globez, and call the `createLevel`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add globe creation to `createLevel`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here we are just building a two-dimensional array called `tileArray` according
    to the `fieldSize` number of entries. Given the *i* and *j* values, the `addTile`
    function causes the final creation of the tile, which accepts the row and the
    column of such a tile in the game field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at `addTile` to know how to set up a game field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point of time, you can test the project and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the board](img/0075OS_09_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Did you notice? Every time you run the game, you get a different, random game
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having a look at the `addTile` function will let you understand what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: First, a random number between zero and the number of allowed tile types minus
    one is generated. In this case, it is from zero to five.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'From the sprite sheet, we will pick the sprite with the same key as `tileTypes[randomTile]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the sprite is created starting from its assigned frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'I added two custom attributes to our sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '`val`: This variable represents the value of the tile as defined by the `randomTile`
    variable'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`picked`: This is a Boolean variable that says whether the tile has currently
    been picked by the players'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Then, the sprite is added to the `globezLayer` layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have to make something with all these globez.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and deselecting the first globe
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What''s the first thing we need to do when we want the player to interact with
    the game? Yes, add a listener. We will add it to the game''s `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'These are all concepts you have already met; I am just putting them together
    in order to create a game. So, you should know by now that we are going to declare
    `touchListener`; but first, let me add two more global variables to keep track
    of all the tiles I am going to select and the color I select:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '`visitedTiles` is the array that will store the tiles once they have been picked
    up by the player, while `startColor` is the color of the first tile selected.
    We start with `null` as no color has been selected.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s move to the `touchListener` creation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems a lot of code but don''t worry; it''s really easy. Check the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, we will play with the mouse but, obviously, you can use touch if
    you want. Let''s say you should be able to use both ways to control the game.
    Using the mouse, we have to deal with two events, `onMouseDown` and `onMouseUp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When the mouse is pressed, the `pickedRow` and `pickedCol` variables take the
    index of the row and column picked by the mouse according to click coordinates
    and `tileSize`. Once I know the row and column of the globe I picked, I can make
    it semitransparent by setting its opacity to 128—remember that opacity ranges
    from 0 to 255 in Cocos2d-JS with the `setOpacity` method. Also, I set the globe
    `picked` value to `true` because I actually picked it up, and since it's the first
    globe I am picking, I also need to set `startColor` to the globe color. From now
    on, we will only have to pick globez with the same color.
  prefs: []
  type: TYPE_NORMAL
- en: Last but not least, we need to update the `visitedTiles` array with the newly
    picked globe—in this case, it's added as an object.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the moment, `onMouseUp` is quite simple, although it will become the most
    complicated function in the whole game. It is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: There isn't much to say; once the player releases the mouse, the `startColor`
    method needs to be reset to `null` and each globe in the `visitedTiles` array
    must be set to fully opaque, with the `picked` attribute set to `false`. With
    an empty `visitedTiles` array, we are ready to wait for the next player choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the game and try to pick and release a globe:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting and deselecting the first globe](img/0075OS_09_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, when you pick a globe, it turns semitransparent. When you release
    it, it returns fully opaque.
  prefs: []
  type: TYPE_NORMAL
- en: Let's make our first chain.
  prefs: []
  type: TYPE_NORMAL
- en: Making globez chains
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The gameplay is simple: you have to connect as many globez you can, horizontally,
    vertically, or diagonally. And you can also backtrack.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how to connect globez. First, though, let me introduce you to a
    variable that will be very important in all your draw-to-match games: `tolerance`.
    Check the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Have a look at the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making globez chains](img/0075OS_09_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Let's say the player wants to connect the three green globez, from bottom to
    top. When you draw with your finger on a small surface, say, your mobile phone,
    maybe in a train, you aren't this precise. So, on the left side, we can see what
    will happen if we detect player movement in a tile-based environment. The not-that-precise
    drawing would touch five different globez, resulting in an illegal move, which
    is frustrating. On the right side, using a tolerance, we only detect a player
    movement when next to the center of the tile. See the difference? The player only
    touches three globez, performing a legal move as required.
  prefs: []
  type: TYPE_NORMAL
- en: I called the square of the distance from the center—the radius of the inner
    white circles—`tolerance`, and in this case, I set it to *20 pixels * 20 pixels
    = 400*.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can say we have a legal move when:'
  prefs: []
  type: TYPE_NORMAL
- en: We are inside a tolerance area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current globe hasn't already been picked—the `picked` attribute is `false`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current globe is adjacent to the last picked globe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current globe has the same color as the first picked globe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Translated into Cocos2d-JS, this means the `onMouseMove` function will contain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'It seems a lot of code but it''s just the representation of the four conditions
    mentioned earlier. I would like to point out the following line to you:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Here, I am applying the **Pythagorean Theorem** without using square roots,
    to save CPU time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Test the script, and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making globez chains](img/0075OS_09_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You are now able to select globez even if your drawing is a bit imprecise. Now,
    what if you change your mind and want to backtrack to try another route?
  prefs: []
  type: TYPE_NORMAL
- en: Backtracking
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can backtrack your selection when you move your mouse back to the second
    last globe. In this case, the last globe is removed from the `visitedTiles` array
    and both the `picked` attribute and the opacity are turned back to their default
    values: `true` and `255`, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To check for backtrack, you must check whether:'
  prefs: []
  type: TYPE_NORMAL
- en: We are inside a tolerance area
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current globe has already been picked—the `picked` attribute is `true`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The current globe is the second last entry in the `visitedTiles` array
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is just a minor change in the `onMouseMove` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Test your game now, and try to backtrack. See the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Backtracking](img/0075OS_09_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Do you see this? Now, you can change your mind and take another route.
  prefs: []
  type: TYPE_NORMAL
- en: Take a short break because it's not over yet, although we managed to completely
    handle player movements.
  prefs: []
  type: TYPE_NORMAL
- en: Removing globez
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An ancient proverb says, *it's not a match game if you can't remove items*.
    And, it's right! Once you select the globez, you must be able to remove them once
    you release the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'Removing globez is very easy: once you know the `visitedTiles` array has at
    least three items, just remove those items from the stage and from the `tileArray`
    array.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change `onMouseUp` this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Setting removed globez with `null` in the `tileArray` array after having physically
    removed them from the stage with `removeChild` will be useful when we want to
    replenish the board.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, try the game:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Removing globez](img/0075OS_09_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Did you see? We removed the globez. Now, the game is complete. Wait. No. Once
    you remove the globez, some globez have to fall down and more globez have to appear
    from the top of the screen to refill the stage. We will make them fall down gently
    using a tween.
  prefs: []
  type: TYPE_NORMAL
- en: Making the globez fall down
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you remove the globez, you will need to check whether there are globez
    with empty spaces below them, and make them fall down accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, unlike most other languages, Cocos2d-JS sets the origin (0,0) coordinate
    at the bottom left of the stage, so the lowest row is row zero.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to heavily edit `onMouseUp`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the script and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Making the globez fall down](img/0075OS_09_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once green globez have been removed, the upper globez fall down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s analyze the code a little:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Everything depends on whether we selected more than three globez. Otherwise,
    no globez will be removed, and there will be no need to check for empty spaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We start looping through all rows starting from `1`—the next-to-bottomt row—to
    row `fieldsize`-1, which is the topmost row.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: We do the same thing for the columns but, this time, we scan them.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If in the given position we have a globe, it's time to count how many empty
    spaces we have below it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The `holesBelow` variable will keep track of the empty spaces below a globe.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Starting from the current row and going down to the first, we have to count
    the empty spaces.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We find an empty space when its `tileArray` value is null.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'And, in this case, we increment the `holesBelow` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the loop has finished, we check whether there were holes below:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Then, move the globe accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we can update `tileArray` to register the new position of the globe.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we managed to make the globez fall down, there is just one more thing
    to do—create new globes to fill the stage again.
  prefs: []
  type: TYPE_NORMAL
- en: Creating new globez
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating new globez shares the same concept as making the globez fall. For each
    column, we count the number of empty places; this number is the number of globez
    we have to create.
  prefs: []
  type: TYPE_NORMAL
- en: In order to create a smooth appearance, each globe will be created outside the
    top of the stage and an animation tween will place it in its right place.
  prefs: []
  type: TYPE_NORMAL
- en: This is the last time we need to modify `onMouseUp`, promise!
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This is the part needed to scan for empty spaces and call the `fallTile` method
    to create a new tile with the destination row, destination column, and falling
    height. We use the falling height to create a smooth tween to the globe's final
    position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the definition for `fallTile`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s really similar to the `addTile` method created several pages ago—it was
    a long journey, wasn''t it? And finally Globez is made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating new globez](img/0075OS_09_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once you remove some globez, new ones will fall down from the top.
  prefs: []
  type: TYPE_NORMAL
- en: Bonus – using the drawing API for a visual feedback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As promised, we will use the drawing API to provide a visual feedback of the
    path we are drawing with the mouse.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new global variable to store the layer where we will
    draw the player movement. It''s called `arrowsLayer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'We will create and add `arrowLayer` after `globezLayer` in the `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: The entity we can draw in is `DrawNode`.
  prefs: []
  type: TYPE_NORMAL
- en: 'No matter what happens, when we release the mouse, we will clear the draw area
    using the `clear` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we know how to clear a draw node and we have to see how to draw lines
    in it. Add a new method call when the player performs a legal move, no matter
    whether you''re selecting a new globe or backtracking:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'And now the only thing to do is the creation of `touchListener` listener''s
    `drawPath` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, I loop through the `visitedTiles` array and use the `drawSegment`
    method to draw a segment from the first `cc.Point` argument to the second.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, your game is completed. For real!!
  prefs: []
  type: TYPE_NORMAL
- en: '![Bonus – using the drawing API for a visual feedback](img/0075OS_09_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Look how you can draw lines with the mouse, connecting the various globez you
    selected.
  prefs: []
  type: TYPE_NORMAL
- en: Where to go now
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Normally, each chapter ends with a summary heading; anyway, this time I don't
    think you need a summary. I mean, you made several games, from a Concentration
    to Sokoban, from an endless runner to Globez.
  prefs: []
  type: TYPE_NORMAL
- en: First, I want to thank you for reading the entire book, and I hope you enjoyed
    reading it as much as I enjoyed writing it.
  prefs: []
  type: TYPE_NORMAL
- en: Although you created several games, this is just the beginning of a long journey
    into cross-platform game development.
  prefs: []
  type: TYPE_NORMAL
- en: First, you should complete the game by adding sounds, a scoring system, and
    some other features I am sure you know how to add, now that you are reading these
    final pages.
  prefs: []
  type: TYPE_NORMAL
- en: Then, I just want to point you to three sites you may find useful if you want
    to dive into cross-platform HTML5 development.
  prefs: []
  type: TYPE_NORMAL
- en: Protect your code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As your games were written in JavaScript, anyone can look at your code simply
    by directly looking at the HTML of your pages. There are several tools to obfuscate
    your code to make it unreadable—or at least to make life really hard for code
    lurkers. I selected two of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Javascript Obfuscator** ([http://javascriptobfuscator.com/](http://javascriptobfuscator.com/)):
    This is an online free tool to obfuscate your code; just copy-and-paste your code
    or upload small files and it does the hard work for you.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**JScrambler** ([https://jscrambler.com](https://jscrambler.com)): This is
    the one I currently use and recommend. This allows you a lot of obfuscation levels,
    mobile gaming optimizations, site-locking, expiration dates, and many more. Just
    drag-and-drop your project and download the protected version.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Port your game on mobile devices as a native app
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Once your game is running on each browser, you may be tempted to convert it
    into a native mobile app to try to conquer new markets. There are three awesome
    tools that allow you to create mobile apps starting from HTML, CSS, and JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Cocos2D proprietary JSB API ([http://www.cocos2d-x.org/wiki/Basic_usage_of_JSB_API](http://www.cocos2d-x.org/wiki/Basic_usage_of_JSB_API)):
    This is the official API to bind C++ to JavaScript. Starting from a Cocos2d-iphone
    or Cocos2d-x project, you can have all graphics, rendering, and physics code running
    natively with the game logic running JavaScript.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**PhoneGap** ([http://phonegap.com/](http://phonegap.com/)): This application
    works both from your computer using native SDKs and from the cloud. PhoneGap compiles
    your HTML5 games, creating native apps ready to be published in markets such as
    Apple App Store. I used it to create the iOS version of BWBan ([https://itunes.apple.com/us/app/bwban/id783208885?mt=8](https://itunes.apple.com/us/app/bwban/id783208885?mt=8)),
    starting from an HTML5 game.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**CocoonJS** ([https://www.ludei.com/cocoonjs/](https://www.ludei.com/cocoonjs/)):
    This platform provides you with a platform to test, accelerate, deploy, and monetize
    your HTML5 apps and games on all mobile devices with many interesting features
    to help you deliver great web products faster.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Publishing your game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Making games is fun, but having people playing your games is even more fun.
    Here are the two top gaming portals where you should upload your games to receive
    plays, ratings, comments, and feedback:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Newgrounds** ([http://www.newgrounds.com/](http://www.newgrounds.com/)):
    This web gaming portal has a collection of the best indie audios, web movies,
    and games made by developers all around the world.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Kongregate** ([http://www.kongregate.com/](http://www.kongregate.com/)):
    This is my favorite web gaming portal; it also offers an interesting revenue share.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Licensing your game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Game publishers are always looking for quality games and are willing to pay
    you to license them to use and customize your game. Unfortunately, it''s not that
    easy to get in touch with them and get enough attention. Luckily, there''s a service
    that does the hard job for you, showing your game to hundreds of potential buyers:'
  prefs: []
  type: TYPE_NORMAL
- en: '**FGL** ([https://www.fgl.com/](https://www.fgl.com/)): This is the industry''s
    leading distribution and monetization services for HTML5, Android, iOS, Unity,
    and Flash. I got several sponsorships, thanks to FGL. I highly recommend working
    with them.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Staying up-to-date
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML5 gaming market is a new market changing almost daily. You will need
    to stay up-to-date to know news and trends. There''s one forum I highly recommend:'
  prefs: []
  type: TYPE_NORMAL
- en: '**HTML5GameDevs** ([http://www.html5gamedevs.com/](http://www.html5gamedevs.com/)):
    This is the top HTML5 Game Dev forum with articles, game releases, frameworks,
    demos, videos, tutorials, blog posts, and more.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: And obviously, my blog, [http://www.emanueleferonato.com/](http://www.emanueleferonato.com/),
    is updated with almost daily news and tutorials.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you can refer to the official Cocos2d-JS site, [http://www.cocos2d-x.org/wiki/Cocos2d-JS](http://www.cocos2d-x.org/wiki/Cocos2d-JS),
    where you can find all new releases and under-development features.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this last chapter, you created a complete prototype of a Match-3 game using
    most of the features you learned during the reading of this book. Now, you should
    be able to create your own games starting from scratch, porting your ideas from
    pencil and paper to modern web browsers and mobile devices.
  prefs: []
  type: TYPE_NORMAL
