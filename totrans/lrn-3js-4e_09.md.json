["```js\nfunction animate() {\n  requestAnimationFrame(animate);\n  renderer.render(scene, camera);\n}\nanimate();\n```", "```js\nconst geometry = new THREE.TorusKnotGeometry(2, 0.5, 150, 50, 3, 4)\nconst material = new THREE.PointsMaterial({\n  size: 0.1,\n  vertexColors: false,\n  color: 0xffffff,\n  map: texture,\n  depthWrite: false,\n  opacity: 0.1,\n  transparent: true,\n  blending: THREE.AdditiveBlending\n})\nconst points = new THREE.Points(geometry, material)\npoints.userData.rotationSpeed = 0\npoints.userData.scalingSpeed = 0\npoints.userData.bouncingSpeed = 0\npoints.userData.currentStep = 0\npoints.userData.scalingStep = 0\n// in the render loop\nfunction render() {\n  const rotationSpeed = points.userData.rotationSpeed\n  const scalingSpeed = points.userData.scalingSpeed\n  const bouncingSpeed = points.userData.bouncingSpeed\n  const currentStep = points.userData.currentStep\n  const scalingStep = points.userData.scalingStep\n  points.rotation.x += rotationSpeed\n  points.rotation.y += rotationSpeed\n  points.rotation.z += rotationSpeed\n  points.userData.currentStep = currentStep + bouncingSpeed\n  points.position.x = Math.cos(points.userData.currentStep)\n  points.position.y = Math.abs(Math.sin\n   (points.userData.currentStep)) * 2\n  points.userData.scalingStep = scalingStep + scalingSpeed\n  var scaleX = Math.abs(Math.sin(scalingStep * 3 + 0.5 * \n    Math.PI))\n  var scaleY = Math.abs(Math.cos(scalingStep * 2))\n  var scaleZ = Math.abs(Math.sin(scalingStep * 4 + 0.5 * \n    Math.PI))\n  points.scale.set(scaleX, scaleY, scaleZ)\n}\n```", "```js\n// initially set the position to -1, -1\nlet pointer = {\n  x: -1,\n  y: -1\n}\n// when the mouse moves update the point\ndocument.addEventListener('mousemove', (event) => {\n  pointer.x = (event.clientX / window.innerWidth) * 2 - 1\n  pointer.y = -(event.clientY / window.innerHeight) * 2 + 1\n})\n// an array containing all the cubes in the scene\nconst cubes = ...\n// use in the render loop to determine the object to highlight\nconst raycaster = new THREE.Raycaster()\nfunction render() {\n  raycaster.setFromCamera(pointer, camera)\n  const cubes = scene.getObjectByName('group').children\n  const intersects = raycaster.intersectObjects(cubes)\n  // do something with the intersected objects\n}\n```", "```js\nconst orbit = new OrbitControls(camera, renderer.domElement)\norbit.update()\nconst controls = new DragControls(cubes, camera, renderer.domElement)\ncontrols.addEventListener('dragstart', function (event) {\n  orbit.enabled = false\n  event.object.material.emissive.set(0x33333)\n})\ncontrols.addEventListener('dragend', function (event) {\n  orbit.enabled = true\n  event.object.material.emissive.set(0x000000)\n})\n```", "```js\nconst tween = new TWEEN.Tween({x: 10}).to({x: 3}, 10000)\n.easing(TWEEN.Easing.Elastic.InOut)\n.onUpdate( function () {\n  // update the mesh\n})\n```", "```js\n  const tweenData = {\n    x: 10\n  }\n  new TWEEN.Tween(tweenData)\n    .to({ x: 3 }, 10000)\n    .yoyo(true)\n    .repeat(Infinity)\n    .easing(TWEEN.Easing.Bounce.InOut)\n    .start()\n  mesh.userData.tweenData = tweenData    \n```", "```js\nconst geometry = new THREE.TorusKnotGeometry(2, 0.5, 150, 50, 3, 4)\ngeometry.setAttribute('originalPos', geometry.attributes['position'].clone())\nconst material = new THREE.PointsMaterial(..)\nconst points = new THREE.Points(geometry, material)\nconst tweenData = {\n  pos: 1\n}\nnew TWEEN.Tween(tweenData)\n  .to({ pos: 3 }, 10000)\n  .yoyo(true)\n  .repeat(Infinity)\n  .easing(TWEEN.Easing.Bounce.InOut)\n  .start()\npoints.userData.tweenData = tweenData    \n// in the render loop\nconst originalPosArray = points.geometry.attributes.originalPos.array\nconst positionArray = points.geometry.attributes.position.array\nTWEEN.update()\n for (let i = 0; i < points.geometry.attributes.position.count; i++) {\n  positionArray[i * 3] = originalPosArray[i * 3] * points.userData.tweenData.pos\n  positionArray[i * 3 + 1] = originalPosArray[i * 3 + 1] * points.userData.tweenData.pos\n  positionArray[i * 3 + 2] = originalPosArray[i * 3 + 2] * points.userData.tweenData.pos\n}\npoints.geometry.attributes.position.needsUpdate = true\n```", "```js\ngeometry.setAttribute('originalPos', geometry.attributes['position'].clone())\n```", "```js\nconst originalPosArray = points.geometry.attributes.originalPos.array\nconst positionArray = points.geometry.attributes.position.array\nfor (let i = 0; i < points.geometry.attributes.position.count; i++) {\n  positionArray[i * 3] = originalPosArray[i * 3] * points.userData.tweenData.pos\n  positionArray[i * 3 + 1] = originalPosArray[i * 3 + 1] * points.userData.tweenData.pos\n  positionArray[i * 3 + 2] = originalPosArray[i * 3 + 2] * points.userData.tweenData.pos\n}\npoints.geometry.attributes.position.needsUpdate = true\n```", "```js\nimport { ArcballControls } from 'three/examples/jsm/controls/ArcballControls'\nconst controls = new ArcballControls(camera, renderer.domElement, scene)\ncontrols.update()\n```", "```js\nimport { TrackBallControls } from 'three/examples/jsm/\n  controls/TrackBallControls'\nconst controls = new TrackBallControls(camera, renderer.\n  domElement)\n```", "```js\nconst clock = new THREE.Clock()\nfunction animate() {\n  requestAnimationFrame(animate)\n  renderer.render(scene, camera)\n  controls.update(clock.getDelta())\n}\n```", "```js\nimport { FlyControls } from 'three/examples/jsm/controls/FlyControls'\nconst controls = new FlyControls(camera, renderer.domElement)\nconst clock = new THREE.Clock()\nfunction animate() {\n  requestAnimationFrame(animate)\n  renderer.render(scene, camera)\n  controls.update(clock.getDelta())\n}\n```", "```js\nImport { FirstPersonControls } from 'three/examples/jsm/\n  controls/FirstPersonControls'\nconst controls = new FirstPersonControls(camera, renderer.domElement)\nconst clock = new THREE.Clock()\nfunction animate() {\n  requestAnimationFrame(animate)\n  renderer.render(scene, camera)\n  controls.update(clock.getDelta())\n}\n```", "```js\nimport { OrbitControls } from 'three/examples/jsm/\n  controls/OrbitControls'\nconst controls = new OrbitControls(camera, renderer.\n  domElement)\nconst clock = new THREE.Clock()\nfunction animate() {\n  requestAnimationFrame(animate)\n  renderer.render(scene, camera)\n  controls.update(clock.getDelta())\n}\n```", "```js\nlet animations = []\nconst loadModel = () => {\n  const loader = new GLTFLoader()\n  return loader.loadAsync('/assets/models/blender-morph-targets/morph-targets.gltf').then((container) => {\n    animations = container.animations\n    return container.scene\n  })\n}\n```", "```js\nconst mixer = new THREE.AnimationMixer(mesh)\nconst action = mixer.clipAction(animations[0])\naction.play()\n```", "```js\n// in render loop\nmixer.update(clock.getDelta())\n```", "```js\nlet animations = []\nconst loadModel = () => {\n  const loader = new GLTFLoader()\n  return loader.loadAsync('/assets/models/blender-\n    skeleton/lpp-rigging.gltf').then((container) => {\n    container.scene.translateY(-2)\n    applyShadowsAndDepthWrite(container.scene)\n    animations = container.animations\n    return container.scene\n  })\n}\n```", "```js\nconst mixer = new THREE.AnimationMixer(mesh)\nconst action = mixer.clipAction(animations[0])\naction.play()\n```", "```js\nimport { GLTFLoader } from 'three/examples\n  /jsm/loaders/GLTFLoader'\n...\nreturn loader.loadAsync('/assets/models/truffle_man/scene.gltf').\n  then((container) => {\n  container.scene.scale.setScalar(4)\n  container.scene.translateY(-2)\n  scene.add(container.scene)\n\n  const mixer = new THREE.AnimationMixer( container.scene ); \n  const animationClip = container.animations[0];\n  const clipAction = mixer.clipAction( animationClip ).\nplay(); \n})\n```", "```js\nimport { FBXLoader } from 'three/examples/jsm/loaders/FBXLoader'\n...\nloader.loadAsync('/assets/models/salsa/salsa.fbx').then((mesh) => {\n  mesh.translateX(-0.8)\n  mesh.translateY(-1.9)\n  mesh.scale.set(0.03, 0.03, 0.03)\n  scene.add(mesh)\n  const mixer = new THREE.AnimationMixer(mesh)\n  const clips = mesh.animations\n  const clip = THREE.AnimationClip.findByName(clips, \n    'mixamo.com')   \n})\n```", "```js\nlet animations = []\nconst loader = new MD2Loader()\nloader.loadAsync('/assets/models/ogre/ogro.md2').then\n  ((object) => {\n  const mat = new THREE.MeshStandardMaterial({\n    color: 0xffffff,\n    metalness: 0,\n    map: new THREE.TextureLoader().load\n      ('/assets/models/ogre/skins/skin.jpg')\n  })\n  animations = object.animations\n  const mesh = new THREE.Mesh(object, mat)\n  // add to scene, and you can animate it as we've seen \n    already\n})\n```", "```js\nconst loader = new BVHLoader()\nlet animation = undefined\nloader.loadAsync('/assets/models//amelia-dance/DanceNightClub7_t1.bvh').then((result) => {\n  const skeletonHelper = new THREE.SkeletonHelper\n    (result.skeleton.bones[0])\n  skeletonHelper.skeleton = result.skeleton\n  const boneContainer = new THREE.Group()\n  boneContainer.add(result.skeleton.bones[0])\n  animation = result.clip\n  const group = new THREE.Group()\n  group.add(skeletonHelper)\n  group.add(boneContainer)\n  group.scale.setScalar(0.2)\n  group.translateY(-1.6)\n  group.translateX(-3)\n  // Now we can animate the group just like we did for the \n    other examples\n})\n```"]