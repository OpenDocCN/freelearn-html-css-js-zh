<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Handling Web Requests with Express</h1></div></div></div><p>Express is a powerful, unopinionated web application framework built on top of Node.js. It provides a highly pluggable interface and a few basic objects to handle the HTTP request response life cycle.</p><p>We have already begun working with Express, beginning our SPA with the Express generator. It's time to build things out further and learn more about the power of Express.</p><p>Express's true power comes from its minimal and unopinionated nature. It's highly flexible and extensible, making it a good tool for a number of web applications, single page, hybrid, even socket-based.</p><p>This chapter covers Express in more detail, starting with built-in objects. We will build out a number of routes, organizing the code of our application into logical modules. We will learn about the request and response objects in Express in detail, and develop our own middleware functionality to handle AJAX requests.</p><p>We will conclude by stubbing out a RESTful API for our SPA, configuring it to respond using different data formats.</p><p>This chapter covers the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Configuring Express</li><li class="listitem" style="list-style-type: disc">Express request and response objects</li><li class="listitem" style="list-style-type: disc">Passing variables in GET and POST request</li><li class="listitem" style="list-style-type: disc">Developing Express middleware</li><li class="listitem" style="list-style-type: disc">Building RESTful services</li><li class="listitem" style="list-style-type: disc">Organizing routes into logical modules</li></ul></div><div><div><div><div><h1 class="title"><a id="ch09lvl1sec54"/>Examining Express in detail</h1></div></div></div><p>Express represents a very thin layer on top of Node's HTTP server, but it has a few built-in objects that are important to become familiar with. These include the <code class="literal">App</code>, <code class="literal">Request</code>, <code class="literal">Response</code>, and <code class="literal">Router</code> objects. These objects, and a couple of plugins, provide all of the core functionality of the Express framework.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec113"/>App object</h2></div></div></div><p>In Express, the <code class="literal">app</code> object typically refers to the Express application. This is by convention and is the result of calling the <code class="literal">express()</code> function. Open up your <code class="literal">app.js</code> file and see the line that reads <code class="literal">varapp=express()</code>. This is where we create our application and assign it to the variable <code class="literal">app</code>. We could have used any variable name, but the convention is to use <code class="literal">app</code>. We'll stick to convention and refer to this object as <code class="literal">app</code>.</p><p>Let's take a closer look at our <code class="literal">app.js</code> file and look at how we're already using the <code class="literal">app</code> object:</p><pre class="programlisting">var express = require('express'); &#13;
var path = require('path'); &#13;
var favicon = require('serve-favicon'); &#13;
var logger = require('morgan'); &#13;
var cookieParser = require('cookie-parser'); &#13;
var bodyParser = require('body-parser'); &#13;
 &#13;
//Database stuff &#13;
var mongodb = require('mongodb'); &#13;
var monk = require('monk'); &#13;
var db = monk('localhost:27017/giftapp') &#13;
 &#13;
var routes = require('./routes/index'); &#13;
var users = require('./routes/users'); &#13;
 &#13;
var app = express(); &#13;
 &#13;
// view engine setup &#13;
app.set('views', path.join(__dirname, 'views')); &#13;
app.set('view engine', 'ejs'); &#13;
 &#13;
// uncomment after placing your favicon in /public &#13;
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))); &#13;
app.use(logger('dev')); &#13;
app.use(bodyParser.json()); &#13;
app.use(bodyParser.urlencoded({ extended: false })); &#13;
app.use(cookieParser()); &#13;
app.use(express.static(path.join(__dirname, 'public'))); &#13;
 &#13;
//Database middlewear &#13;
app.use(function(req,res,next){ &#13;
    req.db = db; &#13;
    next(); &#13;
}); &#13;
 &#13;
app.use('/', routes); &#13;
app.use('/users', users); &#13;
 &#13;
// catch 404 and forward to error handler &#13;
app.use(function(req, res, next) { &#13;
  var err = new Error('Not Found'); &#13;
  err.status = 404; &#13;
  next(err); &#13;
}); &#13;
 &#13;
// error handlers &#13;
 &#13;
// development error handler &#13;
// will print stacktrace &#13;
if (app.get('env') === 'development') { &#13;
  app.use(function(err, req, res, next) { &#13;
    res.status(err.status || 500); &#13;
    res.render('error', { &#13;
      message: err.message, &#13;
      error: err &#13;
    }); &#13;
  }); &#13;
} &#13;
 &#13;
// production error handler &#13;
// no stacktraces leaked to user &#13;
app.use(function(err, req, res, next) { &#13;
  res.status(err.status || 500); &#13;
  res.render('error', { &#13;
    message: err.message, &#13;
    error: {} &#13;
  }); &#13;
}); &#13;
 &#13;
module.exports = app; &#13;
</pre><p>The <code class="literal">app</code> API includes an important property, event, and a number of methods. To see a full list of functionality in the Express application API, you can view the documentation at <a class="ulink" href="http://expressjs.com/en/api.html">http://expressjs.com/en/api.html</a>, but we'll cover some of the most important features here.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec117"/>app.locals</h3></div></div></div><p>
<code class="literal">app.locals</code> is a JavaScript object that persists within the application itself. Any properties or functions added to the object will be available throughout the <code class="literal">app</code>. This is useful for creating helper functions or app level values.</p><p>The <code class="literal">app.locals</code> objects are available in middleware through the request object through <code class="literal">req.app.locals</code>.</p><p>Add the following line in your <code class="literal">app.js</code> file after the calls to <code class="literal">app.set();</code>:<code class="literal">app.locals.appName="MyGiftApp";</code>
</p><p>Now open up your <code class="literal">routes/users.js</code> file and modify it like so:</p><pre class="programlisting">var express = require('express'); &#13;
var router = express.Router(); &#13;
 &#13;
/* GET users listing. */ &#13;
router.get('/', function(req, res, next) { &#13;
  res.send('respond with a resource'); &#13;
}); &#13;
 &#13;
router.get('/show', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.find({}, {}, function(err,docs){ &#13;
        if(!err){ &#13;
            //res.json(docs); &#13;
<strong>            res.render('users/show',&#13;
 {&#13;
</strong>
<strong>                users: docs,&#13;
</strong>
<strong>                appName: req.app.locals.appName&#13;
</strong>
<strong>            }&#13;
);</strong> &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
module.exports = router; &#13;
</pre><p>Inside the route for show, we added a bit of data to the second argument to <code class="literal">res.render()</code>. We mapped <code class="literal">req.app.locals.appname</code> to the property <code class="literal">appName</code>. This makes it available to our template.</p><p>Now open your <code class="literal">views/users/show.ejs</code> template file and modify it:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
    &lt;title&gt;Show Users&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
<strong>&lt;h1&gt;User List: &lt;%= appName %&gt;&lt;/h1&gt;</strong> &#13;
 &#13;
&lt;table&gt; &#13;
    &lt;thead&gt; &#13;
        &lt;tr&gt; &#13;
 &#13;
            &lt;th&gt;First Name&lt;/th&gt; &#13;
            &lt;th&gt;Last Name&lt;/th&gt; &#13;
            &lt;th&gt;Email Address&lt;/th&gt; &#13;
        &lt;/tr&gt; &#13;
    &lt;/thead&gt; &#13;
    &lt;tbody&gt; &#13;
    &lt;% users.forEach(function(user, index){ -%&gt; &#13;
        &lt;tr&gt; &#13;
            &lt;td&gt;&lt;%= user.firstName %&gt;&lt;/td&gt; &#13;
            &lt;td&gt;&lt;%= user.lastName %&gt;&lt;/td&gt; &#13;
            &lt;td&gt;&lt;%= user.email %&gt;&lt;/td&gt; &#13;
        &lt;/tr&gt; &#13;
    &lt;% }); %&gt; &#13;
    &lt;/tbody&gt; &#13;
&lt;/table&gt; &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>We've added an output tag for the <code class="literal">appName</code> property.</p><p>Now, make sure that the Mongo daemon is running and start or restart your application. In your browser, navigate to<code class="literal">:localhost:3000/users/show</code> and you should see something like the following:</p><p>
</p><div><img src="img/image_09_001.jpg" alt="app.locals"/></div><p>
</p><p>We've successfully added an application level local property and displayed it in one of our templates.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec118"/>app.set()</h3></div></div></div><p>After we create the application by calling the express function, we see a couple of calls to <code class="literal">app.set()</code> setting the path to the views directory and the view engine. The set function takes two arguments. The first argument is a string containing the name of one of the application settings for Express. Some application settings include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">casesensitiverouting</code>: A Boolean, disabled by default. When enabled, it ignores the case of routes. <code class="literal">/route</code> and <code class="literal">/Route</code> would be treated as the same route.</li><li class="listitem" style="list-style-type: disc"><code class="literal">env</code>: A string setting for the environment mode. The default is <code class="literal">development</code> or whatever the <code class="literal">NODE_ENV</code> environment variable is set to.</li><li class="listitem" style="list-style-type: disc"><code class="literal">etag</code>: A setting for the <code class="literal">ETag</code> response header. It has a sensible default, but if you want to change it, I suggest referring to the documentation.</li><li class="listitem" style="list-style-type: disc"><code class="literal">jsonpcallbackname</code>: A string, specifying a default callback function for JSONP responses.</li><li class="listitem" style="list-style-type: disc"><code class="literal">jsonspaces</code>: Numeric, when specified, it sends JSON responses back prettified and indented by the specified number of spaces.</li><li class="listitem" style="list-style-type: disc"><code class="literal">queryparser</code>: By default, this is set to <code class="literal">extended</code>, but you can use it to disable query parsing or to set a simpler or customized query parsing function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">strictrouting</code>: A Boolean, disabled by default treating <code class="literal">/route</code> the same as <code class="literal">/route/</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">views</code>: A string or array telling Express where to look up display templates. If the value is an array, Express will look them up in the order they occur in the array.</li><li class="listitem" style="list-style-type: disc"><code class="literal">viewcache</code>: A Boolean, true in production, this tells Express to cache the view templates. This is usually undesired in development.</li><li class="listitem" style="list-style-type: disc"><code class="literal">viewengine</code>: A string - the default engine extension (such as <code class="literal">ejs</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">x-powered-by</code>: A Boolean, true by default, sends a <code class="literal">X-Powered-By:Express</code> HTTP header. I think it's normally a good idea to shut this off, giving less information to potential hackers. Go ahead and add <code class="literal">app.set('x-powered-by',false);</code> to your <code class="literal">app.js</code> file after the line setting the view engine.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec119"/>app.enable()</h3></div></div></div><p>Any of the <code class="literal">app</code> settings that take Booleans can be turned on with <code class="literal">app.enable()</code>; for example, to enable view caching, you can use <code class="literal">app.enable('viewcache');</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec120"/>app.disable()</h3></div></div></div><p>If you have an enable function, you should have a disable function as well, right? <code class="literal">app.disable()</code> sets any <code class="literal">app</code> settings that are Boolean to false, turning them off.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec121"/>app.listen()</h3></div></div></div><p>Under the covers, the app object returned by the call to <code class="literal">express()</code> is a JavaScript function. Remember that functions in JavaScript are objects and can be passed around like any other objects. When we call <code class="literal">app.listen()</code>, it essentially invokes Node's native <code class="literal">http.createServer()</code> function passing itself, the <code class="literal">app</code> function, as a callback.</p><p>If we want to use HTTPS, it's a little different, and we'll cover that in a later chapter.</p><p>For our purposes, we would use <code class="literal">app.listen()</code> passing the port we wish to listen to as the argument. However, the Express generator has set up our code for us in <code class="literal">bin/www</code>, as shown in the following code:</p><pre class="programlisting">/** &#13;
 * Module dependencies. &#13;
 */ &#13;
 &#13;
var app = require('../app'); &#13;
var debug = require('debug')('giftapp:server'); &#13;
var http = require('http'); &#13;
 &#13;
/** &#13;
 * Get port from environment and store in Express. &#13;
 */ &#13;
 &#13;
var port = normalizePort(process.env.PORT || '3000'); &#13;
app.set('port', port); &#13;
 &#13;
/** &#13;
 * Create HTTP server. &#13;
 */ &#13;
 &#13;
var server = http.createServer(app); &#13;
 &#13;
/** &#13;
 * Listen on provided port, on all network interfaces. &#13;
 */ &#13;
 &#13;
server.listen(port); &#13;
server.on('error', onError); &#13;
server.on('listening', onListening); &#13;
</pre><p>Instead of simply calling <code class="literal">app.listen()</code>, the Express generator has set up this method, which is essentially doing the same thing, but adding some event listeners to the server object for error handling, and more.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec122"/>app.METHOD()</h3></div></div></div><p>
<code class="literal">app.METHOD()</code> routes requests that come into the server using an actual method. There isn't a <code class="literal">METHOD</code> function, the actual functions are the lowercase of specific HTTP request methods. In other words, you would use <code class="literal">app.get()</code> or <code class="literal">app.post()</code> methods.</p><p>There can be small point of confusion here because <code class="literal">app.get('somevalue')</code> can also be used to return an <code class="literal">app</code> setting.</p><p>In general, we are going to hand off requests to the Express router and handle routing in a more modular manner.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec123"/>app.all()</h3></div></div></div><p>
<code class="literal">app.all()</code> is similar to <code class="literal">app.METHOD()</code>, but it matches all HTTP request methods. It's often used to easily add global functionality via middleware to a path or part of an application.</p><p>For example, if you want to add authentication to a part of your <code class="literal">app</code> without the bother of adding it to each individual route or method, you might do something like this:</p><pre class="programlisting">app.all('/protected/', authenticationRequired); &#13;
</pre><p>This would pass all requests, regardless of method, which began with the path <code class="literal">/protected/</code> through the <code class="literal">authenticationRequired</code> middleware.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec114"/>Request object</h2></div></div></div><p>The request object in Express holds data related to the HTTP request. By default, it will contain properties for things such as the query string, parameters, headers, post parameters, and more. It is the first argument in callback functions provided by middleware, like routing, and, by convention, is usually called <code class="literal">req</code>:</p><pre class="programlisting">router.get('/show', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.find({}, {}, function(err,docs){ &#13;
        if(!err){ &#13;
            //res.json(docs); &#13;
            res.render('users/show', { &#13;
                users: docs, &#13;
                appName: req.app.locals.appName &#13;
            }); &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
</pre><p>In our routes<code class="literal">/users</code> file, here is our one route for a get request for the URI <code class="literal">/show</code>. You can see that the first argument to the callback function is <code class="literal">req</code>. This is the request object. We get a reference to the database from the request object, as well as a reference to the <code class="literal">app.locals.appName</code> property.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec124"/>req.params</h3></div></div></div><p>The <code class="literal">params</code> property of the request object gives us access to parameters passed to the server through the URL.</p><p>Let's modify our <code class="literal">routes/users</code> file to add a new route:</p><pre class="programlisting">var express = require('express'); &#13;
var router = express.Router(); &#13;
 &#13;
/* GET users listing. */ &#13;
router.get('/', function(req, res, next) { &#13;
  res.send('respond with a resource'); &#13;
}); &#13;
 &#13;
<strong>router.get('/show/:id', function(req, res, next)&#13;
 {&#13;
</strong>
<strong>    var db = req.db;&#13;
</strong>
<strong>    var collection = db.get('users');&#13;
</strong>
<strong>    collection.findOne({ "_id": req.params.id },{}, function(err,User)&#13;
{</strong>
<strong>        &#13;
if(!err)&#13;
{&#13;
</strong>
<strong>            res.render('users/user',&#13;
 {&#13;
</strong>
<strong>                user: User,&#13;
</strong>
<strong>                appName: req.app.locals.appName&#13;
</strong>
<strong>            }&#13;
);&#13;
</strong>
<strong>        }&#13;
else&#13;
{&#13;
</strong>
<strong>            res.send('error');&#13;
</strong>
<strong>        }&#13;
</strong>
<strong>    });&#13;
</strong>
<strong>});</strong> &#13;
 &#13;
router.get('/show', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.find({}, {}, function(err,docs){ &#13;
        if(!err){ &#13;
            //res.json(docs); &#13;
            res.render('users/show', { &#13;
                users: docs, &#13;
                appName: req.app.locals.appName &#13;
            }); &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
 &#13;
module.exports = router; &#13;
</pre><p>We've added a new route that matches <code class="literal">/show/:id</code>. The <code class="literal">:id</code> portion will match a variable part of the URL; in this case we are expecting an ID, and place that on the <code class="literal">req.params</code> object as a property named <code class="literal">id</code>.</p><p>We issue a <code class="literal">findOne</code> query to our database on the users collection. <code class="literal">findOne</code> returns a single object (the first match), where find returns an array with all matches. In this case, we are only interested in a single match; we are looking for a user with a specific <code class="literal">_id</code>.</p><p>Then we render the <code class="literal">users/user</code> template passing our values. We don't have a user template yet, so let's create <code class="literal">user.ejs</code> in our <code class="literal">views/users</code> directory:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
    &lt;title&gt;&lt;%= appName %&gt;: &lt;%= user.firstName %&gt; &lt;%= user.lastName  &#13;
%&gt;&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
&lt;h1&gt;&lt;%= user.firstName %&gt; &lt;%= user.lastName %&gt;&lt;/h1&gt; &#13;
&lt;ul&gt; &#13;
    &lt;li&gt;Email: &lt;%= user.email %&gt;&lt;/li&gt; &#13;
    &lt;li&gt;Id: &lt;%= user._id %&gt;&lt;/li&gt; &#13;
&lt;/ul&gt; &#13;
 &#13;
&lt;p&gt;&lt;a href="/users/show"&gt;&amp;lt; Back&lt;/a&gt;&lt;/p&gt; &#13;
 &#13;
 &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>The object passed into the template containing our user data is called <code class="literal">user</code>. Here, we can access all its properties, <code class="literal">firstName</code>, <code class="literal">lastName</code>, <code class="literal">email</code>, and <code class="literal">_id</code>. To make life a little easier, we've added a link to go back to the show route.</p><p>Let's modify <code class="literal">show.ejs</code> a little to add navigation:</p><pre class="programlisting">&lt;!DOCTYPE html&gt; &#13;
&lt;html&gt; &#13;
&lt;head&gt; &#13;
    &lt;title&gt;Show Users&lt;/title&gt; &#13;
    &lt;link rel='stylesheet' href='/stylesheets/style.css' /&gt; &#13;
&lt;/head&gt; &#13;
&lt;body&gt; &#13;
&lt;h1&gt;User List: &lt;%= appName %&gt;&lt;/h1&gt; &#13;
 &#13;
&lt;table&gt; &#13;
    &lt;thead&gt; &#13;
        &lt;tr&gt; &#13;
 &#13;
            &lt;th&gt;First Name&lt;/th&gt; &#13;
            &lt;th&gt;Last Name&lt;/th&gt; &#13;
            &lt;th&gt;Email Address&lt;/th&gt; &#13;
        &lt;/tr&gt; &#13;
    &lt;/thead&gt; &#13;
    &lt;tbody&gt; &#13;
    &lt;% users.forEach(function(user, index){ -%&gt; &#13;
        &lt;tr&gt; &#13;
<strong>            &lt;td&gt;&lt;a href=""show/&lt;%= user._id%&gt;""&gt;&lt;%= user.firstName %&gt;&lt;/a&gt;&lt;/td&gt;</strong> &#13;
            &lt;td&gt;&lt;%= user.lastName %&gt;&lt;/td&gt; &#13;
            &lt;td&gt;&lt;%= user.email %&gt;&lt;/td&gt; &#13;
        &lt;/tr&gt; &#13;
    &lt;% }); %&gt; &#13;
    &lt;/tbody&gt; &#13;
&lt;/table&gt; &#13;
 &#13;
 &#13;
&lt;/body&gt; &#13;
&lt;/html&gt; &#13;
</pre><p>We've added a link to <code class="literal">show/&lt;%=user._id%&gt;,</code> which will create the URL we need to navigate to the individual user's show route.</p><p>Start or restart your server. A restart is required any time you change a route or the main application, but not for simple template changes.</p><p>Navigate to <code class="literal">localhost:3000/users/show</code> and click on one of your user's first names. You should see something like this:</p><p>
</p><div><img src="img/image_09_002.jpg" alt="req.params"/></div><p>
</p><p>Of course, because Mongo generates the <code class="literal">_id</code> field, yours will not match mine. Well, they might, but it would be an astronomical coincidence.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec125"/>req.body</h3></div></div></div><p>The <code class="literal">body</code> property on the request object contains name value pairs typically sent as part of a post request. In order to get access to this, you need to add <code class="literal">body</code> parsing middleware to your <code class="literal">app</code>.</p><p>The Express generator has already set this up for us by requiring a <code class="literal">body</code> parser and then adding the middleware in these two lines:</p><pre class="programlisting">app.use(bodyParser.json()); &#13;
app.use(bodyParser.urlencoded({ extended: false })); &#13;
</pre><p>These two lines allow us to parse data sent back as <code class="literal">application/json or application/x-www-form-urlencoded</code>.</p><p>In our routes, we would have access to parameters passed in through <code class="literal">req.body</code>. We'll be doing a lot of that when we start to build resourceful routes later. Here's an example (there's no need to add it to our code):</p><pre class="programlisting">router.post('/user', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.insert({ firstName: req.body.firstName, &#13;
                        lastName: req.body.lastName, &#13;
                        email: req.body.email}, &#13;
                        function(err){ &#13;
        if(!err){ &#13;
            res.redirect('/users/show'); &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
</pre><p>Here, we accept a post to <code class="literal">users/user</code>. We use <code class="literal">monk</code> to do an insert (adding a record to our MongoDB database). The first argument to the insert function is an object, and we are using the <code class="literal">firstName</code>, <code class="literal">lastName</code>, and <code class="literal">email</code> fields from <code class="literal">req.body</code> to populate the same properties of the document to be inserted. Assuming there's no error, we redirect to <code class="literal">users/show</code>, which displays a list of users including our new user.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec126"/>req.query</h3></div></div></div><p>Another way we can get data from a request is using the query string appended to a URL. If you are unfamiliar with this, the query string is data that is appended as name value pairs after a question mark on the URL.</p><p>For example, in <code class="literal">http:www.mymadeupdomain.org/foo?name=john+smith&amp;q=foo</code>, the query string part is the <code class="literal">name=john+smith&amp;q=foo</code>. To access this inside our <code class="literal">app</code>, we would use <code class="literal">req.query.name</code> and <code class="literal">req.query.q</code>. This would give us back <code class="literal">johnsmith</code> and <code class="literal">foo</code> respectively with no plus sign between <code class="literal">john</code> and <code class="literal">smith</code>. The plus sign is part of URL encoding that happens because spaces don't translate in URLs.</p><p>If there is no query string, <code class="literal">req.query</code> will contain an empty object.</p><div><div><h3 class="title"><a id="note12"/>Note</h3><p>
<strong>When should I use a query string instead of parameters?</strong></p><p>There's no best answer for this. In general, you want to use route parameters when you want multiple routes to handle different types of operations. We're going to take this approach most of the time. Query strings are good if you want a single <code class="literal">GET</code> request route that's going to be flexible with the type of data it receives, and you want users to be able to bookmark it. Google uses query strings for searches: <a class="ulink" href="https://www.google.com/search?q=things">https://www.google.com/search?q=things</a>.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec127"/>req.cookies</h3></div></div></div><p>
<code class="literal">req.cookies</code> requires the use of the cookie parser middleware, conveniently already installed for us by the Express generator, and gives us access to the cookies in the request. If there are no cookies, the value of <code class="literal">req.cookies</code> will be an empty object.</p><p>Cookies are accessed by name: <code class="literal">req.cookies.userID</code> would give us a cookie named <code class="literal">userID</code>.</p><div><div><h3 class="title"><a id="note13"/>Note</h3><p>We will delve into cookies in more detail later, but the cookie parser is required for things such as authentication and security. It's best to leave it in place whether you are going to use cookies directly or not.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec128"/>req.xhr</h3></div></div></div><p>This is a simple Boolean value that is <code class="literal">true</code> if the <code class="literal">X-Requested-With</code> request header is <code class="literal">XMLHttpRequest</code>. Most commonly, this happens with AJAX requests issued by libraries such as jQuery.</p><p>This is useful for SPAs because we may want to respond with an HTML page when the request comes from a change in location from the browser, but with data when subsequent requests come from client-side code issuing requests through AJAX.</p><p>Let's look at our <code class="literal">/show/:id</code> route from <code class="literal">/routes/users.js</code>:</p><pre class="programlisting">router.get('/show/:id', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.findOne({ ""_id"": req.params.id }, {}, function(err,User){ &#13;
        if(!err){ &#13;
<strong>            if(req.xhr){&#13;
</strong>
<strong>                User.appName = req.app.locals.appName;&#13;
</strong>
<strong>                res.json(User);&#13;
</strong>
<strong>            } else {&#13;
</strong>
<strong>                res.render('users/user',&#13;
 {&#13;
</strong>
<strong>                    user: User,&#13;
</strong>
<strong>                    appName: req.app.locals.appName&#13;
</strong>
<strong>                });&#13;
</strong>
<strong>            }</strong> &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
</pre><p>So we check to see if the request has come in through <code class="literal">XMLHTTPRequest</code>, AJAX. If it has, we add the <code class="literal">appName</code> to the <code class="literal">User</code> object and then return it as JSON. If it didn't, we render and return the page as normal.</p><p>This is quite handy, and we'll use this mechanism later.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec129"/>req.accepts()</h3></div></div></div><p>
<code class="literal">req.accepts</code> is a function which checks a request's <code class="literal">Accept</code> header and returns <code class="literal">true</code> if there's a match. It can accept a string or array or extensions or MIME types, and returns either the best match or <code class="literal">false</code> (<code class="literal">undefined</code>, which is a falsy value in JavaScript), if there's nothing matching.</p><p>For example, let's say the browser sends back the header: <code class="literal">Accept:text/*</code>. <code class="literal">application/json</code>: <code class="literal">req.accepts('html')</code> would match the <code class="literal">text/*</code> part and return <code class="literal">html</code>. <code class="literal">req.accepts(['image/png','application/json'])</code> would return <code class="literal">json</code>.</p><p>As with <code class="literal">req.xhr</code>, this can be very useful for responding flexibly to different types of requests on the same route.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec130"/>req.get()</h3></div></div></div><p>
<code class="literal">req.get()</code> is a function that returns the value of an HTTP header sent in the request. The function takes a string which does case-insensitive matching. An alias of this function is <code class="literal">req.header()</code>.</p><p>For example, <code class="literal">req.get('content-type')</code> returns the content type header from the HTTP request as a string, such as <code class="literal">application/json</code> or <code class="literal">text/html</code>.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec115"/>Response object</h2></div></div></div><p>The Express response object is a JavaScript object that represents the response that we are going to send back from the server to the client. We see it paired with the request object and, like using <code class="literal">req</code> for request, the convention is to use <code class="literal">res</code>.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec131"/>res.app</h3></div></div></div><p>The <code class="literal">res.app</code> object is identical to the <code class="literal">req.app</code> property. It's a reference to the application, but attached to the response object in this case. This offers some flexibility in accessing the app properties.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec132"/>res.cookie()</h3></div></div></div><p>This is a response object method that allows us to set a cookie and send it back with the response. It takes a name, value, and an optional object containing parameters.</p><p>Here's an example:</p><pre class="programlisting">res.cookie('userName', 'Joe', { maxage: 900000, secure: true, signed:true }); &#13;
</pre><p>This sets a <code class="literal">userName</code> cookie with a value of <code class="literal">Joe</code>. The cookie expires 900,000 seconds from the response. The cookie is to be used with HTTPS only, and it is to be signed. Other options that can be set are the domain and path for the cookie, and an actual expiration date.</p><p>This method clears the named cookie:</p><pre class="programlisting">res.clearCookie() &#13;
</pre><p>This would clear the cookie we set previously:</p><pre class="programlisting">res.clearCooke('userName'); &#13;
</pre></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec133"/>res.download()</h3></div></div></div><p>
<code class="literal">res.download</code> transfers a file at a given path as an attachment. It takes the path, an optional filename, and an option callback function once the file transfer completes:</p><pre class="programlisting">res.download('/reports/TPS-coversheet.pdf', 'coversheet.pdf, function(err){ &#13;
  if(err){ &#13;
    //handle error here &#13;
} else { &#13;
    //do something appropriate &#13;
  } &#13;
}); &#13;
</pre><p>We initiate a download of the file at <code class="literal">/reports/TPS-coversheet</code>, but transfer it as <code class="literal">coversheet.pdf</code>. Once complete, we check if there was an error, doing something appropriate in any case.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec134"/>res.json()</h3></div></div></div><p>This method sends a JSON response, it's that straightforward. It can take any JavaScript object. The nice thing about using a MongoDB database is that often we can just pass out raw database responses using <code class="literal">res.json():</code>
</p><pre class="programlisting">res.json({dog: 'Fido', breed: 'Sheltie' commands: {sit: true, stay: false}); &#13;
</pre><p>Here, we respond with JSON passing an object with properties for our <code class="literal">Sheltie</code> named <code class="literal">Fido</code> and the commands that she knows.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec135"/>res.jsonp()</h3></div></div></div><p>This method returns JSON data wrapped in a callback function, otherwise known as JSONP. By default the function will be called callback. But this can be overridden using <code class="literal">app.set('jsonpcallbackname','someFunction');</code>. In this case, we get the following:</p><pre class="programlisting">res.jsonp({dog: 'Fido'); &#13;
//returns someFunction({""dog"": ""Fido""}) &#13;
</pre><p>Of course, the appropriate client-side code would have to be in place to handle the response.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec136"/>res.redirect()</h3></div></div></div><p>We've already used this one. This sends a redirect back to the requester with an appropriate HTTP status code. If no status code is specified, a <code class="literal">302</code> is used.</p><p>Here's something we looked at earlier:</p><pre class="programlisting">router.post('/user', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.insert({ firstName: req.body.firstName, &#13;
                        lastName: req.body.lastName, &#13;
                        email: req.body.email}, &#13;
                        function(err){ &#13;
        if(!err){ &#13;
<strong>            res.redirect('/users/show');</strong> &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
</pre><p>After an insert operation, adding a new document to our database, we send a redirect back to the browser to go to <code class="literal">/users/show</code>. Because no status was specified, a <code class="literal">302</code> will be returned.</p><p>The path is quite flexible and can be anything from a fully formed URL: <code class="literal">res.redirect('https://www.google.com/search?q=food');</code> to a relative path: <code class="literal">res.redirect('../dashboard/show');</code>.</p><pre class="programlisting">res.redirect(301, 'http://www.whitehouse.gov'); &#13;
</pre><p>This sends a permanently moved redirect to <code class="literal">whitehouse.gov</code>, consequently confusing Google and ruining your SEO. For more information about various redirect codes, check out the official HTTP specification, paying attention to the <code class="literal">3xx</code> status codes: <a class="ulink" href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</a>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec137"/>res.render()</h3></div></div></div><p>This is another method we've already used, which sends back rendered HTML which has been compiled from a <code class="literal">view</code> template. The arguments to the method are the template view, an optional object containing local variables, and an optional callback function.</p><p>Let's take a peek at our <code class="literal">/show</code> route inside our routes<code class="literal">/users.js</code> file:</p><pre class="programlisting">router.get('/show', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.find({}, {}, function(err,docs){ &#13;
        if(!err){ &#13;
            //res.json(docs); &#13;
<strong>            res.render('users/show',&#13;
 {&#13;
</strong>
<strong>                users: docs,&#13;
</strong>
<strong>                appName: req.app.locals.appName&#13;
</strong>
<strong>            }&#13;
);</strong> &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
</pre><p>As we've seen, this call to <code class="literal">res.render()</code> renders the template at <code class="literal">/views/users/show</code>. It makes the local object with users and <code class="literal">appName</code> available to the template.</p><p>If we you add a callback method to the render method, you need to call <code class="literal">res.send()</code> explicitly:</p><pre class="programlisting">res.render('users/show', { &#13;
    users: docs, &#13;
    appName: req.app.locals.appName &#13;
}, function(err, html){ &#13;
    if(!err){ &#13;
    res.cookie('rendered':""someValue"") &#13;
        res.send(html); &#13;
    } else { &#13;
        res.send(""There's been a horrible error.""); &#13;
    } &#13;
}); &#13;
</pre><p>Here, we've added a callback function which has two arguments, an error, if any, and the rendered <code class="literal">html</code>. This allows us to add an error handler, set a cookie on the response object, and then send the response.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec138"/>res.send()</h3></div></div></div><p>We've seen that <code class="literal">res.send()</code> is a method that is used to send the HTTP response. <code class="literal">res.send()</code> is pretty flexible and can give a number of different types of arguments, including a <code class="literal">Buffer</code>, an object, array, or a string.</p><p>
<code class="literal">res.send()</code> will adjust the HTTP <code class="literal">Content-Type</code> header appropriately for the argument. When the argument is a string the <code class="literal">Content-Type</code> will be <code class="literal">text/html</code>, when an object or array it will be <code class="literal">application/json</code>, and when it's a <code class="literal">Buffer</code> object it will be set to <code class="literal">application/octet-stream</code>. These defaults can be overridden by calling <code class="literal">res.set()</code> with a different <code class="literal">Content-Type</code>.</p><p>We can also chain a call to <code class="literal">status()</code> to pass an HTTP status:</p><pre class="programlisting">router.get('/show', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.find({}, {}, function(err,docs){ &#13;
        if(!err){ &#13;
            //res.json(docs); &#13;
            res.render('users/show', { &#13;
                users: docs, &#13;
                appName: req.app.locals.appName &#13;
            }); &#13;
        }else{ &#13;
<strong>            res.status(500).send(""There has been a major error"");</strong> &#13;
        } &#13;
    }); &#13;
}); &#13;
</pre><p>By chaining the status with a <code class="literal">500</code> HTTP status, we can send a message that there's been an internal server error along with our message.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec116"/>Router object</h2></div></div></div><p>The router object is described in the Express documentation as a <code class="literal">mini-application</code> that only provides middleware and routing functionality. The router acts as middleware so it can be used as an argument in <code class="literal">app.use()</code> or in another router's <code class="literal">use()</code> method, making nesting and organizing routes easy.</p><p>We create a router object by calling the <code class="literal">express.Router()</code> function:</p><pre class="programlisting">var router = express.Router(); &#13;
</pre><p>In our router files, we always export the router using <code class="literal">module.exports=router</code>. This allows us to load the router as a module through <code class="literal">require()</code> and then use it like any other middleware.</p><p>Let's review our <code class="literal">app.js</code> file again:</p><pre class="programlisting">var express = require('express'); &#13;
var path = require('path'); &#13;
var favicon = require('serve-favicon'); &#13;
var logger = require('morgan'); &#13;
var cookieParser = require('cookie-parser'); &#13;
var bodyParser = require('body-parser'); &#13;
 &#13;
//Database stuff &#13;
var mongodb = require('mongodb'); &#13;
var monk = require('monk'); &#13;
var db = monk('localhost:27017/giftapp') &#13;
 &#13;
<strong>var routes = require('./routes/index');</strong>
<strong>var users = require('./routes/users');</strong> &#13;
 &#13;
var app = express(); &#13;
 &#13;
// view engine setup &#13;
app.set('views', path.join(__dirname, 'views')); &#13;
app.set('view engine', 'ejs'); &#13;
 &#13;
app.set('x-powered-by', false); &#13;
 &#13;
app.locals.appName = "My Gift App"; &#13;
 &#13;
// uncomment after placing your favicon in /public &#13;
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))); &#13;
app.use(logger('dev')); &#13;
app.use(bodyParser.json()); &#13;
app.use(bodyParser.urlencoded({ extended: false })); &#13;
app.use(cookieParser()); &#13;
app.use(express.static(path.join(__dirname, 'public'))); &#13;
 &#13;
//Database middlewear &#13;
app.use(function(req,res,next){ &#13;
    req.db = db; &#13;
    next(); &#13;
}); &#13;
 &#13;
<strong>app.use('/', routes);</strong>
<strong>app.use('/users', users);</strong> &#13;
 &#13;
// catch 404 and forward to error handler &#13;
app.use(function(req, res, next) { &#13;
  var err = new Error('Not Found'); &#13;
  err.status = 404; &#13;
  next(err); &#13;
}); &#13;
 &#13;
// error handlers &#13;
 &#13;
// development error handler &#13;
// will print stacktrace &#13;
if (app.get('env') === 'development') { &#13;
  app.use(function(err, req, res, next) { &#13;
    res.status(err.status || 500); &#13;
    res.render('error', { &#13;
      message: err.message, &#13;
      error: err &#13;
    }); &#13;
  }); &#13;
} &#13;
 &#13;
// production error handler &#13;
// no stacktraces leaked to user &#13;
app.use(function(err, req, res, next) { &#13;
  res.status(err.status || 500); &#13;
  res.render('error', { &#13;
    message: err.message, &#13;
    error: {} &#13;
  }); &#13;
}); &#13;
 &#13;
module.exports = app &#13;
</pre><p>We require the index route, assigning it to the variable routes, and then we require the users route, assigning it to the variable users. Then we add the routes to the <code class="literal">app</code> using the <code class="literal">app.use</code> function, matching the root path and the <code class="literal">/users</code> path.</p><p>Note that Express will try to match routes in order. Since every route will match the root path, it will look there first, and if it finds no match to anything starting with <code class="literal">/users</code>, Express will then match to the next route. Inside our <code class="literal">/users</code> route, we know we have a route for show, so <code class="literal">/users/show</code> will be matched there.</p><div><div><div><div><h3 class="title"><a id="ch09lvl3sec139"/>router.METHOD()</h3></div></div></div><p>This works the same exact way as <code class="literal">app.METHOD()</code>. We add lowercase HTTP verbs as functions, passing in a route to match and a callback function. We've seen this pattern already:</p><pre class="programlisting">router.get('/something', function(req, res, next) { &#13;
    res.send(""something loaded""); &#13;
}); &#13;
</pre><p>One thing to note here is that <code class="literal">res.send()</code>, <code class="literal">res.render()</code>, and <code class="literal">res.end()</code> will all terminate the response. This means that whatever is in <code class="literal">next()</code> will not be called. Think of it as returning out of a JavaScript function. There's no more you can do after that. However, you can call multiple routes in succession by not terminating:</p><pre class="programlisting">router.get('/something', function(req, res, next) { &#13;
    res.locals.foo = ""bar""; &#13;
    next() &#13;
}); &#13;
 &#13;
router.get('/something', function(req, res, next) { &#13;
    res.send(res.locals.foo); &#13;
    //send s 'bar' &#13;
}); &#13;
</pre><p>Both routes match <code class="literal">/something</code>, so the first one would get called, and it adds <code class="literal">foo</code> to the locals property on the response object. Then it makes a call to next which calls the next matching route, sending the value of <code class="literal">res.locals,foo</code>.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec140"/>router.all()</h3></div></div></div><p>
<code class="literal">router.all()</code> works like <code class="literal">router.METHOD()</code> except that it matches all HTTP verbs, get, post, and so on. It's incredibly useful for adding <code class="literal">global</code> functionality to a series of routes. For example, let's say that you have an <code class="literal">api</code> route and want to make sure that every call to any route in <code class="literal">api</code> is authenticated:</p><pre class="programlisting">router.all('/api/*', someAuthenticationMiddleware); &#13;
</pre><p>Placing this at the top of your routes file would make all calls to any URL starting with <code class="literal">/api/</code> to go through the <code class="literal">someAuthenticationMiddleware</code> middleware.</p></div><div><div><div><div><h3 class="title"><a id="ch09lvl3sec141"/>router.param()</h3></div></div></div><p>
<code class="literal">router.param()</code> is a powerful way to add callback functionality based on route parameters. Let's say, for example, that in our <code class="literal">users</code> route file, every time we get an <code class="literal">id</code> parameter.</p><p>Let's dive back into our <code class="literal">routes/users.js</code> file:</p><pre class="programlisting">var express = require('express'); &#13;
var router = express.Router(); &#13;
 &#13;
/* GET users listing. */ &#13;
router.get('/', function(req, res, next) { &#13;
  res.send('respond with a resource'); &#13;
}); &#13;
 &#13;
<strong>router.param('id', function(req, res, next, id)&#13;
 {&#13;
</strong>
<strong>    var db = req.db;&#13;
</strong>
<strong>    var collection = db.get('users');&#13;
</strong>
<strong>    collection.findOne({ ""_id"": id }, {}, function(err,User)&#13;
{&#13;
</strong>
<strong>        if(err)&#13;
{</strong>
<strong> &#13;
           res.send(err);&#13;
</strong>
<strong>        }else if(User){&#13;
</strong>
<strong>            req.user = User;&#13;
</strong>
<strong>            next();&#13;
</strong>
<strong>        }&#13;
 else&#13;
 {&#13;
</strong>
<strong>            res.send(new Error('User not found.')&#13;
);&#13;
</strong>
<strong>        }&#13;
</strong>
<strong>    });&#13;
</strong>
<strong>});&#13;
</strong>
<strong>router.get('/show/:id', function(req, res, next)&#13;
 {&#13;
</strong>
<strong>        if(req.xhr)&#13;
{&#13;
</strong>
<strong>            User.appName = req.app.locals.appName;&#13;
</strong>
<strong>            res.json(req.user);&#13;
</strong>
<strong>        }&#13;
 else&#13;
 {&#13;
</strong>
<strong>            res.render('users/user',&#13;
 {&#13;
</strong>
<strong>                user: req.user,&#13;
</strong>
<strong>                appName: req.app.locals.appName&#13;
</strong>
<strong>            });&#13;
</strong>
<strong>        }</strong>
<strong>});</strong> &#13;
 &#13;
router.get('/show', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.find({}, {}, function(err,docs){ &#13;
        if(!err){ &#13;
            //res.json(docs); &#13;
            res.render('users/show', { &#13;
                users: docs, &#13;
                appName: req.app.locals.appName &#13;
            }); &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
 &#13;
module.exports = router; &#13;
</pre><p>We use <code class="literal">router.param()</code> to look for calls to any route that has an <code class="literal">id</code> parameter. The callback function does a database lookup on user. If there's an error, we terminate by sending the error. The user, if one is found, is added to the request object. We then call <code class="literal">next()</code> to pass the request to the matching route.</p></div></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec117"/>Writing our own middleware</h2></div></div></div><p>As we've seen, Express is designed to rely heavily on pluggable middleware for adding functionality to our application. Let's roll our own piece of middleware that will give us an easy way to switch our responses to JSON format anywhere in our <code class="literal">app</code>.</p><p>Add a <code class="literal">utils</code> directory to your <code class="literal">giftapp</code> project folder and create a file called <code class="literal">json.js</code> inside that folder:</p><pre class="programlisting">var isJSON = function(req, res, next){ &#13;
    if(req.xhr || req.headers['accepts'] == 'application/json'){ &#13;
        req.isJSON = true; &#13;
    } &#13;
    next(); &#13;
} &#13;
 &#13;
module.exports = isJSON; &#13;
</pre><p>The <code class="literal">isJSON</code> function we create takes the three arguments that all Express middleware accepts - the request object, the response object, and the reference to next. We check to see if the request object's <code class="literal">xhr</code> value is <code class="literal">true</code> or if the accepts header on the request is <code class="literal">application/json</code>. If either condition is true, we can assume that the client is requesting <code class="literal">JSON</code> rather than <code class="literal">HTML</code>.</p><p>We add an <code class="literal">isJSON</code> property to the request object, setting it to <code class="literal">true</code>.</p><p>Now, let's modify our <code class="literal">app.js</code> file to include this middleware anywhere in the application where we need it:</p><pre class="programlisting">var express = require('express'); &#13;
var path = require('path'); &#13;
var favicon = require('serve-favicon'); &#13;
var logger = require('morgan'); &#13;
var cookieParser = require('cookie-parser'); &#13;
var bodyParser = require('body-parser'); &#13;
<strong>var isJSON = require('./utils/json');</strong> &#13;
 &#13;
//Database stuff &#13;
var mongodb = require('mongodb'); &#13;
var monk = require('monk'); &#13;
var db = monk('localhost:27017/giftapp') &#13;
 &#13;
var routes = require('./routes/index'); &#13;
var users = require('./routes/users'); &#13;
 &#13;
var app = express(); &#13;
 &#13;
// view engine setup &#13;
app.set('views', path.join(__dirname, 'views')); &#13;
app.set('view engine', 'ejs'); &#13;
 &#13;
app.set('x-powered-by', false); &#13;
 &#13;
app.locals.appName = ""My Gift App""; &#13;
 &#13;
// uncomment after placing your favicon in /public &#13;
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))); &#13;
app.use(logger('dev')); &#13;
app.use(bodyParser.json()); &#13;
app.use(bodyParser.urlencoded({ extended: false })); &#13;
app.use(cookieParser()); &#13;
app.use(express.static(path.join(__dirname, 'public'))); &#13;
<strong>app.use(isJSON);</strong> &#13;
 &#13;
//Database middlewear &#13;
app.use(function(req,res,next){ &#13;
    req.db = db; &#13;
    next(); &#13;
}); &#13;
 &#13;
app.use('/', routes); &#13;
app.use('/users', users); &#13;
 &#13;
// catch 404 and forward to error handler &#13;
app.use(function(req, res, next) { &#13;
  var err = new Error('Not Found'); &#13;
  err.status = 404; &#13;
  next(err); &#13;
}); &#13;
 &#13;
// error handlers &#13;
 &#13;
// development error handler &#13;
// will print stacktrace &#13;
if (app.get('env') === 'development') { &#13;
  app.use(function(err, req, res, next) { &#13;
    res.status(err.status || 500); &#13;
    res.render('error', { &#13;
      message: err.message, &#13;
      error: err &#13;
    }); &#13;
  }); &#13;
} &#13;
 &#13;
// production error handler &#13;
// no stacktraces leaked to user &#13;
app.use(function(err, req, res, next) { &#13;
  res.status(err.status || 500); &#13;
  res.render('error', { &#13;
    message: err.message, &#13;
    error: {} &#13;
  }); &#13;
}); &#13;
 &#13;
module.exports = app; &#13;
</pre><p>First, we require in our module, assigning it to the variable <code class="literal">isJSON</code>. Note that we need to use an explicit path here. If we simply used a module name, Node will try to look for it in the <code class="literal">node_modules</code> directory.</p><p>Then we add our middleware to the application using <code class="literal">app.use(isJSON)</code>. Where we place this in the file is important as middleware is called sequentially. In our case, this can be anywhere as long as it appears before the routes that use it:</p><pre class="programlisting">Next, we'll modify our routes/users.js file to use the middleware:var express = require('express'); &#13;
var router = express.Router(); &#13;
 &#13;
/* GET users listing. */ &#13;
router.get('/', function(req, res, next) { &#13;
  res.send('respond with a resource'); &#13;
}); &#13;
 &#13;
router.param('id', function(req, res, next, id) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.findOne({ ""_id"": id }, {}, function(err,User){ &#13;
        if(err){ &#13;
            res.send(err); &#13;
        }else if(User){ &#13;
            req.user = User; &#13;
            next(); &#13;
        } else { &#13;
            res.send(new Error('User not found.')); &#13;
        } &#13;
    }); &#13;
}); &#13;
 &#13;
router.get('/show/:id', function(req, res, next) { &#13;
<strong>        if(req.isJSON){</strong>
<strong>            User.appName = req.app.locals.appName;</strong>
<strong>            res.json(req.user);</strong>
<strong>        } else {</strong>
<strong>            res.render('users/user', {</strong>
<strong>                user: req.user,</strong>
<strong>                appName: req.app.locals.appName</strong>
<strong>            });</strong>
<strong>        }</strong> &#13;
}); &#13;
 &#13;
router.get('/show', function(req, res, next) { &#13;
    var db = req.db; &#13;
    var collection = db.get('users'); &#13;
    collection.find({}, {}, function(err,docs){ &#13;
        if(!err){ &#13;
<strong>            if(req.isJSON)&#13;
{&#13;
</strong>
<strong>                res.send(docs);&#13;
</strong>
<strong>            }&#13;
 else&#13;
 {&#13;
</strong>
<strong>                res.render('users/show',&#13;
 {&#13;
</strong>
<strong>                    users: docs,&#13;
</strong>
<strong>                    appName: req.app.locals.appName&#13;
</strong>
<strong>                });&#13;
</strong>
<strong>            }</strong> &#13;
        }else{ &#13;
            res.send('error'); &#13;
        } &#13;
    }); &#13;
}); &#13;
 &#13;
module.exports = router; &#13;
</pre><p>We modify our two routes to conditionally send JSON or HTML depending on our new <code class="literal">isJSON</code> flag. Restarting your server and then browsing to either route should show no difference, since you're not actually requesting JSON.</p><p>If you'd like to test this, you can use a browser plugin such as <code class="literal">Postman</code> or a terminal request such as <code class="literal">curl</code> to issue an <code class="literal">xhr</code> request and see the data come back as <code class="literal">JSON</code>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec55"/>Developing a RESTful API</h1></div></div></div><p>Let's do a little more work setting up our SPA by building out some resourceful routing as part of a RESTFul API that we can connect later to our database and our client-side code. We're lucky that Express has such a vibrant community of developers building many add-ons, and we're going to use one for resourceful routing.</p><div><div><div><div><h2 class="title"><a id="ch09lvl2sec118"/>Installing resourceful routing</h2></div></div></div><p>The first thing we need to do is to install our module, which will provide us with some resourceful routing:</p><pre class="programlisting">
<strong>npm install resource-routing -save</strong>
</pre><p>This installs the resourceful routing plugin we're going to use, and saves a reference to the <code class="literal">package.json</code> file.</p><p>Next, we need to do some setup in our <code class="literal">app.js</code> file:</p><pre class="programlisting">var express = require('express'); &#13;
var path = require('path'); &#13;
var favicon = require('serve-favicon'); &#13;
var logger = require('morgan'); &#13;
var cookieParser = require('cookie-parser'); &#13;
var bodyParser = require('body-parser'); &#13;
var isJSON = require('./utils/json'); &#13;
<strong>var routing = require('resource-routing');</strong>
<strong>var controllers = path.resolve('./controllers');</strong> &#13;
 &#13;
//Database stuff &#13;
var mongodb = require('mongodb'); &#13;
var monk = require('monk'); &#13;
var db = monk('localhost:27017/giftapp') &#13;
 &#13;
var routes = require('./routes/index'); &#13;
var users = require('./routes/users'); &#13;
 &#13;
var app = express(); &#13;
<strong>routing.expose_routing_table(app, { at: ""/my-routes"" });</strong> &#13;
 &#13;
// view engine setup &#13;
app.set('views', path.join(__dirname, 'views')); &#13;
app.set('view engine', 'ejs'); &#13;
 &#13;
app.set('x-powered-by', false); &#13;
 &#13;
app.locals.appName = ""My Gift App""; &#13;
 &#13;
// uncomment after placing your favicon in /public &#13;
//app.use(favicon(path.join(__dirname, 'public', 'favicon.ico'))); &#13;
app.use(logger('dev')); &#13;
app.use(bodyParser.json()); &#13;
app.use(bodyParser.urlencoded({ extended: false })); &#13;
app.use(cookieParser()); &#13;
app.use(express.static(path.join(__dirname, 'public'))); &#13;
app.use(isJSON); &#13;
 &#13;
//Database middlewear &#13;
app.use(function(req,res,next){ &#13;
    req.db = db; &#13;
    next(); &#13;
}); &#13;
 &#13;
app.use('/', routes); &#13;
app.use('/users', users); &#13;
 &#13;
<strong>routing.resources(app, controllers, ""giftlist"");</strong> &#13;
 &#13;
// catch 404 and forward to error handler &#13;
app.use(function(req, res, next) { &#13;
  var err = new Error('Not Found'); &#13;
  err.status = 404; &#13;
  next(err); &#13;
}); &#13;
 &#13;
// error handlers &#13;
 &#13;
// development error handler &#13;
// will print stacktrace &#13;
if (app.get('env') === 'development') { &#13;
  app.use(function(err, req, res, next) { &#13;
    res.status(err.status || 500); &#13;
    res.render('error', { &#13;
      message: err.message, &#13;
      error: err &#13;
    }); &#13;
  }); &#13;
} &#13;
 &#13;
// production error handler &#13;
// no stacktraces leaked to user &#13;
app.use(function(err, req, res, next) { &#13;
  res.status(err.status || 500); &#13;
  res.render('error', { &#13;
    message: err.message, &#13;
    error: {} &#13;
  }); &#13;
}); &#13;
 &#13;
module.exports = app; &#13;
</pre><p>We pull in the resource routing module using <code class="literal">require()</code> and assign it to the variable <code class="literal">routing</code>. Then we create a shortcut variable to a controllers directory, which we will be building next.</p><p>We add the following code, <code class="literal">routing.expose_routing_table(app,{at:""/my-routes""});</code> which allows us to view our routing table at the URL <code class="literal">my-routes</code>. Obviously, this is not something we'd leave intact in production, but it's a useful debugging tool.</p><p>Finally, we set up our resourceful routing for <code class="literal">giftlists</code> with <code class="literal">routing.resources(app,controllers,""giftlist"");</code>. This won't do anything yet because we haven't set up our controller.</p></div><div><div><div><div><h2 class="title"><a id="ch09lvl2sec119"/>Building out giftlist controller</h2></div></div></div><p>By default, our resourceful router will build a number of standard restful routes for us, including:</p><pre class="programlisting">GET    /giftlist             giftlist_controller.index &#13;
GET    /giftlist.format      giftlist_controller.index &#13;
GET    /giftlist/new         giftlist_controller.new &#13;
GET    /giftlist/new.format  giftlist_controller.new &#13;
POST   /giftlist             giftlist_controller.create &#13;
POST   /giftlist:format      giftlist_controller.create &#13;
GET    /giftlist/:id         giftlist_controller.show &#13;
GET    /giftlist/:id.format  giftlist_controller.show &#13;
GET    /giftlist/:id/edit    giftlist_controller.edit &#13;
GET    /giftlist/:id/edit.format  giftlist_controller.edit &#13;
PUT    /giftlist/:id         giftlist_controler.update &#13;
PUT    /giftlist/:id.format  giftlist_controller.update &#13;
DELETE    /giftlist/:id      giftlist_controller.destroy &#13;
DELETE    /giftlist/:id.format   giftlist_controller.destroy &#13;
</pre><p>As you can see, these routes provide use with basic CRUD (create, read, update, delete) functionality.</p><p>However, these routes will only be created if the controller and routes actually exist, so we need to build them. Create a controllers directory in your <code class="literal">giftapp</code> folder with a file called <code class="literal">giftlist_controller.js</code>. Our plugin will add the <code class="literal">_controller</code> part when it goes to load our controller, so be sure to name it correctly. For now, we are going to stub out our routes to make sure they are working:</p><pre class="programlisting">exports.index = function(req, res){ &#13;
    res.send('giftlist index'); &#13;
}; &#13;
 &#13;
exports.new = function(req, res){ &#13;
    res.send('new giftlist'); &#13;
}; &#13;
 &#13;
exports.create = function(req, res){ &#13;
    res.send('create giftlist'); &#13;
}; &#13;
 &#13;
exports.show = function(req, res){ &#13;
    res.send('show giftlist'+ req.params.id); &#13;
}; &#13;
 &#13;
exports.edit = function(req, res){ &#13;
    res.send('edit giftlist'); &#13;
}; &#13;
 &#13;
exports.update = function(req, res){ &#13;
    res.send('update giftlist'); &#13;
}; &#13;
 &#13;
exports.destroy = function(req, res){ &#13;
    res.send('destroy giftlist'); &#13;
}; &#13;
</pre><p>As you can see, each of our route handlers is a function that receives the request and response objects.</p><p>Restart your server and navigate to <code class="literal">localhost:3000/giftlist/17</code>, where you should see:</p><pre class="programlisting">show giftlist 17 &#13;
</pre><div><div><div><div><h3 class="title"><a id="ch09lvl3sec142"/>Responding with different data formats</h3></div></div></div><p>Our resourceful routes can also support different data formats, so let's stub those out as well, and we'll also use our <code class="literal">isJSON</code> property in our <code class="literal">giftlist_controller.js</code>:</p><pre class="programlisting">exports.index = function(req, res){ &#13;
    if(req.params.format == ""json"" || req.isJSON){ &#13;
        res.json({""title"":""giftlist index""}) &#13;
    }else{ &#13;
        res.send('&lt;h1&gt;giftlist index&lt;/h1&gt;'); &#13;
    } &#13;
 &#13;
}; &#13;
 &#13;
exports.new = function(req, res){ &#13;
    exports.index = function(req, res){ &#13;
        if(req.params.format == ""json"" || req.isJSON){ &#13;
            res.json({""title"":""new giftlist""}) &#13;
        }else{ &#13;
            res.send('&lt;h1&gt;new giftlist&lt;/h1&gt;'); &#13;
        } &#13;
 &#13;
    }; &#13;
 &#13;
}; &#13;
 &#13;
exports.create = function(req, res){ &#13;
    exports.index = function(req, res){ &#13;
        if(req.params.format == ""json"" || req.isJSON){ &#13;
            res.json({""title"":""create giftlist""}) &#13;
        }else{ &#13;
            res.send('&lt;h1&gt;create giftlist&lt;/h1&gt;'); &#13;
        } &#13;
 &#13;
    }; &#13;
 &#13;
}; &#13;
 &#13;
exports.show = function(req, res){ &#13;
    exports.index = function(req, res){ &#13;
        if(req.params.format == ""json"" || req.isJSON){ &#13;
            res.json({ ""title"":""show giftlist"", ""giftlist"":req.params.id }) &#13;
        }else{ &#13;
            res.send('&lt;h1&gt;show giftlist' + req.params.id + '&lt;/h1&gt;'); &#13;
        } &#13;
 &#13;
    }; &#13;
 &#13;
}; &#13;
 &#13;
exports.edit = function(req, res){ &#13;
    exports.index = function(req, res){ &#13;
        if(req.params.format == ""json"" || req.isJSON){ &#13;
            res.json({ ""title"":""edit giftlist"", ""giftlist"":req.params.id }) &#13;
        }else{ &#13;
            res.send('&lt;h1&gt;edit giftlist' + req.params.id + '&lt;/h1&gt;'); &#13;
        } &#13;
 &#13;
    }; &#13;
 &#13;
}; &#13;
 &#13;
exports.update = function(req, res){ &#13;
    exports.index = function(req, res){ &#13;
        if(req.params.format == ""json"" || req.isJSON){ &#13;
            res.json({ ""title"":""update giftlist"", ""giftlist"":req.params.id }) &#13;
        }else{ &#13;
            res.send('&lt;h1&gt;update giftlist' + req.params.id + '&lt;/h1&gt;'); &#13;
        } &#13;
 &#13;
    }; &#13;
 &#13;
}; &#13;
 &#13;
exports.destroy = function(req, res){ &#13;
    exports.index = function(req, res){ &#13;
        if(req.params.format == ""json"" || req.isJSON){ &#13;
            res.json({ ""title"":""delete giftlist"", ""giftlist"":req.params.id }) &#13;
        }else{ &#13;
            res.send('&lt;h1&gt;delete giftlist' + req.params.id + '&lt;/h1&gt;'); &#13;
        } &#13;
 &#13;
    }; &#13;
 &#13;
}; &#13;
</pre><p>Here, we added tests to each of our routes to see if the client is requesting <code class="literal">JSON</code> data. If they are, we return <code class="literal">JSON</code>. Otherwise, we return <code class="literal">HTML</code>.</p><p>We check to see if the client is expecting <code class="literal">JSON </code>in two ways.</p><p>First, we look to see if the <code class="literal">req.params.format</code> is <code class="literal">json</code>. Using this resourceful routing middleware, appending a .:format to the URL adds that format to the <code class="literal">req.params</code> object as the value of the format. In other words, entering the URL <code class="literal">localhost:3000/giftlist.json</code> triggers the <code class="literal">giftlist_controller.index</code> route, setting the format parameter to <code class="literal">json</code>.</p><p>The second method is to rely on the <code class="literal">req.isJSON</code> parameter set by our middleware.</p><p>In the next chapter, we will connect these resourceful routes to CRUD operations on our database, and start to render data to a page as we flesh out our SPA.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch09lvl1sec56"/>Summary</h1></div></div></div><p>In this chapter, we looked at Express, a Node.js web application framework, in greater detail. You learned that Express is an extremely flexible and unopinionated web framework built on top of Node.js HTTP services.</p><p>At its core, Express provides access to a request, response, application, and router objects. Using these objects, we can manipulate web requests and respond in a sophisticated manner.</p><p>Using Express predominantly means writing or using middleware plugins, through which requests flow. We learned to use these plugins, and we wrote some utility middleware of our own. We examined routing in detail, and used a resourceful routing plugin to start to build a RESTful API for our SPA. We made the API flexible, capable of responding with either <code class="literal">JSON</code> or <code class="literal">HTML</code> data depending on the request.</p><p>The next chapter will cover the frontend. Specifically, you will be learning about view templates, as well as AngularJS.</p></div></body></html>