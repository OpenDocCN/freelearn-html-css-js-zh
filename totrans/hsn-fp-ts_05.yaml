- en: The Runtime &#x2013; Closures and Prototypes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 运行时 —— 闭包和原型
- en: 'In the previous chapter, we learned about certain aspects of the TypeScript/JavaScript
    runtime that will help us to understand the implementation of some functional
    programming techniques in upcoming chapters. In this chapter, we are going to
    explore two more aspects of the TypeScript/JavaScript runtime:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们学习了 TypeScript/JavaScript 运行时的某些方面，这将帮助我们理解在后续章节中实现某些函数式编程技术的方法。在本章中，我们将探索
    TypeScript/JavaScript 运行的另外两个方面：
- en: Prototypes
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 原型
- en: Closures
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 闭包
- en: After exploring these two concepts, we will finally be ready to delve into the
    implementation and application of the main functional programming techniques.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 探索了这两个概念之后，我们最终将准备好深入探讨主要函数式编程技术的实现和应用。
- en: Prototypes
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型
- en: When we compile a TypeScript program, all classes and objects become JavaScript
    objects. Occasionally, however, we may encounter an unexpected behavior at runtime
    even if the compilation was completed without errors. To be able to identify and
    understand the cause of this behavior, we need a good understanding of the JavaScript
    runtime. One of the main concepts that we need to understand is how classes and
    inheritance work at runtime.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编译 TypeScript 程序时，所有类和对象都成为 JavaScript 对象。然而，即使编译没有错误，我们有时也可能在运行时遇到意外的行为。为了能够识别和理解这种行为的起因，我们需要对
    JavaScript 运行时有一个很好的理解。我们需要理解的主要概念之一是类和继承在运行时的如何工作。
- en: The runtime inheritance system uses a prototypal inheritance model. In a prototypal
    inheritance model, objects inherit from objects, and there are no classes available.
    However, we can use prototypes to simulate classes. Let's see how this works.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 运行时继承系统使用原型继承模型。在原型继承模型中，对象从对象继承，没有类可用。然而，我们可以使用原型来模拟类。让我们看看它是如何工作的。
- en: At runtime, objects have an internal property called `prototype`. The values
    of the `prototype` property is an object that contains some properties (data)
    and methods (behavior).
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，对象有一个内部属性称为 `prototype`。`prototype` 属性的值是一个包含一些属性（数据）和方法（行为）的对象。
- en: 'In TypeScript, we can use a class-based inheritance system:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 TypeScript 中，我们可以使用基于类的继承系统：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We have defined a class named `Person`. At runtime, this class is declared
    using prototypes instead of classes:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了一个名为 `Person` 的类。在运行时，这个类使用原型而不是类来声明：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code is emitted by TypeScript when we target ES5\. The `class`
    keyword is supported by ES6 at runtime, but it is only syntactic sugar.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码是 TypeScript 在针对 ES5 时输出的。`class` 关键字在 ES6 运行时得到支持，但它只是语法糖。
- en: Syntactic sugar is syntax within a programming language that is designed to
    make things easier to read or to express. This means that the class keyword is
    just a helper to make our lives as software engineers easier; internally, prototypes
    are always used.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 语法糖是编程语言内部的语法，旨在使事物更容易阅读或表达。这意味着 `class` 关键字只是一个帮助我们作为软件工程师更容易生活的辅助工具；内部，始终使用原型。
- en: The TypeScript compiler wraps the object definition (we will not refer to it
    as a class definition because technically, it is not a class) with an **immediately-invoked
    function expression** (**IIFE**). Inside the IIFE, we can find a function named
    `Person`. If we examine the function and compare it with the TypeScript class,
    we will notice that it takes the same parameters that the class constructor takes
    in the TypeScript class. This function is used to create new instances of the
    `Person` class.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 编译器使用一个立即执行的函数表达式（**IIFE**）包装对象定义（我们不会将其称为类定义，因为技术上它不是一个类）。在 IIFE
    内部，我们可以找到一个名为 `Person` 的函数。如果我们检查这个函数并与 TypeScript 类进行比较，我们会注意到它接受与 TypeScript
    类构造函数相同的参数。这个函数用于创建 `Person` 类的新实例。
- en: After the constructor, we can see the definition of the `greet` method. As we
    can see, the `prototype` property is used to attach the `greet` method to the
    `Person` class.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数之后，我们可以看到 `greet` 方法的定义。正如我们所见，`prototype` 属性被用来将 `greet` 方法附加到 `Person`
    类上。
- en: Instance properties versus class properties
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实例属性与类属性
- en: 'Because JavaScript is a dynamic programming language, we can add properties
    and methods to an instance of an object at runtime; and they don''t need to be
    part of the object (class) itself:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 JavaScript 是一种动态编程语言，我们可以在运行时向对象实例添加属性和方法；它们不需要是对象（类）本身的一部分：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We have defined a constructor function for an object named `Person`, which
    takes two variables (`name` and `surname`) as arguments. Then we have created
    an instance of the `Person` object and added a new property named `age` to it.
    We can use a `for…in` statement to check the properties of `person1` at runtime:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们为名为`Person`的对象定义了一个构造函数，它接受两个变量（`name`和`surname`）作为参数。然后我们创建了一个`Person`对象的实例，并给它添加了一个名为`age`的新属性。我们可以使用`for…in`语句在运行时检查`person1`的属性：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following will be displayed in the console output:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台输出将显示以下内容：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'As we can see, `age` has been added as a property. All these properties are
    instance properties because they hold a value for each new instance. If, for example,
    we create a new instance of `Person`, both instances will hold their own values:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`age`已被添加为一个属性。所有这些属性都是实例属性，因为它们为每个新实例持有值。例如，如果我们创建`Person`的新实例，这两个实例都将持有它们自己的值：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We have defined these instance properties using the `this` operator because,
    when a function is used as a constructor (with the `new` keyword), the `this`
    operator is bound to the object instance constructed. The preceding also explains
    why we can alternatively define instance properties through the object''s prototype:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`this`运算符定义了这些实例属性，因为当一个函数用作构造函数（使用`new`关键字）时，`this`运算符绑定到所构造的对象实例。前面的内容也解释了为什么我们可以通过对象的原型来定义实例属性：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We can also declare class properties and methods (also known as static properties).
    The main difference between instance properties and class properties is that the
    value of class properties and methods are shared between all instances of an object.
    Class properties are often used to store static values:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以声明类属性和方法（也称为静态属性）。实例属性和类属性之间的主要区别是，类属性和方法的价值在对象的所有实例之间共享。类属性通常用于存储静态值：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Class methods are also often used as utility functions that perform calculations
    on supplied parameters and return a result:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 类方法也常被用作执行参数计算并返回结果的实用函数：
- en: '[PRE8]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Please note that the preceding code snippet is valid in JavaScript, but will
    throw a compilation error in TypeScript.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码片段在JavaScript中是有效的，但在TypeScript中会抛出编译错误。
- en: 'In the preceding example, we accessed a class attribute (`PI`) from a class
    method (`areaOfCircle`). We can access class properties from instance methods,
    but we cannot access instance properties or methods from class properties or methods.
    We can demonstrate this by declaring `PI` as an instance property instead of a
    class property:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，我们从类方法（`areaOfCircle`）中访问了一个类属性（`PI`）。我们可以从实例方法中访问类属性，但不能从类属性或方法中访问实例属性或方法。我们可以通过将`PI`声明为实例属性而不是类属性来演示这一点：
- en: '[PRE9]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'If we then attempt to access `PI` from a class method, it will be undefined:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试从类方法中访问`PI`，它将是未定义的：
- en: '[PRE10]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'We are not supposed to access class methods or properties from instance methods,
    but there is a way to do it. We can do this by using the prototype''s `constructor`
    property, as demonstrated in the following example:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该从实例方法中访问类方法或属性，但有一种方法可以做到。我们可以通过使用原型的`constructor`属性来实现，如下面的示例所示：
- en: '[PRE11]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: We can access the `PI` class property from the `areaOfCircle` instance method
    using the prototype's `constructor` property because this property returns a reference
    to the object's constructor.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过原型对象的`constructor`属性从`areaOfCircle`实例方法访问`PI`类属性，因为这个属性返回一个指向对象构造函数的引用。
- en: 'Inside `areaOfCircle`, the `this` operator returns a reference to the object''s
    prototype:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在`areaOfCircle`内部，`this`运算符返回对对象原型的引用：
- en: '[PRE12]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: We may deduce that `this.constructor` is equal to `MathHelper.prototype.constructor`
    and, therefore, `MathHelper.prototype.constructor` is equal to `MathHelper`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以推断出`this.constructor`等于`MathHelper.prototype.constructor`，因此`MathHelper.prototype.constructor`等于`MathHelper`。
- en: 'In TypeScript, we can define class properties using the `static` keyword:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在TypeScript中，我们可以使用`static`关键字定义类属性：
- en: '[PRE13]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Prototypal inheritance
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型继承
- en: 'You might be wondering how the `extends` keyword works. Let''s create a new
    TypeScript class, which inherits from the `Person` class, to understand it:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道`extends`关键字是如何工作的。让我们创建一个新的TypeScript类，它从`Person`类继承，以理解它：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The preceding class is named `SuperHero` and extends the `Person` class. It
    has one additional attribute (`superpower`) and method (`useSuperPower`).
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类名为`SuperHero`，它扩展了`Person`类。它有一个额外的属性（`superpower`）和一个方法（`useSuperPower`）。
- en: 'We need to compile the previous code snippet into JavaScript code so we can
    examine how inheritance is implemented at runtime. The compiler will generate
    a polyfill function named `__extends` which is meant to be a replacement for the
    extends keyword compatible with the older versions of JavaScript:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要将之前的代码片段编译成JavaScript代码，以便我们可以检查继承在运行时是如何实现的。编译器将生成一个名为`__extends`的polyfill函数，该函数旨在作为与旧版JavaScript兼容的`extends`关键字的替代品：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Please note that the preceding code snippet is slightly more complicated in
    the latest version of TypeScript. We will use the code from previous versions
    here because it contains fewer conditions and is easier to understand.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，先前的代码片段在TypeScript的最新版本中稍微复杂一些。在这里我们将使用之前版本的代码，因为它包含的条件较少，更容易理解。
- en: This piece of code is generated by TypeScript. Even though it is a small piece
    of code, it showcases almost every concept contained in this chapter, and understanding
    it can be quite challenging.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是由TypeScript生成的。尽管它是一小段代码，但它展示了本章几乎包含的每一个概念，理解它可能相当具有挑战性。
- en: Before the function expression is evaluated for the first time, the `this` operator
    points to the global object, which does not contain a method named `__extends`.
    This means that the `__extends` variable is undefined.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在函数表达式第一次评估之前，`this`操作符指向全局对象，该对象不包含名为`__extends`的方法。这意味着`__extends`变量是未定义的。
- en: When the function expression is evaluated for the first time, the value of the
    function expression (an anonymous function) is assigned to the `__extends` property
    in the global scope.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当函数表达式第一次评估时，函数表达式的值（一个匿名函数）被分配给全局作用域中的`__extends`属性。
- en: 'TypeScript generates the function expression on one occasion for each TypeScript
    file containing the `extends` keyword. However, the function expression is only
    evaluated once (when the `__extends` variable is undefined). This behavior is
    implemented by the conditional statement in the first line:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript为包含`extends`关键字的每个TypeScript文件生成一个函数表达式。然而，函数表达式只被评估一次（当`__extends`变量未定义时）。这种行为是通过第一行的条件语句实现的：
- en: '[PRE16]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The first time the preceding line of code is executed, the function expression
    is evaluated. The value of the function expression is an anonymous function, which
    is assigned to the `__extends` variable in the global scope. Because we are in
    the global scope, `var __extends` and `this. __extends` refer to the same variable
    at this point.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行上一行代码时，函数表达式将被评估。函数表达式的值是一个匿名函数，它被分配给全局作用域中的`__extends`变量。因为我们在全局作用域中，`var
    __extends`和`this. __extends`在此点指向相同的变量。
- en: When a new file is executed, the `__extends` variable is already available in
    the global scope, and the function expression is not evaluated. This means that
    the value of the function expression is only assigned to the `__extends` variable
    once, even if the snippet is executed multiple times.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个新文件被执行时，`__extends`变量已经在全局作用域中可用，函数表达式不会被评估。这意味着函数表达式的值只被分配给`__extends`变量一次，即使代码片段被多次执行。
- en: 'Let''s focus now on the `__extends` variable (the anonymous function):'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来关注一下`__extends`变量（匿名函数）：
- en: '[PRE17]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function takes two arguments named `d` and `b`. When we invoke it, we should
    pass a derived object constructor (`d`) and a base object constructor (`b`).
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此函数接受两个名为`d`和`b`的参数。当我们调用它时，我们应该传递一个派生对象构造函数（`d`）和一个基对象构造函数（`b`）。
- en: 'The first line inside the anonymous function iterates each class property and
    method from the base class and creates their copy in the derived class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 匿名函数内的第一行代码迭代基类中的每个类属性和方法，并在派生类中创建它们的副本：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: When we use a `for…in` statement to iterate an instance of an object to `a`,
    it will iterate the object's instance properties. However, if we use a `for…in`
    statement to iterate the properties of an object's constructor, the statement
    will iterate its class properties. In the preceding example, the `for…in` statement
    is used to inherit the object's class properties and methods. To inherit the instance
    properties, we will copy the object's prototype.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用`for…in`语句迭代对象的实例到`a`时，它将迭代对象的实例属性。然而，如果我们使用`for…in`语句迭代对象构造函数的属性，该语句将迭代其类属性。在先前的例子中，`for…in`语句用于继承对象的类属性和方法。要继承实例属性，我们将复制对象的原型。
- en: The second line declares a new constructor function named `__` and, inside it,
    the `this` operator is used to access its prototype.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 第二行声明了一个新的构造函数 `__`，在其中，使用 `this` 操作符来访问其原型。
- en: '[PRE19]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The prototype contains a special property named `constructor`, which returns
    a reference to the object's constructor. The function named `__` and `this.constructor`
    are pointing to the same variable at this point. The value of the derived object
    constructor (`d`) is then assigned to the `__` constructor.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 原型包含一个名为 `constructor` 的特殊属性，它返回对对象构造函数的引用。在这个点上，名为 `__` 和 `this.constructor`
    的函数指向相同的变量。然后，派生对象构造函数（`d`）的值被分配给 `__` 构造函数。
- en: 'In the third line, the value of the prototype object from the base object constructor
    is assigned to the prototype of the `__` object constructor:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三行，将基对象构造函数的原型对象的值分配给 `__` 对象构造函数的原型：
- en: '[PRE20]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the last line, the `__` function is invoked as a constructor with the `new` keyword,
    and the result is assigned to the derived class (`d`) prototype. By performing
    all these steps, we have achieved what we need to in order to invoke the following:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在最后一行，`__` 函数作为构造函数使用 `new` 关键字调用，其结果被分配给派生类（`d`）的原型。通过执行所有这些步骤，我们已经完成了调用以下内容所需的所有操作：
- en: '[PRE21]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Upon doing so, we will get an object that contains all the properties from both
    the derived class (`d`) and the base class (`b`). Furthermore, any instance objects
    constructed by the derived constructor (`d`) will be instances of the derived
    class, while inheriting the class and instance properties and methods from the
    base class (`b`).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这样做之后，我们将得到一个包含派生类（`d`）和基类（`b`）所有属性的对象。此外，由派生构造函数（`d`）构建的任何实例对象都将成为派生类的实例，同时继承自基类（`b`）的类和实例属性和方法。
- en: 'We can see the function in action by examining the runtime code that defines
    the `SuperHero` class:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过检查定义 `SuperHero` 类的运行时代码来看到函数的作用：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: We can see an IIFE here again. This time, the IIFE takes the `Person` object
    constructor as the argument. Inside the function, we will refer to this argument
    using the name `_super`. Inside the IIFE, the `__extends` function is invoked
    and the `SuperHero` (derived class) and `_super` (base class) arguments are passed
    to it.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里再次看到了一个立即执行函数表达式（IIFE）。这次，IIFE 将 `Person` 对象构造函数作为参数。在函数内部，我们将使用名称 `_super`
    来引用这个参数。在 IIFE 内部，调用 `__extends` 函数，并将 `SuperHero`（派生类）和 `_super`（基类）参数传递给它。
- en: In the next line, we can find the declaration of the `SuperHero` object constructor
    and the `useSuperPower` function. We can use `SuperHero` as an argument of `__extend`
    before it is declared because function declarations are hoisted to the top of
    the scope.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一行中，我们可以找到 `SuperHero` 对象构造函数和 `useSuperPower` 函数的声明。在声明之前，我们可以将 `SuperHero`
    作为 `__extend` 的参数使用，因为函数声明会被提升到作用域的顶部。
- en: Function expressions are not hoisted. When we assign a function to a variable
    in a function expression, the variable is hoisted, but its value (the function
    itself) is not hoisted.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 函数表达式不会被提升。当我们在一个函数表达式中将函数赋值给变量时，变量会被提升，但它的值（函数本身）不会被提升。
- en: 'Inside the `SuperHero` constructor, the base class (`Person`) constructor is
    invoked using the `call` method:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `SuperHero` 构造函数内部，使用 `call` 方法调用了基类（`Person`）的构造函数：
- en: '[PRE23]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As we discovered in the previous chapter, we can use `call` to set the value
    of the `this` operator in a function context. In this case, we are passing the
    `this` operator, which points to the instance of `SuperHero` being created:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在上一章中发现的，我们可以使用 `call` 方法在函数上下文中设置 `this` 操作符的值。在这种情况下，我们传递了 `this` 操作符，它指向正在创建的
    `SuperHero` 实例：
- en: '[PRE24]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Prototype chains and property shadowing
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 原型链和属性遮蔽
- en: When we try to access a property or a method of an object, the runtime will
    search for that property or method in the object's own properties and methods.
    If it is not found, the runtime will continue searching through the object's inherited
    properties by navigating the entire inheritance tree. Because a derived object
    is linked to its base object through the `prototype` property, we refer to this
    inheritance tree as the **prototype chain**.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们尝试访问一个对象的属性或方法时，运行时会搜索该属性或方法在对象自己的属性和方法中。如果找不到，运行时会继续通过遍历整个继承树来搜索对象的继承属性。因为派生对象通过
    `prototype` 属性与基对象链接，所以我们称这个继承树为 **原型链**。
- en: 'Let''s look at an example. We will declare two simple TypeScript classes, named
    `Base` and `Derived`:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一个例子。我们将声明两个简单的 TypeScript 类，分别命名为 `Base` 和 `Derived`：
- en: '[PRE25]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now we will examine the JavaScript code generated by TypeScript:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将检查TypeScript生成的JavaScript代码：
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can then create an instance of the `Derived` class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以创建`Derived`类的实例：
- en: '[PRE27]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `new` operator creates an object instance that inherits from the `Base` class.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`new`运算符创建了一个从`Base`类继承的对象实例。'
- en: 'If we try to access the method named `method1`, the runtime will find it in
    the instance''s properties:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试访问名为`method1`的方法，运行时会从实例属性中找到它：
- en: '[PRE28]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The instance also has its own property named `method2` (with a value of `2`),
    but there is also an inherited property named `method2` (with a value of `3`).
    The object''s property (`method2` with a value of `3`) prevents access to the
    prototype property (`method2` with a value of `2`). This is known as **property
    shadowing**:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 实例还有一个名为`method2`的属性（值为`2`），但还有一个继承的属性名为`method2`（值为`3`）。对象的属性（值为`3`的`method2`）阻止了对原型属性（值为`2`的`method2`）的访问。这被称为**属性遮蔽**：
- en: '[PRE29]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The instance does not have its own property named `method3`, but it does have
    a property named `method3` in its prototype chain:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 实例没有自己的名为`method3`的属性，但在其原型链中有一个名为`method3`的属性：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Neither the instance nor the objects in the prototype chain (the `Base` class)
    have a property named `method4`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 实例以及原型链中的对象（`Base`类）都没有名为`method4`的属性：
- en: '[PRE31]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Accessing the prototype of an object
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 访问对象的原型
- en: 'Prototypes can be accessed in three different ways:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 原型可以通过三种不同的方式访问：
- en: '`Person.prototype`'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Person.prototype`'
- en: '`Object.getPrototypeOf(person)`'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Object.getPrototypeOf(person)`'
- en: '`person.__proto__`'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`person.__proto__`'
- en: The use of `__proto__` is controversial and has been discouraged by many experienced
    software engineers. It was never originally included in the ECMAScript language
    specification, but modern browsers decided to implement it in any case. Today,
    the `__proto__` property has been standardized in the ECMAScript 6 language specification
    and will be supported in future, but it is still a slow operation that should
    be avoided if performance is a concern.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`__proto__`是有争议的，并且被许多经验丰富的软件工程师所不推荐。它从未最初包含在ECMAScript语言规范中，但现代浏览器还是决定无论如何实现它。如今，`__proto__`属性已经被标准化在ECMAScript
    6语言规范中，并将在未来得到支持，但它仍然是一个应该避免的慢操作，如果性能是一个考虑因素的话。
- en: Closures
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 闭包
- en: 'Closures are one of the most powerful features in JavaScript and TypeScript,
    but they are also one of the most misunderstood. The *Mozilla developer network*
    defines closures as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是JavaScript和TypeScript中最强大的特性之一，但它们也是最容易误解的特性之一。*Mozilla开发者网络*将闭包定义为如下：
- en: Closures are functions that refer to independent (free) variables. In other
    words, the function defined in the closure 'remembers' the environment in which
    it was created.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 闭包是引用独立（自由）变量的函数。换句话说，闭包中定义的函数“记住”了它被创建的环境。
- en: 'We understand independent (free) variables as variables that persist beyond
    the lexical scope from which they were created. Let''s look at an example:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将独立（自由）变量理解为在它们被创建的词法作用域之外持续存在的变量。让我们看一个例子：
- en: '[PRE32]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Please note that the preceding example is meant to be a JavaScript example.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的例子是一个JavaScript示例。
- en: 'We have declared a function named `makeArmy`. Inside the function, we have
    created an array of functions named `shooters`. Each function in the `shooters`
    array will display a number, the value of which was set from the variable `i`
    inside a `for` statement. We will now invoke the `makeArmy` function:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了一个名为`makeArmy`的函数。在函数内部，我们创建了一个名为`shooters`的函数数组。`shooters`数组中的每个函数都将显示一个数字，其值是从`for`语句内部的变量`i`设置的。现在我们将调用`makeArmy`函数：
- en: '[PRE33]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The `army` variable should now contain the array of the function''s `shooters`.
    However, we will notice a problem if we execute the following piece of code:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`army`变量现在应该包含函数的`shooters`数组。然而，如果我们执行以下代码，我们会注意到一个问题：'
- en: '[PRE34]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The preceding code snippet does not work as expected because we made one of
    the most common mistakes related to closures. When we declared the `shooter` function
    inside the `makeArmy` function, we created a closure without being aware of it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段没有按预期工作，因为我们犯了与闭包相关的一个最常见的错误。当我们把`shooter`函数声明在`makeArmy`函数内部时，我们无意中创建了一个闭包。
- en: This is because the functions assigned to `shooter` are closures. A closure
    has access to variables in the environment that encloses them (the `makeArmy`
    function's scope). Ten closure functions have been created, but each one shares
    the same single environment. By the time the `shooter` functions are executed,
    the loop has run its course and the `i` variable (shared by all the closure functions)
    has been left pointing to the last entry (`10`).
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为分配给 `shooter` 的函数是闭包。闭包可以访问包围它们的（`makeArmy` 函数的作用域）环境中的变量。已经创建了十个闭包函数，但每个函数都共享同一个单一的环境。当
    `shooter` 函数执行时，循环已经完成，共享的 `i` 变量（所有闭包函数共享）已经指向最后一个条目（`10`）。
- en: 'One solution, in this case, is to use more closures:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个情况下，一个解决方案是使用更多的闭包：
- en: '[PRE35]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Please note that the preceding example is meant to be a TypeScript example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例是一个 TypeScript 示例。
- en: This works as expected. Rather than the `shooter` functions sharing a single
    environment, the immediately-invoked function creates a new environment for each
    one in which `i` refers to the corresponding value.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这正如预期的那样工作。不是 `shooter` 函数共享一个单一的环境，立即调用的函数为每个函数创建了一个新的环境，其中 `i` 指向相应的值。
- en: Static variables powered by closures
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由闭包驱动的静态变量
- en: 'In the previous section, we learned that, when a variable in a closure context
    can be shared between multiple instances of a class, this means that the variable
    behaves like a static variable. We will now see how we can create variables and
    methods that behave like a static variable using closures. Let''s start by declaring
    a TypeScript class named `Counter`:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到，当闭包上下文中的变量可以在类的多个实例之间共享时，这意味着该变量表现得像静态变量。现在我们将看到如何使用闭包创建表现得像静态变量的变量和方法。让我们首先声明一个名为
    `Counter` 的 TypeScript 类：
- en: '[PRE36]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Please note that the preceding example is meant to be a TypeScript example.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例是一个 TypeScript 示例。
- en: 'The preceding class contains a static member named `_COUNTER`. The TypeScript
    compiler transforms it into the following code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的类包含一个名为 `_COUNTER` 的静态成员。TypeScript 编译器将其转换为以下代码：
- en: '[PRE37]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Please note that the preceding code snippet is the compilation output generated
    by the TypeScript compiler.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的代码片段是 TypeScript 编译器生成的编译输出。
- en: As we can observe, the static variable is declared by the TypeScript compiler
    as a class property (as opposed to an instance property). The compiler uses a
    class property because class properties are shared across all instances of a class.
    The problem is that the private variable is not private at runtime.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所观察到的，TypeScript 编译器将静态变量声明为类属性（而不是实例属性）。编译器使用类属性，因为类属性在类的所有实例之间共享。问题是私有变量在运行时并不是私有的。
- en: 'Alternatively, we could write some JavaScript (remember that all valid JavaScript
    is valid TypeScript) code to emulate static properties using closures:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以编写一些 JavaScript（记住，所有有效的 JavaScript 都是有效的 TypeScript）代码来使用闭包模拟静态属性：
- en: '[PRE38]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Please note that the preceding example is meant to be a TypeScript example.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的示例是一个 TypeScript 示例。
- en: The preceding code snippet declares a class named `Counter`. The class has some
    methods used to increment, decrement, and read the variable named `_COUNTER`.
    The `_COUNTER` variable itself is not part of the object prototype.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段声明了一个名为 `Counter` 的类。该类有一些用于增加、减少和读取名为 `_COUNTER` 的变量的方法。`_COUNTER` 变量本身不是对象原型的部分。
- en: All the instances of the `Counter` class will share the same context, which
    means that the context (the `_COUNTER` variable and the `changeBy` function) will
    behave as a singleton.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的 `Counter` 类实例将共享同一个上下文，这意味着上下文（`_COUNTER` 变量和 `changeBy` 函数）将表现得像一个单例。
- en: The singleton pattern requires an object to be declared as a static variable
    to avoid the need to create its instance whenever it is required. The object instance
    is, therefore, shared by all the components in the application. The singleton
    pattern is frequently used in scenarios where it is not beneficial, thereby introducing
    unnecessary restrictions in situations where a unique instance of a class is not
    required, and introduces global state into an application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式需要一个对象被声明为静态变量以避免在需要时创建其实例。因此，对象实例由应用程序中的所有组件共享。单例模式在不需要类唯一实例的情况下经常被使用，从而在不必要的情况下引入了不必要的限制，并将全局状态引入了应用程序。
- en: 'So now we know that it is possible to use closures to emulate static variables:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道可以使用闭包来模拟静态变量：
- en: '[PRE39]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: As we can see, the preceding example doesn't work as expected because both instances
    of `Counter` share the internal counter. We will learn how to fix this problem
    in the following section.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，前面的例子并没有按预期工作，因为 `Counter` 的两个实例共享内部计数器。我们将在下一节中学习如何解决这个问题。
- en: Private members powered by closures
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 由闭包支持的私有成员
- en: In the previous section, we learned that closures can access variables that
    persist beyond the lexical scope from which they were created. These variables
    are not part of the function's prototype or body, but they are part of the function's
    context.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到闭包可以访问超出它们创建的词法作用域的持久变量。这些变量不是函数的原型或主体的部分，但它们是函数上下文的一部分。
- en: Because there is no way we can directly invoke the function's context, context
    variables and methods can be used to emulate private members. The main advantage
    of using closures to emulate private members (instead of the TypeScript private
    access modifier) is that closures will prevent access to private members at runtime.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法直接调用函数的上下文，上下文变量和方法可以用来模拟私有成员。使用闭包来模拟私有成员（而不是 TypeScript 的私有访问修饰符）的主要优势是，闭包将在运行时防止对私有成员的访问。
- en: TypeScript avoids emulating private properties at runtime because the compiler
    will throw an error at compilation time if we attempt to access a private member.
    TypeScript avoids using closures to emulate private members so as to improve application
    performance. If we add or remove an access modifier to or from one of our classes,
    the resulting JavaScript code will not change at all. This means that private
    members of a class become public members at runtime.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: TypeScript 避免在运行时模拟私有属性，因为如果我们尝试访问私有成员，编译器将在编译时抛出错误。TypeScript 避免使用闭包来模拟私有成员，以便提高应用程序性能。如果我们向我们的类之一添加或移除访问修饰符，生成的
    JavaScript 代码将完全不会改变。这意味着类的私有成员在运行时变成了公共成员。
- en: 'However, it is possible to use closures to emulate private properties at runtime.
    Let''s look at an example:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，使用闭包在运行时模拟私有属性是可能的。让我们看看一个例子：
- en: '[PRE40]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Please note that the preceding example is meant to be a TypeScript example.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，前面的例子是一个 TypeScript 示例。
- en: The preceding class is almost identical to the class that we previously declared
    in order to demonstrate how to emulate static variables at runtime using closures.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类几乎与我们之前声明的类相同，目的是为了演示如何使用闭包在运行时模拟静态变量。
- en: 'This time, a new closure context is created every time we invoke the `makeCounter`
    function, so each new instance of `Counter` will remember an independent context
    (`_COUNTER` and `changeBy`):'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，每次我们调用 `makeCounter` 函数时，都会创建一个新的闭包上下文，因此每个新的 `Counter` 实例都会记住一个独立的环境（`_COUNTER`
    和 `changeBy`）：
- en: '[PRE41]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Since the context cannot be accessed directly, we can say that the `_COUNTER`
    variable and the `changeBy` function are private members even at runtime:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于上下文无法直接访问，我们可以这样说，`_COUNTER` 变量和 `changeBy` 函数即使在运行时也是私有成员：
- en: '[PRE42]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Summary
  id: totrans-150
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have acquired a better understanding of the runtime, which
    allows us to not only resolve runtime issues easily, but also to write better
    TypeScript code. An in-depth understanding of closures and prototypes will allow
    us to understand the implementation of some functional programming techniques
    in upcoming chapters.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们更好地理解了运行时，这使我们不仅能够轻松解决运行时问题，而且还能编写更好的 TypeScript 代码。对闭包和原型的深入理解将使我们能够理解在后续章节中某些函数式编程技术的实现。
- en: In the next chapter, we will learn how to implement a number of fundamental
    functional programming techniques.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将学习如何实现许多基本的函数式编程技术。
