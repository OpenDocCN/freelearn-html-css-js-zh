- en: The Runtime &#x2013; Closures and Prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned about certain aspects of the TypeScript/JavaScript
    runtime that will help us to understand the implementation of some functional
    programming techniques in upcoming chapters. In this chapter, we are going to
    explore two more aspects of the TypeScript/JavaScript runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After exploring these two concepts, we will finally be ready to delve into the
    implementation and application of the main functional programming techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we compile a TypeScript program, all classes and objects become JavaScript
    objects. Occasionally, however, we may encounter an unexpected behavior at runtime
    even if the compilation was completed without errors. To be able to identify and
    understand the cause of this behavior, we need a good understanding of the JavaScript
    runtime. One of the main concepts that we need to understand is how classes and
    inheritance work at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: The runtime inheritance system uses a prototypal inheritance model. In a prototypal
    inheritance model, objects inherit from objects, and there are no classes available.
    However, we can use prototypes to simulate classes. Let's see how this works.
  prefs: []
  type: TYPE_NORMAL
- en: At runtime, objects have an internal property called `prototype`. The values
    of the `prototype` property is an object that contains some properties (data)
    and methods (behavior).
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, we can use a class-based inheritance system:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined a class named `Person`. At runtime, this class is declared
    using prototypes instead of classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code is emitted by TypeScript when we target ES5\. The `class`
    keyword is supported by ES6 at runtime, but it is only syntactic sugar.
  prefs: []
  type: TYPE_NORMAL
- en: Syntactic sugar is syntax within a programming language that is designed to
    make things easier to read or to express. This means that the class keyword is
    just a helper to make our lives as software engineers easier; internally, prototypes
    are always used.
  prefs: []
  type: TYPE_NORMAL
- en: The TypeScript compiler wraps the object definition (we will not refer to it
    as a class definition because technically, it is not a class) with an **immediately-invoked
    function expression** (**IIFE**). Inside the IIFE, we can find a function named
    `Person`. If we examine the function and compare it with the TypeScript class,
    we will notice that it takes the same parameters that the class constructor takes
    in the TypeScript class. This function is used to create new instances of the
    `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: After the constructor, we can see the definition of the `greet` method. As we
    can see, the `prototype` property is used to attach the `greet` method to the
    `Person` class.
  prefs: []
  type: TYPE_NORMAL
- en: Instance properties versus class properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Because JavaScript is a dynamic programming language, we can add properties
    and methods to an instance of an object at runtime; and they don''t need to be
    part of the object (class) itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined a constructor function for an object named `Person`, which
    takes two variables (`name` and `surname`) as arguments. Then we have created
    an instance of the `Person` object and added a new property named `age` to it.
    We can use a `for…in` statement to check the properties of `person1` at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The following will be displayed in the console output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, `age` has been added as a property. All these properties are
    instance properties because they hold a value for each new instance. If, for example,
    we create a new instance of `Person`, both instances will hold their own values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We have defined these instance properties using the `this` operator because,
    when a function is used as a constructor (with the `new` keyword), the `this`
    operator is bound to the object instance constructed. The preceding also explains
    why we can alternatively define instance properties through the object''s prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also declare class properties and methods (also known as static properties).
    The main difference between instance properties and class properties is that the
    value of class properties and methods are shared between all instances of an object.
    Class properties are often used to store static values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Class methods are also often used as utility functions that perform calculations
    on supplied parameters and return a result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding code snippet is valid in JavaScript, but will
    throw a compilation error in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding example, we accessed a class attribute (`PI`) from a class
    method (`areaOfCircle`). We can access class properties from instance methods,
    but we cannot access instance properties or methods from class properties or methods.
    We can demonstrate this by declaring `PI` as an instance property instead of a
    class property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then attempt to access `PI` from a class method, it will be undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'We are not supposed to access class methods or properties from instance methods,
    but there is a way to do it. We can do this by using the prototype''s `constructor`
    property, as demonstrated in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We can access the `PI` class property from the `areaOfCircle` instance method
    using the prototype's `constructor` property because this property returns a reference
    to the object's constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside `areaOfCircle`, the `this` operator returns a reference to the object''s
    prototype:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We may deduce that `this.constructor` is equal to `MathHelper.prototype.constructor`
    and, therefore, `MathHelper.prototype.constructor` is equal to `MathHelper`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, we can define class properties using the `static` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Prototypal inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You might be wondering how the `extends` keyword works. Let''s create a new
    TypeScript class, which inherits from the `Person` class, to understand it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The preceding class is named `SuperHero` and extends the `Person` class. It
    has one additional attribute (`superpower`) and method (`useSuperPower`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to compile the previous code snippet into JavaScript code so we can
    examine how inheritance is implemented at runtime. The compiler will generate
    a polyfill function named `__extends` which is meant to be a replacement for the
    extends keyword compatible with the older versions of JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding code snippet is slightly more complicated in
    the latest version of TypeScript. We will use the code from previous versions
    here because it contains fewer conditions and is easier to understand.
  prefs: []
  type: TYPE_NORMAL
- en: This piece of code is generated by TypeScript. Even though it is a small piece
    of code, it showcases almost every concept contained in this chapter, and understanding
    it can be quite challenging.
  prefs: []
  type: TYPE_NORMAL
- en: Before the function expression is evaluated for the first time, the `this` operator
    points to the global object, which does not contain a method named `__extends`.
    This means that the `__extends` variable is undefined.
  prefs: []
  type: TYPE_NORMAL
- en: When the function expression is evaluated for the first time, the value of the
    function expression (an anonymous function) is assigned to the `__extends` property
    in the global scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript generates the function expression on one occasion for each TypeScript
    file containing the `extends` keyword. However, the function expression is only
    evaluated once (when the `__extends` variable is undefined). This behavior is
    implemented by the conditional statement in the first line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The first time the preceding line of code is executed, the function expression
    is evaluated. The value of the function expression is an anonymous function, which
    is assigned to the `__extends` variable in the global scope. Because we are in
    the global scope, `var __extends` and `this. __extends` refer to the same variable
    at this point.
  prefs: []
  type: TYPE_NORMAL
- en: When a new file is executed, the `__extends` variable is already available in
    the global scope, and the function expression is not evaluated. This means that
    the value of the function expression is only assigned to the `__extends` variable
    once, even if the snippet is executed multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s focus now on the `__extends` variable (the anonymous function):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This function takes two arguments named `d` and `b`. When we invoke it, we should
    pass a derived object constructor (`d`) and a base object constructor (`b`).
  prefs: []
  type: TYPE_NORMAL
- en: 'The first line inside the anonymous function iterates each class property and
    method from the base class and creates their copy in the derived class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: When we use a `for…in` statement to iterate an instance of an object to `a`,
    it will iterate the object's instance properties. However, if we use a `for…in`
    statement to iterate the properties of an object's constructor, the statement
    will iterate its class properties. In the preceding example, the `for…in` statement
    is used to inherit the object's class properties and methods. To inherit the instance
    properties, we will copy the object's prototype.
  prefs: []
  type: TYPE_NORMAL
- en: The second line declares a new constructor function named `__` and, inside it,
    the `this` operator is used to access its prototype.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The prototype contains a special property named `constructor`, which returns
    a reference to the object's constructor. The function named `__` and `this.constructor`
    are pointing to the same variable at this point. The value of the derived object
    constructor (`d`) is then assigned to the `__` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the third line, the value of the prototype object from the base object constructor
    is assigned to the prototype of the `__` object constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'In the last line, the `__` function is invoked as a constructor with the `new` keyword,
    and the result is assigned to the derived class (`d`) prototype. By performing
    all these steps, we have achieved what we need to in order to invoke the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Upon doing so, we will get an object that contains all the properties from both
    the derived class (`d`) and the base class (`b`). Furthermore, any instance objects
    constructed by the derived constructor (`d`) will be instances of the derived
    class, while inheriting the class and instance properties and methods from the
    base class (`b`).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can see the function in action by examining the runtime code that defines
    the `SuperHero` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We can see an IIFE here again. This time, the IIFE takes the `Person` object
    constructor as the argument. Inside the function, we will refer to this argument
    using the name `_super`. Inside the IIFE, the `__extends` function is invoked
    and the `SuperHero` (derived class) and `_super` (base class) arguments are passed
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: In the next line, we can find the declaration of the `SuperHero` object constructor
    and the `useSuperPower` function. We can use `SuperHero` as an argument of `__extend`
    before it is declared because function declarations are hoisted to the top of
    the scope.
  prefs: []
  type: TYPE_NORMAL
- en: Function expressions are not hoisted. When we assign a function to a variable
    in a function expression, the variable is hoisted, but its value (the function
    itself) is not hoisted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the `SuperHero` constructor, the base class (`Person`) constructor is
    invoked using the `call` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As we discovered in the previous chapter, we can use `call` to set the value
    of the `this` operator in a function context. In this case, we are passing the
    `this` operator, which points to the instance of `SuperHero` being created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Prototype chains and property shadowing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we try to access a property or a method of an object, the runtime will
    search for that property or method in the object's own properties and methods.
    If it is not found, the runtime will continue searching through the object's inherited
    properties by navigating the entire inheritance tree. Because a derived object
    is linked to its base object through the `prototype` property, we refer to this
    inheritance tree as the **prototype chain**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at an example. We will declare two simple TypeScript classes, named
    `Base` and `Derived`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we will examine the JavaScript code generated by TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then create an instance of the `Derived` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `new` operator creates an object instance that inherits from the `Base` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we try to access the method named `method1`, the runtime will find it in
    the instance''s properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance also has its own property named `method2` (with a value of `2`),
    but there is also an inherited property named `method2` (with a value of `3`).
    The object''s property (`method2` with a value of `3`) prevents access to the
    prototype property (`method2` with a value of `2`). This is known as **property
    shadowing**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The instance does not have its own property named `method3`, but it does have
    a property named `method3` in its prototype chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Neither the instance nor the objects in the prototype chain (the `Base` class)
    have a property named `method4`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Accessing the prototype of an object
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prototypes can be accessed in three different ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Person.prototype`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Object.getPrototypeOf(person)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`person.__proto__`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of `__proto__` is controversial and has been discouraged by many experienced
    software engineers. It was never originally included in the ECMAScript language
    specification, but modern browsers decided to implement it in any case. Today,
    the `__proto__` property has been standardized in the ECMAScript 6 language specification
    and will be supported in future, but it is still a slow operation that should
    be avoided if performance is a concern.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Closures are one of the most powerful features in JavaScript and TypeScript,
    but they are also one of the most misunderstood. The *Mozilla developer network*
    defines closures as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Closures are functions that refer to independent (free) variables. In other
    words, the function defined in the closure 'remembers' the environment in which
    it was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'We understand independent (free) variables as variables that persist beyond
    the lexical scope from which they were created. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding example is meant to be a JavaScript example.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have declared a function named `makeArmy`. Inside the function, we have
    created an array of functions named `shooters`. Each function in the `shooters`
    array will display a number, the value of which was set from the variable `i`
    inside a `for` statement. We will now invoke the `makeArmy` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `army` variable should now contain the array of the function''s `shooters`.
    However, we will notice a problem if we execute the following piece of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet does not work as expected because we made one of
    the most common mistakes related to closures. When we declared the `shooter` function
    inside the `makeArmy` function, we created a closure without being aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: This is because the functions assigned to `shooter` are closures. A closure
    has access to variables in the environment that encloses them (the `makeArmy`
    function's scope). Ten closure functions have been created, but each one shares
    the same single environment. By the time the `shooter` functions are executed,
    the loop has run its course and the `i` variable (shared by all the closure functions)
    has been left pointing to the last entry (`10`).
  prefs: []
  type: TYPE_NORMAL
- en: 'One solution, in this case, is to use more closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding example is meant to be a TypeScript example.
  prefs: []
  type: TYPE_NORMAL
- en: This works as expected. Rather than the `shooter` functions sharing a single
    environment, the immediately-invoked function creates a new environment for each
    one in which `i` refers to the corresponding value.
  prefs: []
  type: TYPE_NORMAL
- en: Static variables powered by closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we learned that, when a variable in a closure context
    can be shared between multiple instances of a class, this means that the variable
    behaves like a static variable. We will now see how we can create variables and
    methods that behave like a static variable using closures. Let''s start by declaring
    a TypeScript class named `Counter`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding example is meant to be a TypeScript example.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding class contains a static member named `_COUNTER`. The TypeScript
    compiler transforms it into the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding code snippet is the compilation output generated
    by the TypeScript compiler.
  prefs: []
  type: TYPE_NORMAL
- en: As we can observe, the static variable is declared by the TypeScript compiler
    as a class property (as opposed to an instance property). The compiler uses a
    class property because class properties are shared across all instances of a class.
    The problem is that the private variable is not private at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, we could write some JavaScript (remember that all valid JavaScript
    is valid TypeScript) code to emulate static properties using closures:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding example is meant to be a TypeScript example.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding code snippet declares a class named `Counter`. The class has some
    methods used to increment, decrement, and read the variable named `_COUNTER`.
    The `_COUNTER` variable itself is not part of the object prototype.
  prefs: []
  type: TYPE_NORMAL
- en: All the instances of the `Counter` class will share the same context, which
    means that the context (the `_COUNTER` variable and the `changeBy` function) will
    behave as a singleton.
  prefs: []
  type: TYPE_NORMAL
- en: The singleton pattern requires an object to be declared as a static variable
    to avoid the need to create its instance whenever it is required. The object instance
    is, therefore, shared by all the components in the application. The singleton
    pattern is frequently used in scenarios where it is not beneficial, thereby introducing
    unnecessary restrictions in situations where a unique instance of a class is not
    required, and introduces global state into an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So now we know that it is possible to use closures to emulate static variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the preceding example doesn't work as expected because both instances
    of `Counter` share the internal counter. We will learn how to fix this problem
    in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Private members powered by closures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we learned that closures can access variables that
    persist beyond the lexical scope from which they were created. These variables
    are not part of the function's prototype or body, but they are part of the function's
    context.
  prefs: []
  type: TYPE_NORMAL
- en: Because there is no way we can directly invoke the function's context, context
    variables and methods can be used to emulate private members. The main advantage
    of using closures to emulate private members (instead of the TypeScript private
    access modifier) is that closures will prevent access to private members at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript avoids emulating private properties at runtime because the compiler
    will throw an error at compilation time if we attempt to access a private member.
    TypeScript avoids using closures to emulate private members so as to improve application
    performance. If we add or remove an access modifier to or from one of our classes,
    the resulting JavaScript code will not change at all. This means that private
    members of a class become public members at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, it is possible to use closures to emulate private properties at runtime.
    Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Please note that the preceding example is meant to be a TypeScript example.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding class is almost identical to the class that we previously declared
    in order to demonstrate how to emulate static variables at runtime using closures.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, a new closure context is created every time we invoke the `makeCounter`
    function, so each new instance of `Counter` will remember an independent context
    (`_COUNTER` and `changeBy`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Since the context cannot be accessed directly, we can say that the `_COUNTER`
    variable and the `changeBy` function are private members even at runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have acquired a better understanding of the runtime, which
    allows us to not only resolve runtime issues easily, but also to write better
    TypeScript code. An in-depth understanding of closures and prototypes will allow
    us to understand the implementation of some functional programming techniques
    in upcoming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to implement a number of fundamental
    functional programming techniques.
  prefs: []
  type: TYPE_NORMAL
