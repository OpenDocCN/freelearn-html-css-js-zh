- en: Chapter 8. Adding Physics to Your Games Using the Chipmunk2D Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, you saw how to add physics to your games using Box2D.
    However, Box2D isn't the only physics engine supported by Cocos2d-JS; you can
    also feature physics in your games using the Chipmunk2D engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'So the main question is: should you use Box2D or Chipmunk2D to add physics
    to your games? There isn''t a right answer. Just use the one you feel the most
    comfortable with.'
  prefs: []
  type: TYPE_NORMAL
- en: That's why, in this chapter, I will show you how to create the same Totem Destroyer
    game using Chipmunk2D, highlighting the similarities and differences between the
    two physics engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you saw in the previous chapter, it''s time to learn:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Cocos2d-JS to add Chipmunk2D engine to your games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a physics space with gravity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining bodies and shapes to create a physics object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating static objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dynamic objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching sprites to physics objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting physics objects with the mouse or finger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying physics objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for collisions among objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the physics simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using debug draw to test your projects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I assume you are quite familiar with basic Box2D concepts discussed in the previous
    chapter, so I will move on rather fast in the creation of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Chipmunk2D engine to your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we will create the same game as the one in the previous chapter, I suggest
    you copy your project into a new folder since we will reuse most of the code already
    written in the previous chapter. All graphic assets will not change, so simply
    don't touch the `assets` folder. The same thing goes for the `loadassets.js`,
    `main.js` and `project.json` files.
  prefs: []
  type: TYPE_NORMAL
- en: So basically, the only file we will change is `gamescript.js`. Get ready to
    dive into the Chipmunk2D world.
  prefs: []
  type: TYPE_NORMAL
- en: A physics game, without physics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we already built the Totem Destroyer game prototype, we can strip all the
    physics parts out of it and leave just the bare bones, where we will build the
    new physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The physics-stripped version of `gamescript.js` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, everything is ready to inject Chimpunk2D physics into the game. Let's start
    from the beginning and create the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the physics space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Look at the heading. It says **Configuring the physics space**. I used *space*
    rather than *world* because Chipmunk2D calls *space* what Box2D calls *world*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Both world and space represent the same thing: the place where physics-driven
    things happen.'
  prefs: []
  type: TYPE_NORMAL
- en: Although Chipmunk2D calls it *space*, we will continue to use a variable called
    *world* to keep as much similarity with Box2D code as we can. This is the best
    way for you to see the similarities and differences between the two engines.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `init` function in game declaration as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, create the `world` global variable at the very beginning of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what happens when the following line is executed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `cp.Space` method creates the Chipmunk2D space; by now, you should know
    this is the same as the Box2D world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `gravity` property sets `world gravity` with a vector. `cp.v` is how Chipmunk2D
    represents vectors, in the same way as Box2D uses `b2Vec2`. There's a horizontal
    and a vertical component and, to simulate earth gravity, you can use `(0,-100)`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike Box2D, Chipmunk2D does not use real-world units of measurements, so expect
    to use pixels rather than meters.
  prefs: []
  type: TYPE_NORMAL
- en: Adding bodies to the space
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We already have the `addBody` function with all required arguments, so it''s
    time to define it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where big differences between Box2D and Chipmunk2D start to show. Thus,
    we will explain the `addBody` function line-by-line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: We have two ways to create a body, irrespective of whether it's static or dynamic.
    Both use the `cp.Body` method, whose arguments are the mass and the moment of
    inertia. The moment of inertia is the mass property of a rigid body that determines
    the torque needed for a desired angular acceleration about an axis of rotation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For more information, visit the Wikipedia article at [http://en.wikipedia.org/wiki/Moment_of_inertia](http://en.wikipedia.org/wiki/Moment_of_inertia),
    which explains it very clearly.
  prefs: []
  type: TYPE_NORMAL
- en: When a body is dynamic, I set the mass to `1`, but it could be any positive
    finite number, and the moment of inertia is a result of the calculation of the
    mass, the width, and the height by the `momentForBox` method, which does the hard
    work for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, a box with *mass = 1* will be declared this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'While a box with mass 15 will be declared, replacing 1 with 15 in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember, for a dynamic body, the mass can be set to any positive number.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, when dealing with static bodies, you must set both the mass
    and the moment of inertia to an infinite number, which JavaScript represents with
    infinity.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the body is created, you need to give it a position in the space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `setPos` method places it on the space using pixel coordinates. As you can
    see, `cp.v` arguments are the actual pixel coordinates you set when you call the
    `addBody` function with no conversions between units of measurement.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember, in the Box2D chapter, you needed to convert meters to pixels.
    However, Chipmunk2D works directly in pixels.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to add the body to the space:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `addBody` method adds a body to the space. You are probably wondering why
    I am adding the body to it only if it's dynamic. Once a body has been defined
    as static with infinite mass and a moment of inertia, there's no need to add it
    to the space unless you plan to move it manually during the game (think about
    a moving platform, which is not the case with our solid ground), because you will
    only add its collision shape.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is a body collision shape? You are about to discover it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty much like Box2D, Chipmunk2D works with bodies and shapes, where bodies
    represent abstract physics entities, and shapes are actual pieces of physics matter
    attached to bodies. In Box2D, we also use fixtures as glue between a body and
    a shape while, in Chipmunk2D, this is not necessary: we can directly create a
    shape and attach it to a body.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the shape then:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `cp.BoxShape` method creates the shape, gives a width, height, and a body
    to attach the shape to `setFriction`, and `setElasticity` defines the shape material,
    which is referred to as elasticity as Box2D's restitution. I am also giving the
    shape a name; then the `addShape` method adds the shape to the space.
  prefs: []
  type: TYPE_NORMAL
- en: Now, all these shapes and bodies should be ready to be processed by the Chipmunk2D
    space, so it's time to see how to run the simulation.
  prefs: []
  type: TYPE_NORMAL
- en: Updating Chipmunk2D space and using debug draw
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To update the Chipmunk2D space, just call the `step` method in the update function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will make the simulation advance by the `dt` time.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, now run the project and you will see just the background gradient. Did
    we miss something?
  prefs: []
  type: TYPE_NORMAL
- en: Like Box2D, Chipmunk2D does not draw the space; it simply computes it and leaves
    us the job of rendering it.
  prefs: []
  type: TYPE_NORMAL
- en: Anyway, to make quick and simple tests, there's a feature called debug draw
    (also included in Box2D), although I did not show you how to reduce the page count,
    which allows you to render the space without having actual graphic assets attached
    to bodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the `init` function this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: These three lines will create a debug draw layer with the `cc.PhysicsDebugNode.create`
    method, which is later added to the stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating Chipmunk2D space and using debug draw](img/0075SOS_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Also, here are our dynamic totem pieces and our static background rendered with
    debug draw. `PhysicsDebug` will iterate through the shapes and constraints in
    space, and draw them with the default color. Now, we can continue adding features
    to the game and add actual graphic assets once the game is completed. This will
    save developing time because, if something does not work as it should, then we
    can use debug draw to see whether Chipmunk2D bodies position-match the graphic
    assets position.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and destroying space bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The player must be able to destroy certain bodies: the ones called with the
    `destroyable` name by clicking or tapping over them. Thus, this is the complete
    `touchListener` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Before commenting on it, I will explain to you another way to iterate through
    all these bodies or shapes in the space.
  prefs: []
  type: TYPE_NORMAL
- en: Do you remember body selection in Box2D? We looped through all world bodies
    using the `GetBodyList()` function. That's one way to do it. However, there are
    other ways; since I want to show you as many features as possible, this time we'll
    loop through shapes without using any Chipmunk2D proprietary function.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can just add another global variable called `shapeArray`, an empty array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `addBody` function, once we add a shape to the space, we append
    it to `shapeArray`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once we have all the shapes in `shapeArray`, it's easy to loop through them
    and see whether the clicked or touched point is inside one of them thanks to `pointQuery`,
    whose argument is a vector with stage coordinates. If it does not return `undefined`,
    it means the point is inside the given shape.
  prefs: []
  type: TYPE_NORMAL
- en: Then, the `removeBody` and `removeShape` space's methods delete the shape and
    the body, respectively. Remember to manually splice `shapeArray` when you remove
    something.
  prefs: []
  type: TYPE_NORMAL
- en: 'Want to see whether this works? Just run the project and click on a destroyable
    brick:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting and destroying space bodies](img/0075SOS_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Watch out! It's falling bricks!
  prefs: []
  type: TYPE_NORMAL
- en: This reminds me of two things. First, this is not the best way to solve the
    level. Second, we have to detect when the idol hits the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for collisions among bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, to check for collision, we iterated through idol contact
    points to see when it hit the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Both Box2D and Chipmunk2D have more interesting ways to check for collisions,
    as they handle collision listeners.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the highlighted line to the `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'With just one single line, we entered the world of collision listeners. The
    different types of listeners that can be used are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`setDefaultCollisionHandler`: This method will call four functions each time
    a collision will be updated. In Chipmunk2D as well as in Box2D, a collision has
    four states:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`begin`: This method defines the time the script realizes that two shapes are
    touching.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`preSolve`: This method is called just before solving the collision. To solve
    a collision means to update shapes and bodies according to the collision itself.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postSolve`: This method is called just after solving the collision.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`separate`: This method is called when the collision ceases to exist—that is,
    these two shapes are no longer in touch.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We just need to check when the collision begins; that''s why I am passing `collisionBegin`
    as the first argument, leaving other arguments to `null`. The `collisionBegin`
    function is very simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'I am just checking whether the first shape: `arbiter.a` is called `totem`,
    and the second shape: `arbiter.b` is called `ground` or vice versa to output a
    console message.'
  prefs: []
  type: TYPE_NORMAL
- en: You also have to return `true`, or the collision will be ignored.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the project, and when the totem touches the ground this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking for collisions among bodies](img/0075SOS_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You will see this:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Oh no!!!!**'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we completed all the game mechanics of our Totem Destroyer prototype.
    We just have to add our graphic assets to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Did you notice? We are completing a project by adding graphic assets whereas,
    in the previous chapter, we started by adding them. This is one of the things
    I love about programming. Your choices are unlimited.
  prefs: []
  type: TYPE_NORMAL
- en: Using your own graphic assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as in the previous chapter, we will add graphics when we add a body, then
    update their position and rotation according to its body position and rotation.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, update the `addBody` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'This works in the same way as we saw with Box2D: a sprite is added to the game
    and is saved in a custom shape attribute—in this case, `image`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To update the sprite''s position in the `update` function, we need to loop
    through all shapes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We loop through our custom variable, `shapeArray`, and update each shape image
    according to its body position and rotation. While it's very easy to get a body
    position with the `p` property, Chipmunk2D does not return a body rotation in
    degrees or radians, but with a vector; you can get its position with the `rot`
    property. That's why I am using the `atan2` method to get an angle from a vector;
    then I multiply it by `57.2957795` to turn radians into degrees.
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, don''t forget to manually remove a sprite when you remove its body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the project and see your custom graphics in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using your own graphic assets](img/0075SOS_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: At this time, you can remove debug draw graphics; this leaves you with the same
    game made with two different physics engines.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me congratulate you; you not only made a Totem Destroyer game, but you were
    also able to make it using two different physics engines. Not all developers out
    there are able to do it. Now, add to the game the same improvement you added to
    the Box2D game because you improved the game, didn't you? Let's start the last
    chapter, where you will create a blockbuster game in a matter of minutes.
  prefs: []
  type: TYPE_NORMAL
