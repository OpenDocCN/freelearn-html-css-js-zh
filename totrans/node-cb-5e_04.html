<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-101">
    <a id="_idTextAnchor100">
    </a>
    
     4
    
   </h1>
   <h1 id="_idParaDest-102">
    <a id="_idTextAnchor101">
    </a>
    
     Using Web Protocols
    
   </h1>
   <p>
    
     Node.js was built with web servers in mind.
    
    
     Using Node.js, we can quickly create a web server with a few lines of code, allowing us to customize the behavior of
    
    
     
      our server.
     
    
   </p>
   <p>
    <strong class="bold">
     
      HTTP
     
    </strong>
    
     stands
    
    <a id="_idIndexMarker180">
    </a>
    
     for
    
    <strong class="bold">
     
      HyperText Transfer Protocol
     
    </strong>
    
     and is an application layer protocol that underpins the
    
    <strong class="bold">
     
      World Wide Web
     
    </strong>
    
     (
    
    <strong class="bold">
     
      WWW
     
    </strong>
    
     ).
    
    
     HTTP is
    
    <a id="_idIndexMarker181">
    </a>
    
     a stateless protocol that was originally designed to facilitate communication between web browsers and servers.
    
    
     The recipes in this chapter will have a large emphasis on how to handle and send HTTP requests.
    
    
     Although the recipes do not require a deep understanding of how HTTP operates, it would be worthwhile reading a high-level overview if you’re completely new to the concept.
    
    <em class="italic">
     
      MDN Web Docs
     
    </em>
    
     provides an overview of HTTP
    
    
     
      at
     
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview">
     
      
       https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     This chapter will showcase the low-level core
    
    <strong class="bold">
     
      application programming interfaces
     
    </strong>
    
     (
    
    <strong class="bold">
     
      APIs
     
    </strong>
    
     ) that Node.js provides
    
    <a id="_idIndexMarker182">
    </a>
    
     for interacting with web protocols.
    
    
     We’ll start by making HTTP requests, creating an HTTP server, and learning how to handle
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests and file uploads.
    
    
     Later in the chapter, we will learn how to create a WebSocket server and how to create a
    
    <strong class="bold">
     
      Simple Mail Transfer Protocol
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SMTP
     
    </strong>
    
     ) server
    
    <a id="_idIndexMarker183">
    </a>
    
     
      using Node.js.
     
    
   </p>
   <p>
    
     It’s important to understand how Node.js interacts with underlying web protocols, as these web protocols and fundamental concepts form the basis of most real-world web applications.
    
    
     Later, in
    
    <a href="B19212_06.xhtml#_idTextAnchor178">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     , we will learn how to use web frameworks that abstract web protocols into higher-level APIs, but understanding how Node.js interacts with web protocols at a low level
    
    
     
      is important.
     
    
   </p>
   <p>
    
     This chapter will cover the
    
    
     
      following recipes:
     
    
   </p>
   <ul>
    <li>
     
      Making
     
     
      
       HTTP requests
      
     
    </li>
    <li>
     
      Creating an
     
     
      
       HTTP server
      
     
    </li>
    <li>
     
      Receiving HTTP
     
     
      <strong class="source-inline">
       
        POST
       
      </strong>
     
     
      
       requests
      
     
    </li>
    <li>
     
      Handling
     
     
      
       file uploads
      
     
    </li>
    <li>
     
      Creating a
     
     
      
       WebSocket server
      
     
    </li>
    <li>
     
      Creating an
     
     
      
       SMTP server
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-103">
    <a id="_idTextAnchor102">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     This chapter will require you to have Node.js installed – preferably, a recent version of Node.js 22.
    
    
     Also, you will need access to both an editor and a browser of your choice.
    
    
     The code samples used in this chapter are available on GitHub at
    
    <a href="https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition">
     
      https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition
     
    </a>
    
     in the
    
    
     <strong class="source-inline">
      
       Chapter04
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <h1 id="_idParaDest-104">
    <a id="_idTextAnchor103">
    </a>
    
     Making HTTP requests
    
   </h1>
   <p>
    
     Programs and applications
    
    <a id="_idIndexMarker184">
    </a>
    
     often need to obtain data from another source or server.
    
    
     In modern web development, this is commonly achieved by sending an HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request to the source or server.
    
    
     Similarly, an application or program may also need to send data to other sources or servers.
    
    
     This is often achieved by sending an HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request containing the data to the target source
    
    
     
      or server.
     
    
   </p>
   <p>
    
     As well as being used to build HTTP servers, the Node.js core
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      https
     
    </strong>
    
     modules expose APIs that can be used to send HTTP requests to
    
    
     
      other servers.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to use the Node.js core
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      https
     
    </strong>
    
     modules to send both an HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request and an HTTP
    
    
     <strong class="source-inline">
      
       POST
      
     </strong>
    
    
     
      request.
     
    
   </p>
   <h2 id="_idParaDest-105">
    <a id="_idTextAnchor104">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Start by creating a directory named
    
    <strong class="source-inline">
     
      making-requests
     
    </strong>
    
     for this recipe.
    
    
     We’ll also create a file
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       requests.js
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="console">
$ mkdir making-requests
$ cd making-requests
$ touch requests.js</pre>
   <h2 id="_idParaDest-106">
    <a id="_idTextAnchor105">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     We’re going to use the Node.js core
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module to send an HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request and an HTTP
    
    
     <strong class="source-inline">
      
       POST
      
     </strong>
    
    
     
      request.
     
    
   </p>
   <ol>
    <li>
     
      Start by importing the
     
     <strong class="source-inline">
      
       http
      
     </strong>
     
      module in your
     
     
      <strong class="source-inline">
       
        requests.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
const http = require('node:http');</pre>
    </li>
    <li>
     
      Now, we can send an HTTP
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      request.
     
     
      We’re going to send a request to
     
     <a href="http://example.com">
      
       http://example.com
      
     </a>
     
      .
     
     
      This can be done with one line
     
     
      
       of code:
      
     
     <pre class="source-code">
http.get('http://example.com', (res) =&gt;
  res.pipe(process.stdout));</pre>
    </li>
    <li>
     
      Execute your Node.js script with the following command.
     
     
      You should expect to see the HTML representation of
     
     <a href="http://example.com">
      
       http://example.com
      
     </a>
     
      printed
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        stdout
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ node requests.js</strong></pre>
    </li>
    <li>
     
      Now, we can look at how we send an HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request.
     
     
      Start by commenting out the HTTP
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      request with
     
     <strong class="source-inline">
      
       //
      
     </strong>
     
      – leaving it in will make the output of later steps difficult
     
     <a id="_idIndexMarker185">
     </a>
     
      
       to read:
      
     
     <pre class="source-code">
// http.get('http://example.com', (res) =&gt;
  res.pipe(process.stdout));</pre>
    </li>
    <li>
     
      For our HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request, we will first need to define the data that we want to send with the request.
     
     
      To achieve this, we define a variable named
     
     <strong class="source-inline">
      
       payload
      
     </strong>
     
      containing
     
     <a id="_idIndexMarker186">
     </a>
     
      a
     
     <strong class="bold">
      
       JavaScript Object Notation
      
     </strong>
     
      (
     
     <strong class="bold">
      
       JSON
      
     </strong>
     
      ) representation of
     
     
      
       our data:
      
     
     <pre class="source-code">
const payload = JSON.stringify({
    'name': 'Laddie',
    'breed': 'Rough Collie'
});</pre>
    </li>
    <li>
     
      We also need to create a configuration object for the options we want to send with the HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request.
     
     
      We’re going to send the HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request to
     
     <a href="http://postman-echo.com">
      
       http://postman-echo.com
      
     </a>
     
      .
     
     
      This is a test endpoint that will return our HTTP headers, parameters, and content of our HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request – mirroring
     
     
      
       our request:
      
     
     <pre class="source-code">
const opts = {
  method: 'POST',
  hostname: 'postman-echo.com',
  path: '/post',
  headers: {
    'Content-Type': 'application/json',
    'Content-Length': Buffer.byteLength(payload)
  }
};</pre>
    </li>
   </ol>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Postman (
    
    <a href="http://postman.com">
     
      http://postman.com
     
    </a>
    
     ) is a platform for API development and provides a
    
    <strong class="bold">
     
      Representational State Transfer
     
    </strong>
    
     (
    
    <strong class="bold">
     
      REST
     
    </strong>
    
     ) client application that you can download to use to
    
    <a id="_idIndexMarker187">
    </a>
    
     send HTTP requests.
    
    
     Postman also provides a service named Postman Echo – this provides an endpoint that you can send your HTTP requests to for testing.
    
    
     Refer to the Postman
    
    <a id="_idIndexMarker188">
    </a>
    
     Echo documentation
    
    
     
      here:
     
    
    <a href="https://docs.postman-echo.com/?version=latest">
     
      
       https://docs.postman-echo.com/?version=latest
      
     
    </a>
    
     
      .
     
    
   </p>
   <ol>
    <li value="7">
     
      To send the HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request, add the following code.
     
     
      This will write the responses of
     
     <a id="_idIndexMarker189">
     </a>
     
      the HTTP status code and request body to
     
     <strong class="source-inline">
      
       stdout
      
     </strong>
     
      once the response
     
     
      
       is received:
      
     
     <pre class="source-code">
const req = http.request(opts, (res) =&gt; {
  process.stdout.write('Status Code: ' +
    res.statusCode + '\n');
  process.stdout.write('Body: ');
  res.pipe(process.stdout);
});</pre>
    </li>
    <li>
     
      We should also catch any errors that occur on
     
     
      
       the request:
      
     
     <pre class="source-code">
req.on('error', (err) =&gt; console.error('Error: ',
  err));</pre>
    </li>
    <li>
     
      Finally, we need to send our request with
     
     
      
       the payload:
      
     
     <pre class="source-code">
req.end(payload);</pre>
    </li>
    <li>
     
      Now, execute your program, and you should see that the Postman Echo API responds to
     
     <a id="_idIndexMarker190">
     </a>
     
      our HTTP
     
     
      <strong class="source-inline">
       
        POST
       
      </strong>
     
     
      
       request:
      
     
     <pre class="source-code">
<strong class="bold">$ node requests.js</strong>
Status Code: 200
Body: {
  "args": {},
  "data": {
    "name": "Laddie",
    "breed": "Rough Collie"
  },
  "files": {},
  "form": {},
  "headers": {
    "x-forwarded-proto": "http",
    "x-forwarded-port": "80",
    "host": "postman-echo.com",
    "x-amzn-trace-id": "Root=1-656ddcfe-
      52b1cf7a1671685c6985fa59",
    "content-length": "53",
    "content-type": "application/json"
  },
  "json": {
    "name": "Laddie",
    "breed": "Rough Collie"
  },
  "url": "http://postman-echo.com/post"
}%</pre>
    </li>
   </ol>
   <p>
    
     We’ve learned how to use the Node.js core
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module to send HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     and HTTP
    
    
     <strong class="source-inline">
      
       POST
      
     </strong>
    
    
     
      requests.
     
    
   </p>
   <h2 id="_idParaDest-107">
    <a id="_idTextAnchor106">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we leveraged the Node.js core
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module to send HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     and HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests.
    
    
     The Node.js core
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module relies on the underlying Node.js core
    
    
     <strong class="source-inline">
      
       net
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <p>
    
     For the HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request, we call the
    
    <strong class="source-inline">
     
      http.get()
     
    </strong>
    
     function with two parameters.
    
    
     The first parameter is the endpoint that we wish to send the request to, and the second is the callback
    
    <a id="_idIndexMarker191">
    </a>
    
     function.
    
    
     The callback function executes once the HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request is complete, and in this recipe, our function forwards the response we receive from the endpoint
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       stdout
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     To make the HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request, we use the
    
    <strong class="source-inline">
     
      http.request()
     
    </strong>
    
     function.
    
    
     This function also takes
    
    
     
      two parameters.
     
    
   </p>
   <p>
    
     The first parameter to the
    
    <strong class="source-inline">
     
      request()
     
    </strong>
    
     function is the
    
    <strong class="source-inline">
     
      options
     
    </strong>
    
     object.
    
    
     In the recipe
    
    
     
      ,
     
    
    
     we used the
    
    <strong class="source-inline">
     
      options
     
    </strong>
    
     object to configure which HTTP method to use, the hostname, the path the request should be sent to, and the headers to be set on the request.
    
    
     A full list of configuration options that can be passed to the
    
    <strong class="source-inline">
     
      request()
     
    </strong>
    
     function is viewable in the Node.js HTTP API
    
    
     
      documentation (
     
    
    <a href="https://nodejs.org/api/http.html#http_http_request_options_callback">
     
      
       https://nodejs.org/api/http.html#http_http_request_options_callback
      
     
    </a>
    
     
      ).
     
    
   </p>
   <p>
    
     The second parameter to the
    
    <strong class="source-inline">
     
      request()
     
    </strong>
    
     function is the callback function to be executed upon completion of the HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request.
    
    
     Our request function writes the HTTP status code and forwards the request’s
    
    <a id="_idIndexMarker192">
    </a>
    
     response to
    
    <strong class="bold">
     
      standard
     
    </strong>
    
     <strong class="bold">
      
       output
      
     </strong>
    
    
     
      (
     
    
    
     <strong class="source-inline">
      
       stdout
      
     </strong>
    
    
     
      ).
     
    
   </p>
   <p>
    
     An error event listener was added to the request object to capture and log any errors
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       stdout
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
req.on('error', (err) =&gt; console.error('Error: ', err));</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      req.end(payload);
     
    </strong>
    
     statement sends our request with
    
    
     
      the payload.
     
    
   </p>
   <p>
    
     It’s also possible to combine this
    
    <a id="_idIndexMarker193">
    </a>
    
     API with
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     syntax.
    
    
     Add the following to a file
    
    
     
      named
     
    
    
     <strong class="source-inline">
      
       requestPromise.js
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
const http = require('node:http');
function httpGet (url) {
  return new Promise((resolve, reject) =&gt; {
    http
      .get(url, (res) =&gt; {
        let data = '';
        res.on('data', (chunk) =&gt; {
          data += chunk;
        });
        res.on('end', () =&gt; {
          resolve(data);
        });
      })
      .on('error', (err) =&gt; {
        reject(err);
      });
  });
}
const run = async () =&gt; {
  const res = await httpGet('http://example.com');
  console.log(res);
};
run();</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      httpGet()
     
    </strong>
    
     function uses a
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     to manage an asynchronous HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request: it resolves with the full data on successful completion and rejects with an error if the request fails.
    
    
     This setup allows for easy integration with
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     for handling asynchronous
    
    
     
      HTTP operations.
     
    
   </p>
   <h2 id="_idParaDest-108">
    <a id="_idTextAnchor107">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     The recipe demonstrated how to send
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests over HTTP, but it is also worth considering how to send requests over HTTPS.
    
    <strong class="bold">
     
      HTTPS
     
    </strong>
    
     stands for
    
    <strong class="bold">
     
      HyperText Transfer Protocol Secure
     
    </strong>
    
     .
    
    
     HTTPS is an extension of the HTTP protocol.
    
    
     Communications
    
    <a id="_idIndexMarker194">
    </a>
    
     over HTTPS are encrypted.
    
    
     Node.js core provides an
    
    <strong class="source-inline">
     
      https
     
    </strong>
    
     module, alongside the
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module, to be used when dealing with
    
    
     
      HTTPS communications.
     
    
   </p>
   <p>
    
     It is possible to change the requests in the recipe to use HTTPS by importing the
    
    <strong class="source-inline">
     
      https
     
    </strong>
    
     core module and changing any instances of
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      https
     
    </strong>
    
     .
    
    
     You also will need to send the request to the
    
    
     
      HTTPS endpoint:
     
    
   </p>
   <pre class="source-code">
const https = require('node:https');
https.get('https://example.com', ...);
https.request('https://example.com', ...);</pre>
   <p>
    
     Having covered the basics with the traditional HTTP and HTTPS modules for making requests, let’s pivot
    
    <a id="_idIndexMarker195">
    </a>
    
     to explore how to use
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     syntax and the more recently added
    
    
     
      Fetch API.
     
    
   </p>
   <h3>
    
     Using the Fetch API
    
   </h3>
   <p>
    
     Let’s explore
    
    <a id="_idIndexMarker196">
    </a>
    
     the
    
    <strong class="bold">
     
      Fetch API
     
    </strong>
    
     , a modern
    
    <a id="_idIndexMarker197">
    </a>
    
     web API designed for making HTTP requests.
    
    
     While it has been available in browsers for some time, it has more recently become available by default in Node.js.
    
    
     In Node.js, the Fetch API is a higher-level alternative to the core HTTP modules, offering a simplified and user-friendly abstraction over lower-level HTTP APIs.
    
    
     It embraces a
    
    <strong class="source-inline">
     
      Promise
     
    </strong>
    
     -based approach for handling
    
    
     
      asynchronous operations.
     
    
   </p>
   <p>
    
     Starting from Node.js version 18, the Fetch API is readily available as a global API.
    
    
     The implementation in Node.js is powered by
    
    <strong class="source-inline">
     
      undici
     
    </strong>
    
     , an HTTP/1.1 client developed from scratch specifically for Node.js.
    
    
     You can find more information about
    
    <strong class="source-inline">
     
      undici
     
    </strong>
    
     
      at
     
    
    <a href="https://undici.nodejs.org/#/">
     
      
       https://undici.nodejs.org/#/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The implementation was inspired by the frequently used
    
    <strong class="source-inline">
     
      node-fetch
     
    </strong>
    
     (
    
    <a href="https://npmjs.com/package/node-fetch">
     
      https://npmjs.com/package/node-fetch
     
    </a>
    
     ) package.
    
    
     The Node.js implementation of the Fetch API strives to be as close to specification-compliant as possible, but some aspects of the Fetch API specification are more browser-oriented and are therefore omitted in the
    
    
     
      Node.js implementation.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     You can directly use
    
    <strong class="source-inline">
     
      undici
     
    </strong>
    
     as a module for lower-level and more fine-grained control of handling HTTP requests.
    
    
     Read the
    
    <strong class="source-inline">
     
      undici
     
    </strong>
    
     API documentation for more
    
    
     
      information:
     
    
    <a href="https://undici.nodejs.org/#/">
     
      
       https://undici.nodejs.org/#/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Let us look at
    
    <a id="_idIndexMarker198">
    </a>
    
     an example of making HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     and HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests using the Node.js
    
    
     
      Fetch API:
     
    
   </p>
   <ol>
    <li>
     
      Create a file named
     
     <strong class="source-inline">
      
       fetchGet.js
      
     </strong>
     
      and a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        fetchPost.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
$ touch fetchGet.js fetchPost.js</pre>
    </li>
    <li>
     
      Add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        fetchGet.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
async function performGetRequest() {
  const url = 'https://api.github.com/orgs/nodejs';
  try {
    const response = await fetch(url);
    if (!response.ok) {
      throw new Error(`HTTP error! Status:
        ${response.status}`);
    }
    const data = await response.json();
    console.log('GET request successful:', data);
  } catch (error) {
    console.error('Error during GET request:',
      error);
  }
}
performGetRequest();</pre>
    </li>
    <li>
     
      You can run this example with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node fetchGet.js</strong>
GET request successful: {
  login: 'nodejs',
  id: 9950313,
  ...
}</pre>
    </li>
    <li>
     
      To
     
     <a id="_idIndexMarker199">
     </a>
     
      demonstrate
     
     <a id="_idIndexMarker200">
     </a>
     
      making an HTTP
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request using the Node.js Fetch API, add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        fetchPost.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
async function performPostRequest() {
  const url = 'https://postman-echo.com/post';
  const postData = {
    name: 'Laddie',
    breed: 'Rough Collie'
  };
  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify(postData)
    });
    if (!response.ok) {
      throw new Error(`HTTP error! Status:
        ${response.status}`);
    }
    const data = await response.json();
    console.log('POST request successful:', data);
  } catch (error) {
    console.error('Error during POST request:',
      error);
  }
}
performPostRequest();</pre>
     <p class="list-inset">
      
       Note the use of
      
      <a id="_idIndexMarker201">
      </a>
      
       the configuration object to set the HTTP method to
      
      <strong class="source-inline">
       
        POST
       
      </strong>
      
       and set the
      
      
       
        content type.
       
      
     </p>
    </li>
    <li>
     
      Run the example with the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ node fetchPost.js</strong>
POST request successful: {
  args: {},
  data: { name: 'Laddie', breed: 'Rough Collie' },
...</pre>
    </li>
   </ol>
   <p>
    
     As the implementation of the Fetch API in Node.js intends to be as compatible with the specification as
    
    <a id="_idIndexMarker202">
    </a>
    
     possible, you can refer to
    
    <em class="italic">
     
      MDN Web Docs
     
    </em>
    
     for more detailed usage information:
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">
     
      https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API
     
    </a>
    
     .
    
    <em class="italic">
     
      MDN Web Docs
     
    </em>
    
     provides
    
    <a id="_idIndexMarker203">
    </a>
    
     a comprehensive
    
    <a id="_idIndexMarker204">
    </a>
    
     and often considered canonical resource for
    
    
     
      web developers.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     It’s advisable to stay informed about updates and changes to its status as Node.js may release newer versions that refine the Fetch API implementation.
    
    
     Refer to the API
    
    
     
      documentation:
     
    
    <a href="https://nodejs.org/dist/latest-v22.x/docs/api/globals.html#fetch">
     
      
       https://nodejs.org/dist/latest-v22.x/docs/api/globals.html#fetch
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-109">
    <a id="_idTextAnchor108">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Creating an HTTP server
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Receiving HTTP POST requests
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     <em class="italic">
      
       Chapters 3
      
     </em>
     
      ,
     
     <em class="italic">
      
       6
      
     </em>
     
      ,
     
     
      
       and
      
     
     
      <em class="italic">
       
        9
       
      </em>
     
    </li>
   </ul>
   <h1 id="_idParaDest-110">
    <a id="_idTextAnchor109">
    </a>
    
     Creating an HTTP server
    
   </h1>
   <p>
    
     When building large
    
    <a id="_idIndexMarker205">
    </a>
    
     complex applications, it is typical to implement HTTP servers using a higher-level web framework rather than interacting with core Node.js APIs.
    
    
     However, understanding the underlying APIs is important, and in some cases, only interacting with the underlying Node.js APIs will provide you with the fine-grained control required in
    
    
     
      certain circumstances.
     
    
   </p>
   <p>
    
     In the previous section, we explored foundational concepts of HTTP and relevant Node.js core APIs.
    
    
     In this tutorial, we’ll guide you through the process of building an HTTP server using Node.js where we’ll initially focus on handling
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     requests – fundamental functionality for
    
    
     
      web servers.
     
    
   </p>
   <h2 id="_idParaDest-111">
    <a id="_idTextAnchor110">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Start by creating a directory for this recipe and a file named
    
    <strong class="source-inline">
     
      server.js
     
    </strong>
    
     that will contain our
    
    
     
      HTTP server:
     
    
   </p>
   <pre class="console">
$ mkdir http-server
$ cd http-server
$ touch server.js</pre>
   <h2 id="_idParaDest-112">
    <a id="_idTextAnchor111">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     For this recipe, we will be using the core Node.js
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module.
    
    
     API documentation for the
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module is available at
    
    <a href="https://nodejs.org/api/http.html">
     
      https://nodejs.org/api/http.html
     
    </a>
    
     .
    
    
     In the recipe, we’ll create a “To Do”
    
    
     
      task server.
     
    
   </p>
   <ol>
    <li>
     
      To start, we need to import the core Node.js
     
     <strong class="source-inline">
      
       http
      
     </strong>
     
      module by adding the following line
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const http = require('node:http');</pre>
    </li>
    <li>
     
      We’ll start by defining the hostname and port for
     
     
      
       our server:
      
     
     <pre class="source-code">
const HOSTNAME = process.env.HOSTNAME || '0.0.0.0';
const PORT = process.env.PORT || 3000;</pre>
    </li>
    <li>
     
      Next, we can create the server and add some route handling.
     
     
      Within the
     
     <strong class="source-inline">
      
       createServer()
      
     </strong>
     
      function, we will reference the
     
     <strong class="source-inline">
      
       error()
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       todo()
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       index()
      
     </strong>
     
      functions that we’ll create in the
     
     
      
       following steps:
      
     
     <pre class="source-code">
const server = http.createServer((req, res) =&gt; {
  if (req.method !== 'GET') return error(res, 405);
  if (req.url === '/todo') return todo(res);
  if (req.url === '/') return index(res);
  error(res, 404);
});</pre>
    </li>
    <li>
     
      Now, let’s create our
     
     <strong class="source-inline">
      
       error()
      
     </strong>
     
      function.
     
     
      This function will take a parameter of the response object and a status code, where the code is expected to be an HTTP
     
     
      
       status
      
     
     
      <a id="_idIndexMarker206">
      </a>
     
     
      
       code:
      
     
     <pre class="source-code">
function error (res, code) {
  res.statusCode = code;
  res.end(`{"error":
    "${http.STATUS_CODES[code]}"}`);
}</pre>
    </li>
    <li>
     
      We will now create our
     
     <strong class="source-inline">
      
       todo()
      
     </strong>
     
      function.
     
     
      For now, this function will just return a static JSON string representing an item on the “To
     
     
      
       Do” list:
      
     
     <pre class="source-code">
function todo (res) {
  res.end('[{"task_id": 1, "description": "walk the
    dog"}]}');
}</pre>
    </li>
    <li>
     
      The final function to create is an
     
     <strong class="source-inline">
      
       index()
      
     </strong>
     
      function, which will be called when we perform a
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      request on the
     
     <strong class="source-inline">
      
       /
      
     </strong>
     
      
       route:
      
     
     <pre class="source-code">
function index (res) {
  res.end('{"name": "todo-server"}');
}</pre>
    </li>
    <li>
     
      Finally, we need to call the
     
     <strong class="source-inline">
      
       listen()
      
     </strong>
     
      function on our server.
     
     
      We’ll also pass a callback function to the
     
     <strong class="source-inline">
      
       listen()
      
     </strong>
     
      function that will log out the address that the server is listening on once the server
     
     
      
       has started:
      
     
     <pre class="source-code">
server.listen(PORT, HOSTNAME, () =&gt; {
  console.log(`Server listening on port
    ${server.address().port}`);
});</pre>
    </li>
    <li>
     
      It’s now possible to start our server from
     
     
      
       our terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">Server listening on port 3000</strong></pre>
    </li>
    <li>
     
      In a separate terminal window, we can either use cURL to send
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      requests to our server or
     
     <a id="_idIndexMarker207">
     </a>
     
      access the various endpoints in
     
     
      
       our browser:
      
     
     <pre class="source-code">
$ curl http://localhost:3000/
{"name": "todo-server"}%
$ curl http://localhost:3000/todo
[{"task_id": 1, "description": "walk the dog"}]}%
$ curl -X DELETE http://localhost:3000/
{"error": "Method Not Allowed"}%
$ curl http://localhost:3000/not-an-endpoint
{"error": "Not Found"}%</pre>
    </li>
   </ol>
   <p>
    
     We’ve built a barebones “To Do” list server that we can send HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     requests to, and the server responds with
    
    
     
      JSON data.
     
    
   </p>
   <h2 id="_idParaDest-113">
    <a id="_idTextAnchor112">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The Node.js core
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module provides interfaces to the features of the
    
    
     
      HTTP protocol.
     
    
   </p>
   <p>
    
     In the recipe, we created a server using the
    
    <strong class="source-inline">
     
      createServer()
     
    </strong>
    
     function that is exposed by the
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module.
    
    
     We passed the
    
    <strong class="source-inline">
     
      createServer()
     
    </strong>
    
     function a request listener function that is executed upon
    
    
     
      each request.
     
    
   </p>
   <p>
    
     Each time a request is received to the specified route, the request listener function will execute.
    
    
     The request listener function has two parameters,
    
    <strong class="source-inline">
     
      req
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      res
     
    </strong>
    
     , where
    
    <strong class="source-inline">
     
      req
     
    </strong>
    
     is the request object and
    
    <strong class="source-inline">
     
      res
     
    </strong>
    
     is the response object.
    
    
     The
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module creates the
    
    <strong class="source-inline">
     
      req
     
    </strong>
    
     object based on the data in
    
    
     
      the request.
     
    
   </p>
   <p>
    
     It is possible to pass the
    
    <strong class="source-inline">
     
      createServer()
     
    </strong>
    
     function an
    
    <strong class="source-inline">
     
      options
     
    </strong>
    
     object as the first parameter.
    
    
     Refer to the
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module Node.js API documentation to see which parameters and options can be passed to the various
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     
      functions:
     
    
    <a href="https://nodejs.org/api/http.html">
     
      
       https://nodejs.org/api/http.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      createServer()
     
    </strong>
    
     function returns an
    
    <strong class="source-inline">
     
      http.Server
     
    </strong>
    
     object.
    
    
     We start the server by calling the
    
    <strong class="source-inline">
     
      listen()
     
    </strong>
    
     function.
    
    
     We pass the
    
    <strong class="source-inline">
     
      listen()
     
    </strong>
    
     function our
    
    <strong class="source-inline">
     
      HOSTNAME
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      PORT
     
    </strong>
    
     parameters to instruct the server which hostname and port it should be
    
    
     
      listening on.
     
    
   </p>
   <p>
    
     Our request handler in the recipe is formed of three
    
    <strong class="source-inline">
     
      if
     
    </strong>
    
     statements.
    
    
     The first
    
    <strong class="source-inline">
     
      if
     
    </strong>
    
     statement checks the
    
    <strong class="source-inline">
     
      req.method
     
    </strong>
    
     property for which HTTP method the incoming request was
    
    
     
      sent with:
     
    
   </p>
   <pre class="source-code">
  if (req.method !== 'GET') return error(res, 405);</pre>
   <p>
    
     In this recipe, we
    
    <a id="_idIndexMarker208">
    </a>
    
     only allowed
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     requests.
    
    
     When any other HTTP method is detected on the incoming request, we return and call our
    
    
     
      error function.
     
    
   </p>
   <p>
    
     The second two
    
    <strong class="source-inline">
     
      if
     
    </strong>
    
     statements inspect the
    
    
     <strong class="source-inline">
      
       req.url
      
     </strong>
    
    
     
      value:
     
    
   </p>
   <pre class="source-code">
  if (req.url === '/todo') return todo(res);
  if (req.url === '/') return index(res);</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      url
     
    </strong>
    
     property on the request object informs us which route the request was sent to.
    
    
     The
    
    <strong class="source-inline">
     
      req.url
     
    </strong>
    
     property does not provide
    
    <a id="_idIndexMarker209">
    </a>
    
     the full
    
    <strong class="bold">
     
      Uniform Resource Locator
     
    </strong>
    
     (
    
    <strong class="bold">
     
      URL
     
    </strong>
    
     ), just the relative path or “route” segment.
    
    
     The
    
    <strong class="source-inline">
     
      if
     
    </strong>
    
     statements in this recipe control which function is called upon each request to a specific URL – this forms
    
    <a id="_idIndexMarker210">
    </a>
    
     a
    
    <strong class="bold">
     
      simple
     
    </strong>
    
     <strong class="bold">
      
       route handler
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     The final line of our listener function calls our
    
    <strong class="source-inline">
     
      error()
     
    </strong>
    
     function.
    
    
     This line will only be reached if none of our conditional
    
    <strong class="source-inline">
     
      if
     
    </strong>
    
     statements are satisfied.
    
    
     In our recipe, this will happen when a request is sent to any route other than
    
    <strong class="source-inline">
     
      /
     
    </strong>
    
     
      or
     
    
    
     <strong class="source-inline">
      
       /todo
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We pass the response object,
    
    <strong class="source-inline">
     
      res
     
    </strong>
    
     , to each of our
    
    <strong class="source-inline">
     
      error()
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      todo()
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      index()
     
    </strong>
    
     functions.
    
    
     This object is a
    
    <strong class="source-inline">
     
      Stream
     
    </strong>
    
     object.
    
    
     We call
    
    <strong class="source-inline">
     
      res.end()
     
    </strong>
    
     to return the
    
    
     
      desired content.
     
    
   </p>
   <p>
    
     For the
    
    <strong class="source-inline">
     
      error()
     
    </strong>
    
     function, we pass an additional parameter,
    
    <strong class="source-inline">
     
      code
     
    </strong>
    
     .
    
    
     We use this to pass and then return HTTP status codes.
    
    
     HTTP status codes are part of the HTTP protocol specification (
    
    <a href="https://tools.ietf.org/html/rfc2616#section-10">
     
      https://tools.ietf.org/html/rfc2616#section-10
     
    </a>
    
     ).
    
    
     The following table shows how HTTP response codes
    
    
     
      are grouped:
     
    
   </p>
   <table class="No-Table-Style _idGenTablePara-1" id="table001-2">
    <colgroup>
     <col/>
     <col/>
    </colgroup>
    <tbody>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Range
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         <strong class="bold">
          
           Use
          
         </strong>
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           1xx
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Information
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           2xx
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Success
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           3xx
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Redirection
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           4xx
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Client error
         
        
       </p>
      </td>
     </tr>
     <tr class="No-Table-Style">
      <td class="No-Table-Style">
       <p>
        
         <strong class="source-inline">
          
           5xx
          
         </strong>
        
       </p>
      </td>
      <td class="No-Table-Style">
       <p>
        
         
          Server error
         
        
       </p>
      </td>
     </tr>
    </tbody>
   </table>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Table 4.1 – Table listing HTTP status codes and their use
    
   </p>
   <p>
    
     In the recipe, we returned the following
    
    
     
      error codes:
     
    
   </p>
   <ul>
    <li>
     
      404 –
     
     
      
       Not Found
      
     
    </li>
    <li>
     
      405 – Method
     
     
      
       Not Allowed
      
     
    </li>
   </ul>
   <p>
    
     The
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module
    
    <a id="_idIndexMarker211">
    </a>
    
     exposes a constant object that stores all the HTTP response codes and their corresponding descriptions:
    
    <strong class="source-inline">
     
      http.STATUS_CODES
     
    </strong>
    
     .
    
    
     We used this to return the response message
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       http.STATUS_CODE
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-114">
    <a id="_idTextAnchor113">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In the recipe, we defined a constant for the
    
    <strong class="source-inline">
     
      HOSTNAME
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      PORT
     
    </strong>
    
     values with the
    
    
     
      following lines:
     
    
   </p>
   <pre class="source-code">
const HOSTNAME = process.env.HOSTNAME || '0.0.0.0';
const PORT = process.env.PORT || 3000;</pre>
   <p>
    
     The use of
    
    <strong class="source-inline">
     
      process.env
     
    </strong>
    
     allows the values to be set as environment variables.
    
    
     If the environmental variables are not set, then our use of the
    
    <strong class="source-inline">
     
      OR
     
    </strong>
    
     logical operator (
    
    <strong class="source-inline">
     
      ||
     
    </strong>
    
     ) will mean our hostname and port values default to
    
    <strong class="source-inline">
     
      0.0.0.0
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       3000
      
     </strong>
    
    
     
      respectively.
     
    
   </p>
   <p>
    
     It’s a good practice to allow the hostname and port values to be set via environment variables as this allows deployment orchestrators, such as Kubernetes, to inject these values
    
    
     
      at runtime.
     
    
   </p>
   <p>
    
     It’s also possible to bind your HTTP server to a random free port.
    
    
     To do this, we set the
    
    <strong class="source-inline">
     
      PORT
     
    </strong>
    
     value to
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     .
    
    
     You can change our recipe code that assigns the
    
    <strong class="source-inline">
     
      PORT
     
    </strong>
    
     variable to the following to instruct the server to listen to a random
    
    
     
      free port:
     
    
   </p>
   <pre class="source-code">
const PORT = process.env.PORT || 0;</pre>
   <p>
    
     Binding to any random port in Node.js is useful when deploying on platforms that dynamically assign ports (for example, cloud services) or in scenarios with potential port conflicts (for example, multiple instances
    
    
     
      running simultaneously).
     
    
   </p>
   <h3>
    
     Using --env-file
    
   </h3>
   <p>
    
     As of Node.js 20.6.0 and
    
    <a id="_idIndexMarker212">
    </a>
    
     later, there is a new command-line option
    
    <a id="_idIndexMarker213">
    </a>
    
     that can be used to load environment variables from files.
    
    
     This provides similar functionality to the commonly used
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     package
    
    <strong class="source-inline">
     
      dotenv
     
    </strong>
    
     (
    
    <a href="https://www.npmjs.com/package/dotenv">
     
      https://www.npmjs.com/package/dotenv
     
    </a>
    
     ) by loading environment variables
    
    <a id="_idIndexMarker214">
    </a>
    
     into
    
    <strong class="source-inline">
     
      process.env
     
    </strong>
    
     from a file containing the
    
    
     
      environment variables.
     
    
   </p>
   <p>
    
     Each line in the file should consist of a key-value pair representing an environment variable, with the name and value separated by an equals sign (
    
    <strong class="source-inline">
     
      =
     
    </strong>
    
     ).
    
    
     For example, you would add the following to define the
    
    <strong class="source-inline">
     
      HOSTNAME
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      PORT
     
    </strong>
    
     variables to the default values used in
    
    
     
      the recipe:
     
    
   </p>
   <pre class="source-code">
HOSTNAME='0.0.0.0'
PORT=3000</pre>
   <p>
    
     Often, this file will be called
    
    <strong class="source-inline">
     
      .env
     
    </strong>
    
     for local development, but it is also common to have multiple environment files representing different application environments, such as
    
    <strong class="source-inline">
     
      .staging.env
     
    </strong>
    
     for environment values that correspond to the staging application of
    
    
     
      your development.
     
    
   </p>
   <p>
    
     To load the values in the environment, you need to supply the
    
    <strong class="source-inline">
     
      --env-file
     
    </strong>
    
     
      command-line option:
     
    
   </p>
   <pre class="console">
$ node --env-file=.env server.js</pre>
   <p>
    
     If the same variable is defined in the environment and the file, the value from the environment will
    
    
     
      take precedence.
     
    
   </p>
   <p>
    
     Note that at the time of writing, this feature is
    
    <a id="_idIndexMarker215">
    </a>
    
     designated as
    
    <strong class="bold">
     
      Experimental
     
    </strong>
    
     status, meaning the feature may be subject to breaking changes and/or removal.
    
    
     More details can be
    
    <a id="_idIndexMarker216">
    </a>
    
     found in the
    
    <a id="_idIndexMarker217">
    </a>
    
     official API documentation
    
    
     
      at
     
    
    <a href="https://nodejs.org/docs/latest-v22.x/api/cli.html#--env-fileconfig">
     
      
       https://nodejs.org/docs/latest-v22.x/api/cli.html#--env-fileconfig
      
     
    </a>
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-115">
    <a id="_idTextAnchor114">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Receiving HTTP POST requests
      
     </em>
     
      recipe in
     
     
      
       this chapter
      
     
    </li>
    <li>
     <em class="italic">
      
       Chapters 6
      
     </em>
     
      
       and
      
     
     
      <em class="italic">
       
        11
       
      </em>
     
    </li>
   </ul>
   <h1 id="_idParaDest-116">
    <a id="_idTextAnchor115">
    </a>
    
     Receiving HTTP POST requests
    
   </h1>
   <p>
    
     The HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method is
    
    <a id="_idIndexMarker218">
    </a>
    
     employed for transmitting data to the server, in contrast to the HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method, which is utilized to
    
    
     
      retrieve data.
     
    
   </p>
   <p>
    
     To be able to receive
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     data, we need to instruct our server on how to accept and handle
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests.
    
    
     A
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request typically contains data within the body of the request, which is sent to the server to be handled.
    
    
     The submission of a web form is typically done via an HTTP
    
    
     <strong class="source-inline">
      
       POST
      
     </strong>
    
    
     
      request.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     In PHP, it is possible to access
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     data via a
    
    <strong class="source-inline">
     
      $_POST
     
    </strong>
    
     array.
    
    
     PHP does not follow the non-blocking architecture that Node.js does, which means that the PHP program would wait or block until the
    
    <strong class="source-inline">
     
      $_POST
     
    </strong>
    
     values are populated.
    
    
     Node.js, however, provides asynchronous interaction with HTTP data at a lower level, which allows us to interface with the incoming message body as a stream.
    
    
     This means that the handling of the incoming stream is within the developer’s control
    
    
     
      and concern.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to create a web server that accepts and handles HTTP
    
    
     <strong class="source-inline">
      
       POST
      
     </strong>
    
    
     
      requests.
     
    
   </p>
   <h2 id="_idParaDest-117">
    <a id="_idTextAnchor116">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To prepare the groundwork for the recipe, we’ll start by setting up the
    
    
     
      project structure.
     
    
   </p>
   <ol>
    <li>
     
      Start by creating a directory for this recipe.
     
     
      We’ll also need a file named
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      that will contain our
     
     
      
       HTTP server:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir post-server</strong>
<strong class="bold">$ cd post-server</strong>
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      We also need to create a subdirectory called
     
     <strong class="source-inline">
      
       public
      
     </strong>
     
      , containing a file named
     
     <strong class="source-inline">
      
       form.html
      
     </strong>
     
      that will contain an
     
     
      
       HTML form:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir public</strong>
<strong class="bold">$ touch public/form.html</strong></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-118">
    <a id="_idTextAnchor117">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     We’re going to create a server
    
    <a id="_idIndexMarker219">
    </a>
    
     that accepts and handles both HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     and HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests using the Node.js core APIs provided by the
    
    
     <strong class="source-inline">
      
       http
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <ol>
    <li>
     
      First, let’s set up an HTML form with input fields for forename and surname.
     
     
      Open
     
     <strong class="source-inline">
      
       form.html
      
     </strong>
     
      and add
     
     
      
       the following:
      
     
     <pre class="source-code">
&lt;form method="POST"&gt;
    &lt;label for="forename"&gt;Forename:&lt;/label&gt;
    &lt;input id="forename" name="forename"&gt;
    &lt;label for="surname"&gt;Surname:&lt;/label&gt;
    &lt;input id="surname" name="surname"&gt;
    &lt;input type="submit" value="Submit"&gt;
&lt;/form&gt;</pre>
    </li>
    <li>
     
      Next, open the
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file and import the
     
     <strong class="source-inline">
      
       fs
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       http
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       path
      
     </strong>
     
      Node.js
     
     
      
       core modules:
      
     
     <pre class="source-code">
const http = require('node:http');
const fs = require('node:fs');
const path = require('node:path');</pre>
    </li>
    <li>
     
      On the next line, we’ll create a reference to our
     
     
      <strong class="source-inline">
       
        form.html
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
const form = fs.readFileSync(path.join(__dirname, 'public', 'form.html'));</pre>
    </li>
    <li>
     
      Now, add the following lines of code to
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      to set up the server.
     
     
      We’ll also create a
     
     <strong class="source-inline">
      
       get()
      
     </strong>
     
      function to
     
     <a id="_idIndexMarker220">
     </a>
     
      return the form and an error function
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        error()
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
http
  .createServer((req, res) =&gt; {
    if (req.method === 'GET') {
      get(res);
      return;
    }
    error(405, res);
  })
  .listen(3000, () =&gt; console.log('Server running on
    http://localhost:3000/'));
function get (res) {
  res.writeHead(200, {
    'Content-Type': 'text/html'
  });
  res.end(form);
}
function error (code, res) {
  res.statusCode = code;
  res.end(http.STATUS_CODES[code]);
}</pre>
    </li>
    <li>
     
      Start your server and confirm that you can view the form in your browser
     
     
      
       at
      
     
     
      <strong class="source-inline">
       
        http://localhost:3000
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
     <p class="list-inset">
      
       Expect to see the
      
      <a id="_idIndexMarker221">
      </a>
      
       following HTML form in
      
      
       
        your browser:
       
      
     </p>
     <div><img alt="Figure 4.1 – Browser window depicting an HTML form" src="img/B19212_04_01.jpg"/>
      
     </div>
    </li>
   </ol>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 4.1 – Browser window depicting an HTML form
    
   </p>
   <ol>
    <li value="6">
     
      In your browser, click
     
     <strong class="bold">
      
       Submit
      
     </strong>
     
      on the form.
     
     
      Notice that you receive a
     
     <strong class="bold">
      
       Method Not Allowed
      
     </strong>
     
      error message.
     
     
      This is because we do not yet have a conditional statement in our request listener function that handles
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      requests.
     
     
      Let’s add one now.
     
     
      Add the following code below the
     
     <strong class="source-inline">
      
       if
      
     </strong>
     
      statement that checks for
     
     
      <strong class="source-inline">
       
        GET
       
      </strong>
     
     
      
       requests:
      
     
     <pre class="source-code">
  if (req.method === 'POST') {
      post(req, res);
      return;
    }</pre>
    </li>
    <li>
     
      Now, we’ll also need to define our
     
     <strong class="source-inline">
      
       post()
      
     </strong>
     
      function.
     
     
      Add this below your
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file, ideally
     
     <a id="_idIndexMarker222">
     </a>
     
      just below the
     
     <strong class="source-inline">
      
       get()
      
     </strong>
     
      
       function definition:
      
     
     <pre class="source-code">
function post (req, res) {
  if (req.headers['content-type'] !==
    'application/x-www-form-urlencoded') {
    error(415, res);
    return;
  }
  let input = '';
  req.on('data', (chunk) =&gt; {
    input += chunk.toString();
  });
  req.on('end', () =&gt; {
    console.log(input);
    res.end(http.STATUS_CODES[200]);
  });
}</pre>
    </li>
    <li>
     
      Restart your server, return to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      in your browser, and submit the form.
     
     
      You should see an
     
     <strong class="source-inline">
      
       OK
      
     </strong>
     
      message returned.
     
     
      If you look at the terminal window where you’re running your server, you can see that the server received
     
     
      
       your data:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">forename=Ada&amp;surname=Lovelace</strong></pre>
    </li>
   </ol>
   <p>
    
     We’ve now created a server that accepts and handles both HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     and HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests using the Node.js
    
    <a id="_idIndexMarker223">
    </a>
    
     core APIs provided by the
    
    
     <strong class="source-inline">
      
       http
      
     </strong>
    
    
     
      module.
     
    
   </p>
   <h2 id="_idParaDest-119">
    <a id="_idTextAnchor118">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The Node.js core
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module is built on top of and interacts with the Node.js core
    
    <strong class="source-inline">
     
      net
     
    </strong>
    
     module.
    
    
     The
    
    <strong class="source-inline">
     
      net
     
    </strong>
    
     module interacts with an underlying C library built into Node.js, called
    
    <strong class="source-inline">
     
      libuv
     
    </strong>
    
     .
    
    
     The
    
    <strong class="source-inline">
     
      libuv
     
    </strong>
    
     C library handles network
    
    <a id="_idIndexMarker224">
    </a>
    
     socket
    
    <strong class="bold">
     
      input/output
     
    </strong>
    
     (
    
    <strong class="bold">
     
      I/O
     
    </strong>
    
     ) and handles the passing of data between the C and
    
    
     
      JavaScript layers.
     
    
   </p>
   <p>
    
     As in previous recipes, we call the
    
    <strong class="source-inline">
     
      createServer()
     
    </strong>
    
     function, which returns an HTTP server object.
    
    
     Then, calling the
    
    <strong class="source-inline">
     
      listen()
     
    </strong>
    
     method on the server object instructs the
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module to start listening for incoming data on the specified address
    
    
     
      and port.
     
    
   </p>
   <p>
    
     When the server receives an HTTP request, the
    
    <strong class="source-inline">
     
      http
     
    </strong>
    
     module will create objects representing the HTTP request (
    
    <strong class="source-inline">
     
      req
     
    </strong>
    
     ) and the HTTP response (
    
    <strong class="source-inline">
     
      res
     
    </strong>
    
     ).
    
    
     After this, our request handler is called with the
    
    <strong class="source-inline">
     
      req
     
    </strong>
    
     and
    
    
     <strong class="source-inline">
      
       res
      
     </strong>
    
    
     
      arguments.
     
    
   </p>
   <p>
    
     Our route handler has the following
    
    <strong class="source-inline">
     
      if
     
    </strong>
    
     statements, which inspect each request to see if it is an HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request or an HTTP
    
    
     <strong class="source-inline">
      
       POST
      
     </strong>
    
    
     
      request:
     
    
   </p>
   <pre class="source-code">
http
  .createServer((req, res) =&gt; {
    if (req.method === 'GET') {
      get(res);
      return;
    }
    if (req.method === 'POST') {
      post(req, res);
      return;
    }
    error(405, res);
  })
  .listen(3000);</pre>
   <p>
    
     Our
    
    <strong class="source-inline">
     
      get()
     
    </strong>
    
     function sets the
    
    <strong class="source-inline">
     
      Content-Type
     
    </strong>
    
     HTTP header to
    
    <strong class="source-inline">
     
      text/html
     
    </strong>
    
     , as we’re expecting to return an HTML form.
    
    
     We call the
    
    <strong class="source-inline">
     
      res.end()
     
    </strong>
    
     function to finish
    
    <strong class="source-inline">
     
      WriteStream
     
    </strong>
    
     , write the response, and end the HTTP connection.
    
    
     Refer to
    
    <a href="B19212_03.xhtml#_idTextAnchor068">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     for more information
    
    
     
      on
     
    
    
     <strong class="source-inline">
      
       WriteStream
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Similarly, our
    
    <strong class="source-inline">
     
      post()
     
    </strong>
    
     function checks the
    
    <strong class="source-inline">
     
      Content-Type
     
    </strong>
    
     headers to determine whether we can support the supplied values.
    
    
     In this instance, we only accept the
    
    <strong class="source-inline">
     
      Content-Type
     
    </strong>
    
     header of
    
    <strong class="source-inline">
     
      application/x-www-form-urlencode
     
    </strong>
    
     , and our error function will be called if the request is sent with any other
    
    
     
      content type.
     
    
   </p>
   <p>
    
     Within our request handler function, we register a listener for the data event.
    
    
     Each time a chunk of data is received, we convert it to a string using the
    
    <strong class="source-inline">
     
      toString()
     
    </strong>
    
     method and append it to our
    
    
     
      input variable.
     
    
   </p>
   <p>
    
     Once all the data is received from the client, the
    
    <strong class="source-inline">
     
      end
     
    </strong>
    
     event is triggered.
    
    
     We pass a callback function to
    
    <a id="_idIndexMarker225">
    </a>
    
     the end event listener, which gets called only once all data is received.
    
    
     Our callback logs the data received and returns an
    
    <strong class="source-inline">
     
      HTTP
     
    </strong>
    <strong class="source-inline">
     
      OK
     
    </strong>
    
     
      status message.
     
    
   </p>
   <h2 id="_idParaDest-120">
    <a id="_idTextAnchor119">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Node.js servers commonly
    
    <a id="_idIndexMarker226">
    </a>
    
     allow interaction via JSON.
    
    
     Let’s look at how we can
    
    <a id="_idIndexMarker227">
    </a>
    
     handle HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     requests that are sending JSON data.
    
    
     Specifically, this means accepting and handling content with the
    
    <strong class="source-inline">
     
      application/json
     
    </strong>
    
     
      content type.
     
    
   </p>
   <p>
    
     Let’s convert the server from this recipe to handle
    
    
     
      JSON data.
     
    
   </p>
   <ol>
    <li>
     
      First, copy the existing
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      file to a new file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        json-server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ cp server.js json-server.js</strong></pre>
    </li>
    <li>
     
      Then, we will change our
     
     <strong class="source-inline">
      
       post()
      
     </strong>
     
      function to check that the
     
     <strong class="source-inline">
      
       Content-Type
      
     </strong>
     
      header of the request is set
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        application/json
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
function post (req, res) {
  if (req.headers['content-type'] !==
    'application/json') {
      error(415, res);
      return;
    }
...</pre>
    </li>
    <li>
     
      We also need to change our
     
     <strong class="source-inline">
      
       end
      
     </strong>
     
      event listener function to parse and return the
     
     
      
       JSON data:
      
     
     <pre class="source-code">
  req.on('end', () =&gt; {
    try {
      const parsed = JSON.parse(input);
      console.log('Received data: ', parsed);
      res.end('{"data": ' + input + '}');
    } catch (err) {
      error(400, res);
    }
  });</pre>
    </li>
    <li>
     
      Let’s now test whether our server can handle the
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      route.
     
     
      We will do this using the
     
     <strong class="source-inline">
      
       cURL
      
     </strong>
     
      command-line tool.
     
     
      Start your server in one
     
     
      
       terminal window:
      
     
     <pre class="source-code">
<strong class="bold">$ node json-server.js</strong></pre>
    </li>
    <li>
     
      In a separate terminal window, enter the
     
     
      
       following command:
      
     
     <pre class="source-code">
<strong class="bold">$ curl --header "Content-Type: application/json" \</strong>
<strong class="bold">  --request POST \</strong>
<strong class="bold">  --data '{"forename":"Ada","surname":"Lovelace"}' \</strong>
<strong class="bold">  http://localhost:3000/</strong>
<strong class="bold">{"data": {"forename":"Ada","surname":"Lovelace"}}%</strong></pre>
    </li>
    <li>
     
      Now, we can add the following script to our
     
     <strong class="source-inline">
      
       form.html
      
     </strong>
     
      file, which will convert our HTML
     
     <a id="_idIndexMarker228">
     </a>
     
      form
     
     <a id="_idIndexMarker229">
     </a>
     
      data into JSON and send it via a
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      request to the server.
     
     
      Add the following after the closing form
     
     
      
       tag (
      
     
     
      <strong class="source-inline">
       
        &lt;/form&gt;
       
      </strong>
     
     
      
       ):
      
     
     <pre class="source-code">
&lt;script&gt;
  document.forms[0].addEventListener("submit", (event) =&gt; {
    event.preventDefault();
    let data = {
      forename:
        document.getElementById("forename").value,
      surname:
        document.getElementById("surname").value,
    };
    console.log("data", data);
    fetch("http://localhost:3000", {
      method: "post",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(data),
    }).then(function (response) {
      console.log(response);
      return response.json();
    });
  });
&lt;/script&gt;</pre>
    </li>
   </ol>
   <p>
    
     Restart your JSON server with
    
    <strong class="source-inline">
     
      $ node json-server.js
     
    </strong>
    
     and navigate to
    
    <strong class="source-inline">
     
      http://localhost:3000
     
    </strong>
    
     in your browser.
    
    
     If we now complete the input fields in our browser and submit the form, we should see in the server logs that the request has been successfully sent to the server.
    
    
     Note that our use of
    
    <strong class="source-inline">
     
      event.preventDefault()
     
    </strong>
    
     will prevent the browser from redirecting the web page upon submission of
    
    
     
      the form.
     
    
   </p>
   <p>
    
     Our form and server behave
    
    <a id="_idIndexMarker230">
    </a>
    
     similarly to the server we created in the
    
    <em class="italic">
     
      Receiving HTTP POST requests
     
    </em>
    
     recipe, with the difference being that the frontend form interacts
    
    <a id="_idIndexMarker231">
    </a>
    
     with the backend via an HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     request that sends a JSON representation of the form data.
    
    
     The client frontend interacting with the backend server via JSON is typical of modern
    
    
     
      web architectures.
     
    
   </p>
   <h2 id="_idParaDest-121">
    <a id="_idTextAnchor120">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <em class="italic">
      
       Chapters 3
      
     </em>
     
      ,
     
     <em class="italic">
      
       6
      
     </em>
     
      ,
     
     
      
       and
      
     
     
      <em class="italic">
       
        11
       
      </em>
     
    </li>
   </ul>
   <h1 id="_idParaDest-122">
    <a id="_idTextAnchor121">
    </a>
    
     Handling file uploads
    
   </h1>
   <p>
    
     Uploading a file to
    
    <a id="_idIndexMarker232">
    </a>
    
     the web is a common activity, be it an image, a video, or a document.
    
    
     Files require different handling compared to simple
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     data.
    
    
     Browsers embed files being uploaded into
    
    
     
      multipart messages.
     
    
   </p>
   <p>
    
     Multipart messages allow multiple pieces of content to be combined into one payload.
    
    
     To handle multipart messages, we need to use a
    
    
     
      multipart parser.
     
    
   </p>
   <p>
    
     In this recipe, we will use the
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     module as our multipart parser to handle file uploads.
    
    
     The file uploads in this recipe will be stored
    
    
     
      on disk.
     
    
   </p>
   <h2 id="_idParaDest-123">
    <a id="_idTextAnchor122">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     To get started, let’s set up the foundation for our file
    
    
     
      upload recipe.
     
    
   </p>
   <ol>
    <li>
     
      First, let’s create a new folder called
     
     <strong class="source-inline">
      
       file-upload
      
     </strong>
     
      and create a
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir file-upload</strong>
<strong class="bold">$ cd file-upload</strong>
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      As we will be using a
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      module for this recipe, we need to initialize
     
     
      
       our project:
      
     
     <pre class="source-code">
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
    <li>
     
      We will also need to create two subdirectories: one named
     
     <strong class="source-inline">
      
       public
      
     </strong>
     
      to store our HTML form and another named
     
     <strong class="source-inline">
      
       uploads
      
     </strong>
     
      to store our
     
     
      
       uploaded files:
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir public</strong>
<strong class="bold">$ mkdir uploads</strong></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-124">
    <a id="_idTextAnchor123">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will create a server that can handle file uploads and store the files on
    
    
     
      the server.
     
    
   </p>
   <ol>
    <li>
     
      First, we should create an HTML form with a file input field.
     
     
      Create a file named
     
     <strong class="source-inline">
      
       form.html
      
     </strong>
     
      inside the
     
     <strong class="source-inline">
      
       public
      
     </strong>
     
      directory.
     
     
      Add the following content
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        form.html
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
&lt;form method="POST" enctype="multipart/form-data"&gt;
    &lt;label for="userfile"&gt;File:&lt;/label&gt;
    &lt;input type="file" id="userfile"
      name="userfile"&gt;&lt;br&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;</pre>
    </li>
    <li>
     
      Now, we should install our multipart parser
     
     
      
       module,
      
     
     
      <strong class="source-inline">
       
        formidable
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ npm install formidable</strong></pre>
    </li>
    <li>
     
      Now, we can start creating our server.
     
     
      In
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      , we will import the required modules
     
     <a id="_idIndexMarker233">
     </a>
     
      and create a variable to store the path to our
     
     
      <strong class="source-inline">
       
        form.html
       
      </strong>
     
     
      
       file:
      
     
     <pre class="source-code">
const fs = require('node:fs');
const http = require('node:http');
const path = require('node:path');
const form = fs.readFileSync(path.join(__dirname,
  'public', 'form.html'));
const { formidable } = require('formidable');</pre>
    </li>
    <li>
     
      Next, we’ll create our server with handlers for
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      requests.
     
     
      This is like the server we built in the
     
     <em class="italic">
      
       Receiving HTTP POST
      
     </em>
     
      <em class="italic">
       
        requests
       
      </em>
     
     
      
       recipe:
      
     
     <pre class="source-code">
http
  .createServer((req, res) =&gt; {
    if (req.method === 'GET') {
      get(res);
      return;
    }
    if (req.method === 'POST') {
      post(req, res);
      return;
    }
    error(405, res);
  })
 .listen(3000, () =&gt; {
    console.log('Server listening on
      http://localhost:3000');
  });
function get (res) {
  res.writeHead(200, {
    'Content-Type': 'text/html'
  });
  res.end(form);
}
function error (code, res) {
  res.statusCode = code;
  res.end(http.STATUS_CODES[code]);
}</pre>
    </li>
    <li>
     
      Now, we’ll add our
     
     <strong class="source-inline">
      
       post()
      
     </strong>
     
      function.
     
     
      This function will handle
     
     
      
       file uploads:
      
     
     <pre class="source-code">
function post (req, res) {
  if (!/multipart\/form-
    data/.test(req.headers['content-type'])) {
      error(415, res);
      return;
  }
  const form = formidable({
    keepExtensions: true,
    uploadDir: './uploads'
  });
  form.parse(req, (err, fields, files) =&gt; {
    if (err) return error(400, err);
    res.writeHead(200, {
      'Content-Type': 'application/json'
    });
    res.end(JSON.stringify({ fields, files }));
  });
}</pre>
    </li>
    <li>
     
      Start the server
     
     <a id="_idIndexMarker234">
     </a>
     
      and navigate to
     
     <strong class="source-inline">
      
       http://localhost:3000
      
     </strong>
     
      in
     
     
      
       your browser:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
Server listening on http://localhost:3000</pre>
    </li>
    <li>
     
      Click the button to upload a file (it could be named
     
     <strong class="bold">
      
       Choose File
      
     </strong>
     
      ,
     
     <strong class="bold">
      
       Browse
      
     </strong>
     
      , or similar, depending on your browser and/or operating system) and select any file to upload in your File Explorer.
     
     
      You should see the file indicate it has been selected.
     
     
      Submit the file.
     
     
      Your server should have successfully received and stored the file and
     
     <a id="_idIndexMarker235">
     </a>
     
      responded with data about the stored file in
     
     
      
       JSON format:
      
     
     <pre class="source-code">
{
  "fields": {
  },
  "files": {
    "userfile": [
      {
        "size": 21,
        "filepath": "/Users/beth/Node.js-
Cookbook/Chapter04/file-upload/uploads/ac36e936ec65f3b0699442f00.txt",
        "newFilename":
           "ac36e936ec65f3b0699442f00.txt",
        "mimetype": "text/plain",
        "mtime": "2024-04-15T02:52:18.886Z",
        "originalFilename": "file.txt"
      }
    ]
  }
}</pre>
    </li>
    <li>
     
      If we list out the contents of the
     
     <strong class="source-inline">
      
       uploads
      
     </strong>
     
      directory, we should see the
     
     
      
       uploaded file:
      
     
     <pre class="source-code">
<strong class="bold">$ ls uploads</strong>
ac36e936ec65f3b0699442f00.txt</pre>
    </li>
   </ol>
   <p>
    
     We’ve created a server that can handle file uploads and tested this by uploading a file through
    
    
     
      our browser.
     
    
   </p>
   <h2 id="_idParaDest-125">
    <a id="_idTextAnchor124">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the first step in the recipe, we set up an HTML form with a file input.
    
    
     The
    
    <strong class="source-inline">
     
      enctype="multipart/form-data"
     
    </strong>
    
     property on the form element instructs the browser to set the
    
    <strong class="source-inline">
     
      Content-Type
     
    </strong>
    
     header of the request to
    
    <strong class="source-inline">
     
      multipart/form-data
     
    </strong>
    
     .
    
    
     This also instructs the browser to embed the files to be uploaded into a
    
    
     
      multipart message.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      post()
     
    </strong>
    
     function
    
    <a id="_idIndexMarker236">
    </a>
    
     checks that the
    
    <strong class="source-inline">
     
      Content-Type
     
    </strong>
    
     header is set to
    
    <strong class="source-inline">
     
      multipart/form-data
     
    </strong>
    
     .
    
    
     If this header isn’t set, we call our error function and return a
    
    <strong class="source-inline">
     
      415
     
    </strong>
    
     HTTP status code with the message
    
    <strong class="source-inline">
     
      Unsupported
     
    </strong>
    
     <strong class="source-inline">
      
       Media Type
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Within the
    
    <strong class="source-inline">
     
      post()
     
    </strong>
    
     function, we initialized a
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     object with configuration options and assigned it to a constant
    
    
     
      named
     
    
    
     <strong class="source-inline">
      
       form
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
  const form = formidable({
    keepExtensions: true,
    uploadDir: './uploads'
  });</pre>
   <p>
    
     The first configuration option,
    
    <strong class="source-inline">
     
      keepExtensions:true
     
    </strong>
    
     , instructs
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     to preserve the file extension of the file being uploaded.
    
    
     The
    
    <strong class="source-inline">
     
      uploadDir
     
    </strong>
    
     option is used to instruct
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     where the uploaded files should be stored, and in the case of our recipe, we set this to the
    
    
     <strong class="source-inline">
      
       uploads
      
     </strong>
    
    
     
      directory.
     
    
   </p>
   <p>
    
     Next, we call the
    
    <strong class="source-inline">
     
      form.parse()
     
    </strong>
    
     function.
    
    
     This function parses the request and collects the form data within the request.
    
    
     The parsed form data is passed to our callback function as an array of fields and an array
    
    
     
      of files.
     
    
   </p>
   <p>
    
     Within our
    
    <strong class="source-inline">
     
      form.parse()
     
    </strong>
    
     callback function, we first check if any errors occurred during the
    
    <strong class="source-inline">
     
      form.parse()
     
    </strong>
    
     function and return an error if there was one.
    
    
     Assuming the form data was successfully parsed, we return our response to the request, which is an HTTP status code 200,
    
    <strong class="source-inline">
     
      OK
     
    </strong>
    
     .
    
    
     We also return the information
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     provides by default about our uploaded file, in a string representation of the
    
    
     
      JSON format.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     library in Node.js uses random filenames when uploading files to prevent conflicts.
    
    
     Assigning unique names helps to avoid issues such as file overwriting, where multiple users might upload files with the same name, potentially replacing existing data.
    
    
     This method also helps mitigate security risks associated with user input by preventing deliberate attempts to overwrite sensitive files or predict and access files on
    
    
     
      the server.
     
    
   </p>
   <p>
    
     This recipe demonstrates how community modules such as
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     can do the heavy lifting and handle complex, but common, problems.
    
    
     In this instance, it saved us from writing a multipart parser from scratch.
    
    
     Refer to the
    
    <em class="italic">
     
      Consuming Node.js modules
     
    </em>
    
     recipe of
    
    <a href="B19212_05.xhtml#_idTextAnchor139">
     
      <em class="italic">
       
        Chapter 5
       
      </em>
     
    </a>
    
     for considerations that you should make when selecting which modules to
    
    <a id="_idIndexMarker237">
    </a>
    
     include in
    
    
     
      your applications.
     
    
   </p>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Allowing the upload of any file type of any size makes your server vulnerable to
    
    <strong class="bold">
     
      Denial-of-Service
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DoS
     
    </strong>
    
     ) attacks.
    
    
     Attackers
    
    <a id="_idIndexMarker238">
    </a>
    
     could purposely try to upload excessively large or malicious files to slow down your server.
    
    
     It is recommended that you add both client-side and server-side validation to restrict the file types and sizes that your server
    
    
     
      will accept.
     
    
   </p>
   <h2 id="_idParaDest-126">
    <a id="_idTextAnchor125">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In this recipe, we have seen how to handle a simple form containing just one file input.
    
    
     Now, let’s look at how we can handle the uploading of multiple files at a time and how we handle other types of form data alongside uploading
    
    
     
      a file.
     
    
   </p>
   <h3>
    
     Uploading multiple files
    
   </h3>
   <p>
    
     In some cases, you
    
    <a id="_idIndexMarker239">
    </a>
    
     may want to upload multiple files
    
    <a id="_idIndexMarker240">
    </a>
    
     to a server at the same time.
    
    
     Conveniently, with
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     , this is supported by default.
    
    
     We just need to make one change to our
    
    <strong class="source-inline">
     
      form.html
     
    </strong>
    
     file, which is to add the
    
    <strong class="source-inline">
     
      multiple
     
    </strong>
    
     attribute to the
    
    
     
      input element:
     
    
   </p>
   <pre class="source-code">
&lt;form method="POST" enctype="multipart/form-data"&gt;
    &lt;label for="userfile"&gt;File:&lt;/label&gt;
    &lt;input type="file" id="userfile" name="userfile"
      multiple&gt;&lt;br&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;</pre>
   <p>
    
     Start the server with
    
    <strong class="source-inline">
     
      node server.js
     
    </strong>
    
     and navigate to
    
    <strong class="source-inline">
     
      http://localhost:3000
     
    </strong>
    
     .
    
    
     Now, when you click
    
    <strong class="bold">
     
      Upload
     
    </strong>
    
     , you should be able to select multiple files to upload.
    
    
     On macOS, to select multiple files, you can hold the
    
    <em class="italic">
     
      Shift
     
    </em>
    
     key and select multiple files.
    
    
     Then, upon submitting multiple files,
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     will return data about each
    
    <a id="_idIndexMarker241">
    </a>
    
     of the files uploaded.
    
    
     Expect to
    
    <a id="_idIndexMarker242">
    </a>
    
     see JSON output returned that is like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
{
  "fields": {},
  "files": {
    "userfile": [
      {
        "size": 334367,
        "filepath": "/Users/beth/Node.js-Cookbook/Chapter04/file-upload/uploads/8bcdb0be88a49a8e1aec95e00.jpg",
        "newFilename":
          "8bcdb0be88a49a8e1aec95e00.jpg",
        "mimetype": "image/jpeg",
        "mtime": "2024-04-15T02:57:23.589Z",
        "originalFilename": "photo.jpg"
      },
      {
        "size": 21,
        "filepath": "/Users/beth/Node.js-Cookbook/Chapter04/file-upload/uploads/8bcdb0be88a49a8e1aec95e01.txt",
        "newFilename":
          "8bcdb0be88a49a8e1aec95e01.txt",
        "mimetype": "text/plain",
        "mtime": "2024-04-15T02:57:23.589Z",
        "originalFilename": "file.txt"
      }
    ]
  }
}</pre>
   <h3>
    
     Processing multiple input types
    
   </h3>
   <p>
    
     It’s common
    
    <a id="_idIndexMarker243">
    </a>
    
     for a form
    
    <a id="_idIndexMarker244">
    </a>
    
     to contain a mixture of input types.
    
    
     On top of the file input type, it could contain text, a password, a date, or more input types.
    
    
     The
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     module handles mixed
    
    
     
      data types.
     
    
   </p>
   <p class="callout-heading">
    
     HTML input element
    
   </p>
   <p class="callout">
    
     For a full list of input types defined, refer to the MDN web documentation
    
    
     
      at
     
    
    <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input">
     
      
       https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Let’s extend the HTML form created in the recipe to contain some additional text input fields to demonstrate how
    
    <strong class="source-inline">
     
      formidable
     
    </strong>
    
     handles multiple
    
    
     
      input types.
     
    
   </p>
   <p>
    
     First, let’s add a text input to our
    
    
     <strong class="source-inline">
      
       form.html
      
     </strong>
    
    
     
      file:
     
    
   </p>
   <pre class="source-code">
&lt;form method="POST" enctype="multipart/form-data"&gt;
    &lt;label for="user"&gt;User:&lt;/label&gt;
    &lt;input type="text" id="user" name="user"&gt;&lt;br&gt;
    &lt;label for="userfile"&gt;File:&lt;/label&gt;
    &lt;input type="file" id="userfile" name="userfile"&gt;&lt;br&gt;
    &lt;input type="submit"&gt;
&lt;/form&gt;</pre>
   <p>
    
     Start the server with
    
    <strong class="source-inline">
     
      node server.js
     
    </strong>
    
     and navigate to
    
    <strong class="source-inline">
     
      http://localhost:3000
     
    </strong>
    
     .
    
    
     Insert text into the
    
    <strong class="source-inline">
     
      user
     
    </strong>
    
     field and select a file to be uploaded.
    
    
     Click
    
    
     
      on
     
    
    
     <strong class="bold">
      
       Submit
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     You will receive a JSON
    
    <a id="_idIndexMarker245">
    </a>
    
     response containing all your
    
    <a id="_idIndexMarker246">
    </a>
    
     form data, like
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
{
  "fields": { "user" : ["Beth"] },
  "files": {
    "userfile": [
      {
        "size": 21,
        "filepath": "/Users/beth/Node.js-Cookbook/Chapter04/file-upload/uploads/659d0cc8a8898fce93231aa00.txt",
        "newFilename": "659d0cc8a8898fce93231aa00.txt",
        "mimetype": "text/plain",
        "mtime": "2024-04-15T02:59:22.633Z",
        "originalFilename": "file.txt"
      }
    ]
  }
}</pre>
   <p>
    
     The field information
    
    <a id="_idIndexMarker247">
    </a>
    
     is automatically handled by the
    
    <strong class="source-inline">
     
      form.parse()
     
    </strong>
    
     function, making the fields accessible to
    
    
     
      the server.
     
    
   </p>
   <h2 id="_idParaDest-127">
    <a id="_idTextAnchor126">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <em class="italic">
      
       Chapters 5
      
     </em>
     
      ,
     
     <em class="italic">
      
       6
      
     </em>
     
      ,
     
     
      
       and
      
     
     
      <em class="italic">
       
        9
       
      </em>
     
    </li>
   </ul>
   <h1 id="_idParaDest-128">
    <a id="_idTextAnchor127">
    </a>
    
     Creating a WebSocket server
    
   </h1>
   <p>
    
     The
    
    <strong class="bold">
     
      WebSocket protocol
     
    </strong>
    
     enables
    
    <a id="_idIndexMarker248">
    </a>
    
     two-way communication between a browser and a server.
    
    
     WebSockets are commonly leveraged for building real-time web applications, such as instant
    
    
     
      messaging clients.
     
    
   </p>
   <p>
    
     In this recipe, we’re going to use the third-party
    
    <strong class="source-inline">
     
      ws
     
    </strong>
    
     module to create a WebSocket server that we can interact with via
    
    
     
      our browser.
     
    
   </p>
   <h2 id="_idParaDest-129">
    <a id="_idTextAnchor128">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     First, we need to prepare our project directory with the necessary files for
    
    
     
      the recipe.
     
    
   </p>
   <ol>
    <li>
     
      Start by creating a directory named
     
     <strong class="source-inline">
      
       websocket-server
      
     </strong>
     
      containing two files – one named
     
     <strong class="source-inline">
      
       client.js
      
     </strong>
     
      and another
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir websocket-server</strong>
<strong class="bold">$ cd websocket-server</strong>
<strong class="bold">$ touch client.js</strong>
<strong class="bold">$ touch server.js</strong></pre>
    </li>
    <li>
     
      Also, for our client, let’s create a public directory containing a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        index.html
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ mkdir public</strong>
<strong class="bold">$ touch public/index.html</strong></pre>
    </li>
    <li>
     
      As we will be using a third-party
     
     <strong class="source-inline">
      
       npm
      
     </strong>
     
      module, we also need to initialize
     
     
      
       our project:
      
     
     <pre class="source-code">
<strong class="bold">$ npm init --yes</strong></pre>
    </li>
   </ol>
   <h2 id="_idParaDest-130">
    <a id="_idTextAnchor129">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we’re going to create a WebSocket server and a client and send messages between
    
    
     
      the two.
     
    
   </p>
   <ol>
    <li>
     
      Start by installing the
     
     
      <strong class="source-inline">
       
        ws
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install ws</strong></pre>
    </li>
    <li>
     
      Import the
     
     <strong class="source-inline">
      
       ws
      
     </strong>
     
      module
     
     
      
       in
      
     
     
      <strong class="source-inline">
       
        server.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const WebSocket = require('ws');</pre>
    </li>
    <li>
     
      Now, we can define our
     
     <strong class="source-inline">
      
       WebSocketServer
      
     </strong>
     
      instance, including which port it should be
     
     
      
       accessible at:
      
     
     <pre class="source-code">
const WebSocketServer = new WebSocket.Server({
  port: 3000
});</pre>
    </li>
    <li>
     
      We need to listen
     
     <a id="_idIndexMarker249">
     </a>
     
      for connections and messages to our
     
     
      <strong class="source-inline">
       
        WebSocketServer
       
      </strong>
     
     
      
       instance:
      
     
     <pre class="source-code">
WebSocketServer.on('connection', (socket) =&gt; {
  socket.on('message', (msg) =&gt; {
    console.log('Received:', msg.toString());
    if (msg.toString() === 'Hello')
      socket.send('World!');
  });
});</pre>
    </li>
    <li>
     
      Now, let’s create our client.
     
     
      Add the following
     
     
      
       to
      
     
     
      <strong class="source-inline">
       
        client.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
const fs = require('node:fs');
const http = require('node:http');
const index = fs.readFileSync('public/index.html');
const server = http.createServer((req, res) =&gt; {
  res.setHeader('Content-Type', 'text/html');
  res.end(index);
});
server.listen(8080);</pre>
    </li>
    <li>
     
      Open
     
     <strong class="source-inline">
      
       index.html
      
     </strong>
     
      and add
     
     
      
       the
      
     
     
      <a id="_idIndexMarker250">
      </a>
     
     
      
       following:
      
     
     <pre class="source-code">
&lt;h1&gt;Communicating with WebSockets&lt;/h1&gt;
&lt;input id="msg" /&gt;&lt;button id="send"&gt;Send&lt;/button&gt;
&lt;div id="output"&gt;&lt;/div&gt;
&lt;script&gt;
    const ws = new WebSocket('ws://localhost:3000');
    const output =
      document.getElementById('output');
    const send = document.getElementById('send');
    send.addEventListener('click', () =&gt; {
        const msg =
          document.getElementById('msg').value;
        ws.send(msg);
        output.innerHTML += log('Sent', msg);
    });
    function log(event, msg) {
        return '&lt;p&gt;' + event + ': ' + msg + '&lt;/p&gt;';
    }
    ws.onmessage = function (e) {
        output.innerHTML += log('Received', e.data);
    };
    ws.onclose = function (e) {
        output.innerHTML += log('Disconnected',
          e.code);
    };
    ws.onerror = function (e) {
        output.innerHTML += log('Error', e.data);
    };
&lt;/script&gt;</pre>
    </li>
    <li>
     
      Now, start your
     
     <a id="_idIndexMarker251">
     </a>
     
      server in one terminal window and your client in a second
     
     
      
       terminal window:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">$ node client.js</strong></pre>
    </li>
    <li>
     
      Access
     
     <strong class="source-inline">
      
       http://localhost:8080
      
     </strong>
     
      in your browser, and you should see a simple input box with a
     
     <strong class="bold">
      
       Submit
      
     </strong>
     
      button.
     
     
      Type
     
     <strong class="source-inline">
      
       Hello
      
     </strong>
     
      into the input box and click
     
     <strong class="bold">
      
       Submit
      
     </strong>
     
      .
     
     
      The WebSocket server should respond
     
     
      
       with
      
     
     
      <strong class="source-inline">
       
        World!
       
      </strong>
     
     
      
       .
      
     
    </li>
   </ol>
   <p>
    
     If we look at the terminal window where we are running our server, we should see that the server received the message:
    
    <strong class="source-inline">
     
      Received: Hello
     
    </strong>
    
     .
    
    
     This means that we have now got a client and server communicating
    
    
     
      over WebSockets.
     
    
   </p>
   <p>
    
     We’ve created a WebSocket server and client and demonstrated how they can exchange messages.
    
    
     Now, let’s see how
    
    
     
      it works.
     
    
   </p>
   <h2 id="_idParaDest-131">
    <a id="_idTextAnchor130">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In this recipe, we used the
    
    <strong class="source-inline">
     
      ws
     
    </strong>
    
     module to define a
    
    
     
      WebSocket server:
     
    
   </p>
   <pre class="source-code">
const WebSocketServer = new WebSocket.Server({
  port: 3000,
});</pre>
   <p>
    
     We then registered a listener for the connection event.
    
    
     The function passed to this is executed each time there is a new connection to the WebSocket.
    
    
     Within the connection event callback function, we have a socket instance in which we registered a listener for the message event, which gets executed each time a message is received on
    
    
     
      that socket.
     
    
   </p>
   <p>
    
     For our client, we defined a regular HTTP server to serve our
    
    <strong class="source-inline">
     
      index.html
     
    </strong>
    
     file.
    
    
     Our
    
    <strong class="source-inline">
     
      index.html
     
    </strong>
    
     file contains JavaScript that is executed within the browser.
    
    
     Within this JavaScript, we created a connection to our WebSocket server, providing the endpoint that the
    
    <strong class="source-inline">
     
      ws
     
    </strong>
    
     object is
    
    
     
      listening to:
     
    
   </p>
   <pre class="source-code">
    const ws = new WebSocket('ws://localhost:3000');</pre>
   <p>
    
     To send a message to our
    
    <a id="_idIndexMarker252">
    </a>
    
     WebSocket server, we just call
    
    <strong class="source-inline">
     
      send
     
    </strong>
    
     on the
    
    <strong class="source-inline">
     
      ws
     
    </strong>
    
     object
    
    
     
      with
     
    
    
     <strong class="source-inline">
      
       ws.send(msg)
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     We wrapped the
    
    <strong class="source-inline">
     
      ws.send(msg)
     
    </strong>
    
     in an event listener.
    
    
     The event listener was listening for the “click” event on the
    
    <strong class="bold">
     
      Submit
     
    </strong>
    
     button, meaning that we would send the message to the WebSocket when the
    
    <strong class="bold">
     
      Submit
     
    </strong>
    
     button
    
    
     
      was clicked.
     
    
   </p>
   <p>
    
     In our script in
    
    <strong class="source-inline">
     
      index.html
     
    </strong>
    
     , we registered event listener functions on our WebSocket, including
    
    <strong class="source-inline">
     
      onmessage
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      onclose
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      onerror
     
    </strong>
    
     
      event listeners:
     
    
   </p>
   <pre class="source-code">
    ws.onmessage = function (e) {
        output.innerHTML += log('Received', e.data);
    };
    ws.onclose = function (e) {
        output.innerHTML += log('Disconnected', e.code);
    };
    ws.onerror = function (e) {
        output.innerHTML += log('Error', e.data);
    };</pre>
   <p>
    
     These functions execute on their respective events.
    
    
     For example, the
    
    <strong class="source-inline">
     
      onmessage()
     
    </strong>
    
     event listener function would execute when our WebSocket receives a message.
    
    
     We use these event listeners to add output to our web page according to
    
    
     
      the event.
     
    
   </p>
   <h2 id="_idParaDest-132">
    <a id="_idTextAnchor131">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Now, we’ve learned
    
    <a id="_idIndexMarker253">
    </a>
    
     how we can communicate between a browser and a server using WebSockets.
    
    
     But it is also possible to create a WebSocket client in Node.js, enabling two Node.js programs to communicate over WebSockets using the
    
    
     
      following steps:
     
    
   </p>
   <ol>
    <li>
     
      Start by creating a new file within our
     
     <strong class="source-inline">
      
       websocket-server
      
     </strong>
     
      directory,
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        node-client.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch node-client.js</strong></pre>
    </li>
    <li>
     
      Import the
     
     <strong class="source-inline">
      
       ws
      
     </strong>
     
      module and create a new WebSocket object that is configured to point to the WebSocket server we created in the
     
     <em class="italic">
      
       Creating a WebSocket
      
     </em>
     
      <em class="italic">
       
        server
       
      </em>
     
     
      
       recipe:
      
     
     <pre class="source-code">
const WebSocket = require('ws');
const ws = new WebSocket('ws://localhost:3000');</pre>
    </li>
    <li>
     
      Now, we’ll set up some listeners on our sockets.
     
     
      We will add listeners for the
     
     <strong class="source-inline">
      
       open
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       close
      
     </strong>
     
      , and
     
     
      <strong class="source-inline">
       
        message
       
      </strong>
     
     
      
       events:
      
     
     <pre class="source-code">
ws.on('open', () =&gt; {
  console.log('Connected');
});
ws.on('close', () =&gt; {
  console.log('Disconnected');
});
ws.on('message', (message) =&gt; {
  console.log('Received:', message.toString());
});</pre>
    </li>
    <li>
     
      Now, let’s send a
     
     <strong class="source-inline">
      
       'Hello'
      
     </strong>
     
      message to the WebSocket server every 3 seconds.
     
     
      We will use the
     
     <strong class="source-inline">
      
       setInterval()
      
     </strong>
     
      function to
     
     
      
       achieve this:
      
     
     <pre class="source-code">
setInterval(() =&gt; {
  ws.send('Hello');
}, 3000);</pre>
    </li>
    <li>
     
      Start both the
     
     <a id="_idIndexMarker254">
     </a>
     
      WebSocket server and your Node.js-based client in separate
     
     
      
       terminal windows:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">$ node node-client.js</strong></pre>
    </li>
    <li>
     
      You should expect to see the server responding every 3 seconds to your
     
     <strong class="source-inline">
      
       'Hello'
      
     </strong>
     
      message with the
     
     
      <strong class="source-inline">
       
        World!
       
      </strong>
     
     
      
       message:
      
     
     <pre class="source-code">
Connected
Received: World!
Received: World!
Received: World!</pre>
    </li>
   </ol>
   <p>
    
     You’ve now created a WebSocket communication between two
    
    
     
      Node.js programs.
     
    
   </p>
   <h2 id="_idParaDest-133">
    <a id="_idTextAnchor132">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     
      The
     
     <em class="italic">
      
       Interfacing with standard I/O
      
     </em>
     
      recipe in
     
     <a href="B19212_02.xhtml#_idTextAnchor041">
      
       <em class="italic">
        
         Chapter 2
        
       </em>
      
     </a>
    </li>
    <li>
     
      The
     
     <em class="italic">
      
       Communicating with sockets
      
     </em>
     
      recipe in
     
     <a href="B19212_02.xhtml#_idTextAnchor041">
      
       <em class="italic">
        
         Chapter 2
        
       </em>
      
     </a>
    </li>
    <li>
     <a href="B19212_06.xhtml#_idTextAnchor178">
      
       <em class="italic">
        
         Chapter 6
        
       </em>
      
     </a>
    </li>
   </ul>
   <h1 id="_idParaDest-134">
    <a id="_idTextAnchor133">
    </a>
    
     Creating an SMTP server
    
   </h1>
   <p>
    <strong class="bold">
     
      SMTP
     
    </strong>
    
     is a protocol
    
    <a id="_idIndexMarker255">
    </a>
    
     for sending emails.
    
    
     In this recipe, we will be setting up an SMTP server using a third-party
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     module
    
    
     
      named
     
    
    
     <strong class="source-inline">
      
       smtp-server
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     You probably receive several automated emails per day in your inbox.
    
    
     In the
    
    <em class="italic">
     
      There’s more…
     
    </em>
    
     section, we’re going to learn how we can send an email via Node.js to the SMTP server we created in
    
    
     
      the recipe.
     
    
   </p>
   <h2 id="_idParaDest-135">
    <a id="_idTextAnchor134">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     First, let’s create a directory named
    
    <strong class="source-inline">
     
      server-smtp
     
    </strong>
    
     and a file
    
    
     
      named
     
    
    
     <strong class="source-inline">
      
       server.js
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="console">
$ mkdir server-smtp
$ cd server-smtp
$ touch server.js</pre>
   <p>
    
     As we’ll be using the third-party
    
    <strong class="source-inline">
     
      smtp-server
     
    </strong>
    
     module from
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     , we will need to initialize
    
    
     
      our project:
     
    
   </p>
   <pre class="console">
$ npm init --yes</pre>
   <p class="callout-heading">
    
     Important note
    
   </p>
   <p class="callout">
    
     Note that we could not name our directory for this recipe
    
    <strong class="source-inline">
     
      smtp-server
     
    </strong>
    
     as
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     refuses to allow you to install a module where the project name is the same as the module.
    
    
     If we had named our directory
    
    <strong class="source-inline">
     
      smtp-server
     
    </strong>
    
     , our
    
    <strong class="source-inline">
     
      package.json
     
    </strong>
    
     name would have also been set to
    
    <strong class="source-inline">
     
      smtp-server
     
    </strong>
    
     , and we would not be able to install the module with the
    
    
     
      same name.
     
    
   </p>
   <h2 id="_idParaDest-136">
    <a id="_idTextAnchor135">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     In this recipe, we will be creating an SMTP server that can receive email messages.
    
    
     We will use the
    
    <strong class="source-inline">
     
      smtp-server
     
    </strong>
    
     module to
    
    
     
      achieve this.
     
    
   </p>
   <ol>
    <li>
     
      First, start by installing the
     
     
      <strong class="source-inline">
       
        smtp-server
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install smtp-server</strong></pre>
    </li>
    <li>
     
      Next, we need to open
     
     <strong class="source-inline">
      
       server.js
      
     </strong>
     
      and import the
     
     
      <strong class="source-inline">
       
        server-smtp
       
      </strong>
     
     
      
       module:
      
     
     <pre class="source-code">
const SMTPServer = require('smtp-
  server').SMTPServer;</pre>
    </li>
    <li>
     
      Let’s define the port that our SMTP server should be
     
     
      
       accessible at:
      
     
     <pre class="source-code">
const PORT = 4321;</pre>
    </li>
    <li>
     
      Now, we’ll create
     
     <a id="_idIndexMarker256">
     </a>
     
      an SMTP
     
     
      
       server object:
      
     
     <pre class="source-code">
const server = new SMTPServer({
  disabledCommands: ['STARTTLS', 'AUTH'],
  logger: true
});</pre>
    </li>
    <li>
     
      We should also catch any errors.
     
     
      Register an error event listener function on the
     
     
      
       server object:
      
     
     <pre class="source-code">
server.on('error', (err) =&gt; {
  console.error(err);
});</pre>
    </li>
    <li>
     
      Finally, we can call the
     
     <strong class="source-inline">
      
       listen()
      
     </strong>
     
      function to start our
     
     
      
       SMTP server:
      
     
     <pre class="source-code">
server.listen(PORT);</pre>
    </li>
    <li>
     
      Start your
     
     
      
       SMTP server:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong>
<strong class="bold">[2020-04-27 21:57:51] INFO  SMTP Server listening on [::]:4321</strong></pre>
    </li>
    <li>
     
      You can test a connection to your server by using either the
     
     <strong class="source-inline">
      
       nc
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       telnet
      
     </strong>
     
      command-line tools in a
     
     
      
       new terminal:
      
     
     <pre class="source-code">
<strong class="bold">$ telnet localhost 4321</strong>
<strong class="bold">$ nc -c localhost 4321</strong></pre>
    </li>
   </ol>
   <p>
    
     We’ve now confirmed that our SMTP server is available and listening on
    
    
     
      port
     
    
    
     <strong class="source-inline">
      
       4321
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-137">
    <a id="_idTextAnchor136">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In the recipe, we
    
    <a id="_idIndexMarker257">
    </a>
    
     leveraged the
    
    <strong class="source-inline">
     
      smtp-server
     
    </strong>
    
     module.
    
    
     This module takes care of the implementation of the SMTP protocol, meaning we can focus on the logic of our program rather than lower-level
    
    
     
      implementation details.
     
    
   </p>
   <p>
    
     The
    
    <strong class="source-inline">
     
      smtp-server
     
    </strong>
    
     module provides high-level APIs.
    
    
     In the recipe, we used the following to create a new SMTP
    
    
     
      server object:
     
    
   </p>
   <pre class="source-code">
const server = new SMTPServer({
  disabledCommands: ['STARTTLS', 'AUTH'],
  logger: true
});</pre>
   <p>
    
     The constructor of the
    
    <strong class="source-inline">
     
      SMTPServer
     
    </strong>
    
     object accepts many parameters.
    
    
     A full list of options that can be passed to the
    
    <strong class="source-inline">
     
      SMTPServer
     
    </strong>
    
     constructor is available in the
    
    <strong class="source-inline">
     
      nodemailer
     
    </strong>
    
     documentation
    
    
     
      at
     
    
    <a href="https://nodemailer.com/extras/smtp-server/">
     
      
       https://nodemailer.com/extras/smtp-server/
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     In this recipe, we added the
    
    <strong class="source-inline">
     
      disabledCommands: ['STARTTLS', 'AUTH']
     
    </strong>
    
     option.
    
    
     This option disabled
    
    <strong class="bold">
     
      Transport Layer Security
     
    </strong>
    
     (
    
    <strong class="bold">
     
      TLS
     
    </strong>
    
     ) support and authentication for simplicity.
    
    
     However, in production, it would not be recommended to disable TLS support and authentication.
    
    
     Instead, it would be recommended to enforce TLS.
    
    
     You can do this with the
    
    <strong class="source-inline">
     
      smtp-server
     
    </strong>
    
     module by specifying the
    
    
     <strong class="source-inline">
      
       secure:true
      
     </strong>
    
    
     
      option.
     
    
   </p>
   <p>
    
     Should you wish to enforce TLS for the connection, you would also need to define a private key and a certificate.
    
    
     If no certificate is provided, then the module will generate a self-signed certificate; however, many clients reject
    
    
     
      these certificates.
     
    
   </p>
   <p>
    
     The second option we specify on the
    
    <strong class="source-inline">
     
      SMTPServer
     
    </strong>
    
     constructor is the
    
    <strong class="source-inline">
     
      logger:true
     
    </strong>
    
     option, which enables logging from our
    
    
     
      SMTP server.
     
    
   </p>
   <p>
    
     To start our
    
    <strong class="source-inline">
     
      SMTPServer
     
    </strong>
    
     constructor, we call the
    
    <strong class="source-inline">
     
      listen()
     
    </strong>
    
     function on the
    
    <strong class="source-inline">
     
      SMTPServer
     
    </strong>
    
     object.
    
    
     It is possible to pass the
    
    <strong class="source-inline">
     
      listen()
     
    </strong>
    
     function a port, a hostname, and a callback function.
    
    
     In this case, we only provide the port; the hostname will default
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       localhost
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-138">
    <a id="_idTextAnchor137">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Now that we’ve set up
    
    <a id="_idIndexMarker258">
    </a>
    
     a simple SMTP server, we should try sending an email to it
    
    
     
      via Node.js.
     
    
   </p>
   <p>
    
     To send an email with Node.js, we can use the
    
    <strong class="source-inline">
     
      nodemailer
     
    </strong>
    
     module from
    
    <strong class="source-inline">
     
      npm
     
    </strong>
    
     .
    
    
     This module is provided by the same organization as the
    
    <strong class="source-inline">
     
      smtp-server
     
    </strong>
    
     module used in the
    
    <em class="italic">
     
      Creating an SMTP
     
    </em>
    
     <em class="italic">
      
       server
      
     </em>
    
    
     
      recipe.
     
    
   </p>
   <ol>
    <li>
     
      Let’s start by installing the
     
     <strong class="source-inline">
      
       nodemailer
      
     </strong>
     
      module in our
     
     
      <strong class="source-inline">
       
        server-smtp
       
      </strong>
     
     
      
       directory:
      
     
     <pre class="source-code">
<strong class="bold">$ npm install nodemailer</strong></pre>
    </li>
    <li>
     
      Next, we’ll create a file
     
     
      
       named
      
     
     
      <strong class="source-inline">
       
        send-email.js
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">$ touch send-email.js</strong></pre>
    </li>
    <li>
     
      The first line of code we need to add to our
     
     <strong class="source-inline">
      
       send-email.js
      
     </strong>
     
      file to import the
     
     <strong class="source-inline">
      
       nodemailer
      
     </strong>
     
      module is
     
     
      
       the following:
      
     
     <pre class="source-code">
const nodemailer = require('nodemailer');</pre>
    </li>
    <li>
     
      Next, we need to set up the transport object; we will configure the
     
     <strong class="source-inline">
      
       transporter
      
     </strong>
     
      object to connect to the SMTP server we created in the
     
     <em class="italic">
      
       Creating an SMTP
      
     </em>
     
      <em class="italic">
       
        server
       
      </em>
     
     
      
       recipe:
      
     
     <pre class="source-code">
const transporter = nodemailer.createTransport({
  host: 'localhost',
  port: 4321,
});</pre>
    </li>
    <li>
     
      Next, we can call the
     
     <strong class="source-inline">
      
       sendMail()
      
     </strong>
     
      function on the
     
     
      <strong class="source-inline">
       
        transporter
       
      </strong>
     
     
      
       object:
      
     
     <pre class="source-code">
transporter.sendMail(
  {
    from: 'beth@example.com',
    to: 'laddie@example.com',
    subject: 'Hello',
    text: 'Hello world!',
  },
  (err, info) =&gt; {
    if (err) {
      console.log(err);
    }
    console.log("Message Sent:", info);
  }
);</pre>
     <p class="list-inset">
      
       The first parameter of the
      
      <strong class="source-inline">
       
        sendMail()
       
      </strong>
      
       function is an object representing the email, including the email address of the sender and receiver, the subject line, and the text of the
      
      <a id="_idIndexMarker259">
      </a>
      
       email.
      
      
       The second parameter is a callback function that executes once the mail
      
      
       
        is sent.
       
      
     </p>
    </li>
    <li>
     
      To test our
     
     <strong class="source-inline">
      
       send-email.js
      
     </strong>
     
      program, first start the
     
     
      
       SMTP server:
      
     
     <pre class="source-code">
<strong class="bold">$ node server.js</strong></pre>
    </li>
    <li>
     
      In a second terminal window, run your
     
     
      <strong class="source-inline">
       
        send-email.js
       
      </strong>
     
     
      
       program:
      
     
     <pre class="source-code">
<strong class="bold">$ node send-email.js</strong></pre>
    </li>
    <li>
     
      You should expect to see the following output from
     
     
      
       the server:
      
     
     <pre class="source-code">
<strong class="bold">[2020-04-27 23:05:44] INFO  [#cifjnbwdwbhcf54a] Connection from [127.0.0.1]</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] S: 220 Beths-MBP.lan ESMTP</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] C: EHLO Beths-MBP.lan</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] S: 250-Beths-MBP.lan Nice to meet you, [127.0.0.1]</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] 250-PIPELINING</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] 250-8BITMIME</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] 250 SMTPUTF8</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] C: MAIL FROM:&lt;beth@example.com&gt;</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] S: 250 Accepted</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] C: RCPT TO:&lt;laddie@example.com&gt;</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] S: 250 Accepted</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] C: DATA</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] S: 354 End data with &lt;CR&gt;&lt;LF&gt;.&lt;CR&gt;&lt;LF&gt;</strong>
<strong class="bold">[2020-04-27 23:05:44] INFO  &lt;received 261 bytes&gt;</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] C: &lt;261 bytes of DATA&gt;</strong>
<strong class="bold">[2020-04-27 23:05:44] DEBUG [#cifjnbwdwbhcf54a] S: 250 OK: message queued</strong>
<strong class="bold">[2020-04-27 23:05:44] INFO  [#cifjnbwdwbhcf54a] Connection closed to [127.0.0.1]</strong></pre>
    </li>
    <li>
     
      You should see the output like the following from the
     
     
      <strong class="source-inline">
       
        send-email.js
       
      </strong>
     
     
      
       program:
      
     
     <pre class="source-code">
Message Sent: { accepted: [ 'laddie@example.com' ],
  rejected: [],
  ehlo: [ 'PIPELINING', '8BITMIME', 'SMTPUTF8' ],
  envelopeTime: 4,
  messageTime: 2,
  messageSize: 279,
  response: '250 OK: message queued',
  envelope: { from: 'beth@example.com', to: [
    'laddie@example.com' ] },
  messageId: '&lt;fde460ce-f83a-95e2-5f8a-
    76dd11f6e61f@example.com&gt;' }</pre>
    </li>
   </ol>
   <p>
    
     This shows that we have
    
    <a id="_idIndexMarker260">
    </a>
    
     successfully created an SMTP server, and we’re able to send emails to the SMTP server from another
    
    
     
      Node.js program.
     
    
   </p>
   <h2 id="_idParaDest-139">
    <a id="_idTextAnchor138">
    </a>
    
     See also
    
   </h2>
   <ul>
    <li>
     <em class="italic">
      
       Chapters 5
      
     </em>
     
      
       and
      
     
     
      <em class="italic">
       
        9
       
      </em>
     
    </li>
   </ul>
  </div>
 </body></html>