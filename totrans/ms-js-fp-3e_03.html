<html><head></head><body>
		<div id="_idContainer017">
			<h1 id="_idParaDest-55" class="chapter-number"><a id="_idTextAnchor054"/>3</h1>
			<h1 id="_idParaDest-56"><a id="_idTextAnchor055"/>Starting Out with Functions – A Core Concept</h1>
			<p>In <a href="B19301_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Thinking Functionally</em>, we discussed an example of FP thinking, but now, let’s look at the basics and <span class="No-Break">review functions.</span></p>
			<p>In this chapter, we’ll do <span class="No-Break">the following:</span></p>
			<ul>
				<li>Discuss functions in JavaScript, including how to define them, with a particular focus on <span class="No-Break">arrow functions</span></li>
				<li>Learn about currying and functions as <span class="No-Break">first-class objects</span></li>
				<li>Explore several ways of using functions in an <span class="No-Break">FP way</span></li>
			</ul>
			<p>After going through all this content, you’ll be up to date with the generic and specific concepts relating to functions, which are, after all, at the core <span class="No-Break">of FP!</span></p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor056"/>All about functions</h1>
			<p>Let’s start with a short review of <a id="_idIndexMarker117"/>functions in JavaScript and their relationship to FP concepts. We will begin with something that we mainly mentioned in the <em class="italic">Functions as first-class objects</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><em class="italic">, Becoming Functional,</em> and again in a couple of places in <a href="B19301_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Thinking Functionally</em>, and then go on to several considerations about their usage in actual coding. In particular, we’ll be looking at <span class="No-Break">the following:</span></p>
			<ul>
				<li>Some basic concepts about lambda calculus, which is the theoretical basis <span class="No-Break">for FP</span></li>
				<li>Arrow functions, which are the most direct translation of lambda calculus <span class="No-Break">into JavaScript</span></li>
				<li>Using functions as first-class objects, a key concept <span class="No-Break">in FP</span></li>
			</ul>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor057"/>Of lambdas and functions</h2>
			<p>In lambda <a id="_idIndexMarker118"/>calculus terms, a function can look like λ<em class="italic">x</em>.2*<em class="italic">x</em>. The understanding<a id="_idIndexMarker119"/> is that the variable after the λ character (the Greek letter <em class="italic">lambda</em> in lowercase) is the parameter for the function, and the expression after the dot is where you would replace whatever value is passed as an argument. Later in this chapter, we will see that this particular example could be written as <strong class="source-inline">(x) =&gt; 2*x</strong> in JavaScript in arrow function form, which, as you can see, is <span class="No-Break">very similar.</span></p>
			<p class="callout-heading">An alliterative aid</p>
			<p class="callout">If you sometimes wonder about the difference between arguments and parameters, a mnemonic with some alliteration may help: <em class="italic">Parameters are Potential, Arguments are Actual</em>. Parameters are<a id="_idIndexMarker120"/> placeholders for potential values that will be passed, and arguments are the actual values passed to the function. In other words, when you define the function, you list its parameters, and when you call it, you <span class="No-Break">provide arguments.</span></p>
			<p>Applying a function means you provide an actual argument to it, which is written in the usual way, using parentheses. For example, (λ<em class="italic">x</em>.2*<em class="italic">x</em>)(3) would be calculated as 6. What’s the equivalent of these lambda functions in JavaScript? That’s an interesting question! There are several ways of defining functions, and not all have the <span class="No-Break">same meaning.</span></p>
			<p>In how many ways can you <a id="_idIndexMarker121"/>define a function in JavaScript? The answer is probably in more ways than you thought! (A good article that shows the many ways of defining functions, methods, and more is <em class="italic">The Many Faces of Functions in JavaScript</em>, by Leo Balter and Rick Waldron, at <a href="http://bocoup.com/blog/the-many-faces-of-functions-in-javascript">bocoup.com/blog/the-many-faces-of-functions-in-javascript</a> – give it a look!) At the very least, you could write the following – and I’ll use vanilla JavaScript because here types aren’t <span class="No-Break">a concern:</span></p>
			<ul>
				<li>A named function declaration: <strong class="source-inline">function </strong><span class="No-Break"><strong class="source-inline">first(...) {...};</strong></span></li>
				<li>An anonymous function expression: <strong class="source-inline">var second = </strong><span class="No-Break"><strong class="source-inline">function(...) {...};</strong></span></li>
				<li>A named function expression: <strong class="source-inline">var third = function </strong><span class="No-Break"><strong class="source-inline">someName(…) {...};</strong></span></li>
				<li>An immediately-invoked expression: <strong class="source-inline">var fourth = (function() { ...; return function(...) {...}; })();</strong></li>
				<li>A function constructor: <strong class="source-inline">var fifth = </strong><span class="No-Break"><strong class="source-inline">new Function(...);</strong></span></li>
				<li>An arrow function: <strong class="source-inline">var sixth = (...) =&gt; {...};</strong></li>
			</ul>
			<p>If you wanted, you <a id="_idIndexMarker122"/>could add object method declarations since they also imply functions, but the preceding list should <span class="No-Break">be enough.</span></p>
			<p class="callout-heading">More function types</p>
			<p class="callout">JavaScript also allows us to<a id="_idIndexMarker123"/> define <strong class="bold">generator</strong> functions (as in <strong class="source-inline">function*(...) {...}</strong>) that return a <strong class="source-inline">Generator</strong> object and <strong class="source-inline">async</strong> functions that are a mix of generators and <a id="_idIndexMarker124"/>promises. You can read more <a id="_idIndexMarker125"/>about them at <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/function</a> and <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function"><span class="No-Break">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function</span></a><span class="No-Break">, respectively.</span></p>
			<p>What’s the difference between all these ways of defining functions, and why should we care? Let’s go over them one <span class="No-Break">by one:</span></p>
			<ul>
				<li>The first definition, <strong class="source-inline">function first(...) {...}</strong>, a standalone declaration starting with the <strong class="source-inline">function</strong> keyword, is probably the most used in JavaScript and defines a function named <strong class="source-inline">first</strong> (that is, <strong class="source-inline">first.name==="first"</strong>). Because of <strong class="bold">hoisting</strong>, this function will be accessible everywhere in the scope where it’s <a id="_idIndexMarker126"/>defined; we’ll touch on this again later in the <em class="italic">Functions as objects</em> section. (Of course, this only happens if you use a <strong class="source-inline">var</strong> definition; with <strong class="source-inline">let</strong> or <strong class="source-inline">const</strong>, hoisting doesn’t apply. You can read more about <a id="_idIndexMarker127"/>hoisting at <a href="http://developer.mozilla.org/en-US/docs/Glossary/Hoisting">developer.mozilla.org/en-US/docs/Glossary/Hoisting</a>. Remember that it applies only to declarations,  not <span class="No-Break">to initializations.)</span></li>
				<li>The <strong class="source-inline">second = function(...) {...}</strong> definition, which assigns a function to a variable, also produces a function, but an <em class="italic">anonymous</em> (that is, not named) one. However, many JavaScript engines can deduce what the name should be and will then set <strong class="source-inline">second.name === "second"</strong>. (Look at the following code, which shows a case where the anonymous function has no name assigned.) Since the assignment isn’t hoisted, the function will only be accessible after the assignment has been executed. Also, you’d probably prefer defining the variable with <strong class="source-inline">const</strong> rather than <strong class="source-inline">var</strong>, because you wouldn’t (shouldn’t) be changing the function – take a look at the ESLint <strong class="source-inline">no-var</strong> and <strong class="source-inline">prefer-const</strong> rules to <span class="No-Break">enforce this:</span><pre class="source-code">
var second = function() {};
console.log(second.name);
// "second"
var myArray = new Array(3);
myArray[1] = function() {};
console.log(myArray[1].name);
// ""</pre></li>
				<li>The third <a id="_idIndexMarker128"/>definition, <strong class="source-inline">third = function someName(…) {...}</strong>, is the same as the second, except that the function now has its own name: <strong class="source-inline">third.name === "someName"</strong>. The name of a function is relevant when you want to call it and is needed for recursive calls; we’ll return to this in <a href="B19301_09.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Designing Functions</em>. If you just want a function for, say, a callback, you can use one without a name. However, note that named functions are more easily recognized in an error traceback, the kind of listing you use when trying to understand what happened, and which function <span class="No-Break">called what.</span></li>
				<li>The fourth definition, <strong class="source-inline">fourth = (function() { ...; return function(...) {...}; })()</strong>, with an immediately-invoked expression, lets you use a closure. Going back to the counter-making function that we saw in the <em class="italic">Closures</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>, we could write something like the following. An inner function can use variables or other functions, defined in its outer function, in a private, encapsulated way. The outer function receives an argument (<strong class="source-inline">77</strong>, in this case) that is used as the initial value of <strong class="source-inline">count</strong> (if no initial value is provided, we start at <strong class="source-inline">0</strong>). The inner function can access <strong class="source-inline">count</strong> (because of the closure), but the variable cannot be accessed anywhere else. In all aspects, the returned function is common – the only difference is its access to private elements. This is also the basis of<a id="_idIndexMarker129"/> the <span class="No-Break"><strong class="bold">module</strong></span><span class="No-Break"> pattern:</span><pre class="source-code">
const myCounter = <strong class="bold">(</strong>function myCounter(initialValue =
  0) {
  let count = initialValue;
  return function () {
    count++;
    return count;
  };
}<strong class="bold">)(77)</strong>;
console.log(myCounter()); // 78
console.log(myCounter()); // 79
console.log(myCounter()); // 80</pre></li>
				<li>The fifth <a id="_idIndexMarker130"/>definition, <strong class="source-inline">fifth = new Function(...)</strong>, isn’t safe and you shouldn’t use it! You pass the names of the arguments first, then the actual function body as a string, and the equivalent of <strong class="source-inline">eval()</strong> is used to create the function – this allows many dangerous hacks, so don’t do this! (Also, TypeScript cannot deduce the type of the produced function; it just assumes the generic <strong class="source-inline">Function</strong> type.) Just to whet your curiosity, let’s look at an example of rewriting the very simple <strong class="source-inline">sum3()</strong> function we saw back in the <em class="italic">Spread</em> section of <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a><em class="italic">, </em><span class="No-Break"><em class="italic">Becoming Functional</em></span><span class="No-Break">:</span><pre class="source-code">
const sum3 = new Function(
  "x",
  "y",
  "z",
  "const t = x+y+z; return t;"
);
sum3(4, 6, 7); // 17</pre></li>
			</ul>
			<p class="callout-heading">Quirks of eval()</p>
			<p class="callout">This definition is not only unsafe but has some other quirks – they don’t create closures with their creation contexts, so they are always global. See <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function</a> for more on this, but remember that this way of creating functions isn’t a <span class="No-Break">good idea!</span></p>
			<ul>
				<li>Finally, the last<a id="_idIndexMarker131"/> definition, <strong class="source-inline">sixth = (...) =&gt; {...}</strong>, which uses an arrow, <strong class="source-inline">=&gt;</strong>, is the most compact way to define a function and the one we’ll try to use <span class="No-Break">whenever possible.</span></li>
			</ul>
			<p>At this point, we have seen several ways of defining a function, so let’s focus on arrow functions, a style we’ll favor in our coding for <span class="No-Break">this book.</span></p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor058"/>Arrow functions – the modern way</h2>
			<p>Even if arrow functions<a id="_idIndexMarker132"/> work in pretty much the same way as the other functions, there are<a id="_idIndexMarker133"/> some <a id="_idIndexMarker134"/>crucial differences (see <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a>) between them and the usual ones: arrow functions can implicitly return a value even with no return statement present; the value of <strong class="source-inline">this</strong> (the context for the function) is not bound; there is no <strong class="source-inline">arguments</strong> object; they cannot be used as constructors; they do not have a prototype property; and they cannot be used as generators because they don’t allow the <span class="No-Break"><strong class="source-inline">yield</strong></span><span class="No-Break"> keyword.</span></p>
			<p>In this section, we’ll go into several JavaScript function-related topics, <span class="No-Break">including these:</span></p>
			<ul>
				<li>How to return <span class="No-Break">different values</span></li>
				<li>How to handle problems with the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">this</strong></span></li>
				<li>How to work with varying numbers <span class="No-Break">of arguments</span></li>
				<li>An important concept, currying, for which we’ll find many usages in the rest of <span class="No-Break">this book</span></li>
			</ul>
			<h3>Returning values</h3>
			<p>In the<a id="_idIndexMarker135"/> lambda coding style, functions only consist of a result. For the sake of brevity, the new arrow functions provide a syntax for this. When you write something such as <strong class="source-inline">(x,y,z) =&gt;</strong> followed by an expression, a <strong class="source-inline">return</strong> is implied. For instance, the following two functions do the same as the <strong class="source-inline">sum3()</strong> function that we <span class="No-Break">showed previously:</span></p>
			<pre class="source-code">
const f1 = (x: number, y: number, z: number): number <strong class="bold">=&gt;</strong>
<strong class="bold">  x + y + z;</strong>
const f2 = (x: number, y: number, z: number): number <strong class="bold">=&gt; {</strong>
<strong class="bold">  return x + y + z;</strong>
<strong class="bold">};</strong></pre>
			<p>If you want to return an object, you <a id="_idIndexMarker136"/>must use parentheses; otherwise, JavaScript will assume that code follows. Lest you think this is a wildly improbable case, check out <em class="italic">Question 3.1</em> in the <em class="italic">Questions</em> section later in this chapter for a very <span class="No-Break">common scenario!</span></p>
			<p class="callout-heading">A matter of style</p>
			<p class="callout">When you define an arrow function with only one parameter, you can omit the parentheses around it. For consistency, I prefer to always include them. Prettier, the formatting tool I use (we mentioned it in <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>), originally didn’t approve, but in version 2.0, it changed the default of its <strong class="source-inline">arrow-parens</strong> configuration item from <strong class="source-inline">avoid</strong> (meaning, try to do without parentheses) <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">always</strong></span><span class="No-Break">.</span></p>
			<h3>Handling the <strong class="source-inline">this</strong> value</h3>
			<p>A classic problem with JavaScript <a id="_idIndexMarker137"/>is handling <strong class="source-inline">this</strong>, whose value isn’t always what you expect it to be. ES2015 solved this with arrow functions, which inherit the proper <strong class="source-inline">this</strong> value so that problems are avoided. Look at the following code for an example of the possible problems: by the time the timeout function is called, <strong class="source-inline">this</strong> will point to the global (<strong class="source-inline">window</strong>) variable instead of the new object, so you’ll get <strong class="source-inline">undefined</strong> in <span class="No-Break">the console:</span></p>
			<pre class="source-code">
function ShowItself1(identity: string) {
  this.identity = identity;
  setTimeout(function () {
    console.log(this.identity);
  }, 1000);
}
var x = new ShowItself1("Functional");
// after one second, <strong class="bold">undefined</strong> is displayed, not <strong class="bold">Functional</strong></pre>
			<p>There are traditional ways of solving this with <span class="No-Break">old-fashioned JavaScript:</span></p>
			<ul>
				<li>One solution uses a closure and defines a local variable (usually named <strong class="source-inline">that</strong> or sometimes <strong class="source-inline">self</strong>) that will get the original value of <strong class="source-inline">this</strong>, so it won’t <span class="No-Break">be undefined</span></li>
				<li>The second way uses <strong class="source-inline">bind()</strong>, so the timeout function will be bound to the correct value of this (we used <strong class="source-inline">bind()</strong> for a similar purpose in the <em class="italic">Of lambdas and </em><span class="No-Break"><em class="italic">functions</em></span><span class="No-Break"> section)</span></li>
				<li>A third, more modern way just uses an arrow function, so <strong class="source-inline">this</strong> gets the correct value (pointing to the object) without <span class="No-Break">further ado</span></li>
			</ul>
			<p>Let’s see the three solutions in<a id="_idIndexMarker138"/> actual code. We use a closure for the first timeout, binding for the second, and an arrow function for <span class="No-Break">the third:</span></p>
			<pre class="source-code">
// continued...
function ShowItself2(identity: string) {
  this.identity = identity;
  <strong class="bold">const that = this</strong>;
  setTimeout(function () {
    console.log(<strong class="bold">that.identity</strong>);
  }, 1000);
  setTimeout(
    function () {
      console.log(this.identity);
    }<strong class="bold">.bind(this)</strong>,
    2000
  );
  setTimeout(<strong class="bold">() =&gt;</strong> {
    console.log(this.identity);
  }, 3000);
}
const x2 = new ShowItself2("JavaScript");
// after one second, "JavaScript"
// after another second, the same
// after yet another second, once again</pre>
			<p>If you <a id="_idIndexMarker139"/>run this code, you’ll get <strong class="source-inline">JavaScript</strong> after 1 second, then again after another second, and a third time after another second. All three methods worked correctly, so whichever you pick just depends on which you <span class="No-Break">like better.</span></p>
			<h3>Working with arguments</h3>
			<p>In <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>, and <a href="B19301_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a>, <em class="italic">Thinking Functionally</em>, we saw some uses of the spread (<strong class="source-inline">...</strong>) operator. However, the most practical usage we’ll be making of it has to do with working with arguments; we’ll see some<a id="_idIndexMarker140"/> cases of this in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>. </p>
			<p>Let’s review our <strong class="source-inline">once()</strong> function from <a href="B19301_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">, </em><span class="No-Break"><em class="italic">Thinking Functionally</em></span><span class="No-Break">:</span></p>
			<pre class="source-code">
// once.ts
const once = &lt;FNType extends (...args: any[]) =&gt; any&gt;(
  fn: FNType
) =&gt; {
  let done = false;
  return ((<strong class="bold">...args</strong>: Parameters&lt;FNType&gt;) =&gt; {
    if (!done) {
      done = true;
      return fn(<strong class="bold">...args</strong>);
    }
  }) as FNType;
};</pre>
			<p>Why are we writing <strong class="source-inline">return (...args) =&gt;</strong> and then afterward <strong class="source-inline">func(...args)</strong>? The answer has to do with the more modern way of handling a variable number (possibly zero) of arguments. How did you manage such kinds of code in older versions of JavaScript? The answer is the <strong class="source-inline">arguments</strong> object (not an array; read <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/arguments</a>) that lets you access the actual arguments passed to <span class="No-Break">the function.</span></p>
			<p>It <a id="_idIndexMarker141"/>happens that <strong class="source-inline">arguments</strong> is an <em class="italic">array-like</em> object, not really an array – the only array property it has is <strong class="source-inline">length</strong>. You cannot use methods such as <strong class="source-inline">map()</strong>, <strong class="source-inline">forEach()</strong>, and others on <strong class="source-inline">arguments</strong>. To convert <strong class="source-inline">arguments</strong> into a real array, you have to use <strong class="source-inline">slice()</strong>; you would also have to use <strong class="source-inline">apply()</strong> to call another function, <span class="No-Break">like so:</span></p>
			<pre class="source-code">
function useArguments() {
  …
  var myArray = Array.prototype.slice.call(arguments);
  somethingElse.apply(null, myArray);
  …
}</pre>
			<p>In modern JavaScript, you don’t need to use arguments, slicing, <span class="No-Break">or applying:</span></p>
			<pre class="source-code">
function useArguments2(...args) {
  …
  somethingElse(...args);
  …
}</pre>
			<p>You should bear in mind the following points when looking at <span class="No-Break">this code:</span></p>
			<ul>
				<li>By writing <strong class="source-inline">useArguments2(...args)</strong>, we immediately and clearly express that our new function receives several (possibly <span class="No-Break">zero) arguments</span></li>
				<li>You don’t need to do anything to get an array; <strong class="source-inline">args</strong> is a <span class="No-Break">genuine array</span></li>
				<li>Writing <strong class="source-inline">somethingElse(...args)</strong> is much clearer than <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">apply()</strong></span></li>
			</ul>
			<p>By the way, the <strong class="source-inline">arguments</strong> object is still available in the current version of JavaScript. If you want to create an array from it, you have two alternative ways of doing so without having to resort to the <span class="No-Break"><strong class="source-inline">Array.prototype.slice.call</strong></span><span class="No-Break"> trick:</span></p>
			<ul>
				<li>Use the <strong class="source-inline">from()</strong> method and <span class="No-Break">write </span><span class="No-Break"><strong class="source-inline">myArray=Array.from(arguments)</strong></span></li>
				<li>Write <strong class="source-inline">myArray=[...arguments]</strong>, which shows yet another type of usage of the <span class="No-Break">spread operator</span></li>
			</ul>
			<p>When we<a id="_idIndexMarker142"/> get to the topic of higher-order functions, writing functions that deal with other functions, with a possibly unknown number of parameters, will <span class="No-Break">be commonplace.</span></p>
			<p>JavaScript provides a much shorter way of doing this, so you’ll have to get accustomed to this usage. It’s <span class="No-Break">worth it!</span></p>
			<h3>One argument or many?</h3>
			<p>It’s also possible to write functions that return functions, and in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>, we will see more of this. For instance, in lambda calculus, you don’t write functions with several parameters, but only one; you do this using a technique <a id="_idIndexMarker143"/>called <strong class="bold">currying</strong>. (But why would you do this? Hold that thought; we’ll come to <span class="No-Break">this later.)</span></p>
			<p class="callout-heading">Twice recognized</p>
			<p class="callout">Currying gets its name from Haskell Curry, who developed the concept. A functional language, <em class="italic">Haskell</em>, is also named after him – <span class="No-Break">double recognition!</span></p>
			<p>For instance, the function that we saw previously that sums three numbers would be written <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// sum3.ts
const altSum3 = (x: number) =&gt; (y: number) =&gt; (z: number)
  =&gt;
    x + y + z;</pre>
			<p>Why did I change the function’s name? Simply put, this is <em class="italic">not</em> the same function we saw previously. The type of <strong class="source-inline">sum3()</strong> is <strong class="source-inline">(x: number, y: number, z: number) =&gt; number</strong>, while that of <strong class="source-inline">altSum3()</strong> is <strong class="source-inline">(x: number) =&gt; (y: number) =&gt; (z: number) =&gt; number</strong>, which is different. (See <em class="italic">Question 3.3</em> for more on this.) As-is, though, it can be used to produce the very same results as our earlier function. Let’s look at how you would use it, say, to sum the numbers 1, 2, <span class="No-Break">and 3:</span></p>
			<pre class="source-code">
altSum3(1)(2)(3); // 6</pre>
			<p>Test yourself before reading on, and think about this: what would have been returned if you had written <strong class="source-inline">altSum3(1,2,3)</strong> instead? Tip: it would not be a number! For the full answer, <span class="No-Break">keep reading.</span></p>
			<p>How does this work? Separating it into many calls can help; this would be the way the previous expression is calculated by the <span class="No-Break">JavaScript interpreter:</span></p>
			<pre class="source-code">
const fn1 = altSum3(1);
const fn2 = fn1(2);
const fn3 = fn2(3);</pre>
			<p>Think functionally! The result of calling <strong class="source-inline">altSum3(1)</strong> is, according to the definition, a function, which, in virtue of a closure, resolves to be equivalent to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const fn1 = y =&gt; z =&gt; 1 + y + z;</pre>
			<p>Our <strong class="source-inline">altSum3()</strong> function is meant to receive a single argument, not three! The result of this call, <strong class="source-inline">fn1</strong>, is also a single-argument function. When you use <strong class="source-inline">fn1(2)</strong>, the result is again a function, also with a single parameter, which is equivalent to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const fn2 = z =&gt; 1 + 2 + z;</pre>
			<p>And when you calculate <strong class="source-inline">fn2(3)</strong>, a value is finally returned – great! As we said, the function performs the same kind of calculations as we saw earlier, but in an intrinsically <span class="No-Break">different way.</span></p>
			<p>You might think that <a id="_idIndexMarker144"/>currying is a peculiar trick: who would want to use only single-argument functions? You’ll see the reasons for this when we consider how to join functions together in <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a>, <em class="italic">Connecting Functions</em>, and <a href="B19301_12.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Building Better Containers</em>, where it won’t be feasible to pass more than one parameter from one step to <span class="No-Break">the next.</span></p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor059"/>Functions as objects</h2>
			<p>The concept of first-class objects<a id="_idIndexMarker145"/> means that functions can be created, assigned, changed, passed as parameters, and returned as a result of other functions in the same way you can with, say, numbers or strings. Let’s start with its definition. Let’s look at how you usually define a function – and do you recognize the function’s name? (Hint: google “Colossal <span class="No-Break">Cave Adventure”!)</span></p>
			<pre class="source-code">
function xyzzy(...) { ... }</pre>
			<p>This is (almost) equivalent to writing <span class="No-Break">the following:</span></p>
			<pre class="source-code">
var xyzzy = function(...) { ... }</pre>
			<p>However, this is not true for hoisting, as we explained in the <em class="italic">Of lambdas and functions</em> section. JavaScript moves all definitions to the top of the current scope but does <em class="italic">not</em> move the assignments. With the first definition, you can invoke <strong class="source-inline">xyzzy(...)</strong> from any place in your code, but with the second, you cannot invoke the function until the assignment has <span class="No-Break">been executed.</span></p>
			<p>The point that we want to<a id="_idIndexMarker146"/> make is that a function can be assigned to a variable and can also be reassigned if desired. In a similar vein, we can define functions on the spot where they are needed. We can even do this without naming them: as with common expressions, if they are used only once, you don’t need to name them or store them in <span class="No-Break">a variable.</span></p>
			<p class="callout-heading">A colossal parallel</p>
			<p class="callout">See the parallel with the <em class="italic">Colossal Cave Adventure</em> game from the 70s? Invoking <strong class="source-inline">xyzzy()</strong> anywhere won’t always work! If you have never played that famous interactive fiction game, try it online – for example, at <a href="http://www.web-adventures.org/cgi-bin/webfrotz?s=Adventure">www.web-adventures.org/cgi-bin/webfrotz?s=Adventure</a> <span class="No-Break">or </span><a href="http://www.amc.com/blogs/play-the-colossal-cave-adventure-game-just-like-halt-and-catch-fires-cameron-howe--1009966"><span class="No-Break">www.amc.com/blogs/play-the-colossal-cave-adventure-game-just-like-halt-and-catch-fires-cameron-howe--1009966</span></a><span class="No-Break">.</span></p>
			<p>Let’s see an actual code example that involves <span class="No-Break">assigning functions.</span></p>
			<h3>A React-Redux reducer</h3>
			<p>As we mentioned in <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>, React-Redux<a id="_idIndexMarker147"/> works by dispatching actions <a id="_idIndexMarker148"/>that a <em class="italic">reducer</em> processes. (Read more about this at <a href="http://redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers">redux.js.org/tutorials/fundamentals/part-3-state-actions-reducers</a>.) Usually, the reducer includes code with a switch. An example follows – and I’m using JavaScript (not TypeScript) to focus on <span class="No-Break">logic aspects:</span></p>
			<pre class="source-code">
// reducer.ts
function doAction(
  state = initialState,
  action = emptyAction
) {
  const newState: State = {};
  switch (action?.type) {
    case "CREATE":
      // update state, generating newState,
      // depending on the action data
      // to create a new item
      return newState;
    case "DELETE":
      // update state, generating newState,
      // after deleting an item
      return newState;
    case "UPDATE":
      // update an item,
      // and generate an updated state
      return newState;
    default:
      return state;
  }
}</pre>
			<p class="callout-heading">Initial state</p>
			<p class="callout">Providing <strong class="source-inline">initialState</strong> as a default value for the state is a simple way of initializing the global state. Pay no attention to that <strong class="source-inline">default</strong>; it’s irrelevant to our example, and I included it just for completeness. I’m also assuming the existence of <strong class="source-inline">State</strong>,  <strong class="source-inline">Action</strong>, and others as types – see <span class="No-Break"><em class="italic">Question 3.5</em></span><span class="No-Break">!</span></p>
			<p>By taking advantage of the <a id="_idIndexMarker149"/>possibility of storing functions, we can build a <strong class="bold">dispatch</strong> <strong class="bold">table</strong> and <a id="_idIndexMarker150"/>simplify the preceding code. First, we initialize an object with the code for the functions for each action type. We are just taking the preceding code and creating <span class="No-Break">separate functions:</span></p>
			<pre class="source-code">
// continued...
const dispatchTable = {
  CREATE: (state, action) =&gt; {
    // update state, generating newState,
    // depending on the action data
    // to create a new item
    const NewState = {
      /* updated State */
    };
    return NewState;
  },
  DELETE: (state, action) =&gt; {
    // update state, generating newState,
    // after deleting an item
    const NewState = {
      /* updated State */
    };
    return NewState;
  },
  UPDATE: (state, action) =&gt; {
    // update an item,
    // and generate an updated state
    const NewState = {
      /* updated State */
    };
    return NewState;
  },
};</pre>
			<p>We store the different functions that process each type of action as attributes in an object that will work as <a id="_idIndexMarker151"/>a dispatcher table. This object is created only once and is constant during the execution of the application. With it, we can now rewrite the action-processing code in a single line <span class="No-Break">of code:</span></p>
			<pre class="source-code">
// continued...
function doAction2(state, action) {
  return dispatchTable[action.type]
    ? <strong class="bold">dispatchTable[action.type](state, action)</strong>
    : state;
}</pre>
			<p>Let’s analyze it: given the action, if <strong class="source-inline">action.type</strong> matches an attribute in the dispatching object, we execute the corresponding function taken from the object where it was stored. If there isn’t a match, we just return the current state as Redux requires. This kind of code wouldn’t be possible if we couldn’t handle functions (storing and recalling them) as <span class="No-Break">first-class objects.</span></p>
			<h3>An unnecessary mistake</h3>
			<p>There is, however, a common (though, in fact, harmless) mistake that is usually made. You often see code <span class="No-Break">like this:</span></p>
			<pre class="source-code">
fetch("some/url").then(function(data) {
  processResult(data);
});
fetch("some/url").then(<strong class="bold">(data) =&gt; processResult(data)</strong>);</pre>
			<p>What does this code do? The idea is that a remote URL is fetched, and when the data arrives, a function is called – and this function calls <strong class="source-inline">processResult</strong> with <strong class="source-inline">data</strong> as an argument. That is to say, in the <strong class="source-inline">then()</strong> part, we want a function that, given data, calculates <strong class="source-inline">processResult(data)</strong>. But don’t we already have such <span class="No-Break">a function?</span></p>
			<p>There is a rule that you can apply whenever you see something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
function someFunction(someData) {
  return someOtherFunction(someData);
}</pre>
			<p>This rule states that you can replace code resembling the preceding code with just <strong class="source-inline">someOtherFunction</strong>. So, in our example, we can directly write <span class="No-Break">what follows:</span></p>
			<pre class="source-code">
fetch("some/url").then(<strong class="bold">processResult</strong>);</pre>
			<p>This code is equivalent to the previous method that we looked at (although it is infinitesimally quicker since you avoid one function call), but is it simpler <span class="No-Break">to understand?</span></p>
			<p class="callout-heading">Some terminology</p>
			<p class="callout">In lambda calculus<a id="_idIndexMarker152"/> terms, we are replacing λ<em class="italic">x</em>.<em class="italic">func</em> <em class="italic">x</em> with simply <em class="italic">func</em> – this is called an <strong class="bold">η (eta) conversion</strong>, or more<a id="_idIndexMarker153"/> specifically, an <strong class="bold">η</strong><strong class="bold"> reduction</strong>. (If you were to do it the other way round, it would be an <strong class="bold">η</strong><strong class="bold"> abstraction</strong>.) In our case, it could be<a id="_idIndexMarker154"/> considered a (very, very small!) optimization, but its main advantage is shorter, more <span class="No-Break">compact code.</span></p>
			<p>This programming style is<a id="_idIndexMarker155"/> called <strong class="bold">pointfree</strong> (also <strong class="bold">point-free</strong>) or <strong class="bold">tacit</strong> style, and its <a id="_idIndexMarker156"/>defining characteristic is that you never specify the arguments for each function application. An advantage of this way of coding is that it helps the writer (and the future readers of the code) think about the functions and their meanings instead of working at a low level, passing data around, and working with it. In the shorter version of the code, there are no extraneous or irrelevant details: if you know what the called function does, you understand the meaning of the complete piece of code. We’ll often (but not necessarily always) work this way in <span class="No-Break">our text.</span></p>
			<p class="callout-heading">Old Unix style</p>
			<p class="callout">Unix/Linux users are already accustomed to this style because they work in a similar way when they use pipes to pass the result of a command as input to another. When you write something as <strong class="source-inline">ls|grep doc|sort</strong>, the output of <strong class="source-inline">ls</strong> is the input to <strong class="source-inline">grep</strong>, and the latter’s output is the input to <strong class="source-inline">sort</strong> – but input arguments aren’t written out anywhere; they are implied. We’ll come back to this in the <em class="italic">Pointfree style</em> section of <a href="B19301_08.xhtml#_idTextAnchor148"><span class="No-Break"><em class="italic">Chapter 8</em></span></a><em class="italic">, </em><span class="No-Break"><em class="italic">Connecting Functions</em></span><span class="No-Break">.</span></p>
			<h3>Working with methods</h3>
			<p>However, there is a case that<a id="_idIndexMarker157"/> you should be aware of: what happens if you call an object’s method? Look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fetch("some/remote/url").then(function (data) {
  myObject.store(data);
});</pre>
			<p>If your original code had been something along the lines of the preceding code, then the seemingly obvious transformed code <span class="No-Break">would fail:</span></p>
			<pre class="source-code">
fetch("some/remote/url").then(<strong class="bold">myObject.store</strong>); // Fail!</pre>
			<p>Why? The reason is that in the original code, the called method is bound to an object (<strong class="source-inline">myObject</strong>), but in the modified code, it isn’t bound and is just a free function. We can fix it by <span class="No-Break">using </span><span class="No-Break"><strong class="source-inline">bind()</strong></span><span class="No-Break">:</span></p>
			<pre class="source-code">
fetch("some/remote/url").then(
  <strong class="bold">myObject.store.bind(myObject)</strong>
);</pre>
			<p>This is a general solution. When dealing with a method, you cannot just assign it; you must use <strong class="source-inline">bind()</strong> so that the correct context will be available. Look at the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
const doSomeMethod = (someData) =&gt; {
  return someObject.someMethod(someData);
}</pre>
			<p>Following this rule, such code should be converted into <span class="No-Break">the following:</span></p>
			<pre class="source-code">
const doSomeMethod = someObject.someMethod.bind(someObject);</pre>
			<p class="callout-heading">Tip</p>
			<p class="callout">Read more<a id="_idIndexMarker158"/> on <strong class="source-inline">bind()</strong> <span class="No-Break">at </span><a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind"><span class="No-Break">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind</span></a><span class="No-Break">.</span></p>
			<p>This looks rather <a id="_idIndexMarker159"/>awkward and not too elegant, but it’s required so that the method will be associated with the correct object. We will see one application of this when we <em class="italic">promisify</em> functions in <a href="B19301_06.xhtml#_idTextAnchor107"><span class="No-Break"><em class="italic">Chapter 6</em></span></a>, <em class="italic">Producing Functions</em>. Even if this code isn’t so nice to look at, whenever you have to work with objects (and remember, we didn’t say that we would be trying to aim for fully FP code, and did say that we would accept other constructs if they made things easier), you’ll have to remember to bind methods before passing them as first-class objects in <span class="No-Break">pointfree style.</span></p>
			<p>So far, we have been discussing many aspects of functions; now, let’s get more into functions in FP, and see how we’ll <span class="No-Break">use them.</span></p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor060"/>Using functions in FP ways</h1>
			<p>Several common coding patterns take advantage of the FP style, even if you aren’t aware of it. In this section, we will go through them and look at the functional aspects of the code so that you can get more accustomed to this <span class="No-Break">coding style.</span></p>
			<p>Then, we’ll look in detail at using functions in an FP way<a id="_idIndexMarker160"/> by considering several FP techniques, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="bold">Injection</strong>, which is needed for sorting different strategies, as well as <span class="No-Break">other uses</span></li>
				<li><strong class="bold">Callbacks</strong> and <strong class="bold">promises</strong>, introducing the <span class="No-Break"><strong class="bold">continuation-passing</strong></span><span class="No-Break"> style</span></li>
				<li><strong class="bold">Polyfilling</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="bold">stubbing</strong></span></li>
				<li><strong class="bold">Immediate </strong><span class="No-Break"><strong class="bold">invocation</strong></span><span class="No-Break"> schemes</span></li>
			</ul>
			<h2 id="_idParaDest-62"><a id="_idTextAnchor061"/>Injection – sorting it out</h2>
			<p>The <strong class="source-inline">Array.prototype.sort()</strong> method <a id="_idIndexMarker161"/>provides the first example of passing functions as parameters. If you have an array of strings and you want to sort it, you can <a id="_idIndexMarker162"/>just use the <strong class="source-inline">sort()</strong> method. For example, to alphabetically sort an array with the colors of the rainbow, we would write something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
// sort.ts
const colors = [
  "violet",
  "indigo",
  "blue",
  "green",
  "yellow",
  "orange",
  "red",
];
colors.sort();
console.log(colors);
// 'blue', 'green', 'indigo', 'orange', 'red',
// 'violet', 'yellow'</pre>
			<p>Note that we didn’t have to provide any parameters to the <strong class="source-inline">sort()</strong> call, but the array got sorted perfectly well. By default, this method sorts strings according to their ASCII internal representation. So, if you use this method to sort an array of numbers, it will fail because it will decide that 20 must be between 100 and 3, as 100 precedes 20 (taken as strings!) and the latter precedes 3, so this needs fixing! The following code shows <span class="No-Break">the problem:</span></p>
			<pre class="source-code">
// continued...
const someNumbers = [3, 20, 100];
someNumbers.sort();
console.log(someNumbers);
// 100, 20, 3</pre>
			<p>But let’s forget <a id="_idIndexMarker163"/>numbers for a while and stick to sorting strings. What would happen if we <a id="_idIndexMarker164"/>wanted to sort some Spanish words (<em class="italic">palabras</em>) while following the appropriate locale rules? We would be sorting strings, but the results wouldn’t <span class="No-Break">be correct:</span></p>
			<pre class="source-code">
// continued...
const palabras = [
  "ñandú",
  "oasis",
  "mano",
  "natural",
  "mítico",
  "musical",
];
palabras.sort();
console.log(palabras);
<strong class="bold">// "mano", "musical", "mítico",</strong>
<strong class="bold">// "natural", "oasis", "ñandú" -- wrong result!</strong></pre>
			<p class="callout-heading">What’s in a word?</p>
			<p class="callout">For language or biology buffs, <em class="italic">ñandú</em> in English is <em class="italic">rhea</em>, a running bird similar to an ostrich. There aren’t many Spanish words beginning with <em class="italic">ñ</em>, and we happen to have these birds in my country, Uruguay, so that’s the reason for the <span class="No-Break">odd word!</span></p>
			<p>Oops! In Spanish, <em class="italic">ñ</em> comes <a id="_idIndexMarker165"/>between <em class="italic">n</em> and <em class="italic">o</em>, but <strong class="source-inline">"ñandú"</strong> got sorted at the end. Also, <strong class="source-inline">"mítico"</strong> (in English, mythical; note the accented <em class="italic">í</em>) should appear between <strong class="source-inline">"mano"</strong> and <strong class="source-inline">"musical"</strong> because the tilde should be ignored. The appropriate way of solving this is by providing a comparison function to <strong class="source-inline">sort()</strong>. In this case, we can use the <strong class="source-inline">localeCompare()</strong> method<a id="_idIndexMarker166"/> <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// continued...
palabras.sort((a: string, b: string) =&gt;
  a.localeCompare(b, "es")
);
console.log(palabras);
<strong class="bold">// "mano", "mítico", "musical",</strong>
<strong class="bold">// "natural", "ñandú", "oasis" –- correct result!</strong></pre>
			<p>The <strong class="source-inline">a.localeCompare(b,"es")</strong> call compares the <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> strings and returns a negative value should <strong class="source-inline">a</strong> precede <strong class="source-inline">b</strong>, a positive value should <strong class="source-inline">a</strong> follow <strong class="source-inline">b</strong>, and 0 if <strong class="source-inline">a</strong> and <strong class="source-inline">b</strong> are the same – but according to Spanish (<strong class="source-inline">"es"</strong>) <span class="No-Break">ordering rules.</span></p>
			<p>Now, things are right! And the code could be made clearer by introducing a new function, <strong class="source-inline">spanishComparison()</strong>, to perform the required <span class="No-Break">strings comparison:</span></p>
			<pre class="source-code">
// continued...
const spanishComparison = (a: string, b: string) =&gt;
  a.localeCompare(b, "es");
palabras.sort(spanishComparison); // same correct result</pre>
			<p class="callout-heading">International sorting</p>
			<p class="callout">For more on<a id="_idIndexMarker167"/> the <strong class="source-inline">localeCompare()</strong> possibilities, see <a href="http://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare">developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/localeCompare</a>. You can specify which locale rules to apply, in which order to place upper/lowercase letters, whether to ignore punctuation, and much more. But be careful: not all browsers may support the required <span class="No-Break">extra parameters.</span></p>
			<p>In upcoming chapters, we will discuss how FP lets you write code in a more declarative fashion, producing more understandable code, and how this sort of minor change helps. When readers of the code get to the <strong class="source-inline">sort</strong> function, they will immediately deduce what is being done, even if the comment <span class="No-Break">wasn’t present.</span></p>
			<p class="callout-heading">Of strategies and patterns</p>
			<p class="callout">This way of changing how the <strong class="source-inline">sort()</strong> function works by injecting different comparison functions is a case of the strategy <strong class="bold">design pattern</strong>. We’ll learn more about this in <a href="B19301_11.xhtml#_idTextAnchor204"><span class="No-Break"><em class="italic">Chapter 11</em></span></a>, <em class="italic">Implementing </em><span class="No-Break"><em class="italic">Design Patterns</em></span><span class="No-Break">.</span></p>
			<p>Providing a <strong class="source-inline">sort</strong> function as a parameter (in a very FP way!) can also help with several other problems, such as <span class="No-Break">the following:</span></p>
			<ul>
				<li><strong class="source-inline">sort()</strong> only works with strings by default. If you want to sort numbers (as we tried to do previously), you <a id="_idIndexMarker168"/>have to provide a function that will compare numerically. For example, you would write something like <strong class="source-inline">myNumbers.sort((a:number, b:number) =&gt; a – b)</strong>. (Why? See <span class="No-Break"><em class="italic">Question 3.7</em></span><span class="No-Break">.)</span></li>
				<li>If you want to sort objects<a id="_idIndexMarker169"/> by a given attribute, you will use a function that compares to it. For example, you could sort people by age with something like <strong class="source-inline">myPeople.sort((a:Person, b:Person) =&gt; a.age - </strong><span class="No-Break"><strong class="source-inline">b.age)</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>This is a simple example you have probably used before, but it’s an FP pattern, after all. Let’s move on to even more common usage of functions as parameters when you perform <span class="No-Break">Ajax calls.</span></p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor062"/>Callbacks and promises</h2>
			<p>Probably the most used <a id="_idIndexMarker170"/>example of functions passed as first-class objects has to do with callbacks<a id="_idIndexMarker171"/> and <a id="_idIndexMarker172"/>promises. In Node.js, reading a <a id="_idIndexMarker173"/>file is accomplished asynchronously with something like the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
const fs = require("fs");
fs.readFile("someFile.txt", (err, data) =&gt; {
  if (err) {
    // handle the error
  } else {
    // do something with the received data
  }
});</pre>
			<p>The <strong class="source-inline">readFile()</strong> function requires a callback – in this example, an anonymous function – that will get called when the file-reading operation <span class="No-Break">is finished.</span></p>
			<p>A better, more modern way is using<a id="_idIndexMarker174"/> promises; read more at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise</a>. With this, when performing an Ajax web service call using the <strong class="source-inline">fetch()</strong> function, you could write something along the lines of the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
fetch("some/remote/url")
  .then((data) =&gt; {
    // do something with the received data
  })
  .catch((error) =&gt; {
    // handle the error
  });</pre>
			<p>Finally, you should also look into <a id="_idIndexMarker175"/>using <strong class="source-inline">async</strong>/<strong class="source-inline">await</strong>; read more about them at <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function</a> and <a href="http://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await"><span class="No-Break">developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/await</span></a><span class="No-Break">, respectively.</span></p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor063"/>Continuation-passing style</h2>
			<p>The preceding <a id="_idIndexMarker176"/>code, in which you call a function but also pass another function to be executed when the input/output operation is<a id="_idIndexMarker177"/> finished, can be considered something called <strong class="bold">continuation-passing style</strong> (<strong class="bold">CPS</strong>). What is this technique of coding? One way of looking at it is by thinking about the question: <em class="italic">how would you program if using the return statement </em><span class="No-Break"><em class="italic">was forbidden?</em></span></p>
			<p>At first glance, this may appear to be an impossible situation. However, we can get out of our fix by passing a callback to the called function so that when that procedure is ready to return to the caller, instead of returning, it invokes the given callback. By doing this, the callback provides the called function with the way to continue the process, hence the word <em class="italic">continuation</em>. We won’t get into this now, but in <a href="B19301_09.xhtml#_idTextAnchor172"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, <em class="italic">Designing Functions</em>, we will study it in depth. In particular, CPS will help us to avoid an important recursion restriction, as <span class="No-Break">we’ll see.</span></p>
			<p>Working out how to use continuations is sometimes challenging, but always possible. An exciting advantage of this way of coding is that by specifying how the process will continue, you can go beyond all the usual structures (<strong class="source-inline">if</strong>, <strong class="source-inline">while</strong>, <strong class="source-inline">return</strong>, and so on) and implement whatever mechanisms you want. This can be very useful in problems where the process isn’t necessarily linear. Of course, this can also lead to you inventing a kind of control structure far worse than the possible usage of GOTO statements that you might imagine! <span class="No-Break"><em class="italic">Figure 3</em></span><em class="italic">.1</em> shows the dangers of <span class="No-Break">that practice!</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_3.1_B19301.jpg" alt="Figure 3.1 – What’s the ﻿worst that could happen if you start messing with the program ﬂow? (This XKCD comic is available online at xkcd.com/292/)"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – What’s the worst that could happen if you start messing with the program ﬂow? (This XKCD comic is available online at <a href="http://xkcd.com/292/">xkcd.com/292/</a>)</p>
			<p>You are not limited to passing a single continuation. As with promises, you can provide two or more alternative callbacks. And this, by the way, can provide a solution to the problem of how you would work with exceptions. If we simply allowed a function to throw an error, it would be an implied return to the caller, and we don’t want this. The way out of this is to provide an alternative callback (that is, a different continuation) to be used whenever an exception is thrown (in <a href="B19301_12.xhtml#_idTextAnchor221"><span class="No-Break"><em class="italic">Chapter 12</em></span></a>, <em class="italic">Building Better Containers</em>, we’ll find another solution <span class="No-Break">using monads):</span></p>
			<pre class="source-code">
function doSomething(a, b, c,
  normalContinuation, errorContinuation) {
  let r = 0;
  // ... do some calculations involving a, b, and c,
  // and store the result in r
  // if an error happens, invoke:
  // errorContinuation("description of the error")
  // otherwise, invoke:
  // normalContinuation(r)
}</pre>
			<p>Using CPS<a id="_idIndexMarker178"/> can even allow you to go beyond the<a id="_idIndexMarker179"/> control structures that JavaScript provides, but that would be beyond the objectives of this book, so I’ll let you research that on <span class="No-Break">your own!</span></p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor064"/>Polyfills</h2>
			<p>Being able to assign<a id="_idIndexMarker180"/> functions<a id="_idIndexMarker181"/> dynamically (in the same way that you can assign different values to a variable) also allows you to work more efficiently when <span class="No-Break">defining polyfills.</span></p>
			<h3>Detecting Ajax</h3>
			<p>Let’s go back a bit in time to when <a id="_idIndexMarker182"/>Ajax started to appear. Given that different browsers implemented Ajax calls in distinct fashions, you would always have to code around these differences. The following code shows how you would go about implementing an Ajax call by testing several <span class="No-Break">different conditions:</span></p>
			<pre class="source-code">
// ajax.ts
function getAjax() {
  let ajax = null;
  if (window.XMLHttpRequest) {
    // modern browser? use XMLHttpRequest
    ajax = new XMLHttpRequest();
  } else if (window.ActiveXObject) {
    // otherwise, use ActiveX for IE5 and IE6
    ajax = new ActiveXObject("Microsoft.XMLHTTP");
  } else {
    throw new Error("No Ajax support!");
  }
  return ajax;
}</pre>
			<p>This worked but <a id="_idIndexMarker183"/>implied that you would redo the Ajax check for every call, even though the test results wouldn’t ever change. There’s a more efficient way to do this, and it has to do with using functions as first-class objects. We could define <em class="italic">two</em> different functions, test for the condition only once, and then assign the correct function to be used later; study the following code for such <span class="No-Break">an alternative:</span></p>
			<pre class="source-code">
// continued...
(function initializeGetAjax() {
  let myAjax = null;
  if (window.XMLHttpRequest) {
    // modern browsers? use XMLHttpRequest
    myAjax = function () {
      return new XMLHttpRequest();
    };
  } else if (window.ActiveXObject) {
    // it's ActiveX for IE5 and IE6
    myAjax = function () {
      new ActiveXObject("Microsoft.XMLHTTP");
    };
  } else {
    myAjax = function () {
      throw new Error("No Ajax support!");
    };
  }
  window.getAjax = myAjax;
})();</pre>
			<p>This piece of code shows two important concepts. First, we can dynamically assign a function: when this code runs, <strong class="source-inline">window.getAjax</strong> (the global <strong class="source-inline">getAjax</strong> variable) will get one of three possible values according to the current browser. When you later call <strong class="source-inline">getAjax()</strong> in your code, the correct function will execute without you needing to do any further <span class="No-Break">browser-detection tests.</span></p>
			<p>The second <a id="_idIndexMarker184"/>interesting idea is that we define the <strong class="source-inline">initializeGetAjax()</strong> function and immediately run it – this pattern is called the <strong class="bold">immediately invoked function expression</strong> (<strong class="bold">IIFE</strong>), and we<a id="_idIndexMarker185"/> already saw it in the <em class="italic">Solution 7 – using a local flag</em> section in <a href="B19301_02.xhtml#_idTextAnchor037"><span class="No-Break"><em class="italic">Chapter 2</em></span></a><em class="italic">, Thinking Functionally</em>. The function runs but cleans up after itself because all its variables are local and won’t even exist after the function runs. We’ll learn more about this later in <span class="No-Break">this chapter.</span></p>
			<p>Nowadays, you would use a module instead of an IIFE, <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
// ajax.module.ts
let getAjax = null;
if (window.XMLHttpRequest) {
  // modern browsers? use XMLHttpRequest
  getAjax = function () {
    return new XMLHttpRequest();
  };
} else if (window.ActiveXObject) {
  // it's ActiveX for IE5 and IE6
  getAjax = function () {
    new ActiveXObject("Microsoft.XMLHTTP");
  };
} else {
  getAjax = function () {
    throw new Error("No Ajax support!");
  };
}
export { getAjax };</pre>
			<p>The code in the<a id="_idIndexMarker186"/> module is guaranteed to run only once. Wherever you need to do an Ajax call, you would just <strong class="source-inline">import { getAjax } from "/path/to/ajax.module"</strong> and you could use <strong class="source-inline">getAjax()</strong> <span class="No-Break">at will.</span></p>
			<h3>Adding missing functions</h3>
			<p>This idea of <a id="_idIndexMarker187"/>defining a function on the run also allows us to write polyfills that provide otherwise missing functions. For example, let’s say that we had some code such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
if (currentName.indexOf("Mr.") !== -1) {
  // it's a man
  ...
}</pre>
			<p>Instead of this, you might very much prefer using the newer <strong class="source-inline">includes()</strong> method and just <span class="No-Break">write this:</span></p>
			<pre class="source-code">
if (currentName.includes("Mr.")) {
  // it's a man
  ...
}</pre>
			<p>What happens if your browser doesn’t provide <strong class="source-inline">includes()</strong>? Once again, we can define the appropriate function on the fly, but only if needed. If <strong class="source-inline">includes()</strong> is available, you don’t need to do anything, but if it is missing, you need to define a polyfill that will provide the same workings. (You can find links to polyfills on Mozilla’s developer site.) The following code shows an example of such <span class="No-Break">a polyfill:</span></p>
			<pre class="source-code">
if (!String.prototype.includes) {
  String.prototype.includes = function (search, start) {
    "use strict";
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length &gt; this.length) {
      return false;
    } else {
      return this.indexOf(search, start) !== -1;
    }
  };
}</pre>
			<p>When this code runs, it checks whether the <strong class="source-inline">String</strong> prototype already has the <strong class="source-inline">includes()</strong> method. If not, it assigns a function to it that does the same job, so from that point onward, you’ll be able to use <strong class="source-inline">includes()</strong> without further worries. By the way, there are other ways of defining a polyfill: check the answer to <em class="italic">Question 3.7</em> for an alternative. Yet another<a id="_idIndexMarker188"/> solution is the <strong class="source-inline">core-js</strong> package (<a href="http://github.com/zloirock/core-js">github.com/zloirock/core-js</a>), which provides polyfills for ECMAScript up to the latest version, and even some<a id="_idIndexMarker189"/> proposals that haven’t made it into the <span class="No-Break">language yet.</span></p>
			<p class="callout-heading">Good or bad?</p>
			<p class="callout">Directly modifying a standard type’s prototype object is usually frowned upon because, in essence, it’s equivalent to using a global variable, and thus it’s prone to errors; however, in this case (writing a polyfill for a well-established, known function) is quite unlikely to provoke <span class="No-Break">any conflicts.</span></p>
			<p>Finally, if you happened to think that the Ajax example shown previously was old hat, consider this: if you want to use the more modern <strong class="source-inline">fetch()</strong> way of calling services, you will also find that not all modern browsers support it (check <a href="http://caniuse.com/#search=fetch">caniuse.com/#search=fetch</a> to verify this), so you’d have to use a polyfill, such as the one at <a href="http://github.com/github/fetch">github.com/github/fetch</a>. Study the code, and you’ll see that it uses the same method described previously to see whether a polyfill is needed and <span class="No-Break">create it.</span></p>
			<h2 id="_idParaDest-66"><a id="_idTextAnchor065"/>Stubbing</h2>
			<p>Here, we will look at a use case similar to using a polyfill: having a function do different work depending on the environment. The idea is to perform stubbing, an idea that comes from testing and involves replacing a function with another that does a simpler job instead of the <span class="No-Break">actual work.</span></p>
			<p>Stubbing<a id="_idIndexMarker190"/> is commonly <a id="_idIndexMarker191"/>used with logging functions. You may want the application to perform detailed logging when in development but not to say a peep when in production. A common solution would be to write something along the lines of <span class="No-Break">the following:</span></p>
			<pre class="source-code">
let myLog = (someText) =&gt; {
  if (DEVELOPMENT) {
    console.log(someText); // or some other way of logging
  } else {
    // do nothing
  }
};</pre>
			<p>This works, but as in the example of Ajax detection, it does more work than it needs to because it checks whether the application is in development <span class="No-Break">every time.</span></p>
			<p>We could simplify the code (and get a really, really tiny performance gain!) if we stub out the logging function so that it won’t log anything; an easy implementation is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
let myLog;
if (DEVELOPMENT) {
  myLog = (someText: string) =&gt; console.log(someText);
} else {
  myLog = (someText: string) =&gt; {};
}</pre>
			<p>We can do even better with the <span class="No-Break">ternary operator:</span></p>
			<pre class="source-code">
const myLog = DEVELOPMENT
  ? (someText: string) =&gt; console.log(someText)
  : (someText: string) =&gt; {};</pre>
			<p>This is a bit <a id="_idIndexMarker192"/>more cryptic, but<a id="_idIndexMarker193"/> I prefer it because it uses <strong class="source-inline">const</strong>, which cannot <span class="No-Break">be modified.</span></p>
			<p>There’s yet another possibility: you could modify the original method <span class="No-Break">like this:</span></p>
			<pre class="source-code">
if (DEVELOPMENT) {
  // do nothing, let things be
} else {
  console.log = (someText: string) =&gt; {};
}</pre>
			<p>In this case, we are directly changing how <strong class="source-inline">console.log()</strong> works, so it won’t <span class="No-Break">log anything.</span></p>
			<p class="callout-heading">Useless arguments – ignore or exclude?</p>
			<p class="callout">Given that JavaScript allows us to call functions with more arguments than parameters, and given that we aren’t doing anything in <strong class="source-inline">myLog()</strong> when we are not in development, we could also have written <strong class="source-inline">() =&gt; {}</strong> and it would have worked fine. However, I do prefer keeping the same signature, and that’s why I specified the <strong class="source-inline">someText</strong> argument, even if it wouldn’t be used. But, if you use ESLint’s <strong class="source-inline">no-unused-vars</strong> rule to detect unused variables, you may have to tweak its configuration to allow <span class="No-Break">unused arguments.</span></p>
			<p>You’ll notice that we are using the concept of functions as first-class objects over and over again; look through all the code samples and <span class="No-Break">you’ll see!</span></p>
			<h2 id="_idParaDest-67"><a id="_idTextAnchor066"/>Immediate invocation (IIFE)</h2>
			<p>There’s yet another common usage of functions, usually seen in popular libraries and frameworks, that lets you <a id="_idIndexMarker194"/>bring some modularity advantages from other<a id="_idIndexMarker195"/> languages into JavaScript (even the older versions!). The usual way of writing this is something like <span class="No-Break">the following:</span></p>
			<pre class="source-code">
(function () {
  // do something...
})();</pre>
			<p>Alternatively, you may find <strong class="source-inline">(function(){ ... }())</strong> – note the different placement of the parentheses for the function call. Both styles have their fans; pick whichever suits you, and follow <span class="No-Break">it consistently.</span></p>
			<p>You can also pass some arguments to the function that will be used as the initial values for <span class="No-Break">its parameters:</span></p>
			<pre class="source-code">
(function (a, b) {
  // do something, using the
  // received arguments for a and b...
})(some, values);</pre>
			<p>Finally, you could also return something from the function – usually, an object (with several methods) or <span class="No-Break">a function:</span></p>
			<pre class="source-code">
let x = (function (a, b) {
  // ...return an object or function
})(some, values);</pre>
			<p>Note the parentheses around the function. These help the parser understand that we are writing an expression. If you were to omit the first set of parentheses, JavaScript would think you were writing a function declaration instead of an invocation. The parentheses also serve as a visual note, so readers of your code will immediately recognize <span class="No-Break">the IIFE.</span></p>
			<p>As previously mentioned, the pattern is called IIFE (pronounced <em class="italic">iffy</em>). The name is easy to understand: you define a function and call it right away so that it gets executed on the spot. Why would you do this, instead of simply writing the code inline? The reason has to do <span class="No-Break">with scopes.</span></p>
			<p>If you define any variables or functions within IIFE, then because of how JavaScript defines the scope of functions, those definitions will be internal, and no other part of your code will be able to access them. Imagine that you wanted to write some complicated initialization, such as <span class="No-Break">the following:</span></p>
			<pre class="source-code">
function ready() { ... }
function set() { ... }
function go() { ... }
// initialize things calling ready(),
// set(), and go() appropriately</pre>
			<p>What could go <a id="_idIndexMarker196"/>wrong? The problem hinges on the fact that you<a id="_idIndexMarker197"/> could (by accident) have a function with the same name as any of the three here, and hoisting would imply that the last function would <span class="No-Break">be called:</span></p>
			<pre class="source-code">
function ready() {
  console.log("ready");
}
<strong class="bold">function set() {</strong>
<strong class="bold">  console.log("set");</strong>
<strong class="bold">}</strong>
function go() {
  console.log("go");
}
ready();
set();
go();
<strong class="bold">function set() {</strong>
<strong class="bold">  console.log("UNEXPECTED...");</strong>
<strong class="bold">}</strong>
// "ready"
// "UNEXPECTED"
// "go"</pre>
			<p>Oops! If you had used IIFE, the <a id="_idIndexMarker198"/>problem wouldn’t have happened. (Using ESLint’s <strong class="source-inline">no-func-assign</strong> rule would have prevented this, too.) Also, the three inner <a id="_idIndexMarker199"/>functions wouldn’t even be visible to the rest of the code, which helps to keep the global namespace less polluted. The following code shows a widespread pattern <span class="No-Break">for this:</span></p>
			<pre class="source-code">
<strong class="bold">(function () {</strong>
  function ready() {
    console.log("ready");
  }
  function set() {
    console.log("set");
  }
  function go() {
    console.log("go");
  }
  ready();
  set();
  go();
<strong class="bold">})();</strong>
function set() {
  console.log("UNEXPECTED...");
}
// "ready"
// "set"
// "go"</pre>
			<p>To see an <a id="_idIndexMarker200"/>example involving returned values, we could revisit<a id="_idIndexMarker201"/> the example from <a href="B19301_01.xhtml#_idTextAnchor015"><span class="No-Break"><em class="italic">Chapter 1</em></span></a>, <em class="italic">Becoming Functional</em>, and write the following, which would create a <span class="No-Break">single counter:</span></p>
			<pre class="source-code">
const myCounter = <strong class="bold">(</strong>function () {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}<strong class="bold">)();</strong></pre>
			<p>Then, every call to <strong class="source-inline">myCounter()</strong> would return an incremented count, but there is no chance that any other part of your code will overwrite the inner <strong class="source-inline">count</strong> variable because it’s only accessible within the <span class="No-Break">returned function.</span></p>
			<h1 id="_idParaDest-68"><a id="_idTextAnchor067"/>Summary</h1>
			<p>In this chapter, we went over several ways of defining functions in JavaScript, focusing mainly on arrow functions, which have several advantages over standard functions, including being terser. We learned about the concept of currying (which we’ll be revisiting later), considered some aspects of functions as first-class objects, and reviewed several techniques that happen to be fully FP in concept. Rest assured that we’ll be using everything in this chapter as the building blocks for more advanced techniques in the rest of this book; just wait <span class="No-Break">and see!</span></p>
			<p>In <a href="B19301_04.xhtml#_idTextAnchor069"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Behaving Properly</em>, we will delve even more deeply into functions and learn about the concept of pure functions, leading us to an even better <span class="No-Break">programming style.</span></p>
			<h1 id="_idParaDest-69"><a id="_idTextAnchor068"/>Questions</h1>
			<p>3.1 <strong class="bold">Uninitialized object?</strong> React-Redux programmers usually code action creators to simplify the creation of actions that will later be processed by a reducer. (We saw this in the <em class="italic">A React-Redux reducer</em> section.) Actions are objects with a <strong class="source-inline">type</strong> attribute, used to determine what kind of action you are creating. The following code supposedly produces an action, but can you explain the <span class="No-Break">unexpected results?</span></p>
			<pre class="source-code">
const simpleAction = (t:string) =&gt; {
  type: t;
};
console.log(simpleAction("INITIALIZE"));
// undefined</pre>
			<p>3.2 <strong class="bold">Are arrows allowed?</strong> Would everything be the same if you defined <strong class="source-inline">useArguments()</strong> and <strong class="source-inline">useArguments2()</strong> from the <em class="italic">Working with arguments</em> section by using arrow functions instead of the way we did, with the <span class="No-Break"><strong class="source-inline">function</strong></span><span class="No-Break"> keyword?</span></p>
			<p>3.3 <strong class="bold">Three more types</strong>: Back in the <em class="italic">One argument or many?</em> section, we showed the types of <strong class="source-inline">sum3()</strong> and <strong class="source-inline">altsum3()</strong>, but we didn’t do that for <strong class="source-inline">fn1</strong>, <strong class="source-inline">fn2</strong>, and <strong class="source-inline">fn3</strong>. What are the types of <span class="No-Break">those functions?</span></p>
			<p>3.4 <strong class="bold">One-liner</strong>: A programmer, particularly thrifty with lines of code, suggested rewriting <strong class="source-inline">doAction2()</strong> as a one-liner, even though you can’t tell this from the formatting! What do you think: is it correct or <span class="No-Break">isn’t it?</span></p>
			<pre class="source-code">
const doAction3 = (state = initialState, action) =&gt;
  (dispatchTable[action.type] &amp;&amp;
    dispatchTable[action.type](state, action)) ||
  state;</pre>
			<p>3.5 <strong class="bold">Reducing types</strong>: In the <em class="italic">A React-Redux reducer</em> section, I used JavaScript instead of TypeScript to focus on the details of the needed logic. Can you provide TypeScript versions of <strong class="source-inline">doAction()</strong>, <strong class="source-inline">dispatchTable</strong>, and <strong class="source-inline">doAction2()</strong>? Be sure to describe all needed <span class="No-Break">types, too.</span></p>
			<p>3.6 <strong class="bold">Spot the bug!</strong> A programmer, working with a global store for state (similar in concept to those of Redux, Mobx, Vuex, and others used by different web frameworks), wanted to log (for debugging purposes) all calls to the store’s <strong class="source-inline">set()</strong> method. After creating the new store object, he wrote the following so that the arguments to <strong class="source-inline">store.set()</strong> would be logged before being processed. Unfortunately, the code didn’t work as expected. What’s the problem? Can you spot <span class="No-Break">the mistake?</span></p>
			<pre class="source-code">
window.store = new Store();
const oldSet = window.store.set;
window.store.set = (...data) =&gt; (
  console.log(...data), oldSet(...data)
);</pre>
			<p>3.7 <strong class="bold">Bindless binding</strong>: Suppose that <strong class="source-inline">bind()</strong> was not available; how could you do a polyfill <span class="No-Break">for it?</span></p>
			<p>3.8 <strong class="bold">Mystery sort</strong>: Back in the <em class="italic">Injection – sorting it out</em> section, we mentioned that we could sort numbers with something like <strong class="source-inline">myNumbers.sort((a:number, b:number) =&gt; a-b)</strong> – why/how does <span class="No-Break">this work?</span></p>
			<p>3.9 <strong class="bold">Negative sort</strong>: Earlier, in the <em class="italic">Injection – sorting it out</em> section, we saw that sorting numbers as strings produces unexpected results. What would the result be if the array included both negative and <span class="No-Break">positive numbers?</span></p>
			<p>3.10 <strong class="bold">Lexicographic sorting</strong>: When sorting, say, book titles or personal names, special collation rules are applied. For instance, “THE SHINING” would be sorted as “SHINING, THE,” and “Stephen King” would be sorted as “King, Stephen.” How could you (efficiently) implement <span class="No-Break">such sorting?</span></p>
			<p>3.11 <strong class="bold">Stubbed logging</strong>: In the <em class="italic">Stubbing</em> section, the stubbed <strong class="source-inline">console.log()</strong> method doesn’t have the correct data type – for instance, our version just allows a single argument. Can you provide the right data <span class="No-Break">type definition?</span></p>
		</div>
	</body></html>