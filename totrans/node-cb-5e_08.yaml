- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing with Node.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing enables you to identify bugs in your code quickly and efficiently. Test
    cases should be written to verify that each piece of code yields the expected
    output or results. The added benefit is that these tests can act as a form of
    documentation for the expected behaviors of your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing is a type of testing where individual units of code are tested.
    Small unit tests provide a granular specification for your program to test against.
    Ensuring your code base is covered by unit tests aids the development, debugging,
    and refactoring process by providing a baseline measure of behavior and quality.
    Having a comprehensive test suite can lead to identifying bugs sooner, which can
    save time and money since the earlier a bug is found, the cheaper it is to fix.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will start by introducing some key techniques with the test runner
    built into recent versions of Node.js. We’ll also explore some popular testing
    frameworks. Testing frameworks provide components and utilities such as test runners
    for running automated tests. The later recipes in this chapter will introduce
    other testing concepts – including **stubbing** , **user interface** ( **UI**
    ) testing, and how to configure **continuous integration** ( **CI** ) testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Testing with **node:test**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with Jest
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Puppeteer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring CI tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter assumes that you have Node.js installed, preferably the latest
    version of Node.js 22. You’ll also need access to an editor and browser of your
    choice. Throughout the recipes, we’ll be installing modules from the public **npm**
    registry.
  prefs: []
  type: TYPE_NORMAL
- en: The code for the recipes is available in the book’s GitHub repository ( [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    ) in the **Chapter08** directory.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with node:test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js introduced a built-in test runner in version 18 as an experimental feature,
    subsequently making it stable in version 20. This addition marked a significant
    shift in the Node.js runtime development philosophy away from the “small core”
    to adding more utilities into the runtime itself.
  prefs: []
  type: TYPE_NORMAL
- en: The decision to include a built-in test runner was influenced by a broader industry
    trend toward including more built-in tooling in programming languages and runtimes.
    This shift is partly in response to concerns about security, such as the risks
    associated with dependency vulnerabilities. By providing a native test solution,
    Node.js aims to make testing a first-class citizen within its environment, reducing
    the potential attack surface provided by third-party test runners.
  prefs: []
  type: TYPE_NORMAL
- en: The built-in test runner in Node.js does not have as extensive an API as is
    provided by the many common and popular test frameworks, such as Jest. It was
    designed to be a minimal and lightweight, yet functional, testing utility without
    the overhead of additional features and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: This tutorial will guide you through the basics of using the Node.js built-in
    test runner, demonstrating how it can be leveraged to perform effective testing
    in your projects without the need for a third-party test framework.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll create and use a basic calculator application to demonstrate
    the fundamentals of unit testing with the built-in **node:test** module. Throughout
    the recipe, we’ll be using the **ECMAScript Module** ( **ESM** ) syntax covered
    in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139) .
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create a directory to work in and initialize our project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a file named **calculator.mjs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the following to **calculator.mjs** to create our calculator
    program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have our project directory set up and an application ready to test,
    we can move on to the recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will be adding unit tests using the built-in **node:test**
    module for the small calculator application we created in the *Getting* *ready*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to ensure we’re using a version of Node.js where the **node
    --test** command is available. Enter the following command in your terminal and
    expect to see the test runner execute:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we should create a file named **calculator.test.mjs** , which will contain
    our tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **calculator.test.mjs** , we first need to import the **node:test** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can import the **add()** function from our **calculator.js** program.
    We’ll only import and test the **add()** function as an example:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It can be useful to organize our tests with subtests. To demonstrate this,
    we’ll create a test parent for the **add()** function, which we’ll later add our
    subtests to:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can write our first test case as a subtest. Our first test will pass
    integer test values to the **add()** function and confirm that we get the expected
    results. Add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Run the tests with the **node --test** command in your terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can add a second subtest. This time, we’ll pass the numbers as strings
    rather than integers. This test is expected to fail as our **calculator.mjs**
    program does not contain logic to transform string input into integers. Add the
    following beneath the first subtest:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can run the tests by entering the following command in our terminal
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following output indicating that the first test passed and
    the second test failed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve learned how we can write unit tests for our application using the **node:test**
    module. We’ve executed these tests and produced a **Test Anything Protocol** (
    **TAP** ) summary of the test results.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the provided example utilizing the **node:test** built-in module for Node.js,
    we start by importing the necessary modules using the ESM syntax. This includes
    **test** from **node:test** for testing framework functionalities, **assert**
    from **node:assert** for assertions, and the **add()** function from a local module,
    **calculator.mjs** , which is the function under test.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s crucial to import the **node:test** module by using the **node:** scheme
    prefix, like this: **const test = require(''node:test'');** . This module is one
    of the first to only be exposed via the **node:** prefix. Attempting to import
    it without the **node:** prefix, as in **const test = require(''test'');** , will
    result in an error.'
  prefs: []
  type: TYPE_NORMAL
- en: The tests are structured using the **test()** function, where each test case
    is encapsulated within an asynchronous function. Within each test, subtests are
    defined using **await t.test(...)** , which helps organize the tests hierarchically
    and manage multiple assertions or setup processes cleanly within one test block.
    For asserting conditions, **assert.strictEqual()** is employed to compare the
    expected and actual outcomes, ensuring that both type and value are equal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **node:assert** module in Node.js provides a set of assertion functions
    for verifying invariants, primarily used for writing tests. Key assertions include
    **assert.strictEqual()** , which checks for strict equality between the expected
    and actual values, and **assert.deepStrictEqual()** , which performs a deep equality
    comparison of objects and arrays. The module also offers **assert.ok()** to test
    if a value is **truthy** and **assert.rejects()** and **assert.doesNotReject()**
    for handling promises that should or should not reject. This suite of assertions
    allows developers to enforce expected behaviors and values in code. A full list
    of available assertions is detailed in the Node.js assert module documentation:
    [https://nodejs.org/docs/latest/api/assert.html#assert](https://nodejs.org/docs/latest/api/assert.html#assert)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: To run these tests, the script is executed directly with Node.js by running
    **node --test** in the command line. This approach directly outputs the test results
    to the console, indicating which tests have passed or failed. This method of using
    Node.js’s built-in testing tools simplifies the testing process by eliminating
    the need for external libraries – reducing overhead and minimizing third-party
    dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, our test results were output using the **spec** format. When
    using the **node:test** module with a **terminal interface** ( **TTY** ), the
    default output reporter is set to **spec** . The **spec** reporter formats test
    results in a human-readable manner. If the standard output is not a TTY, the module
    defaults to using the **tap** reporter, which outputs the test results in TAP
    format.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to specify alternate test reporter output using the **--test-reporter**
    command-line flag. Details of the available reporters can be found in the Node.js
    documentation: [https://nodejs.org/docs/latest-v22.x/api/test.html#test-reporters](https://nodejs.org/docs/latest-v22.x/api/test.html#test-reporters)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To further enhance your understanding of the core **node:test** module, let’s
    explore the default file patterns the test runner uses to locate and execute tests,
    along with additional features that streamline the testing process.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Node.js default test file patterns
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Node.js test runner automatically finds and runs test files based on their
    names by looking for files that match specific patterns – essentially, indicators
    that a file is a test. The patterns use wildcards ( ***** ) and optional groups
    ( **?(...)** ) to include various filenames and extensions. The double asterisk
    ( ****** ) means that Node.js searches all directories and subdirectories, so
    no matter where your test files are, they’ll be found as long as they match the
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are common patterns the Node.js test runner searches for by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '****/*.test.?(c|m)js** : This finds files ending with **.test.js** , **.test.cjs**
    , or **.test.mjs** in any directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****/*-test.?(c|m)js** : Like the first pattern, but for files ending with
    **-test.js** , **-test.cjs** , or **-test.mjs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****/*_test.?(c|m)js** catches files ending with **_test.js** , **_test.cjs**
    , or **_test.mjs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****/test-*.?(c|m)js** looks for files starting with **test-** and ending with
    **.js** , **.cjs** , or **.mjs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****/test.?(c|m)js** matches files named exactly **test.js** , **test.cjs**
    , or **test.mjs**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '****/test/**/*.?(c|m)js** digs into any **test** directory and finds files
    with **.js** , **.cjs** , or **.mjs** extensions in any subdirectory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To make sure Node.js can find and run your tests without extra configuration,
    it is advisable to name your test files following these patterns. It keeps your
    project organized and aligns with common Node.js practices.
  prefs: []
  type: TYPE_NORMAL
- en: Filtering tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With the **node:test** module, there are several options for filtering tests
    to manage which ones are executed during a test run. This flexibility is useful
    for focusing on specific tests during development or debugging:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Skipping tests** : Tests can be skipped using the **skip** option or the
    test contexts **skip()** method. This is useful for temporarily disabling a test
    without removing it from the code base. For example, marking a test with **{ skip:
    true }** or using **t.skip()** within the **test()** function will prevent its
    execution:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Marking tests as todo** : When a test is not yet implemented or if it’s known
    to be flaky, it can be marked as **todo** . These tests will still run, but their
    failures won’t count against the test suite’s success. Using the **{ todo: true
    }** option or **t.todo()** can annotate these tests effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Focusing on specific tests** : The **{ only: true }** option is used to focus
    on running specific tests, skipping all others not marked with this option. This
    is particularly useful when needing to isolate a test for scrutiny without running
    the entire suite.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering by test name** : Using the **--test-name-pattern** command-line
    option, tests can be filtered by their names. This is useful when you want to
    run a subset of tests that match a specific naming pattern or convention. Patterns
    are treated as regular expressions. For example, running the test suite with **--test-name-pattern="add"**
    would only execute tests with **"add"** in their name.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Collecting code coverage
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Code coverage** is a key metric used to evaluate the extent to which source
    code is executed during testing, helping developers identify untested parts of
    their code base. In Node.js, enabling code coverage is straightforward, but it’s
    important to note that this feature is currently experimental.'
  prefs: []
  type: TYPE_NORMAL
- en: You can enable it by launching Node.js with the **--experimental-test-coverage**
    command-line flag. This setup automatically collects coverage statistics, which
    are reported after all tests are completed. Coverage for Node.js core modules
    and files within **node_modules** directories is not included in the report.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s possible to control which lines are included for code coverage by using
    annotations:'
  prefs: []
  type: TYPE_NORMAL
- en: '**/* node:coverage disable */** and **/* node:coverage enable */** , which
    exclude specific lines or blocks of code from being counted'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/* node:coverage ignore next */** to exclude the following line'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**/* node:coverage ignore next n */** to exclude the following **n** lines'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coverage results can be summarized by built-in reporters such as **tap** and
    **spec** , or detailed through the **lcov** reporter, which generates a **lcov**
    file suitable for in-depth analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The current implementation of **--experimental-test-coverage** has limitations,
    such as the absence of source map support and the inability to exclude specific
    files or directories from the coverage report.
  prefs: []
  type: TYPE_NORMAL
- en: 'To collect code coverage in the example from the recipe, you can run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Expect to see output like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Terminal window showing a node:test code coverage report](img/B19212_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Terminal window showing a node:test code coverage report
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Testing with Jest* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Configuring Continuous Integration tests* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing module code* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing with Jest
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Jest is a widely adopted open source JavaScript testing framework developed
    by Facebook. It is particularly favored for testing React applications, though
    its versatility extends to Node.js environments. Jest is an opinionated testing
    framework with a host of bundled features.
  prefs: []
  type: TYPE_NORMAL
- en: In this guide, we will explore how to effectively write and structure tests
    using Jest. You’ll learn the key principles of Jest and how to set up your testing
    environment. Additionally, we’ll explore Jest’s capabilities in measuring and
    reporting test coverage to help you understand how well your code base is covered
    by tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will be using Jest to test a program that provides some text utility functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create and initialize our project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need a program to test. Create a file named **textUtils.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following code to **textUtils.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also create a test file named **textUtils.test.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we’ve got our directory and files initialized, we’re ready to move
    on to the recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to write and structure various tests with
    Jest.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to install Jest as a development dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll also update our **npm** test script in our **package.json** file to call
    the **jest** test runner. Change the **"test"** script field to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In **textUtils.test.js** , we first need to import our **textUtils.js** module
    to enable us to test it. Add the following line to the top of the test file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a Jest **describe()** block. Jest **describe()** blocks are used to group
    and structure our tests. Add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **describe()** block, we can start adding our test cases. We use
    Jest’s **test()** syntax to define each test. Our test will use Jest’s assertion
    syntax to verify that when we call our **lowercase()** and **uppercase()** functions
    they produce the expected results. Add the following code within the **describe()**
    block to create the three test cases:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can run our tests. We can run the test by entering the **npm test**
    command in our terminal. Jest will print a summary of our test results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Jest provides a built-in code coverage feature. Running this will show us which
    lines of our program have been covered by the test case. You can enable coverage
    reporting by passing the **--coverage** flag to the Jest executable. Enter the
    following command in your terminal to reference the installed Jest executable
    and report code coverage:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Terminal window showing a Jest code coverage report](img/B19212_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Terminal window showing a Jest code coverage report
  prefs: []
  type: TYPE_NORMAL
- en: Note that the code coverage report states we’ve not covered line 8 in textUtils.js.
    Note that depending on your code formatting, the specific line number may change.
    With this information, we can add a test case to satisfy this line.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following test case to **textUtils.test.js** to cover the missing line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, you can rerun the code coverage report with the following command and
    expect to see our code is now 100% covered:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now created a test for our **textUtils.js** module using Jest and learned
    how to generate code coverage reports.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first line of our **textUtils.test.js** file imports our **textUtils.js**
    module, allowing us to call it when testing.
  prefs: []
  type: TYPE_NORMAL
- en: We organized our tests using Jest’s **describe()** and **test()** functions.
    The **describe()** function is used to define a collection of tests. The **describe()**
    method takes two parameters. The first is a name for the test group, and the second
    parameter is a callback function, which can contain test cases or nested **describe()**
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Jest’s **test()** syntax is used to define a test case. The **test()** method
    accepts two parameters. The first is the test name, and the second is a callback
    function that contains the test logic.
  prefs: []
  type: TYPE_NORMAL
- en: The test logic for this program had just one line, which asserts that when we
    call **uppercase('hello world')** , a **HELLO WORLD** value is returned as expected.
    The assertion uses Jest’s **Expect** bundled assertion library ( [https://www.npmjs.com/package/expect](https://www.npmjs.com/package/expect)
    ). We used the **toBe()** assertion from the **Expect** library to equate the
    two values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Expect** exposes many assertion methods, including **toBe()** , **toContain()**
    , **toThrow()** , and others. A full list of assertions is defined in the **Expect**
    section of Jest’s API documentation [https://jestjs.io/docs/en/expect.html#methods](https://jestjs.io/docs/en/expect.html#methods)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to invert assertions by adding **.not** to our statements,
    as in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: To run our test cases, we call the **jest** test runner, which is located within
    our **node_modules** directory. The Jest executable runs the tests, automatically
    looking for files containing **test.js** . The runner executes our tests and then
    generates an output summary of the results.
  prefs: []
  type: TYPE_NORMAL
- en: In the final step of the recipe, we enabled Jest’s code coverage reporting.
    Code coverage is a measure of how many lines of our program code are touched when
    executing our tests. 100% code coverage means that every line of your program
    is covered by the test suite. This helps you easily detect bugs introduced by
    code changes. Some developers and organizations set acceptable thresholds for
    code coverage and put restrictions in place so that the code coverage percentage
    cannot be regressed.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Jest provides more features **out of the box** ( **OOTB** ) than some of the
    other popular Node.js test libraries. Let’s look at a couple of them.
  prefs: []
  type: TYPE_NORMAL
- en: Setup and teardown
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jest provides setup and teardown functionality for tests. Setup steps can be
    run before each or all tests using the **beforeEach()** and **beforeAll()** functions
    respectively. Similarly, teardown steps can be run after each or all tests with
    the **afterEach()** and **afterAll()** functions respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following pseudocode demonstrates how these functions can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Mocking with Jest
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mocks enable you to test the interaction of your code or functions without having
    to execute the code. Mocks are often used in cases where your tests rely on third-party
    services or APIs, and you do not want to send real requests to these services
    when running your test suite. There are benefits to **mocking** , including faster
    execution of test suites and ensuring your tests are not going to be impacted
    by network conditions.
  prefs: []
  type: TYPE_NORMAL
- en: Jest provides mocking functionality OOTB. We can use a mock to verify that our
    function has been called with the correct parameters, without executing the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we could change the test from the recipe to mock the **uppercase()**
    module with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The **jest.fn(() => 'HELLO');** method returns a new mock function. We assign
    this to a variable named **uppercase** . The parameter is a callback function
    that returns the string **'HELLO'** – this is to demonstrate how we can simulate
    a function’s return value.
  prefs: []
  type: TYPE_NORMAL
- en: The **.toHaveBeenCalled()** method from **Expect** verifies that our mock function
    was called with the correct parameter. If, for some reason, you cannot execute
    a function in your test suite, you can use mocks to validate that the function
    is being called with the correct parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Testing asynchronous code
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Testing asynchronous code is essential in ensuring that Node.js applications
    perform as expected, especially when dealing with operations such as API calls,
    database transactions, or any processes that depend on promise resolution or callbacks.
    Jest provides a clear and straightforward way to handle these asynchronous operations
    in your tests, ensuring they complete before making assertions.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the most common methods to test asynchronous code in Jest is by using
    the **async** / **await** syntax along with Jest’s **.resolves** and **.rejects**
    matchers. For example, consider a **fetchData()** function that returns a promise
    resolving to some data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'You can write a Jest test to verify that **fetchData()** resolves to the expected
    value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: This test will wait for the **fetchData()** promise to resolve, thanks to the
    **await** keyword, and then check that the resolved value matches **'hello'**
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, if you’re working with asynchronous code that uses callbacks,
    you can use Jest’s **done()** callback to handle this pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this test, **done()** is called once the callback receives data, signaling
    to Jest that the test is complete. If there is an error in your expectation, calling
    **done()** with an **error** argument allows Jest to handle the error properly.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Configuring Continuous Integration tests* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Writing module code* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Stubbing HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is common for the Node.js applications you’re building to rely on and consume
    an external service or API. When unit testing, you do not typically want your
    test to send a request to an external service. Requests to the external service
    you’re consuming are metered or rate-limited, and you do not want your test cases
    to consume the allowance.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also possible that your tests would require access to service credentials.
    This means every developer on the project would need access to those credentials
    before they could run the test suite.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to unit test your code without sending a request to an external service,
    you can fake a request and response. This concept is known as stubbing. Stubbing
    can be used to mimic API calls, without sending the request. Stubbing comes with
    the additional benefit of reducing any request latency, potentially making the
    tests run faster than if they were to send real requests.
  prefs: []
  type: TYPE_NORMAL
- en: The test concepts of stubbing and mocking are often confused. Stubbing provides
    predefined responses to isolate the unit under test, while mocking also verifies
    interactions by ensuring methods are called with certain parameters.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we will be using Sinon.js, which is a library that provides stubbing
    functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, let’s set up our directories and files for this recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory and initialize the project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll create a program that sends a request to a third-party service.
    Create a file named **github.mjs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In our **github.mjs** file, we’ll send an HTTP **GET** request to the **https://api.github.com/users/**
    endpoint. Add the following to **github.mjs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have a program that sends an HTTP request to the GitHub API, we
    can move on to the recipe steps, where we’ll learn how to stub the request.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’re going to learn how to stub an HTTP request within our
    tests. But we first need to create a test case. We’ll use **node:test** to save
    having to install an additional test framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named **github.test.mjs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **github.test.mjs** to create a test case using **node:test**
    for the **getGithubUser()** function. This will send a real request to the GitHub
    API:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can run the test to check that it passes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can move on to the [stubbing. We first need to instal](https://www.npmjs.com/package/sinon)
    l **sinon** ( [https://www.npmjs.com/package/sinon](https://www.npmjs.com/package/sinon)
    ) as a development dependency:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in **github.test.mjs** , we need to import **sinon** . Add the following
    just below the line where the **node:test** module is imported:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To be able to stub the request, we need to store the output from the real request
    to the GitHub API. In this case, we’ll create a **fakeResponse** constant to return
    just the values we’re verifying. Add the following to the start of the test case:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to add a line that instructs the test to use the stubbed **fetch()**
    function instead of the real function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After we’ve made our **getGitHubUser('octokit')** call in the test case, we
    should restore the original **fetch()** method so that it can be used by other
    tests or code. We can do this using **sinon.restore();** . Add this below the
    line where we call **getGitHubUser('octokit')** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your full **github.test.mjs** file should now look like the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s rerun the tests and check whether they still pass now that we’re mocking
    the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the **duration_ms** value of this test run is reduced – this is because
    we are not sending a real request over the network.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now learned how to stub an API request using Sinon.js.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, Sinon.js is used to simulate the behavior of a function that
    fetches user data from GitHub’s API. Instead of executing an actual network request,
    which can be slow and consume limited API request quotas, we substitute the global
    **fetch()** method with a “stub.” This **stub()** function is designed to resolve
    with a predetermined object that represents a GitHub user’s data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initially, the necessary modules and utilities are imported: **node:assert**
    for assertions, **node:test** to define the test case, and **sinon** for creating
    a stub. We also import the **getGitHubUser()** function we plan to test.'
  prefs: []
  type: TYPE_NORMAL
- en: Sinon.js is used to create a stub for the global **fetch()** function. The stub
    is designed to return a fake response that resembles what would be expected from
    the actual GitHub API. This fake response is a *promise* that resolves to an object
    with a **json()** method. This, in turn, returns a promise that resolves to an
    object containing the **id** , **login** , and **name** properties of our test
    GitHub user – mimicking the format of the GitHub API response.
  prefs: []
  type: TYPE_NORMAL
- en: When **getGitHubUser()** is invoked with the **octokit** username, the stubbed
    **fetch()** function intercepts the call and returns a fake response. As a result,
    **getGitHubUser** **()** processes this response as if it were a real one from
    the API but without incurring network latency. After the simulated API call, the
    actual **user** object is awaited and then checked against the expected values
    to confirm that the **getGitHubUser()** function handles the response as expected.
  prefs: []
  type: TYPE_NORMAL
- en: After the assertions, **sinon.restore()** is called, which reinstates the original
    **fetch()** method. This ensures that subsequent tests or other parts of the code
    base are not affected by the stubbing of the **fetch()** method in this test.
    This practice ensures the isolation of the test and prevents side effects on other
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe provided a high-level view of the stubbing process by demonstrating
    how to stub a single method with Sinon.js. Stubbing can be used to replace any
    part of the system under test, from individual functions to entire modules, which
    can be particularly useful in a microservice architecture where services may depend
    on responses from other services.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Testing with Jest* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Configuring Continuous Integration tests* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using Puppeteer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: UI testing is a technique used to identify issues with **graphical UIs** ( **GUIs**
    ), particularly in web applications. Although Node.js is primarily a server-side
    platform, it is frequently used to develop web applications, where UI testing
    plays a critical role.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you have an application containing an HTML form, you could use
    UI testing to validate that the HTML form contains the correct set of input fields.
    UI testing can also validate interactions with the interface – such as simulating
    button clicks or hyperlink activations.
  prefs: []
  type: TYPE_NORMAL
- en: Puppeteer is an open source library that provides a headless Chromium instance,
    which can be programmatically interacted with to automate UI tests. It is particularly
    useful for Node.js environments because of its native support and ease of integration.
  prefs: []
  type: TYPE_NORMAL
- en: n the recipe, we will use Puppeteer ( [https://pptr.dev/](https://pptr.dev/)
    ) to perform UI testing on the **http://example.com/** website. However, other
    popular alternatives for UI testing in Node.js include Selenium, Cypress, and
    Playwright. While the high-level principle and purpose of each of these tools
    are similar, each tool has its strengths and can be chosen based on specific needs
    such as cross-browser testing, ease of setup, and integration capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Prepare your development environment for Puppeteer by setting up a new project
    directory and creating an initial test file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a directory and initialize our project directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create our UI test file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have our project directory initialized, we’re ready to move on to
    the recipe steps.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’ll learn how to test a web page using Puppeteer. We’re going
    to verify that we receive the expected content from **https://example.com** .
    We’ll use the Node.js core **assert** library for the assertion logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step is to install the **puppeteer** module. We’ll install the **puppeteer**
    module as a development dependency as it’ll only be used for testing:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this may take a long time as it is downloading the Chromium headless
    browser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Next, we’ll open **test.js** and add the following lines to import both the
    **assert** and **puppeteer** modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create an asynchronous function named **runTest()** , which will
    hold all our test logic:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Within the **runTest()** function, we need to launch Puppeteer. Do this by
    adding the following line, which calls Puppeteer’s **launch()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, also inside the **runTest()** function, we need to create a new Puppeteer
    browser page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can now instruct Puppeteer to load a URL. We do this by calling the **goto()**
    function on the **page** object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we’ve got a handle to the web page ( **https://example.com** ), we
    can extract values from the web page by calling Puppeteer’s **$eval()** function.
    We supply the **$eval()** function the **h1** tag, indicating that we want to
    abstract the **h1** element and a callback function. The callback function will
    return the **innerText** value of the **h1** element. Add the following line to
    extract the **h1** value:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add our assertion. We expect the title to be **"Example Domain"**
    . Add the following assertion statement. We’ll also add a **console.log()** statement
    to output the value – you wouldn’t typically do this in a real test case to avoid
    noise in **STDOUT** , but it will help us see what is happening:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to call **browser.close()** ; otherwise, Puppeteer will continue emulating,
    and the Node.js process will never exit. Within the **runTest()** function, add
    the following line:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we just need to call our **runTest()** function. Add the following
    to the bottom of **test.js** , outside of the **runTest()** function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’re now ready to run the test. Enter the following command in your terminal
    to run the test:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now created our first UI test using Puppeteer.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we used Puppeteer to create a test that verifies that the **https://example.com**
    web page returns the heading **'Example Domain'** within an **h1** HTML element
    tag. Most of the Puppeteer APIs are asynchronous, so we used the **async** / **await**
    syntax throughout the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: When we call **puppeteer.launch()** , Puppeteer initializes a new headless Chrome
    instance that we can interact with via JavaScript. As testing with Puppeteer has
    the overhead of a headless Chrome instance, using it for testing can be less performant
    than other types of tests. However, as Puppeteer is interacting with Chrome under
    the hood, it provides a very close simulation of how end users interact with a
    web application.
  prefs: []
  type: TYPE_NORMAL
- en: Once Puppeteer was launched, we initialized a **page** object by calling the
    **newPage()** method on the **browser** object. The **page** object is used to
    represent a web page. On the **page** object, we then called the **goto()** method,
    which is used to tell Puppeteer which URL should be loaded for that object.
  prefs: []
  type: TYPE_NORMAL
- en: The **$eval()** method is called on the **page** object to extract values from
    the web page. In the recipe, we passed the **$eval()** method **h1** as the first
    parameter. This instructs Puppeteer to identify and extract the HTML **<h1>**
    element. The second parameter is a callback function, which extracts the **innerText**
    value of the **<h1>** element. For **http://example.com** , this extracted the
    **'Example** **Domain'** value.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the **runTest()** function, we called the **browser.close()**
    method to instruct Puppeteer to end the Chrome emulation. This was necessary since
    Puppeteer will continue emulating Chrome with the Node.js process never exiting.
  prefs: []
  type: TYPE_NORMAL
- en: This is a simplistic example, but it serves as a foundation for understanding
    how UI testing automation works. This test script is easily extendable, allowing
    the simulation of more complex user interactions such as form submissions, navigation,
    and error handling.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It’s also possible to run Puppeteer in non-headless mode. You can do this by
    passing a parameter to the **launch()** method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: In this mode, when you run your tests, you will see the Chromium UI and can
    follow your tests while they are executing. This can be useful when debugging
    your Puppeteer tests.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Testing with Jest* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Configuring Continuous Integration tests* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring Continuous Integration tests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI is a development practice where developers regularly merge their code to
    a source repository. To maintain the integrity of the source code, automated tests
    will often be run before each code change is accepted.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub is one of the most widely used source code repository hosts. With GitHub,
    when you wish to merge a change into the main Git branch or repository, you open
    a **pull request** ( **PR** ). GitHub provides features for you to configure checks
    that should run on each PR. It’s common, and good practice, to require a PR to
    have a passing run of the application’s or module’s unit tests before it can be
    accepted.
  prefs: []
  type: TYPE_NORMAL
- en: There are many CI products that can enable the execution of your unit tests
    (GitHub Actions, Travis CI, and many others). Most of these programs come with
    a limited free tier for casual developers and paid commercial plans for businesses
    and enterprises.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will learn how to configure GitHub Actions to run our Node.js
    tests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, you’ll need a GitHub account. If you’re unfamiliar with Git
    and GitHub, refer to the *Scaffolding a module* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
    .
  prefs: []
  type: TYPE_NORMAL
- en: To be able to configure GitHub Actions to run unit tests, we first need to create
    a GitHub repository and some example unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new GitHub repository via [https://github.com/new](https://github.com/new)
    . Name the new repository **enabling-actions** . Also, add the *Node* **.gitignore**
    template via the drop-down menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Clone your GitHub repository with the following command, replacing **<username>**
    with your GitHub username:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We now need to initialize our project with **npm** and install the **tape**
    test library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to create a test. Create a file named **test.mjs** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **test.mjs** to create our unit tests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have our project initialized and some unit tests, we can move on
    to configuring GitHub Actions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’re going to learn how to configure CI to run our unit tests
    when a new change is pushed to our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a GitHub Actions workflow file in our repository. Create
    a **.** **github/workflows** directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to the **test.yml** file. This will instruct GitHub Actions
    to run our tests using Node.js 20. Be aware that YAML files are sensitive to both
    whitespace and indentation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’re ready to commit our code. Enter the following in your terminal to
    commit the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Navigate to **https://github.com/<username>/enabling-actions** in your browser
    and confirm your code has been pushed to the repository. Expect it to look like
    the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.3 – GitHub UI showing the code in the enabling-actions repository](img/B19212_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – GitHub UI showing the code in the enabling-actions repository
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the test run has completed, GitHub Actions will indicate that the build
    is failing. This is intentional, as we purposely created a test case that is expected
    to fail. This is indicated by a red cross icon. When clicking this icon, we’ll
    see more details about the test run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Failed GitHub Actions build modal](img/B19212_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Failed GitHub Actions build modal
  prefs: []
  type: TYPE_NORMAL
- en: 'Click **Details** , and it’ll take you to the **Actions** tab for that test
    run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 8.5 – GitHub Actions build log](img/B19212_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – GitHub Actions build log
  prefs: []
  type: TYPE_NORMAL
- en: Observe that we can see the specific step that failed, **Run node --test** .
    You should be able to click on each step to expand and view the logs.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve successfully enabled GitHub Actions CI on our GitHub repository.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the GitHub Actions workflow configuration for a Node.js application, we outlined
    a specific CI process designed to automate testing upon commits and PRs to the
    main branch. Here’s a detailed breakdown of how the workflow functions, illustrated
    with code snippets from the **test.yml** file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The workflow starts with the definition of event triggers under the **on**
    key in the YAML file. It is set to activate on **push** and **pull_request** events
    specifically targeting the **main** branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: This snippet ensures that any code pushed to **main** or any PRs made to **main**
    will initiate the CI process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we define the job environment and specify the Node.js versions to test
    against using a matrix strategy. This approach allows testing across multiple
    versions, enhancing compatibility verification:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the test matrix to test across multiple versions, we can expect
    to see an interface similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – GitHub Actions jobs showing builds on Node.js 20 and 22](img/B19212_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – GitHub Actions jobs showing builds on Node.js 20 and 22
  prefs: []
  type: TYPE_NORMAL
- en: 'The **runs-on: ubuntu-latest** step specifies that the job should run on the
    latest available version of Ubuntu. The **matrix.node-version** is initially set
    to test on Node.js 20, but it’s extended to also include Node.js 22, demonstrating
    how easily additional versions can be incorporated into the testing strategy.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the environment setup, the workflow includes steps to check out the
    code, setup Node.js, install dependencies, and run tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: The **actions/checkout@v4** step checks out the repository contents into the
    GitHub Actions runner, allowing the workflow to access the code. The **actions/setup-node@v4**
    step configures the runner to use a specific version of Node.js as defined by
    the matrix.
  prefs: []
  type: TYPE_NORMAL
- en: By integrating these steps, the GitHub Actions workflow automates the testing
    process, ensuring that all new code integrated into the **main** branch has passed
    through a rigorous testing process. This not only ensures code quality but also
    helps in identifying issues early in the development cycle, making it easier to
    manage and fix them.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub branch protection
  prefs: []
  type: TYPE_NORMAL
- en: It’s possible to configure GitHub to block PRs until they have a passing build/CI
    run. This can be configured in the settings of your GitHub repository. For information
    on how to configure branch protection, refer to [https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches](https://docs.github.com/en/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches)
    .
  prefs: []
  type: TYPE_NORMAL
- en: GitHub Actions, as with the alternative CI providers, offers a powerful and
    flexible platform for automating workflows across a wide range of development
    tasks. While this tutorial focused on setting up a CI workflow for a typical Node.js
    application, the scope of GitHub Actions extends far beyond this, allowing for
    a multitude of complex workflows.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Testing with node:test* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Scaffolding a module* recipe in [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
