- en: WebGL 2 Highlights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this book, we have covered the foundations of computer graphics with WebGL
    2, the web-based 3D Graphics API that ships with all modern browsers. We learned
    that WebGL 1 is based on OpenGL ES 2.0, while WebGL 2 is based on OpenGL ES 3.0,
    which guarantees many features that are offered in WebGL 1 as *optional* extensions,
    along with many other powerful methods. Although we’ve used WebGL 2 to learn a
    wide range of computer graphics topics, almost all that knowledge and all of those
    skills translate to other graphics APIs. That being said, let’s take a moment
    to cover the key features that WebGL 2 provides over WebGL 1, along with a strategy
    for migration from WebGL 1 to WebGL 2.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A more extensive look at the WebGL 2 API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: New additions to the WebGL 2 core specification
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A strategy for migrating 3D applications from WebGL 1 to WebGL 2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What's New in WebGL 2?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As of January 27, 2016, WebGL 2 is available by default in Firefox and Chrome.
    This means that you will automatically have access to WebGL 2 without any additional
    dependencies, as long as you use one of the following browsers:'
  prefs: []
  type: TYPE_NORMAL
- en: Firefox 51 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Google Chrome 56 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chrome for Android 64 or above
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: WebGL 2 Support
  prefs: []
  type: TYPE_NORMAL
- en: For an updated list of the browsers that support WebGL 2, please visit the Khronos
    Group web page by following this link: [http://www.khronos.org/WebGL/wiki/Getting_a_WebGL_Implementation](http://www.khronos.org/webgl/wiki/Getting_a_WebGL_Implementation). Or,
    you can visit the well-known **CanIUse.com** resource at: [https://caniuse.com/#search=WebGL
    2](https://caniuse.com/#search=webgl2).
  prefs: []
  type: TYPE_NORMAL
- en: As described in [Chapter 1](48a27fb2-f17b-43b2-8706-ab638a32b7ff.xhtml), *Getting
    Started*, WebGL 1 is based on OpenGL ES 2.0; therefore, it doesn’t expose features
    like query timers, compute shaders, uniform buffers, and so on. That being said,
    with WebGL 2 (based on OpenGL ES 3.0), we are getting access to more GPU features
    like instancing and multiple render targets. Since WebGL 2 is a considerable upgrade
    from WebGL 1, let’s highlight some of its important features.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Array Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As described in [Chapter 2](d2019a49-9e84-448c-8799-e296187476d1.xhtml), *Rendering*,
    we can implement **vertex array objects** in WebGL 1 by using the `OES_vertex_array_object` extension.
    That being said, they are available by default in WebGL 2. This is an important
    feature that should alwaysbe used, since it significantly reduces rendering times.
    When not using vertex array objects, all attributes data is in a global WebGL
    state, which means that calling functions such as `gl.vertexAttribPointer`, `gl.enableVertexAttribArray`,
    and `gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffer)` manipulates the global state.
    This leads to performance loss, because before any draw call, we would need to
    set up all vertex attributes and set the `ELEMENT_ARRAY_BUFFER` where indexed
    data is being used. On the other hand, with vertex array objects, we would set
    up all attributes during our application's initialization and simply bind the
    data during rendering, yielding much better performance.
  prefs: []
  type: TYPE_NORMAL
- en: This is very similar to the `IDirect3DVertexDeclaration9`/`ID3D11InputLayout` interfaces
    in DirectX land.
  prefs: []
  type: TYPE_NORMAL
- en: '| WebGL 1 with Extension | WebGL 2 |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `createVertexArrayOES` | `createVertexArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `deleteVertexArrayOES` | `deleteVertexArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `isVertexArrayOES` | `isVertexArray` |'
  prefs: []
  type: TYPE_TB
- en: '| `bindVertexArrayOES` | `bindVertexArray` |'
  prefs: []
  type: TYPE_TB
- en: 'An example of this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Wider Range of Texture Formats
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While WebGL 1 had a limited set of texture formats, WebGL 2 provides a much
    larger set, some of which are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `RGBA32I` | `RG8` | `RGB16UI` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGBA32UI` | `RG8I` | `RGB8_SNORM` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGBA16I` | `RG8UI` | `RGB8I` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGBA16UI` | `R32I` | `RGB8UI` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGBA8` | `R32UI` | `SRGB8` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGBA8I` | `R16I` | `R11F_G11F_B10F` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGBA8UI` | `R16UI` | `RGB9_E5` |'
  prefs: []
  type: TYPE_TB
- en: '| `SRGB8_ALPHA8` | `R8` | `RG32F` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGB10_A2` | `R8I` | `RG16F` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGB10_A2UI` | `R8UI` | `RG8_SNORM` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGBA4` | `RGBA32F` | `R32F` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGB5_A1` | `RGBA16F` | `R16F` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGB8` | `RGBA8_SNORM` | `R8_SNORM` |'
  prefs: []
  type: TYPE_TB
- en: '| `RGB565` | `RGB32F` | `DEPTH_COMPONENT32F` |'
  prefs: []
  type: TYPE_TB
- en: '| `RG32I` | `RGB32I` | `DEPTH_COMPONENT24` |'
  prefs: []
  type: TYPE_TB
- en: '| `RG32UI` | `RGB32UI` | `DEPTH_COMPONENT16` |'
  prefs: []
  type: TYPE_TB
- en: '| `RG16I` | `RGB16F` |  |'
  prefs: []
  type: TYPE_TB
- en: '| `RG16UI` | `RGB16I` |  |'
  prefs: []
  type: TYPE_TB
- en: 3D Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **3D texture **is a texture in which each mipmap level contains a single three-dimensional
    image. A 3D texture is essentially just a stack of 2D textures that can be sampled
    with `x`, `y`, and `z` coordinates in the shader. This functionality allows us
    to have multiple 2D textures in a single object so that shaders can seamlessly
    select which image to use for each object.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful for visualizing volumetric data (like medical scans), 3D effects
    like smoke, storing lookup tables, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Texture Arrays
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Texture arrays**, similar to 3D textures, are a great feature for reducing
    complexity, improving code maintainability, and increasing the number of textures
    that can be used. By ensuring that all texture slices in a texture array are the
    same size, shaders can have access to many textures with a smaller footprint.'
  prefs: []
  type: TYPE_NORMAL
- en: Instanced Rendering
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WebGL 2, **instancing** or **instanced rendering** is available by default*. *Instance
    rendering is a way to execute the same drawing commands many times in a row, with
    each producing a slightly different result. This can be a very efficient method
    for rendering a large amount of geometry with very few API calls.
  prefs: []
  type: TYPE_NORMAL
- en: Instancing is a great performance booster for certain types of geometry, especially
    objects with many instances but without many vertices. Good examples are grass
    and fur. Instancing avoids the overhead of an individual API call per object,
    while minimizing memory costs by avoiding storing geometric data for each separate
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a quick example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Non-Power of 2 Texture Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we saw in [Chapter 7](1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml), *Textures**,*mipmaps are
    a powerful feature in which pre-calculated, optimized sequences of images, each
    of which is a progressively lower-resolution representation of the same image,
    allow for more optimized rendering. While in WebGL 1 the height and width of each
    image, or level, in the mipmap is a power of two smaller than the previous level,
    in WebGL 2, that limit is removed. That is, **non-power of 2 textures** work the
    same as power of 2 textures.
  prefs: []
  type: TYPE_NORMAL
- en: Fragment Depth
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WebGL 2, we can manually set our own custom values to the depth buffer (z-buffer).
    This feature allows you to manipulate the depth of a fragment from the fragment
    shader. This can be expensive, because it forces the GPU to bypass a lot of it's
    normal fragment discard behavior, but can also allow for some interesting effects
    that would be difficult to accomplish without having incredibly high poly geometry.
  prefs: []
  type: TYPE_NORMAL
- en: Texture Size in Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WebGL 2, you can look up the size of any texture within ESSL shaders using `textureSize`.
    With WebGL 1, you'd need to create a uniform and pass the data into the shader
    manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Sync Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With WebGL 1, the path from Javascript to GPU to screen is fairly opaque to
    developers. That is, you dispatch draw commands and at some undefined point in
    the future, the results show up on the screen. In WebGL 2, **sync objects** allow
    the developer to gain a little more insight into when the GPU has completed it's
    work. Using `gl.fenceSync`, you can place a marker at some point in the GPU command
    stream and then later call `gl.clientWaitSync` to pause Javascript execution until
    the GPU has completed all commands up to the fence. Obviously blocking execution
    isn't desirable for applications that want to render fast, but this can be very
    beneficial for getting accurate benchmarks. It may also possibly be used in the
    future for synchronizing between workers.
  prefs: []
  type: TYPE_NORMAL
- en: Direct Texel Lookup
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It's often convenient to store large arrays of data in a texture. This is possible
    in WebGL 1, but you can only address textures with texture coordinates inside
    a range spanning from `0.0` to `1.0`. In WebGL 2, accessing this sort of data
    is considerably easier, as you can easily look up values from a texture with pixel/texel
    coordinates.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Flexible Shader Loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WebGL 1, loops in the shader had to use a constant integer expression. However,
    since WebGL 2 is based on OpenGL ES 3.0, this limit no longer exists.
  prefs: []
  type: TYPE_NORMAL
- en: Shader Matrix Functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that WebGL 2's shading language is much more feature-rich than WebGL 1's,
    we now have many more matrix math operations at our fingertips. For example, if
    an `inverse` or `transpose` of a matrix is needed, we would need to pass it in
    as a uniform. However, in WebGL 2, functions such as `inverse`and `transpose` are
    functions directly built into shaders.
  prefs: []
  type: TYPE_NORMAL
- en: Common Compressed Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In WebGL 1, there are various compressed texture formats that are hardware-dependent.
    For example, formats such as `S3TC` and `PVTC` are desktop and iOS only, respectively.
    However, in WebGL 2, the following formats are much more flexible by being hardware
    independent:'
  prefs: []
  type: TYPE_NORMAL
- en: '`COMPRESSED_R11_EAC RED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMPRESSED_SIGNED_R11_EAC RED`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMPRESSED_RG11_EAC RG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMPRESSED_SIGNED_RG11_EAC RG`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMPRESSED_RGB8_ETC2 RGB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMPRESSED_SRGB8_ETC2 RGB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 RGBA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMPRESSED_RGBA8_ETC2_EAC RGBA`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`COMPRESSED_SRGB8_ALPHA8_ETC2_EAC`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uniform Buffer Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Setting shader program uniforms is a huge part of almost any WebGL/OpenGL draw
    loop. This can make your draw calls fairly chatty as they make hundreds or thousands
    of `gl.uniform` calls.
  prefs: []
  type: TYPE_NORMAL
- en: In WebGL 1, if we have `n` number of uniforms that need to be updated, then
    it would require `n` number of calls with the appropriate uniform method—this
    can be quite slow. However, with WebGL 2, we can use **uniform buffer objects****, **which
    allow us to specify a large number of uniforms from a single buffer. This is a
    major boost in performance, since we can manipulate uniforms in the buffer outside
    of WebGL by using JavaScript-typed arrays and updating a set of uniforms with
    a single call. Additionally, uniform buffers can be bound to multiple programs
    at the same time, so it's possible to update global data (like projection or view
    matrices) once and all programs that use them will automatically see the changed
    values.
  prefs: []
  type: TYPE_NORMAL
- en: '**Heterogeneous Uniform Buffer Objects** It''s important to note that, in a
    given application, you can leverage a diverse set of uniform buffer objects to
    fit your application''s needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Integer Textures and Attributes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in WebGL 1 textures and attributes are represented as floating-point values,
    regardless of their original type, in WebGL 2, textures and attributes are provided
    integer representation.
  prefs: []
  type: TYPE_NORMAL
- en: Transform Feedback
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A powerful technique offered in WebGL 2 is that vertex shaders can write their
    results back into a buffer. This can be very useful in situations where we want
    to leverage the GPU's computational power to perform complex computations so that
    we are able to read them within our application.
  prefs: []
  type: TYPE_NORMAL
- en: Sampler Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in WebGL 1 all texture parameters are *per texture*, in WebGL 2, we can
    optionally use **sampler objects**. By using samplers, we can move all texture
    parameters to a sampler, allowing a single texture to be sampled in different
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: In WebGL 1, texture image data and sampling information (which tells GPU how
    to read the image data) are both stored in texture objects. It can be painful
    when we want to read from the same texture twice but with a different method (say,
    linear filtering vs nearest filtering) because we need to have two texture objects.
    With sampler objects, we can separate these two concepts. We can have one texture
    object and two different sampler objects. This will result in a change in how
    our engine organize textures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Depth Textures
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A major drawback to WebGL 1 is the lack of support for **depth textures**. In
    WebGL 2, they are available by default.
  prefs: []
  type: TYPE_NORMAL
- en: Standard Derivatives
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in WebGL 1 you'd need to compute normal and pass them to shaders, in WebGL
    2, you can compute them within shaders by using a larger set of mathematical operations
    that are available by default.
  prefs: []
  type: TYPE_NORMAL
- en: UNSIGNED_INT Indices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WebGL 2, there isn't a practical size limit for indexed geometries since
    we can use 32-bit `int` for indices.
  prefs: []
  type: TYPE_NORMAL
- en: Blend Equation MIN / MAX
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WebGL, you can easily take the `MIN` or `MAX` of two colors when blending
    using these added functions.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple Render Targets (MRT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WebGL 2, you can draw to multiple buffers at once from a shader. This can
    be quite powerful for various deferred rendering techniques. This is "the big
    one" for many developers, because it makes many of the modern deferred rendering
    techniques that have become such a core part of modern realtime 3D practical for
    WebGL.
  prefs: []
  type: TYPE_NORMAL
- en: Texture Access in Vertex Shaders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While accessing textures within vertex shaders is possible in WebGL 1, you would
    need to count how many textures you could access, and that could equal zero. In
    WebGL 2, texture access is much more streamlined, and the texture access count
    is required to be at least `16`.
  prefs: []
  type: TYPE_NORMAL
- en: Multi-Sampled Renderbuffers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in WebGL 1 we could only use the GPU's built in multi-sample system to
    anti-alias our `canvas`, in WebGL 2, there is support to perform our own custom
    multi-sampling.
  prefs: []
  type: TYPE_NORMAL
- en: Query Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Query objects** give developers another, more explicit way to peek at the
    inner workings of the GPU. A query wraps a set of GL commands for the GPU to asynchronously
    report some sort of statistic about. For example, occlusion queries are done in
    the following way: performing a `gl.ANY_SAMPLES_PASSED` query around a set of
    draw calls will let you detect if any of the geometry passed the depth test. If
    not, you know that the object wasn''t visible and may choose not to draw that
    geometry in future frames until something happens (object moved, camera moved,
    and so on) that indicates that the geometry might have become visible again.'
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that these queries are asynchronous, which means that a queries'
    results may not be ready for many frames after the query was originally issued!
    This makes them tricky to use, but it can be worth it in the right circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Texture LOD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **texture LOD** parameter is used to determine which mipmap to fetch from.
    This allows for mipmap streaming, that is, loading only the mipmap levels currently
    needed. This is very useful for a WebGL environment, where textures are downloaded
    via a network.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Shader Texture LOD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Shader Texture LOD** bias control makes mipmap level control simpler for
    glossy environment effects in physically-based rendering. Now as part of the WebGL
    2 core, the `lodBias` can be passed as an optional parameter to texture.
  prefs: []
  type: TYPE_NORMAL
- en: Floating Point Textures Always Available
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in WebGL 1, floating point textures are optional*,* but in WebGL 2, they
    are available by default.
  prefs: []
  type: TYPE_NORMAL
- en: Migrating to WebGL 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we described previously, WebGL 2 is nearly 100 percent backward compatible
    with WebGL 1.
  prefs: []
  type: TYPE_NORMAL
- en: Backward Compatibility
  prefs: []
  type: TYPE_NORMAL
- en: All exceptions to backward compatibility are recorded at the following link: [https://www.khronos.org/registry/WebGL/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY](https://www.khronos.org/registry/webgl/specs/latest/2.0/#BACKWARDS_INCOMPATIBILITY).
  prefs: []
  type: TYPE_NORMAL
- en: That being said, let's cover some key components of migrating a WebGL 1 application
    to WebGL 2.
  prefs: []
  type: TYPE_NORMAL
- en: Attaining context
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In WebGL 1, you''d attain a WebGL context with something that looks like the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'In WebGL 2, you''d simply attain the context with a single line, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While in WebGL many optionalextensions were *required* for more advanced functionality,
    in WebGL 2 you can remove most of those extensions, because they are available
    by *default*. Some of these include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Depth textures: [https://www.khronos.org/registry/WebGL/extensions/WebGL_depth_texture](https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Floating point textures:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.khronos.org/registry/WebGL/extensions/OES_texture_float](https://www.khronos.org/registry/webgl/extensions/OES_texture_float)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.khronos.org/registry/WebGL/extensions/OES_texture_float_linear](https://www.khronos.org/registry/webgl/extensions/OES_texture_float_linear)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertex array objects: [https://www.khronos.org/registry/WebGL/extensions/OES_vertex_array_object](https://www.khronos.org/registry/webgl/extensions/OES_vertex_array_object)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Standard derivatives: [https://www.khronos.org/registry/WebGL/extensions/OES_standard_derivatives](https://www.khronos.org/registry/webgl/extensions/OES_standard_derivatives)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instanced drawing: [https://www.khronos.org/registry/WebGL/extensions/ANGLE_instanced_arrays](https://www.khronos.org/registry/webgl/extensions/ANGLE_instanced_arrays)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`UNSIGNED_INT` indices: [https://www.khronos.org/registry/WebGL/extensions/OES_element_index_uint](https://www.khronos.org/registry/webgl/extensions/OES_element_index_uint)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting gl_FragDepth: [https://www.khronos.org/registry/WebGL/extensions/EXT_frag_depth](https://www.khronos.org/registry/webgl/extensions/EXT_frag_depth)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Blend equation `MIN`/`MAX`: [https://www.khronos.org/registry/WebGL/extensions/EXT_blend_minmax](https://www.khronos.org/registry/webgl/extensions/EXT_blend_minmax)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct texture LOD access: [https://www.khronos.org/registry/WebGL/extensions/EXT_shader_texture_lod](https://www.khronos.org/registry/webgl/extensions/EXT_shader_texture_lod)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple draw buffers: [https://www.khronos.org/registry/WebGL/extensions/WebGL_draw_buffers](https://www.khronos.org/registry/webgl/extensions/WEBGL_draw_buffers)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Texture access in vertex shaders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Shader Updates
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While WebGL 2's shader language, based on GLSL 300, is backward compatible with
    WebGL 1's shader language, we need to make a few changes to ensure that our shaders
    compile. Let's cover them now.
  prefs: []
  type: TYPE_NORMAL
- en: Shader Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With WebGL 2's shaders, we have to prepend all shaders with the following line
    of code: `#version 300 es`. It’s important to note that this *must *be the very
    first line in the shader, otherwise the shader will not compile.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Given that attributes are *provided as inputs *to shaders, in GLSL 300 ES,
    the `attribute` qualifier is removed. For example, with WebGL''s GLSL 100, you
    might have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'In GLSL 300 ES, this would be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Varying Definitions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While in GLSL 100, varyings are often defined in both the vertex and fragment
    shaders, the `varying` qualifier has been removed in GLSL 300 ES. That is, varying
    qualifiers are updated with their appropriate `in` and `out` qualifiers, depending
    on whether the values are provided as *inputs* or returned as *outputs*. For example,
    consider the following from GLSL 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be changed to the following in GLSL 300 ES:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: No More gl_FragColor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While in GLSL 100 you''d ultimately render the color of the pixel by setting
    the `gl_FragColor` inside of the fragment shader, in GLSL 300 ES, you simply expose
    a value from your fragment shader. Consider, for example, the following in GLSL
    100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be updated by setting a defined custom output variable, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: It's important to note that even though we declared a variable called `fragColor`,
    you can choose any name not starting with the prefix `gl_`, due to ambiguity.
    Throughout this book, we have defined this custom variable as `fragColor`.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Texture Type Detection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While in GLSL 100 you''d get a color from a texture by using the appropriate
    methods, such as `texture2D`, in GLSL 300 ES, shaders automatically detect the
    type based on the sampler type in use. For example, consider the following in
    GLSL 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This would be updated to the following in GLSL 300 ES:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Non-Power of 2 Texture Support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As demonstrated in [Chapter 7](1455f0ba-ecbd-463d-bd1b-6c91fa910b26.xhtml), *Textures*, in
    WebGL 1, mipmaps don't exist for textures that don't conform to the *power of
    2* restriction. In WebGL 2, however, non-power of 2 textures work exactly the
    same as power of 2 textures.
  prefs: []
  type: TYPE_NORMAL
- en: Floating Point Framebuffer Attachments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While in WebGL 1 a strange hack is required to check whether there is support
    for rendering to a floating point texture, in WebGL 2, this involves a simple
    check via standard methods.
  prefs: []
  type: TYPE_NORMAL
- en: Vertex Array Objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While using vertex array objects is not a *necessary *requirement, it's a highly *recommended *feature
    to use in your migration. By using vertex array objects, you can improve both
    the overall structure of your code and the performance of your application.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let’s summarize what we’ve learned in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: We covered many of the core methods available only in the WebGL 2 specification.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We learned some of the key differences between WebGL 1 and WebGL 2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We discussed migration strategies for converting a WebGL 1 application to WebGL
    2.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We're nearly done! Can you believe it? Up next, in the final chapter, *Journey
    Ahead*, we will conclude this book by laying out a roadmap of concepts, resources,
    and other useful pieces of information that are both inspiring and empowering,
    to help you continue down the path of mastering real-time computer graphics.
  prefs: []
  type: TYPE_NORMAL
