- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Super Speed – Time-Travel Paradoxes and Broken Promises
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 超级速度 – 时空悖论和未兑现的承诺
- en: In this chapter, we will discuss how we deal with issues that arise with multithreaded
    execution in an event loop of a test framework. Then, we’ll look at a way to keep
    the switches in a framework in a consistent location when we begin to add more
    complex functionality.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论我们如何处理在测试框架的事件循环中多线程执行时出现的问题。然后，我们将探讨当我们开始添加更复杂的功能时，如何保持框架中的开关在一致的位置。
- en: JavaScript is an insanely fast programming language. Because its primary goal
    is to build website pages as fast as possible, it executes lines of code in an
    event loop with multiple threads. This is an advantage in building web pages as
    fast as possible, but it can be a hindrance in test automation that needs events
    executed in a particular order.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 是一种疯狂快速的编程语言。因为它的主要目标是尽可能快地构建网站页面，它使用多线程在事件循环中执行代码行。这在尽可能快地构建网页方面是一个优势，但在需要按特定顺序执行事件的测试自动化中可能会成为障碍。
- en: In fact, this speedster is so fast it can time travel. Let us take a look at
    an example in the next section.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，这个速度极快的家伙甚至可以穿越时空。让我们在下一节中看看一个例子。
- en: 'Before we do that, here''s a list of the topics we''ll cover in this chapter:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们这样做之前，这里是我们将在本章中涵盖的主题列表：
- en: The time-travel dilemma
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 时空困境
- en: Schrödinger and the quantum mechanics of test automation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 薛定谔和测试自动化的量子力学
- en: Callbacks, promises, and async/await
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回调、Promise 和 async/await
- en: The death of fibers and synchronous mode
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纤维的死亡和同步模式
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'All test examples can be found at this GitHub repository: [https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO](https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO).'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试示例都可以在这个 GitHub 仓库中找到：[https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO](https://github.com/PacktPublishing/Enhanced-Test-Automation-with-WebdriverIO)。
- en: The time-travel dilemma
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 时空困境
- en: 'Let’s begin with the most basic script – login. Open `login.page.ts` in the
    `\pageobjects` folder. Note there is an `async` command in the `login()` function:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从最基本的脚本开始 – 登录。在 `\pageobjects` 文件夹中打开 `login.page.ts`。注意 `login()` 函数中有一个
    `async` 命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The `async` keyword forces the function to always be asynchronous, returning
    a `Promise` object representing the completion or failure of the function. There
    is also an `await` keyword preceding the `.setValue` and `.click` commands, which
    pauses the function until the `Promise` object is resolved or rejected. What would
    happen if the `await` command were removed?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 关键字强制函数始终是异步的，返回一个表示函数完成或失败的 `Promise` 对象。在 `.setValue` 和 `.click`
    命令之前还有一个 `await` 关键字，它暂停函数直到 `Promise` 对象被解决或拒绝。如果移除 `await` 命令会发生什么？'
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'From the Visual Studio Code shell, run the `wdio` test:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Visual Studio Code 命令行运行 `wdio` 测试：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'When the test is executed, it fails! It indicates that the username provided
    was invalid in the following results, which leads us down a rabbit hole because
    the password is in fact perfectly valid:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当测试执行时，它失败了！这表明在以下结果中提供的用户名无效，这让我们陷入了一个兔子洞，因为密码实际上是完全有效的：
- en: '[PRE3]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: So, what changed? The execution order of the lines of code! Without the `await`
    keyword, Node.js will execute all the JavaScript commands simultaneously. So,
    the `You are logged into a secure area!`. It fails because the `Username` field
    was completely populated. It instead reports `Your username is invalid` because
    the username was still blank when the **Submit** button was clicked.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，发生了什么变化？代码的执行顺序！没有 `await` 关键字，Node.js 将会同时执行所有 JavaScript 命令。所以，“您已登录到安全区域！”失败了，因为“用户名”字段被完全填充。相反，它报告“您的用户名无效”，因为当**提交**按钮被点击时，用户名仍然是空的。
- en: 'Of course, the best superhero detectives need more evidence. No one thought
    to take a picture at the scene of the crime. So, let’s add some debugging output
    and try the test again:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，最好的超级英雄侦探需要更多的证据。没有人想到在犯罪现场拍照。所以，让我们添加一些调试输出并再次尝试测试：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'This time, the results show the test passed. However, we have now encountered
    a stale element:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，结果显示测试通过了。然而，我们现在遇到了一个过时的元素：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Which element was stale? In order to find out, we need to change the `logLevel`
    back to `info` in `wdio.conf.ts`:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 哪个元素是过时的？为了找出答案，我们需要将 `wdio.conf.ts` 中的 `logLevel` 改回 `info`：
- en: '[PRE6]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, when we rerun the test, we get a completely different error buried in
    a lot of information:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我们重新运行测试时，我们得到了一个完全不同的错误，隐藏在大量信息中：
- en: '[PRE7]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It looks like things have gotten out of hand. If we try to add more `debug`
    statements, we’ll get differing results that might not be repeatable. Would you
    believe this exact phenomenon is described in a book far more advanced than this
    one?
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来事情已经失控了。如果我们尝试添加更多的 `debug` 语句，我们可能会得到不同的结果，这些结果可能无法重复。你相信这个现象在比这本书更高级的书中被描述过吗？
- en: Schrödinger and the quantum mechanics of test automation
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 谢林格和测试自动化的量子力学
- en: This issue is similar to what is known as the *measurement problem* in quantum
    mechanics. Putting it simply, measuring the outcome of an event at the quantum
    level can change the outcome of the event. Imagine testing the temperature of
    cold water with a warm thermometer. Over time, the measuring equipment warms the
    cold water slightly and the equipment itself cools from the cold water. Thus,
    readings over time become inconclusive.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题类似于量子力学中众所周知的 *测量问题*。简单来说，在量子层面上测量事件的后果可能会改变事件的后果。想象一下用温度计测试冷水温度。随着时间的推移，测量设备会稍微加热冷水，而设备本身也会从冷水中冷却。因此，随着时间的推移，读数变得不确定。
- en: 'In this case, sending details to the console window puts a little more overhead
    on the system. The speed of execution of the statements changes slightly, and
    so does the completion order, giving different results each time. This has a lot
    to do with the prioritization of statement execution in the JavaScript event Loop,
    as shown next:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，将详细信息发送到控制台窗口会给系统带来一点额外的开销。语句的执行速度略有变化，完成顺序也是如此，每次都会得到不同的结果。这与 JavaScript
    事件循环中语句执行优先级的选择有很大关系，如下所示：
- en: '![Figure 4.1 – A visualization of the execution order of promises and callbacks
    in the JavaScript Event loop](img/B19395_04_1.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1 – JavaScript 事件循环中承诺和回调执行顺序的可视化](img/B19395_04_1.jpg)'
- en: Figure 4.1 – A visualization of the execution order of promises and callbacks
    in the JavaScript Event loop
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – JavaScript 事件循环中承诺和回调执行顺序的可视化
- en: JavaScript has an Event Loop with the main thread, with macro tasks and micro
    tasks. The latter, which are promises, execute after the main thread statements.
    `MacroTasks`, which include callbacks and the timeout statement, *can* execute
    prior to the Main thread but after promises. When these tasks are completed in
    an unexpected order, you can waste hours of time trying to isolate the issue during
    debugging.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 有一个包含主线程、宏任务和微任务的 Event Loop。后者，即承诺，在主线程语句之后执行。包括回调和超时语句的 `MacroTasks`
    *可以*在主线程之前但承诺之后执行。当这些任务以意外的顺序完成时，你可能会在调试过程中浪费数小时的时间来隔离问题。
- en: '`MacroTasks` are usually related to I/O operations or UI rendering. Examples
    of `MacroTasks` include `setTimeout`, `setInterval`, `setImmediate`, and I/O operations.
    These tasks are executed by the event loop, and they can run before or after `MicroTasks`.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`MacroTasks` 通常与 I/O 操作或 UI 渲染相关。`MacroTasks` 的例子包括 `setTimeout`、`setInterval`、`setImmediate`
    和 I/O 操作。这些任务由事件循环执行，并且可以在 `MicroTasks` 之前或之后运行。'
- en: '`MicroTasks` are usually related to promises. They can also include mutation
    observers. Developers use these in various scenarios, such as tracking changes
    to attributes, detecting additions or removals of child elements, or even observing
    changes to character data within an element. `MicroTasks` are executed after the
    main thread statements and before the execution of the next `macroTask`. They
    are used to handle callbacks and resolve promises.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`MicroTasks` 通常与承诺相关。它们还可以包括突变观察者。开发者会在各种场景中使用这些，例如跟踪属性的变化、检测子元素的添加或删除，或者甚至观察元素内字符数据的变化。`MicroTasks`
    在主线程语句执行之后和下一个 `macroTask` 执行之前执行。它们用于处理回调和解决承诺。'
- en: When tasks complete in an unexpected order, it can lead to debugging challenges.
    This is because the order of execution impacts the overall behavior of the test.
    This is fine for optimizing the time spent building a web page on multiple threads,
    but it causes havoc for SDETs trying to run script steps in a sequential order.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 当任务以意外的顺序完成时，可能会导致调试挑战。这是因为执行顺序会影响测试的整体行为。对于在多个线程上优化构建网页所需的时间来说，这是可以接受的，但对于试图按顺序运行脚本步骤的
    SDETs 来说，这会造成混乱。
- en: Callbacks, promises, and async/await
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回调、承诺和 async/await
- en: To resolve these issues, we need to force JavaScript to execute code in a linear
    order. JavaScript provides three solutions – callbacks, promises, and `async`/`await`
    keywords. JavaScript promises and callbacks are two ways of knowing when the asynchronous
    call has a result. Callbacks allow you to execute a function once a response is
    received. Promises do the same and allow you to specify an easily readable order
    for multiple operations, as well as handle error cases. However, did you know
    there was an even easier way to deal with promises called synchronous mode?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这些问题，我们需要强制 JavaScript 以线性顺序执行代码。JavaScript 提供了三种解决方案——回调、承诺和 `async`/`await`
    关键字。JavaScript 承诺和回调是两种了解异步调用何时有结果的方式。回调允许你在收到响应后执行一个函数。承诺做同样的事情，并允许你为多个操作指定一个易于阅读的顺序，以及处理错误情况。然而，你知道还有一个处理承诺的更简单的方法，称为同步模式吗？
- en: The death of fibers and synchronous mode
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 纤维和同步模式的消亡
- en: Promises were added to JavaScript to make asynchronous callbacks to functions
    easier to implement. Functions were passed without parenthesis, making them visibly
    similar to variables and objects. Then, the `node-fibers` package project, which
    implicitly wrapped statements as callbacks in the background.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使异步回调到函数的实现更容易，JavaScript 添加了承诺。函数被传递时不带括号，这使得它们在视觉上与变量和对象相似。然后，`node-fibers`
    包项目在后台隐式地将语句包装为回调。
- en: Up until version 7.0, WebdriverIO leveraged the `node-fibers` package as part
    of the `@wdio/sync` feature. This meant all browser methods would execute synchronously
    without callbacks, promises, or **await**. This was a brilliant trade-off for
    WebdriverIO framework architects! It avoided the time travel issues while making
    the code less complex.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 直到版本 7.0，WebdriverIO 利用 `node-fibers` 包作为 `@wdio/sync` 功能的一部分。这意味着所有浏览器方法都会以同步方式执行，而不需要回调、承诺或
    **await**。这对 WebdriverIO 框架架构师来说是一个绝妙的权衡！它避免了时间旅行问题，同时使代码更简单。
- en: Unfortunately, the `node-fibers` project was discontinued in 2021\. WebdriverIO
    was forced to notify users of two solutions – they could lock Node to the last
    supported version that was compatible with `node-fibers`, missing out on new features
    as JavaScript added more functionality defined by the evolving ECMAScript standard.
    Alternatively, they could refactor the code base to include `async` in functions
    and `await` in browser methods. Most chose the latter and faced a large amount
    of time refactoring code.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，`node-fibers` 项目在 2021 年被终止。WebdriverIO 被迫通知用户两个解决方案——他们可以将 Node 锁定到最后一个与
    `node-fibers` 兼容的受支持版本，从而错过 JavaScript 通过不断发展的 ECMAScript 标准添加的新功能。或者，他们可以将代码库重构以在函数中包含
    `async` 并在浏览器方法中使用 `await`。大多数人选择了后者，并面临了大量代码重构的工作。
- en: '![Figure 4.2 – Packages looking for funding](img/B19395_04_2.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2 – 寻找资金的包](img/B19395_04_2.jpg)'
- en: Figure 4.2 – Packages looking for funding
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2 – 寻找资金的包
- en: 'That said, let us look at how we solve this time crisis. In our previous chapter,
    we simulated an error by passing a `promise` object:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们看看我们如何解决这个时间危机。在我们之前的章节中，我们通过传递一个 `promise` 对象来模拟错误：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: What happens if we remove the `await` keyword?
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们移除 `await` 关键字会发生什么？
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note that when `await` is missing from the code, all that happens is the custom
    `WARN` message appears after the error detail, instead of before it. This relates
    to JavaScript executing in multiple threads. We have proof of the effect of events
    executing out of sequence.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，当代码中缺少 `await` 时，所有发生的事情只是在错误详情之后出现自定义的 `WARN` 消息，而不是之前。这与 JavaScript 在多个线程中执行有关。我们有事件执行顺序错误的证据。
- en: Keep it simple with async and await
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 async 和 await 保持简单
- en: Every custom method in this book will execute asynchronously. In theory, we
    might think it would be clever to populate fields and drop-down lists concurrently
    for speed. However, often choosing a value from a list will kick off an `Ajax`
    method that will update the web page. This would then have fields generating errors
    if the elements do not yet exist because the code executed while the page was
    built anew.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 本书中的每个自定义方法都将异步执行。从理论上讲，我们可能会认为同时填充字段和下拉列表以提高速度是聪明的。然而，通常从列表中选择一个值将启动一个 `Ajax`
    方法，该方法将更新网页。然后，如果元素尚未存在，因为代码在页面重新构建时执行，这将导致字段生成错误。
- en: Summary
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about the impact synchronous code execution can
    have on our framework. While callbacks and promises are ways to keep code running
    in sequential order, it is best to use async and await to keep it consistent.
    We also upgraded global values to a single `switchboard` object that can be viewed
    during debugging sessions.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们了解了同步代码执行对我们框架的影响。虽然回调和承诺是保持代码按顺序运行的方法，但最好使用 async 和 await 来保持一致性。我们还升级了全局值到一个单一的
    `switchboard` 对象，该对象可以在调试会话中查看。
- en: In the next chapter, we will combine everything so far to enhance our first
    method wrapper function.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将把到目前为止的所有内容结合起来，以增强我们的第一个方法包装函数。
