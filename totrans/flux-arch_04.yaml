- en: Chapter 4. Creating Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we worked on building a skeleton architecture for our
    Flux application. The actions were directly dispatched by the dispatcher. Now
    that we have a skeleton Flux architecture under our belts, it's time to look more
    deeply into actions, and in particular, how actions are created.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by talking about the names we give actions and the constants used
    to identify the available actions in our system. Then, we'll implement some action
    creator functions, and we'll think about how we can keep these modular. Even though
    we might be done with implementing our skeleton architecture, we may still have
    a need to mock some API data—we'll go over how this is done with action creator
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Typical action creator functions are stateless—data in, data out. We'll cover
    some scenarios where action creators actually depend on state, such as when long-running
    connections are involved. We'll wrap the chapter up with a look at parameterized
    action creators, allowing us to reuse them for different purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Action names and constants
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any large Flux application will have a lot of actions. This is why having action
    constants and sensible action names matter. The focus of this section is to discuss
    possible naming conventions for actions and to get organized with our actions.
    Constants help with reducing repetitive strings that are error-prone, but we'll
    also need to think about the best way to organize our constants. We'll also look
    at static action data—this will also help us reduce the amount of action dispatch
    code we have to write.
  prefs: []
  type: TYPE_NORMAL
- en: Action name conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All actions in a Flux system have a name. The name is important because it tells
    whoever is looking at it a lot about what it does. An application where there
    are less than ten actions is unlikely to have a strong naming convention requirement,
    because we can easily figure out what these actions do. However, it's equally
    unlikely we'd use Flux to implement a small application—Flux is for systems that
    need to scale. This means that there's a strong likelihood of many actions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Action names can be divided into two segments—the *subject* and the *operation*.
    For example, having an action named `ACTIVATE` wouldn''t be terribly helpful—what
    are we activating? Adding a subject to the name is often all it takes to provide
    some much needed context. Here are some examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ACTIVATE_SETTING`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACTIVATE_USER`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ACTIVATE_TAB`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The subject is just an abstract type of thing in our system—it doesn''t even
    have to correspond to a concrete software entity. However, if there are a lot
    of subjects in our system with similar actions, we might want to change up the
    format of our action names, like this for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SETTING_ACTIVATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`USER_ACTIVATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TAB_ACTIVATE`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At the end of the day, this is really a personal (or team) preference, just
    as long as the name is descriptive enough to provide meaning for someone who's
    looking at the code. What if the subject and the operation aren't enough? For
    example, there could be several subjects that are similar, and this could cause
    confusion. Then, we could add another layer of subject to the name—think of this
    as namespacing the action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Try not to go beyond three segments in a Flux action name. If you feel the need
    to do this, there's probably somewhere else in your architecture that needs attention.
  prefs: []
  type: TYPE_NORMAL
- en: Static action data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Some actions are very similar to other actions, similar in the sense, that
    the payload data that''s sent to the stores has many of the same properties. If
    we were to directly dispatch these actions, using the dispatcher instance, then
    we''d usually have to repeat object literal code. Let''s take a look at an action
    creator function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The aim of this action is pretty straightforward—sort the list of users that
    are presumably UI components. The only payload data that's required is a sort
    direction, which is specified in the `direction` property. The problem with this
    action creator function is that this payload data is hard-coded. For example,
    the payload data in question here seems fairly generic, and other action creator
    functions that sort data should follow this pattern. But, this also means that
    they'll each have their own hard-coded values.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing we can do about this is to create a module within the `actions` directory
    that exports any default payload data that can be shared amongst several action
    creator functions. Carrying on with the sorting example, the module might start
    off looking something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This is easy to build on. We can extend `PAYLOAD_SORT`, as new properties are
    needed and when old defaults need to change. It''s also easy to add new default
    payloads as they''re needed. Let''s take look at another action creator function
    that uses this default payload:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, the `PAYLOAD_SORT` object is used by the `sortTasks()` function,
    rather than hard-coding the payload within the action creator. This reduces the
    amount of code we need to write, and it puts common payload data in a central
    place, making it easy for us to change the behavior of many action creator functions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You may have noticed that the default payload object is being passed to `dispatch()`
    as is. More often than not, we'll have part of the payload object that's common
    across several functions and part of the payload object that's dynamic. We'll
    build in the examples from this section in the last section of the chapter, when
    it's time to think about parameterized action creator functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s take a look at both of these action creator functions in use, to
    make sure we''re getting what we expect. Rather than setting up stores for this,
    we''ll just listen to the dispatcher directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Organizing action constants
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You may have noticed that there''s already a hint of organization with the
    action constants used in the previous example. For example, the `SORT_USERS` constant
    was defined in the same module as the `sortUsers()` action creator function. This
    is generally a good idea because these two things are closely related to one another.
    There is a downside to this though. Imagine a more complex store that needs to
    handle a lot of actions. If each individual action constant is declared in its
    own module, the store would have to perform a lot of imports just to get these
    constants. If there''s a number of complex stores that each need access to lots
    of actions, the number of imports starts to really add up. This problem is illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we find ourselves in a situation like this one, where several stores need
    access to several modules, maybe we need a `constants.js` module in the `actions`
    directory. This module would expose every action in the system. Here''s an example
    of what this module might look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'As our system grows and new actions are added, this is where we would centralize
    the action constants for easy access by stores that require many of them. They''re
    not defined here; this is just a proxy that reduces the number of imports from
    stores, because the stores never need the action creator functions. Let''s see
    if the situation has improved from the perspective of a store that requires action
    constants:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: That's better. Only one `import` statement gets us everything we need, and it's
    still nice and legible. There are several ways we could spin this approach to
    better suit our needs. For example, maybe instead of one big constants module,
    we want to group our actions into logical modules that more closely resemble our
    features, and likewise for our action creator functions. We'll discuss action
    modularity as it relates to our application features in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Feature action creators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Action creator functions need to be organized, just as action constants are.
    In the preceding code examples of this chapter, we've organized both our action
    constants and our action creator functions into modules. This keeps our action
    code clean and easy to traverse. In this section, we'll build on this idea from
    the feature point of view. We'll look at why this is worth thinking about in the
    first place, then we'll talk about how these ideas make the architecture as a
    whole more modular.
  prefs: []
  type: TYPE_NORMAL
- en: When modularity is needed
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Do we need to think deeply about modular action creator functions at the beginning
    of our Flux project? While the project is still small in size, it's okay if all
    action creator functions are part of one monolithic action creator module—there's
    simply no meaningful impact on the architecture. It's when we have more than a
    dozen or so actions that we need to start thinking about modularity and, in particular,
    features.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can split our action creator module into several smaller modules, each with
    their own action creator function. This is certainly a step in the right direction,
    but in essence, we''re just moving the problem to the directory level. So instead
    of a monolithic module, we now have a monolithic directory with lots of files
    in it. This directory is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When modularity is needed](img/B05419_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There''s nothing inherently wrong with this layout—it''s just that there''s
    no indication of which feature a given action is part of. This may not even be
    necessary, but when the architecture grows to be a certain size, it''s usually
    helpful to group action modules by features. This concept is illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![When modularity is needed](img/B05419_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Once we're able to get the actions of the system organized in such a way that
    they reflect the behavior of any given feature, we can start thinking about other
    architectural challenges related to modularity. We'll discuss these next.
  prefs: []
  type: TYPE_NORMAL
- en: Modular architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s a good thing when the modules in a Flux architecture start taking the
    shape of the features our application provides. This has implications elsewhere
    in the architecture as well. For example, if we''re organizing the actions by
    features, then should we not also organize the stores and the views by feature
    as well? Stores are easy—they''re not exactly decomposable into smaller stores;
    they naturally represent the feature in its entirety. Views, on the other hand,
    could potentially have many JavaScript modules to organize within a feature. Here''s
    a potential directory structure of a Flux feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Modular architecture](img/B05419_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This is a cohesive structure—everything the views need to dispatch these actions
    are in the same parent directory. Likewise, the store that notifies the views
    about state changes is in the same place. We can get away with following a similar
    pattern for all of our features, which has the added benefit of promoting consistency.
  prefs: []
  type: TYPE_NORMAL
- en: We'll revisit structuring feature modules toward the end of the book. For now,
    our main concern is the dependencies that other features might have with a given
    set of actions. For example, our feature defines several actions that are dispatched
    by views. What should happen with other features that want to respond to these
    actions—do they need to depend on this feature for the action? There's also the
    matter of the action creators themselves, and whether or not other features can
    dispatch them. The answer is a resounding yes, and the reason is simple—actions
    are how things happen in Flux architectures. There's no event bus where modules
    publish events in a fire-and-forget way. Actions play a vital role in the modularity
    of our Flux architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The dispatcher in Flux architectures is the single point of entry for new data
    entering the system. This makes it easy to fabricate mock data to help us churn
    out features faster. In this section, we'll discuss mocking existing APIs, and
    whether or not this is worthwhile to build into the action creator functions that
    talk to them. Then, we'll go over implementing mocks for new APIs that doesn't
    yet exist, followed by a look at strategies to substitute mock action creators
    for the real deal.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking existing APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In order to mock data in a Flux system, the actions that are dispatched need
    to deliver this mock data to the stores. This is done by creating an alternative
    implementation of the action creator function that dispatches the action. When
    there's already an API that an action creator can target, we don't necessarily
    need to mock the data during the development of a given feature—the data is already
    there. However, the existence of an API that's used by an action creator shouldn't
    rule out the existence of a mocked version.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main reason we would want to do this is because at any given point during
    the lifetime of our product, there''s going to be a missing API that we need.
    As we''ll see in the next section, we''ll obviously want to mock the data returned
    by this API, so we can continue implementing the feature we''re working on. But
    do we really want to mock some actions and not others? The idea is illustrated
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking existing APIs](img/B05419_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The challenge with this approach—mocking some actions while actually implementing
    others—is consistency. When we''re mocking data that enters the system, we have
    to be cognizant of the relationships between one set of data and another. Look
    at it from the perspective of our stores—they''ll likely have dependencies on
    one another. Can we capture these dependencies using a mixture of mock data and
    actual data? Here is an illustration of actions that mock the entirety of the
    system:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Mocking existing APIs](img/B05419_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It's better to have total control over the data that's used when we experiment
    with new functionality. This eliminates the possibility of errant behavior because
    of some inconsistency in our data. It takes more effort to construct mock data
    like this, but it pays off in the end when we're adding new features and we only
    have to mock one new action at a time, as it's added into the system. As we'll
    see later in this section, it's easy to substitute mock action creators for production
    action creators.
  prefs: []
  type: TYPE_NORMAL
- en: Mocking new APIs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once we reach the point during the implementation of a new feature where we're
    missing API functionality, we'll have to mock it. We can use this new mock with
    the other mocks we've created to support other features in the application. The
    advantage of doing this is that it allows us to create something without delay,
    something we can demonstrate to stakeholders. Another benefit of mocking APIs
    as action creator functions is that they can help steer the API in the right direction.
    Without a UI, the API has nothing to base its design on, so this is a good opportunity
    to solicit a design that works best with the application we're building.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at some action creator functions that mock the data that''s
    dispatched as action payloads. We''ll start with a basic loader function that
    bootstraps some data into the store for us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is quite simple. The data we want to mock is part of the function, as
    the action payload. Let''s look at another mock action creator now, one that manipulates
    the state of a store after the data has already been bootstrapped:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Once again, we have very specific mock data we're using here, which is fine
    because it's directly coupled to the action creator function that's dispatching
    the action—this is the only way this data can enter the system too. Something
    else that's different about this function is that it's simulating latency by not
    dispatching the action until the `setTimeout()` callback triggers after one second.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll take a more detailed look at asynchronous actions, including latency,
    promises, and multiple API endpoints in a later chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have two mock action creator functions available for use.
    But before we start using these functions, let''s create a task store so that
    we can make sure the correct information is being stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have a store to handle both actions we''ve just implemented, let''s
    put the store and the actions to use in the `main.js` module of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the tasks were successfully bootstrapped into the store with
    the call to `loadTasks()`, and the state of the second task was updated when we
    called `runTask()`. This latter update isn't logged till one second has elapsed.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing action creators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point, we have a working action creator function that dispatches actions
    with mock payload data into the system. Recall that we don't necessarily want
    to get rid of these action creator functions, because when it's time to implement
    something new, we'll want to use these mocks again.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we really need is a global switch that toggles the mock mode of the system,
    and this would change the implementation of the action creator function that''s
    used. Here''s a diagram that shows how this might work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Replacing action creators](img/B05419_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The idea here is that there''s a mock version and a production version of the
    same action creator function within the module. This is the easy part; the tricky
    part is going to be implementing a global mock switch so that the correct function
    is exported, depending on the mode of the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This is very handy during development, because the extent of our mocked functions
    is limited to the action creator modules and is controlled by one setting. Let''s
    see how this action creator function is used, regardless of whether the mock or
    the production implementation is exported:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Stateful action creators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The action creator functions we've looked at so far in this chapter have been
    relatively simple—they dispatch some action when called. But before that happens,
    these action creators will typically reach out to some API endpoint to retrieve
    some data, then dispatch the action, using the data as the payload. These are
    called stateless action creator functions because there's no intermediary state
    about them—no lifecycle in other words.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll think about things that are stateful and how we might
    go about integrating these into our Flux architecture. Another challenge we could
    face is integrating our Flux application into another architecture. First, we'll
    cover some basic ground on stateful action creators, then we'll look at a concrete
    example using web sockets.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with other systems
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Most of the time, Flux applications are standalone in the browser. That is,
    they''re not a cog in a larger machine. We will, however, come up against cases
    where our Flux architecture needs to fit into something bigger. For example, if
    we need to interface with components that use a completely different framework,
    then we need to come up with a way to embed our software without compromising
    the Flux patterns. Or perhaps the coupling between our application and the one
    we''re integrating with is a little looser, as when communicating with another
    browser tab. Whatever the case may be, we have to be able to send messages to
    this external system and we need to be able to consume messages from it, translating
    them into actions. Here is an illustration of this idea:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Integrating with other systems](img/B05419_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the Flux architecture depicted here isn't a closed system. The
    main implication is that the typical action creator functions that we're used
    to working with aren't necessarily called within the system. That is, they're
    handling a stream of external messages, using a stateful connection to the other
    system. This is just how web sockets work. We'll look at these stateful action
    creators next.
  prefs: []
  type: TYPE_NORMAL
- en: Web socket connectivity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Web socket connectivity is growing to the point of pervasiveness in modern web
    applications, and if we're building a Flux architecture, there's a good chance
    we're going to need to build web socket support. When something changes state
    in the backend, web socket connections are a great way to notify clients about
    such a change. For example, imagine a Flux store is managing the state of some
    piece of backend data, and something causes its state to change—wouldn't we want
    the store to know about it?
  prefs: []
  type: TYPE_NORMAL
- en: 'The challenge is that we need a stateful connection in order to receive web
    socket messages and translate them into Flux actions. This is how web socket data
    enters the system. Let''s take a look at some socket listener code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'All we''re doing here is creating a simple `actions` map. This is how we call
    the correct action creator function based on the `task` property of the message
    that was received. What''s nice about this approach is that there''s very little
    additional functionality required to make this work; the preceding code is the
    extent of it. The actual action creator functions, constants, and so on, are just
    typical Flux items. Let''s look at the server code that generates these web socket
    messages, so we have an idea of what''s actually being passed to the socket listener
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Over the course of three seconds, we''ll see three web socket messages delivered
    to the client. Each message has a `task` property, and this is the value we''re
    using to determine which action is dispatched. Let''s take a look at the `main.js`
    frontend module and make sure everything''s working as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `connect()` function is responsible for establishing the
    web socket connection. This is a simple implementation, lacking several production-grade
    capabilities, such as reconnecting dropped connections. However, the important
    thing to note here is that this listener is actually located in the same directory
    as the other action modules. We actually want a tight coupling here because the
    main goal of the socket listener is to dispatch actions, by translating web socket
    messages.
  prefs: []
  type: TYPE_NORMAL
- en: Parameterized action creators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The final section of this chapter focuses on parameterized action creators.
    All the action creator functions we've looked at so far in the chapter have been
    basic functions that don't accept any arguments. This is fine, except for when
    we start to accumulate several unique actions that are nearly identical. Without
    parameterized action creator functions, we'll soon have an endless proliferation
    of functions; this does not scale.
  prefs: []
  type: TYPE_NORMAL
- en: First, we'll establish the goals of passing arguments to action creator functions,
    followed by some example code that implements generic action creator functions.
    We'll then look into creating partial functions to further reduce repetitiveness
    by composing action creators.
  prefs: []
  type: TYPE_NORMAL
- en: Removing redundant actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Action creators are plain JavaScript functions. This means that they can accept
    zero or more arguments when called. The whole point of implementing a function,
    regardless of whether or not it's in the context of Flux, is to reduce the amount
    of code we have to write. Action creators in a Flux application are likely to
    accumulate because they drive the behavior of our application. If anything happens,
    it can be traced back to an action. So it's easy to introduce several new actions
    over the course of a day.
  prefs: []
  type: TYPE_NORMAL
- en: Once our application has several features implemented, we're bound to have a
    lot of actions. Some of these actions will serve a distinct purpose, while other
    actions will be very similar to each other. In other words, some actions will
    start to feel redundant. The goal is to remove redundant action creator functions
    by introducing parameters.
  prefs: []
  type: TYPE_NORMAL
- en: We should exercise caution in how we go about refactoring our action creator
    functions. There's a strong argument in favor of keeping a dedicated function
    for each type of action in the system. That is, one action creator function should
    only ever dispatch one type of action, not one of several options. Otherwise,
    the traceability of our code will be diminished. We should aim to reduce the total
    number of actions in the system altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping actions generic
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When actions are generic, the architecture requires less of them. This is a
    good thing because it means there''s less knowledge to keep in our heads as we''re
    writing code. Let''s take a look at a couple of actions that do essentially the
    same thing; in other words, they''re not generic at all. The first action is as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Simple enough—it's using the lodash `sortBy()` function to sort the payload
    before dispatching the action.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that we wouldn't actually sort payload data like this in the action creator
    function. Think of this as an API mock. The point is that action creator function
    is asking something outside of Flux for data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at another similar but distinct action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference here is how we''re sorting the data. If this were a production
    action creator function, we would tell the API to sort the data in descending
    order instead of using lodash to do it in the action creator. Do we need two distinct
    actions for these two sort directions? Or can we eliminate both of them in favor
    of a generic action that accepts a sort direction parameter? Here''s a generic
    implementation of the action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here are all three actions being used. Note that the third action covers both
    cases, and yet the fundamental sort action is the same no matter what arguments
    are passed. You can see in the dispatcher callback function that stores would
    have an easier time listening to one action instead of two or more:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Creating action partials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In some cases, function arguments are straightforward—as in there are one or
    two of them. In others, the argument lists can be daunting, especially when we're
    calling them repeatedly using the same handful of arguments. Action creators in
    Flux applications are no different. There will be cases where we have a generic
    function that supports the odd case where, instead of a new action creator function,
    we simply supply a different parameter. But in the most common case, where the
    same parameters have to be supplied all the time, this can get repetitive to the
    point where it defeats the purpose of having generic functions.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at a generic action creator function that accepts a variable number
    of arguments. Since the same arguments are passed to the function in the most
    common case, we'll also export a partial version of the function where these arguments
    have been partially applied.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Default parameters in ES2015 syntax are a good alternative to creating partial
    functions, but only when the number of arguments is fixed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now let''s see how these two versions of the same action creator are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It's important to note that the `first()` and `firstCommon()` functions are
    the same action creator, and this is why they're defined in the same module. If
    we were to define `firstCommon()` in another action module, this would lead to
    confusion, because they both use the same action type—`FIRST`.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about the action creator functions that Flux applications
    utilize in order to dispatch actions. Without action creator functions, we'd have
    to directly interface with the dispatcher in our code, which makes the architecture
    more difficult to reason about.
  prefs: []
  type: TYPE_NORMAL
- en: We started off by thinking about action naming conventions and the general organization
    of our action modules. Grouping action creators by feature has implications for
    modularity as well, especially in how this influences modularity in other areas
    of the architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we discussed mocking data using action creator functions. Mocking data
    in Flux applications is easy to do and encouraged. Actions are the only way for
    data to enter the system, making it easy for us to switch between mocked action
    data and our production implementations. We wrapped the chapter up with a look
    at stateful action creators that listen to things such as web socket connections,
    and a look at parameterized action creators that keep repetitive code to a minimum.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll address another key aspect of action creator functions—asynchronicity.
  prefs: []
  type: TYPE_NORMAL
