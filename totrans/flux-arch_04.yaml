- en: Chapter 4. Creating Actions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章 创建操作
- en: In the previous chapter, we worked on building a skeleton architecture for our
    Flux application. The actions were directly dispatched by the dispatcher. Now
    that we have a skeleton Flux architecture under our belts, it's time to look more
    deeply into actions, and in particular, how actions are created.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们致力于构建我们的 Flux 应用的骨架架构。操作是由分发器直接分发的。现在我们已经掌握了骨架 Flux 架构，是时候更深入地研究操作了，特别是操作的创建方式。
- en: We'll start by talking about the names we give actions and the constants used
    to identify the available actions in our system. Then, we'll implement some action
    creator functions, and we'll think about how we can keep these modular. Even though
    we might be done with implementing our skeleton architecture, we may still have
    a need to mock some API data—we'll go over how this is done with action creator
    functions.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从讨论我们赋予操作的名称以及用于识别系统中可用操作的常量开始。然后，我们将实现一些操作创建函数，并考虑如何保持这些模块化。尽管我们可能已经完成了骨架架构的实现，但我们可能仍然需要模拟一些
    API 数据——我们将通过操作创建函数介绍如何完成这项工作。
- en: Typical action creator functions are stateless—data in, data out. We'll cover
    some scenarios where action creators actually depend on state, such as when long-running
    connections are involved. We'll wrap the chapter up with a look at parameterized
    action creators, allowing us to reuse them for different purposes.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 典型的操作创建函数是无状态的——输入数据，输出数据。我们将讨论一些操作创建函数实际上依赖于状态的情况，例如涉及长时间运行连接的情况。我们将以参数化操作创建函数的介绍来结束本章，这将允许我们为不同的目的重用它们。
- en: Action names and constants
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作名称和常量
- en: Any large Flux application will have a lot of actions. This is why having action
    constants and sensible action names matter. The focus of this section is to discuss
    possible naming conventions for actions and to get organized with our actions.
    Constants help with reducing repetitive strings that are error-prone, but we'll
    also need to think about the best way to organize our constants. We'll also look
    at static action data—this will also help us reduce the amount of action dispatch
    code we have to write.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 任何大型 Flux 应用都会有很多操作。这就是为什么拥有操作常量和合理的操作名称很重要的原因。本节的重点是讨论操作的可能命名约定，并整理我们的操作。常量有助于减少重复且易出错的字符串，但我们也需要考虑如何最好地组织我们的常量。我们还将查看静态操作数据——这也有助于我们减少必须编写的操作分发代码的数量。
- en: Action name conventions
  id: totrans-6
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 操作名称约定
- en: All actions in a Flux system have a name. The name is important because it tells
    whoever is looking at it a lot about what it does. An application where there
    are less than ten actions is unlikely to have a strong naming convention requirement,
    because we can easily figure out what these actions do. However, it's equally
    unlikely we'd use Flux to implement a small application—Flux is for systems that
    need to scale. This means that there's a strong likelihood of many actions.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: Flux 系统中的所有操作都有一个名称。名称很重要，因为它告诉查看它的人很多关于它做什么的信息。如果一个应用中少于十个操作，不太可能对命名约定有强烈的要求，因为我们很容易就能弄清楚这些操作做什么。然而，同样不太可能我们会使用
    Flux 来实现一个小型应用——Flux 是用于需要扩展的系统。这意味着有很多操作的可能性很大。
- en: 'Action names can be divided into two segments—the *subject* and the *operation*.
    For example, having an action named `ACTIVATE` wouldn''t be terribly helpful—what
    are we activating? Adding a subject to the name is often all it takes to provide
    some much needed context. Here are some examples:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 操作名称可以分为两个部分——*主题*和*操作*。例如，一个名为 `ACTIVATE` 的操作不会非常有帮助——我们在激活什么？在名称中添加一个主题通常就足以提供所需的大量上下文。以下是一些示例：
- en: '`ACTIVATE_SETTING`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACTIVATE_SETTING`'
- en: '`ACTIVATE_USER`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACTIVATE_USER`'
- en: '`ACTIVATE_TAB`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ACTIVATE_TAB`'
- en: 'The subject is just an abstract type of thing in our system—it doesn''t even
    have to correspond to a concrete software entity. However, if there are a lot
    of subjects in our system with similar actions, we might want to change up the
    format of our action names, like this for example:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 主题只是我们系统中的一种抽象类型的东西——它甚至不需要对应一个具体的软件实体。然而，如果我们的系统中有很多具有相似操作的主题，我们可能想要改变操作名称的格式，例如：
- en: '`SETTING_ACTIVATE`'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SETTING_ACTIVATE`'
- en: '`USER_ACTIVATE`'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`USER_ACTIVATE`'
- en: '`TAB_ACTIVATE`'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TAB_ACTIVATE`'
- en: At the end of the day, this is really a personal (or team) preference, just
    as long as the name is descriptive enough to provide meaning for someone who's
    looking at the code. What if the subject and the operation aren't enough? For
    example, there could be several subjects that are similar, and this could cause
    confusion. Then, we could add another layer of subject to the name—think of this
    as namespacing the action.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，这实际上是一个个人（或团队）偏好问题，只要名称足够描述性，足以向查看代码的人提供意义即可。如果主题和操作不够用怎么办？例如，可能有几个相似的主题，这可能会引起混淆。然后，我们可以在名称中添加另一个主题层——将其视为动作的命名空间。
- en: Note
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Try not to go beyond three segments in a Flux action name. If you feel the need
    to do this, there's probably somewhere else in your architecture that needs attention.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 尽量不要在Flux动作名称中超过三个部分。如果你觉得需要这样做，那么你的架构中可能还有其他地方需要关注。
- en: Static action data
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态动作数据
- en: 'Some actions are very similar to other actions, similar in the sense, that
    the payload data that''s sent to the stores has many of the same properties. If
    we were to directly dispatch these actions, using the dispatcher instance, then
    we''d usually have to repeat object literal code. Let''s take a look at an action
    creator function:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一些动作与其他动作非常相似，相似之处在于发送到存储器的有效负载数据具有许多相同的属性。如果我们直接使用分发器实例分发这些动作，那么我们通常需要重复对象字面量代码。让我们看看一个动作创建函数：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The aim of this action is pretty straightforward—sort the list of users that
    are presumably UI components. The only payload data that's required is a sort
    direction, which is specified in the `direction` property. The problem with this
    action creator function is that this payload data is hard-coded. For example,
    the payload data in question here seems fairly generic, and other action creator
    functions that sort data should follow this pattern. But, this also means that
    they'll each have their own hard-coded values.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动作的目标非常直接——对用户列表进行排序，这些用户可能是UI组件。所需的有效负载数据仅是一个排序方向，该方向在 `direction` 属性中指定。这个动作创建函数的问题在于这个有效负载数据是硬编码的。例如，这里讨论的有效负载数据似乎相当通用，其他对数据进行排序的动作创建函数应该遵循这个模式。但这同时也意味着它们各自都会有自己的硬编码值。
- en: 'One thing we can do about this is to create a module within the `actions` directory
    that exports any default payload data that can be shared amongst several action
    creator functions. Carrying on with the sorting example, the module might start
    off looking something like this:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做的关于这一点的事情是在 `actions` 目录中创建一个模块，该模块导出可以在多个动作创建函数之间共享的任何默认有效负载数据。继续使用排序示例，该模块可能开始看起来像这样：
- en: '[PRE1]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This is easy to build on. We can extend `PAYLOAD_SORT`, as new properties are
    needed and when old defaults need to change. It''s also easy to add new default
    payloads as they''re needed. Let''s take look at another action creator function
    that uses this default payload:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这很容易扩展。当需要新的属性或旧默认值需要更改时，我们可以扩展 `PAYLOAD_SORT`。当需要时，添加新的默认有效负载也很容易。让我们看看另一个使用此默认有效负载的动作创建函数：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: As we can see, the `PAYLOAD_SORT` object is used by the `sortTasks()` function,
    rather than hard-coding the payload within the action creator. This reduces the
    amount of code we need to write, and it puts common payload data in a central
    place, making it easy for us to change the behavior of many action creator functions.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，`PAYLOAD_SORT` 对象被 `sortTasks()` 函数使用，而不是在动作创建器中硬编码有效负载。这减少了我们需要编写的代码量，并将通用有效负载数据放在一个中心位置，使我们能够轻松地更改许多动作创建函数的行为。
- en: Note
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You may have noticed that the default payload object is being passed to `dispatch()`
    as is. More often than not, we'll have part of the payload object that's common
    across several functions and part of the payload object that's dynamic. We'll
    build in the examples from this section in the last section of the chapter, when
    it's time to think about parameterized action creator functions.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，默认的有效负载对象是直接传递给 `dispatch()` 的。大多数情况下，我们会有部分有效负载对象在多个函数中是通用的，而另一部分则是动态的。我们将在本章的最后部分构建本节的示例，届时将考虑参数化动作创建函数。
- en: 'Now, let''s take a look at both of these action creator functions in use, to
    make sure we''re getting what we expect. Rather than setting up stores for this,
    we''ll just listen to the dispatcher directly:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们来看看这两个动作创建函数的实际应用，以确保我们得到预期的结果。而不是为这个设置存储，我们只需直接监听分发器：
- en: '[PRE3]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Organizing action constants
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 组织动作常量
- en: 'You may have noticed that there''s already a hint of organization with the
    action constants used in the previous example. For example, the `SORT_USERS` constant
    was defined in the same module as the `sortUsers()` action creator function. This
    is generally a good idea because these two things are closely related to one another.
    There is a downside to this though. Imagine a more complex store that needs to
    handle a lot of actions. If each individual action constant is declared in its
    own module, the store would have to perform a lot of imports just to get these
    constants. If there''s a number of complex stores that each need access to lots
    of actions, the number of imports starts to really add up. This problem is illustrated
    here:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，在之前的例子中已经有一些关于操作常量的组织性。例如，`SORT_USERS`常量是在与`sortUsers()`操作创建函数相同的模块中定义的。这通常是一个好主意，因为这两者之间关系密切。然而，这也存在一个缺点。想象一个需要处理大量操作的更复杂的存储器。如果每个单独的操作常量都在自己的模块中声明，存储器将不得不执行大量的导入，只是为了获取这些常量。如果有多个复杂的存储器，每个都需要访问大量操作，导入的数量开始真正增加。这个问题在这里得到了说明：
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'If we find ourselves in a situation like this one, where several stores need
    access to several modules, maybe we need a `constants.js` module in the `actions`
    directory. This module would expose every action in the system. Here''s an example
    of what this module might look like:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们发现自己处于这种情况下，即几个存储器需要访问几个模块，可能我们需要在`actions`目录中创建一个`constants.js`模块。这个模块将暴露系统中的每一个操作。以下是这个模块可能的样子：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As our system grows and new actions are added, this is where we would centralize
    the action constants for easy access by stores that require many of them. They''re
    not defined here; this is just a proxy that reduces the number of imports from
    stores, because the stores never need the action creator functions. Let''s see
    if the situation has improved from the perspective of a store that requires action
    constants:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们的系统增长和新操作的添加，这就是我们集中管理操作常量的地方，以便于需要大量常量的存储器轻松访问。它们在这里没有定义；这只是一个代理，减少了从存储器中导入的数量，因为存储器从不需要操作创建函数。让我们看看从需要操作常量的存储器的角度来看，情况是否有所改善：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That's better. Only one `import` statement gets us everything we need, and it's
    still nice and legible. There are several ways we could spin this approach to
    better suit our needs. For example, maybe instead of one big constants module,
    we want to group our actions into logical modules that more closely resemble our
    features, and likewise for our action creator functions. We'll discuss action
    modularity as it relates to our application features in the next section.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这样更好。只有一个`import`语句就能获取我们所需的一切，而且代码依然清晰易读。我们可以有几种方法来调整这种做法，使其更符合我们的需求。例如，我们可能不想创建一个大的常量模块，而是希望将我们的操作分组到逻辑模块中，这些模块更接近我们的功能，同样也适用于我们的操作创建函数。我们将在下一节讨论与我们的应用程序功能相关的操作模块化。
- en: Feature action creators
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 功能操作创建函数
- en: Action creator functions need to be organized, just as action constants are.
    In the preceding code examples of this chapter, we've organized both our action
    constants and our action creator functions into modules. This keeps our action
    code clean and easy to traverse. In this section, we'll build on this idea from
    the feature point of view. We'll look at why this is worth thinking about in the
    first place, then we'll talk about how these ideas make the architecture as a
    whole more modular.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 操作创建函数需要组织，就像操作常量一样。在本章前面的代码示例中，我们已经将我们的操作常量和操作创建函数组织到模块中。这使我们的操作代码保持整洁且易于遍历。在本节中，我们将从功能的角度来构建这个想法。我们将探讨为什么一开始就值得考虑这个问题，然后我们将讨论这些想法如何使整体架构更加模块化。
- en: When modularity is needed
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 当需要模块化时
- en: Do we need to think deeply about modular action creator functions at the beginning
    of our Flux project? While the project is still small in size, it's okay if all
    action creator functions are part of one monolithic action creator module—there's
    simply no meaningful impact on the architecture. It's when we have more than a
    dozen or so actions that we need to start thinking about modularity and, in particular,
    features.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 我们是否需要在Flux项目的开始阶段就深入思考模块化的操作创建函数？当项目规模还较小时，如果所有操作创建函数都是单一的操作创建模块的一部分，这是可以接受的——这根本不会对架构产生有意义的影响。只有当我们有十几个或更多的操作时，我们才需要开始考虑模块化，特别是功能。
- en: 'We can split our action creator module into several smaller modules, each with
    their own action creator function. This is certainly a step in the right direction,
    but in essence, we''re just moving the problem to the directory level. So instead
    of a monolithic module, we now have a monolithic directory with lots of files
    in it. This directory is illustrated here:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将动作创建者模块拆分为几个更小的模块，每个模块都有自己的动作创建者函数。这当然是一个正确的方向，但从本质上讲，我们只是将问题移动到了目录级别。因此，我们不再有一个单一的模块，而是一个包含许多文件的单一目录。这个目录在这里得到了说明：
- en: '![When modularity is needed](img/B05419_04_01.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![当需要模块化时](img/B05419_04_01.jpg)'
- en: 'There''s nothing inherently wrong with this layout—it''s just that there''s
    no indication of which feature a given action is part of. This may not even be
    necessary, but when the architecture grows to be a certain size, it''s usually
    helpful to group action modules by features. This concept is illustrated here:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种布局本身并没有什么固有的错误——只是没有指示哪个功能包含特定的操作。这可能甚至不是必要的，但当架构增长到一定规模时，通常有助于按功能分组操作模块。这个概念在这里得到了说明：
- en: '![When modularity is needed](img/B05419_04_02.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![当需要模块化时](img/B05419_04_02.jpg)'
- en: Once we're able to get the actions of the system organized in such a way that
    they reflect the behavior of any given feature, we can start thinking about other
    architectural challenges related to modularity. We'll discuss these next.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够以这种方式组织系统的操作，使它们反映任何给定功能的任何行为，我们就可以开始考虑与模块化相关的其他架构挑战。我们将在下一节讨论这些内容。
- en: Modular architecture
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块化架构
- en: 'It''s a good thing when the modules in a Flux architecture start taking the
    shape of the features our application provides. This has implications elsewhere
    in the architecture as well. For example, if we''re organizing the actions by
    features, then should we not also organize the stores and the views by feature
    as well? Stores are easy—they''re not exactly decomposable into smaller stores;
    they naturally represent the feature in its entirety. Views, on the other hand,
    could potentially have many JavaScript modules to organize within a feature. Here''s
    a potential directory structure of a Flux feature:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当Flux架构中的模块开始呈现出我们应用提供的功能形状时，这是一件好事。这在架构的其他地方也有影响。例如，如果我们按功能组织操作，那么我们是否也应该按功能组织存储和视图？存储很容易——它们不能精确地分解成更小的存储；它们自然地代表了一个功能的全貌。另一方面，视图可能包含许多JavaScript模块来组织在一个功能内。以下是一个Flux功能的潜在目录结构：
- en: '![Modular architecture](img/B05419_04_03.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![模块化架构](img/B05419_04_03.jpg)'
- en: This is a cohesive structure—everything the views need to dispatch these actions
    are in the same parent directory. Likewise, the store that notifies the views
    about state changes is in the same place. We can get away with following a similar
    pattern for all of our features, which has the added benefit of promoting consistency.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个结构紧凑的布局——所有需要执行这些操作的视图都在同一个父目录中。同样，通知视图关于状态变化的存储也在同一个地方。我们可以通过遵循类似的模式来处理我们所有的功能，这还有一个额外的优点，就是促进了一致性。
- en: We'll revisit structuring feature modules toward the end of the book. For now,
    our main concern is the dependencies that other features might have with a given
    set of actions. For example, our feature defines several actions that are dispatched
    by views. What should happen with other features that want to respond to these
    actions—do they need to depend on this feature for the action? There's also the
    matter of the action creators themselves, and whether or not other features can
    dispatch them. The answer is a resounding yes, and the reason is simple—actions
    are how things happen in Flux architectures. There's no event bus where modules
    publish events in a fire-and-forget way. Actions play a vital role in the modularity
    of our Flux architecture.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的结尾重新审视功能模块的结构。现在，我们主要关心的是其他功能可能对一组操作具有的依赖关系。例如，我们的功能定义了几个由视图分发的操作。那么，其他想要对这些操作做出响应的功能应该怎么办——它们需要依赖这个功能来执行操作吗？还有关于动作创建者本身的问题，以及其他功能是否可以分发它们。答案是响亮的“是”，原因很简单——动作是Flux架构中事情发生的方式。没有事件总线，模块可以以“点火并忘记”的方式发布事件。动作在我们的Flux架构的模块化中起着至关重要的作用。
- en: Mocking data
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模拟数据
- en: The dispatcher in Flux architectures is the single point of entry for new data
    entering the system. This makes it easy to fabricate mock data to help us churn
    out features faster. In this section, we'll discuss mocking existing APIs, and
    whether or not this is worthwhile to build into the action creator functions that
    talk to them. Then, we'll go over implementing mocks for new APIs that doesn't
    yet exist, followed by a look at strategies to substitute mock action creators
    for the real deal.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: Flux架构中的调度器是新数据进入系统的单一入口点。这使得我们能够轻松地制造模拟数据以帮助我们更快地生成功能。在本节中，我们将讨论模拟现有API，以及是否值得将其构建到与它们通信的动作创建器函数中。然后，我们将介绍为尚未存在的API实现模拟，接着探讨用模拟动作创建器替代真实动作创建器的策略。
- en: Mocking existing APIs
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟现有API
- en: In order to mock data in a Flux system, the actions that are dispatched need
    to deliver this mock data to the stores. This is done by creating an alternative
    implementation of the action creator function that dispatches the action. When
    there's already an API that an action creator can target, we don't necessarily
    need to mock the data during the development of a given feature—the data is already
    there. However, the existence of an API that's used by an action creator shouldn't
    rule out the existence of a mocked version.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在Flux系统中模拟数据，需要分发的动作必须将这个模拟数据传递给存储。这是通过创建一个替代的动作创建器函数实现，该函数分发动作。当动作创建器已经有一个可以针对的API时，我们不一定需要在开发特定功能时模拟数据——数据已经存在了。然而，动作创建器使用的API的存在不应排除存在一个模拟版本的可能性。
- en: 'The main reason we would want to do this is because at any given point during
    the lifetime of our product, there''s going to be a missing API that we need.
    As we''ll see in the next section, we''ll obviously want to mock the data returned
    by this API, so we can continue implementing the feature we''re working on. But
    do we really want to mock some actions and not others? The idea is illustrated
    here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要这样做的主要原因是因为在我们产品的生命周期中的任何时刻，都可能存在一个我们需要但尚未出现的API。正如我们将在下一节中看到的，显然我们想要模拟这个API返回的数据，以便我们能够继续实现我们正在工作的功能。但我们真的想要模拟一些动作而不模拟其他动作吗？这个想法在这里得到了说明：
- en: '![Mocking existing APIs](img/B05419_04_04.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![模拟现有API](img/B05419_04_04.jpg)'
- en: 'The challenge with this approach—mocking some actions while actually implementing
    others—is consistency. When we''re mocking data that enters the system, we have
    to be cognizant of the relationships between one set of data and another. Look
    at it from the perspective of our stores—they''ll likely have dependencies on
    one another. Can we capture these dependencies using a mixture of mock data and
    actual data? Here is an illustration of actions that mock the entirety of the
    system:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法——模拟一些动作而实际实现其他动作——的挑战在于一致性。当我们模拟进入系统的数据时，我们必须意识到一组数据与另一组数据之间的关系。从我们存储的角度来看——它们之间可能存在依赖关系。我们能否使用模拟数据和实际数据混合来捕捉这些依赖关系？以下是一个模拟整个系统动作的示例：
- en: '![Mocking existing APIs](img/B05419_04_05.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![模拟现有API](img/B05419_04_05.jpg)'
- en: It's better to have total control over the data that's used when we experiment
    with new functionality. This eliminates the possibility of errant behavior because
    of some inconsistency in our data. It takes more effort to construct mock data
    like this, but it pays off in the end when we're adding new features and we only
    have to mock one new action at a time, as it's added into the system. As we'll
    see later in this section, it's easy to substitute mock action creators for production
    action creators.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们尝试新功能时，最好对所使用的数据有完全的控制。这消除了由于我们数据中的一些不一致性而导致的错误行为。构建这样的模拟数据需要更多的努力，但当我们添加新功能时，这会带来回报，因为我们每次只需要模拟一个新动作，就像它被添加到系统中一样。正如我们将在本节后面看到的那样，用模拟动作创建器替代生产动作创建器很容易。
- en: Mocking new APIs
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟新API
- en: Once we reach the point during the implementation of a new feature where we're
    missing API functionality, we'll have to mock it. We can use this new mock with
    the other mocks we've created to support other features in the application. The
    advantage of doing this is that it allows us to create something without delay,
    something we can demonstrate to stakeholders. Another benefit of mocking APIs
    as action creator functions is that they can help steer the API in the right direction.
    Without a UI, the API has nothing to base its design on, so this is a good opportunity
    to solicit a design that works best with the application we're building.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现新功能的过程中，当我们缺少API功能时，我们必须进行模拟。我们可以使用这个新的模拟与我们已经创建的其他模拟一起支持应用程序中的其他功能。这样做的好处是，它允许我们立即创建一些东西，我们可以向利益相关者展示。将API作为动作创建者函数进行模拟的另一个好处是，它们可以帮助将API引导到正确的方向。没有UI，API没有任何东西可以基于其设计，所以这是一个征求与我们要构建的应用程序最兼容的设计的好机会。
- en: 'Let''s take a look at some action creator functions that mock the data that''s
    dispatched as action payloads. We''ll start with a basic loader function that
    bootstraps some data into the store for us:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些模拟作为动作有效载荷分发的数据的动作创建者函数。我们将从一个基本的加载函数开始，这个函数将一些数据引导到存储中供我们使用：
- en: '[PRE7]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'This is quite simple. The data we want to mock is part of the function, as
    the action payload. Let''s look at another mock action creator now, one that manipulates
    the state of a store after the data has already been bootstrapped:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当简单。我们想要模拟的数据是函数的一部分，作为动作有效载荷。现在让我们看看另一个模拟动作创建者，它是在数据已经被引导后操纵存储状态的：
- en: '[PRE8]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Once again, we have very specific mock data we're using here, which is fine
    because it's directly coupled to the action creator function that's dispatching
    the action—this is the only way this data can enter the system too. Something
    else that's different about this function is that it's simulating latency by not
    dispatching the action until the `setTimeout()` callback triggers after one second.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，我们在这里使用的是非常具体的模拟数据，这是可以接受的，因为它直接耦合到正在分发动作的动作创建者函数——这也是数据进入系统的唯一方式。这个函数与其他函数不同的另一个特点是，它通过在`setTimeout()`回调在1秒后触发之前不分发动作来模拟延迟。
- en: Note
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We'll take a more detailed look at asynchronous actions, including latency,
    promises, and multiple API endpoints in a later chapter.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后面的章节中更详细地探讨异步动作，包括延迟、承诺和多个API端点。
- en: 'At this point, we have two mock action creator functions available for use.
    But before we start using these functions, let''s create a task store so that
    we can make sure the correct information is being stored:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有可用的两个模拟动作创建者函数。但在我们开始使用这些函数之前，让我们创建一个任务存储，以确保正确的信息被存储：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now that we have a store to handle both actions we''ve just implemented, let''s
    put the store and the actions to use in the `main.js` module of the application:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个存储来处理我们刚刚实现的所有动作，让我们在应用程序的`main.js`模块中使用存储和动作：
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you can see, the tasks were successfully bootstrapped into the store with
    the call to `loadTasks()`, and the state of the second task was updated when we
    called `runTask()`. This latter update isn't logged till one second has elapsed.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，通过调用`loadTasks()`，任务已成功引导到存储中，当我们调用`runTask()`时，第二个任务的状态被更新。这个后者的更新直到一秒后才会被记录。
- en: Replacing action creators
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换动作创建者
- en: At this point, we have a working action creator function that dispatches actions
    with mock payload data into the system. Recall that we don't necessarily want
    to get rid of these action creator functions, because when it's time to implement
    something new, we'll want to use these mocks again.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个工作的动作创建者函数，它将模拟有效载荷数据的动作分发到系统中。回想一下，我们不一定想摆脱这些动作创建者函数，因为当我们需要实现新功能时，我们还想再次使用这些模拟。
- en: 'What we really need is a global switch that toggles the mock mode of the system,
    and this would change the implementation of the action creator function that''s
    used. Here''s a diagram that shows how this might work:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正需要的是一个全局开关，可以切换系统的模拟模式，这将改变使用的动作创建者函数的实现。以下是一个显示这可能如何工作的图解：
- en: '![Replacing action creators](img/B05419_04_06.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![替换动作创建者](img/B05419_04_06.jpg)'
- en: 'The idea here is that there''s a mock version and a production version of the
    same action creator function within the module. This is the easy part; the tricky
    part is going to be implementing a global mock switch so that the correct function
    is exported, depending on the mode of the application:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的想法是在模块内部存在同一动作创建函数的模拟版本和生产版本。这是容易的部分；困难的部分是实现一个全局模拟开关，以便根据应用程序的模式导出正确的函数：
- en: '[PRE11]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This is very handy during development, because the extent of our mocked functions
    is limited to the action creator modules and is controlled by one setting. Let''s
    see how this action creator function is used, regardless of whether the mock or
    the production implementation is exported:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发过程中，这非常方便，因为我们的模拟函数的范围仅限于动作创建模块，并且由一个设置控制。让我们看看这个动作创建函数是如何使用的，无论导出的是模拟还是生产实现：
- en: '[PRE12]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Stateful action creators
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有状态动作创建者
- en: The action creator functions we've looked at so far in this chapter have been
    relatively simple—they dispatch some action when called. But before that happens,
    these action creators will typically reach out to some API endpoint to retrieve
    some data, then dispatch the action, using the data as the payload. These are
    called stateless action creator functions because there's no intermediary state
    about them—no lifecycle in other words.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中我们讨论的动作创建函数相对简单——当被调用时，它们会分发一些动作。但在那之前，这些动作创建者通常会联系某个API端点以检索一些数据，然后使用这些数据作为有效载荷分发动作。这些被称为无状态动作创建函数，因为它们没有中间状态——换句话说，没有生命周期。
- en: In this section, we'll think about things that are stateful and how we might
    go about integrating these into our Flux architecture. Another challenge we could
    face is integrating our Flux application into another architecture. First, we'll
    cover some basic ground on stateful action creators, then we'll look at a concrete
    example using web sockets.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将思考那些有状态的事物，以及我们如何将它们集成到我们的Flux架构中。我们可能面临的另一个挑战是将我们的Flux应用程序集成到另一个架构中。首先，我们将介绍一些关于有状态动作创建者的基础知识，然后我们将通过使用Web
    sockets的实例来查看一个具体的例子。
- en: Integrating with other systems
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 与其他系统集成
- en: 'Most of the time, Flux applications are standalone in the browser. That is,
    they''re not a cog in a larger machine. We will, however, come up against cases
    where our Flux architecture needs to fit into something bigger. For example, if
    we need to interface with components that use a completely different framework,
    then we need to come up with a way to embed our software without compromising
    the Flux patterns. Or perhaps the coupling between our application and the one
    we''re integrating with is a little looser, as when communicating with another
    browser tab. Whatever the case may be, we have to be able to send messages to
    this external system and we need to be able to consume messages from it, translating
    them into actions. Here is an illustration of this idea:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，Flux应用程序在浏览器中是独立的。也就是说，它们不是更大机器上的一个齿轮。然而，我们可能会遇到需要我们的Flux架构适应更大系统的案例。例如，如果我们需要与使用完全不同框架的组件进行接口，那么我们需要想出一个方法来嵌入我们的软件，同时不破坏Flux模式。或者，也许我们的应用程序与我们集成的应用程序之间的耦合稍微松散一些，就像在与另一个浏览器标签页通信时那样。无论情况如何，我们必须能够向这个外部系统发送消息，并且我们需要能够从它那里接收消息，将它们转换为操作。以下是这个想法的说明：
- en: '![Integrating with other systems](img/B05419_04_07.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![与其他系统集成](img/B05419_04_07.jpg)'
- en: As you can see, the Flux architecture depicted here isn't a closed system. The
    main implication is that the typical action creator functions that we're used
    to working with aren't necessarily called within the system. That is, they're
    handling a stream of external messages, using a stateful connection to the other
    system. This is just how web sockets work. We'll look at these stateful action
    creators next.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这里描述的Flux架构不是一个封闭系统。主要影响是，我们习惯于在系统中调用的典型动作创建函数并不一定在系统中被调用。也就是说，它们正在处理外部消息流，使用与另一个系统的有状态连接。这正是Web
    sockets的工作方式。接下来，我们将查看这些有状态的动作创建函数。
- en: Web socket connectivity
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web socket连接
- en: Web socket connectivity is growing to the point of pervasiveness in modern web
    applications, and if we're building a Flux architecture, there's a good chance
    we're going to need to build web socket support. When something changes state
    in the backend, web socket connections are a great way to notify clients about
    such a change. For example, imagine a Flux store is managing the state of some
    piece of backend data, and something causes its state to change—wouldn't we want
    the store to know about it?
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: WebSocket 连接在现代 Web 应用程序中越来越普及，如果我们正在构建 Flux 架构，那么我们很可能需要构建 WebSocket 支持。当后端的状态发生变化时，WebSocket
    连接是通知客户端这种变化的好方法。例如，想象一个 Flux 存储正在管理某些后端数据的状态，如果有什么原因导致其状态发生变化——我们难道不希望存储知道这一点吗？
- en: 'The challenge is that we need a stateful connection in order to receive web
    socket messages and translate them into Flux actions. This is how web socket data
    enters the system. Let''s take a look at some socket listener code:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 挑战在于，我们需要一个有状态的连接来接收 WebSocket 消息并将它们转换为 Flux 操作。这就是 WebSocket 数据进入系统的方式。让我们看看一些
    socket 监听器代码：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'All we''re doing here is creating a simple `actions` map. This is how we call
    the correct action creator function based on the `task` property of the message
    that was received. What''s nice about this approach is that there''s very little
    additional functionality required to make this work; the preceding code is the
    extent of it. The actual action creator functions, constants, and so on, are just
    typical Flux items. Let''s look at the server code that generates these web socket
    messages, so we have an idea of what''s actually being passed to the socket listener
    code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里我们只是创建了一个简单的 `actions` 映射。这是根据接收到的消息的 `task` 属性调用正确的操作创建函数的方法。这种方法的优点是，为了使它工作，所需的额外功能非常少；前面的代码就是全部。实际的操作创建函数、常量等等，都是典型的
    Flux 项目。让我们看看生成这些 WebSocket 消息的服务器代码，以便了解实际上传递给 socket 监听器代码的内容：
- en: '[PRE14]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Over the course of three seconds, we''ll see three web socket messages delivered
    to the client. Each message has a `task` property, and this is the value we''re
    using to determine which action is dispatched. Let''s take a look at the `main.js`
    frontend module and make sure everything''s working as expected:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三秒钟内，我们将看到三个 WebSocket 消息被发送到客户端。每个消息都有一个 `task` 属性，这是我们用来确定要派发哪个操作的值。让我们看一下
    `main.js` 前端模块，确保一切按预期工作：
- en: '[PRE15]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: As you can see, the `connect()` function is responsible for establishing the
    web socket connection. This is a simple implementation, lacking several production-grade
    capabilities, such as reconnecting dropped connections. However, the important
    thing to note here is that this listener is actually located in the same directory
    as the other action modules. We actually want a tight coupling here because the
    main goal of the socket listener is to dispatch actions, by translating web socket
    messages.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`connect()` 函数负责建立 WebSocket 连接。这是一个简单的实现，缺乏一些生产级功能，例如重新连接丢失的连接。然而，这里需要注意的是，这个监听器实际上位于其他操作模块相同的目录中。我们实际上希望这里有一个紧密耦合，因为
    socket 监听器的主要目标是通过转换 WebSocket 消息来派发操作。
- en: Parameterized action creators
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参数化操作创建者
- en: The final section of this chapter focuses on parameterized action creators.
    All the action creator functions we've looked at so far in the chapter have been
    basic functions that don't accept any arguments. This is fine, except for when
    we start to accumulate several unique actions that are nearly identical. Without
    parameterized action creator functions, we'll soon have an endless proliferation
    of functions; this does not scale.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的最后一节重点介绍了参数化操作创建者。到目前为止，本章中我们看到的操作创建者函数都是不接受任何参数的基本函数。这很好，除非我们开始积累几个几乎相同的独特操作。如果没有参数化操作创建者函数，我们很快就会有无穷无尽的函数；这并不适合扩展。
- en: First, we'll establish the goals of passing arguments to action creator functions,
    followed by some example code that implements generic action creator functions.
    We'll then look into creating partial functions to further reduce repetitiveness
    by composing action creators.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将确定传递参数到操作创建函数的目标，然后是一些实现通用操作创建函数的示例代码。然后我们将探讨创建部分函数，通过组合操作创建者来进一步减少重复性。
- en: Removing redundant actions
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除冗余操作
- en: Action creators are plain JavaScript functions. This means that they can accept
    zero or more arguments when called. The whole point of implementing a function,
    regardless of whether or not it's in the context of Flux, is to reduce the amount
    of code we have to write. Action creators in a Flux application are likely to
    accumulate because they drive the behavior of our application. If anything happens,
    it can be traced back to an action. So it's easy to introduce several new actions
    over the course of a day.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 操作创建者是普通的 JavaScript 函数。这意味着它们在调用时可以接受零个或多个参数。无论是否在 Flux 的上下文中实现函数，其整个目的都是减少我们必须编写的代码量。在
    Flux 应用程序中的操作创建者可能会积累，因为它们驱动着我们的应用程序的行为。如果发生任何事情，都可以追溯到操作。因此，在一天之内引入几个新的操作是很常见的。
- en: Once our application has several features implemented, we're bound to have a
    lot of actions. Some of these actions will serve a distinct purpose, while other
    actions will be very similar to each other. In other words, some actions will
    start to feel redundant. The goal is to remove redundant action creator functions
    by introducing parameters.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的应用程序实现了几个功能，我们肯定会有一大堆操作。其中一些操作将服务于一个特定的目的，而其他操作将彼此非常相似。换句话说，一些操作开始感觉重复。目标是通过引入参数来移除重复的操作创建函数。
- en: We should exercise caution in how we go about refactoring our action creator
    functions. There's a strong argument in favor of keeping a dedicated function
    for each type of action in the system. That is, one action creator function should
    only ever dispatch one type of action, not one of several options. Otherwise,
    the traceability of our code will be diminished. We should aim to reduce the total
    number of actions in the system altogether.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在重构操作创建函数的方式上应该谨慎行事。有一个强有力的论点支持为系统中的每种类型的操作保留一个专门的函数。也就是说，一个操作创建函数应该只派发一种类型的操作，而不是几种选项中的一种。否则，我们代码的可追溯性将会降低。我们应该努力减少系统中的操作总数。
- en: Keeping actions generic
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 保持操作通用
- en: 'When actions are generic, the architecture requires less of them. This is a
    good thing because it means there''s less knowledge to keep in our heads as we''re
    writing code. Let''s take a look at a couple of actions that do essentially the
    same thing; in other words, they''re not generic at all. The first action is as
    follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当操作通用时，架构对它们的需求更少。这是一件好事，因为它意味着我们在编写代码时需要记住的知识更少。让我们看看几个本质上做同样事情的几个操作；换句话说，它们根本不是通用的。第一个操作如下：
- en: '[PRE16]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Simple enough—it's using the lodash `sortBy()` function to sort the payload
    before dispatching the action.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 简单到足以——这是使用 lodash 的 `sortBy()` 函数在派发操作之前对有效负载进行排序。
- en: Note
  id: totrans-112
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we wouldn't actually sort payload data like this in the action creator
    function. Think of this as an API mock. The point is that action creator function
    is asking something outside of Flux for data.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们实际上不会在操作创建函数中这样排序有效负载数据。把这看作是一个 API 模拟。重点是操作创建函数正在向 Flux 之外请求数据。
- en: 'Let''s look at another similar but distinct action:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看另一个类似但不同的操作：
- en: '[PRE17]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The only difference here is how we''re sorting the data. If this were a production
    action creator function, we would tell the API to sort the data in descending
    order instead of using lodash to do it in the action creator. Do we need two distinct
    actions for these two sort directions? Or can we eliminate both of them in favor
    of a generic action that accepts a sort direction parameter? Here''s a generic
    implementation of the action:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一区别是我们如何排序数据。如果这是一个生产操作创建函数，我们会告诉 API 按降序排序数据，而不是在操作创建函数中使用 lodash 来做。我们需要两个不同的操作来处理这两种排序方向吗？或者我们可以通过一个接受排序方向参数的通用操作来消除这两个操作？以下是通用实现的示例：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here are all three actions being used. Note that the third action covers both
    cases, and yet the fundamental sort action is the same no matter what arguments
    are passed. You can see in the dispatcher callback function that stores would
    have an easier time listening to one action instead of two or more:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是所有三个正在使用的操作。请注意，第三个操作涵盖了两种情况，而且无论传递什么参数，基本的排序操作都是相同的。您可以在存储回调函数中看到，存储器会更愿意监听一个操作而不是两个或更多：
- en: '[PRE19]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Creating action partials
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建操作部分
- en: In some cases, function arguments are straightforward—as in there are one or
    two of them. In others, the argument lists can be daunting, especially when we're
    calling them repeatedly using the same handful of arguments. Action creators in
    Flux applications are no different. There will be cases where we have a generic
    function that supports the odd case where, instead of a new action creator function,
    we simply supply a different parameter. But in the most common case, where the
    same parameters have to be supplied all the time, this can get repetitive to the
    point where it defeats the purpose of having generic functions.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，函数参数是直接的——比如有一个或两个参数。在其他情况下，参数列表可能会令人望而生畏，尤其是当我们反复使用相同的一小部分参数调用它们时。Flux应用中的动作创建函数也不例外。会有一些情况，我们有一个通用函数，它支持偶尔的情况，即不是提供一个新的动作创建函数，而是提供一个不同的参数。但在最常见的情况下，必须始终提供相同的参数，这可能会变得重复，以至于失去了通用函数的意义。
- en: Let's look at a generic action creator function that accepts a variable number
    of arguments. Since the same arguments are passed to the function in the most
    common case, we'll also export a partial version of the function where these arguments
    have been partially applied.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个通用的动作创建函数，它接受可变数量的参数。由于在大多数情况下，相同的参数会被传递给函数，因此我们还会导出一个部分应用了这些参数的函数的版本。
- en: Note
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Default parameters in ES2015 syntax are a good alternative to creating partial
    functions, but only when the number of arguments is fixed.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在ES2015语法中，默认参数是创建部分函数的良好替代品，但只有当参数数量固定时。
- en: '[PRE20]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Now let''s see how these two versions of the same action creator are used:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看这两个相同动作创建函数版本的使用方法：
- en: '[PRE21]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Note
  id: totrans-128
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's important to note that the `first()` and `firstCommon()` functions are
    the same action creator, and this is why they're defined in the same module. If
    we were to define `firstCommon()` in another action module, this would lead to
    confusion, because they both use the same action type—`FIRST`.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`first()` 和 `firstCommon()` 函数是同一个动作创建函数，这就是为什么它们被定义在同一个模块中的原因。如果我们把
    `firstCommon()` 定义在另一个动作模块中，这会导致混淆，因为它们都使用相同的动作类型——`FIRST`。
- en: Summary
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about the action creator functions that Flux applications
    utilize in order to dispatch actions. Without action creator functions, we'd have
    to directly interface with the dispatcher in our code, which makes the architecture
    more difficult to reason about.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了Flux应用利用的动作创建函数，以便分发动作。如果没有动作创建函数，我们就必须直接在我们的代码中与分发器接口，这使得架构更难推理。
- en: We started off by thinking about action naming conventions and the general organization
    of our action modules. Grouping action creators by feature has implications for
    modularity as well, especially in how this influences modularity in other areas
    of the architecture.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先思考了动作命名约定和我们的动作模块的一般组织结构。按功能分组动作创建函数对模块化也有影响，尤其是在它如何影响架构的其他方面。
- en: Next, we discussed mocking data using action creator functions. Mocking data
    in Flux applications is easy to do and encouraged. Actions are the only way for
    data to enter the system, making it easy for us to switch between mocked action
    data and our production implementations. We wrapped the chapter up with a look
    at stateful action creators that listen to things such as web socket connections,
    and a look at parameterized action creators that keep repetitive code to a minimum.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们讨论了使用动作创建函数来模拟数据。在Flux应用中模拟数据很容易做到，并且是被鼓励的。动作是数据进入系统的唯一方式，这使得我们能够轻松地在模拟动作数据和我们的生产实现之间切换。我们通过查看监听诸如WebSocket连接等内容的可状态动作创建函数，以及查看将重复代码保持在最低限度的参数化动作创建函数来结束这一章。
- en: In the next chapter, we'll address another key aspect of action creator functions—asynchronicity.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将解决动作创建函数的另一个关键方面——异步性。
