<html><head></head><body>
        

                            
                    <h1 class="header-title" id="calibre_pb_0">Mastering the Cache API - Managing Web Assets in a Podcast Application</h1>
                
            
            
                
<p class="calibre2">The most important service worker superpower is the ability to use a local response cache, making the network optional. Service workers can do this because they can intercept network requests and check if a response has previously been cached before passing the request to the network. They can also be programmed to cache any network response for future use. This allows the website to possibly load instantly and regardless of the network state, which is another way of saying your web apps can work offline.</p>
<p class="calibre2">This super power relies on two newer platform features, Fetch and the Cache APIs. Before adding caching to the Podstr application, we need to learn the details of the APIs.</p>
<p class="calibre2">You first saw fetch in <a target="_blank" href="part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 4,</a> <em class="calibre13">Service Workers – Notification, Synchronization, and Our Podcast App</em>, but it was only a simple introduction. Before we dive into using the Cache API, we are going to take a deep dive into the Fetch API and its support objects. After learning the details of these APIs, we can start stacking our skills to build caching strategies and make our web applications robust, offline progressive web applications.</p>
<p class="calibre2">The following topics will be covered in this chapter:</p>
<ul class="calibre10">
<li class="calibre11">How the Fetch API works</li>
<li class="calibre11">The <kbd class="calibre12">Request</kbd>, <kbd class="calibre12">Response</kbd>, <kbd class="calibre12">header</kbd> objects and other Fetch API features</li>
<li class="calibre11">How the Cache API works</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Using the Fetch API</h1>
                
            
            
                
<p class="calibre2">We have already seen the Fetch API being used in <a target="_blank" href="part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 4</a>, <em class="calibre13">Service Workers – Notification, Synchronization, and Our Podcast App</em>, so let's do a quick review. Fetch is a modern replacement for <kbd class="calibre12">XMLHttpRequest</kbd>. It is asynchronous, relying on promises, and provides a more streamline interface to manage dynamic requests. You can customize requests by creating custom <kbd class="calibre12">Request</kbd> and <kbd class="calibre12">header</kbd> objects. Service workers rely on Fetch to make network requests.</p>
<p class="calibre2">The <kbd class="calibre12">fetch()</kbd> method takes two parameters, the URL that you are requesting (or a <kbd class="calibre12">request</kbd> object) and an <kbd class="calibre12">options</kbd> object. This method returns a <kbd class="calibre12">promise</kbd> object.</p>
<p class="calibre2">There are also some differences from how you may be accustomed to making AJAX requests. Fetch does not usually throw an exception on HTTPS status codes, only if there is a network problem making the request, which typically indicates a platform or hardware issue. Any response from the server, even if it is an error status code such as 404: Page Not Found or 500: Server Error is still considered a successful request.</p>
<p class="calibre2">This is because the browser cannot judge the success of the request in the eyes of the application. You are responsible for validating the response, which you see being done in the first code example, demonstrating a basic fetch request with a check for a successful response. If the response status is anything but 200 (good response), an error message is logged.</p>
<p class="calibre2">Another difference is how cookies are managed. Fetch does not send cookies to or from the server. This means if you rely on cookie-based authentication tokens, you will need to use the credentials property in fetch's initial options.</p>
<p class="calibre2">The <kbd class="calibre12">fetch</kbd> method accepts two parameters, a <kbd class="calibre12">request</kbd> object or URL and an optional <kbd class="calibre12">init</kbd> object. The first parameter is either a valid URL or a <kbd class="calibre12">request</kbd> object. If the URL is provided, fetch creates a default request to call the network. The <kbd class="calibre12">request</kbd> object is covered in the next section.</p>
<p class="calibre2">If the init parameter is not supplied or a property is not set, the default values are used. The <kbd class="calibre12">init</kbd> object can contain the following properties:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">method</kbd>: HTTP verb; GET, POST, PUT, DELETE, and so on.</li>
<li class="calibre11"><kbd class="calibre12">headers</kbd>: Custom HTTP headers are added to your request. They can be part of either a <kbd class="calibre12">header</kbd> object or an object <kbd class="calibre12">literal</kbd>.</li>
<li class="calibre11"><kbd class="calibre12">body</kbd>: Any data passed to the server. It can be a <kbd class="calibre12">Blob</kbd>, <kbd class="calibre12">Buffer</kbd>, <kbd class="calibre12">FormData</kbd>, <kbd class="calibre12">QueryString,</kbd> or <kbd class="calibre12">String</kbd> object.</li>
<li class="calibre11"><kbd class="calibre12">mode</kbd>: <kbd class="calibre12">cors</kbd>, <kbd class="calibre12">no-cors</kbd>, or <kbd class="calibre12">same-origin</kbd>.</li>
<li class="calibre11"><kbd class="calibre12">credentials</kbd>: <kbd class="calibre12">omit</kbd>, <kbd class="calibre12">same-origin</kbd>, or <kbd class="calibre12">include</kbd> (required). It indicates how authentication cookies are handled.</li>
<li class="calibre11"><kbd class="calibre12">cache</kbd>: <kbd class="calibre12">default</kbd>, <kbd class="calibre12">no-store</kbd>, <kbd class="calibre12">reload</kbd>, <kbd class="calibre12">no-cache</kbd>, <kbd class="calibre12">force-cache</kbd>, or <kbd class="calibre12">only-if-cached</kbd>.</li>
<li class="calibre11"><kbd class="calibre12">redirect</kbd>: <kbd class="calibre12">follow</kbd> or <kbd class="calibre12">manual</kbd>.</li>
<li class="calibre11"><kbd class="calibre12">referrer</kbd>: <kbd class="calibre12">no-referrer</kbd>, client (default), or a URL.</li>
<li class="calibre11"><kbd class="calibre12">referrerPolicy</kbd>: <kbd class="calibre12">no-referrer</kbd>, <kbd class="calibre12">no-referrer-when-downgrade</kbd>, <kbd class="calibre12">origin</kbd>, <kbd class="calibre12">origin-when-cross-origin</kbd>, or <kbd class="calibre12">unsafe-url</kbd>.</li>
<li class="calibre11"><kbd class="calibre12">keepalive</kbd>: Can improve performance by keeping the connection after the response is delivered.</li>
</ul>
<p class="calibre2">When you supply just a URL or a URL and an init object, the <kbd class="calibre12">fetch</kbd> method creates a request from those parameters. When you supply your own <kbd class="calibre12">request</kbd> object, it contains those values. One of the cool things about the Fetch API is its ability to create a custom <kbd class="calibre12">request</kbd> object. This means you can intercept a request in your service worker and transform it into a different request.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Request object</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">Request</kbd> constructor has the same two parameters as the <kbd class="calibre12">fetch</kbd> method has, a URL and option initialization object. The following code modifies the fetch example to use a custom <kbd class="calibre12">request</kbd> object:</p>
<pre class="calibre17">var myRequest = new Request("./api/podcast/" + id + ".json"); 
 
fetch(myRequest).then(function(response) { 
      if (response.status !== 200) {   
        console.log('Status Code: ' + response.status);   
        return;   
      } 
    return response.json(); 
}).then(function(response) { 
    console.log(data);   
}); </pre>
<p class="calibre2">You can do much more than just create a <kbd class="calibre12">request</kbd> object from a URL. You can craft a request using various options. While most requests are simple GET requests, there are many times where you need to craft something custom. The <kbd class="calibre12">request</kbd> object gives you the flexibility to make these requests.</p>
<p class="calibre2">The following example shows how to manage a potential redirect situation where you have changed your primary image folder:</p>
<pre class="calibre17"> 
self.addEventListener("fetch", function (event) { 
 
  event.respondWith( 
 
   var re = /img/S+/g; 
 
   if(re.test(request.url)){ 
 
       request = new Request(request.url.replace("img", "images"), 
               { 
                  method: request.method, 
                  headers: request.headers, 
                  mode: request.mode, 
                  credentials: request.credentials 
               }); 
 
   } 
 
   return fetch(request) 
      .then(function (response) { 
         //process response  
      }) 
  ); 
 
}); 
 </pre>
<p class="calibre2">Of course, there are many other potential scenarios where you might need to modify a request before sending it to the network. Remember, if you make a custom request and cache the response, you will need to modify the request before checking the cache.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Handling cross-origin requests</h1>
                
            
            
                
<p class="calibre2">You may also need to address a URL on a separate domain. Because of potential security holes, access to these URLs is often protected. You can access these URLs using <strong class="calibre4">Cross</strong><strong class="calibre4">-Origin Resource Sharing</strong> (<strong class="calibre4">CORS</strong>), an additional layer, which relies on headers to control access.</p>
<p class="calibre2">It is up to the server to tell the browser if it is alright for the browser to access the resource. CORS is a protocol that enables these cross-origin requests. There are actually two requests required to complete a cross-origin request. The first is a pre-flight request (<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests" class="calibre9">https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#Preflighted_requests</a>) where the server tells the browser that the request is approved. After that, the original request is made.</p>
<p class="calibre2">Fetch will not make the pre-flight request unless the <kbd class="calibre12">mode</kbd> property is set to <kbd class="calibre12">cors</kbd>. The remaining part of the CORS request is handled in the <kbd class="calibre12">response</kbd> object. I will cover that in a later section.</p>
<p class="calibre2">There are four different request modes: <kbd class="calibre12">cors</kbd>, <kbd class="calibre12">no-cors</kbd>, <kbd class="calibre12">same-origin</kbd>, and <kbd class="calibre12">navigate</kbd>. You won't use navigate because it is only used to navigate between pages. Thus, it is created by the browser.</p>
<p class="calibre2">The default mode is <kbd class="calibre12">same-origin</kbd>, which limits requests to the <kbd class="calibre12">same-origin</kbd>. If a request to an external domain is made, an error is thrown:</p>
<pre class="calibre17">var myRequest = new Request("./api/podcast/" + id + ".json", 
                        {mode: "cors"}); 
 
fetch(myRequest).then(function(response) { 
      if (response.status !== 200) {   
        console.log('Status Code: ' + response.status);   
        return;   
      } 
     return response.json(); 
}).then(function(response) { 
     console.log(data);   
}); </pre>
<p class="calibre2">A <kbd class="calibre12">no-cors</kbd> request limits the type of request methods to GET, HEAD, and POST. When using <kbd class="calibre12">no-cors</kbd>, the service worker is limited in how it can modify the request and what response properties it can access.</p>
<p class="calibre2">You can still request resources from a separate origin using no-cors, but the types of response types are limited. For example, you can fetch an image, but you are limited as to what you can do with the response. These are called <strong class="calibre4">opaque requests</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Managing request credentials</h1>
                
            
            
                
<p class="calibre2">By default, fetch does not append cookies to requests. This is good for both security and performance. In most scenarios, accessing an API does require cookie-based authentication. For these scenarios, you need to set the credentials property to either <kbd class="calibre12">same-origin</kbd> or include. The default value is <kbd class="calibre12">omit</kbd>.</p>
<p class="calibre2">By setting the <kbd class="calibre12">credentials</kbd> option to include or <kbd class="calibre12">same-origin</kbd>, the request will include the authentication cookies. The include value triggers the <kbd class="calibre12">request</kbd> object to include the credentials for any target origin, and the <kbd class="calibre12">same-origin</kbd> limits the credentials to the <kbd class="calibre12">same-origin</kbd>:</p>
<pre class="calibre17">var myRequest = new Request("./api/podcast/" + id + ".json", 
                       { 
                          mode: "cors", 
                          credentials: "include" 
                       }); 
 
fetch(myRequest).then(function(response) { 
      if (response.status !== 200) {   
        console.log('Status Code: ' + response.status);   
        return;   
      } 
     return response.json(); 
}).then(function(response) { 
     console.log(data);   
}); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Controlling how a response is cached</h1>
                
            
            
                
<p class="calibre2">Another important request option is the cache property. This property controls how the browser uses its own cache. Since service workers provide a cache, you can programmatically control the browser cache, but it might seem a bit redundant and cause some unwanted responses.</p>
<p class="calibre2">The default cache value changes nothing; the browser checks its own cache before making a network call and the response is the best one based on the default caching rules.</p>
<p class="calibre2">However, by setting the request cache option to another value, you can force the browser to bypass or change the way it uses the browser cache. The options are as follows:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">default</kbd></li>
<li class="calibre11"><kbd class="calibre12">no-store</kbd></li>
<li class="calibre11"><kbd class="calibre12">reload</kbd></li>
<li class="calibre11"><kbd class="calibre12">no-cache</kbd></li>
<li class="calibre11"><kbd class="calibre12">force-cache</kbd></li>
<li class="calibre11"><kbd class="calibre12">only-if-cached</kbd></li>
</ul>
<p class="calibre2">Since the service worker cache provides a superior method to cache assets, I tend to use it, and may want to remove the browser's cache from the pipeline. In this scenario, you would want to change the cache property to <kbd class="calibre12">no-store</kbd>:</p>
<pre class="calibre17">var myRequest = new Request("./api/podcast/" + id + ".json", 
                       { 
                          mode: "cors", 
                          credentials: "include", 
                          cache: "no-store" 
                       }); 
 
fetch(myRequest).then(function(response) { 
      if (response.status !== 200) {   
        console.log('Looks like there was a problem. Status Code: ' +   
          response.status);   
        return;   
      } 
     return response.json(); 
}).then(function(response) { 
     console.log(data);   
}); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Headers object</h1>
                
            
            
                
<p class="calibre2">Customizing request headers is important when crafting unique requests and responses between the client and server. The request headers property is a <kbd class="calibre12">Headers</kbd> object. <kbd class="calibre12">Header</kbd> objects are used by both <kbd class="calibre12">request</kbd> and <kbd class="calibre12">response</kbd> objects.</p>
<p class="calibre2"><kbd class="calibre12">Headers</kbd> are a way for the client and server to communicate extra information about the request and response. Think about them as meta data about the data being sent back and forth.</p>
<p class="calibre2">For example, when a response includes gzip compressed data, the Content-Encoding header tells the browser so it can decompress the body. Before returning a compressed response, the server looks for a corresponding header, such as accept-encoding, telling it that the client can accept a compressed response.</p>
<p class="calibre2">The <kbd class="calibre12">Headers</kbd> object manages the headers list. Member methods provide the ability to manage headers associated with a request or response.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Adding Headers</h1>
                
            
            
                
<p class="calibre2">Headers can be added either in the constructor or via the <kbd class="calibre12">append</kbd> method. The following example uses the <kbd class="calibre12">Headers</kbd> constructor:</p>
<pre class="calibre17">var httpHeaders = {  
'Content-Type' : 'image/jpeg',  
'Accept-Charset' : 'utf-8',  
'X-My-Custom-Header' : 'custom-value'  
}; 
var myHeaders = new Headers(httpHeaders); </pre>
<p class="calibre2">Headers can also be added using the <kbd class="calibre12">append</kbd> method:</p>
<pre class="calibre17">var myHeaders = new Headers(); 
myHeaders.append('Content-Type', 'image/jpeg'); 
myHeaders.append('Accept-Charset', 'utf-8); 
myHeaders.append('X-My-Custom-Header', 'custom-value'); </pre>
<p class="calibre2">A final way to add headers is by using the <kbd class="calibre12">set</kbd> method:</p>
<pre class="calibre17">var myHeaders = new Headers(); 
myHeaders.set('Content-Type', 'image/jpeg'); 
myHeaders.set('Accept-Charset', 'utf-8); 
myHeaders.set('X-My-Custom-Header', 'custom-value'); </pre>
<p class="calibre2">The difference between <kbd class="calibre12">append</kbd> and <kbd class="calibre12">set</kbd> is the latter one will overwrite any existing values. While the <kbd class="calibre12">append</kbd> method adds the header value to the list of headers, the <kbd class="calibre12">append</kbd> method should be used for headers that allow multiple values.</p>
<p class="calibre2">An example multiple-value header is Cache-Control. There are many combinations you may need to set to provide instructions to different clients and intermediaries.</p>
<p class="calibre2">For example, the best way to manage cache on HTML assets with my CDN is to mark them as private, with a 3,600 seconds time to live. You may also include a value for CDN caching, maybe 300 seconds. This means my CDN will naturally invalidate after 300 seconds, reducing my need to force updates.</p>
<p class="calibre2">Using the <kbd class="calibre12">append</kbd> method requires up to three calls:</p>
<pre class="calibre17">myHeaders.append('Cache-Control', 'private'); 
myHeaders.append('Cache-Control', 'max-age=3600'); 
myHeaders.append('Cache-Control', 's-max-age=300'); </pre>
<p class="calibre2">The <kbd class="calibre12">set</kbd> method writes the final value, overwriting any previous value:</p>
<pre class="calibre17">myHeaders.set('Cache-Control', 'private, max-age=3600, s-max-age=300'); </pre>
<p class="calibre2">Headers are a complex topic, so I recommend finding more resources if you need to dig deeper into specific headers and their values. Wikipedia is a good place to start (<a href="https://en.wikipedia.org/wiki/List_of_HTTP_header_fields" class="calibre9">https://en.wikipedia.org/wiki/List_of_HTTP_header_fields</a>) as its page provides a very thorough list with details and further links to specifications.</p>
<p class="calibre2">There is a limit to the amount of headers you can manage. There are headers that are restricted to the browser and others that are restricted to the server, which means you are not allowed to change them.</p>
<p class="calibre2">If you try to append or set an invalid header, an exception will be thrown.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Accessing Header values</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">get</kbd> method returns a specific headers value:</p>
<pre class="calibre17">Var cacheHeader = myHeaders.get('Cache-Control'); 
    //returns 'private, max-age=3600, s-max-age=300' </pre>
<p class="calibre2">The <kbd class="calibre12">entries</kbd> method returns an iterator you can use to loop through all the headers. Each entry is a simple array, with the first entry being the header key name and the second member being the value:</p>
<pre class="calibre17">// Display the key/value pairs 
for (var header of myHeaders.entries()) { 
   console.log(header[0]+ ': '+ header[1]); 
} </pre>
<p class="calibre2">The <kbd class="calibre12">keys</kbd> method also provides an iterator, but only returns a list of header names:</p>
<pre class="calibre17">// Display the keys 
for(var key of myHeaders.keys()) { 
   console.log(key);  
} </pre>
<p class="calibre2">Conversely, you can get a list of values from the <kbd class="calibre12">values</kbd> method. The problem with this method is that the values are not directly correlated to their keys:</p>
<pre class="calibre17">// Display the values 
for (var value of myHeaders.values()) { 
   console.log(value);  
} </pre>
<p class="calibre2">You can check if a header exists by calling the <kbd class="calibre12">has</kbd> method:</p>
<pre class="calibre17">myHeaders.has(name); </pre>
<p class="calibre2">A header can be removed using the <kbd class="calibre12">delete</kbd> method:</p>
<pre class="calibre17">myHeaders.delete(name); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Protected Headers</h1>
                
            
            
                
<p class="calibre2">Headers have a guard property. This flag indicates if headers can be manipulated. If you try to manipulate a header whose guard is set to immutable, an exception is thrown.</p>
<p class="calibre2">These are the possible guard states:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">none</kbd>: Default</li>
<li class="calibre11"><kbd class="calibre12">request</kbd>: Guard for a Headers object obtained from a Request (<kbd class="calibre12">Request.headers</kbd>)</li>
<li class="calibre11"><kbd class="calibre12">request-no-cors</kbd>: Guard for a Headers object obtained from a Request that's been created with mode <kbd class="calibre12">no-cors</kbd></li>
<li class="calibre11"><kbd class="calibre12">response</kbd>: Naturally, for Headers obtained from Response (<kbd class="calibre12">Response.headers</kbd>)</li>
<li class="calibre11"><kbd class="calibre12">immutable</kbd>: Mostly used for ServiceWorkers; renders a <kbd class="calibre12">Headers</kbd> object</li>
</ul>
<p class="calibre2">The actual rules controlling how different headers can be manipulated is very detailed. If you want to know more about these details, I recommend reading the Fetch specification (<a href="https://fetch.spec.whatwg.org/" target="_blank" class="calibre9">https://fetch.spec.whatwg.org/</a>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Body mixin</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">Request</kbd> and <kbd class="calibre12">Response</kbd> objects both have a <kbd class="calibre12">body</kbd> property. This is actually a mixin or a class that implements the body interface. The body contains a data stream with methods to retrieve the contents according to the type.</p>
<p class="calibre2">Each <kbd class="calibre12">body</kbd> method reads the stream and converts it into the desired format. The stream is completely read and a <kbd class="calibre12">promise</kbd> is returned, resolving to the formatted data.</p>
<p class="calibre2">You have already seen how to use the <kbd class="calibre12">json()</kbd> method to read JSON formatted data. There is also the <kbd class="calibre12">text</kbd>, <kbd class="calibre12">blob</kbd>, <kbd class="calibre12">formData</kbd>, and <kbd class="calibre12">arrayBuffer</kbd> methods. Each one resolves the body to the corresponding format.</p>
<p class="calibre2">To review how to use JSON formatted data, let's see how to retrieve search results in the Podstr application:</p>
<pre class="calibre17">    function fetchSearch(term) { 
 
        fetch("api/search.json?term=" + term) 
            .then(function (response) { 
 
                if (response.status !== 200) {      
                    console.log('Status Code: ' + response.status); 
                    return;     
                }    
 
                return response.json(); 
 
            }).then(function (results) { 
                renderResults(results); 
            }) 
            .catch(function (err) { 
                console.log('No CORS Fetch Error :-S', err); 
            }); 
    } 
 </pre>
<p class="calibre2">Notice how the <kbd class="calibre12">json()</kbd> mixin is available as a method of the response. That's because each of the body mixins implements the Body interface and are added to the Response object.</p>
<p class="calibre2">The mixin returns a promise, resolving the JSON object. Remember, you cannot directly use the return value of the body mixins because they return a promise. You need to process the formatted data in a promise handler, which is the <kbd class="calibre12">then</kbd> method.</p>
<p class="calibre2">JSON may be the most common format used by modern APIs, but there are times when you retrieve other formats – the simplest being plain text.</p>
<p class="calibre2">Fetching plain text looks almost identical to fetching JSON. Instead of using the json mixin, use the <kbd class="calibre12">text</kbd> mixin:</p>
<pre class="calibre17">fetch("api/simple.txt") 
    .then(function (response) { 
     
        if (response.status !== 200) {      
         console.log('Status Code: ' + response.status);      
         return;     
        }    
     
        return response.text(); 
 
    }) 
    .then(function(result){ 
        renderResult(result); 
    }) 
    .catch(function (err) { 
        console.log('Fetch Error :-S', err); 
    }); 
 </pre>
<p class="calibre2">The following example shows how to fetch an audio file (<kbd class="calibre12">ogg</kbd> format) and buffer the data to an <kbd class="calibre12">AudioContext</kbd> object:</p>
<pre class="calibre17">        source = audioCtx.createBufferSource(); 
 
        fetch('./viper.ogg') 
            .then(function (response) { 
                return response.arrayBuffer(); 
            }) 
            .then(function (buffer) { 
                audioCtx.decodeAudioData(buffer, function (decodedData) { 
                    source.buffer = decodedData; 
                    source.connect(audioCtx.destination); 
                }); 
            }); 
 </pre>
<p class="calibre2">So far, we have seen how to use a response body, but you can also set the body in a request. A common scenario is posting form data.</p>
<p class="calibre2">This example shows how to POST the contact form as a JSON object. The method is set to <kbd class="calibre12">'post'</kbd> and custom headers are supplied. The custom headers tell the server you are sending a JSON formatted body with the <kbd class="calibre12">Content-Type</kbd> header. You are also telling the server (the <kbd class="calibre12">Accept</kbd> header) that you expect a JSON object back.</p>
<p class="calibre2">The form is serialized or converted to a JSON object in the <kbd class="calibre12">serializeForm</kbd> method (not shown):</p>
<pre class="calibre17"> 
fetch("/api/contact/, { 
    method: 'post', 
    headers: { 
        'Accept': 'application/json, text/plain, */*', 
        'Content-Type': 'application/json; charset=UTF-8' 
    }, 
    body: JSON.stringify(serializeForm()) 
}).then(function (res) { 
 
    if (res.status &gt;= 200 &amp;&amp; res.status &lt; 400) { 
        // Success! 
   return res.json(); 
 
    } else { 
  console.log('Status Code: ' + response.status);      
     return; 
    } 
}).then(function (resp) { 
    //process the response 
}); 
 </pre>
<p class="calibre2">You can also post the raw form using the <kbd class="calibre12">FormData</kbd> object (<a href="https://developer.mozilla.org/en-US/docs/Web/API/FormData" target="_blank" class="calibre9">https://developer.mozilla.org/en-US/docs/Web/API/FormData</a>). Make sure that the API you are posting to can handle the form data:</p>
<pre class="calibre17"> var form = document.querySelector("[name=contact-form]"); 
 
fetch("/api/contact/, { 
    method: 'post', 
    body: new FormData(form) 
}).then(function (res) { 
 
    if (res.status &gt;= 200 &amp;&amp; res.status &lt; 400) { 
        // Success! 
   return res.json(); 
    } else { 
  console.log('Status Code: ' + response.status);      
     return; 
    } 
}).then(function (resp) { 
    //process the response 
}); </pre>
<p class="calibre2">The last aspect of the body you need to know about is the <kbd class="calibre12">bodyUsed</kbd> property. This can be checked to see if you can still use the body or not. A body can only be read once.</p>
<p class="calibre2">The body is a stream, which is a forward only set of data. Attempting to read the body more than once results in an exception being thrown.</p>
<p class="calibre2">If you need to read or use a body more than once, you should clone the request or response. A common scenario is when a service worker fetches a URL and caches the response while returning the response to the client. You will see this in more detail in the next chapter:</p>
<pre class="calibre17">fetch(request) 
     .then(function (response) { 
 
         var rsp = response.clone(); 
 
         //cache response for the next time around 
         return caches.open(cacheName).then(function (cache) { 
             cache.put(request, rsp); 
             return response; 
         }); 
 
     }) </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Response object</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">response</kbd> object is almost identical to the <kbd class="calibre12">request</kbd> object. It is created when a request receives an answer from the server. Response objects also have headers and a body, the same object types as <kbd class="calibre12">request</kbd> objects.</p>
<p class="calibre2">Responses are normally created by the platform when a response is received from the server. However, you can create a new response. This is more common when you want to transform a response.</p>
<p class="calibre2">A scenario I have dealt with is accessing data from an older API that returned flat data. The flat data needed to be transformed into a multi-dimensional JSON object. Instead of repeating that CPU intensive process, I transformed the data and cached the transformed response.</p>
<p class="calibre2">The Response constructor has two parameters, a Body object and an initialization object. We have already gone over Body objects in <a target="_blank" href="part0088.html#2JTHG0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 4</a>, <em class="calibre13">Service Workers – Notification, Synchronization, and Our Podcast App</em>. The Response initialization object is slightly different than the <kbd class="calibre12">request</kbd> object.</p>
<p class="calibre2">Response object properties that differ from the <kbd class="calibre12">request</kbd> object are as follows:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">status</kbd>: The status code for the reponse, for example, <kbd class="calibre12">200</kbd></li>
<li class="calibre11"><kbd class="calibre12">statusText</kbd>: The status message associated with the status code, for example, <kbd class="calibre12">OK</kbd></li>
<li class="calibre11"><kbd class="calibre12">headers</kbd>: Any headers you want to add to your response, contained within a Headers object or object literal of <kbd class="calibre12">ByteString</kbd> key/value pairs (see HTTP headers for a reference)</li>
</ul>
<p class="calibre2">There are only three properties, one being a Headers object. The other two properties indicate the HTTP status. There is a code, status, and a text value, statusText.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Response properties</h1>
                
            
            
                
<p class="calibre2">Most of the Response object properties are similar to a <kbd class="calibre12">request</kbd> object, most notably the Body and its mixins.</p>
<p class="calibre2">The <kbd class="calibre12">isRedirected</kbd> property indicates if the response is the product of a redirected (HTTPS status code <kbd class="calibre12">301</kbd> or <kbd class="calibre12">302</kbd>) response.</p>
<p class="calibre2">The type property is <kbd class="calibre12">readonly</kbd>, and tells us if the response had a network error (error), opaque (cross-origin with a no-cors request, cors, and basically inidicates a successful response.</p>
<p class="calibre2">The <kbd class="calibre12">url</kbd> property is the final response URL, after any redirects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Verifying a successful response</h1>
                
            
            
                
<p class="calibre2">As I mentioned earlier, fetch does not throw an exception or return an error if the response status is not 200. Instead, as long as fetch receives a response, it does not fail. It is still up to you to interrogate the response status to determine how you want to process the response.</p>
<p class="calibre2">The <kbd class="calibre12">ok</kbd> property is true if the status code is 200-299, and false otherwise. It can be a quick way to verify a request's success. Just be careful, as sometimes you can receive a 0 status code for cached, cross-origin responses.</p>
<p class="calibre2">In practice, many requests can have a range of successful status codes. HTTP status codes are grouped by 100s. 200-299 indicates a successful response, while 300-399 indicates a redirect and is accompanied by a new address. <kbd class="calibre12">400</kbd> indicates that the URL is not accessible, <kbd class="calibre12">404</kbd> being the most well-known. Other reasons a resource is not accessible have to do with authorization or permission to access the resource. Finally, anything in the 500 range indicates that there is a server-side problem.</p>
<p class="calibre2">Having a strategy to handle different statuses is important for the success of your application. Checking the <kbd class="calibre12">response.ok</kbd> value may not give you the entire story. I found that Chrome returns a status equal to 0 for external origin resources stored in the cache. The response is still successful, but limiting your logic to check for <kbd class="calibre12">response.ok</kbd> would lead to excess network requests.</p>
<p class="calibre2">Now that you know the details of the Fetch API, it's time to start learning how the Cache API works. The Cache API depends on the Fetch API because it caches request-response pairs.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Caching responses</h1>
                
            
            
                
<p class="calibre2">We have been able to store content, including data and site assets using web storage and IndexedDB for several years. Using either medium requires a library or custom logic to manage site assets, which is why the service worker specification includes a specialized Cache API.</p>
<p class="calibre2">The Cache interface provides a managed storage mechanism for Request/Response object pairs. These objects are also referred to as network addressable resources, but you can think about them as just files or API responses.</p>
<p class="calibre2">The Cache API has a natural advantage over <kbd class="calibre12">IndexedDB</kbd> and <kbd class="calibre12">localStorage</kbd> because it is designed to abstract, persisting these assets by the <kbd class="calibre12">Request</kbd> and <kbd class="calibre12">Response</kbd> objects. This means that you can reference the assets using more than just a single key value, like <kbd class="calibre12">localStorage</kbd> provides.</p>
<p class="calibre2">Besides providing a managed interface to store assets, it also allows you to organize those assets into groups or caches. As we progress through the remaining chapters, you will see how to use this power to segregate the assets to make updating and invalidating easier.</p>
<p class="calibre2">Caches, like other browser storage services, are managed by the browser by origin, or domain. This prevents third parties from accessing the content that's stored your site. Your overall storage quota is also tied to the origin and allocated across the various storage services.</p>
<p class="calibre2">The amount of space available varies by device and is proportional to the available disk space. Like income tax, the rule governing your quota allowance varies by the amount of available space.</p>
<p class="calibre2">Ali Alabbas shared the following slide at the Microsoft Edge Developer Summit, explaining the rules governing storage quotas:</p>
<div><img src="img/00070.jpeg" class="calibre84"/></div>
<p class="calibre2">If space becomes limited, the browser will arbitrarily purge stored data from the different storage providers. Unless you manage this process, you have no guarantee that your assets have remained cached.</p>
<p class="calibre2">The Cache API is part of the service worker specification because it is the backbone to make your progressive web application work offline. Without the ability to save assets for immediate access, your site could not work offline.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Caches object</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">Caches</kbd> object represents a collection of named caches and members to interact with those caches. The interface provides methods to open, create, iterate, and remove individual caches. You can also match cached responses over all the named caches without interrogating each one.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">caches.open</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">caches.open</kbd> method returns a reference to a cache matching the name that's supplied. This reference is a <kbd class="calibre12">Cache</kbd> object, which is detailed in later sections. If a cache matching the name does not exist, a new cache is provisioned. This returns a promise; resolving a cache object allows you to manage cached responses in that cache:</p>
<pre class="calibre17">caches.open(cacheName).then(function (cache) { 
//do something here 
}); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">caches.match</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">caches.match</kbd> method is a convivence method that works similarly to the <kbd class="calibre12">cache.match</kbd> method. It returns a promise that resolves to the first cached response matching the <kbd class="calibre12">Request</kbd> object passed to the method.</p>
<p class="calibre2">The nice thing about the <kbd class="calibre12">caches.match</kbd> method is how it handles interrogating all named caches for a match. It returns the first match it finds.</p>
<p class="calibre2">This means that if matching responses are stored in different caches, you have no control over which response is found. To avoid a scenario where an invalid response is matched, you need to ensure that your logic invalidates outdated cached responses before caching an update:</p>
<pre class="calibre17">return caches.match(request) 
    .then(function (response) { 
   return response; 
    }) </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">caches.has()</h1>
                
            
            
                
<p class="calibre2">If you need to check if a named cache exists, the <kbd class="calibre12">has</kbd> method returns a promise, resolving true:</p>
<pre class="calibre17">caches.has(cacheName).then(function(ret) { 
  // true: your cache exists! 
}); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">caches.delete()</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">delete</kbd> method searches for a cache matching the name supplied. If a matching cache is found, it is deleted. A promise is returned that resolves true if a matching cache was deleted or false if one was not deleted:</p>
<pre class="calibre17">Cached.delete(cacheName).then((ret)=&gt;{ console.log(cacheName + " deleted: " + res}); </pre>
<p class="calibre2">You don't always need to add code to handle the response. Typically, you would log the activity. If no cache was deleted, it is most likely due to the cache not existing, which in that case you probably have nothing to worry about.</p>
<p class="calibre2">You should also note that if you delete a cache, all of the cached items are deleted along with it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">caches.keys()</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">keys</kbd> method returns a promise with an array of names (strings) for each named cache. This list can be iterated over for processing.</p>
<p class="calibre2">The following example is placed within the service worker activate event handler. It removes caches that were crafted for a previous service worker version. This concept was covered in <a target="_blank" href="part0114.html#3CN040-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 5</a>, <em class="calibre13">The Service Worker Life Cycle</em>:</p>
<pre class="calibre17">    caches.keys().then(function (cacheNames) { 
      cacheNames.forEach(function (value) { 
        if (value.indexOf(version) &lt; 0) { 
          caches.delete(value); 
        } 
      }); 
      return; 
    }) </pre>
<p class="calibre2">Notice the <kbd class="calibre12">delete</kbd> method does not have any processing after a cache is deleted. If you wanted to log any problems regarding deleting a cache, you could do that here.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">The Cache object</h1>
                
            
            
                
<p class="calibre2">The Cache interface is a collection of methods and properties to manage stored responses. You cannot create a cache object; you must open a reference to a cache using the <kbd class="calibre12">Caches.open</kbd> method, which will be covered later. This reference is an instance of the Cache object, giving you access to the responses it manages.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">cache.match()</h1>
                
            
            
                
<p class="calibre2">The <kbd class="calibre12">match</kbd> method has two parameters, a <kbd class="calibre12">request</kbd> object and an optional options object. It returns a promise if a matching response is found to be resolved in the promise's return. If no response was found, the promise still resolves, but as undefined.</p>
<p class="calibre2">If no match was found, you can then continue with the appropriate logic, like forwarding the request to the network or returning a fallback response.</p>
<p class="calibre2">The <kbd class="calibre12">request</kbd> object parameter can be either a valid <kbd class="calibre12">request</kbd> object or a URL. If only a URL is provided, the method does an implicit conversion internally. Supplying a <kbd class="calibre12">request</kbd> object gives you more control because different responses could be cached by request variations.</p>
<p class="calibre2">For example, the same URL might have a cached response for both <kbd class="calibre12">HEAD</kbd> and <kbd class="calibre12">GET</kbd> methods, each being unique. Differing <kbd class="calibre12">QueryStrings</kbd> is another common example where similar URLs have different responses cached.</p>
<p class="calibre2">The optional <kbd class="calibre12">options</kbd> parameter allows you to provide more details to the <kbd class="calibre12">match</kbd> method about the specific request you want to match. You can think of it as a way of filtering potential matches.</p>
<p class="calibre2">The <kbd class="calibre12">options</kbd> object has a set of potential properties you can provide a value to match or filter against.</p>
<p class="calibre2">The potential options that are available are as follows:</p>
<ul class="calibre10">
<li class="calibre11"><kbd class="calibre12">ignoreSearch</kbd>: Indicates if you want to use the <kbd class="calibre12">QueryString</kbd> or not. The options are true or false.</li>
<li class="calibre11"><kbd class="calibre12">ignoreMethod</kbd>: Indicates if you want to filter by the <kbd class="calibre12">request</kbd> method, for example GET, POST, DELETE, and so on. By default, match does use the request method to match a response.</li>
<li class="calibre11"><kbd class="calibre12">ignoreVary</kbd>: When set to true, headers are ignored when retrieving a match. The URL is used as the filter, which means cached responses for different header combinations could match.</li>
<li class="calibre11"><kbd class="calibre12">cacheName</kbd>: This limits matching responses to a specific cache name. Multiple responses could be cached across different named caches, but this specifies which cache should be used.</li>
</ul>
<p class="calibre2">For most queries, you won't use these options because they are highly specialized. <kbd class="calibre12">ignoreSearch</kbd> has the most potential to be used because <kbd class="calibre12">QueryString</kbd> parameters are very common. Servers typically return different responses based on how these values vary:</p>
<pre class="calibre17">return namedCache.match(request).then(function (response) { 
   return response; 
    }); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">cache.matchAll</h1>
                
            
            
                
<p class="calibre2">Similar to the <kbd class="calibre12">match</kbd> method, the <kbd class="calibre12">matchAll()</kbd> method takes request and options (optional) parameters. The method returns a promise that resolves an array of matching responses. Unlike the same method on the Caches object, it only returns matches in the specifically named cache.</p>
<p class="calibre2">The main difference between <kbd class="calibre12">matchAll</kbd> and match is that the <kbd class="calibre12">match</kbd> method returns the first response it matches.</p>
<p class="calibre2">The <kbd class="calibre12">matchAll</kbd> method is useful when you need to match responses using a route, not just a specific URL. For example, if you want to get a list of all a podcast's banner images, you could do something like this:</p>
<pre class="calibre17">caches.open("podcasts").then(function(cache) { 
  cache.matchAll('/images/').then(function(response) { 
    response.forEach(function(element, index, array) { 
         //do something with each response/image 
    }); 
  }); 
}); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Cache add and addAll</h1>
                
            
            
                
<p class="calibre2">If you want to retrieve an asset and immediately cache the response, the <kbd class="calibre12">add</kbd> and <kbd class="calibre12">addAll</kbd> methods manage this process. The <kbd class="calibre12">add</kbd> method is equivalent to the following code:</p>
<pre class="calibre17">    const precache_urls = [...] 
 
    caches.open(preCacheName).then(function (cache) { 
      return cache.addAll(precache_urls); 
    }) </pre>
<p class="calibre2">Both the <kbd class="calibre12">add</kbd> and <kbd class="calibre12">addAll</kbd> methods have a single parameter: a <kbd class="calibre12">request</kbd> object. Like the <kbd class="calibre12">match</kbd> method, you can also supply a valid URL and the method will convert it into a <kbd class="calibre12">request</kbd> object.</p>
<p class="calibre2">Both methods return a promise, but do not resolve a value. As long as there were no exceptions making and caching the requests, you can use the resolution to continue the application workflow. If there was an exception, you can catch and handle it appropriately.</p>
<p class="calibre2">The add methods are useful in the install and activate life cycle events because you can provide a list of URLs to precache. You are not limited to these scenarios, as they can be called anytime.</p>
<p class="calibre2">They are not helpful during most caching strategies, which are initiated by the fetch event handler. We will go over many of these strategies in the following chapter. When handling real-time fetches, the network response is typically needed to render a page. These methods do not return access to the responses.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">cache.put</h1>
                
            
            
                
<p class="calibre2">Despite what you might think, the <kbd class="calibre12">add</kbd> method do not let you cache a response directly. If you receive a network response from a fetch call, you would need to explicitly handle its caching. This is where the <kbd class="calibre12">put</kbd> method gives you the control needed to cache a response with the flexibility to use the response in parallel to the caching process.</p>
<p class="calibre2">As you will learn in the next chapter, there are many different caching strategies where a network response is cached once the network request resolves.</p>
<p class="calibre2">The <kbd class="calibre12">put</kbd> method has two parameters, <kbd class="calibre12">request</kbd> and <kbd class="calibre12">response</kbd>. These are the same <kbd class="calibre12">Request</kbd> and <kbd class="calibre12">Response</kbd> objects that were covered in the <em class="calibre13">Fetch</em> section.</p>
<p class="calibre2">The <kbd class="calibre12">put</kbd> method uses these two objects to catalog the assets in a key value fashion, sort of like localStorage, just specialized for caching page assets.</p>
<p class="calibre2">The <kbd class="calibre12">put</kbd> method returns a promise, but does not resolve a value.</p>
<p class="calibre2">If you need to use the response, you should clone it before caching. A response body can only be used once, but the <kbd class="calibre12">response</kbd> object has a <kbd class="calibre12">clone</kbd> method that creates a copy. I typically cache the copy and return the original, but it does not matter.</p>
<p class="calibre2">The following code demonstrates how to fetch a resource, clone the response, cache the clone, and return the original response:</p>
<pre class="calibre17">fetch(request).then(function (response) { 
   var rsp = response.clone(); 
   //cache response for the next time around 
   return caches.open(cacheName).then(function (cache) { 
       cache.put(request, rsp); 
       return response; 
   }); 
}); </pre>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Deleting Cached items</h1>
                
            
            
                
<p class="calibre2">You are also responsible for periodically purging cache entries. The browser will not invalidate cache for you. It might purge items if available space becomes limited. However, I would not worry about this scenario. Instead, you need a plan to delete cached assets so that you can control how long an item is cached for.</p>
<p class="calibre2">The best way to manage or invalidate cached assets is to apply a set of rules to control your cache. <a target="_blank" href="part0174.html#55U1S0-f12cdcca08b54960b3d271452dc7667d" class="calibre9">Chapter 8</a>, <em class="calibre13">Applying Advanced Service Worker Cache Strategies</em>, goes into more detail about invalidation strategies. Before you reach that level, it's important to know how to remove an asset or delete an entire cache.</p>
<p class="calibre2">The <kbd class="calibre12">delete</kbd> method returns a promise that resolves true if a matching response was found and deleted, otherwise it returns false:</p>
<pre class="calibre17">cache.delete(request,{options}).then(function(true) { 
  //your cache entry has been deleted 
}); </pre>
<p class="calibre2">This method has two parameters, a request and an optional options object. The options are the same ones that are used in the match method. This is because you can cache multiple responses to a URL if there are different request variations using those options.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">cache.keys</h1>
                
            
            
                
<p class="calibre2">The cache object's <kbd class="calibre12">key</kbd> method returns a promise that resolves an array of requests that are stored in the cache. The method has two optional parameters, request and options. These are the same two types we have seen for the other methods.</p>
<p class="calibre2">When supplying these parameters, the <kbd class="calibre12">keys</kbd> method works much like the match and <kbd class="calibre12">matchAll</kbd> methods.</p>
<p class="calibre2">The array of keys or requests can then be used to update your cache. For example, you could loop through and delete all matches or maybe do a silent background update:</p>
<pre class="calibre17">caches.open(cacheName).then(function(cache) { 
  cache.keys().then(function(keys) { 
    keys.forEach(function(request) { 
      fetchAndUpdateCache(cacheName, request); 
    }); 
  }); 
}) </pre>
<p class="calibre2">The keys are returned in insertion order. This can come in handy if you want to manage cache invalidation by removing the oldest pair(s) first. We'll review some cache invalidation strategies in the later chapters. You will see how this can be done along with some other strategies.</p>


            

            
        
    

        

                            
                    <h1 class="header-title" id="calibre_pb_0">Summary</h1>
                
            
            
                
<p class="calibre2">In this chapter, we saw how the Fetch and Cache APIs are critical for the service workers. To get the most out of service workers, you need to be able to intercept and manipulate requests and the server responses. Because service workers rely on asynchronous functions (Promises), you must use Fetch, as a new replacement for <kbd class="calibre12">XMLHttpRequest</kbd>.</p>
<p class="calibre2">The Cache API provides a new storage medium in the browser, which is highly specialized for request/response pairs. The API is a rich platform, providing the maximum amount of control over network resources.</p>
<p class="calibre2">Your goal is to use the best logic and platform resources to make your website load quickly and work offline. Now that you know how the Fetch and Cache APIs work, it's time to start crafting the best caching system you can.</p>
<p class="calibre2">In the next chapter, we will review different caching patterns and start seeing how they can be applied so that you can determine what strategy you should employ in your applications.</p>


            

            
        
    </body></html>