- en: '1'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '1'
- en: Lifecycles in Svelte
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Svelte中的生命周期
- en: Svelte is a frontend framework. You can use Svelte to build websites and web
    applications. A Svelte application is made up of components. You write a Svelte
    component within a file with `.svelte` extension. Each `.svelte` file is one Svelte
    component.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte是一个前端框架。你可以使用Svelte来构建网站和Web应用程序。一个Svelte应用程序由组件组成。你可以在具有`.svelte`扩展名的文件中编写Svelte组件。每个`.svelte`文件都是一个Svelte组件。
- en: When you create and use a Svelte component, the component goes through various
    stages of the component lifecycle. Svelte provides lifecycle functions, allowing
    you to hook into the different stages of the component.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建和使用一个Svelte组件时，该组件会经历组件生命周期的各个阶段。Svelte提供了生命周期函数，允许你钩入组件的不同阶段。
- en: In this chapter, we will start by talking about the various lifecycles and the
    lifecycle functions in Svelte. With a clear idea of lifecycles in mind, you will
    then learn the basic rule of using the lifecycle functions. This is essential,
    as you will see that this understanding will allow us to use the lifecycle functions
    in a lot of creative ways.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将首先讨论Svelte中的各种生命周期和生命周期函数。在心中有了对生命周期的清晰认识后，你将学习使用生命周期函数的基本规则。这是非常重要的，因为你会发现这种理解将使我们能够以很多创造性的方式使用生命周期函数。
- en: 'This chapter contains sections on the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含以下主题的章节：
- en: What are Svelte lifecycle functions?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Svelte生命周期函数是什么？
- en: The rule of calling lifecycle functions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用生命周期函数的规则
- en: How to reuse and compose lifecycle functions
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何重用和组合生命周期函数
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Writing Svelte applications is very easy and does not require any paid tools.
    Despite the added value of most paid tools, we decided to use only free tools
    to make the content of this book available to you without any limitations.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 编写Svelte应用程序非常简单，不需要任何付费工具。尽管大多数付费工具都有附加价值，但我们决定只使用免费工具，以便您无限制地获取本书的内容。
- en: 'You will require the following:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你将需要以下内容：
- en: Visual Studio Code as the integrated development environment ([https://code.visualstudio.com/](https://code.visualstudio.com/))
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio Code作为集成开发环境([https://code.visualstudio.com/](https://code.visualstudio.com/))
- en: A decent web browser (Chrome, Firefox, or Edge, for instance)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个不错的网络浏览器（例如Chrome、Firefox或Edge）
- en: Node.js as the JavaScript runtime environment ([https://nodejs.org/](https://nodejs.org/))
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Node.js作为JavaScript运行环境([https://nodejs.org/](https://nodejs.org/))
- en: 'All the code examples for this chapter can be found on GitHub at: [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01)'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的所有代码示例都可以在GitHub上找到：[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01)
- en: Code for all chapters can be found at [https://github.com/PacktPublishing/Real-World-Svelte](https://github.com/PacktPublishing/Real-World-Svelte).
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 所有章节的代码可以在[https://github.com/PacktPublishing/Real-World-Svelte](https://github.com/PacktPublishing/Real-World-Svelte)找到。
- en: Understanding the Svelte lifecycle functions
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解Svelte的生命周期函数
- en: 'When using a Svelte component, it goes through different stages throughout
    its lifetime: mounting, updating, and destroying. This is similar to a human being.
    We go through various stages in our lifetime, such as birth, growth, old age,
    and death, throughout our lifetime. We call the different stages lifecycles.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用Svelte组件时，它在其生命周期中会经历不同的阶段：挂载、更新和销毁。这类似于人类。我们一生中会经历各种阶段，如出生、成长、老年和死亡。我们称这些不同的阶段为生命周期。
- en: Before we talk about lifecycles in Svelte, let’s look at a Svelte component.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们讨论Svelte中的生命周期之前，让我们先看看一个Svelte组件。
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Can you tell me when each part of the code is executed?
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你能告诉我代码的每个部分何时执行吗？
- en: Not every part of the code is executed at once; different parts of the code
    are executed at different stages of the component lifecycle.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的并非所有部分都会同时执行；代码的不同部分会在组件生命周期的不同阶段执行。
- en: 'A Svelte component has four different lifecycle stages: initializing, mounting,
    updating, and destroying.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte组件有四个不同的生命周期阶段：初始化、挂载、更新和销毁。
- en: Initializing the component
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 初始化组件
- en: When you create a component, the component first goes through the initialization
    phase. You can think of this as the setup phase, where the component sets up its
    internal state.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个组件时，组件首先会进入初始化阶段。你可以将其视为设置阶段，此时组件会设置其内部状态。
- en: This is where lines 2–7 are being executed.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是第2-7行正在执行的地方。
- en: The `count` variable is declared and initialized. The `onMount`, `beforeUpdate`,
    `afterUpdate`, and `onDestroy` lifecycle functions are called, with callback functions
    passed in, to register them at the specific stages of the component lifecycles.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 声明并初始化 `count` 变量。调用 `onMount`、`beforeUpdate`、`afterUpdate` 和 `onDestroy` 生命周期函数，并传入回调函数，以在组件生命周期的特定阶段注册它们。
- en: 'After the component is initialized, Svelte starts to create elements in the
    template, in this case, a `<button>` element and text elements for `"Counter:
    "` and `{count}`.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '在组件初始化后，Svelte 开始在模板中创建元素，在这种情况下，是一个 `<button>` 元素和用于 `"Counter: "` 和 `{count}`
    的文本元素。'
- en: Mounting the component
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 挂载组件
- en: After all the elements are created, Svelte will insert them in order into the
    **Document Object Model** **(DOM)**. This is called the mounting phase, where
    elements are mounted onto the DOM.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在所有元素创建完成后，Svelte 将按顺序将它们插入到 **文档对象模型** **(DOM)** 中。这被称为挂载阶段，其中元素被挂载到 DOM 上。
- en: 'If you add Svelte actions to an element, then the actions are called with the
    element:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向一个元素添加 Svelte 动作，那么这些动作将与元素一起被调用：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: We will explore Svelte actions in more depth in [*Chapter 5*](B18887_05.xhtml#_idTextAnchor080)
    to *7*.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在 [*第 5 章*](B18887_05.xhtml#_idTextAnchor080) 到 *7* 中更深入地探讨 Svelte 动作。
- en: If and when you add event listeners to the element, this is when Svelte will
    attach the event listeners to the element.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向元素添加事件监听器，这就是 Svelte 将事件监听器附加到元素的时候。
- en: In the case of the preceding example, Svelte attaches the `click` event listener
    onto the button after it is inserted into the DOM.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在前一个示例中，Svelte 在将按钮插入 DOM 之后将其附加到 `click` 事件监听器上。
- en: 'When we add bindings to an element, the bound variable gets updated with values
    from the element:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们向一个元素添加绑定时，绑定的变量会根据元素的值进行更新：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is when the `element` variable gets updated with the reference to the `<div>`
    element created by Svelte.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，`element` 变量将更新为 Svelte 创建的 `<div>` 元素的引用。
- en: If and when you add transitions to an element, this is when the transitions
    are initialized and start playing.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你向一个元素添加转换，这就是转换被初始化并开始播放的时候。
- en: 'The following snippet is an example of adding a transition to an element. You
    can add a transition to an element using the `transition:`, `in:`, and `out:`
    directives. We will explore more about Svelte transitions in [*Chapter 13*](B18887_13.xhtml#_idTextAnchor187)
    to *15*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个向元素添加转换的示例。你可以使用 `transition:`, `in:`, 和 `out:` 指令向元素添加转换。我们将在 [*第 13 章*](B18887_13.xhtml#_idTextAnchor187)
    到 *15* 中更深入地探讨 Svelte 转换：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: After all the directives, `use:` (actions), `on:` (event listeners), `bind:`
    bindings, `in:`, `transition:` (transitions), are processed, the mounting phase
    comes to an end by calling all the functions registered in the `onMount` lifecycle
    functions.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理完所有指令，`use:`（动作），`on:`（事件监听器），`bind:` 绑定，`in:`，`transition:`（转换）之后，通过调用在
    `onMount` 生命周期函数中注册的所有函数，挂载阶段结束。
- en: This is when the function on line 4 is executed, and you will see `"onMount!"`
    printed in the logs.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这时，第 4 行的函数将被执行，你将在日志中看到打印出 `"onMount!"`。
- en: Updating the component
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新组件
- en: When you click on the button, the `click` event listener is called. The function
    on line 9 is executed. The `count` variable is incremented.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击按钮时，`click` 事件监听器被调用。第 9 行的函数被执行。`count` 变量被增加。
- en: Right before Svelte modifies the DOM based on the latest value of the `count`
    variable, the functions registered in the `beforeUpdate` lifecycle function are
    called.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Svelte 根据最新的 `count` 变量值修改 DOM 之前，将调用在 `beforeUpdate` 生命周期函数中注册的函数。
- en: The function on line 5 is executed, and you will see the text `"beforeUpdate!"`
    printed in the logs.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 第 5 行的函数将被执行，你将在日志中看到打印出文本 `"beforeUpdate!"`。
- en: 'At this point, if you attempt to retrieve the text content within the button,
    it would still be `"``Counter: 0"`.'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '在此阶段，如果你尝试检索按钮内的文本内容，它仍然是 `"``Counter: 0"`。'
- en: 'Svelte then proceeds to modify the DOM, updating the text content of the button
    to `"``Counter: 1"`.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '然后 Svelte 继续修改 DOM，将按钮的文本内容更新为 `"``Counter: 1"`。'
- en: After updating all the elements within the component, Svelte calls all the functions
    registered in the `afterUpdate` lifecycle function.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新组件内的所有元素之后，Svelte 会调用在 `afterUpdate` 生命周期函数中注册的所有函数。
- en: The function on line 6 is executed, and you will see the text `"afterUpdate!"`
    printed in the logs.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 第 6 行的函数被执行，你将在日志中看到打印出文本 `"afterUpdate!"`。
- en: If you click on the button again, Svelte will go through another cycle of `beforeUpdate`,
    and then update the DOM elements, and then `afterUpdate`.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次点击按钮，Svelte 将通过另一个周期的 `beforeUpdate`，然后更新 DOM 元素，然后 `afterUpdate`。
- en: Destroying the component
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 销毁组件
- en: A component that is conditionally shown to a user will remain while the condition
    holds; when the condition no longer holds, Svelte will proceed to destroy the
    component.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当条件成立时，向用户显示的条件性组件将保持不变；当条件不再成立时，Svelte 将继续销毁组件。
- en: Let’s say the component in our example now enters the destroy stage.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们例子中的组件现在进入了销毁阶段。
- en: Svelte calls all the functions registered in the `onDestroy` lifecycle function.
    The function on line 7 is executed, and you will see the text `"onDestroy!"` printed
    in the logs.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 会调用在 `onDestroy` 生命周期函数中注册的所有函数。第 7 行的函数会被执行，你将在日志中看到打印出的文本 `"onDestroy!"`。
- en: After that, Svelte removes the elements from the DOM.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，Svelte 会从 DOM 中移除元素。
- en: Svelte then cleans up the directives if necessary, such as removing the event
    listeners and calling the destroy method from the action.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，Svelte 会清理指令，例如移除事件监听器和从动作中调用销毁方法。
- en: And that’s it! If you try to recreate the component again, a new cycle starts
    again.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果你尝试再次创建组件，新的周期会再次开始。
- en: The Svelte component lifecycle starts with initializing, mounting, updating,
    and destroying. Svelte provides lifecycle methods, allowing you to run functions
    at different stages of the component.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: Svelte 组件的生命周期从初始化、挂载、更新和销毁开始。Svelte 提供生命周期方法，允许你在组件的不同阶段运行函数。
- en: Since the component lifecycle functions are just functions exported from `'svelte'`,
    can you import and use them anywhere? Are there any rules or constraints when
    importing and using them?
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 由于生命周期函数只是从 `'svelte'` 导出的函数，你可以在任何地方导入和使用它们吗？导入和使用它们时有什么规则或约束吗？
- en: Let’s find out.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看。
- en: The one rule for calling lifecycle functions
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调用生命周期函数的一条规则
- en: The only rule for calling component lifecycle functions is that you should call
    them during component initialization. If no component is being initialized, Svelte
    will complain by throwing an error.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 调用组件生命周期函数的唯一规则是，你应该在组件初始化期间调用它们。如果没有组件正在初始化，Svelte 会通过抛出错误来抱怨。
- en: 'Let’s look at the following example:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看以下示例：
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When you click on the button, it will call `buttonClicked`, which will call
    `onMount`. As no component is being initialized when `onMount` is being called,
    (the component above has initialized and mounted by the time you click on the
    button), Svelte throws an error:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 当你点击按钮时，它会调用 `buttonClicked`，这将调用 `onMount`。由于在调用 `onMount` 时没有组件正在初始化（在你点击按钮时，上面的组件已经初始化并挂载），Svelte
    会抛出错误：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Yes, Svelte does not allow lifecycle functions to be called outside of the component
    initialization phase. This rule dictates when you can call the lifecycle functions.
    What it does not dictate is where or how you call the lifecycle functions. This
    allows us to refactor lifecycle functions and call them in other ways.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，Svelte 不允许在组件初始化阶段之外调用生命周期函数。这条规则规定了你可以何时调用生命周期函数。它没有规定在哪里或如何调用生命周期函数。这允许我们重构生命周期函数并以其他方式调用它们。
- en: Refactoring lifecycle functions
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重构生命周期函数
- en: If you look carefully at the rule for calling lifecycle functions, you will
    notice that it is about when you call them, and not where you call them.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仔细观察调用生命周期函数的规则，你会注意到它关乎何时调用它们，而不是在哪里调用它们。
- en: It is not necessary to call lifecycle functions at the top level within the
    `<``script>` tag.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `<script>` 标签的顶层调用生命周期函数并不是必需的。
- en: 'In the following example, the `setup` function is called during component initialization,
    and in turn calls the `onMount` function:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，`setup` 函数在组件初始化期间被调用，然后反过来调用 `onMount` 函数：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Since the component is still initializing, this is perfectly fine.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 由于组件仍在初始化中，这是完全正常的。
- en: 'It is also not necessary to import the `onMount` function within the component.
    As you see in the following example, you can import it in another file; as long
    as the `onMount` function is called during component initialization, it is perfectly
    fine:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，在组件内部导入 `onMount` 函数也不是必需的。正如你在以下示例中看到的，你可以在另一个文件中导入它；只要在组件初始化期间调用 `onMount`
    函数，那就完全没问题：
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the preceding code snippet, we’ve moved the `setup` function we defined
    previously to a new module called `file-a.js`. Then, in the original Svelte component,
    rather than defining the `setup` function, we import it from `file-a.js`, shown
    in the following code snippet:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，我们将之前定义的`setup`函数移动到一个名为`file-a.js`的新模块中。然后，在原始的Svelte组件中，我们不是定义`setup`函数，而是从`file-a.js`中导入它，如下面的代码片段所示：
- en: '[PRE8]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Since the `setup` function calls the `onMount` function, the same rule applies
    to the `setup` function too! You can no longer call the `setup` function outside
    component initialization.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`setup`函数调用了`onMount`函数，同样的规则也适用于`setup`函数！您不能再在组件初始化之外调用`setup`函数。
- en: Which component to register?
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应该注册哪个组件？
- en: Looking at just the `setup` function, you may be wondering, when you call the
    `onMount` function, how does Svelte know which component’s lifecycle you are referring
    to?
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 仅看`setup`函数，您可能会想知道，当您调用`onMount`函数时，Svelte是如何知道您指的是哪个组件的生命周期的？
- en: Internally, Svelte keeps track of which component is initializing. When you
    call the lifecycle functions, it will register your function to the lifecycle
    of the component that is being initialized.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 内部，Svelte跟踪哪个组件正在初始化。当您调用生命周期函数时，它将您的函数注册到正在初始化的组件的生命周期中。
- en: So, the same `setup` function can be called within different components and
    registers the `onMount` function for different components.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，相同的`setup`函数可以在不同的组件中调用，并为不同的组件注册`onMount`函数。
- en: 'This unlocks the first pattern in this chapter: reusing lifecycle functions.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这解锁了本章的第一个模式：重用生命周期函数。
- en: Reusing lifecycle functions in Svelte components
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Svelte组件中重用生命周期函数
- en: In the previous section, we learned that we can extract the calling of lifecycle
    functions into a function and reuse the function in other components.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们了解到我们可以将生命周期函数的调用提取到一个函数中，并在其他组件中重用该函数。
- en: 'Let’s look at an example. In this example, after the component is added to
    the screen for 5 seconds, it will call the `showPopup` function. I want to reuse
    this logic of calling `showPopup` in other components:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子。在这个例子中，组件在屏幕上添加了5秒后，将调用`showPopup`函数。我想在其他组件中重用调用`showPopup`的逻辑：
- en: '[PRE9]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Here, I can extract the logic into a function, `showPopupOnMount`:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我可以将逻辑提取到一个函数中，`showPopupOnMount`：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'And now, I can import this function and reuse it in any component:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我可以导入这个函数并在任何组件中重用它：
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You may be wondering, why not only extract the callback function and reuse that
    instead?
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能想知道，为什么不只提取回调函数并重用它呢？
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Over here, we extract only `setTimeout` and `clearTimeout` logic into `showPopupOnMount`,
    and pass the function into `onMount`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将`setTimeout`和`clearTimeout`逻辑提取到`showPopupOnMount`中，并将该函数传递给`onMount`：
- en: '[PRE13]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In my opinion, the second approach of refactoring and reusing is not as good
    as the first approach. There are a few pros in extracting the entire calling of
    the lifecycle functions into a function, as it allows you to do much more than
    you can otherwise:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，重构和重用的第二种方法不如第一种方法好。将整个生命周期函数的调用提取到函数中有几个优点，因为它允许您做更多的事情：
- en: '*You can pass in different input parameters to your* *lifecycle functions.*'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您可以将不同的输入参数传递给您的生命周期函数。*'
- en: 'Let’s say you wish to allow different components to customize the duration
    before showing the popup. It is much easier to pass that in this way:'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设您希望允许不同的组件自定义显示弹出窗口前的持续时间。以这种方式传递要容易得多：
- en: '[PRE14]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '*You can return values from* *the function.*'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您可以从函数中返回值。*'
- en: Let’s say you want to return the `timeoutId` used in the `onMount` function
    so that you can cancel it if the user clicks on any button within the component.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 假设您想返回`onMount`函数中使用的`timeoutId`，这样您就可以在用户在组件中的任何按钮上点击时取消它。
- en: 'It is near impossible to do so if you just reuse the callback function, as
    the value returned from the callback function will be used to register for the
    `onDestroy` lifecycle function:'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您只是重用回调函数，这将几乎不可能做到，因为回调函数返回的值将用于注册`onDestroy`生命周期函数：
- en: '[PRE15]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'See how easy it is to implement it to return anything if we write it this way:'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 看看这样写，实现它以返回任何内容是多么容易：
- en: '[PRE16]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '*You can encapsulate more logic along with the* *lifecycle functions.*'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*您可以将更多逻辑与生命周期函数一起封装。*'
- en: Sometimes, the code in your lifecycle functions callback function does not work
    in a silo; it interacts with and modifies other variables. To reuse lifecycle
    functions like this, you must encapsulate those variables and logic into a reusable
    function.
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 有时，您在生命周期函数回调函数中的代码在隔离环境中不起作用；它会与其他变量交互并修改它们。为了重用此类生命周期函数，必须将这些变量和逻辑封装到一个可重用的函数中。
- en: To illustrate this, let’s look at a new example.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了说明这一点，让我们看看一个新的例子。
- en: 'Here, I have a counter that starts counting when a component is added to the
    screen:'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里，我有一个计数器，当组件被添加到屏幕上时开始计数：
- en: '[PRE17]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `counter` variable is coupled with the `onMount` lifecycle functions; to
    reuse this logic, the `counter` variable and the `onMount` function should be
    extracted together into a reusable function:'
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`counter` 变量与 `onMount` 生命周期函数相关联；为了重用此逻辑，应将 `counter` 变量和 `onMount` 函数一起提取到一个可重用的函数中：'
- en: '[PRE18]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this example, we use a `writable` Svelte store to make the `counter` variable
    reactive. We will delve more into Svelte stores in *Part 3* of this book.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们使用一个 `writable` Svelte 存储使 `counter` 变量变得响应式。我们将在本书的 *第3部分* 中更深入地探讨
    Svelte 存储。
- en: For now, all you need to understand is that a Svelte store allows Svelte to
    track changes in a variable across modules, and you can subscribe to and retrieve
    the value of the store by prefixing a `$` in front of a Svelte store variable.
    For example, if you have a Svelte store named `counter`, then to get the value
    of the Svelte store, you would need to use the `$``counter` variable.
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 目前，您需要理解的是，Svelte 存储允许 Svelte 跨模块跟踪变量的变化，并且您可以通过在 Svelte 存储变量前加上 `$` 来订阅和检索存储的值。例如，如果您有一个名为
    `counter` 的 Svelte 存储，那么要获取 Svelte 存储的值，您需要使用 `$counter` 变量。
- en: 'Now, we can use the `startCounterOnMount` function in any Svelte component:'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以在任何 Svelte 组件中使用 `startCounterOnMount` 函数：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: I hope I’ve convinced you about the pros of extracting the calling of lifecycle
    functions into a function. Let’s try it out in an example.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 希望我已经说服您提取生命周期函数调用的优点。让我们通过一个例子来试试。
- en: Exercise 1 – Update counter
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1 – 更新计数器
- en: In the following example code, I want to know how many times the component has
    gone through the update cycle.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例代码中，我想知道组件经过了多少次更新周期。
- en: Using the fact that every time the component goes through the update cycle,
    the `afterUpdate` callback function will be called, I created a counter that will
    be incremented every time the `afterUpdate` callback function is called.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 利用每次组件经过更新周期时都会调用 `afterUpdate` 回调函数的事实，我创建了一个计数器，每次 `afterUpdate` 回调函数被调用时都会递增。
- en: 'To help us measure only the update count of a certain user operation, we have
    functions to start measuring and stop measuring, so the update counter is only
    incremented when we are measuring:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助我们仅测量特定用户操作的更新计数，我们有开始测量和停止测量的函数，因此更新计数器仅在测量时递增：
- en: '[PRE20]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'To reuse all the logic of the `counter:` – the counting of update cycles and
    the starting and stopping of the measurement – we should move all of it into a
    function, which ends up looking like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 为了重用 `counter:` 的所有逻辑——更新周期的计数以及测量开始和停止——我们应该将所有这些移动到一个函数中，最终看起来像这样：
- en: '[PRE21]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The update counter returns an object that contains the `updateCount` variable
    and the `startMeasuring` and `stopMeasuring` functions.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 更新计数器返回一个包含 `updateCount` 变量和 `startMeasuring` 以及 `stopMeasuring` 函数的对象。
- en: The implementation of the `createUpdateCounter` function is left as an exercise
    to you, and you can check the answer at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/01-update-counter](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/01-update-counter).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`createUpdateCounter` 函数的实现留作练习，您可以在 [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/01-update-counter](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/01-update-counter)
    查看答案。'
- en: 'We’ve learned how to extract a lifecycle function and reuse it, so let’s take
    it up a notch and reuse multiple lifecycle functions in the next pattern: composing
    lifecycle functions.'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何提取生命周期函数并重用它，所以让我们更进一步，在下一个模式中重用多个生命周期函数：组合生命周期函数。
- en: Composing lifecycle functions into reusable hooks
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将生命周期函数组合成可重用钩子
- en: So far, we’ve mainly talked about reusing one lifecycle function. However, there’s
    nothing stopping us from grouping multiple lifecycle functions to perform a function.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要讨论了重用单个生命周期函数。然而，没有任何阻止我们将多个生命周期函数组合起来执行一个函数。
- en: 'Here’s an excerpt from the example at [https://svelte.dev/examples/update](https://svelte.dev/examples/update).
    The example shows a list of messages. When new messages are added to the list,
    the container will automatically scroll to the bottom to show the new message.
    In the code snippet, we see that this automatic scrolling behavior is achieved
    by using a combination of `beforeUpdate` and `afterUpdate`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 这里摘录了来自 [https://svelte.dev/examples/update](https://svelte.dev/examples/update)
    的示例。该示例显示了一个消息列表。当新消息被添加到列表中时，容器会自动滚动到最底部以显示新消息。在代码片段中，我们看到这种自动滚动行为是通过结合使用 `beforeUpdate`
    和 `afterUpdate` 实现的：
- en: '[PRE22]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'To reuse this `autoscroll` logic in other components, we can extract the `beforeUpdate`
    and `afterUpdate` logic together into a new function:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 要在其他组件中重用这个 `autoscroll` 逻辑，我们可以将 `beforeUpdate` 和 `afterUpdate` 逻辑一起提取到一个新函数中：
- en: '[PRE23]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We can then use the extracted function, `setupAutoScroll`, in any component:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以在任何组件中使用提取的函数，`setupAutoScroll`：
- en: '[PRE24]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the refactored `setupAutoscroll` function, we return a `setDiv` function
    to allow us to update the reference of the `div` used within the `setupAutoscroll`
    function.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构后的 `setupAutoscroll` 函数中，我们返回一个 `setDiv` 函数，以便我们可以在 `setupAutoscroll` 函数内部更新
    `div` 的引用。
- en: As you’ve seen, by adhering to the one rule of calling lifecycle functions during
    component initialization, you can compose multiple lifecycle functions into reusable
    hooks. What you’ve learned so far is sufficient for composing lifecycle functions,
    but there are more alternatives on the horizon. In the upcoming chapters, you’ll
    explore Svelte actions in [*Chapter 5*](B18887_05.xhtml#_idTextAnchor080) and
    the Svelte store in [*Chapter 8*](B18887_08.xhtml#_idTextAnchor121), expanding
    your options further. Here’s a sneak peek at some of these alternatives.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，通过遵循在组件初始化期间调用生命周期函数的一条规则，你可以将多个生命周期函数组合成可重用的钩子。到目前为止你所学的足以组合生命周期函数，但未来还有更多替代方案。在接下来的章节中，你将探索第
    [*5章*](B18887_05.xhtml#_idTextAnchor080) 中的 Svelte 动作和第 [*8章*](B18887_08.xhtml#_idTextAnchor121)
    中的 Svelte 存储，进一步扩展你的选择。以下是一些这些替代方案的预览。
- en: An alternative implementation could be to make `div` a writable store and return
    it from the `setupAutoscroll` function. This way, we could bind to the `div` writable
    store directly instead of having to call `setDiv` manually.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种实现方式可能是将 `div` 设为一个可写存储，并在 `setupAutoscroll` 函数中返回它。这样，我们就可以直接绑定到 `div` 可写存储，而无需手动调用
    `setDiv`。
- en: 'Alternatively, we could return a function that follows the Svelte action contract
    and use the action on the `div`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，我们可以返回一个遵循 Svelte 动作合约的函数，并在 `div` 上使用该动作：
- en: '[PRE25]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`setupAutoscroll` now returns an action, and we use the action on our `div`
    container:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '`setupAutoscroll` 现在返回一个动作，我们使用这个动作在我们的 `div` 容器上：'
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We will discuss the Svelte action contract in more detail later in the book.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本书的后面部分更详细地讨论 Svelte 动作合约。
- en: We’ve seen how we can extract lifecycle functions into a separate file and reuse
    it in multiple Svelte components. Currently, the components call the lifecycle
    functions independently and function as standalone units. Is it possible to synchronize
    or coordinate actions across components that uses the same lifecycle functions?
    Let’s find out.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到如何将生命周期函数提取到单独的文件中，并在多个 Svelte 组件中重用它。目前，组件独立调用生命周期函数，并作为独立单元运行。是否有可能同步或协调使用相同生命周期函数的组件之间的动作？让我们来找出答案。
- en: Coordinating lifecycle functions across components
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在组件间协调生命周期函数
- en: As we reuse the same function across components, we can keep track globally
    of the components that use the same lifecycle function.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在组件间重用相同的函数，我们可以全局跟踪使用相同生命周期函数的组件。
- en: Let me show you an example. Here, I would like to keep track of how many components
    on the screen are using our lifecycle function.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 让我给你举一个例子。在这里，我想跟踪屏幕上有多少组件正在使用我们的生命周期函数。
- en: 'To count the number of components, we can define a module-level variable and
    update it within our lifecycle function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算组件的数量，我们可以在模块级别定义一个变量，并在我们的生命周期函数中更新它：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: As the `counter` variable is declared outside the `setupGlobalCounter` function,
    the same `counter` variable instance is used and shared across all the components.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 `counter` 变量是在 `setupGlobalCounter` 函数外部声明的，因此相同的 `counter` 变量实例被用于并共享在所有组件之间。
- en: When any component is mounted, it will increment the `counter`, and any component
    that is referring to the `counter` will get updated with the latest counter value.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 当任何组件被挂载时，它将增加 `counter`，任何引用 `counter` 的组件都将更新为最新的计数器值。
- en: This pattern is extremely useful when you want to set up a shared communication
    channel between components and tear it down in `onDestroy` when the component
    is being destroyed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 当你想要在组件之间设置一个共享的通信通道并在组件被销毁时在`onDestroy`中将其拆除时，这种模式非常有用。
- en: Let’s try to use this technique in our next exercise.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试在我们的下一个练习中使用这项技术。
- en: Exercise 2 – Scroll blocker
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2 – 滚动阻止器
- en: Usually, when you add a pop-up component onto the screen, you want the document
    to not be scrollable so that the user focuses on the popup and only scrolls within
    the popup.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，当你将一个弹出组件添加到屏幕上时，你希望文档不可滚动，这样用户就能专注于弹出窗口，并且只在该弹出窗口内滚动。
- en: This can be done by setting the `overflow` CSS property of the body to `"hidden"`.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过将`body`的`overflow` CSS属性设置为`"hidden"`来实现。
- en: Write a reusable function used by pop-up components that disables scrolling
    when the pop-up component is mounted. Restore the initial `overflow` property
    value when the pop-up component is destroyed.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 编写一个可重用的函数，该函数由弹出组件使用，在弹出组件安装时禁用滚动。当弹出组件被销毁时，恢复初始的`overflow`属性值。
- en: Do note that it is possible to have more than one pop-up component mounted on
    the screen at once, so you should only restore the `overflow` property value when
    all the popups are destroyed.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，屏幕上可以同时安装多个弹出组件，因此只有当所有弹出窗口都被销毁时，你才应该恢复`overflow`属性值。
- en: You can check the answer at [https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/02-scroll-blocker](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/02-scroll-blocker).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/02-scroll-blocker](https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter01/02-scroll-blocker)查看答案。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we went through the lifecycles of a Svelte component. We saw
    the different stages of a component lifecycle and learned when the lifecycle function
    callbacks will be called.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了Svelte组件的生命周期。我们看到了组件生命周期的不同阶段，并学习了生命周期函数回调将在何时被调用。
- en: We also covered the rule of calling lifecycle functions. This helps us to realize
    the different patterns of reusing and composing lifecycle functions.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了调用生命周期函数的规则。这有助于我们实现生命周期函数的重用和组合的不同模式。
- en: In the next chapter, we will start to look at the different patterns for styling
    and theming a Svelte component.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始探讨为Svelte组件进行样式化和主题化的不同模式。
