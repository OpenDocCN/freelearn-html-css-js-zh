- en: Chapter 7. Adding Physics to Your Games Using the Box2D Engine
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章。使用Box2D引擎为您的游戏添加物理
- en: If you ask me what the biggest revolution in casual gaming is, no doubt I'll
    say physics engines. A lot of top-selling casual games such as Crayon Physics,
    Totem Destroyer, Crush the Castle, Angry Birds, Tiny Wings, just to mention a
    few use physics engines to add a realistic behavior that wouldn't be possible
    without such engines.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你问我休闲游戏最大的革命是什么，毫无疑问我会说是物理引擎。许多畅销的休闲游戏，如蜡笔物理、图腾破坏者、城堡粉碎、愤怒的小鸟、小翅膀，仅举几个例子，都使用了物理引擎来添加一种没有这些引擎就无法实现的现实行为。
- en: The most popular among physics engines in the 2D world is Box2D, initially written
    in C++, then ported to all major languages, including JavaScript.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在2D物理引擎中，Box2D是最受欢迎的，最初是用C++编写的，后来移植到了包括JavaScript在内的所有主要语言。
- en: 'Cocos2d-JS supports Box2D, and this chapter will cover the creation of a physics
    game, including these concepts:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-JS支持Box2D，本章将涵盖创建物理游戏，包括以下概念：
- en: Configuring and setting up Cocos2d-JS to add the Box2D engine to your games
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置和设置Cocos2d-JS以将Box2D引擎添加到您的游戏中
- en: Creating a physics world
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建物理世界
- en: Giving the world a realistic gravity
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为世界添加真实的重力
- en: Combining bodies, shapes, and fixtures to create a physics object
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过组合刚体、形状和固定装置来创建物理对象
- en: Creating a material
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建材料
- en: Creating static objects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建静态对象
- en: Creating dynamic objects
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建动态对象
- en: Attaching sprites to physics objects
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将精灵附加到物理对象上
- en: Selecting physics objects with the mouse/finger
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用鼠标/手指选择物理对象
- en: Destroying physics objects
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 销毁物理对象
- en: Checking for collisions among objects
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查物体之间的碰撞
- en: Running the physics simulation
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运行物理模拟
- en: That's a lot of stuff, isn't it?
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多东西，不是吗？
- en: By the end of the chapter, you will have a playable level of a famous physics
    game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 到了本章的结尾，您将拥有一个著名物理游戏的可玩关卡。
- en: Before you start
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在开始之前
- en: Learning Box2D in just a few pages is not possible. A whole book is what you
    will need to start mastering it.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 仅用几页来学习Box2D是不可能的。您需要一整本书来开始掌握它。
- en: Tip
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For an in-depth understanding of Box2D, you can find my book, *Box2D for Flash
    Games*, at [https://www.packtpub.com/game-development/box2d-flash-games](https://www.packtpub.com/game-development/box2d-flash-games).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 要深入了解Box2D，您可以在[https://www.packtpub.com/game-development/box2d-flash-games](https://www.packtpub.com/game-development/box2d-flash-games)找到我的书，《Box2D
    for Flash Games》。
- en: 'Anyway, this chapter will give you the bare bones to add physics to your games.
    Although experienced Box2D users may find some concepts such as collision detection
    covered in a less-than-perfect way, in the end, it works and that''s what really
    matters in the scope of this chapter: giving you the knowledge to start learning
    Box2D and include it into your Cocos2d-JS projects.'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这一章将为您提供添加物理到游戏的骨架。尽管经验丰富的Box2D用户可能会发现碰撞检测等一些概念介绍得不够完美，但最终它还是可行的，这正是本章的真正目的：为您提供开始学习Box2D并将其包含到Cocos2d-JS项目中的知识。
- en: Adding the Box2D engine to your project
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将Box2D引擎添加到您的项目中
- en: The best game to write for you to learn most Box2D concepts is Totem Destroyer.
    It can be found at [http://armorgames.com/play/1871/totem-destroyer](http://armorgames.com/play/1871/totem-destroyer).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的游戏是Totem Destroyer，您可以在这里找到它：[http://armorgames.com/play/1871/totem-destroyer](http://armorgames.com/play/1871/totem-destroyer)。
- en: 'You have to smash bricks by clicking/tapping on them while being careful not
    to let the totem fall to the ground, or it''s game over. Not all bricks can be
    destroyed. In the level shown in the following screenshot, dark bricks can''t
    be destroyed:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 您必须通过点击/轻触砖块来摧毁它们，同时注意不要让图腾掉到地上，否则游戏结束。并非所有砖块都可以被摧毁。在下面的屏幕截图所示的关卡中，深色砖块无法被摧毁：
- en: '![Adding the Box2D engine to your project](img/0075SOS_07_01.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![将Box2D引擎添加到您的项目中](img/0075SOS_07_01.jpg)'
- en: Although the game has quite a simple gameplay, it features some advanced physics
    concepts, such as collision detection and how to select a physics body.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管游戏玩法相当简单，但它包含了一些高级物理概念，例如碰撞检测和如何选择物理体。
- en: 'We will build this level; so, as usual, the first thing we need to do is take
    care of the content of the assets folder:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建这个关卡；因此，像往常一样，我们首先需要处理的是资源文件夹的内容：
- en: '![Adding the Box2D engine to your project](img/0075SOS_07_02.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![将Box2D引擎添加到您的项目中](img/0075SOS_07_02.jpg)'
- en: 'And this is the content of `loadassets.js`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是`loadassets.js`的内容：
- en: '[PRE0]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: To keep loading times as fast as possible, the basic Cocos2d-JS source we used
    in the previous chapters did not feature any physics engine.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 为了尽可能快地加载，我们在前几章中使用的基本Cocos2d-JS源代码没有包含任何物理引擎。
- en: 'In order to have Cocos2d-JS work with Box2D, we have to load another module
    called `external`, which we will define in the `project.json` file:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 为了让Cocos2d-JS与Box2D一起工作，我们必须加载另一个名为`external`的模块，我们将在`project.json`文件中定义它。
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now, the engine knows we will use Box2D; so, we can focus on the game itself.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，引擎知道我们将使用Box2D；因此，我们可以专注于游戏本身。
- en: Configuring the physics world
  id: totrans-36
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置物理世界
- en: From now on, all the script will be written in `gamescript.js` as usual, so
    be prepared to write your first Cocos2d-JS Box2D script.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，所有的脚本都将按照惯例写在`gamescript.js`中，所以请准备好编写你的第一个Cocos2d-JS Box2D脚本。
- en: 'Some of the magic happens from the first two lines, which declare global variables:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 一些魔法从前两行开始，它们声明了全局变量：
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Here, the `world` variable will represent the physics world we are setting the
    game in, and will include its own gravity and other properties that we will discover.
    However, first I want to say a couple of words about `worldScale`.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`world`变量将代表我们在其中设置游戏的物理世界，它将包括我们将会发现的自己的重力和其他属性。然而，首先我想说几句关于`worldScale`的话。
- en: Box2D is a realistic physics engine that uses real-world units of measurement.
    This way, everything you will create in Box2D world will be measured in meters.
    If you create a box whose side length is 2, you mean it's two meters.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D是一个使用现实世界测量单位的真实物理引擎。这样，你将在Box2D世界中创建的一切都将用米来衡量。如果你创建一个边长为2米的盒子，这意味着它是两米。
- en: On the other hand, browsers have their own unit of measurement, which is pixels.
    You can have a game 480 pixels wide, but you'll never find a game two meters wide.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，浏览器有自己的单位，即像素。你可以有一个480像素宽的游戏，但你永远不会找到一个两米宽的游戏。
- en: So, we need to find a ratio between pixels and meters. In almost every project,
    the *1 meter = 30 pixels* setting works fine and allows us to think and work in
    pixels without caring about the Box2D internal unit of measurement.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要找到像素和米之间的比率。在几乎每一个项目中，*1米=30像素*的设置都很好，并允许我们在像素中思考和操作，而不必关心Box2D的内部单位。
- en: 'The `gameScene` class declaration does not change:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameScene`类的声明没有改变：'
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The interesting part as usual can be found in the `game` declaration:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 如往常一样，有趣的部分可以在`game`声明中找到：
- en: '[PRE4]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Once you run the project, in your console, you should see a several instances
    of **b2World**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦运行项目，在你的控制台中，你应该会看到几个**b2World**的实例。
- en: This means our Box2D physics world is running; let's see what happened.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们的Box2D物理世界正在运行；让我们看看发生了什么。
- en: 'First, we added a gradient background layer:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了一个渐变背景层：
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, we already know that a physics world has gravity. Here is how we define
    the gravity:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们已经知道物理世界有重力。以下是定义重力的方法：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: All in all, the gravity in the real world can be represented by a vector, and
    Earth gravity can be represented by a vector (0,9.81), where 9.81 is expressed
    in meters per second squared, which is the average acceleration of a falling body
    near the surface of the Earth.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 总而言之，现实世界中的重力可以用一个向量来表示，地球的重力可以用一个向量(0,9.81)来表示，其中9.81用米每秒平方表示，这是在地球表面附近坠落物体的平均加速度。
- en: In Box2D, the `b2Vec2` type is used to store vectors; while it's clear that
    we can approximate 9.81 to 10, it's quite unclear why the gravity vector has its
    *y* value to -10\. A negative gravity?
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在Box2D中，`b2Vec2`类型用于存储向量；虽然我们可以将9.81近似为10，但重力向量的*y*值为什么是-10，这相当不清楚。负重力？
- en: 'Let me explain: you already know Cocos2d-JS has its origin coordinate in the
    bottom left of the stage; so, as long as you move from bottom to top, your y coordinate
    increases. On the other hand, Box2D works in the opposite way: as long as a physics
    body falls down; its *y* coordinate increases, and setting the gravity at (0,10)
    would make Cocos2d-JS sprites fly away rather than fall down.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 让我来解释一下：你已经知道Cocos2d-JS的坐标原点位于舞台的左下角；因此，只要你从底部向上移动，你的y坐标就会增加。另一方面，Box2D以相反的方式工作：只要一个物理体向下坠落，它的*y*坐标就会增加，将重力设置为(0,10)会使Cocos2d-JS精灵飞走而不是坠落。
- en: That's why we need to reverse the gravity. In Box2D, internal world bodies will
    fly away, but what we'll see on the stage are the same objects falling down.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是为什么我们需要反转重力。在Box2D中，内部世界体将飞走，但我们将在舞台上看到相同的物体坠落。
- en: 'Now, we are finally able to create the world:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们终于可以创建世界了：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As you can see, the world has two arguments: the `gravity` variable we created
    before, and a Boolean flag to determine whether bodies can sleep. Normally, to
    save CPU time, physics bodies that don''t receive hits and aren''t affected by
    forces for some amount of time are put to sleep. This means they still exist in
    the Box2D world although their position isn''t updated at each frame until they
    wake up because of some event such as a collision or a force applied to them.'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，世界有两个参数：我们之前创建的`gravity`变量和一个布尔标志，用于确定身体是否可以休眠。通常，为了节省CPU时间，一段时间内没有受到打击且不受力的影响的物理身体会被休眠。这意味着它们仍然存在于Box2D世界中，尽管它们的每个帧的位置不会更新，直到由于某些事件（如碰撞或施加到它们上的力）而醒来。
- en: 'The remaining line should already be clear for you. We are enabling the game
    to schedule the update function to be executed at each frame:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的行应该对你来说已经很清晰了。我们正在使游戏能够安排更新函数在每个帧执行：
- en: '[PRE8]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'When we call `scheduleUpdate`, we also need an `update` function, which in
    this case only contains:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们调用`scheduleUpdate`时，我们还需要一个`update`函数，在这种情况下，它只包含：
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The `Step` method advances the simulation for a certain amount of time, `dt`
    in this case and to be as accurate as possible, while the other two arguments
    represent the velocity and position iterations, respectively.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Step`方法将模拟推进一定的时间，`dt`在这种情况下，为了尽可能准确，而其他两个参数分别代表速度和位置迭代。'
- en: These two arguments are needed because most Box2D code is used for an operation
    called constraint solver, an algorithm that solves all the constraints in the
    simulation, one at a time. While one single constraint can be easily solved, when
    more constraints come into play, solving one of them means slightly disrupting
    the others. That's why we need more iterations in order to have an accurate simulation.
    The official Box2D documentation suggests you set eight for velocity and three
    for position, although I usually set both to 10 and do not have any problem in
    making simple games.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个参数是必需的，因为大多数Box2D代码都是用于一个称为约束求解器的操作，这是一个一次解决模拟中所有约束的算法。虽然单个约束可以很容易地解决，但当更多的约束介入时，解决其中一个意味着稍微干扰其他约束。这就是为什么我们需要更多的迭代才能有一个准确的模拟。官方Box2D文档建议将速度设置为8，位置设置为3，尽管我通常将两者都设置为10，并且在制作简单游戏时没有遇到任何问题。
- en: Now, it's time to build the totem.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候构建图腾了。
- en: Adding bodies to the world
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向世界添加身体
- en: A physics object in the Box2D world is called a body. So, we will see how to
    add a body to the world. Moreover, since all bodies in our Totem Destroyer game
    are boxes, we will define a function to create a body and customize it to fit
    our needs.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在Box2D世界中，一个物理对象被称为身体。因此，我们将看到如何向世界添加一个身体。此外，由于我们“图腾破坏者”游戏中的所有身体都是盒子，我们将定义一个函数来创建一个身体，并对其进行定制以适应我们的需求。
- en: We'll start from the end, calling a function we haven't written yet, just to
    have a look at all arguments that we need to create any kind of body used in Totem
    Destroyer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从结尾开始，调用一个我们尚未编写的函数，只是为了看看我们需要创建任何用于“图腾破坏者”的身体的全部参数。
- en: 'So, the game''s `init` function will be modified this way:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，游戏的`init`函数将被修改成这样：
- en: '[PRE10]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Our custom function is called `addBody` and according to the number of arguments
    will do a lot of things. Let''s have a look at the following arguements:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的定制函数被称为`addBody`，根据参数的数量将执行很多事情。让我们看看以下参数：
- en: '`240`: This is the horizontal centre of the body, in pixels.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`240`：这是身体水平中心，以像素为单位。'
- en: '`10`: This is the vertical centre of the body, in pixels.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`10`：这是身体垂直中心，以像素为单位。'
- en: '`480`: This is the body width, in pixels.'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`480`：这是身体的宽度，以像素为单位。'
- en: '`20`: This is the body height, in pixels.'
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`20`：这是身体的高度，以像素为单位。'
- en: '`false`: This Boolean value determines whether the body is dynamic or not.
    We are building two kinds of bodies, dynamic bodies, which are affected by forces
    such as gravity and react to collisions, and static bodies, which can''t be moved.
    This will be a static body.'
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`false`：这个布尔值决定了身体是动态的还是静态的。我们正在构建两种类型的身体，动态身体，它们会受到重力等力的作用并响应碰撞，以及静态身体，它们不能被移动。这将是一个静态身体。'
- en: '`"assets/ground.png"`: These are the graphic assets to be bound to the body.'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"assets/ground.png"`：这些是要绑定到身体上的图形资源。'
- en: '`"ground"`: This is the body type. We call it `ground` because it will represent
    the ground.'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`"ground"`：这是身体类型。我们称之为`ground`，因为它将代表地面。'
- en: So, in other words, we are creating a static body in the bottom of the stage,
    which will represent the ground.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，我们在舞台底部创建了一个静态身体，它将代表地面。
- en: 'Now, it is time to see how to create and configure a body with Cocos2d-JS and
    Box2D. Add the `addBody` function to the `game` class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候看看如何使用Cocos2d-JS和Box2D创建和配置一个身体了。将`addBody`函数添加到`game`类中：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'There''s a lot of new stuff here, so we will see it line by line. First, we
    have to create a fixture:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多新内容，所以我们将逐行查看。首先，我们必须创建一个固定件：
- en: '[PRE12]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Think about a fixture as a relationship between a body, which is the physics
    actor, and its shape, which determines how the body looks—like a box, like a circle,
    and so on.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将固定件视为一个关系，它是一个物理演员（body）与其形状之间的关系，该形状决定了物体的外观——如盒子、圆形等。
- en: 'The fixture also determines the material of the body, thanks to these three
    attributes:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 固定件还通过这三个属性决定了身体的材料：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The `density` attribute affects the mass of the body, `friction` determines
    how bodies slide along each other, and `restitution` is used to see how a body
    bounces.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`density`属性影响身体的重量，`friction`决定了身体如何相互滑动，而`restitution`用于查看身体如何弹跳。'
- en: 'Now, it''s time to create the shape attached to the fixture:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候创建与固定件相连的形状了：
- en: '[PRE14]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `SetAsBox` method creates a box given a width and a height that Box2D accepts
    as half of the actual width and height. So, if you want a box with a width of
    30 meters, you'll have to set its width to *30*0.5*. As said, we are talking about
    pixels so we also have to divide the given width by `worldScale`.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetAsBox`方法根据Box2D接受的宽度的一半和高度创建一个盒子。所以，如果你想有一个30米宽的盒子，你必须将其宽度设置为*30*0.5。如前所述，我们谈论的是像素，所以我们还必须将给定的宽度除以`worldScale`。'
- en: 'Once we have the shape and the fixture, it''s time to care about the physical
    body:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了形状和固定件，就是时候关注物理身体了：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, we can say whether the body is static or dynamic. In our game, only the
    floor will be a static body. The code for this is as follows:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以确定身体是静态的还是动态的。在我们的游戏中，只有地板将是一个静态身体。相应的代码如下：
- en: '[PRE16]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `type` attribute will determine whether the body will be static or dynamic.
    Now, we have a shape, a body, and a fixture; why don''t we place this body somewhere
    in the world? See the following code snippet:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`type`属性将决定身体是静态的还是动态的。现在，我们有了形状、身体和固定件；为什么我们不把这个身体放在世界的某个地方呢？请看下面的代码片段：'
- en: '[PRE17]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This can be done with the `position` property. Don't forget the pixels-to-meters
    conversion.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过`position`属性来完成。别忘了像素到米的转换。
- en: Now for the hardest part of Box2D. Most of the people trying to learn Box2D
    fail when it's time to attach a graphic asset to a body. The main reason is, Box2D
    does not allow you to attach sprites to a body. Print it with a 72-pixel font.
    You have to manually place sprites on the stage and manually move them as the
    world updates.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是Box2D最困难的部分。大多数试图学习Box2D的人在需要将图形资产附加到身体上时都会失败。主要原因在于，Box2D不允许你将精灵附加到身体上。用72像素的字体打印出来。你必须手动将精灵放置在舞台上，并随着世界的更新手动移动它们。
- en: 'Let''s add the sprite:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加这个精灵：
- en: '[PRE18]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This was easy because we only add a sprite in the same way we have since the
    start of the first chapter. Anyway, we have to somehow tell Box2D that this sprite
    belongs to the body we just created.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，因为我们只是以与第一章开始以来相同的方式添加了一个精灵。无论如何，我们必须以某种方式告诉Box2D这个精灵属于我们刚刚创建的身体。
- en: 'Too good! There''s a `userData` property that we can use to store any kind
    of custom body information:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！有一个`userData`属性，我们可以用它来存储任何类型的自定义身体信息：
- en: '[PRE19]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, I defined an object with the sprites to be linked with and the
    type of body we are dealing with—in this case, it will be `ground`, according
    to the argument passed to the `addBody` function.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我定义了一个对象，其中包含要链接的精灵和我们要处理的身体类型——在这种情况下，它将是`ground`，根据传递给`addBody`函数的参数。
- en: 'Finally, we are ready to attach the body to the world, that is, turning our
    body definition—`b2BodyDef` is a body definition—into a physical body:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们准备将身体附加到世界中，也就是说，将我们的身体定义——`b2BodyDef`是一个身体定义——转换成物理身体：
- en: '[PRE20]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `CreateBody` method will create a real physics body starting from a body
    definition, while `CreateFixture` will attach a fixture—and its shape—to a body.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateBody`方法将从身体定义创建一个真实的物理身体，而`CreateFixture`方法将固定件及其形状附加到身体上。'
- en: 'Finally, we can run the game and the following image is what you should see:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以运行游戏，以下是你应该看到的图像：
- en: '![Adding bodies to the world](img/0075SOS_07_04.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![向世界中添加物体](img/0075SOS_07_04.jpg)'
- en: Finally, we will have a solid ground, and moreover, a function that will allow
    us to create the entire totem quickly.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将有一个坚固的地板，而且还有一个函数将允许我们快速创建整个图腾。
- en: 'Let''s add these lines:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加这些行：
- en: '[PRE21]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: We just have to correctly call the `addBody` function to have our totem built
    with each brick defined with its own graphic assets, position, size, and property.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只需正确调用`addBody`函数，就可以用每个砖块定义的自己的图形资产、位置、大小和属性来构建我们的图腾。
- en: 'Launch the game now:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 现在启动游戏：
- en: '![Adding bodies to the world](img/0075SOS_07_05.jpg)'
  id: totrans-117
  prefs: []
  type: TYPE_IMG
  zh: '![向世界添加物体](img/0075SOS_07_05.jpg)'
- en: That's it! Our totem is standing on the floor, ready to be destroyed.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 那就对了！我们的图腾现在站在地板上，准备被摧毁。
- en: Updating sprite position as the world changes
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 随着世界变化更新精灵位置
- en: Unfortunately, our totem is still just a bunch of static sprites. Yes, we attached
    them to a body, but what happens when the world changes?
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，我们的图腾仍然只是一堆静态的精灵。是的，我们将其附加到了一个物体上，但世界发生变化时会发生什么呢？
- en: 'Try to remove the left foot of the totem, this way:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试移除图腾的左脚，方法如下：
- en: '[PRE22]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'I just commented a line; let''s see what happens:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我只是注释了一行；让我们看看会发生什么：
- en: '![Updating sprite position as the world changes](img/0075SOS_07_06.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![随着世界变化更新精灵位置](img/0075SOS_07_06.jpg)'
- en: It definitively looks wrong. The totem should fall!
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 这显然是错误的。图腾应该掉下来！
- en: This happens because we properly placed the sprites when we created the bodies
    but since then, the sprites' position has not been updated.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为我们在创建物体时正确地放置了精灵，但自那时起，精灵的位置尚未更新。
- en: The result is the sprites remain in the same position no matter what happens
    to the bodies. Remember? *Box2D does not allow attaching sprites to a body*. Lesson
    learned.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，无论物体发生什么变化，精灵都保持在相同的位置。还记得吗？*Box2D不允许将精灵附加到物体上*。教训学到了。
- en: 'We have to move sprites manually, in the `update` function:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须在`update`函数中手动移动精灵：
- en: '[PRE23]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Run the game now:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行游戏：
- en: '![Updating sprite position as the world changes](img/0075SOS_07_07.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![随着世界变化更新精灵位置](img/0075SOS_07_07.jpg)'
- en: 'Finally, the totem falls! Let''s have a look at what happened:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，图腾掉下来了！让我们看看发生了什么：
- en: '[PRE24]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This cycle loops through all bodies placed in the world.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个循环遍历世界中放置的所有物体。
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '`b` is now our current body, and we will see whether we set something into
    its user data:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`b`现在是我们的当前物体，我们将查看是否将其用户数据中设置了某些内容：'
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Once we know there's something in the user data, as in this case, we know it's
    one of the bodies we created to build the totem or the ground. Do you remember
    we created an object in the user data? The `mySprite` variable will store the
    sprite we inserted in this object.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道用户数据中有什么东西，就像这个例子一样，我们知道它是我们创建来构建图腾或地面的物体之一。你还记得我们在用户数据中创建了一个对象吗？`mySprite`变量将存储我们插入此对象中的精灵。
- en: The `GetPosition` method returns body's position; so, we can update the sprite
    position—remember the conversion from meters to pixels—and `getAngle` returns
    body rotation.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetPosition`方法返回物体的位置；因此，我们可以更新精灵的位置——记住从米到像素的转换——而`getAngle`返回物体的旋转。'
- en: This way we can manually update all sprites attached to Box2D world bodies.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这样我们就可以手动更新所有附加到Box2D世界物体的精灵。
- en: Selecting and destroying world bodies
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择和摧毁世界物体
- en: As the name Totem Destroyer suggests, you should be able to destroy the totem.
    First, uncomment the previously commented line in order to give back the totem
    its left foot, and then we are ready to destroy bricks when the player touches/clicks
    them.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 正如名字“图腾破坏者”所暗示的，你应该能够摧毁图腾。首先，取消注释之前注释的行，以便恢复图腾的左脚，然后当玩家触摸/点击它们时，我们就可以准备摧毁砖块了。
- en: 'Everything starts with a touch, so we have to manage it by first adding the
    listener to the game''s `init` function:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 一切从触摸开始，所以我们必须通过首先将监听器添加到游戏的`init`函数来管理它：
- en: '[PRE27]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then create the `listener` variable itself:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后创建`listener`变量本身：
- en: '[PRE28]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s see what we added. First, we have to get click/touch coordinates and
    translate them into Box2D world coordinates; this means turning pixels into meters
    and placing coordinates into a `b2Vec2` variable:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们添加了什么。首先，我们必须获取点击/触摸坐标并将它们转换为Box2D世界坐标；这意味着将像素转换为米，并将坐标放入一个`b2Vec2`变量中：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we will loop through all bodies in the same way we do when it''s time
    to update the sprite''s'' position:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将以更新精灵位置时相同的方式遍历所有物体：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Not all bodies can be destroyed: the ground and dark bricks can''t be destroyed
    for instance, so we have to be sure we are only trying to destroy bricks we marked
    with `destroyable` in their user data:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有物体都可以被摧毁：例如，地面和深色砖块不能被摧毁，所以我们必须确保我们只尝试摧毁我们用`destroyable`标记的用户数据中的砖块：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Once we know a brick can be destroyed, we have to loop through all its fixtures
    and see whether one of them contains the point the player clicked/touched. This
    is how we will loop through all fixtures of a body:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们知道一块砖可以被摧毁，我们就必须遍历它的所有固定件，看看其中是否有任何一个包含玩家点击/触摸的点。这就是我们将如何遍历一个物体的所有固定件：
- en: '[PRE32]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'And once `f` represents the current texture, the `TestPoint` method will return
    `true` if the point passed as an argument is inside the fixture:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦 `f` 代表当前纹理，`TestPoint` 方法将返回 `true` 如果传递给它的点位于固定件内部：
- en: '[PRE33]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'At this time, we are sure the player touched the `b` body and we can destroy
    it, after having removed the sprite. Remember: *Box2D does not allow you to attach
    a sprite to a body*. The code snippet for this is shown as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个时候，我们确信玩家触摸了 `b` 主体，我们可以在移除精灵后摧毁它。记住：*Box2D 不允许你将精灵附加到主体上*。这个代码片段如下所示：
- en: '[PRE34]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `DestroyBody` method removes a body from the world.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '`DestroyBody` 方法从世界中移除一个主体。'
- en: Run the game and touch some bodies, then you will be able to destroy the light
    ones.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并触摸一些主体，然后你将能够摧毁那些轻的主体。
- en: '![Selecting and destroying world bodies](img/0075SOS_07_08.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![选择和摧毁世界主体](img/0075SOS_07_08.jpg)'
- en: Now the game is ready to be played we only have to check when the idol touches
    the ground. This is a game-over event, so it's very important.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在游戏已经准备好被玩，我们只需要检查偶像是否触摸到地面。这是一个游戏结束事件，所以它非常重要。
- en: Checking for collisions among bodies
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查主体之间的碰撞
- en: To complete the prototype, we need to check whether the idol touches the ground.
    The simplest way, according to what you have learned about Box2D until now, is
    to continuously scan through idol collisions and check whether one of the bodies
    it collides with is the ground.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成原型，我们需要检查偶像是否触摸到地面。根据你到目前为止对 Box2D 的了解，最简单的方法是持续扫描偶像的碰撞，并检查它碰撞到的主体中是否有地面。
- en: 'We need to add some lines to the `update` function:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在 `update` 函数中添加一些行：
- en: '[PRE35]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the way that we looped through bodies and fixtures, we can loop through
    contacts using the following line of code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们遍历主体和固定件的方式中，我们可以使用以下代码行遍历接触：
- en: '[PRE36]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: For every `c` contact, we check the body it got in contact with thanks to the
    `other` property; if its type is `ground`, we output a message in the console.
    The whole process is made only if the current body is the idol.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个 `c` 接触，我们通过 `other` 属性检查与之接触的主体；如果它的类型是 `ground`，我们在控制台输出一条消息。整个过程只有在当前主体是偶像时才会进行。
- en: Run the game and let the idol touch the ground. You will see several instances
    of **Oh no!!!!** on your console log. And finally, we have a working Totem Destroyer
    prototype!!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏并让偶像触摸地面。你将在控制台日志中看到几个 **Oh no!!!!** 的实例。最终，我们有一个工作的图腾摧毁者原型！！
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Building a Totem Destroyer level was a great achievement because now you are
    able to build a cross-platform game like one of the most played browser games;
    and all thanks to Box2D.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 构建一个图腾摧毁者关卡是一个巨大的成就，因为现在你能够构建一个像最受欢迎的浏览器游戏之一那样的跨平台游戏；所有这些都归功于 Box2D。
- en: Why don't you improve it by setting a level goal—such as *remove four blocks*—and,
    when this is achieved, waiting a couple of seconds to see if the idol stays in
    its position without falling to the ground as in the original game?
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 你为什么不通过设定一个目标——比如 *移除四个方块*——来改进它呢？当这个目标达成后，等待几秒钟看看偶像是否保持在原位而没有掉到地上，就像在原始游戏中那样？
