- en: Chapter 7. Adding Physics to Your Games Using the Box2D Engine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you ask me what the biggest revolution in casual gaming is, no doubt I'll
    say physics engines. A lot of top-selling casual games such as Crayon Physics,
    Totem Destroyer, Crush the Castle, Angry Birds, Tiny Wings, just to mention a
    few use physics engines to add a realistic behavior that wouldn't be possible
    without such engines.
  prefs: []
  type: TYPE_NORMAL
- en: The most popular among physics engines in the 2D world is Box2D, initially written
    in C++, then ported to all major languages, including JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cocos2d-JS supports Box2D, and this chapter will cover the creation of a physics
    game, including these concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: Configuring and setting up Cocos2d-JS to add the Box2D engine to your games
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a physics world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Giving the world a realistic gravity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combining bodies, shapes, and fixtures to create a physics object
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a material
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating static objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating dynamic objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Attaching sprites to physics objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting physics objects with the mouse/finger
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Destroying physics objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for collisions among objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running the physics simulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a lot of stuff, isn't it?
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will have a playable level of a famous physics
    game.
  prefs: []
  type: TYPE_NORMAL
- en: Before you start
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Learning Box2D in just a few pages is not possible. A whole book is what you
    will need to start mastering it.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For an in-depth understanding of Box2D, you can find my book, *Box2D for Flash
    Games*, at [https://www.packtpub.com/game-development/box2d-flash-games](https://www.packtpub.com/game-development/box2d-flash-games).
  prefs: []
  type: TYPE_NORMAL
- en: 'Anyway, this chapter will give you the bare bones to add physics to your games.
    Although experienced Box2D users may find some concepts such as collision detection
    covered in a less-than-perfect way, in the end, it works and that''s what really
    matters in the scope of this chapter: giving you the knowledge to start learning
    Box2D and include it into your Cocos2d-JS projects.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the Box2D engine to your project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best game to write for you to learn most Box2D concepts is Totem Destroyer.
    It can be found at [http://armorgames.com/play/1871/totem-destroyer](http://armorgames.com/play/1871/totem-destroyer).
  prefs: []
  type: TYPE_NORMAL
- en: 'You have to smash bricks by clicking/tapping on them while being careful not
    to let the totem fall to the ground, or it''s game over. Not all bricks can be
    destroyed. In the level shown in the following screenshot, dark bricks can''t
    be destroyed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Box2D engine to your project](img/0075SOS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Although the game has quite a simple gameplay, it features some advanced physics
    concepts, such as collision detection and how to select a physics body.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will build this level; so, as usual, the first thing we need to do is take
    care of the content of the assets folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the Box2D engine to your project](img/0075SOS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'And this is the content of `loadassets.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: To keep loading times as fast as possible, the basic Cocos2d-JS source we used
    in the previous chapters did not feature any physics engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to have Cocos2d-JS work with Box2D, we have to load another module
    called `external`, which we will define in the `project.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now, the engine knows we will use Box2D; so, we can focus on the game itself.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the physics world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: From now on, all the script will be written in `gamescript.js` as usual, so
    be prepared to write your first Cocos2d-JS Box2D script.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some of the magic happens from the first two lines, which declare global variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `world` variable will represent the physics world we are setting the
    game in, and will include its own gravity and other properties that we will discover.
    However, first I want to say a couple of words about `worldScale`.
  prefs: []
  type: TYPE_NORMAL
- en: Box2D is a realistic physics engine that uses real-world units of measurement.
    This way, everything you will create in Box2D world will be measured in meters.
    If you create a box whose side length is 2, you mean it's two meters.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, browsers have their own unit of measurement, which is pixels.
    You can have a game 480 pixels wide, but you'll never find a game two meters wide.
  prefs: []
  type: TYPE_NORMAL
- en: So, we need to find a ratio between pixels and meters. In almost every project,
    the *1 meter = 30 pixels* setting works fine and allows us to think and work in
    pixels without caring about the Box2D internal unit of measurement.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gameScene` class declaration does not change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The interesting part as usual can be found in the `game` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Once you run the project, in your console, you should see a several instances
    of **b2World**.
  prefs: []
  type: TYPE_NORMAL
- en: This means our Box2D physics world is running; let's see what happened.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we added a gradient background layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we already know that a physics world has gravity. Here is how we define
    the gravity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: All in all, the gravity in the real world can be represented by a vector, and
    Earth gravity can be represented by a vector (0,9.81), where 9.81 is expressed
    in meters per second squared, which is the average acceleration of a falling body
    near the surface of the Earth.
  prefs: []
  type: TYPE_NORMAL
- en: In Box2D, the `b2Vec2` type is used to store vectors; while it's clear that
    we can approximate 9.81 to 10, it's quite unclear why the gravity vector has its
    *y* value to -10\. A negative gravity?
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me explain: you already know Cocos2d-JS has its origin coordinate in the
    bottom left of the stage; so, as long as you move from bottom to top, your y coordinate
    increases. On the other hand, Box2D works in the opposite way: as long as a physics
    body falls down; its *y* coordinate increases, and setting the gravity at (0,10)
    would make Cocos2d-JS sprites fly away rather than fall down.'
  prefs: []
  type: TYPE_NORMAL
- en: That's why we need to reverse the gravity. In Box2D, internal world bodies will
    fly away, but what we'll see on the stage are the same objects falling down.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are finally able to create the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the world has two arguments: the `gravity` variable we created
    before, and a Boolean flag to determine whether bodies can sleep. Normally, to
    save CPU time, physics bodies that don''t receive hits and aren''t affected by
    forces for some amount of time are put to sleep. This means they still exist in
    the Box2D world although their position isn''t updated at each frame until they
    wake up because of some event such as a collision or a force applied to them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The remaining line should already be clear for you. We are enabling the game
    to schedule the update function to be executed at each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'When we call `scheduleUpdate`, we also need an `update` function, which in
    this case only contains:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `Step` method advances the simulation for a certain amount of time, `dt`
    in this case and to be as accurate as possible, while the other two arguments
    represent the velocity and position iterations, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: These two arguments are needed because most Box2D code is used for an operation
    called constraint solver, an algorithm that solves all the constraints in the
    simulation, one at a time. While one single constraint can be easily solved, when
    more constraints come into play, solving one of them means slightly disrupting
    the others. That's why we need more iterations in order to have an accurate simulation.
    The official Box2D documentation suggests you set eight for velocity and three
    for position, although I usually set both to 10 and do not have any problem in
    making simple games.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it's time to build the totem.
  prefs: []
  type: TYPE_NORMAL
- en: Adding bodies to the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A physics object in the Box2D world is called a body. So, we will see how to
    add a body to the world. Moreover, since all bodies in our Totem Destroyer game
    are boxes, we will define a function to create a body and customize it to fit
    our needs.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start from the end, calling a function we haven't written yet, just to
    have a look at all arguments that we need to create any kind of body used in Totem
    Destroyer.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, the game''s `init` function will be modified this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Our custom function is called `addBody` and according to the number of arguments
    will do a lot of things. Let''s have a look at the following arguements:'
  prefs: []
  type: TYPE_NORMAL
- en: '`240`: This is the horizontal centre of the body, in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`10`: This is the vertical centre of the body, in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`480`: This is the body width, in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`20`: This is the body height, in pixels.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`false`: This Boolean value determines whether the body is dynamic or not.
    We are building two kinds of bodies, dynamic bodies, which are affected by forces
    such as gravity and react to collisions, and static bodies, which can''t be moved.
    This will be a static body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"assets/ground.png"`: These are the graphic assets to be bound to the body.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`"ground"`: This is the body type. We call it `ground` because it will represent
    the ground.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in other words, we are creating a static body in the bottom of the stage,
    which will represent the ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it is time to see how to create and configure a body with Cocos2d-JS and
    Box2D. Add the `addBody` function to the `game` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s a lot of new stuff here, so we will see it line by line. First, we
    have to create a fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Think about a fixture as a relationship between a body, which is the physics
    actor, and its shape, which determines how the body looks—like a box, like a circle,
    and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The fixture also determines the material of the body, thanks to these three
    attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `density` attribute affects the mass of the body, `friction` determines
    how bodies slide along each other, and `restitution` is used to see how a body
    bounces.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, it''s time to create the shape attached to the fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The `SetAsBox` method creates a box given a width and a height that Box2D accepts
    as half of the actual width and height. So, if you want a box with a width of
    30 meters, you'll have to set its width to *30*0.5*. As said, we are talking about
    pixels so we also have to divide the given width by `worldScale`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have the shape and the fixture, it''s time to care about the physical
    body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can say whether the body is static or dynamic. In our game, only the
    floor will be a static body. The code for this is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `type` attribute will determine whether the body will be static or dynamic.
    Now, we have a shape, a body, and a fixture; why don''t we place this body somewhere
    in the world? See the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This can be done with the `position` property. Don't forget the pixels-to-meters
    conversion.
  prefs: []
  type: TYPE_NORMAL
- en: Now for the hardest part of Box2D. Most of the people trying to learn Box2D
    fail when it's time to attach a graphic asset to a body. The main reason is, Box2D
    does not allow you to attach sprites to a body. Print it with a 72-pixel font.
    You have to manually place sprites on the stage and manually move them as the
    world updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add the sprite:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This was easy because we only add a sprite in the same way we have since the
    start of the first chapter. Anyway, we have to somehow tell Box2D that this sprite
    belongs to the body we just created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Too good! There''s a `userData` property that we can use to store any kind
    of custom body information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In this case, I defined an object with the sprites to be linked with and the
    type of body we are dealing with—in this case, it will be `ground`, according
    to the argument passed to the `addBody` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we are ready to attach the body to the world, that is, turning our
    body definition—`b2BodyDef` is a body definition—into a physical body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `CreateBody` method will create a real physics body starting from a body
    definition, while `CreateFixture` will attach a fixture—and its shape—to a body.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can run the game and the following image is what you should see:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding bodies to the world](img/0075SOS_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, we will have a solid ground, and moreover, a function that will allow
    us to create the entire totem quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s add these lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We just have to correctly call the `addBody` function to have our totem built
    with each brick defined with its own graphic assets, position, size, and property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Launch the game now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding bodies to the world](img/0075SOS_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: That's it! Our totem is standing on the floor, ready to be destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Updating sprite position as the world changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unfortunately, our totem is still just a bunch of static sprites. Yes, we attached
    them to a body, but what happens when the world changes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Try to remove the left foot of the totem, this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'I just commented a line; let''s see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating sprite position as the world changes](img/0075SOS_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: It definitively looks wrong. The totem should fall!
  prefs: []
  type: TYPE_NORMAL
- en: This happens because we properly placed the sprites when we created the bodies
    but since then, the sprites' position has not been updated.
  prefs: []
  type: TYPE_NORMAL
- en: The result is the sprites remain in the same position no matter what happens
    to the bodies. Remember? *Box2D does not allow attaching sprites to a body*. Lesson
    learned.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have to move sprites manually, in the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the game now:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Updating sprite position as the world changes](img/0075SOS_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, the totem falls! Let''s have a look at what happened:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This cycle loops through all bodies placed in the world.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`b` is now our current body, and we will see whether we set something into
    its user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once we know there's something in the user data, as in this case, we know it's
    one of the bodies we created to build the totem or the ground. Do you remember
    we created an object in the user data? The `mySprite` variable will store the
    sprite we inserted in this object.
  prefs: []
  type: TYPE_NORMAL
- en: The `GetPosition` method returns body's position; so, we can update the sprite
    position—remember the conversion from meters to pixels—and `getAngle` returns
    body rotation.
  prefs: []
  type: TYPE_NORMAL
- en: This way we can manually update all sprites attached to Box2D world bodies.
  prefs: []
  type: TYPE_NORMAL
- en: Selecting and destroying world bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the name Totem Destroyer suggests, you should be able to destroy the totem.
    First, uncomment the previously commented line in order to give back the totem
    its left foot, and then we are ready to destroy bricks when the player touches/clicks
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Everything starts with a touch, so we have to manage it by first adding the
    listener to the game''s `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Then create the `listener` variable itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s see what we added. First, we have to get click/touch coordinates and
    translate them into Box2D world coordinates; this means turning pixels into meters
    and placing coordinates into a `b2Vec2` variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we will loop through all bodies in the same way we do when it''s time
    to update the sprite''s'' position:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Not all bodies can be destroyed: the ground and dark bricks can''t be destroyed
    for instance, so we have to be sure we are only trying to destroy bricks we marked
    with `destroyable` in their user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we know a brick can be destroyed, we have to loop through all its fixtures
    and see whether one of them contains the point the player clicked/touched. This
    is how we will loop through all fixtures of a body:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'And once `f` represents the current texture, the `TestPoint` method will return
    `true` if the point passed as an argument is inside the fixture:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'At this time, we are sure the player touched the `b` body and we can destroy
    it, after having removed the sprite. Remember: *Box2D does not allow you to attach
    a sprite to a body*. The code snippet for this is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The `DestroyBody` method removes a body from the world.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and touch some bodies, then you will be able to destroy the light
    ones.
  prefs: []
  type: TYPE_NORMAL
- en: '![Selecting and destroying world bodies](img/0075SOS_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now the game is ready to be played we only have to check when the idol touches
    the ground. This is a game-over event, so it's very important.
  prefs: []
  type: TYPE_NORMAL
- en: Checking for collisions among bodies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To complete the prototype, we need to check whether the idol touches the ground.
    The simplest way, according to what you have learned about Box2D until now, is
    to continuously scan through idol collisions and check whether one of the bodies
    it collides with is the ground.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to add some lines to the `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'In the way that we looped through bodies and fixtures, we can loop through
    contacts using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: For every `c` contact, we check the body it got in contact with thanks to the
    `other` property; if its type is `ground`, we output a message in the console.
    The whole process is made only if the current body is the idol.
  prefs: []
  type: TYPE_NORMAL
- en: Run the game and let the idol touch the ground. You will see several instances
    of **Oh no!!!!** on your console log. And finally, we have a working Totem Destroyer
    prototype!!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Totem Destroyer level was a great achievement because now you are
    able to build a cross-platform game like one of the most played browser games;
    and all thanks to Box2D.
  prefs: []
  type: TYPE_NORMAL
- en: Why don't you improve it by setting a level goal—such as *remove four blocks*—and,
    when this is achieved, waiting a couple of seconds to see if the idol stays in
    its position without falling to the ground as in the original game?
  prefs: []
  type: TYPE_NORMAL
