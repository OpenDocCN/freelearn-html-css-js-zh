- en: Reusing Code with Many Different Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In previous chapters, we covered a lot of specific techniques. Among others,
    we have seen how modules are used to package code that defines types and values.
    We have also seen functions and function types, including their usage techniques,
    such as currying and partial application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we are going to build on what we have seen so far, and cover
    the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism techniques in Reason
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic code with modules and functors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Polymorphism in Reason
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism, a category of technique used in many programming languages, allows
    for writing code that can apply to different types or objects (in languages such
    as C++ or Java, for example). Looking at things precisely shows that there are
    several techniques or kinds of polymorphism.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will discuss two of those ways of doing polymorphism here:'
  prefs: []
  type: TYPE_NORMAL
- en: Parametric polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ad hoc polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic functions with parametric polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Parametric polymorphism allows a function or a data type to be written in a
    generic way, meaning that it can handle values in the same way regardless of their
    type. This is both interesting and powerful, since it implies that functions written
    using parametric polymorphism work on different data types.
  prefs: []
  type: TYPE_NORMAL
- en: In C++, parametric polymorphism is usually known as **generic programming**
    or **compile-time polymorphism**.
  prefs: []
  type: TYPE_NORMAL
- en: We can perform parametric polymorphism with types in ReasonML. There is a special
    feature we use to do it, **type variables**, which we already encountered in [Chapter
    7](e6bacad6-b207-4689-b068-088bed455956.xhtml), *Making Types that Represent Operations,*
    in one of the examples related to *function literals*. Instead of using a concrete
    type such as `int` or `string` for a parameter or result, we use  `type variable`.
    So, using  `type variable` as the type of a parameter would make sure that values
    of any type are accepted.
  prefs: []
  type: TYPE_NORMAL
- en: A function that uses `type variables` is called a **generic function**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explain with an example. The *identity* function is the usual simple
    example that helps explain what a generic function is. The identity function (let''s
    call it `id()`) just returns its input parameter. It is defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Based on that definition, ReasonML infers the type of the input parameter using
    `'a`, meaning it uses a type variable to indicate that values of any type are
    accepted. And the return type of the function is inferred in the same way, as
    the type of its parameter, the `'a` type variable. That is the behavior of a generic
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever we have a type name starting with `'`, such as `'a` (meaning *any type*),
    this defines a type variable.
  prefs: []
  type: TYPE_NORMAL
- en: Here, is another example of such a function. We can think of a function `(lastElem)`
    that returns the last element of a list. The point is that the elements of the
    list could be of any type. In addition to that, since we must account for the
    empty list case, we will use the option type with type variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write an interface for the function (see in the `src/Ch08/Ch08_GenericFunctionLastElementOfList.rei`
    file) as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And, based on how lists work in Reason, we can define a **recursive** function
    (using the `rec` keyword), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s test it with the following `Js.log` calls:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As expected, the output (see the `src/Ch08/Ch08_GenericFunctionLastElementOfList.re`
    file) shows `4` and `d` as resulting values.
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc polymorphism or overloading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ad hoc polymorphism is the other technique we are going to discuss now. It is
    also known as **overloading**, and it provides different implementations for the
    same operation, such as the `+` operation. To stick with this example, we may
    find in some programming languages, such as Python, that the `+` operation has
    an implementation for the addition of numbers, another one for string concatenation,
    and a third one for list or array concatenation.
  prefs: []
  type: TYPE_NORMAL
- en: Ad hoc polymorphism is supported by almost all programming languages for built-in
    operations, such as `+`, `-`, and `*`.
  prefs: []
  type: TYPE_NORMAL
- en: ReasonML does not currently support ad hoc polymorphism. So, for example, we
    have the distinct `+` operator for `int` addition, the `+.` one for float addition,
    and the `++` one for string concatenation. And, if needed, we have to manually
    convert values into the right types before applying a given operator to them.
  prefs: []
  type: TYPE_NORMAL
- en: ReasonML may eventually support ad hoc polymorphism via the modular implicits
    currently being developed.
  prefs: []
  type: TYPE_NORMAL
- en: Generic code with functors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we have seen, modules are important in OCaml and ReasonML, helping to organize
    code into units with specified interfaces. In addition to that, we are going to
    see now that they can serve for building generic code using what are called **Functors**.
  prefs: []
  type: TYPE_NORMAL
- en: What is a functor?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A functor is a function whose parameters are modules and whose result is a module.
  prefs: []
  type: TYPE_NORMAL
- en: Functors allow us to extend existing modules with new functionality, without
    requiring a lot of repetitive code for the different types we have.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax of functors looks as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'With these characteristics, note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The `F` functor has as parameters one or more `M1` modules and so on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each parameter module must be typed via an interface (`I1` for `M1` and so on)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The interface for the result type (`ResultI`) is optional
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some examples will help us understand.
  prefs: []
  type: TYPE_NORMAL
- en: Example 1 – looking in the standard library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The best example is the `Set` module that comes with the standard library.
  prefs: []
  type: TYPE_NORMAL
- en: A `Set` type has an ordering (for example, in the set of the integer numbers,
    *1 < 2* and *2 > 1*), and elements are unique. Note that we have that in other
    languages, such as Python, too.
  prefs: []
  type: TYPE_NORMAL
- en: To use sets in ReasonML and OCaml, you first have to make one. You do that by
    calling `Set.Make`, which is a functor. It takes as input another module that
    must have a `compare()` function implemented within it and returns our `Set` type
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can write this, for example, for a set of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We get a new module that provides functions for conveniently working with sets
    of integers, such as `IntSet.of_list()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s display the result in the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the `node` command to run the JS file generated by compiling that
    program file (`src/Ch08/Ch08_FunctorsExample1.re`), we get output showing the
    created `IntSet`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this first example, we got an idea of how functors work.
  prefs: []
  type: TYPE_NORMAL
- en: Example 2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here's another example taken from the ReasonML documentation, also about sets,
    that we are going to discuss. We will show a `MakeSet` functor that takes in a
    module of the `Comparable` type and returns a new set that can contain such comparable
    items.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by defining the `Comparable` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we define the functor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here is this code block explained:'
  prefs: []
  type: TYPE_NORMAL
- en: (1) We use a list as our data structure.
  prefs: []
  type: TYPE_NORMAL
- en: (2) If the item exists, return the same set.
  prefs: []
  type: TYPE_NORMAL
- en: (3) Else, prepend to the set and return it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s remember that we want to create a set, the items of which are pairs
    of integers. We create the input module, `IntPair`, which abides by the `Comparable`
    signature required by `MakeSet`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that we can write the following, using the functor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To finish, let''s add some code to use the resulting module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This should be enough to get something interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we use the `node` command to run the JS file generated by compiling our
    Reason code file (`src/Ch08/Ch08_FunctorsExample2.re`), we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: What have we done? Using a functor, we were able to create a module, `SetOfIntPairs`,
    from another module. The new module has the `add` function, among other things.
    Using the module, we can create an empty set (`0` in the output), to which we
    can add pairs of `int` instances on demand (using the previously mentioned `add`
    function).
  prefs: []
  type: TYPE_NORMAL
- en: Example 3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will now use an example from Axel Rauschmayer that can be found in his repository,
    at [https://github.com/rauschma/reasonml-demo-functors](https://github.com/rauschma/reasonml-demo-functors).
  prefs: []
  type: TYPE_NORMAL
- en: To be precise, let's use the Printable pair functor example, with a small adaptation,
    to help us easily understand how this can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before defining the functor, we must define the interface of its parameters.
    Here, we will have a single parameter, the `PrintablePair` module. For that, we
    will define a first type, `PrintableType`, that will be used by `PrintablePair`.
    We define it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add the definition of the `PrintablePair` type, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then define the functor, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have the code where we are going to use the functor, starting with defining
    the `PrintableString` and `PrintableInt` modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define `PrintableString` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'And, we define `PrintableInt` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we add the rest of the code, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When we use the `node` command to run the generated JS code  (from the Reason
    file, `src/Ch08/Ch08_FunctorsExample3.re`), we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We are done!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen that ReasonML supports parametric polymorphism using `type variable`s,
    one of the language features. When using  `type variable` as the type of a function's
    parameter, values of any type are accepted for that parameter. This technique
    allows writing what we call generic functions and plays an important part in code
    reusability in ReasonML.
  prefs: []
  type: TYPE_NORMAL
- en: In contrast, ad hoc polymorphism, the other kind of polymorphism that is supported
    in popular programming languages, does not yet exist in ReasonML. But work is
    in progress to correct that lack in a future version.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modules also play an important role in code reuse. But, that''s not all. In
    addition to what they allow by themselves, ReasonML has a powerful feature that
    augments what we can do with them: *functors*. They are like special functions
    that take one or several modules as input and return a module. That opens up some
    possibilities in terms of programming generically.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to explore ReasonML techniques for extending
    types to add behavior.
  prefs: []
  type: TYPE_NORMAL
