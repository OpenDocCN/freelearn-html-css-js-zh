<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-15">1. <a id="_idTextAnchor014"/>TypeScript Fundamentals</h1>
		</div>
		<div><p class="callout-heading"><a id="_idTextAnchor015"/>Overview</p>
			<p class="callout">In this chapter, we'll briefly illustrate the problems that exist in JavaScript development environments, and we'll see exactly how TypeScript helps us write better and more maintainable code. This chapter will first help you set up the TypeScript compiler and then teach you the fundamentals. Additionally, we'll begin our journey into types, as they are the core feature of TypeScript – it's right in the name. Finally, you will be able to test your newly gained TypeScript skills by creating your own library.</p>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor016"/>Introduction</h1>
			<p>The world of online applications has grown tremendously in the past few decades. With it, web-based applications have grown not only in size but also in complexity. JavaScript, a language that was originally thought of and used as a go-between between the core application logic and the user interface, is being seen in a different light. It is the de facto language with which web apps are being developed. However, it just was not designed for the building of large applications with lots of moving parts. Along came TypeScript.</p>
			<p>TypeScript is a superset of JavaScript that provides lots of enterprise-level features that JavaScript lacks, such as modules, types, interfaces, generics, managed asynchrony, and so on. They make our code easier to write, debug, and manage. In this chapter, you will first learn how the TypeScript compiler works, how transpilation occurs, and how you can set up the compiler options to suit your needs. Then, you will dive straight into TypeScript types, functions, and objects. You will also learn how you can make your own types in TypeScript. Finally, you can test your skills by attempting to create your own library to work with strings. This chapter serves as a launchpad with which you can jump-start your TypeScript journey.</p>
			<h2 id="_idParaDest-17"><a id="_idTextAnchor017"/>The Evolution of TypeScript</h2>
			<p>TypeScript was designed by Microsoft as a special-purpose language with a single goal – to enable people to write better JavaScript. But why was that an issue at all? To understand the problem, we have to go back to the roots of the scripting languages for the web.</p>
			<p><a id="_idTextAnchor018"/>In the beginning, JavaScript was designed to enable only a basic level of interactivity on the web. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">JavaScript was initially developed in 1995 by Brendan Eich for use in Netscape Navigator.</p>
			<p>It was specifically not designed to be the main language that runs within a web page, but to be a kind of glue between the browser and the plugins, such as Java applets that run on the site. The heavy lifting was supposed to be done by the plugin code, with JavaScript providing a simple layer of interoperability. JavaScript did not even have any methods that would enable it to access the server. Another design goal for JavaScript was that it had to be easy to use for non-professional developers. That meant that the language had to be extremely forgiving of errors, and quite lax with its syntax.</p>
			<p>For a few years, that was the task that JavaScript (or, more properly, ECMAScript, as it was standardized) was actually doing. But more and more web pages came into existence, and more and more of them needed dynamic content. Suddenly, people needed to use a lot of JavaScript. Web pages started getting more and more complex, and they were now being referred to as web <em class="italic">applications</em>. JavaScript got the ability (via AJAX) to access servers and even other sites, and a whole ecosystem of libraries appeared that helped us write better web applications.</p>
			<p>However, the language itself was still lacking lots of features that are present in most languages – primarily features that are targeted toward professional developers.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Some of the most talked-about features included a lack of module/namespace support, type-checked expressions, better scoping mechanisms, and better support for asynchronous functionality.</p>
			<p>Since it was designed for small-scale usage, it was very troublesome to build, and especially to maintain, large applications built with JavaScript. On the other hand, once it was standardized, JavaScript became the <em class="italic">only</em> way to actually run code inside the browser. So, one solution that was popular in the 2000s was to make an emulation layer – a kind of a tool that enabled developers to use their favorite language to develop an application that will take the original source code as input and output equivalent JavaScript code. Such tools became known as <em class="italic">transpilers</em> – a portmanteau of the words "translator" and "compiler." While traditional compilers take source code as input and output machine code that can execute directly on the target machine, transpilers basically translated the source code from one language to another, specifically to JavaScript. The resulting code is then executed on the browser.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code actually gets compiled inside the browser, but that's another story.</p>
			<p>There were two significant groups of transpilers present – ones that transpiled from an existing language (C#, Java, Ruby, and so on) and ones that transpiled from a language specifically designed to make web development easier (CoffeeScript, Dart, Elm, and so on).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can see a comprehensive list at <a href="https://packt.link/YRoA0">https://packt.link/YRoA0</a>.</p>
			<p><a id="_idTextAnchor019"/>The major problem with most transpilers was that they were not native to the web and JavaScript. The JavaScript that was generated was confusing and non-idiomatic – it looked like it was written by a machine and not a human. That would have been fine, except that generated mess was the code that was actually executing. So, using a transpiler meant that we had to forgo the debugging experience, as we could not understand what was actually being run. Additionally, the file size of the generated code was usually large, and more often than not, it included a huge base library that needed to load before we would be able to run our transpiled code.</p>
			<p>Basically, by 2012 there were two options in sight – write a large web application using plain JavaScript, with all the drawbacks that it had, or write large web applications using a transpiler, writing better and more maintainable code, but being removed from the platform where our code actually runs.</p>
			<p class="Body-Text">Then, TypeScript was introduced.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">A video of the introductory lecture is available at <a href="https://channel9.msdn.com/Events/Build/2012/3-012">https://channel9.msdn.com/Events/Build/2012/3-012</a>.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor020"/>Design Goals of TypeScript</h2>
			<p class="Body-Text">The core idea behind it was one that, in hindsight, seems quite obvious. Instead of replacing JavaScript with another language, why not just add the things that are missing? And why not add them in such a way that they can be very reasonably removed at the transpiling step, so that the generated code will not only look and be idiomatic but also be quite small and performant? What if we can add things such as static typing, but in an optional way, so that it can be used as much or as little as we want? What if all of that existed while we're developing and we can have nice tooling and use a nice environment, yet we're still able to debug and understand the generated code?</p>
			<p>The design goals of TypeScript, as initially stated, were as follows:  </p>
			<ul>
				<li>Extend JavaScript to facilitate writing large applications.</li>
				<li>Create a strict superset of JavaScript (that is, any valid JavaScript is valid TypeScript).</li>
				<li>Enhance the development tooling support.</li>
				<li>Generate JavaScript that runs on any JavaScript execution environment.</li>
				<li>Easy transfer between TypeScript and JavaScript code.</li>
				<li>Generate clean, idiomatic JavaScript.</li>
				<li>Align with future JavaScript standards.</li>
			</ul>
			<p>Sounds like a pie-in-the-sky promise, and the initial response was a bit lukewarm. But, as time progressed, and as people actually tried it and started using it in real applications, the benefits became obvious.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The author's lecture on TypeScript, which was the first one to be broadcast worldwide by a non-Microsoft employee, can be found at <a href="https://www.slideshare.net/sweko/typescript-javascript-done-right">https://www.slideshare.net/sweko/typescript-javascript-done-right</a>.</p>
			<p>Two areas where TypeScript became a power player were JavaScript libraries and server-side JavaScript, where the added strictness of type checking and formal modules enabled higher-quality code. Currently, all of the most popular web development frameworks are either natively written in TypeScript (such as Angular, Vue, and Deno) or have tight integrations with TypeScript (such as React and Node).</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor021"/>Getting Started with TypeScript</h1>
			<p>Consider the following TypeScript program – a simple function that adds two numbers:</p>
			<pre>Example 01.ts
1 function add (x, y) {
2    return x + y;
3 }
Link to the example on GitHub: <a href="https://packt.link/P9k6d">https://packt.link/P9k6d</a></pre>
			<p>No, that's not a joke – that's real-life TypeScript. We just did not use any TypeScript-specific features. We can save this file as <code>add.ts</code> and can compile it to JavaScript using the following command:</p>
			<pre>tsc add.ts</pre>
			<p>This will generate our output file, <code>add.js</code>. If we open it and look inside, we can see that the generated JavaScript is as follows:</p>
			<pre>Example 01.js
1 function add(x, y) {
2     return x + y;
3 }
Link to the example on GitHub: <a href="https://packt.link/mTfWp">https://packt.link/mTfWp</a></pre>
			<p>Yes, aside from some spacing, the code is identical, and we have our first successful transpilation.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor022"/>The TypeScript Compiler</h2>
			<p>We will add to the example, of course, but let's take a moment to analyze what happened. First of all, we gave our file the <code>.ts</code> file extension. All TypeScript files have this extension, and they contain the TypeScript source code of our application. But, even if our code is valid JavaScript (as in this case), we cannot just load the <code>.ts</code> files inside a browser and run them. We need to compile/transpile them using the tool called the "TypeScript compiler," or <code>tsc</code> for short. What this tool does is takes TypeScript files as arguments and generates JavaScript files as outputs. In our case, our input was <code>add.ts</code> and our output was <code>add.js</code>. The <code>tsc</code> compiler is an extremely powerful tool, and it has a lot of options that we're able to set. We can get a full list of the options using this command:</p>
			<pre>tsc --all</pre>
			<p>The most common and important ones are as follows:</p>
			<ul>
				<li><code>–outFile</code>: With this option, we can specify the name of the output file we want to be generated. If it's not specified, it defaults to the same name as the input file, but with the <code>.js</code> extension.</li>
				<li><code>–outDir</code>: With this option, we can specify the location of the output file(s). By default, the generated files will be in the same location as the source files.</li>
				<li><code>–types</code>: With this option, we can specify additional types that will be allowed in our source code.</li>
				<li><code>–lib</code>: With this option, we specify which library files need to be loaded. As there are different execution environments for JavaScript, with different default libraries (for example, browser JavaScript has a <code>window</code> object, and Node.js has a <code>process</code> object), we can specify which one we want to target. We can also use this option to allow or disallow specific JavaScript functionality. For example, the <code>array.include</code> method was added in the <code>es2016</code> JavaScript version. If we want to assume that the method will be available, then we need to add the <code>es2016.array.include</code> library.</li>
				<li><code>–target</code>: With this option, we specify which version of the ECMAScript (that is, JavaScript) language we're targeting. That is, if we need to support older browsers, we can use the <code>ES3</code> or <code>ES5</code> values, which will compile our code to JavaScript code that will execute in any environment that supports, correspondingly, versions 3 and 5 of the JavaScript language. If, on the other hand, we know that we'll run in an ultra-modern environment, as the latest Node.js runtime, we can use the <code>ES2020</code> target, or even <code>ESNEXT</code>, which is always the next available version of the ECMAScript language.</li>
				<li>There are several more options; however, we have only discussed a few here.</li>
			</ul>
			<h2 id="_idParaDest-21"><a id="_idTextAnchor023"/>Setting Up a TypeScript Project</h2>
			<p>Since the TypeScript compiler has lots of options, and we'll need to use quite a few of them, specifying all of them each and every time we transpile a file will get tedious very fast. In order to avoid that, we can save our default options in a special file that will be accessed by the <code>tsc</code> command. The best way to generate this special file called <code>tsconfig.json</code> is to use <code>tsc</code> itself with the <code>--init</code> option. So, navigate to the folder where you want to store your TypeScript project and execute the following command:</p>
			<pre>tsc --init</pre>
			<p>This will generate a <code>tsconfig.json</code> file with the most commonly used option. The rest of the options are commented out, so if we want to use some other set of options, we can simply uncomment what we need. If we ignore the comments (which include a link to the documentation about the options), we get the following content:</p>
			<pre>{
  "compilerOptions": {
    "target": "es5",
    "module": "commonjs",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  }
}</pre>
			<p>You can see that each and every option in the <code>tsconfig.json</code> file has a corresponding command-line switch, for example, <code>module</code>, <code>target</code>, and so on. If a command-line switch is specified, it takes precedence. However, if a command-line switch is not defined, then <code>tsc</code> looks for the nearest <code>tsconfig.json</code> file up the directory hierarchy and takes the value specified there.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor024"/>Exercise 1.01: Using tsconfig.json and Getting Started with TypeScript</h2>
			<p>In this exercise, we'll see how to command TypeScript using the <code>tsconfig.json</code> file. We'll see how to create TypeScript files and transpile them to JavaScript, based on the options we specify:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Please make sure you have installed <strong class="bold">Visual Studio</strong> (<strong class="bold">VS</strong>) Code and followed the installation steps as mentioned in the <em class="italic">Preface</em>. The code files for this exercise can be found here: <a href="https://packt.link/30NuU">https://packt.link/30NuU</a>.</p>
			<ol>
				<li>Create a new folder and execute the following command in a new terminal within it:<pre>tsc --init</pre></li>
				<li>Verify that a new <code>tsconfig.json</code> file is created within the folder and that its target value is <code>es5</code>.</li>
				<li>Create a new file called <code>squares.ts</code> inside it.</li>
				<li>In <code>squares.ts</code>, create a function called <code>squares</code>:<pre>function squares(array: number[]) {</pre></li>
				<li>Create a new array from the input argument, using the JavaScript <code>map</code> function with an arrow function argument:<pre>    const result = array.map(x =&gt; x * x);</pre></li>
				<li>Return the new array from the function:<pre>    return result;
}</pre></li>
				<li>Save the file and run the following command in the folder:<pre>tsc squares.ts</pre></li>
				<li>Verify that there is a new file in the folder called <code>squares.js</code> with the following content:<pre>function squares(array) {
    var result = array.map(function (x) { return x * x; });
    return result;
}</pre><p>Here, we can see that the transpilation step did several things:</p><p>- It removed the type annotation from the <code>array: number[]</code> parameter, transpiling it to <code>array</code>.</p><p>- It changed the <code>const result</code> variable declaration to a <code>var result</code> declaration.</p><p>- It changed the arrow function, <code>x=&gt;x*x</code>, to a regular function, <code>function (x) { return x * x; }</code>.</p><p>While the first is TypeScript-specific code, the second and third are examples of TypeScript's backward compatibility – both the arrow functions and the <code>const</code> declarations are JavaScript features that were introduced in the ES6 version of the language.</p></li>
				<li>Run the following command in the folder:<pre>tsc --target es6 squares.ts</pre><p>This will override the setting from the <code>tsconfig.json</code> file and it will transpile the TypeScript code to <code>ES6</code>-compatible JavaScript.</p></li>
				<li>Verify that the contents of the <code>squares.js</code> file are now as follows:<pre>function squares(array) {
    const result = array.map(x =&gt; x * x);
    return result;
}</pre><p>You can note that, in contrast to the results in <em class="italic">step 8</em>, now the <code>const</code> keyword and the arrow functions are intact, because the target we specified supports them natively. This is an extremely important feature of TypeScript. With this feature, even if we don't use the rich type system that TypeScript provides, we can still write code in the most modern version of JavaScript available, and TypeScript will seamlessly transpile our code to a version that can actually be consumed by our customers.</p></li>
			</ol>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor025"/>Types and Their Uses</h2>
			<p>We've mentioned that TypeScript's type system is its distinguishing feature, so let's take a better look at it. JavaScript is what's called a loosely typed language. That means that it does not enforce any rules on the defined variables and their values. Consider, for example, that we define a variable called <code>count</code> and set it to the value of <code>3</code>:</p>
			<pre>let count = 3;</pre>
			<p>There is nothing that prevents us from setting that variable to a value that is a string, a date, an array, or basically any object. All of the following assignments are valid:</p>
			<pre>count = "string";
count = new Date();
count = false;
count = [1, 2, 3];
count = { key: "value" };</pre>
			<p>In almost all scenarios, this is not a behavior we actually want. Moreover, since JavaScript does not know when we are writing the code whether a variable contains a string or a number, it cannot stop us from trying to, for example, convert it to lowercase. We cannot know whether that operation will succeed or fail until the moment we actually try it, when running the code.</p>
			<p>Let's take the following example:</p>
			<pre>let variable;
if (Math.random()&gt;0.5) {
    variable = 3;
} else {
    variable = "String";
}
console.log(variable.toLowerCase());</pre>
			<p>This code will either output <code>"String"</code> or throw a <code>variable.toLowerCase is not a function</code> error. The only way to determine whether this code will break is to actually run it. In a nutshell, in a loosely typed language, while values themselves have types, variables, on the other hand, don't. They just take the type of the value they are currently holding. So, any checks whether a method is possible on a variable, such as <code>variable.toLowerCase()</code>, can only be done when we have the actual value, that is, when we run the code. Once more, this is quite fine for small-sized applications, but it can become tedious for large-scale applications. In contrast, strongly typed languages enforce the type rules for both the values and the variables they live in. This means that the language itself can detect the error as you are typing the code, as it has more information about what is going on in your code.</p>
			<p>So, in a large software product, (in most cases) we don't want variables that have values of different types. So, we want to be able to somehow say "this variable has to be a number, and if someone tries to put something that is not a number inside it, issue an error." </p>
			<p>This is where TypeScript, as a strongly typed language, comes in. We have two ways that we can use to bind a variable to a type. The simpler one is to simply annotate the variable with the type we want it to be, like this:</p>
			<pre>let variable: number;</pre>
			<p>The <code>: number</code> part of the code is called a <em class="italic">type</em> annotation, and we're doing just that – saying "this variable has to be a number, and if someone tries to put something that is not a number inside it, issue an error."</p>
			<p>Now, if we try to assign a number to that variable, everything is fine. But the minute we try to assign a string to the variable, we'll get an error message:</p>
			<div><div><img src="img/B14508_01_01.jpg" alt="Figure 1.1: Error message from assigning an incorrect type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">F<a id="_idTextAnchor026"/>igure 1.1: Error message from assigning an incorrect type</p>
			<p>This type of annotation is explicit and specific to TypeScript. Another way is simply to assign a value to a variable and let TypeScript work its magic. The magic is called <em class="italic">type inference</em>, and that means that TypeScript will try to guess the type of the variable based on the value provided. </p>
			<p>Let's define a variable and initialize it with a value, like this:</p>
			<pre>let variable = 3;</pre>
			<p>Now, if we try to assign a string to that variable, TypeScript will issue an error:</p>
			<div><div><img src="img/B14508_01_02.jpg" alt="Figure 1.2: Error message from assigning an incorrect type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.2: Error message from assigning an incorrect type</p>
			<p>From the error message, we can see the type that TypeScript correctly inferred for the variable – <code>number</code>. Actually, in most cases, we won't even need to add type annotations, as TypeScript's powerful type inference engine will correctly infer the type of the variable.</p>
			<h1 id="_idParaDest-24">Ty<a id="_idTextAnchor027"/>peScript and Functions</h1>
			<p>Another huge benefit of TypeScript is automatic function invocation checking. Let's say that we have the function we used for our first TypeScript file:</p>
			<pre>function add (x, y) {
    return x + y;
}</pre>
			<p>Even without any type annotations, TypeScript still has some information about this function – namely, that it takes two, and exactly two, parameters. </p>
			<p>In contrast, JavaScript does not enforce that the number of actual arguments has to conform to the number of parameters defined, so all of the following invocations are valid calls in JavaScript:</p>
			<pre>add(1, 2); // two arguments
add(1, 2, 3); // three arguments
add(1); // one argument
add(); // no arguments</pre>
			<p>In JavaScript, we can call a function with more arguments than parameters, fewer arguments, or even without any arguments at all. If we have more arguments than needed, the extra arguments are simply ignored (and stored in the magical <code>arguments</code> variable), and if we have fewer arguments than needed, the extra parameters are given the value <code>undefined</code>. So, in essence, the preceding calls will be correspondingly transformed into the following:</p>
			<pre>add(1, 2); // no changes, as the number of arguments match the number of parameters.
add(1, 2); // the third argument is ignored
add(1, undefined); // the second parameter is given a value of undefined
add(undefined, undefined); // both parameters are given a value of undefined</pre>
			<p>In the third and fourth cases, the return value of the function will be the special numeric value <code>NaN</code>.</p>
			<p>TypeScript has a radically different approach to this issue. A function can only be called using valid arguments – both in number and in type. So, if we write the same code, but this time in a TypeScript file, we'll get appropriate error messages. For a case where we have extra arguments, we'll get an error message on the extra arguments:</p>
			<div><div><img src="img/B14508_01_03.jpg" alt="Figure 1.3: Error message from using an incorrect number of &#13;&#10;arguments – too many in this case&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.3: Error message from using an incorrect number of arguments – too many in this case</p>
			<p>For cases with too few arguments, we get the error message on the method itself:</p>
			<div><div><img src="img/B14508_01_04.jpg" alt="Figure 1.4: Error message from using an incorrect number &#13;&#10;of arguments – too few in this case&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.4: Error message from using an incorrect number of arguments – too few in this case</p>
			<p>In this case, we're notified that a required parameter is missing, as well as what the name and the type of that parameter should be. Note that it's a common JavaScript technique to have methods that accept a variable number of parameters, accept optional parameters, or provide some defaults if a parameter is not specified. All those cases (and many more) are correctly handled by TypeScript. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Details on how to write such methods using TypeScript are inlcuded in <em class="italic">Chapter 3</em>, <em class="italic">Functions</em>.</p>
			<p>Of course, parameter checking works not only on the number but also on the type of the parameters as well. We would want the <code>add</code> function to work only with numbers – it does not make sense to add a Boolean and an object, for example. In TypeScript, we can annotate our function like this:</p>
			<pre>function add (x: number, y: number) {
    return x + y;
}</pre>
			<p>This will cause the compiler not only to check that the number of arguments matches the number of parameters but also to verify that the types used for the arguments are actually valid. Since JavaScript can't check for that, adding a Boolean and an object is actually a valid call to the JavaScript equivalent of our <code>add</code> method. Furthermore, since JavaScript tries to be as forgiving as possible, we won't even get a runtime error – the call will be successful, as JavaScript will coerce both the object and Boolean to a common string representation, and then try (and succeed) to add those two values together.</p>
			<p>Let's interpret the following call to our function as both JavaScript and TypeScript:</p>
			<pre>const first = { property: 'value'};
const second = false;
const result = add(first, second);</pre>
			<p>This is valid, albeit nonsensical, JavaScript code. If run, it will yield the result <code>[object Object]false</code>, which would not be useful in any context.</p>
			<p>The same code, interpreted as TypeScript, will yield the following compile type error:</p>
			<div><div><img src="img/B14508_01_05.jpg" alt="Figure 1.5: Error message on VS Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.5: Error message on VS Code</p>
			<p>We can also annotate the return type of the function, adding a type annotation after the parameter list:</p>
			<pre>function add (x: number, y: number): number {
    return x + y;
}</pre>
			<p>That is usually not necessary, as TypeScript can actually infer the return type from the return statements given. In our case, since <code>x</code> and <code>y</code> are numbers, <code>x+y</code> will be a number as well, which means that our function will return a number. However, if we do annotate the return type, TypeScript will enforce that contract as well:</p>
			<div><div><img src="img/B14508_01_06.jpg" alt="Figure 1.6: TypeScript enforcing the correct type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.6: TypeScript enforcing the correct type</p>
			<p>In either case, whether we explicitly annotate the return type or it's inferred, the type of the function will be applied to any values that are produced by calling the function. So, if we assign the return value to some variable, that variable will have the type of <code>number</code> as well:</p>
			<div><div><img src="img/B14508_01_07.jpg" alt="Figure 1.7: VS Code showing the type of the variable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.7: VS Code showing the type of the variable</p>
			<p>Also, if we try to assign the return value to a variable that is already known to be something else other than a number, we'll get an appropriate error:</p>
			<div><div><img src="img/B14508_01_08.jpg" alt="Figure 1.8: Error message on VS Code&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.8: Error message on VS Code</p>
			<p>Let's make another great point about TypeScript and its type system. As can be seen, the screenshots in this chapter don't show actual compiler error messages – they are taken from inside a code editor (VS Code, an editor that is itself written in TypeScript).</p>
			<p>We did not even have to actually compile the code. Instead, we got the error messages while we typed the code – an experience that is familiar to developers in other strongly typed languages, such as C# or Java. </p>
			<p>This happens because of the design of the TypeScript compiler, specifically its Language Service API. This enables the editor to easily use the compiler to check the code as it's written so that we can get a nice and intuitive GUI. Additionally, since all the editors will use the same compiler, the development experience will be similar across different editors. This is a dramatic change from the situation that we started with – fully writing, loading, and actually executing the JavaScript code in order to know whether it even makes sense.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In recent years, some editors have started using the TypeScript Language Service API on JavaScript code as well, so TypeScript improves even the plain JavaScript development experience.</p>
			<p>In a nutshell, using TypeScript changes one of the most prevalent pain points for JavaScript development – inconsistent and sometimes even impossible tooling support – into a much easier and more convenient experience. In our case, we need only to open a parenthesis when calling the <code>add</code> function, and we'll see the following:</p>
			<div><div><img src="img/B14508_01_09.jpg" alt="Figure 1.9: List of parameters that the function can take&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.9: List of parameters that the function can take</p>
			<p>We are shown a list of parameters that shows that the function – which can be defined in another file, by another developer – takes two numbers and also returns a number.</p>
			<h2 id="_idParaDest-25">Exercise <a id="_idTextAnchor028"/>1.02: Working with Functions in TypeScript</h2>
			<p>In this exercise, we'll define a simple function and see how we can and can't invoke it. The function we will be developing will be a string utility function that shortens a string to a snippet. We'll basically cut off the text after a given length, but take care that we don't chop a word in half. If the string is larger than the maximum length, we'll add an ellipsis (<code>…</code>) to the end:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/BHj53">https://packt.link/BHj53</a>.</p>
			<ol>
				<li value="1">Create a new file called <code>snippet.ts</code>.</li>
				<li>In <code>snippet.ts</code>, define a simple function called <code>snippet</code>:<pre>function snippet (text: string, length: number) : string {</pre></li>
				<li>Check whether the text is smaller than the specified length, and if it is, return it unchanged:<pre>    if (text.length &lt; length) {
        return text;
    }</pre></li>
				<li>If the text is larger than the maximum length, we'll need to add an ellipsis. The maximum number of characters that we'll be able to show is the specified length minus the length of our ellipsis (as it takes up space too). We'll use the <code>slice</code> string method to extract that many characters from the text:<pre>    const ellipsis = "...";
    let result = text.slice(0, length - ellipsis.length);</pre></li>
				<li>We'll find the last word boundary before the cutoff, using <code>lastIndexOf</code>, and then combine the text up to that point with the ellipsis:<pre>    const lastSpace = result.lastIndexOf(" ");
    result = `${result.slice(0, lastSpace)}${ellipsis}`;</pre></li>
				<li>Return the result from the function:<pre>    return result;
}</pre></li>
				<li>After the function, create a few calls to the function with different parameter types:<pre>// correct call and usage
const resultOne = snippet("TypeScript is a programming language that is a strict syntactical superset of JavaScript and adds optional static typing to the language.", 40);
console.log(resultOne);
// missing second parameter
const resultTwo = snippet("Lorem ipsum dolor sit amet");
console.log(resultTwo);
// The first parameter is of incorrect type
const resultThree = snippet(false, 40);
console.log(resultThree);
// The second parameter is of incorrect type
const resultFour = snippet("Lorem ipsum dolor sit amet", false);
console.log(resultFour);
// The result is assigned to a variable of incorrect type
var resultFive: number = snippet("Lorem ipsum dolor sit amet", 20);
console.log(resultFive);</pre></li>
				<li>Save the file and run the following command in the folder:<pre>tsc snippet.ts</pre></li>
				<li>Verify that the file did not compile correctly. You will get specifics from the compiler about the errors found, and the compilation will end with the following message:<pre>Found 3 errors.</pre></li>
				<li>Comment out or delete all invocations except the first one:<pre>// correct call and usage
var resultOne = snippet("TypeScript is a programming language that is a strict syntactical superset of JavaScript and adds optional static typing to the language.", 40);
console.log(resultOne);</pre></li>
				<li>Save the file and compile it again:<pre>tsc snippet.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>snippet.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with the following command:<pre>node snippet.js</pre><p>You will see an output that looks as follows:</p><pre>TypeScript is a programming language...</pre></li>
			</ol>
			<p>In this exercise, we developed a simple string utility function, using TypeScript. We saw the two main strengths of TypeScript. For one, we can see that the code is idiomatic JavaScript – we could leverage our exis<a id="_idTextAnchor029"/>ting JavaScript knowledge to write the function. <em class="italic">Steps 3</em> through <em class="italic">6</em>, the actual body of the function, are exactly the same in JavaScript and TypeScript.</p>
			<p>Next, we saw that TypeScript takes care that we invoke the function correctly. In <em class="italic">step 7</em>, we tried five different invocations of the function. The last four invocations are incorrect ones – they would have been errors either in JavaScript or TypeScript. The important difference is that with TypeScript, we immediately got feedback that the usage is invalid. With JavaScript, the errors would have only been visible when we, or a client, actually executed the code.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor030"/>TypeScript and Objects</h1>
			<p>One great thing about JavaScript is its object literal syntax. While in some languages, to create an object we have to do a lot of groundwork, such as creating classes and defining constructors, in JavaScript, and by extension in TypeScript, we can just create the object as a literal. So, if we want to create a <code>person</code> object, with <code>firstName</code> and <code>lastName</code> properties, we only need to write the following:</p>
			<pre>const person = {
    firstName: "Ada",
    lastName: "Lovelace"
}</pre>
			<p>JavaScript makes it easy to create and use the object, just like any other value. We can access its properties, pass it as an argument into <code>methods</code>, receive it as a <code>return</code> value from functions, and so on. And because of JavaScript's dynamic nature, it's very easy to add properties to our object. If we wanted to add an <code>age</code> property to our object, we could just write the following:</p>
			<pre>person.age = 36;</pre>
			<p>However, because of the loose typing, JavaScript has no knowledge of our object. It does not know what the possible properties of our object are, and what methods can and cannot use it as an argument or a return value. So, say we make a typo, for example, writing out something like this:</p>
			<pre>console.log("Hi, " + person.fristName);</pre>
			<p>JavaScript will happily execute this code and write out <code>Hi undefined</code>. That is not what we intended, and will only be visible and detectible when the code is actually run in the browser. Using TypeScript, we have a few options to remedy that. So, let's rewrite our <code>person</code> object using TypeScript:</p>
			<pre>const person = {
    firstName: "Ada",
    lastName: "Lovelace"
}
console.log(`Hi, ${person.fristName}`);</pre>
			<p>This code will immediately be marked as invalid by the compiler, even when we haven't added any type information:</p>
			<div><div><img src="img/B14508_01_10.jpg" alt="Figure 1.10: TypeScript compiler inferring the type of the object&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.10: TypeScript compiler inferring the type of the object</p>
			<p>From the error message, we can see what the TypeScript compiler inferred for the type of our object – it thinks that its type consists of two properties, <code>firstName</code> of type <code>string</code> and <code>lastName</code> of type <code>string</code>. And according to that definition, there is no place for another property called <code>fristName</code>, so we are issued an error.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Notice the suggestion <code>Did you mean 'firstName'?</code> along with the link to the definition of the <code>person</code> class. Since typos are common, the type inference algorithm tries to detect and offer suggestions on common typos.</p>
			<p>So, once more, we have detected a bug in our code just by using TypeScript, with no additional code written. TypeScript does this by analyzing the definition of the object and extracts the data from there. It will allow us to write code such as the following:</p>
			<pre>person.lastName = "Byron";</pre>
			<p>But it will not allow us to write code where we set <code>lastName</code> to a number:</p>
			<div><div><img src="img/B14508_01_11.jpg" alt="Figure 1.11: Error message by assigning an incorrect type to lastName&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.11: Error message by assigning an incorrect type to lastName</p>
			<p>Sometimes, we know more about the shape of our objects than TypeScript does. For example, TypeScript inferred that our type has only the <code>firstName</code> and <code>lastName</code> properties. So, if we set the age in TypeScript, with <code>person.age = 36;</code>, we will get an error. In this case, we can explicitly define the type of our object, using a TypeScript interface. The syntax that we can use looks as follows:</p>
			<pre>interface Person {
    firstName: string;
    lastName: string;
    age? : number;
}</pre>
			<p>With this piece of code, we're defining an abstract – a structure that some object will need to satisfy in order to be allowed to be treated as a <code>Person</code> object. Notice the question mark (<code>?</code>) next to the <code>age</code> variable name. That denotes that that property is in fact optional. An object does not have to have an <code>age</code> property in order to be a <code>Person</code> object. However, if it does have an <code>age</code> property, that property has to be a number. The two other properties (<code>firstName</code> and <code>lastName</code>) are mandatory.</p>
			<p class="Body-Text">Using this definition, we can define and use our object using the following:</p>
			<pre>const person: Person = {
    firstName: "Ada",
    lastName: "Lovelace"
}
person.age = 36;</pre>
			<p>We can use <a id="_idTextAnchor031"/>interfaces as type annotations for function arguments and return types as well. For example, we can define a function called <code>showFullName</code> that will take a person object and display the full name to the console:</p>
			<pre>function showFullName (person: Person) {
    console.log(`${person.firstName} ${person.lastName}`)
}</pre>
			<p>If we invoke this function with <code>showFullName(person)</code>, we'll see that it will display <code>Ada Lovelace</code> on the console. We can also define a function that will take two strings, and return a new object that fits the <code>Person</code> interface:</p>
			<pre>function makePerson (name: string, surname: string): Person {
    const result = {
        firstName: name,
        lastName: surname
    }
    return result;
}
const babbage = makePerson("Charles", "Babbage");
showFullName(babbage);</pre>
			<p>One important thing that we need to point out is that, unlike in other languages, the interfaces in TypeScript are structural and not nominal. What that means is that if we have a certain object that fulfills the "rules" of the interface, that object can be considered to be a value of that interface. In our <code>makePerson</code> function, we did not specify that the <code>result</code> variable is of the <code>Person</code> type – we just used an object literal with <code>firstName</code> and <code>lastName</code> properties, which were strings. Since that is enough to be considered a person, the code compiles and runs just fine. This is a huge boon to the type inference system, as we can have lots of type checks without having to explicitly define them. In fact, it's quite common to omit the return type of functions.</p>
			<h2 id="_idParaDest-27">Exercise 1.<a id="_idTextAnchor032"/>03: Working with Objects</h2>
			<p>In this exercise, we'll define a simple object that encapsulates a book with a few properties. We'll try to access and modify the object's data and verify that TypeScript constrains us according to inferred or explicit rules. We will also create a function that takes a book object and prints out the book's details:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/N8y1f">https://packt.link/N8y1f</a>.</p>
			<ol>
				<li value="1">Create a new file called <code>book.ts</code>.</li>
				<li>In <code>book.ts</code>, define a simple interface called <code>Book</code>. We will have properties for the author and the title of the book, optional properties for the number of pages of the book, and a Boolean that denotes whether we have read the book:<pre>interface Book {
    author: string;
    title: string;
    pages?: number;
    isRead?: boolean;
}</pre></li>
				<li>Add a function called <code>showBook</code> that will display the book's author and title to the console. It should also display whether the book has been read or not, that is, whether the <code>isRead</code> property is present:<pre>function showBook(book: Book) {
    console.log(`${book.author} wrote ${book.title}`);
    if (book.isRead !== undefined) {
        console.log(`  I have ${book.isRead ? "read" : "not read"} this book`);
    }
}</pre></li>
				<li>Add a function called <code>setPages</code> that will take a book and a number of pages as parameters, and set the <code>pages</code> property of the book to the provided value:<pre>function setPages (book: Book, pages: number) {
    book.pages = pages;
}</pre></li>
				<li>Add a function called <code>readBook</code> that will take a book and mark it as having been read:<pre>function readBook(book: Book) {
    book.isRead = true;
}</pre></li>
				<li>Create several objects that fulfill the interface. You can, but don't have to, annotate them with the interface we have created:<pre>const warAndPeace = {
    author: "Leo Tolstoy",
    title: "War and Peace",
    isRead: false
}
const mobyDick: Book = {
    author: "Herman Melville",
    title: "Moby Dick"
}</pre></li>
				<li>Add code that will call methods on the books:<pre>setPages(warAndPeace, 1225);
showBook(warAndPeace);
showBook(mobyDick);
readBook(mobyDick);
showBook(mobyDick);</pre></li>
				<li>Save the file and run the following command in the folder:<pre>tsc book.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>book.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with the following command:<pre>node book.js</pre><p>You will see an output that looks as follows:</p><pre>Leo Tolstoy wrote War and Peace
  I have not read this book
Herman Melville wrote Moby Dick
Herman Melville wrote Moby Dick
  I have read this book</pre></li>
			</ol>
			<p>In this exercise, we created and used an interface, a purely TypeScript construct. We used it to describe the shape of the objects we will use. Without actually creating any specific objects of that shape, we were able to use the full power of TypeScript's tooling and type inference to create a couple of functions that operate on the objects of the given shape.</p>
			<p>After that, we were able to actually create some objects that had the required shape (with and without making the declaration explicit). We were able to use both kinds of objects as parameters to our functions, and the results were in line with the interface we declared.</p>
			<p>This demonstrated how a simple addition of an interface made our code much safer to write and execute.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor033"/>Basic Types</h1>
			<p>Even though JavaScript is a loosely typed language, that does not mean that values do not have types. There are several primitive types that are available to the JavaScript developer. We can get the type of the value using the <code>typeof</code> operator, available both in JavaScript and TypeScript. Let's inspect some values and see what the results will be:</p>
			<pre>const value = 1234;
console.log(typeof value); </pre>
			<p>The execution of the preceding code will write the string <code>"number"</code> to the console. Now, consider another snippet:</p>
			<pre>const value = "textual value";
console.log(typeof value); </pre>
			<p>The preceding expression will write the string <code>"string"</code> to the console. Consider the following snippet:</p>
			<pre>const value = false;
console.log(typeof value); </pre>
			<p>This will write out <code>"boolean"</code> to the console.</p>
			<p>All of the preceding types are what are called "primitives." They are baked directly into the execution environment, whether that is a browser or a server-side application. We can always use them as needed. There is an additional primitive type that has only a single value, and that's the undefined type, whose only value is undefined. If we try to call <code>typeof</code> undefined, we will receive the string <code>"undefined"</code>. Other than the primitives, JavaScript and by extension TypeScript have two so-called "structural" types. Those are, respectively, objects, that is, custom-created pieces of code that contain data, and functions, that is, custom-created pieces of code that contain logic. This distinction between data and logic is not a clear-cut border, but it can be a useful approximation. For example, we can define an object with some properties using the object literal syntax:</p>
			<pre>const days = {
    "Monday": 1,
    "Tuesday": 2,
    "Wednesday": 3,
    "Thursday": 4,
    "Friday": 5,
    "Saturday": 6,
    "Sunday": 7,
}</pre>
			<p>Calling the <code>typeof</code> operator on the <code>days</code> object will return the string <code>"object"</code>. We can also use the <code>typeof</code> operator if we have an <code>add</code> function as we defined before:</p>
			<pre>function add (x, y) {
    return x + y;
}
console.log(typeof add);</pre>
			<p>This will display the string <code>"function"</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Recent versions of JavaScript added <code>bigint</code> and <code>symbol</code> as primitive types, but they won't be encountered outside of specific scenarios.</p>
			<h2 id="_idParaDest-29">Exercise 1.<a id="_idTextAnchor034"/>04: Examining typeof</h2>
			<p>In this exercise, we'll see how to use the <code>typeof</code> operator to determine the type of a value, and we will investigate the responses:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/uhJqN">https://packt.link/uhJqN</a>.</p>
			<ol>
				<li value="1">Create a new file called <code>type-test.ts</code>.</li>
				<li>In <code>type-test.ts</code>, define several variables with differing values:<pre>const daysInWeek = 7;
const name = "Ada Lovelace";
const isRaining = false;
const today = new Date();
const months = ["January", "February", "March"];
const notDefined = undefined;
const nothing = null;
const add = (x:number, y: number) =&gt; x + y;
const calculator = {
    add
}</pre></li>
				<li>Add all the variables into a containing array, using the array literal syntax:<pre>const everything = [daysInWeek, name, isRaining, today, months, notDefined, nothing, add, calculator];</pre></li>
				<li>Loop all the variables using a <code>for..of</code> loop, and for each value, call the <code>typeof</code> operator. Show the result on the console, along with the value itself:<pre>for (const something of everything) {
    const type = typeof something;
    console.log(something, type);
}</pre></li>
				<li>Save the file and run the following command in the folder:<pre>tsc type-test.ts</pre></li>
				<li>After the compilation is done, you will have a <code>type-test.js</code> file. Execute it in the <code>node</code> environment with the following command:<pre>node type-test.js</pre><p>You will see that the output is as follows:</p><pre>7 number
Ada Lovelace string
false boolean
2021-04-05T09:14:56.259Z object
[ 'January', 'February', 'March' ] object
undefined undefined
null object
[Function: add] function
{ add: [Function: add] } object</pre></li>
			</ol>
			<p>Note specifically the output from the <code>months</code> and <code>nothing. typeof</code> variables will return the string <code>"object"</code> both for arrays and the <code>null</code> value. Also note that the <code>calculator</code> variable is an object whose only property is actually a function; that is, we have an object whose piece of data is actually a piece of logic. This is possible because functions are first-class values in JavaScript and TypeScript, which means that we can manipulate them just like we would regular values.</p>
			<h2 id="_idParaDest-30"><a id="_idTextAnchor035"/>Strings</h2>
			<p>Wor<a id="_idTextAnchor036"/>ds and text are part of any application, just as they are part of everyday life. In JavaScript, they are represented by the <code>string</code> type. Unlike in other languages, such as C++ or Java, strings in JavaScripts are not treated as an array-like object that consists of smaller parts (characters). Instead, strings are a first-order citizen of JavaScript. In addition, JavaScript strings natively support Unicode, so we won't get any problems with characters with, for example, Cyrillic or Arabic script. Just like in JavaScript, to define a string in TypeScript, we can use single quotes (<code>'</code>) or double quotes (<code>"</code>). Of course, if we start the string with a single quote, we have to end it with a single quote, and vice versa. We can also use a special type of string definition, called <em class="italic">template strings</em>. These strings are delimited with the backtick character (<code>`</code>) and support two very important things for web development – newlines and embedded expressions. They are supported in all environments that support ES2015, but TypeScript is able to compile to any JavaScript target environment.</p>
			<p>Using embedded expressions and newlines inside a string enables us to generate nice HTML, because instead of string concatenation, we're able to use embedded expressions to have a much clearer view of the generated output. For example, if we had a <code>person</code> object with <code>firstName</code> and <code>lastName</code> properties, and we wanted to display a simple greeting inside a <code>&lt;div&gt;</code> tag, we would have to write code as follows:</p>
			<pre>const html = "&lt;div class=\"greeting\"&gt;\nHello, " + firstName + " " + lastName + "\n&lt;/div&gt;";</pre>
			<p>From this code (which can get much more complex), it's difficult to see what will actually be written and where. Using template strings transforms this into the following:</p>
			<pre>const html = `&lt;div class="greeting"&gt;
    Hello, ${firstName} ${lastName}
&lt;/div&gt;";</pre>
			<p>In order to output the <code>firstName</code> and <code>lastName</code> values, we have to surround them with brackets (<code>{}</code>), preceded by a dollar sign (<code>$</code>). We are not limited to variable names, but can have whole expressions, including the conditional operator (<code>?:</code>).</p>
			<h2 id="_idParaDest-31"><a id="_idTextAnchor037"/>Numbers</h2>
			<p>Numbers are an important aspect of the world. We use them to quantify everything around us. And, it's worth noting, that there are two quite different kinds of numbers that you encounter in your daily life – integers and real numbers. One distinguishing difference between the two kinds of numbers is that integers are numbers without any fractional part. These often result from counting things; for example, the number of people in town. On the other hand, real numbers can have a fractional component to them. For example, the weight or height of a person is often a real number. </p>
			<p>In most programming languages, these two types of numbers are represented with (at least) two different primitive types; for example, in C#, we have a type called <code>int</code> for integers and a type called <code>float</code> for real numbers.</p>
			<p>In JavaScript, and consequently in TypeScript, they are indeed the same primitive type. That primitive type is simply called <code>number</code>. Under the hood, it's a 64-bit floating-point number, fully implementing the IEEE 754 standard. This standard is specified for real numbers, and this leads to some weirdness that is specific to JavaScript. For example, in most environments, dividing by zero results in an error. In JavaScript and TypeScript, division by zero results in some special numbers such as <code>Infinity</code> or <code>NaN</code>. Additionally, there is no concept of integer division in JavaScript, as division is always done using real numbers.</p>
			<p>However, even if everything is stored as floating-point real numbers, JavaScript guarantees that all operations that can be done using only integer arithmetic will be done exactly. One famous example of this behavior is adding <code>0.1</code> to <code>0.2</code>. In all compliant JavaScript engines, we get the result <code>0.30000000000000004</code> because of the finite precision of the underlying type. What we are guaranteed is that we can never get a decimal result if we are adding integers. The engine makes sure that <code>1+1=2</code> with no decimal remainder. All integer operations are completely safe, but only if the results are within a specified range. JavaScript has a special constant defined (<code>Number.MAX_SAFE_INTEGER</code>) with a value of <code>9007199254740991</code> (with digit grouping, this is represented as <code>9.007.199.254.740.991</code>) over which we might get precision and rounding errors.</p>
			<h2 id="_idParaDest-32"><a id="_idTextAnchor038"/>Booleans</h2>
			<p>Booleans are one of the simplest, and also one of the most used and useful, primitive types. This datatype has exactly two values, <code>true</code> and <code>false</code>. The useful thing is that if a variable of this type does not have a certain value, well, then it automatically has the other, as that is the only other possible option. In theory, this is sound, but in JavaScript, there are a lot of possibilities for things to go wrong. Since it has no type information, it cannot guarantee that a certain variable actually holds a Boolean value, which means that we always have to be careful of our Boolean checks.</p>
			<p>TypeScript completely defines away this problem. Say we define a variable as a Boolean, using either a type annotation or type inference, as follows:</p>
			<pre>let isRead = false;</pre>
			<p>We can be absolutely sure that the variable will always have exactly one of the two possible values.</p>
			<h2 id="_idParaDest-33"><a id="_idTextAnchor039"/>Arrays</h2>
			<p>One of the reasons computers are popular, aside from accessing social networking sites and playing video games, is that they are able to run the same processing algorithm on a whole collection of values, as many times as needed, without getting bored or making any errors. In order to be able to do that, we need to somehow organize the data into a collection of similar values that we can access one at a time. In JavaScript, the primary mechanism for such processing is the array. JavaScript has an extremely simple interface for creating arrays using the array literal syntax. We just list the elements, surrounded by brackets (<code>[ ]</code>), and we have an array:</p>
			<pre>const numbers = [1, 2, 3, 4, 5];</pre>
			<p>We can access that array using an index:</p>
			<pre>console.log(numbers[3]) // writes out 4, as arrays in JavaScript are //…0-based
numbers[1] = 200; // the second element becomes 200</pre>
			<p>That makes it easy to use a <code>for</code> loop to go through the elements and process them all with a single piece of code:</p>
			<pre>for (let index = 0; index &lt; numbers.length; index += 1) {
    const element = numbers[index];
    console.log(`The element at index ${index} has a value of ${element}`);
}</pre>
			<p>We can also use a <code>for..of</code> loop to iterate through the values, and the following snippet will calculate the sum of all the numbers in the array:</p>
			<pre>let sum = 0;
for (const element of numbers) {
    sum += element;
}</pre>
			<p>As with anything in JavaScript, it has no mechanism to enforce that all the items in an array satisfy the "similarity" requirement we mentioned previously. So, there's nothing stopping us from adding a string, a Boolean, an object, or even a function to the array of numbers we have defined. All of these are valid JavaScript commands that will execute successfully:</p>
			<pre>numbers[1] = false;
numbers[2] = new Date();
numbers[3] = "three";
numbers[4] = function () { 
    console.log("I'm really not a number");
};</pre>
			<p>In almost all cases, it is not to our benefit to have an array with vastly different types as elements. The main benefit of arrays is that we can group similar items together and work with all of them with the same code. If we have different types, we lose that advantage, so we might as well not use an array at all.</p>
			<p>With TypeScript, we can restrict the type so that an array will only allow a single type of value for its elements. Arrays have something that is referred to as a <em class="italic">composite</em> or <em class="italic">generic</em> type. That means that when we are specifying the type of the array, we're specifying it indirectly, via another type. </p>
			<p>In this case, we define the type of the array through the type of the array's elements, for example, we can have an array whose elements will be numbers or an array whose elements will be strings. In TypeScript, we denote that by writing the type of the element and then appending brackets to the type name. So, if we needed our <code>numbers</code> array to only accept values whose type is <code>number</code>, we will denote that as follows:</p>
			<pre>let numbers: number[];</pre>
			<p>Even better, if we are initializing our array, we can omit the type annotation and let TypeScript infer the value:</p>
			<div><div><img src="img/B14508_01_12.jpg" alt="Figure 1.12: TypeScript inferring the type of the elements in the array&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.12: TypeScript inferring the type of the elements in the array</p>
			<p>As shown previously, TypeScript will not let us use the <code>push</code> method with a value whose type does not match the type of the elements, nor will it allow elements to be set to invalid values.</p>
			<p>Another, equivalent way to denote the type of the array is to use generic type syntax. In that case, we can use the <code>Array</code> type, with the type of the actual elements in angle brackets:</p>
			<pre>let numbers: Array&lt;number&gt;;</pre>
			<p>Generic classes and methods will be covered in detail in <em class="italic">Chapter 9, Generics and Conditional Types</em>.</p>
			<p>The benefit here is that we can be certain that if an array claims to have elements of a certain type, it will indeed have that kind of element, and we can process them without worrying that a bug introduced an incompatible element.</p>
			<h2 id="_idParaDest-34"><a id="_idTextAnchor040"/>Tuples</h2>
			<p>Another common usage of arrays in JavaScript is to group data – just like objects, but without the hassle (and benefit) of property names. We could, for example, instead of creating a <code>person</code> object create a <code>person</code> array where, by convention, we'll use the first element to hold the first name, the second element to hold the last name, and the third element to hold the age. We could define such an array using the following:</p>
			<pre>const person = ["Ada", "Lovelace", 36];
console.log(`First Name is: ${person[0]}`);
console.log(`Last Name is: ${person[1]}`);
console.log(`Age is: ${person[2]}`);</pre>
			<p>In this case, even as we are using the same structure – an array – we're not using it to group an unknown number of unrelated data of the same type, we're using it to group a known number of related data that can be of separate types. This kind of array is called a <em class="italic">tuple</em>. Once more, JavaScript has no mechanism to enforce the structure of a tuple, so in our code we can do lots of things that are syntactically valid, but nonsensical semantically. We could add a fourth element in the array, we can set the first element to be a number, the third to be a function, and so on.</p>
			<p class="Body-Text">With TypeScript, we can formally define the number and types of the data elements that we need inside a tuple, using syntax such as the following:</p>
			<pre>const person: [string, string, number] = ["Ada", "Lovelace", 36];</pre>
			<p>The <code>[string, string, number]</code> declaration tells TypeScript that we intend to use a tuple of three elements, that the first two elements will be a string, and the third will be a number. TypeScript now has enough information to enforce the structure. So, if we write code that will call the <code>toLowerCase</code> method on the first element of the tuple and multiply the third element by 10, that will work, as the first operation is valid on a string and the second is valid on a number:</p>
			<pre>console.log(person[0].toLowerCase());
console.log(person[2] * 10);</pre>
			<p>But if we try the operations the other way around, we'll get errors on both calls:</p>
			<div><div><img src="img/B14508_01_13.jpg" alt="Figure 1.13: TypeScript error when performing incorrect operations&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.13: TypeScript error when performing incorrect operations</p>
			<p>Additionally, if we try to access an element that is outside of the defined range, we'll get an error as well:</p>
			<div><div><img src="img/B14508_01_14.jpg" alt="Figure 1.14: TypeScript when accessing elements outside the defined range &#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.14: TypeScript when accessing elements outside the defined range </p>
			<h3 id="_idParaDest-35">Schwartzian t<a id="_idTextAnchor041"/>ransform </h3>
			<p>Arrays have a helpful sort function, which we can use to sort the objects contained in the array. However, during the sorting process, multiple comparisons will be done on the same objects. For example, if we sort an array of 100 numbers, the method that compares two numbers will be called more than 500 times, on average. Let's say that we have a <code>Person</code> interface, defined with the following:</p>
			<pre>interface Person {
    firstName: string;
    lastName: string;
}</pre>
			<p>If we want to get the full name of the person, we might use a function such as this:</p>
			<pre>function getFullName (person: Person) {
    return `${person.firstName} ${person.lastName}`;
}</pre>
			<p>If we have an array of <code>Person</code> objects, called <code>persons</code>, and want to sort it according to full name, we might use the following code:</p>
			<pre>persons.sort((first, second) =&gt; {
    const firstFullName = getFullName(first);
    const secondFullName = getFullName(second);
    return firstFullName.localeCompare(secondFullName);
})</pre>
			<p>This will sort the <code>persons</code> array, albeit in an inefficient manner. If we have 100 <code>Person</code> objects, this means that we have 100 different targets for the <code>getFullName</code> functions. But if we have more than 500 calls to the comparison function, that would mean that we have more than 1,000 calls to the <code>getFullName</code> function, so at least 900 calls are redundant. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">The relation gets worse: for 10,000 persons, we will have around a quarter of a million redundant calls.</p>
			<p>Our method is fast and trivial, but if some expensive calculations were needed, simple sorting could slow down our application.</p>
			<p>Fortunately, there's a simple technique called a Schwartzian transform that can help us with that. The technique has three parts:</p>
			<ul>
				<li>We will transform each element in the array into a tuple of two elements. The first element of the tuple will be the original value, and the second will be the result of the ordering function (colloquially, the Schwartz).</li>
				<li>We will sort the array on the second element of the tuple.</li>
				<li>We will transform each tuple, discarding the ordering element and taking the original value.</li>
			</ul>
			<p>We will employ this technique in the following exercise.</p>
			<h2 id="_idParaDest-36"><a id="_idTextAnchor042"/>Exercise 1.05: Using Arrays and Tuples to Create an Efficient Sort of Objects</h2>
			<p>In this exercise, we are going to employ the Schwartzian transform to sort and print a predefined array of programmers. Each programmer object will be an instance of the <code>Person</code> interface, defined in the previous section.</p>
			<p>We'll want to sort the programmers based on their full name, which can be calculated using the <code>getFullName</code> function, also from the previous section.</p>
			<p>In order to implement a Schwartzian transform, we'll take the following steps:</p>
			<p>We'll use the <code>map</code> method of the array in order to transform our programmers into a tuple of the <code>[Person, string]</code> type, where the first element is the actual programmer and the second element is the full name string.</p>
			<p>We'll use the <code>sort</code> method of the array to sort the tuples, using the second element of each tuple.</p>
			<p>We'll use the <code>map</code> method once more to transform the tuples back to an array of programmers by just taking the first element and discarding the second element.</p>
			<p>Let's start:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/EgZnX">https://packt.link/EgZnX</a>.</p>
			<ol>
				<li value="1">Create a new file called <code>person-sort.ts</code>.</li>
				<li>Inside the file, create the interface for the <code>Person</code> objects:<pre>interface Person {
    firstName: string;
    lastName: string;
}</pre></li>
				<li>Create the function that will get the full name of a given person:<pre>let count = 0;
function getFullName (person: Person) {
    count += 1;
    return `${person.firstName} ${person.lastName}`;
}</pre><p>We will use the <code>count</code> variable to detect the total number of calls of the function.</p></li>
				<li>Define an array of persons and add a few objects with <code>firstName</code> and <code>lastName</code> properties:<pre>const programmers: Person[] = [
    { firstName: 'Donald', lastName: 'Knuth'},
    { firstName: 'Barbara', lastName: 'Liskow'},
    { firstName: 'Lars', lastName: 'Bak'},
    { firstName: 'Guido', lastName: 'Van Rossum'},
    { firstName: 'Anders', lastName: 'Hejslberg'},
    { firstName: 'Edsger', lastName: 'Dijkstra'},
    { firstName: 'Brandon', lastName: 'Eich'},
    // feel free to add as many as you want
];</pre></li>
				<li>Define a naïve and straight forward sorting function:<pre>// a naive and straightforward sorting function
function naiveSortPersons (persons: Person[]): Person[] {
    return persons.slice().sort((first, second) =&gt; {
        const firstFullName = getFullName(first);
        const secondFullName = getFullName(second);
        return firstFullName.localeCompare(secondFullName);
    })
}</pre></li>
				<li>Use a Schwartzian transform and define a function that will take an array of persons and return (a sorted) array of persons:<pre>function schwartzSortPersons (persons: Person[]): Person[] {</pre></li>
				<li>Use the array's <code>map</code> function to transform each element into a tuple:<pre>    const tuples: [Person, string][] = persons.map(person =&gt; [person, getFullName(person)]);</pre></li>
				<li>Sort the <code>tuples</code> array of tuples, using the standard <code>sort</code> method:<pre>    tuples.sort((first, second) =&gt; first[1].localeCompare(second[1]));</pre><p>We should note that the <code>sort</code> function takes two objects, in our case, two tuples, and we sort the tuples according to their second element – the result of the <code>getFullName</code> call.</p></li>
				<li>Transform the sorted array of tuples into the format we want – just an array of <code>person</code> objects – by taking the first element of each tuple, discarding the Schwartz:<pre>    const result = tuples.map(tuple =&gt; tuple[0]);</pre></li>
				<li>The last three steps are the three parts of the Schwartzian transform.</li>
				<li>Return the new array from the function:<pre>    return result;
}</pre></li>
				<li>Add a line that will call the <code>naiveSortPersons</code> function on our defined array:<pre>count = 0;
const sortedNaive = naiveSortPersons(programmers);</pre></li>
				<li>Output both the sorted array, and the count variable.<pre>console.log(sortedNaive);
console.log(`When called using the naive approach, the function was called ${count} times`);</pre></li>
				<li>Add a line that will call the <code>schwartzSortPersons</code> function on our defined array:<pre>count = 0;
const sortedSchwartz = schwartzSortPersons(programmers); </pre></li>
				<li>Output both the <code>sorted</code> array and the <code>count</code> variable. The <code>count</code> variable should be identical to the number of items in the array, which is 7 in our example. Without the optimization, the method would have been called 28 times:<pre>console.log(sortedSchwartz);
console.log(`When called using the Schwartzian transform approach, the function was called ${count} times`); </pre></li>
				<li>Save and compile the file:<pre>tsc person-sort.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>person-sort.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with the following command:<pre>node person-sort.js</pre><p>You will see an output that looks as follows:</p><pre>[
  { firstName: 'Anders', lastName: 'Hejslberg' },
  { firstName: 'Barbara', lastName: 'Liskow' },
  { firstName: 'Brandon', lastName: 'Eich' },
  { firstName: 'Donald', lastName: 'Knuth' },
  { firstName: 'Edsger', lastName: 'Dijkstra' },
  { firstName: 'Guido', lastName: 'Van Rossum' },
  { firstName: 'Lars', lastName: 'Bak' }
]
When called using the naive approach, the function was called 28 times
[
  { firstName: 'Anders', lastName: 'Hejslberg' },
  { firstName: 'Barbara', lastName: 'Liskow' },
  { firstName: 'Brandon', lastName: 'Eich' },
  { firstName: 'Donald', lastName: 'Knuth' },
  { firstName: 'Edsger', lastName: 'Dijkstra' },
  { firstName: 'Guido', lastName: 'Van Rossum' },
  { firstName: 'Lars', lastName: 'Bak' }
]
When called using the Schwartzian transform approach, the function was called 7 times </pre></li>
			</ol>
			<p>We can easily <a id="_idTextAnchor043"/>check that the values that are outputted are sorted according to their full names. We can also notice a 7 at the end of output – that's the total number of calls of the <code>getFullName</code> function. Since we have 7 items in the programmers array, we can conclude that the function was called just once for each object.</p>
			<p>We could have instead sorted the programmers array directly, using code such as the following:</p>
			<pre>programmers.sort((first, second) =&gt; {
    const firstFullName = getFullName(first);
    const secondFullName = getFullName(second);
    return firstFullName.localeCompare(secondFullName);
});
console.log(count);</pre>
			<p>In this case, for this array, the count of execution of the <code>getFullName</code> function would have been 28, which is four times as high as our optimized version.</p>
			<h2 id="_idParaDest-37"><a id="_idTextAnchor044"/>Enums</h2>
			<p>Often we have some types that have a predefined set of values, and no other value is valid. For example, there are four and only four cardinal directions (East, West, North, and South). There are four and only four different suits in a deck of cards. So, how do we define a variable that should have such a value?</p>
			<p>In TypeScript, we can use an <code>enum</code> type to do that. The simplest way to define an enum would be as follows:</p>
			<pre>enum Suit {
    Hearts,
    Diamonds,
    Clubs,
    Spades
}</pre>
			<p>We can then define and use a variable of such type, and TypeScript will help us use it:</p>
			<pre>let trumpSuit = Suit.Hears;</pre>
			<p>TypeScript will infer that the type of the <code>trumpSuit</code> variable is <code>Suit</code> and will only allow us to access those four values. Any attempt to assign something else to the variable will result in an error:</p>
			<div><div><img src="img/B14508_01_15.jpg" alt="Figure 1.15: TypeScript inferring the type of trumpSuit&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.15: TypeScript inferring the type of trumpSuit</p>
			<p>So far, all the types we've encountered were JavaScript types that were augmented with TypeScript. Unlike that, enums are specific to TypeScript. Under the hood, the <code>Suit</code> class actually compiles into an object with values like this:</p>
			<pre>{
  '0': 'Hearts',
  '1': 'Diamonds',
  '2': 'Clubs',
  '3': 'Spades',
  Hearts: 0,
  Diamonds: 1,
  Clubs: 2,
  Spades: 3
}</pre>
			<p>TypeScript will automatically assign numbers starting with zero to the options provided and add a reverse mapping as well, so if we have the option, we can get the value, but if we have the value, we can map to the option as well. We can also explicitly set the provided numbers as well:</p>
			<pre>enum Suit {
    Hearts = 10,
    Diamonds = 20,
    Clubs = 30,
    Spades = 40
}</pre>
			<p>We can also use strings instead of numbers, with syntax like this:</p>
			<pre>enum Suit {
    Hearts = "hearts",
    Diamonds = "diamonds",
    Clubs = "clubs",
    Spades = "spades"
}</pre>
			<p>These enums are called string-based enums, and they compile to an object like this:</p>
			<pre>{
  Hearts: 'hearts',
  Diamonds: 'diamonds',
  Clubs: 'clubs',
  Spades: 'spades'
}</pre>
			<h2 id="_idParaDest-38">Any and Unknown<a id="_idTextAnchor045"/></h2>
			<p>So far, we have explained how TypeScript inference works, and how powerful it is. But sometimes we actually want to have JavaScript's "anything goes" behavior. For example, what if we genuinely need a variable that will sometimes hold a string and sometimes hold a number? The following code will issue an error because we're trying to assign a string to a variable that TypeScript inferred to be a number:</p>
			<pre>let variable = 3;
if (Math.random()&gt;0.5) {
    variable = "not-a-number";
}</pre>
			<p>This is how the code will appear on VS Code with the error message:</p>
			<div><div><img src="img/B14508_01_16.jpg" alt="Figure 1.16: TypeScript inferring the type of variable&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.16: TypeScript inferring the type of variable</p>
			<p>What we need to do is somehow suspend the type inference for that specific variable. To be able to do that, TypeScript provides us with the <code>any</code> type:</p>
			<pre>let variable: any = 3;
if (Math.random()&gt;0.5) {
    variable = "not-a-number";
}</pre>
			<p>This type annotation reverts the <code>variable</code> variable to the default JavaScript behavior, so none of the calls involving that variable will be checked by the compiler. Additionally, most calls that include a variable of the <code>any</code> type will infer a result of the same type. This means that the <code>any</code> type is highly contagious, and even if we define it in a single place in our application, it can propagate to lots of places.</p>
			<p>Since using <code>any</code> effectively negates most of TypeScript's benefits, it's best used as seldom as possible, and only when absolutely necessary. It's a powerful tool to use the opt-in/opt-out design of TypeScript so that we can gradually upgrade existing JavaScript code into TypeScript.</p>
			<p>One scenario that is sometimes used is a combination of the dynamic nature of <code>any</code> and the static nature of TypeScript – we can have an array where the elements can be anything:</p>
			<pre>const everything: any[] = [ 1, false, "string"];</pre>
			<p>Starting from version 3.0, TypeScript also offers another type with dynamic semantics – the <code>unknown</code> type. While still dynamic, it's much more constricted in what can be done with it. For example, the following code will compile using <code>any</code>:</p>
			<pre>const variable: any = getSomeResult(); // a hypothetical function //with some return value we know nothing about
const str: string = variable;  // this works, as any might be a //string, and "anything goes";
variable.toLowerCase();        // we are allowed to call a method, //and we'll determine at runtime whether that's possible</pre>
			<p>On the other hand, the same code with an <code>unknown</code> type annotation results in the following:</p>
			<div><div><img src="img/B14508_01_17.jpg" alt="Figure 1.17: TypeScript compiler error message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.17: TypeScript compiler error message</p>
			<p>The <code>unknown</code> type basically flips the assertion and the burden of proof. With <code>any</code>, the flow is that, since we don't know that it's not a string, we can treat it as a string. With <code>unknown</code>, we don't know whether it's a string, so we can't treat it as a string. In order to do anything useful with an <code>unknown</code>, we need to explicitly test its value and determine our actions based on that:</p>
			<pre>const variable: unknown = getSomeResult(); // a hypothetical function with some return value we know nothing about
if (typeof variable === "string") {
    const str: string = variable; // valid, because we tested if the value inside `variable` actually has a type of string
    variable.toLowerCase();
}</pre>
			<h2 id="_idParaDest-39">Null and Undefine<a id="_idTextAnchor046"/>d</h2>
			<p>One of the specifics of JavaScript is that it has two separate values that signify that there isn't a value: <code>null</code> and <code>undefined</code>. The difference between the two is that <code>null</code> has to be specified explicitly – so if something is <code>null</code>, that is because someone set it to <code>null</code>. Meanwhile, if something has the value <code>undefined</code> usually it means that the value is not set at all. For example, let's look at a <code>person</code> object defined with the following:</p>
			<pre>const person = {
    firstName: "Ada",
    lastName: null
}</pre>
			<p>The value of the <code>lastName</code> property has been set to <code>null</code> explicitly. On the other hand, the <code>age</code> property is not set at all. So, if we print them out, we'll see that the <code>lastName</code> property has a value of <code>null</code>, while the <code>age</code> property has a value of <code>undefined</code>:</p>
			<pre>console.log(person.lastName);
console.log(person.age);</pre>
			<p>We should note that if we have some optional properties in an object, their default value will be <code>undefined</code>. Similarly, if we have optional parameters in a function, the default value of the argument will be <code>undefined</code> as well.</p>
			<h2 id="_idParaDest-40"><a id="_idTextAnchor047"/>Never</h2>
			<p>There is an<a id="_idTextAnchor048"/>other "not a value" type that's specific to TypeScript, and that is the special <code>never</code> type. This type represents a value that never occurs. For example, if we have a function where the end of the function is not reachable and has no return statements, its return type will be <code>never</code>. An example of such a function will be as follows:</p>
			<pre>function notReturning(): never {
    throw new Error("point of no return");
}
const value = notReturning();</pre>
			<p>The type of the <code>value</code> variable will be inferred as <code>never</code>. Another situation where <code>never</code> is useful is if we have a logical condition that cannot be <code>true</code>. As a simple example, let's look at this code:</p>
			<pre>const x = true;
if (x) {
    console.log(`x is true: ${x.toString()}`);
}</pre>
			<p>The conditional statement will always be <code>true</code>, so we will always see the text in the console. But if we add an <code>else</code> branch to this code, the value of <code>x</code> inside the branch cannot be <code>true</code> because we're in the <code>else</code> branch, but cannot be anything else because it was defined as <code>true</code>. So, the actual type is inferred to be <code>never</code>. Since <code>never</code> does not have any properties or methods, this branch will throw a compile error:</p>
			<div><div><img src="img/B14508_01_18.jpg" alt="Figure 1.18: Compiler error from using the never type&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.18: Compiler error from using the never type</p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor049"/>Function Types</h2>
			<p>The<a id="_idTextAnchor050"/> last built-in type in JavaScript that we'll take a look at is not really a piece of data – it's a piece of code. Since functions are first-order objects in JavaScript, they remain so in TypeScript as well. And just like the others, functions get types as well. The type of a function is a bit more complicated than the other types. In order to identify it, we need all the parameters and their types, as well as the return values and their types. Let's take a look at an <code>add</code> function defined with the following:</p>
			<pre>const add = function (x: number, y: number) {
    return x + y;
}</pre>
			<p>To fully describe the type of the function, we need to know that it is a function that takes a number as the first parameter and a number as the second parameter and returns a number. In TypeScript, we'll write this as <code>(x: number, y: number) =&gt; number</code>.</p>
			<h1 id="_idParaDest-42">Making Your Own Ty<a id="_idTextAnchor051"/>pes</h1>
			<p>Of course, aside from using the types that are already available in JavaScript, we can define our own types. We have several options for that. We can use the JavaScript <code>class</code> specification to declare our own classes, with properties and methods. A simple class can be defined with the following:</p>
			<pre>class Person {
    constructor(public firstName: string, public lastName: string, public age?: number) {
    }
    getFullName() {
        return `${this.firstName} ${this.lastName}`;
    }
}</pre>
			<p>We can create objects of this class and use methods on them:</p>
			<pre>const person = new Person("Ada", "Lovelace");
console.log(person.getFullName());</pre>
			<p>Another way to formalize our complex structures is to use an interface:</p>
			<pre>interface Person
{
    firstName: string;
    lastName: string;
    age?: string;
}</pre>
			<p>Unlike classes, which compile to JavaScript classes or constructor functions (depending on the compilation target), interfaces are a TypeScript-only construct. When compiling, they are checked statically, and then removed from the compiled code.</p>
			<p>Both classes and interfaces are useful if implementing a class hierarchy, as both constructs are suitable for extension and inheritance.</p>
			<p>Yet another way is to use type aliases, with the <code>type</code> keyword. We can basically put a name that we will use as a type alias to just about anything available in TypeScript. For example, if we want to have another name for the primitive <code>number</code> type, for example, <code>integer</code>, we can always do the following:</p>
			<pre>type integer = number;</pre>
			<p>If we want to give a name to a tuple, <code>[string, string, number?]</code>, that we use to store a person, we can alias that with the following:</p>
			<pre>type Person = [string, string, number?];</pre>
			<p>We can also use objects and functions in the definition of a type alias:</p>
			<pre>type Person = {
    firstName: string;
    lastName: string;
    age?: number;
}
type FilterFunction = (person: Person) =&gt; boolean;</pre>
			<p>We will go into more details and intricacies of the <code>class</code>, <code>interface</code>, and <code>type</code> keywords in <em class="italic">Chapter 4</em>, <em class="italic">Classes and Objects</em>, <em class="italic">Chapter 5</em>, <em class="italic">Interfaces and Inheritance</em>, and <em class="italic">Chapter 6</em>, <em class="italic">Advance Types</em>, respectively.</p>
			<h2 id="_idParaDest-43">Exercise 1.06: Mak<a id="_idTextAnchor052"/>ing a Calculator Function</h2>
			<p>In this exercise, we'll define a calculator function that will take the operands and the operation as parameters. We will design it so it is easy to extend it with additional operations and use that behavior to extend it:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/dKoCZ">https://packt.link/dKoCZ</a>.</p>
			<ol>
				<li value="1">Create a new file called <code>calculator.ts</code>.</li>
				<li>In <code>calculator.ts</code>, define an enum with all the operators that we want to support inside our code:<pre>enum Operator {
    Add = "add",
    Subtract = "subtract",
    Multiply = "multiply",
    Divide = "divide",
}</pre></li>
				<li>Define an empty (for now) <code>calculator</code> function that will be our main interface. The function should take three parameters: the two numbers that we want to operate on, as well as an operator:<pre>const calculator = function (first: number, second: number, op: Operator) {
}</pre></li>
				<li>Create a type alias for a function that does a calculation on two numbers. Such a function will take two numbers as parameters and return a single number:<pre>type Operation = (x: number, y: number) =&gt; number;</pre></li>
				<li>Create an empty array that can hold multiple tuples of the <code>[Operator, Operation]</code> type. This will be our dictionary, where we store all our methods:<pre>const operations: [Operator, Operation][] = [];</pre></li>
				<li>Create an <code>add</code> method that satisfies the <code>Operation</code> type (you don't need to explicitly reference it):<pre>const add = function (first: number, second: number) {
    return first + second;
};</pre></li>
				<li>Create a tuple of the <code>Operator.Add</code> value and the <code>add</code> function and add it to the <code>operations</code> array:<pre>operations.push([Operator.Add, add]);</pre></li>
				<li>Repeat <em class="italic">steps 6</em> and <em class="italic">7</em> for the subtraction, multiplication, and division functions:<pre>const subtract = function (first: number, second: number) {
    return first - second;
};
operations.push([Operator.Subtract, subtract]);
const multiply = function (first: number, second: number) {
    return first * second;
};
operations.push([Operator.Multiply, multiply]);
const divide = function (first: number, second: number) {
    return first / second;
};
operations.push([Operator.Divide, divide]);</pre></li>
				<li>Implement the <code>calculator</code> function, using the <code>operations</code> array to find the correct tuple by the <code>Operator</code> provided, and then using the corresponding <code>Operation</code> value to do the calculation:<pre>const calculator = function (first: number, second: number, op: Operator) {
    const tuple = operations.find(tpl =&gt; tpl[0] === op);
    const operation = tuple[1];
    const result = operation(first, second);
    return result;
}</pre><p>Note that, as long as a function has the required type, that is, it takes two numbers and outputs a number, we can use it as an operation.</p></li>
				<li>Let's take the calculator for a test run. Write some code that will call the <code>calculator</code> function with different arguments:<pre>console.log(calculator(4, 6, Operator.Add));
console.log(calculator(13, 3, Operator.Subtract));
console.log(calculator(2, 5, Operator.Multiply));
console.log(calculator(70, 7, Operator.Divide));</pre></li>
				<li>Save the file and run the following command in the folder:<pre>tsc calculator.ts</pre></li>
				<li>Verify that the compilation ended successfully and that there is a <code>calculator.js</code> file generated in the same folder. Execute it in the <code>node</code> environment with the following command:<pre>node calculator.js</pre><p>You will see the output looks as follows:</p><pre>10
10
10
10</pre></li>
				<li>Now, let's try to extend our calculator by adding a modulo operation. First, we need to add that option to the <code>Operator</code> enum:<pre>enum Operator {
    Add = "add",
    Subtract = "subtract",
    Multiply = "multiply",
    Divide = "divide",
    Modulo = "modulo"
}</pre></li>
				<li>Add a function called <code>modulo</code> of the <code>Operation</code> type, and add a corresponding tuple to the <code>operations</code> array:<pre>const modulo = function (first: number, second: number) {
    return first % second;
};
operations.push([Operator.Modulo, modulo]);</pre></li>
				<li>At the end of the file, add a call to the <code>calculator</code> function that uses the <code>Modulo</code> operator:<pre>console.log(calculator(14, 3, Operator.Modulo));</pre></li>
				<li>Save and compile the file and run the resulting JavaScript with the following command:<pre>node calculator.js</pre><p>You will see an output that looks as follows:</p><pre>10
10
10
10
2</pre></li>
			</ol>
			<p>Note that when we extended our calculator with the modulo function, we did not change the <code>calculator</code> function at all. In this exercise, we saw how we can use the tuples, arrays, and function types to effectively design an extensible system.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor053"/>Activity 1.01: Cre<a id="_idTextAnchor054"/>ating a Library for Working with Strings</h2>
			<p>Your task is to create a series of simple functions that will help you do some common operations on strings. Some of the operations are already supported in the standard JavaScript library, but you will use them as a convenient learning exercise, both of JavaScript internals and TypeScript as a language. Our library will have the following functions:</p>
			<ol>
				<li value="1"><code>toTitleCase</code>: This will process a string and will capitalize the first letter of each word but will make all the other letters lowercase.<p>Test cases for this function are as follows:</p><pre>"war AND peace" =&gt; "War And Peace"
"Catcher in the Rye" =&gt; "Catcher In The Rye"
"tO kILL A mOCKINGBIRD" =&gt; "To Kill A MockingBird"</pre></li>
				<li><code>countWords</code>: This will count the number of separate words within a string. Words are delimited by spaces, dashes (<code>-</code>), or underscores (<code>_</code>).<p>Test cases for this function are as follows:</p><pre>"War and Peace" =&gt; 3 
"catcher-in-the-rye" =&gt; 4 
"for_whom the-bell-tolls" =&gt; 5</pre></li>
				<li><code>toWords</code>: This will return all the words that are within a string. Words are delimited by spaces, dashes (<code>-</code>), or underscores (<code>_</code>).<p>Test cases for this function are as follows:</p><pre>"War and Peace" =&gt; [War, and, peace] 
"catcher-in-the-rye" =&gt; [catcher, in, the, rye] 
"for_whom the-bell-tolls"=&gt; [for, whom, the, bell, tolls]</pre></li>
				<li><code>repeat</code>: This will take a string and a number and return that same string repeated that number of times.<p>Test cases for this function are as follows:</p><pre>"War", 3 =&gt; "WarWarWar" 
"rye", 1 =&gt; "rye"
"bell", 0 =&gt; ""</pre></li>
				<li><code>isAlpha</code>: This will return <code>true</code> if the string only has alpha characters (that is, letters). Test cases for this function are as follows:<pre>"War and Peace" =&gt; false 
"Atonement" =&gt; true 
"1Q84" =&gt; false</pre></li>
				<li><code>isBlank</code>: This will return <code>true</code> if the string is blank, that is, consists only of whitespace characters.<p>Test cases for this function are as follows:</p><pre>"War and Peace" =&gt; false 
"         " =&gt; true 
"" =&gt; true</pre><p>When writing the functions, make sure to think of the types of the parameters and the types of the return values.</p><p class="callout-heading">Note</p><p class="callout">The code files for this activity can be found here: <a href="https://packt.link/TOZuy">https://packt.link/TOZuy</a>.</p></li>
			</ol>
			<p>Here are some steps to help you create the preceding functions (note that there are multiple ways to implement each of the functions, so treat these steps as suggestions):</p>
			<ol>
				<li value="1">Creating the <code>toTitleCase</code> function: In order to change each word, we'll need first to get all the words. You can use the <code>split</code> function to make a single string into an array of words. Next, we'll need to <code>slice</code> off the first letter from the rest of the word. We can use the <code>toLowerCase</code> and <code>toUpperCase</code> methods to make something lower- and uppercase, respectively. After we get all the words properly cased, we can use the <code>join</code> array method to make an array of strings into a single large string. </li>
				<li>Creating the <code>countWords</code> function: In order to get the words, we can split the original string on any occurrence of any of the three delimiters ( <code>" "</code>, <code>"_"</code>, and <code>"-"</code>). Fortunately, the <code>split</code> function can take a regular expression as a parameter, which we can use to our benefit. Once we have the words in an array, we just need to count the elements.</li>
				<li>Creating the <code>towards</code> function: This method can use the same approach as the preceding one. Instead of counting the words, we'll just need to return them. Take note of the return type of this method.</li>
				<li>Creating the <code>repeat</code> function: Create an array with the required length (using the <code>Array</code> constructor), and set each element to the input value (using the array's <code>fill</code> method). After that, you can use the <code>join</code> method of the array to join the values into a single long string.</li>
				<li>Creating the <code>isAlpha</code> function: We can design a regular expression that will test this, but we can also split the string into single characters, using the string <code>split</code> method. Once we have the character array, we can use the map function to transform all the characters to lowercase. We can then use the filter method to return only those characters that are not between "a" and "z". If we don't have such characters, then the input only has letters, so we should return true. Otherwise, we should return false.</li>
				<li>Creating the <code>isBlank</code> function: One way to create such a function is to repeatedly test whether the first character is empty, and if it is, to remove it (a <code>while</code> loop works best for this). That loop will break either on the first non-blank characters or when it runs out of the first elements, that is, when the input is empty. In the first case, the string is not blank, so we should return <code>false</code>; otherwise, we should return <code>true</code>.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor375">this link</a><code>.</code></p></li>
			</ol>
			<h1 id="_idParaDest-45"><a id="_idTextAnchor055"/>Summary</h1>
			<p>In this ch<a id="_idTextAnchor056"/>apter, we looked at the world before TypeScript and described the problems and issues that TypeScript was actually designed to solve. We had a brief overview of how TypeScript operates under the hood, got ourselves introduced to the <code>tsc</code> compiler, and learned how we can control it using the <code>tsconfig.json</code> file.</p>
			<p>We familiarized ourselves with the differences between TypeScript and JavaScript and saw how TypeScript infers the types from the values that we provide. We learned how different primitive types are treated in TypeScript, and finally, we learned how to create our own types to structure the building blocks of a large-scale, enterprise-level web application. Equipped with the fundamentals, you are now in a position to delve further into TypeScript, with the next chapter teaching you about declaration files.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>