<html><head></head><body><div><div><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Getting into Shape</h1></div></div></div><p>In this chapter, we will cover:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Creating simple shapes</li><li class="listitem" style="list-style-type: disc">Using a line generator</li><li class="listitem" style="list-style-type: disc">Using line curve</li><li class="listitem" style="list-style-type: disc">Changing line tension</li><li class="listitem" style="list-style-type: disc">Using an area generator</li><li class="listitem" style="list-style-type: disc">Using area curve</li><li class="listitem" style="list-style-type: disc">Using an arc generator</li><li class="listitem" style="list-style-type: disc">Implementing arc transition</li></ul></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec49"/>Introduction</h1></div></div></div><p>
<strong>Scalable Vector Graphics</strong> (<strong>SVG</strong>) is a mature <strong>World Wide Web Consortium</strong> (<strong>W3C</strong>) standard designed for user-interactive graphics on the Web and Mobile platform. Similar to HTML, SVG can coexist happily with other technologies, such as CSS and JavaScript, in modern browsers and forms the backbone of many Web applications. In today's Web, you can see use cases of SVG everywhere, from digital map to data visualization. So far, in this book, we covered most of the recipes using HTML elements alone; however, in real-world projects, SVG is the <em>de facto</em> standard for data visualization; it is also where D3's strength really shines. In this chapter, we will cover the basic concept of SVG and D3's support for SVG shape generation. SVG is a very rich topic. Volumes of books can be, and have been, devoted to this topic alone; hence, we will not plan or even try to cover all SVG-related topics, rather we'll focus on D3 and data visualization-related techniques and features.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec133"/>What is SVG?</h2></div></div></div><p>As its name suggests, SVG is about graphics. It is a way to describe graphical image with scalable vectors. Let's take a look at the following two of the main SVG advantages:</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec10"/>Vector</h3></div></div></div><p>SVG image is based on vectors instead of pixels. With the pixel-based approach, an image is composed of a bitmap with <em>x</em> and <em>y</em> as its coordinates filled with color pigmentations. Whereas, with the vector-based approach, each image consists of a set of geometric shapes described using simple and relative formulae filled with certain texture. As you can imagine, this latter approach fits naturally with our data visualization requirement. It is much simpler to visualize your data with lines, bar, and circles in SVG rather than trying to manipulate color pigmentations in a bitmap.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec11"/>Scalability</h3></div></div></div><p>The second signature capability of SVG is scalability. Since SVG graphic is a group of geometric shapes described using relative formulas, it can be rendered and re-rendered</p><p>with different sizes and zoom levels without losing precision. On the other hand, when</p><p>bitmap-based images are resized to a large resolution, they suffer the effect of pixelation, which occurs when the individual pixels become visible, while SVG does not have this drawback. Refer to the following figure to get a better picture of what we just read:</p><p>
</p><div><img src="img/image_07_001.jpg" alt="Scalability"/></div><p>
</p><p>SVG versus bitmap pixelation</p><p>As a data visualizer, using SVG gives you the benefit of being able to display your visualization on any resolution without losing the crispiness of your eye-catching creation. On top of that, SVG offers you some additional advantages such as the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Readability</strong>: SVG is based on XML, a human-readable markup language.</li><li class="listitem" style="list-style-type: disc"><strong>Open standard</strong>: SVG was created by W3C and is not a proprietary vendor standard.</li><li class="listitem" style="list-style-type: disc"><strong>Adoption</strong>: All modern browsers support SVG standard, even on mobile platform.</li><li class="listitem" style="list-style-type: disc"><strong>Interoperability</strong>: SVG works well with other Web technologies, such as CSS and JavaScript; D3 itself is a perfect demonstration of this capability.</li><li class="listitem" style="list-style-type: disc"><strong>Lightweight</strong>: Compared to bitmap-based images, SVG is a lot lighter and takes up much less space.</li></ul></div><p>Because of all these capabilities we have mentioned so far, SVG has become the <em>de facto</em> standard for data visualization on the Web. From this chapter onward, all recipes in this book will be illustrated using SVG as its most important part, with which the true power of D3 can be professed.</p><div><div><h3 class="title"><a id="note67"/>Note</h3><p>Some older browsers do not support SVG natively. If your target users are using legacy browsers, please check the SVG compatibility before deciding whether SVG is the right choice for your visualization project. Here is a link that you can visit to check your browser's compatibility:
<a class="ulink" href="http://caniuse.com/#feat=svg">http://caniuse.com/#feat=svg
</a>
</p></div></div></div></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Creating simple shapes</h1></div></div></div><p>In this recipe, we will explore a few simple built-in SVG shape formulas and their attributes. These simple shapes are quite easy to generate and are usually created manually using D3 when necessary. Though these simple shapes are not the most useful shape generator to know when working with D3, occasionally, they could be handy when drawing peripheral shapes in your visualization project.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec134"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/simple-shapes.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/simple-shapes.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec135"/>How to do it...</h2></div></div></div><p>In this recipe, we will draw four different shapes in four different colors using native SVG shape elements:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 600, 
        height = 500; 
 
    var svg = d3.select("body").append("svg"); 
 
    svg.attr("height", height) 
        .attr("width", width);     
 
    svg.append("line") // &lt;-A 
        .attr("x1", 0) 
        .attr("y1", 200) 
        .attr("x2", 100) 
        .attr("y2", 100); 
 
    svg.append("circle") // &lt;-B 
        .attr("cx", 200) 
        .attr("cy", 150) 
        .attr("r", 50); 
 
    svg.append("rect") 
        .attr("x", 300) // &lt;-C 
        .attr("y", 100) 
        .attr("width", 100) // &lt;-D 
        .attr("height", 100) 
        .attr("rx", 5); // &lt;-E 
 
    svg.append("polygon") 
        .attr("points", "450,200 500,100 550,200"); // &lt;-F 
&lt;/script&gt; 
</pre><p>The preceding code generates the following visual output:</p><p>
</p><div><img src="img/image_07_002.jpg" alt="How to do it..."/></div><p>
</p><p>Simple SVG shapes</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec136"/>How it works...</h2></div></div></div><p>We have drawn four different shapes-a line, a circle, a rectangle, and a triangle-in this example using SVG built-in shape elements, which can be described as follows:</p><div><div><h3 class="title"><a id="tip68"/>Tip</h3><p>
<strong>A little refresher on SVG coordinate system</strong>
SVG <em>x</em> and <em>y</em> coordinate system originates from the top-left corner <code class="literal">(0, 0)</code> of the canvas and ends on the lower-right corner <code class="literal">(&lt;width&gt;, &lt;height&gt;)</code>.</p></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">line</code>: A line element creates a simple straight line with coordinate attributes <code class="literal">x1</code> and <code class="literal">y1</code> as its start point and <code class="literal">x2</code>, <code class="literal">y2</code> as its endpoint (refer to line <code class="literal">A</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">circle</code>: The <code class="literal">append()</code> function draws a circle with coordinate attributes <code class="literal">cx</code> and <code class="literal">cy</code> defining the center of the circle, whereas the attribute <code class="literal">r</code> defines the radius of the circle (refer to line <code class="literal">B</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">rect</code>: The <code class="literal">append()</code> function draws a rectangle with coordinate attributes <code class="literal">x</code> and <code class="literal">y</code> that define the top-left corner of the rectangular (refer to line <code class="literal">C</code>), attributes <code class="literal">width</code> and <code class="literal">height</code> that control the size of the rectangle, and the attributes <code class="literal">rx</code> and <code class="literal">ry</code> that introduce rounded corners. The attributes <code class="literal">rx</code> and <code class="literal">ry</code> control the <em>x</em> and <em>y</em> axes radius of the ellipse used to round off the corners of the rectangle (refer to line <code class="literal">E</code>).</li><li class="listitem" style="list-style-type: disc"><code class="literal">polygon</code>: To draw a polygon, a set of points that makes up the polygon need to be defined using a <code class="literal">points</code> attribute (refer to line <code class="literal">F</code>). The <code class="literal">points</code> attribute accepts a list of point coordinates that are separated by space, as shown in the following code snippet:</li></ul></div><pre class="programlisting">    svg.append("polygon") 
        .attr("points", "450,200 500,100 550,200"); // &lt;-F 
</pre><p>All SVG shapes can be styled using style attributes directly or through CSS similar to HTML elements. Furthermore, they can be transformed and filtered using SVG transformation and filter support; however, due to the limited scope of this book, we will not cover these topics in detail. In the rest of this chapter, we will focus on D3-specific supports on SVG shape generation instead.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec137"/>There's more...</h2></div></div></div><p>SVG also supports the <code class="literal">ellipse</code> and <code class="literal">polyline</code> elements; however, due to their similarity to <code class="literal">circle</code> and <code class="literal">polygon</code>, we will not cover them in detail in this book. For more information on SVG shape elements, please visit <a class="ulink" href="https://www.w3.org/TR/SVG/shapes.html">https://www.w3.org/TR/SVG/shapes.html
</a>.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec12"/>D3 SVG shape generators</h3></div></div></div><p>The <em>swiss army knife</em> among SVG shape elements is <code class="literal">svg:path</code>. A path defines the outline of any shape, which can then be filled, stroked, or clipped. Every shape we have discussed so far can be mathematically defined using <code class="literal">svg:path</code> alone. The SVG <code class="literal">path</code> is a very powerful construct and has its own mini-language and grammar. The <code class="literal">svg:path</code> mini-language is used to set the <code class="literal">d</code> attribute on an <code class="literal">svg:path</code> element, which consists of the following commands:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>moveto</strong>: M (absolute)/m (relative) moveto (x y)+</li><li class="listitem" style="list-style-type: disc"><strong>closepath</strong>: Z (absolute)/z (relative) closepath</li><li class="listitem" style="list-style-type: disc"><strong>lineto</strong>: L (absolute)/l (relative) lineto (x y)+, H (absolute)/h (relative) horizontal lineto x+, V(absolute)/v(relative) vertical lineto y+</li><li class="listitem" style="list-style-type: disc"><strong>Cubic Bezier</strong>: C(absolute)/c(relative) curve to (x1 y1 x2 y2 x y)+, S(absolute)/s(relative) shorthand curve to (x2 y2 x y)+</li><li class="listitem" style="list-style-type: disc"><strong>Quadratic Bezier curve</strong>: Q (absolute)/q (relative) quadratic Bezier curve to (x1 y1 x y)+, T (absolute)/t (relative) shorthand Quadratic Bezier curve to (x y)+</li><li class="listitem" style="list-style-type: disc"><strong>Elliptical curve</strong>: A (absolute)/a (relative) elliptical arc (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+</li></ul></div><p>As directly using paths is not a very pleasant method due to its cryptic language, in most cases, some kind of software, for example, Adobe Illustrator or Inkscape, is required to assist us in creating the SVG <code class="literal">path</code> element visually. Similarly, D3 ships with a set of SVG shape generator functions that can be used to generate data-driven path formulas; this is how D3 truly revolutionizes the field of data visualization by combining the power of SVG with intuitive data-driven approach. This will be our focus for the rest of this chapter.</p></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec138"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Please refer to <a class="ulink" href="https://www.w3.org/TR/SVG/Overview.html">https://www.w3.org/TR/SVG/Overview.html
</a> for more information on SVG-related topics</li><li class="listitem" style="list-style-type: disc">For a complete reference on SVG path formula language and its grammar, please visit <a class="ulink" href="https://www.w3.org/TR/SVG/paths.html">https://www.w3.org/TR/SVG/paths.html
</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Using a line generator</h1></div></div></div><p>D3 line generator is probably one of the most versatile generators. Although it is called a line generator, it has little to do with the <code class="literal">svg:line</code> element. In contrast, it is implemented using the <code class="literal">svg:path</code> element. Similar to <code class="literal">svg:path</code>, D3 <code class="literal">line</code> generator is so flexible that you can effectively draw any shape using <code class="literal">line</code> alone; however, to make your life easier, D3 also provides other more specialized shape generators, which will be covered in later recipes in this chapter. In this recipe, we will draw multiple data-driven lines using the <code class="literal">d3.svg.line</code> generator.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec139"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter7/line.html">https://github.com/NickQiZhu/d3-cookbook/blob/master/src/chapter7/line.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec140"/>How to do it...</h2></div></div></div><p>Now, let's take a look at the following line generator in action:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 500, 
        height = 500, 
        margin = 50, 
        x = d3.scaleLinear() // &lt;-A 
            .domain([0, 10]) 
            .range([margin, width - margin]), 
        y = d3.scaleLinear() // &lt;-B 
            .domain([0, 10]) 
            .range([height - margin, margin]); 
 
    var data = [ // &lt;-C 
        [ 
            {x: 0, y: 5},{x: 1, y: 9},{x: 2, y: 7}, 
            {x: 3, y: 5},{x: 4, y: 3},{x: 6, y: 4}, 
            {x: 7, y: 2},{x: 8, y: 3},{x: 9, y: 2} 
        ], 
 
        d3.range(10).map(function(i){ 
            return {x: i, y: Math.sin(i) + 5}; 
        }) 
    ]; 
 
var line = d3.line() // &lt;-D 
            .x(function(d){return x(d.x);}) 
            .y(function(d){return y(d.y);}); 
 
    var svg = d3.select("body").append("svg"); 
 
    svg.attr("height", height) 
        .attr("width", width); 
 
     svg.selectAll("path.line") 
            .data(data) 
        .enter() 
            .append("path") // &lt;-E 
            .attr("class", "line")             
            .attr("d", function(d){return line(d);}); // &lt;-F 
 
    // Axes related code omitted 
    ...         
&lt;/script&gt; 
</pre><p>The preceding code draws multiple lines along with the <em>x</em> and <em>y</em> axes:</p><p>
</p><div><img src="img/image_07_003.jpg" alt="How to do it..."/></div><p>
</p><p>D3 line generator</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec141"/>How it works...</h2></div></div></div><p>In this recipe, the data we used to draw the lines is defined in a two-dimensional array:</p><pre class="programlisting">var data = [ // &lt;-C 
        [ 
            {x: 0, y: 5},{x: 1, y: 9},{x: 2, y: 7}, 
            {x: 3, y: 5},{x: 4, y: 3},{x: 6, y: 4}, 
            {x: 7, y: 2},{x: 8, y: 3},{x: 9, y: 2} 
        ], 
 
        d3.range(10).map(function(i){ 
            return {x: i, y: Math.sin(i) + 5}; 
        }) 
]; 
</pre><p>The first data series is defined manually and explicitly, whereas the second series is generated using a mathematical formula. Both of these cases are quite common in data visualization projects. Once the data is defined, in order to map data points to their visual representation, the following two scales were created for the <em>x</em> and <em>y</em> coordinates:</p><p>x = d3.scaleLinear() // &lt;-A .domain([0, 10]) .range([margin, width - margin]), y = d3.scaleLinear() // &lt;-B .domain([0, 10]) .range([height - margin, margin]);</p><p>Note that the domains for these scales were set to be large enough to include all data points in both the series, while the ranges were set to represent the canvas area without including the margins. The <em>y</em> axis range is inverted since we want our point of origin at the lower-left corner of the canvas instead of the SVG-standard upper-left corner. Once both data and scales are set, all we need to do is generate the lines to define our generator using the <code class="literal">d3.line</code> function:</p><pre class="programlisting">var line = d3.line() // &lt;-D 
            .x(function(d){return x(d.x);}) 
            .y(function(d){return y(d.y);}); 
</pre><p>The <code class="literal">d3.line</code> function returns a D3 line generator function, which you can further customize. In our example, we simply stated for this particular line generator the <em>x</em> coordinate, which will be calculated using the <code class="literal">x</code> scale mapping, while the <em>y</em> coordinate will be mapped by the <code class="literal">y</code> scale. Using D3 scales, to map coordinates, is not only convenient but also a widely accepted best practice (separation of concerns). Though, technically, you can implement these functions using any approach you prefer. Now the only thing left for you to do is the actual creation of the <code class="literal">svg:path</code> elements as follows:</p><pre class="programlisting">svg.selectAll("path.line") 
            .data(data) 
        .enter() 
            .append("path") // &lt;-E 
            .attr("class", "line")             
            .attr("d", function(d){return line(d);}); // &lt;-F 
</pre><p>Path creation process in the preceding code was very straightforward. Two <code class="literal">svg:path</code> elements were created using the data array we defined (on line <code class="literal">E</code>). Then, the <code class="literal">d</code> attribute for each path element was set using the <code class="literal">line</code> generator we created previously by passing in the data <code class="literal">d</code> as its input parameter. The following screenshot shows what the generated <code class="literal">svg:path</code> elements look like:</p><p>
</p><div><img src="img/image_07_004.jpg" alt="How it works..."/></div><p>
</p><p>Generated SVG path elements</p><p>Finally, two axes were created using the same <em>x</em> and <em>y</em> scales we defined earlier. Due to limited space in this book, we have omitted the axes-related code in this recipe and in the rest of this chapter since they don't really change and also are not the focus of this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec142"/>See also</h2></div></div></div><p>For detailed information on D3 axes support, please refer to <a class="link" href="ch05.html" title="Chapter 5. Playing with Axes">Chapter 5</a>, <em>Playing with Axes</em>.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Using line curve</h1></div></div></div><p>By default, the D3 line generator uses the <em>linear curve</em> mode; however, D3 supports a number of different curve factories. The curve function determines how data points will be connected, for example, by a straight line (<em>linear</em>) or a curved line (<strong>B-spline</strong>). In this recipe, we will show you how these curve modes can be set along with their effects.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec143"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/line-curve.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/line-curve.html
</a>
</p><p>This recipe is built on top of what we did in the previous recipe, so if you are not</p><p>yet familiar with basic line generator functions, please refer to the previous recipe first</p><p>before proceeding.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec144"/>How to do it...</h2></div></div></div><p>Now, let's take a look at how different line interpolation modes can be used:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
var width = 500, 
        height = 500, 
        margin = 30, 
        x = d3.scaleLinear() 
            .domain([0, 10]) 
            .range([margin, width - margin]), 
        y = d3.scaleLinear() 
            .domain([0, 10]) 
            .range([height - margin, margin]); 
 
    var data = [ 
        [ 
            {x: 0, y: 5},{x: 1, y: 9},{x: 2, y: 7}, 
            {x: 3, y: 5},{x: 4, y: 3},{x: 6, y: 4}, 
            {x: 7, y: 2},{x: 8, y: 3},{x: 9, y: 2} 
        ], 
        d3.range(10).map(function(i){ 
            return {x: i, y: Math.sin(i) + 5}; 
        }) 
    ]; 
 
    var svg = d3.select("body").append("svg"); 
 
    svg.attr("height", height) 
        .attr("width", width); 
 
    renderAxes(svg); 
 
    render(d3.curveLinear); 
 
    renderDots(svg); 
 
    function render(mode){ 
        var line = d3.line() 
                .x(function(d){return x(d.x);}) 
                .y(function(d){return y(d.y);}) 
                .curve(mode); // &lt;-A 
 
        svg.selectAll("path.line") 
                .data(data) 
            .enter() 
                .append("path") 
                .attr("class", "line"); 
 
        svg.selectAll("path.line") 
                .data(data) 
            .attr("d", function(d){return line(d);}); 
    } 
 
    function renderDots(svg){ // &lt;-B 
        data.forEach(function(list){ 
             svg.append("g").selectAll("circle") 
                .data(list) 
              .enter().append("circle") // &lt;-C 
                .attr("class", "dot") 
                .attr("cx", function(d) { return x(d.x); }) 
                .attr("cy", function(d) { return y(d.y); }) 
                .attr("r", 4.5); 
        }); 
    } 
// Axes related code omitted 
... 
&lt;/script&gt; 
 
&lt;h4&gt;Interpolation Mode:&lt;/h4&gt; 
&lt;div class="control-group"&gt; 
&lt;button onclick="render(d3.curveLinear)"&gt;linear&lt;/button&gt; 
&lt;button onclick="render(d3.curveLinearClosed)"&gt;linear closed&lt;/button&gt; 
&lt;button onclick="render(d3.curveStepBefore)"&gt;step before&lt;/button&gt; 
&lt;button onclick="render(d3.curveStepAfter)"&gt;step after&lt;/button&gt; 
&lt;button onclick="render(d3.curveBasis)"&gt;basis&lt;/button&gt; 
&lt;button onclick="render(d3.curveBasisOpen)"&gt;basis open&lt;/button&gt; 
&lt;/div&gt; 
... 
 
</pre><p>The preceding code generates the following line chart in your browser with configurable interpolation modes:</p><p>
</p><div><img src="img/image_07_005.jpg" alt="How to do it..."/></div><p>
</p><p>Line curve</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec145"/>How it works...</h2></div></div></div><p>Overall, this recipe is similar to the previous one. Two lines are generated using predefined dataset. However, in this recipe, you will allow the user to select a specific line interpolation mode, which is then set using the <code class="literal">interpolate</code> function on line generator (refer to line <code class="literal">A</code>) in the following code snippet:</p><pre class="programlisting">var line = d3.line() 
                .x(function(d){return x(d.x);}) 
                .y(function(d){return y(d.y);}) 
                .curve(mode); // &lt;-A 
</pre><p>The following interpolation modes are supported by D3:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveLinear</code>: Linear segments, that is, polyline</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveLinearClosed</code>: Closed linear segments, that is, polygon</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveStepBefore</code>: Alternated between the vertical and horizontal segments, as in a step function</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveStepAfter</code>: Alternated between the horizontal and vertical segments, as in a step function</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveBasis</code>: It is a B-spline, with control point duplication on the ends</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveBasisOpen</code>: An open B-spline; may not intersect the start or end</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveBasisClosed</code>: A closed B-spline, as in a loop</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveBundle</code>: Equivalent to basis, except the tension parameter is used to straighten the spline</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveCardinal</code>: A cardinal spline, with control point duplication on the ends.</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveCardinalOpen</code>: An open cardinal spline; may not intersect the start or end, but will intersect other control points</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveCardinalClosed</code>: A closed cardinal spline, as in a loop</li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveMonotoneY</code>: Cubic interpolation that preserves monotonicity in <em>y</em></li><li class="listitem" style="list-style-type: disc"><code class="literal">d3.curveCatmullRom</code>: A cubic catmull-Rom spline.</li></ul></div><p>Additionally, in the <code class="literal">renderDots</code> function (refer to line <code class="literal">B</code>), we have also created a small circle for each data point to serve as reference points. These dots are created using the <code class="literal">svg:circle</code> elements, as shown on line <code class="literal">C</code> of the following code snippet:</p><pre class="programlisting">function renderDots(svg){ // &lt;-B 
        data.forEach(function(set){ 
             svg.append("g").selectAll("circle") 
                .data(set) 
              .enter().append("circle") // &lt;-C 
                .attr("class", "dot") 
                .attr("cx", function(d) { return x(d.x); }) 
                .attr("cy", function(d) { return y(d.y); }) 
                .attr("r", 4.5); 
        }); 
} 
</pre></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec146"/>See Also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For detailed listing and API document for all D3 curve factories, please refer to <a class="ulink" href="https://github.com/d3/d3-shape#curves">https://github.com/d3/d3-shape#curves
</a></li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Changing line tension</h1></div></div></div><p>If Cardinal interpolation mode (cardinal, cardinal-open, or cardinal-closed) is used, then the line can be further modified using tension settings. In this recipe, you will see how tension can be modified and its effect on line interpolation.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec147"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/line-tension.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/line-tension.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec148"/>How to do it...</h2></div></div></div><p>Now, let's take a look at how line tension can be changed and what effect it has on line generation:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 500, 
        height = 500, 
        margin = 30, 
        duration = 500,     
        x = d3.scaleLinear() 
            .domain([0, 10]) 
            .range([margin, width - margin]), 
        y = d3.scaleLinear() 
            .domain([0, 1]) 
            .range([height - margin, margin]); 
 
var data = d3.range(10).map(function(i){ 
            return {x: i, y: (Math.sin(i * 3) + 1) / 2}; 
        }); 
 
    var svg = d3.select("body").append("svg"); 
 
    svg.attr("height", height) 
        .attr("width", width); 
 
    renderAxes(svg); 
 
    render(1); 
 
    function render(tension){ 
        var line = d3.line() 
                .curve(d3.curveCardinal.tension(tension)) // &lt;-A 
                .x(function(d){return x(d.x);}) 
                .y(function(d){return y(d.y);}); 
 
        svg.selectAll("path.line") 
                .data([tension]) 
            .enter() 
                .append("path") 
                .attr("class", "line"); 
 
svg.selectAll("path.line") 
                .data([tension])  
            .transition().duration(duration) 
               .ease(d3.easeLinear) // &lt;-B 
            .attr("d", function(d){ 
                return line(data); // &lt;-C 
            }); 
 
        svg.selectAll("circle") 
            .data(data) 
          .enter().append("circle") 
            .attr("class", "dot") 
            .attr("cx", function(d) { return x(d.x); }) 
            .attr("cy", function(d) { return y(d.y); }) 
            .attr("r", 4.5); 
    } 
// Axes related code omitted 
    ... 
&lt;/script&gt; 
&lt;h4&gt;Line Tension:&lt;/h4&gt; 
&lt;div class="control-group"&gt; 
&lt;button onclick="render(0)"&gt;0&lt;/button&gt; 
&lt;button onclick="render(0.2)"&gt;0.2&lt;/button&gt; 
&lt;button onclick="render(0.4)"&gt;0.4&lt;/button&gt; 
&lt;button onclick="render(0.6)"&gt;0.6&lt;/button&gt; 
&lt;button onclick="render(0.8)"&gt;0.8&lt;/button&gt; 
&lt;button onclick="render(1)"&gt;1&lt;/button&gt; 
&lt;/div&gt; 
</pre><p>The preceding code generates a cardinal line chart with configurable tension:</p><p>
</p><div><img src="img/image_07_006.jpg" alt="How to do it..."/></div><p>
</p><p>Line Tension</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec149"/>How it works...</h2></div></div></div><p>Tension sets the Cardinal spline interpolation tension to a specific number in the range of <code class="literal">[0, 1]</code>. Tension can be set using the <code class="literal">tension</code> function on line generator (refer to line <code class="literal">C</code>):</p><pre class="programlisting">var line = d3.line() 
                .curve(d3.curveCardinal.tension(tension)) // &lt;-A  
                .x(function(d){return x(d.x);}) 
                .y(function(d){return y(d.y);}); 
</pre><p>Additionally, we also initiated a transition on line <code class="literal">B</code> to highlight the tension effect on line interpolation. The tension in cardinal curve essentially determines the length of the tangents. At tension one, it is the same as curve linear while at zero it produces uniform Catmull-Rom spline. If the tension is not set explicitly, Cardinal interpolation sets tension to <code class="literal">0</code> by default.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec54"/>Using an area generator</h1></div></div></div><p>Using D3 line generator, we can technically generate an outline of any shape; however, even with a different curve support, directly drawing an area using line (as in an area chart) is not an easy task. This is why D3 also provides a separate shape generator function specifically designed for drawing area.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec150"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/area.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/area.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec151"/>How to do it...</h2></div></div></div><p>In this recipe, we will add a filled area to a pseudo line chart, effectively turning it into an</p><p>area chart:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 500, 
        height = 500, 
        margin = 30, 
        duration = 500, 
        x = d3.scaleLinear() // &lt;-A 
            .domain([0, 10]) 
            .range([margin, width - margin]), 
        y = d3.scaleLinear() 
            .domain([0, 10]) 
            .range([height - margin, margin]); 
 
    var data = d3.range(11).map(function(i){ // &lt;-B 
            return {x: i, y: Math.sin(i)*3 + 5}; 
        }); 
 
    var svg = d3.select("body").append("svg"); 
 
    svg.attr("height", height) 
        .attr("width", width);         
 
    renderAxes(svg); 
 
    render();     
 
    renderDots(svg); 
 
    function render(){ 
        var line = d3.line() 
                .x(function(d){return x(d.x);}) 
                .y(function(d){return y(d.y);}); 
 
        svg.selectAll("path.line") 
                .data([data]) 
            .enter() 
                .append("path") 
                .attr("class", "line");                 
 
        svg.selectAll("path.line") 
                .data([data])        
            .attr("d", function(d){return line(d);});         
 
        var area = d3.area() // &lt;-C 
            .x(function(d) { return x(d.x); }) // &lt;-D 
            .y0(y(0)) // &lt;-E 
            .y1(function(d) { return y(d.y); }); // &lt;-F 
 
        svg.selectAll("path.area") // &lt;-G 
                .data([data]) 
            .enter() 
                .append("path") 
                .attr("class", "area") 
                .attr("d", function(d){return area(d);}); // &lt;-H 
    } 
 
    // Dots rendering code omitted 
 
    // Axes related code omitted 
    ... 
&lt;/script&gt; 
</pre><p>The preceding code generates the following visual output:</p><p>
</p><div><img src="img/image_07_007.jpg" alt="How to do it..."/></div><p>
</p><p>Area generator</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec152"/>How it works...</h2></div></div></div><p>Similar to the earlier given <em>Using a line generator</em> recipe, we have two scales defined in this recipe to map data to visual domain on <em>x</em> and <em>y</em> coordinates (refer to line A) as given in the following code snippet:</p><pre class="programlisting">        x = d3.scaleLinear() // &lt;-A 
            .domain([0, 10]) 
            .range([margin, width - margin]), 
        y = d3.scaleLinear() 
            .domain([0, 10]) 
            .range([height - margin, margin]); 
 
    var data = d3.range(11).map(function(i){ // &lt;-B 
            return {x: i, y: Math.sin(i)*3 + 5}; 
        }); 
</pre><p>On line <code class="literal">B</code>, data is generated by a mathematical formula. Area generator is then created using the <code class="literal">d3.area</code> function (refer to line <code class="literal">C</code>):</p><pre class="programlisting">var area = d3.area() // &lt;-C 
            .x(function(d) { return x(d.x); }) // &lt;-D 
            .y0(y(0)) // &lt;-E 
            .y1(function(d) { return y(d.y); }); // &lt;-F 
</pre><p>As you can see, D3 area generator is-similar to the line generator-designed to work in a 2D Cartesian coordinate system. The <code class="literal">x</code> function defines an accessor function for the <em>x</em> coordinate (refer to line <code class="literal">D</code>), which simply maps data to the visual coordinate using the <code class="literal">x</code> scale we defined earlier. For the <em>y</em> coordinate, we provided the area generator with two different accessors: one for the lower bound (<code class="literal">y0</code>) and the other for the higher bound (<code class="literal">y1</code>) coordinates. This is the crucial difference between area and line generator. D3 area generator supports higher and lower bound on both <em>x</em> and <em>y</em> axes (<code class="literal">x0</code>, <code class="literal">x1</code>, <code class="literal">y0</code>, <code class="literal">y1</code>) and supports the shorthand accessors (<code class="literal">x</code> and <code class="literal">y</code>) if the higher and lower bounds are the same. Once the area generator is defined, the method of creating an area is almost identical to the line generator:</p><pre class="programlisting">svg.selectAll("path.area") // &lt;-G 
                .data([data]) 
            .enter() 
                .append("path") 
                .attr("class", "area") 
                .attr("d", function(d){return area(d);}); // &lt;-H 
</pre><p>Area is also implemented using the <code class="literal">svg:path</code> element (refer to line <code class="literal">G</code>). D3 area generator is used to generate the <code class="literal">d</code> formula for the <code class="literal">svg:path</code> element on line <code class="literal">H</code> with data <code class="literal">d</code> as its input parameter.</p></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec55"/>Using area curve</h1></div></div></div><p>Similar to the D3 line generator, area generator also supports identical interpolation mode, and hence, it can be used in combination with the line generator in every mode.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec153"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/area-curve.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/area-curve.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec154"/>How to do it...</h2></div></div></div><p>In this recipe, we will show how interpolation mode can be configured on an area generator. This way, the matching interpolated area can then be created with its corresponding line:</p><pre class="programlisting">var width = 500, 
        height = 500, 
        margin = 30, 
        x = d3.scaleLinear() 
            .domain([0, 10]) 
            .range([margin, width - margin]), 
        y = d3.scaleLinear() 
            .domain([0, 10]) 
            .range([height - margin, margin]); 
 
    var data = d3.range(11).map(function(i){ 
        return {x: i, y: Math.sin(i)*3 + 5}; 
    }); 
 
    var svg = d3.select("body").append("svg"); 
 
    svg.attr("height", height) 
        .attr("width", width);         
 
    renderAxes(svg); 
 
    render(d3.curveLinear); 
 
    renderDots(svg); 
 
    function render(mode){ 
        var line = d3.line() 
                .x(function(d){return x(d.x);}) 
                .y(function(d){return y(d.y);}) 
                .curve(mode); // &lt;-A 
 
        svg.selectAll("path.line") 
                .data([data]) 
            .enter() 
                .append("path") 
                .attr("class", "line");                 
 
        svg.selectAll("path.line") 
                .data([data])        
            .attr("d", function(d){return line(d);});         
 
        var area = d3.area() 
            .x(function(d) { return x(d.x); }) 
            .y0(y(0)) 
            .y1(function(d) { return y(d.y); }) 
            .curve(mode); // &lt;-B 
 
        svg.selectAll("path.area") 
                .data([data]) 
            .enter() 
                .append("path") 
                .attr("class", "area") 
 
        svg.selectAll("path.area") 
            .data([data]) 
            .attr("d", function(d){return area(d);});         
    } 
// Dots and Axes related code omitted 
</pre><p>The preceding code generates the following pseudo area chart with configurable interpolation mode:</p><p>
</p><div><img src="img/image_07_008.jpg" alt="How to do it..."/></div><p>
</p><p>Area curve</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec155"/>How it works...</h2></div></div></div><p>This recipe is similar to the previous one, except that in this recipe the interpolation mode is passed in based on the user's selection:</p><pre class="programlisting">var line = d3.line() 
                .x(function(d){return x(d.x);}) 
                .y(function(d){return y(d.y);}) 
                .curve(mode); // &lt;-A 
 
var area = d3.area() 
            .x(function(d) { return x(d.x); }) 
            .y0(y(0)) 
            .y1(function(d) { return y(d.y); }) 
            .curve(mode); // &lt;-B 
</pre><p>As you can see, the curve mode was configured on both lines along with the area generator through the <code class="literal">curve</code> function (refer to lines <code class="literal">A</code> and <code class="literal">B</code>). Since D3 line and area generator supports the same set of curve factories, they can always be counted on to generate matching line and area as seen in this recipe.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec156"/>There's more...</h2></div></div></div><p>D3 area generator also supports the same tension configuration when using Cardinal mode; however, since it is identical to the line generator's tension support, and due to limited space in this book, we will not cover area tension here.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec157"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Please refer to <a class="ulink" href="https://github.com/d3/d3/blob/master/API.md#areas">https://github.com/d3/d3/blob/master/API.md#areas
</a> for more information on area generator functions</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec56"/>Using an arc generator</h1></div></div></div><p>Among the most common shape generators-besides the line and area generator-D3 also provides the <em>arc generator</em>. At this point, you might be wondering, <em>Didn't SVG standard already include circle element? Isn't that enough?</em>
</p><p>The simple answer to this is <em>no</em>. The D3 arc generator is a lot more versatile than the simple <code class="literal">svg:circle</code> element. The D3 arc generator is capable of creating not only circles but also annulus (donut), circular sector, and annulus sector, all of which we will learn in this recipe. More importantly, an arc generator is designed to generate, as its name suggests, an arc (in others words, not a full circle or even a sector but rather arcs of arbitrary angle).</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec158"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/arc.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/arc.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec159"/>How to do it...</h2></div></div></div><p>In this recipe, we will use arc generator to generate multi-slice circle, annulus (donut), circular sectors, and annulus sectors as follows:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 400, 
        height = 400, 
        fullAngle = 2 * Math.PI, // &lt;-A 
        colors =  d3.scaleOrdinal(d3.schemeCategory20); 
 
    var svg = d3.select("body").append("svg") 
                .attr("class", "pie") 
                .attr("height", height) 
                .attr("width", width);     
 
    function render(innerRadius, endAngle){ 
        if(!endAngle) endAngle = fullAngle; 
 
        var data = [ // &lt;-B 
            {startAngle: 0, endAngle: 0.1 * endAngle}, 
            {startAngle: 0.1 * endAngle, endAngle: 0.2 * endAngle}, 
            {startAngle: 0.2 * endAngle, endAngle: 0.4 * endAngle}, 
            {startAngle: 0.4 * endAngle, endAngle: 0.6 * endAngle},   
            {startAngle: 0.6 * endAngle, endAngle: 0.7 * endAngle},   
            {startAngle: 0.7 * endAngle, endAngle: 0.9 * endAngle},   
            {startAngle: 0.9 * endAngle, endAngle: endAngle} 
        ]; 
 
        var arc = d3.arc().outerRadius(200) // &lt;-C 
                        .innerRadius(innerRadius); 
 
        svg.select("g").remove(); 
 
        svg.append("g") 
                .attr("transform", "translate(200,200)") 
        .selectAll("path.arc") 
                .data(data) 
            .enter() 
                .append("path") 
                    .attr("class", "arc") 
                    .attr("fill", function(d, i){ 
      return colors(i); 
        }) 
                    .attr("d", function(d, i){ 
                        return arc(d, i); // &lt;-D 
                    }); 
    } 
 
    render(0); 
&lt;/script&gt; 
 
&lt;div class="control-group"&gt; 
&lt;button onclick="render(0)"&gt;Circle&lt;/button&gt; 
&lt;button onclick="render(100)"&gt;Annulus(Donut)&lt;/button&gt; 
&lt;button onclick="render(0, Math.PI)"&gt;Circular Sector&lt;/button&gt; 
&lt;button onclick="render(100, Math.PI)"&gt;Annulus Sector&lt;/button&gt; 
&lt;/div&gt; 
</pre><p>The preceding code produces the following circle, which you can change into an arc, a sector, or an arc sector by clicking on the buttons, for example, <strong>Annulus(Donut)</strong> generates the second shape:</p><p>
</p><div><img src="img/image_07_009.jpg" alt="How to do it..."/></div><p>
</p><p>Arc generator</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec160"/>How it works...</h2></div></div></div><p>The most important part of understanding the D3 arc generator is its data structure. D3 arc generator has very specific requirements when it comes to its data, as shown on line <code class="literal">B</code>:</p><pre class="programlisting">var data = [ // &lt;-B 
        {startAngle: 0, endAngle: 0.1 * endAngle}, 
        {startAngle: 0.1 * endAngle, endAngle: 0.2 * endAngle}, 
        {startAngle: 0.2 * endAngle, endAngle: 0.4 * endAngle}, 
        {startAngle: 0.4 * endAngle, endAngle: 0.6 * endAngle},    
        {startAngle: 0.6 * endAngle, endAngle: 0.7 * endAngle},    
        {startAngle: 0.7 * endAngle, endAngle: 0.9 * endAngle},   
        {startAngle: 0.9 * endAngle, endAngle: endAngle} 
]; 
</pre><p>Each row of the arc data has to contain two mandatory fields: <code class="literal">startAngle</code> and <code class="literal">endAngle</code>. The angles have to be in the range <code class="literal">[0, 2 * Math.PI]</code> (refer to line <code class="literal">A</code>). D3 arc generator will use these angles to generate corresponding slices, as shown earlier in this recipe.</p><div><div><h3 class="title"><a id="note69"/>Note</h3><p>Along with the start and end angles, arc dataset can contain any number of additional fields, which can then be accessed in D3 functions to drive other visual representation.</p></div></div><p>If you think that calculating these angles based on the data you have will be a big hassle, you are absolutely correct. This is why D3 provides specific layout manager to help you calculate these angles, and we will cover this in the next chapter. For now, let's focus on understanding the basic mechanism behind the scenes so that when it is time to introduce the layout manager or if you ever need to set the angles manually, you will be well equipped to do so. D3 arc generator is created using the following <code class="literal">d3.arc</code> function:</p><pre class="programlisting">var arc = d3.arc().outerRadius(200) // &lt;-C 
                    .innerRadius(innerRadius);  
</pre><p>The<code class="literal"> d3.arc</code> function optionally has the <code class="literal">outerRadius</code> and <code class="literal">innerRadius</code> settings. When <code class="literal">innerRadius</code> is set, the arc generator will produce an image of annulus (donut) instead of a circle. Finally, the D3 arc is also implemented using the <code class="literal">svg:path</code> element, and thus similar to the line and area generator, the <code class="literal">d3.arc</code> generator function can be invoked (refer to line <code class="literal">D</code>) to generate the <code class="literal">d</code> formula for the <code class="literal">svg:path</code> element:</p><pre class="programlisting">svg.append("g") 
            .attr("transform", "translate(200,200)") 
    .selectAll("path.arc") 
            .data(data) 
        .enter() 
            .append("path") 
                .attr("class", "arc") 
                .attr("fill", function(d, i){return colors(i);}) 
                .attr("d", function(d, i){ 
                    return arc(d, i); // &lt;-D 
                }); 
</pre><p>One additional element worth mentioning here is the <code class="literal">svg:g</code> element. This element does not define any shape itself but serves rather as a container element used to group other elements, in this case, the <code class="literal">path.arc</code> elements. Transformation applied to the <code class="literal">g</code> element is applied to all the child elements while its attributes are also inherited by its child elements.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec161"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Please refer to <a class="ulink" href="https://github.com/d3/d3/blob/master/API.md#arcs">https://github.com/d3/d3/blob/master/API.md#arcs
</a> for more information on arc generator function</li></ul></div></div></div></div></div>
<div><div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec57"/>Implementing arc transition</h1></div></div></div><p>One area where arc differs significantly from other shapes, such as line and area, is its transition. For most of the shapes that we covered so far, including simple SVG built-in shapes, you can rely on D3 transition and interpolation to handle their animation. However, this is not the case when dealing with arc. We will explore the arc transition technique in this recipe.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec162"/>Getting ready</h2></div></div></div><p>Open your local copy of the following file in your web browser:</p><p>
<a class="ulink" href="https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/arc-transition.html">https://github.com/NickQiZhu/d3-cookbook-v2/blob/master/src/chapter7/arc-transition.html
</a>
</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec163"/>How to do it...</h2></div></div></div><p>In this recipe, we will animate a multi-slice annulus transitioning with each slice starting from angle <code class="literal">0</code> to its final desired angle and eventually reaching a full annulus:</p><pre class="programlisting">&lt;script type="text/javascript"&gt; 
    var width = 400, 
            height = 400, 
            endAngle = 2 * Math.PI, 
            colors = d3.scaleOrdinal(d3.schemeCategory20c); 
 
    var svg = d3.select("body").append("svg") 
            .attr("class", "pie") 
            .attr("height", height) 
            .attr("width", width); 
 
    function render(innerRadius) { 
 
        var data = [ 
            {startAngle: 0, endAngle: 0.1 * endAngle}, 
            {startAngle: 0.1 * endAngle, endAngle: 0.2 * endAngle}, 
            {startAngle: 0.2 * endAngle, endAngle: 0.4 * endAngle}, 
            {startAngle: 0.4 * endAngle, endAngle: 0.6 * endAngle}, 
            {startAngle: 0.6 * endAngle, endAngle: 0.7 * endAngle}, 
            {startAngle: 0.7 * endAngle, endAngle: 0.9 * endAngle}, 
            {startAngle: 0.9 * endAngle, endAngle: endAngle} 
        ]; 
 
        var arc = d3.arc() 
                .outerRadius(200).innerRadius(innerRadius); 
 
        svg.select("g").remove(); 
 
        svg.append("g") 
            .attr("transform", "translate(200,200)") 
            .selectAll("path.arc") 
                .data(data) 
            .enter() 
                .append("path") 
                .attr("class", "arc") 
                .attr("fill", function (d, i) { 
                    return colors(i); 
                }) 
                .transition().duration(1000) 
                .attrTween("d", function (d) { 
                  var start = {startAngle: 0, endAngle: 0}; // &lt;-A 
                  var interpolate = d3.interpolate(start, d); // &lt;-B 
                  return function (t) { 
                      return arc(interpolate(t)); // &lt;-C 
                  }; 
                }); 
    } 
 
    render(100); 
&lt;/script&gt; 
</pre><p>The preceding code generates an arc that starts rotating and eventually becomes a complete annulus as follows:</p><p>
</p><div><img src="img/image_07_010.jpg" alt="How to do it..."/></div><p>
</p><p>Arc transition with tweening</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec164"/>How it works...</h2></div></div></div><p>When confronted with the requirement of such transition, your first thought might be using the vanilla D3 transition while relying on built-in interpolations to generate the animation. Here is the code snippet that will do just that:</p><pre class="programlisting">svg.append("g") 
        .attr("transform", "translate(200,200)") 
        .selectAll("path.arc") 
            .data(data) 
        .enter() 
            .append("path") 
            .attr("class", "arc") 
            .attr("fill", function (d, i) { 
                return colors(i); 
            }) 
            .attr("d", function(d){ 
               return arc({startAngle: 0, endAngle: 0}); 
             }) 
            .transition().duration(1000) 
            .attr("d", function(d){return arc(d);}); 
</pre><p>As shown with highlighted lines in the preceding code snippet, with this approach, we initially created slice path with both <code class="literal">startAngle</code> and <code class="literal">endAngle</code> set to zero. Then, through transition, we interpolated the path <code class="literal">d</code> attribute to its final angle using the arc generator function <code class="literal">arc(d)</code>. This approach seems to make sense, however, what it generates is the transition shown in the following:</p><p>
</p><div><img src="img/5530_07_11.jpg" alt="How it works..."/></div><p>
</p><p>Arc transition without tweening</p><p>This is obviously not the animation we want. The reason for this strange transition is that by directly creating a transition on the <code class="literal">svg:path</code> attribute <code class="literal">d</code>, we are instructing D3 to interpolate this string:</p><pre class="programlisting">d="M1.2246063538223773e-14,-200A200,200 0 0,1 1.2246063538223773e- 
14,-200L6.123031769111886e-15,-100A100,100 0 0,0  
6.123031769111886e-15,-100Z" 
</pre><p>Then, the preceding string will interpolate to this string linearly:</p><pre class="programlisting">d="M1.2246063538223773e-14,-200A200,200 0 0,1 117.55705045849463,- 
161.80339887498948L58.778525229247315,-80.90169943749474A100,100 0  
0,0 6.123031769111886e-15,-100Z" 
</pre><p>Hence, it leads to this particular transition effect.</p><div><div><h3 class="title"><a id="tip70"/>Tip</h3><p>Though this transition effect is not what we desire in this example, this is still a good showcase of how flexible and powerful built-in D3 transition is.</p></div></div><p>In order to achieve the transition effect we want, we will need to leverage the D3 attribute tweening (for detailed description on tweening, refer to the <em>Using tweening</em> recipe of <a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em>):</p><pre class="programlisting">svg.append("g") 
        .attr("transform", "translate(200,200)") 
        .selectAll("path.arc") 
            .data(data) 
        .enter() 
            .append("path") 
            .attr("class", "arc") 
            .attr("fill", function (d, i) { 
                return colors(i); 
            }) 
            .transition().duration(1000) 
            .attrTween("d", function (d) { // &lt;-A 
                var start = {startAngle: 0, endAngle: 0}; // &lt;-B 
                var interpolate = d3.interpolate(start, d); // &lt;-C 
                return function (t) { 
                    return arc(interpolate(t)); // &lt;-D 
                }; 
            }); 
</pre><p>Here, instead of transitioning the <code class="literal">svg:path</code> attribute <code class="literal">d</code> directly, we created a tweening function on line <code class="literal">A</code>. As you can recall, D3 <code class="literal">attrTween</code> expects a factory function for a tween function. In this case, we started our tweening from angle zero (refer to line <code class="literal">B</code>). Then, we created a compound object interpolator on line <code class="literal">C</code>, which will interpolate both start and end angles for each slice. Finally, on line <code class="literal">D</code>, the arc generator is used to generate a proper <code class="literal">svg:path</code> formula using the already interpolated angles. This is how a smooth transition of properly angled arcs can be created through custom attribute tweening.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec165"/>There's more...</h2></div></div></div><p>D3 also provides support for other shape generators, for example, symbol, chord, and diagonal. However, due to their simplicity and the limited scope of this book, we will not cover them individually here, although we will cover them as parts of other more complex visual constructs in the following chapters. More importantly, with well-grounded understanding of these basic shape generators covered in this chapter, you should be able to pick up other D3 shape generators without much trouble.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec166"/>See also</h2></div></div></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">For more information on transition and tweening, refer to the <em>Using tweening recipe</em> in <a class="link" href="ch06.html" title="Chapter 6. Transition with Style">Chapter 6</a>, <em>Transition with Style</em></li></ul></div></div></div></div></div></body></html>