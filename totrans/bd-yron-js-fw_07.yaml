- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a Full Stack Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089), we learned a practical example
    of building a simple JavaScript testing framework. In this chapter, we will continue
    this practical approach, further diving into the development of frameworks.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next goal is to develop a full stack framework that will enable developers
    to build large and small web applications. This chapter will start off by developing
    the backend parts of such a framework, focusing on the server-side components
    and integrating essential developer tooling. These backend components, once established,
    will help us support the frontend elements of the framework we will create in
    [*Chapter 8*](B19014_08.xhtml#_idTextAnchor138). Developing the backend feature
    set in this chapter will help us do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Define the technical architecture and goals of our new full stack framework.
    This is similar to the [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089) exercise,
    but now we will switch the context and focus more on the technical challenges
    of the backend server functionality.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learn more about the components that are required to produce functioning full
    stack tooling. We will study and explore the abstractions we can build and the
    core parts of the framework that will make it usable in many development scenarios.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Identify the features that will improve usability, focusing on the features
    that empower developers and increase efficiency. These comprise tools that help
    automatically generate the framework scaffold from a template and enhance development
    productivity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The implemented framework code is in the book repository at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    The assets and code are in the `chapter7` directory. As with [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089),
    we will utilize Node.js v20 or higher for this project.
  prefs: []
  type: TYPE_NORMAL
- en: Refer to the `README.md` file of the framework in the chapter directory if you
    want to run or tweak the framework files locally. `npm scripts` can be handy to
    use shortcuts during development. As with other projects, to begin working on
    the framework, you need to install the dependencies with `npm install`.
  prefs: []
  type: TYPE_NORMAL
- en: The framework provides an executable that helps create the scaffold outline
    of the project, run the newly created application, and more. To locally install
    the `componium` framework executable from the `chapter7` directory, you can link
    the executable to use it in different directories. To achieve this, from the checked-out
    repository directory, use `npm link <path>/chapter7/componium`. This will link
    a global framework executable to your terminal shell that you can use in a sample
    project. In addition, if you make any changes to the framework files, the executable
    will pick up the changes instantly, as the script is directly linked. Check out
    the detailed `npm link` instructions at [docs.npmjs.com/cli/commands/npm-link](https://docs.npmjs.com/cli/commands/npm-link)
    and the following note about Windows compatibility.
  prefs: []
  type: TYPE_NORMAL
- en: A note about Windows compatibility
  prefs: []
  type: TYPE_NORMAL
- en: There are a few things to keep in mind when working with framework executables
    and commands such as `npm link` in the Windows OS. When running `npm link chapter7\componium`
    or other commands, you may experience some issues with the executable environment.
    There are a few common errors that can occur, including the following.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you get an error related to `enoent ENOENT: no such file or directory AppData\Roaming\npm`,
    make sure to create that directory in the mentioned path. This is usually an artifact
    of the `npm` installer on Windows.'
  prefs: []
  type: TYPE_NORMAL
- en: If you get an issue with `UnauthorizedAccessException`, this is a standard security
    measure of Windows. To fix this, run `Set-ExecutionPolicy RemoteSigned` and allow
    the execution. For more information, refer to Microsoft’s documentation at [learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy).
  prefs: []
  type: TYPE_NORMAL
- en: You can also refer to the *Common errors* article for npm at [docs.npmjs.com/common-errors](https://docs.npmjs.com/common-errors).
    If you can successfully run `componium --version` using your PowerShell or Command
    Prompt, then your environment is correctly configured.
  prefs: []
  type: TYPE_NORMAL
- en: Full stack framework goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before we get to the software architecture part of this project, we need to
    get a better insight into what a full stack framework will entail, especially
    in the JavaScript context and the language’s ecosystem. When developing a full
    stack JavaScript framework, we get to create a blend of abstractions and conventions
    to help developers produce a combination of frontend and backend components, given
    the modular nature of the JavaScript language and its ecosystem. From the JavaScript-language
    point of view, the framework can utilize the latest syntax and functional improvements,
    such as ES6 modules and modern web APIs. Ecosystem-wise, we will heavily rely
    on already-established modules to enable certain functionality. Similar to the
    approach in [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089), this strategy allows
    us to stay focused on the larger system design and achieve much better feature
    coverage.
  prefs: []
  type: TYPE_NORMAL
- en: The primary objective of a full stack framework is to simplify the application
    development process, making it faster and more efficient by providing a structured
    and standardized way to build applications. We have seen examples of the variety
    of these technical solutions in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015),
    where frameworks such as Next.js create a much more streamlined and opinionated
    workflow across the whole stack. The projects, similar to Next.js, encapsulate
    all aspects of development and cover many use cases, seeking to eliminate the
    necessity of deciding on different technologies for different layers of development
    and offer a single unified vision. One of the goals of our sample framework project
    in this chapter is to focus on similar examples of developing a unified feature
    set, where components fit naturally together.
  prefs: []
  type: TYPE_NORMAL
- en: The implementation vision of the framework in this chapter should offer a unified
    API such that the developers utilizing the API can easily get acquainted with
    its structure and functionality, reducing the learning curve typically associated
    with new technology adoption. The familiarity and interoperability between different
    features ensure a seamless experience for developers. The framework API provides
    abstractions (highlighted in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030) in
    the *About abstractions* section) that make complex operations simple without
    compromising the flexibility required for advanced use cases. The approach to
    creating easy-to-use public framework API interfaces is essential to support the
    varying skill levels of developers and the requirements of robust applications.
    When you develop or support a full stack framework similar to the practical example
    in this chapter, you will also have to take a variety of features into consideration.
    You will find that in your particular scenario, you will invest more in a feature
    set that is a higher priority for your organization.
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the server-side feature set first, a full stack JavaScript framework
    must be able to provide a set of fundamental building blocks to handle standard
    use cases, based on different technological challenges. The features powered by
    such building blocks could include request routing, database integrations, unified
    interfaces for events, logging, and performance scaling. In some cases, a framework
    can also offer features beyond what a developer requires in their projects. Therefore,
    as part of the development process, we have to strike a balance between using
    the built-in features and offering a variety of extensibility options. We have
    seen instances of this in the *Plugin and extension APIs* section of [*Chapter
    3*](B19014_03.xhtml#_idTextAnchor051), where the server-side frameworks included
    a way to extend and enable additional functionality. Besides providing a sizeable,
    flexible feature set with the best developer experience, the applications must
    be easily deployable and have a way to be monitored once operating in production
    environments. In this case, pursue a goal of making it easy for developers to
    deploy their applications, scale those applications up as they get more traffic,
    and monitor latency and error rates. This involves building in utilities to set
    up multiple server instances, defining database migrations, and more.
  prefs: []
  type: TYPE_NORMAL
- en: As we define the expected functionality of a full stack framework, we need to
    define how much the frontend and backend features will interact with each other
    and where we would like to start the initial development. Considerations for those
    two sides of a full stack framework are explored in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On the frontend side of a full stack framework, the emphasis should be on providing
    seamless integration of frontend components that interact well with backend services.
    Examples of these types of features could be easily fetching data from the server,
    rendering frontend components, and having access to the static files. Ember.js,
    along with EmberData, provides real-world examples of how to effectively collaborate
    with server-side systems. Another example is Next.js, which provides a tightly
    integrated solution for both the server and the client. Generally, the opinionated
    components can define how the framework interacts with the data received from
    the network requests, and how the data is bound to views and components on the
    frontend.
  prefs: []
  type: TYPE_NORMAL
- en: The frontend feature set should be capable of handling standard frontend requirements
    as well. These could include working with popular libraries by offering an easy
    way to integrate those libraries into projects. An extensive frontend solution
    should facilitate client-side routing and the ability to manage dependencies and
    handle form validation, user input sanitization, and JavaScript code bundling.
    Application state management is another significant component that can help manage
    the complexity of larger projects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.1: The focus of a full stack framework](img/Figure_7.1_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The focus of a full stack framework'
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, the process of developing a comprehensive full stack framework calls
    for the exploration of considerable facets of technology. This initiative also
    necessitates a broad spectrum of programming skills. You’ll be expected to delve
    into both the complexities of the frontend features, where you will be concerned
    with user experience, and the backend challenges, focusing on servers, databases,
    and application logic. The development process enhances your coding abilities
    and promotes a better understanding of the entire web development ecosystem. In
    *Figure 7**.1*, we break down the two important aspects of our framework development.
    The **Features** will provide the necessary functionality to build frontend and
    backend components, interacting with services such as a database, and the **Developer
    Experience** will make these features reusable and easily accessible for application
    projects. The result of all this work will be a project usable by a variety of
    stakeholders, satisfying the respective needs of developers to produce web applications
    that power new services and web-based software products.
  prefs: []
  type: TYPE_NORMAL
- en: Backend functionality
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We start with backend feature development first. This approach will serve the
    project as a foundation to later add frontend features on top of it to complete
    the full stack feature set. We will focus on frontend features and architecture
    in the next chapter. For now, we will imagine that our backend framework can deliver
    files to the browser client and can be used with any frontend framework. Browser-based
    applications can make requests to the server-side components to fetch data, static
    files, or web pages.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Our full stack framework logo](img/Figure_7.2_B19014.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Our full stack framework logo'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will reuse the same Componium project identity and branding that was established
    in [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089). We now have a new logo, as
    shown in *Figure 7**.2*, to serve as a branding example that identifies our full
    stack project. The Componium term and branding will cover all parts of the framework
    will be utilized in the command-line interface as well. Keeping the target developer
    user base in mind, here is a list of potential starter backend features for this
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '**API deployment**: The ability to deploy an API service. The API functionality
    should be flexible enough to allow us to easily configure endpoints and add functional
    middleware to a selection of endpoints. The API capabilities should also include
    a modular approach to defining GraphQL resources and schemas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Page rendering features**: The ability to deliver web pages with custom and
    reusable layouts containing static and dynamic data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Middleware mechanisms**: Features that can add various types of server middleware,
    such as authentication, to all or some of the routes of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Database capabilities**: Database **object-relational mapping** (**ORM**)
    capabilities that provide the ability to use different types of database technologies.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Application scalability**: Designed to handle high-load situations and offer
    scalability and performance optimization options. The framework should provide
    the necessary tools to test, debug, and deploy an application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Development tools**: The framework offers a variety of helpers to ease the
    development process. The tools can include application bootstrapping and scaffolding
    of standard components. Live-reloading of the backend server can also save a lot
    of time by avoiding manually restarting the process on every change.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These functionality goals are now defined in enough detail, covering both the
    frontend and backend experiences. Utilizing the considerations in this section,
    we are ready to proceed to the exciting steps of architecting the initial parts
    of the full stack framework.
  prefs: []
  type: TYPE_NORMAL
- en: Architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a clearer definition of the backend features, we can start
    architecting the packages and components of the framework. We will need encapsulation
    for server and routing interfaces, as well as additional components that allow
    us to communicate with databases, fetch particular application configurations,
    and report metrics or logs through logging.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: The request life cycle](img/Figure_7.3_B19014.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: The request life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.3* represents a simplified view of the request life cycle that
    our framework will process. The requests can originate in a browser client or,
    potentially, be direct requests to an API endpoint of the server that our framework
    needs to handle. You can find a sample application built using our framework in
    the chapter directory under `tests/sample`.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: A sample application layout](img/Figure_7.4_B19014.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: A sample application layout'
  prefs: []
  type: TYPE_NORMAL
- en: We now have an overview of how a framework processes requests through its internals.
    *Figure 7**.4* shows an example of an application layout, consisting of the backend
    API and GraphQL routes. Developers can utilize this structure to build different
    types of server-side applications. In the following sections, we will take an
    in-depth look at the entry points, router, configuration, database, and observability
    features that make this application layout possible. You can find the files in
    the chapter directory under `componium/tests/sample`. Some of the files, such
    as the `*.log` files, will automatically generate when the application starts
    and produces some logging; normally, these log files are ignored by the version
    control system.
  prefs: []
  type: TYPE_NORMAL
- en: Entry point
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The server file is the entry point to provide most of the capabilities of our
    backend framework. It bootstraps a process, loads the appropriate configuration,
    connects to a database if specified, and establishes the request route handlers.
    In [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089), we had a simpler server (located
    in the project file at `componium-test/blob/main/packages/browser/server.js`),
    developed using the `http.createServer(...)` Node.js APIs. We can follow the same
    strategy and build a new server from scratch. However, for a full stack framework,
    we need a more established solution that has many server interfaces already in
    place. An excellent middle-ground choice for this project is to use the `express`
    module and create abstractions on top of it. *Express* will allow us to define
    middleware, custom routers, parse requests, craft API responses, and much more.
    If this sounds familiar, this is because this is a similar architecture to the
    NestJS framework project previewed in [*Chapter 4*](B19014_04.xhtml#_idTextAnchor063).
  prefs: []
  type: TYPE_NORMAL
- en: 'To expand the server functionality, we will also allow developers to create
    multiple servers in the same application context, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With the server interfaces in place, we can now accept requests on a port and
    configure the servers with options that fit our requirements. Once the server
    is created, as seen in the preceding code, the main purpose of it is to handle
    endpoints and perform backend tasks. For the purposes of handling endpoints, we
    will introduce the *router* interface. It comes into play to accept requests and
    enable the API features.
  prefs: []
  type: TYPE_NORMAL
- en: Router
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this framework, we want to provide options for file-based and dynamic routing.
    This involves using a similar feature to file-based routers in Next.js. We saw
    this concept in the overview of the building blocks in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030).
    The router implementations can be found in the server package of the framework
    – for example, the file-based router is in `packages/server/file-router.js`.
  prefs: []
  type: TYPE_NORMAL
- en: The file-based router implementation is capable of recursively loading API endpoints
    from a directory structure. The file-based feature allows for some manual configuration.
    By default, the framework can look in a `routes` directory of a project. However,
    that can be adjusted by passing a file-router directory option to the server configuration.
    For details on the implementation of a file-based router, refer to the following
    package – `packages/server/file-router.js`.
  prefs: []
  type: TYPE_NORMAL
- en: As we need to handle different HTTP methods in our file router, we can establish
    a pattern for the HTTP methods. This way, if you make a `POST` or `DELETE` request,
    you are still able to indicate what type of HTTP method the file should respond
    to. To enable this functionality, we will configure the framework to handle files
    in the following manner. Files ending with a `.post.js` will indicate that this
    route is a `POST` method route. Files omitting this configuration will default
    to a `GET` handler. To handle index or root endpoint routes, we will use an `_index.js`
    file. This indicates that it is the root handler. For example, the `api/` directory
    can have the `_index.js` file, which will handle the requests to the root endpoint
    of the API. Refer to *Figure 7**.4* to see the directory structure of the `api/`
    directory. You can find an example of this in the sample application in the GitHub
    repository at `componium/tests/sample/routes/api/_index.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Besides file-based routing, developers will sometimes need to define the routes
    and modular routers directly or programmatically in their code. To support those
    use cases, our framework offers several server methods to allow flexibility around
    routes, middlewares, and custom routers, as shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Reading the preceding middleware code, we can see some of the methods that our
    framework offers to enable dynamic routing. Backed by the primitives from the
    `express` package, we can create a more abstract system that provides a custom
    way to describe router definitions. As always, it also allows us to swap out the
    `express` module in favor of something else later on if required. The `addRoute`
    methods are present on both the server and custom router objects. These allow
    us to add custom route handlers instead of using file-based handlers. The `addRoute`
    function takes an argument of the route path and a function that has request/response
    arguments, used to process the request. This route-handling flow is visualized
    in the preceding code, which creates a server middleware, a new route, and an
    additional router with its own routing entities. Further details on router capabilities
    can be found at [expressjs.com/en/guide/routing.html](https://expressjs.com/en/guide/routing.html).
  prefs: []
  type: TYPE_NORMAL
- en: In addition to routing methods, we have additional middleware management functions,
    such as `addMiddleware`. These methods allow us to configure any self-developed
    or external middleware. In this case, it makes our framework compatible with other
    express-based middleware. For example, we can use it to add authentication to
    our endpoints using the `passport` module ([github.com/jaredhanson/passport](https://github.com/jaredhanson/passport));
    this will enable the framework to support a huge variety of authentication options.
  prefs: []
  type: TYPE_NORMAL
- en: The established architecture of the router and entry points allows us to actually
    create an application process that can accept requests. In the following subsections,
    we will define the ability to configure different components of our framework.
  prefs: []
  type: TYPE_NORMAL
- en: Configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Developers expect a clean way to configure a framework-based application, with
    capabilities to run it in local, test, and production environments. To enable
    this, we will utilize the `config` package (located at [npmjs.com/package/config](https://npmjs.com/package/config)).
    This package will allow us to elegantly organize the configuration options and
    let the application code base behave differently, based on the environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'To provide a simple example, if we had only one property to configure, then
    our configuration file, `default.json`, would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'With the `config` package, we can access the configuration in any of the framework
    modules and allow it to be used for any developer purposes from within the code
    base:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `config` package automatically loads the required file and allows us to
    fetch data out of that configuration storage and access all the set properties.
    In the preceding configuration code, we get to fetch the database connection URL
    that can be used to bootstrap the database connection from the application.
  prefs: []
  type: TYPE_NORMAL
- en: As with other modules, we can create abstraction on the `config` package. However,
    we want to offer the core features of the package for developers’ use. The `config`
    package supports several file formats for application configuration, such as YAML
    ([yaml.org](https://yaml.org)), JSON, or straight-up JavaScript. Providing a choice
    of formats is helpful, as it enables us to meet the requirements of the application
    deployment tools. For example, developer operations might prefer to structure
    all the production configurations with YAML files.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring aspects of applications within a framework can become remarkably
    complex, due to the variety of configuration formats and methods available. The
    JavaScript ecosystem provides dozens of packages that can help you with configuration.
    Try to evaluate some of them to find the one that fits your needs best. Consider
    the types of configuration file extensions that a package supports and what kind
    of validation it can perform. Furthermore, in the following subsection, we will
    highlight how your framework should offer a set of defaults that work for your
    users.
  prefs: []
  type: TYPE_NORMAL
- en: Sensible defaults
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`config` package features will allow us to specify the defaults in the `default.js`
    file. This file will act as a template for an application’s configuration. The
    configuration file can also be scaffolded in different ways; we will look into
    this further in the *Developer* *experience* section.'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the amount of configuration in your framework is something to strive
    for. It is key to creating a consistent experience and reducing the burdens of
    building new projects with your framework.
  prefs: []
  type: TYPE_NORMAL
- en: Database
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we add the `database` functionality to our framework, we need to make sure
    to support a wide variety of databases. The project should also offer a unified,
    abstract way to work with database objects. To support these use cases, we can
    rely on a higher abstract library that enables ORM. For this chapter’s example,
    we will rely on an open source ORM library called **Sequelize** ([sequelize.org](https://sequelize.org)).
    This library gives us support for MySQL, PostgreSQL, and MSSQL out of the box.
    It also enables us to use SQLite in local development and other environments,
    which makes it really easy to work with database operations and not connect to
    more complex database services. An ORM library such as Sequelize will add capabilities
    to interact with a database using JavaScript. It will allow us to treat database
    entities as objects, simplifying data manipulation and extraction.
  prefs: []
  type: TYPE_NORMAL
- en: In Componium, the database interface can be found in the `db` package. While
    some parts of interaction with Sequelize are abstracted, we still rely on the
    users of our framework to get familiar with the library and its features directly.
    It is common to see large frameworks rely on separate ORM layers, due to the fact
    that implementing and supporting several database engines requires a lot of investment
    in code and time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a new application is initialized in code, a framework automatically tries
    to make a connection to the configured database. To operate with database entities,
    the application needs to load the model files. In the Componium framework, the
    models are stored in the `models` directory and loaded during the initialization
    as well. This application structure allows framework users to keep data models
    organized and modular. The models can then be used within your route handlers
    to interact with the database, whether you need to create, read, update, or delete
    data. Here’s an example of a model we can use in the app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'To get access or mutate this model in our route handlers, we can use the `componium`
    object to get to the database entity object and perform an operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code, located in the application under `sample/api/packages.js`,
    queries the packages stored in the `Package` model. Finally, it returns all the
    objects found in a query in the route handler. For the purposes of this chapter,
    the database implementation is fairly simple, but you can take up the challenge
    to make the code more accommodating to handle multiple databases and improve model
    file coupling if desired.
  prefs: []
  type: TYPE_NORMAL
- en: GraphQL support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to the several options to define API endpoints, our framework also
    supports **GraphQL**, a powerful query language that is useful for backend data
    retrieval. Some developers might prefer to use GraphQL with our framework, and
    they should have good experience in integrating this system.
  prefs: []
  type: TYPE_NORMAL
- en: 'The GraphQL module can be found in the chapter files under `packages/server/graphql.js`.
    Following a similar design for a file-based router, the `componium` framework
    has a feature to make it easier to develop modular schemas for GraphQL. These
    schemas can be defined in separate files and later assembled into full schemas
    that are supported by every Componium server object. Every GraphQL type definition
    can be defined in its own `*.gql.js` file. Here’s an example of a `packages.gql.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we define a sample definition for the package type so that we can query
    the data for that particular model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the schema definition for a Package type that queries
    the entries for the objects related to the `Package` model, retrieving all the
    stored packages in the database. The `.findAll()` call is the built-in interface
    related to the ORM package that is used under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: An Apollo GraphQL sandbox request](img/Figure_7.5_B19014.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: An Apollo GraphQL sandbox request'
  prefs: []
  type: TYPE_NORMAL
- en: The database items can now be retrieved using the query language. *Figure 7**.5*
    shows an interface of the `@apollo/server` package. GraphQL support can be enabled
    or disabled by specifying the `gql` option when we create new Componium servers,
    by calling the `app.createServer({gql:` `false})` method.
  prefs: []
  type: TYPE_NORMAL
- en: If you are looking to learn more about GraphQL, check out some of the publications
    related to it at [packtpub.com/search?query=graphql&products=Book](https://packtpub.com/search?query=graphql&products=Book),
    especially the *Full Stack Web Development with GraphQL and React* book. Many
    aspects of GraphQL can get really complex quickly, but it is a good example of
    a feature you can add to your framework to enable a powerful query language based
    on an established specification.
  prefs: []
  type: TYPE_NORMAL
- en: The next subsection focuses on observability, which will help to make sure the
    GraphQL feature works properly in applications and we can acquire enough visibility
    into the internals of the projects using logging.
  prefs: []
  type: TYPE_NORMAL
- en: Observability
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The final feature that is worth highlighting has to deal with **observability**.
    Our framework should offer an interface to allow developers to log essential operations
    to a file. The framework itself should automatically log any sensitive operations
    that the developer should be aware of.
  prefs: []
  type: TYPE_NORMAL
- en: This is where the *winston*-based `Logger` class comes into play; you can find
    the implementation in the framework’s `packages/app/logger.js` file. winston ([github.com/winstonjs/winston](https://github.com/winstonjs/winston))
    is a logging library that can output the logs in flexible ways and is compatible
    with various deployment environments. It provides a simple and straightforward
    interface for logging, allowing developers to easily incorporate logging into
    their applications with minimal effort. This not only ensures that developers
    have granular control over what gets logged but also standardizes the way logs
    are generated across an application.
  prefs: []
  type: TYPE_NORMAL
- en: 'The logger class is designed to be flexible with respect to the logging environment.
    It is configured to log to a console in non-production environments, allowing
    for real-time debugging during the development stages. In production, the logs
    are written to specified files, providing a permanent record of the application’s
    operation and behavior that can be referred back to when needed. This separation
    of environments also provides a level of safety, ensuring that sensitive data
    is not inadvertently exposed during development. These logs can then be used to
    diagnose and troubleshoot issues, enhancing the observability and reliability
    of the application. As discussed in the *GraphQL support* section earlier, we
    will use the logger to keep track of the found packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In development mode, this logger will provide information in the terminal console;
    this way, this information can effortlessly be seen during the feature development
    phase. Once the application is deployed and running in the production environment,
    it will log into the `error.log` and `combined.log` files. The format of the logs
    in those files will be JSON, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This `logger` class has the interface to log `.info`, `.warn`, and `.error`
    messages. It will empower developers by providing a way to keep track of the application
    behavior, debug issues, and store necessary logs that can later be parsed.
  prefs: []
  type: TYPE_NORMAL
- en: Concluding the *Architecture* section, we now have insight into entry points,
    routing, logging, database, and endpoint support. These are plenty of features
    for the first iteration of the project. Further, we will connect these features
    with an improved developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: Developer experience
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With several essential backend features built, we can now focus on the developer
    experience aspects. Earlier referenced in *Figure 7**.1*, this is the second important
    aspect of the framework we will focus on. The goal behind introducing framework-adjacent
    developer tools is to lessen the friction of adapting the features of our framework.
    It also helps to streamline the experience and create a unified way to work with
    the framework’s primitives.
  prefs: []
  type: TYPE_NORMAL
- en: To enable most of this experience, we will rely on the `componium` executable
    that ships with the framework when it is installed. This executable will take
    care of a lot of mundane tasks, such as initializing applications and scaffolding
    standard components. It will also eliminate common points of friction by enabling
    features such as live server reload.
  prefs: []
  type: TYPE_NORMAL
- en: In the next three subsections, we will explore three potential developer experience
    offerings that you can provide to the users of your framework.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrapping a new application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Componium framework’s `componium` executable shipped with the library simplifies
    the process of bootstrapping a new application. Rather than setting up a new application
    from scratch, the developer can just run the `npx componium init` command. This
    command will provide options to create a basic project structure with all the
    necessary configurations and dependencies set up. The initialization process saves
    a significant amount of time and ensures consistency across different projects
    built using the framework. The command has the flexibility to accept parameters
    such as `npx componium init my-app` to create a new application structure in the
    `my-app` directory. The `init` feature is great for developers, since it automates
    the repetitive and error-prone process of creating new applications from nothing.
  prefs: []
  type: TYPE_NORMAL
- en: Making this bootstrapping process easy is key for new developers to get started
    using the framework. Looking back to [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015),
    you will find that almost every framework offers one or several ways of bootstrapping
    projects, using a CLI tool or a similar mechanism.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To continue on the theme of reducing error-prone tasks, scaffolding is a highly
    beneficial feature that further enhances the developer experience. It allows developers
    to automatically generate boilerplate code for components that are supported by
    the framework. In the framework exercise of this chapter, we will support creating
    things such as models, GraphQL schemas, and routes.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: An example of the scaffolding experience](img/Figure_7.6_B19014.png.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: An example of the scaffolding experience'
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 7**.6* showcases the developer experience when running the framework
    executable to scaffold some new components inside of new applications. A highly
    detailed description can be provided for each option that helps explain the potential
    options of each operation. The `create` command can also support a direct set
    of parameters to avoid the `Select` interface for more advanced users of the framework.
    The scaffolding commands can demonstrate best practices and quickly teach developers
    about the framework’s capabilities.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition, the new project initialization scaffolding options can include
    the framework features a developer wants to use. For example, they can choose
    the defaults or customize the project and choose their database type, enable GraphQL
    support, opt in for the file-based router, and so on. To successfully perform
    this workflow step, the framework has to provide clear instructions related to
    initializing and setting up the project.
  prefs: []
  type: TYPE_NORMAL
- en: Scaffolding is super common in many projects and is a must-have for new projects.
    In some cases, the scaffolding features can ship separately from the main project.
    However, providing the ability to scaffold greatly improves interaction with your
    framework.
  prefs: []
  type: TYPE_NORMAL
- en: File watching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: File watching is another valuable feature provided by the `componium` executable.
    In this case, it’s used for internal usage via the `componium dev` command. This
    feature watches for changes in the source code files of the application. It later
    automatically rebuilds and restarts the server whenever a change is detected.
    This means that developers can see the results of their changes faster and iterate
    faster. This file-watching infrastructure will come in handy as we further develop
    the backend features of the framework. It can also be beneficial for the next
    chapter, where we introduce frontend components that will need to be rebuilt as
    they are iterated upon.
  prefs: []
  type: TYPE_NORMAL
- en: The combination of these features – easy initialization, detailed code scaffolding,
    and file watching – creates an excellent developer experience, as it allows developers
    to focus on the project’s requirements. We shall see how these developer features
    are relevant in the next section, as they relate to an example workflow utilizing
    our newly developed framework.
  prefs: []
  type: TYPE_NORMAL
- en: The three examples of improvements to the developer experience help to define
    the specific tasks in which framework authors can invest. These enhancements aim
    to improve the overall usability of the project. In the next section, the workflow
    that we will discuss how these scaffolding and file-watching tools can be utilized
    and accompany the framework project and makes it more pleasant to use.
  prefs: []
  type: TYPE_NORMAL
- en: Developer workflow
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections of the chapter, we identified the project goals, developed
    the architecture, and described a few sample features of the framework. In this
    workflow section, let us summarize how developers can take advantage of the project
    and understand their workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Here are the parts of the workflow, including some of the steps required on
    the framework developer side to make the project available for consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Framework distribution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A newly created JavaScript framework is published publicly or privately on the
    `npm` package registry. When a framework author wants to keep the project fully
    private, it can be consumed from a private Git repository within the internal
    infrastructure. This whole framework package includes a `README` file and framework
    documentation that helps external developers start building a new application.
  prefs: []
  type: TYPE_NORMAL
- en: New project requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use an example of framework usage, a developer wants to build a sample application
    that keeps track of packages. The system needs to be able to list inbound and
    outbound packages, change the properties of those packages, and add and remove
    new ones. Ultimately, the developer would like to enable these features and deploy
    them to a remote environment, where the application interacts with a production/staging
    database environment.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start building the application, the developer installs the framework. They
    can use a command such as `npm install -g componium`. The command globally installs
    the framework. This is similar to the `npm link` command that we used before to
    get access to the executable. However, in this case, the framework is downloaded
    from the npm package manager database. In your case, you can use the npm-linked
    version of the executable if it makes it easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the framework installed, the developer can now run `componium init` to
    create a new application structure. The terminal will show the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Using the framework
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The initialization script automatically installs the necessary parts of the
    project, including a `package.json` file. The code scaffolds the necessary files
    into the project directory based on those choices. The starting point now leaves
    the developer with a brand-new project directory, where they can begin development.
    The expectation of this workflow ensures minimal friction during installation
    and presents the developer with an example of running application code. The next
    step for the developer is to use either the `componium dev` or `componium create`
    command. The first command, `dev`, will start the development server in the project
    directory, and the second command, `create`, can scaffold new components within
    the project. It is up to the developer to decide whether they want to use the
    scaffolding helpers or write code from scratch using the provided framework documentation.
    These two commands will come in handy in the next parts of the workflow, where
    a developer can start adding new API models and server endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an API and a model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, by following the docs on route creation and handling, the developer can
    create the necessary endpoints to support the requirements of the project that
    they are building. For example, they can begin by using the file-based router
    to define two endpoints – one to create new *package* entries and another to list
    them. To do this, they can make a directory called `api` and add a new file, `api/packages.js`.
    You can find an example of this file at `chapter7/componium/tests/sample/models/package.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of doing this manually, the scaffolding tool can also help generate
    a new route file and a new model file, later placing them into the correct directory.
    For the route generation, the command looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This will now provide an endpoint to handle requests. The developer will likely
    start looking for ways to enrich the API endpoints with actual data. The API creation
    step requires the application author to understand the available options and the
    mechanisms to create new endpoints. Most likely, they can learn this from the
    framework documentation and provided sample apps.
  prefs: []
  type: TYPE_NORMAL
- en: Expanding the API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the API routes functioning, it is time to enable data persistence. In
    this case, the developer needs to add database capabilities to save and list *packages*.
    The framework already ensures that it can connect to a development database locally
    so that step is taken care of. The next step in the workflow is to add a *Package*
    model and load it in the API endpoints. The scaffolding tooling can generate a
    model file in the right location using a CLI prompt or command. For example, the
    CLI can run `componium create` to prompt the developer for the database model
    details. To successfully achieve this workflow task, the application author needs
    to be aware of the scaffolding tools or manual ways to manage database models
    within the framework. Once we create the model, we can update the `models/package.js`
    file to store the properties of different packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we can both create new packages and then respond with
    all the packages in the database. Furthermore, we can split the creation logic
    and the query logic into different routes. The full packages file can be found
    in `tests/sample/routes/api/packages.js`.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this workflow step, the endpoint should now have the code logic
    to interact with the newly created Package model and list the records when the
    `packages.js` route is accessed.
  prefs: []
  type: TYPE_NORMAL
- en: Adding tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At this point in our workflow, we have a working API that interacts with the
    database. The developer has already tested the endpoints manually using sample
    requests. They can also land some functional test cases to make sure the API works
    properly. To successfully add tests, there needs to be documentation on the suggested
    ways to test endpoints. These suggestions can include the use of third-party test
    libraries or the built-in `componium-test` library from [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the routes tested, it is time to attempt to deploy the application to see
    whether it works in the remote environment. The application frameworks that we
    saw in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015) pride themselves on the
    ease of deployment. Therefore, the expectations are high to make the application
    as easy as possible to deploy.
  prefs: []
  type: TYPE_NORMAL
- en: To successfully achieve this step, our framework provides a production configuration
    file, `config/production.json`. This JSON file contains various environment-specific
    settings that the application uses when running in the production environment.
    It is still up to the developer to properly understand how to securely specify
    the database information and other configuration options. The framework documentation
    can guide the application authors to suggest optimal ways to make this step work.
    While the framework provides this file, it’s still the responsibility of the developer
    to understand how to securely specify the required attributes. The way these details
    are specified can significantly impact the security and performance of the application,
    making it critical to get it right.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the production configuration correctly configured, the developer can now
    deploy the application to their server environment and test out the new API. This
    step completes our sample workflow, and if the developer can successfully test
    out their changes and interact with the database, then the workflow is successful.
  prefs: []
  type: TYPE_NORMAL
- en: This is just one example of a framework workflow, which allows us to document
    the steps from installation to a working application. There are more steps that
    could potentially be added; it largely depends on how far we are willing to explore
    this workflow. For example, using the middleware APIs of the framework, we can
    explore how common middleware such as authentication can be easily added to the
    new endpoints. We also didn’t cover the use cases where an application author
    needs to have frontend views to manage and interact with the endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: The process of figuring out these types of workflows can help us identify friction
    and opportunities to make the framework’s developer experience much better. It
    also ensures that we figure out what types of documentation and tooling improvements
    can be added to the project as we develop it further.
  prefs: []
  type: TYPE_NORMAL
- en: At this point of deployment of the application, we conclude the workflow’s standard
    progression. The additional steps in the more extensive workflow can involve doing
    more in-depth database operations and using the framework’s GraphQL features.
    Overall, focusing on several of these types of workflows can help framework authors
    fine-tune how stakeholders interact with their systems. In the following section,
    we will take a look at a list of the external dependencies that made all this
    possible.
  prefs: []
  type: TYPE_NORMAL
- en: Dependencies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The workflow that we mentioned in the previous section is made possible by
    several external libraries and modules. Here’s a recap of some of the modules
    that we used in the Componium framework from this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`@apollo/server` and `@graphql-tools/schema`: The combination of these two
    tools allows us to offer the GraphQL features of this framework project. Apollo
    Server is able to integrate with Componium servers, and it also provides an easy-to-use
    sandbox to test GraphQL schemas.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Chokidar`: This is the file-watching library that helps to create a better
    experience by watching for changes to the application files and performing steps,
    such as restarting the development server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`@inquirer` and `yargs`: These libraries allow us to create the `componium`
    command-line tool. *Inquirer* can create interactive terminal interfaces, useful
    for Componium development commands, such as `componium create`. *Yargs* helps
    us work with command-line commands, flags, and options, making it easier to quickly
    develop a sleek development interface for our project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`express` and `body-parser`: These are the underlying server libraries that
    make it possible to initialize Componium servers and add routes and middleware.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Winston`: This is the logging library that is used in the underlying `Logging`
    class. It helps us provide a way for the Componium applications to log to different
    types of logs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sequelize`: This is the ORM layer library that helps applications integrate
    with a variety of databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`componium-test`: This is the testing library from [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089)
    that we can utilize to test the backend framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`debug`: This is the logging module used to track down and debug internal issues
    of a framework during development. As mentioned in [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089),
    it supports scoping a debug level to a particular component by using the `DEBUG=componium:*`
    `environment` variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config`: This is the configuration manager module that helps store and organize
    the application configuration in different formats.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these modules are quite common in server-side frameworks and other Node.js
    tools at large. For the purposes of your own framework, you can choose the packages
    we just discussed or find alternatives that better fit your use cases. Luckily,
    the Node.js ecosystem has a lot to offer in terms of ORM, logging, and testing
    solutions.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have taken a step further, from the earlier experience with
    the testing framework, by composing a brand-new server-side framework that is
    capable of routing requests, handling API calls, and much more. This supports
    our plan to develop a full stack framework that covers both frontend and backend
    features, with components interacting with each other within the same unified
    vision. Our goal was to create something that is used and reused for multiple
    application use cases and feature set combinations.
  prefs: []
  type: TYPE_NORMAL
- en: We started by defining our project’s goals, and we later developed the core
    architecture aspects of the framework. This architecture included producing features
    such as server process management, environment configuration, and database interaction.
    To enable usability and empower developer productivity, we also focused on producing
    several features that focus on developer experience.
  prefs: []
  type: TYPE_NORMAL
- en: This was the second practical exercise in our framework experience, and hopefully,
    this gives you even more confidence in your skills to develop your own frameworks.
    To take this a step further, the next chapter will focus on our final challenge
    – building frontend components for our full stack framework. The introduction
    of the frontend components in the next chapter will enable the whole full stack
    experience of our newly created framework.
  prefs: []
  type: TYPE_NORMAL
