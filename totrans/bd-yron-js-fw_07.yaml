- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Creating a Full Stack Framework
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建全栈框架
- en: In [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089), we learned a practical example
    of building a simple JavaScript testing framework. In this chapter, we will continue
    this practical approach, further diving into the development of frameworks.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第6章*](B19014_06.xhtml#_idTextAnchor089)中，我们学习了一个构建简单JavaScript测试框架的实用示例。在本章中，我们将继续这种实用方法，进一步深入框架的开发。
- en: 'The next goal is to develop a full stack framework that will enable developers
    to build large and small web applications. This chapter will start off by developing
    the backend parts of such a framework, focusing on the server-side components
    and integrating essential developer tooling. These backend components, once established,
    will help us support the frontend elements of the framework we will create in
    [*Chapter 8*](B19014_08.xhtml#_idTextAnchor138). Developing the backend feature
    set in this chapter will help us do the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个目标是开发一个全栈框架，它将使开发者能够构建大型和小型Web应用程序。本章将从开发此类框架的后端部分开始，重点关注服务器端组件和集成基本开发者工具。一旦建立这些后端组件，将帮助我们支持我们在[*第8章*](B19014_08.xhtml#_idTextAnchor138)中创建的框架的前端元素。在本章中开发后端功能集将帮助我们完成以下工作：
- en: Define the technical architecture and goals of our new full stack framework.
    This is similar to the [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089) exercise,
    but now we will switch the context and focus more on the technical challenges
    of the backend server functionality.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义我们新全栈框架的技术架构和目标。这与[*第6章*](B19014_06.xhtml#_idTextAnchor089)的练习类似，但现在我们将切换上下文，更多地关注后端服务器功能的技术挑战。
- en: Learn more about the components that are required to produce functioning full
    stack tooling. We will study and explore the abstractions we can build and the
    core parts of the framework that will make it usable in many development scenarios.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解构建功能齐全的全栈工具所需的组件。我们将研究和探索我们可以构建的抽象以及框架的核心部分，这将使其在许多开发场景中可用。
- en: Identify the features that will improve usability, focusing on the features
    that empower developers and increase efficiency. These comprise tools that help
    automatically generate the framework scaffold from a template and enhance development
    productivity.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定将提高可用性的功能，重点关注赋予开发者权力并提高效率的功能。这些包括帮助从模板自动生成框架脚手架并提高开发生产力的工具。
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The implemented framework code is in the book repository at [https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework).
    The assets and code are in the `chapter7` directory. As with [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089),
    we will utilize Node.js v20 or higher for this project.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 实现的框架代码位于本书的代码库中，网址为[https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework](https://github.com/PacktPublishing/Building-Your-Own-JavaScript-Framework)。资源和代码位于`chapter7`目录中。与[*第6章*](B19014_06.xhtml#_idTextAnchor089)一样，我们将利用Node.js
    v20或更高版本进行此项目。
- en: Refer to the `README.md` file of the framework in the chapter directory if you
    want to run or tweak the framework files locally. `npm scripts` can be handy to
    use shortcuts during development. As with other projects, to begin working on
    the framework, you need to install the dependencies with `npm install`.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想在本地运行或调整框架文件，请参阅章节目录中框架的`README.md`文件。`npm scripts`在开发期间使用快捷方式很有用。与其他项目一样，要开始工作于框架，您需要使用`npm
    install`安装依赖项。
- en: The framework provides an executable that helps create the scaffold outline
    of the project, run the newly created application, and more. To locally install
    the `componium` framework executable from the `chapter7` directory, you can link
    the executable to use it in different directories. To achieve this, from the checked-out
    repository directory, use `npm link <path>/chapter7/componium`. This will link
    a global framework executable to your terminal shell that you can use in a sample
    project. In addition, if you make any changes to the framework files, the executable
    will pick up the changes instantly, as the script is directly linked. Check out
    the detailed `npm link` instructions at [docs.npmjs.com/cli/commands/npm-link](https://docs.npmjs.com/cli/commands/npm-link)
    and the following note about Windows compatibility.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 该框架提供了一个可执行文件，有助于创建项目的框架轮廓、运行新创建的应用程序等。要从`chapter7`目录本地安装`componium`框架的可执行文件，可以将可执行文件链接到不同的目录中使用。为此，从已签出的存储库目录，使用`npm
    link <path>/chapter7/componium`。这将链接全局框架可执行文件到您的终端shell，您可以在示例项目中使用它。此外，如果您对框架文件进行了任何更改，可执行文件将立即获取这些更改，因为脚本是直接链接的。查看详细的`npm
    link`指令，链接为[docs.npmjs.com/cli/commands/npm-link](https://docs.npmjs.com/cli/commands/npm-link)以及关于Windows兼容性的以下注意事项。
- en: A note about Windows compatibility
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 关于Windows兼容性的注意事项
- en: There are a few things to keep in mind when working with framework executables
    and commands such as `npm link` in the Windows OS. When running `npm link chapter7\componium`
    or other commands, you may experience some issues with the executable environment.
    There are a few common errors that can occur, including the following.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在Windows操作系统中使用框架可执行文件和命令（如`npm link`）时，有一些事项需要注意。当运行`npm link chapter7\componium`或其他命令时，您可能会遇到一些与可执行环境相关的问题。可能会发生一些常见错误，包括以下内容。
- en: 'If you get an error related to `enoent ENOENT: no such file or directory AppData\Roaming\npm`,
    make sure to create that directory in the mentioned path. This is usually an artifact
    of the `npm` installer on Windows.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '如果您遇到与`enoent ENOENT: no such file or directory AppData\Roaming\npm`相关的错误，请确保在指定路径中创建该目录。这通常是Windows上`npm`安装程序的一个副作用。'
- en: If you get an issue with `UnauthorizedAccessException`, this is a standard security
    measure of Windows. To fix this, run `Set-ExecutionPolicy RemoteSigned` and allow
    the execution. For more information, refer to Microsoft’s documentation at [learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 如果遇到`UnauthorizedAccessException`问题，这是Windows的标准安全措施。要修复此问题，请运行`Set-ExecutionPolicy
    RemoteSigned`并允许执行。有关更多信息，请参阅Microsoft的文档，链接为[learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy](https://learn.microsoft.com/en-us/powershell/module/microsoft.powershell.security/set-executionpolicy)。
- en: You can also refer to the *Common errors* article for npm at [docs.npmjs.com/common-errors](https://docs.npmjs.com/common-errors).
    If you can successfully run `componium --version` using your PowerShell or Command
    Prompt, then your environment is correctly configured.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以参考npm的[常见错误](https://docs.npmjs.com/common-errors)文章。如果您能够成功使用PowerShell或命令提示符运行`componium
    --version`，则表示您的环境配置正确。
- en: Full stack framework goals
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全栈框架目标
- en: Before we get to the software architecture part of this project, we need to
    get a better insight into what a full stack framework will entail, especially
    in the JavaScript context and the language’s ecosystem. When developing a full
    stack JavaScript framework, we get to create a blend of abstractions and conventions
    to help developers produce a combination of frontend and backend components, given
    the modular nature of the JavaScript language and its ecosystem. From the JavaScript-language
    point of view, the framework can utilize the latest syntax and functional improvements,
    such as ES6 modules and modern web APIs. Ecosystem-wise, we will heavily rely
    on already-established modules to enable certain functionality. Similar to the
    approach in [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089), this strategy allows
    us to stay focused on the larger system design and achieve much better feature
    coverage.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们进入这个项目的软件架构部分之前，我们需要更深入地了解一个全栈框架将包含哪些内容，特别是在JavaScript环境和语言生态系统中。当开发一个全栈JavaScript框架时，我们可以创建一系列抽象和约定，以帮助开发者根据JavaScript语言及其生态系统的模块化特性，生成前端和后端组件的组合。从JavaScript语言的角度来看，框架可以利用最新的语法和功能改进，例如ES6模块和现代Web
    API。在生态系统方面，我们将大量依赖已经建立的模块来启用某些功能。类似于[*第6章*](B19014_06.xhtml#_idTextAnchor089)中的方法，这种策略使我们能够专注于更大的系统设计，并实现更好的功能覆盖。
- en: The primary objective of a full stack framework is to simplify the application
    development process, making it faster and more efficient by providing a structured
    and standardized way to build applications. We have seen examples of the variety
    of these technical solutions in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015),
    where frameworks such as Next.js create a much more streamlined and opinionated
    workflow across the whole stack. The projects, similar to Next.js, encapsulate
    all aspects of development and cover many use cases, seeking to eliminate the
    necessity of deciding on different technologies for different layers of development
    and offer a single unified vision. One of the goals of our sample framework project
    in this chapter is to focus on similar examples of developing a unified feature
    set, where components fit naturally together.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 全栈框架的主要目标是简化应用程序开发过程，通过提供一种结构化和标准化的方式来构建应用程序，使其更快、更高效。我们在[*第1章*](B19014_01.xhtml#_idTextAnchor015)中看到了这些技术解决方案的多样性，其中像Next.js这样的框架在整个栈上创建了一个更加流畅和有见地的工作流程。与Next.js类似的项目封装了开发的所有方面，覆盖了许多用例，旨在消除在不同开发层决定不同技术的必要性，并提供一个单一的统一愿景。本章中我们样本框架项目的目标之一是关注开发统一功能集的类似示例，其中组件可以自然地结合在一起。
- en: The implementation vision of the framework in this chapter should offer a unified
    API such that the developers utilizing the API can easily get acquainted with
    its structure and functionality, reducing the learning curve typically associated
    with new technology adoption. The familiarity and interoperability between different
    features ensure a seamless experience for developers. The framework API provides
    abstractions (highlighted in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030) in
    the *About abstractions* section) that make complex operations simple without
    compromising the flexibility required for advanced use cases. The approach to
    creating easy-to-use public framework API interfaces is essential to support the
    varying skill levels of developers and the requirements of robust applications.
    When you develop or support a full stack framework similar to the practical example
    in this chapter, you will also have to take a variety of features into consideration.
    You will find that in your particular scenario, you will invest more in a feature
    set that is a higher priority for your organization.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中框架的实现愿景应该提供一个统一的API，以便使用该API的开发者可以轻松熟悉其结构和功能，减少与新技术采用相关联的学习曲线。不同功能之间的熟悉度和互操作性确保了开发者能够获得无缝的体验。框架API提供了抽象（在[*第2章*](B19014_02.xhtml#_idTextAnchor030)的“关于抽象”部分中突出显示），这使得复杂操作变得简单，同时不牺牲高级用例所需的灵活性。创建易于使用的公共框架API接口的方法对于支持开发者的不同技能水平和稳健应用的需求至关重要。当你开发或支持本章中类似实际示例的全栈框架时，你也将不得不考虑各种功能。你会发现，在你的特定场景中，你将更多地投资于对你组织来说优先级更高的功能集。
- en: Looking at the server-side feature set first, a full stack JavaScript framework
    must be able to provide a set of fundamental building blocks to handle standard
    use cases, based on different technological challenges. The features powered by
    such building blocks could include request routing, database integrations, unified
    interfaces for events, logging, and performance scaling. In some cases, a framework
    can also offer features beyond what a developer requires in their projects. Therefore,
    as part of the development process, we have to strike a balance between using
    the built-in features and offering a variety of extensibility options. We have
    seen instances of this in the *Plugin and extension APIs* section of [*Chapter
    3*](B19014_03.xhtml#_idTextAnchor051), where the server-side frameworks included
    a way to extend and enable additional functionality. Besides providing a sizeable,
    flexible feature set with the best developer experience, the applications must
    be easily deployable and have a way to be monitored once operating in production
    environments. In this case, pursue a goal of making it easy for developers to
    deploy their applications, scale those applications up as they get more traffic,
    and monitor latency and error rates. This involves building in utilities to set
    up multiple server instances, defining database migrations, and more.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先查看服务器端功能集，一个全栈JavaScript框架必须能够提供一组基本构建块来处理标准用例，基于不同的技术挑战。这些由构建块驱动的功能可能包括请求路由、数据库集成、事件、日志和性能扩展的统一接口。在某些情况下，框架还可以提供超出开发者项目需求的功能。因此，作为开发过程的一部分，我们必须在使用内置功能和提供各种可扩展性选项之间取得平衡。我们在[*第3章*](B19014_03.xhtml#_idTextAnchor051)的“插件和扩展API”部分中看到了这种情况，其中服务器端框架包括扩展和启用附加功能的方法。除了提供具有最佳开发者体验的庞大、灵活的功能集外，应用程序还必须易于部署，并在生产环境中运行时能够进行监控。在这种情况下，追求的目标是使开发者能够轻松部署他们的应用程序，随着流量的增加而扩展这些应用程序，并监控延迟和错误率。这涉及到构建设置多个服务器实例的实用程序、定义数据库迁移等。
- en: As we define the expected functionality of a full stack framework, we need to
    define how much the frontend and backend features will interact with each other
    and where we would like to start the initial development. Considerations for those
    two sides of a full stack framework are explored in the next sections.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义全栈框架的预期功能时，我们需要定义前端和后端功能将如何相互交互以及我们希望从哪里开始初始开发。全栈框架这两方面的考虑将在下一节中探讨。
- en: Frontend functionality
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 前端功能
- en: On the frontend side of a full stack framework, the emphasis should be on providing
    seamless integration of frontend components that interact well with backend services.
    Examples of these types of features could be easily fetching data from the server,
    rendering frontend components, and having access to the static files. Ember.js,
    along with EmberData, provides real-world examples of how to effectively collaborate
    with server-side systems. Another example is Next.js, which provides a tightly
    integrated solution for both the server and the client. Generally, the opinionated
    components can define how the framework interacts with the data received from
    the network requests, and how the data is bound to views and components on the
    frontend.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在全栈框架的前端方面，重点应放在提供与后端服务良好交互的前端组件的无缝集成。这些类型的功能的例子可能包括轻松从服务器获取数据、渲染前端组件以及访问静态文件。Ember.js，连同EmberData，提供了如何有效地与服务器端系统协作的实例。另一个例子是Next.js，它为服务器和客户端提供了一种紧密集成的解决方案。通常，有偏见的组件可以定义框架如何与网络请求接收到的数据交互，以及数据如何绑定到前端视图和组件上。
- en: The frontend feature set should be capable of handling standard frontend requirements
    as well. These could include working with popular libraries by offering an easy
    way to integrate those libraries into projects. An extensive frontend solution
    should facilitate client-side routing and the ability to manage dependencies and
    handle form validation, user input sanitization, and JavaScript code bundling.
    Application state management is another significant component that can help manage
    the complexity of larger projects.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 前端功能集应该能够处理标准的前端需求。这可能包括通过提供一种简单的方法将库集成到项目中，来与流行的库一起工作。一个广泛的前端解决方案应该促进客户端路由，并能够管理依赖关系、处理表单验证、用户输入净化和JavaScript代码打包。应用程序状态管理是另一个重要的组件，可以帮助管理大型项目的复杂性。
- en: '![Figure 7.1: The focus of a full stack framework](img/Figure_7.1_B19014.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：全栈框架的焦点](img/Figure_7.1_B19014.jpg)'
- en: 'Figure 7.1: The focus of a full stack framework'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：全栈框架的焦点
- en: Ultimately, the process of developing a comprehensive full stack framework calls
    for the exploration of considerable facets of technology. This initiative also
    necessitates a broad spectrum of programming skills. You’ll be expected to delve
    into both the complexities of the frontend features, where you will be concerned
    with user experience, and the backend challenges, focusing on servers, databases,
    and application logic. The development process enhances your coding abilities
    and promotes a better understanding of the entire web development ecosystem. In
    *Figure 7**.1*, we break down the two important aspects of our framework development.
    The **Features** will provide the necessary functionality to build frontend and
    backend components, interacting with services such as a database, and the **Developer
    Experience** will make these features reusable and easily accessible for application
    projects. The result of all this work will be a project usable by a variety of
    stakeholders, satisfying the respective needs of developers to produce web applications
    that power new services and web-based software products.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 最终，开发一个全面的全栈框架的过程需要探索技术的许多方面。这一举措还需要广泛的编程技能。你将需要深入前端功能的复杂性，在那里你将关注用户体验，以及后端挑战，重点关注服务器、数据库和应用逻辑。开发过程将提高你的编码能力，并促进对整个Web开发生态系统的更好理解。在*图7**.1*中，我们分解了我们框架开发的两个重要方面。**功能**将提供构建前端和后端组件所需的功能，与数据库等服务进行交互，而**开发者体验**将使这些功能可重用且易于访问，适用于应用项目。所有这些工作的结果将是一个可供各种利益相关者使用的项目，满足开发者生产能够推动新服务和基于Web的软件产品的Web应用程序的需求。
- en: Backend functionality
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后端功能
- en: We start with backend feature development first. This approach will serve the
    project as a foundation to later add frontend features on top of it to complete
    the full stack feature set. We will focus on frontend features and architecture
    in the next chapter. For now, we will imagine that our backend framework can deliver
    files to the browser client and can be used with any frontend framework. Browser-based
    applications can make requests to the server-side components to fetch data, static
    files, or web pages.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先从后端功能开发开始。这种方法将为项目提供一个基础，以便稍后在其之上添加前端功能，以完成全栈功能集。在下一章中，我们将重点关注前端功能和架构。目前，我们将假设我们的后端框架可以向浏览器客户端发送文件，并且可以与任何前端框架一起使用。基于浏览器的应用程序可以向服务器端组件发出请求，以获取数据、静态文件或网页。
- en: '![Figure 7.2: Our full stack framework logo](img/Figure_7.2_B19014.png.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2：我们的全栈框架标志](img/Figure_7.2_B19014.png.jpg)'
- en: 'Figure 7.2: Our full stack framework logo'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2：我们的全栈框架标志
- en: 'We will reuse the same Componium project identity and branding that was established
    in [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089). We now have a new logo, as
    shown in *Figure 7**.2*, to serve as a branding example that identifies our full
    stack project. The Componium term and branding will cover all parts of the framework
    will be utilized in the command-line interface as well. Keeping the target developer
    user base in mind, here is a list of potential starter backend features for this
    project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重用[*第6章*](B19014_06.xhtml#_idTextAnchor089)中建立的相同Componium项目标识和品牌。我们现在有一个新的标志，如图*图7**.2*所示，作为品牌示例，以识别我们的全栈项目。Componium术语和品牌将涵盖框架的所有部分，并将被用于命令行界面。考虑到目标开发者用户群，以下是为该项目列出的一些潜在的后端入门功能：
- en: '**API deployment**: The ability to deploy an API service. The API functionality
    should be flexible enough to allow us to easily configure endpoints and add functional
    middleware to a selection of endpoints. The API capabilities should also include
    a modular approach to defining GraphQL resources and schemas.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**API部署**：部署API服务的能力。API功能应该足够灵活，使我们能够轻松配置端点并添加功能中间件到所选端点。API功能还应包括定义GraphQL资源和模式时的模块化方法。'
- en: '**Page rendering features**: The ability to deliver web pages with custom and
    reusable layouts containing static and dynamic data.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**页面渲染功能**：提供带有自定义和可重用布局的网页，其中包含静态和动态数据的能力。'
- en: '**Middleware mechanisms**: Features that can add various types of server middleware,
    such as authentication, to all or some of the routes of the application.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**中间件机制**：可以添加各种类型的服务器中间件（如身份验证）到应用程序的所有或某些路由中。'
- en: '**Database capabilities**: Database **object-relational mapping** (**ORM**)
    capabilities that provide the ability to use different types of database technologies.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**数据库功能**：提供使用不同类型数据库技术的数据库**对象关系映射**（ORM）功能。'
- en: '**Application scalability**: Designed to handle high-load situations and offer
    scalability and performance optimization options. The framework should provide
    the necessary tools to test, debug, and deploy an application.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序可伸缩性**：设计用于处理高负载情况并提供可伸缩性和性能优化选项。该框架应提供必要的工具来测试、调试和部署应用程序。'
- en: '**Development tools**: The framework offers a variety of helpers to ease the
    development process. The tools can include application bootstrapping and scaffolding
    of standard components. Live-reloading of the backend server can also save a lot
    of time by avoiding manually restarting the process on every change.'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**开发工具**：该框架提供各种辅助工具以简化开发过程。这些工具可能包括应用程序引导和标准组件的脚手架搭建。通过避免每次更改手动重启进程，实时重新加载后端服务器也可以节省大量时间。'
- en: These functionality goals are now defined in enough detail, covering both the
    frontend and backend experiences. Utilizing the considerations in this section,
    we are ready to proceed to the exciting steps of architecting the initial parts
    of the full stack framework.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能目标现在定义得足够详细，涵盖了前端和后端体验。利用本节中的考虑因素，我们已准备好进入构建全栈框架初始部分的激动人心的步骤。
- en: Architecture
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 架构
- en: Now that we have a clearer definition of the backend features, we can start
    architecting the packages and components of the framework. We will need encapsulation
    for server and routing interfaces, as well as additional components that allow
    us to communicate with databases, fetch particular application configurations,
    and report metrics or logs through logging.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对后端功能有了更清晰的定义，我们可以开始设计框架的包和组件。我们需要对服务器和路由接口进行封装，以及额外的组件，使我们能够与数据库通信，获取特定应用程序配置，并通过日志记录报告指标或日志。
- en: '![Figure 7.3: The request life cycle](img/Figure_7.3_B19014.png.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图7.3：请求生命周期](img/Figure_7.3_B19014.png.jpg)'
- en: 'Figure 7.3: The request life cycle'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3：请求生命周期
- en: '*Figure 7**.3* represents a simplified view of the request life cycle that
    our framework will process. The requests can originate in a browser client or,
    potentially, be direct requests to an API endpoint of the server that our framework
    needs to handle. You can find a sample application built using our framework in
    the chapter directory under `tests/sample`.'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.3* 表示了我们框架将处理的请求生命周期的简化视图。请求可以来自浏览器客户端，或者可能是直接请求到我们框架需要处理的服务的API端点。您可以在章节目录下的
    `tests/sample` 中找到使用我们框架构建的示例应用程序。'
- en: '![Figure 7.4: A sample application layout](img/Figure_7.4_B19014.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图7.4：一个示例应用程序布局](img/Figure_7.4_B19014.jpg)'
- en: 'Figure 7.4: A sample application layout'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.4：一个示例应用程序布局
- en: We now have an overview of how a framework processes requests through its internals.
    *Figure 7**.4* shows an example of an application layout, consisting of the backend
    API and GraphQL routes. Developers can utilize this structure to build different
    types of server-side applications. In the following sections, we will take an
    in-depth look at the entry points, router, configuration, database, and observability
    features that make this application layout possible. You can find the files in
    the chapter directory under `componium/tests/sample`. Some of the files, such
    as the `*.log` files, will automatically generate when the application starts
    and produces some logging; normally, these log files are ignored by the version
    control system.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在对框架如何通过其内部处理请求有一个概述。*图7.4* 展示了一个应用程序布局的示例，包括后端API和GraphQL路由。开发者可以利用这种结构来构建不同类型的后端应用程序。在接下来的章节中，我们将深入探讨使这种应用程序布局成为可能的入口点、路由器、配置、数据库和可观察性功能。您可以在章节目录下的
    `componium/tests/sample` 中找到文件。其中一些文件，如 `*.log` 文件，将在应用程序启动并产生一些日志时自动生成；通常，这些日志文件会被版本控制系统忽略。
- en: Entry point
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 入口点
- en: The server file is the entry point to provide most of the capabilities of our
    backend framework. It bootstraps a process, loads the appropriate configuration,
    connects to a database if specified, and establishes the request route handlers.
    In [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089), we had a simpler server (located
    in the project file at `componium-test/blob/main/packages/browser/server.js`),
    developed using the `http.createServer(...)` Node.js APIs. We can follow the same
    strategy and build a new server from scratch. However, for a full stack framework,
    we need a more established solution that has many server interfaces already in
    place. An excellent middle-ground choice for this project is to use the `express`
    module and create abstractions on top of it. *Express* will allow us to define
    middleware, custom routers, parse requests, craft API responses, and much more.
    If this sounds familiar, this is because this is a similar architecture to the
    NestJS framework project previewed in [*Chapter 4*](B19014_04.xhtml#_idTextAnchor063).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器文件是我们后端框架提供大部分功能的入口点。它启动一个进程，加载适当的配置，如果指定则连接到数据库，并建立请求路由处理程序。在[*第6章*](B19014_06.xhtml#_idTextAnchor089)中，我们有一个更简单的服务器（位于项目文件`componium-test/blob/main/packages/browser/server.js`），使用`http.createServer(...)`
    Node.js API开发。我们可以遵循相同的策略，从头开始构建一个新的服务器。然而，对于一个全栈框架，我们需要一个更成熟的解决方案，它已经提供了许多服务器接口。对于这个项目，一个很好的折中方案是使用`express`模块并在其之上创建抽象。*Express*将允许我们定义中间件、自定义路由器、解析请求、构建API响应等。如果这听起来很熟悉，这是因为这与[*第4章*](B19014_04.xhtml#_idTextAnchor063)中预览的NestJS框架项目架构相似。
- en: 'To expand the server functionality, we will also allow developers to create
    multiple servers in the same application context, like so:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了扩展服务器功能，我们还将允许开发者在同一应用程序上下文中创建多个服务器，如下所示：
- en: '[PRE0]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: With the server interfaces in place, we can now accept requests on a port and
    configure the servers with options that fit our requirements. Once the server
    is created, as seen in the preceding code, the main purpose of it is to handle
    endpoints and perform backend tasks. For the purposes of handling endpoints, we
    will introduce the *router* interface. It comes into play to accept requests and
    enable the API features.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在服务器接口就绪后，我们现在可以在端口上接受请求，并使用符合我们要求的选项配置服务器。一旦创建服务器，如前述代码所示，其主要目的是处理端点并执行后端任务。为了处理端点，我们将引入*路由*接口。它在接受请求并启用API功能时发挥作用。
- en: Router
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 路由器
- en: In this framework, we want to provide options for file-based and dynamic routing.
    This involves using a similar feature to file-based routers in Next.js. We saw
    this concept in the overview of the building blocks in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030).
    The router implementations can be found in the server package of the framework
    – for example, the file-based router is in `packages/server/file-router.js`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个框架中，我们希望提供基于文件和动态路由的选项。这涉及到使用与Next.js中基于文件的路由器类似的功能。我们在[*第2章*](B19014_02.xhtml#_idTextAnchor030)的构建块概述中看到了这个概念。路由器的实现可以在框架的服务器包中找到
    – 例如，基于文件的路由器在`packages/server/file-router.js`。
- en: The file-based router implementation is capable of recursively loading API endpoints
    from a directory structure. The file-based feature allows for some manual configuration.
    By default, the framework can look in a `routes` directory of a project. However,
    that can be adjusted by passing a file-router directory option to the server configuration.
    For details on the implementation of a file-based router, refer to the following
    package – `packages/server/file-router.js`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 基于文件的路由实现能够从目录结构中递归地加载API端点。基于文件的功能允许进行一些手动配置。默认情况下，框架可以在项目的`routes`目录中查找。然而，这可以通过向服务器配置传递文件路由目录选项来调整。有关基于文件的路由实现详情，请参考以下包
    – `packages/server/file-router.js`。
- en: As we need to handle different HTTP methods in our file router, we can establish
    a pattern for the HTTP methods. This way, if you make a `POST` or `DELETE` request,
    you are still able to indicate what type of HTTP method the file should respond
    to. To enable this functionality, we will configure the framework to handle files
    in the following manner. Files ending with a `.post.js` will indicate that this
    route is a `POST` method route. Files omitting this configuration will default
    to a `GET` handler. To handle index or root endpoint routes, we will use an `_index.js`
    file. This indicates that it is the root handler. For example, the `api/` directory
    can have the `_index.js` file, which will handle the requests to the root endpoint
    of the API. Refer to *Figure 7**.4* to see the directory structure of the `api/`
    directory. You can find an example of this in the sample application in the GitHub
    repository at `componium/tests/sample/routes/api/_index.js`.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要在文件路由中处理不同的HTTP方法，我们可以为HTTP方法建立一个模式。这样，如果你发起一个`POST`或`DELETE`请求，你仍然能够表明文件应该响应哪种类型的HTTP方法。为了启用此功能，我们将配置框架以以下方式处理文件。以`.post.js`结尾的文件将表示此路由是一个`POST`方法路由。省略此配置的文件将默认为`GET`处理器。为了处理索引或根端点路由，我们将使用一个`_index.js`文件。这表示它是根处理器。例如，`api/`目录可以有一个`_index.js`文件，它将处理对API根端点的请求。请参阅*图7**.4*以查看`api/`目录的目录结构。你可以在GitHub仓库的示例应用程序中找到这个例子，网址为`componium/tests/sample/routes/api/_index.js`。
- en: 'Besides file-based routing, developers will sometimes need to define the routes
    and modular routers directly or programmatically in their code. To support those
    use cases, our framework offers several server methods to allow flexibility around
    routes, middlewares, and custom routers, as shown in the following code block:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了基于文件的路由之外，开发者有时需要在他们的代码中直接或通过编程方式定义路由和模块化路由器。为了支持这些用例，我们的框架提供了几个服务器方法，以允许在路由、中间件和自定义路由器周围具有灵活性，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Reading the preceding middleware code, we can see some of the methods that our
    framework offers to enable dynamic routing. Backed by the primitives from the
    `express` package, we can create a more abstract system that provides a custom
    way to describe router definitions. As always, it also allows us to swap out the
    `express` module in favor of something else later on if required. The `addRoute`
    methods are present on both the server and custom router objects. These allow
    us to add custom route handlers instead of using file-based handlers. The `addRoute`
    function takes an argument of the route path and a function that has request/response
    arguments, used to process the request. This route-handling flow is visualized
    in the preceding code, which creates a server middleware, a new route, and an
    additional router with its own routing entities. Further details on router capabilities
    can be found at [expressjs.com/en/guide/routing.html](https://expressjs.com/en/guide/routing.html).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 阅读前面的中间件代码，我们可以看到我们的框架提供的某些方法，以启用动态路由。在`express`包的原始基础上，我们可以创建一个更抽象的系统，它提供了一种自定义的方式来描述路由定义。一如既往，它也允许我们在需要时替换`express`模块。`addRoute`方法存在于服务器和自定义路由器对象上。这些允许我们添加自定义路由处理器，而不是使用基于文件的处理器。`addRoute`函数接受一个路由路径和一个具有请求/响应参数的函数作为参数，用于处理请求。这个路由处理流程在上面的代码中得到了可视化，它创建了一个服务器中间件、一个新的路由以及一个具有自己的路由实体的额外路由器。有关路由器功能的更多详细信息，请参阅[expressjs.com/en/guide/routing.html](https://expressjs.com/en/guide/routing.html)。
- en: In addition to routing methods, we have additional middleware management functions,
    such as `addMiddleware`. These methods allow us to configure any self-developed
    or external middleware. In this case, it makes our framework compatible with other
    express-based middleware. For example, we can use it to add authentication to
    our endpoints using the `passport` module ([github.com/jaredhanson/passport](https://github.com/jaredhanson/passport));
    this will enable the framework to support a huge variety of authentication options.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了路由方法之外，我们还有额外的中间件管理函数，例如`addMiddleware`。这些方法允许我们配置任何自开发的或外部中间件。在这种情况下，它使我们的框架与基于express的中间件兼容。例如，我们可以使用它通过`passport`模块（[github.com/jaredhanson/passport](https://github.com/jaredhanson/passport)）对我们的端点添加身份验证；这将使框架能够支持大量的身份验证选项。
- en: The established architecture of the router and entry points allows us to actually
    create an application process that can accept requests. In the following subsections,
    we will define the ability to configure different components of our framework.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器和入口点的既定架构使我们能够实际创建一个可以接受请求的应用程序进程。在以下小节中，我们将定义配置我们框架不同组件的能力。
- en: Configuration
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置
- en: Developers expect a clean way to configure a framework-based application, with
    capabilities to run it in local, test, and production environments. To enable
    this, we will utilize the `config` package (located at [npmjs.com/package/config](https://npmjs.com/package/config)).
    This package will allow us to elegantly organize the configuration options and
    let the application code base behave differently, based on the environment.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者期望有一种干净的方式来配置基于框架的应用程序，并具有在本地、测试和生产环境中运行它的能力。为了实现这一点，我们将利用`config`包（位于[npmjs.com/package/config](https://npmjs.com/package/config)）。这个包将允许我们优雅地组织配置选项，并让应用程序代码库根据环境表现出不同的行为。
- en: 'To provide a simple example, if we had only one property to configure, then
    our configuration file, `default.json`, would look something like this:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 以一个简单的例子来说明，如果我们只有一个属性需要配置，那么我们的配置文件`default.json`可能看起来像这样：
- en: '[PRE2]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'With the `config` package, we can access the configuration in any of the framework
    modules and allow it to be used for any developer purposes from within the code
    base:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`config`包，我们可以在框架的任何模块中访问配置，并允许它在代码库内用于任何开发目的：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `config` package automatically loads the required file and allows us to
    fetch data out of that configuration storage and access all the set properties.
    In the preceding configuration code, we get to fetch the database connection URL
    that can be used to bootstrap the database connection from the application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`config` 包自动加载所需的文件，并允许我们从配置存储中获取数据，访问所有设置的属性。在先前的配置代码中，我们可以获取用于启动数据库连接的数据库连接URL。'
- en: As with other modules, we can create abstraction on the `config` package. However,
    we want to offer the core features of the package for developers’ use. The `config`
    package supports several file formats for application configuration, such as YAML
    ([yaml.org](https://yaml.org)), JSON, or straight-up JavaScript. Providing a choice
    of formats is helpful, as it enables us to meet the requirements of the application
    deployment tools. For example, developer operations might prefer to structure
    all the production configurations with YAML files.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他模块一样，我们可以在`config`包上创建抽象。然而，我们希望为开发者提供包的核心功能。`config`包支持多种应用程序配置文件格式，如YAML
    ([yaml.org](https://yaml.org))、JSON或纯JavaScript。提供格式选择是有帮助的，因为它使我们能够满足应用程序部署工具的要求。例如，开发者运营可能更喜欢使用YAML文件来结构化所有生产配置。
- en: Configuring aspects of applications within a framework can become remarkably
    complex, due to the variety of configuration formats and methods available. The
    JavaScript ecosystem provides dozens of packages that can help you with configuration.
    Try to evaluate some of them to find the one that fits your needs best. Consider
    the types of configuration file extensions that a package supports and what kind
    of validation it can perform. Furthermore, in the following subsection, we will
    highlight how your framework should offer a set of defaults that work for your
    users.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在框架内配置应用程序的各个方面可能会变得非常复杂，因为可用的配置格式和方法种类繁多。JavaScript生态系统提供了数十个可以帮助你进行配置的包。尝试评估其中的一些，以找到最适合你需求的那个。考虑一个包支持的配置文件扩展类型以及它可以执行什么样的验证。此外，在以下小节中，我们将强调你的框架应该如何提供一组适用于用户的默认值。
- en: Sensible defaults
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 合理的默认值
- en: '`config` package features will allow us to specify the defaults in the `default.js`
    file. This file will act as a template for an application’s configuration. The
    configuration file can also be scaffolded in different ways; we will look into
    this further in the *Developer* *experience* section.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`config` 包的功能将允许我们在`default.js`文件中指定默认值。此文件将作为应用程序配置的模板。配置文件也可以以不同的方式构建；我们将在*开发者*
    *体验*部分进一步探讨这一点。'
- en: Reducing the amount of configuration in your framework is something to strive
    for. It is key to creating a consistent experience and reducing the burdens of
    building new projects with your framework.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 减少框架中的配置量是值得追求的。这是创建一致体验和减轻使用框架构建新项目负担的关键。
- en: Database
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库
- en: As we add the `database` functionality to our framework, we need to make sure
    to support a wide variety of databases. The project should also offer a unified,
    abstract way to work with database objects. To support these use cases, we can
    rely on a higher abstract library that enables ORM. For this chapter’s example,
    we will rely on an open source ORM library called **Sequelize** ([sequelize.org](https://sequelize.org)).
    This library gives us support for MySQL, PostgreSQL, and MSSQL out of the box.
    It also enables us to use SQLite in local development and other environments,
    which makes it really easy to work with database operations and not connect to
    more complex database services. An ORM library such as Sequelize will add capabilities
    to interact with a database using JavaScript. It will allow us to treat database
    entities as objects, simplifying data manipulation and extraction.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们向框架添加`database`功能，我们需要确保支持多种数据库。项目还应提供一种统一、抽象的方式来处理数据库对象。为了支持这些用例，我们可以依赖一个支持ORM的更高抽象库。在本章的示例中，我们将依赖一个名为**Sequelize**的开源ORM库（[sequelize.org](https://sequelize.org)）。这个库为我们提供了MySQL、PostgreSQL和MSSQL的原生支持。它还使我们能够在本地开发和其它环境中使用SQLite，这使得数据库操作变得非常容易，而不需要连接到更复杂的数据库服务。像Sequelize这样的ORM库将添加使用JavaScript与数据库交互的能力。它将允许我们将数据库实体视为对象，简化数据操作和提取。
- en: In Componium, the database interface can be found in the `db` package. While
    some parts of interaction with Sequelize are abstracted, we still rely on the
    users of our framework to get familiar with the library and its features directly.
    It is common to see large frameworks rely on separate ORM layers, due to the fact
    that implementing and supporting several database engines requires a lot of investment
    in code and time.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在Componium中，数据库接口可以在`db`包中找到。虽然与Sequelize交互的一些部分被抽象化，但我们仍然依赖框架的用户直接熟悉这个库及其功能。由于实现和支持多个数据库引擎需要大量的代码和时间投资，因此看到大型框架依赖于单独的ORM层是很常见的。
- en: 'When a new application is initialized in code, a framework automatically tries
    to make a connection to the configured database. To operate with database entities,
    the application needs to load the model files. In the Componium framework, the
    models are stored in the `models` directory and loaded during the initialization
    as well. This application structure allows framework users to keep data models
    organized and modular. The models can then be used within your route handlers
    to interact with the database, whether you need to create, read, update, or delete
    data. Here’s an example of a model we can use in the app:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 当在代码中初始化新应用程序时，框架会自动尝试连接到配置的数据库。为了与数据库实体操作，应用程序需要加载模型文件。在Componium框架中，模型存储在`models`目录中，并在初始化时加载。这种应用程序结构允许框架用户保持数据模型有组织和模块化。然后，您可以在路由处理程序中使用这些模型与数据库交互，无论是创建、读取、更新还是删除数据。以下是我们可以在应用程序中使用的模型示例：
- en: '[PRE4]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To get access or mutate this model in our route handlers, we can use the `componium`
    object to get to the database entity object and perform an operation:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 要在我们的路由处理程序中访问或修改此模型，我们可以使用`componium`对象来获取数据库实体对象并执行操作：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding code, located in the application under `sample/api/packages.js`,
    queries the packages stored in the `Package` model. Finally, it returns all the
    objects found in a query in the route handler. For the purposes of this chapter,
    the database implementation is fairly simple, but you can take up the challenge
    to make the code more accommodating to handle multiple databases and improve model
    file coupling if desired.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 之前代码位于应用程序的`sample/api/packages.js`中，它查询存储在`Package`模型中的包。最后，它在路由处理程序中返回查询中找到的所有对象。在本章中，数据库实现相当简单，但如果愿意，你可以接受挑战，使代码更适应处理多个数据库并提高模型文件耦合度。
- en: GraphQL support
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GraphQL支持
- en: In addition to the several options to define API endpoints, our framework also
    supports **GraphQL**, a powerful query language that is useful for backend data
    retrieval. Some developers might prefer to use GraphQL with our framework, and
    they should have good experience in integrating this system.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 除了定义API端点的几种选项之外，我们的框架还支持**GraphQL**，这是一种强大的查询语言，对于后端数据检索非常有用。一些开发者可能更喜欢在我们的框架中使用GraphQL，并且他们应该有良好的集成此系统的经验。
- en: 'The GraphQL module can be found in the chapter files under `packages/server/graphql.js`.
    Following a similar design for a file-based router, the `componium` framework
    has a feature to make it easier to develop modular schemas for GraphQL. These
    schemas can be defined in separate files and later assembled into full schemas
    that are supported by every Componium server object. Every GraphQL type definition
    can be defined in its own `*.gql.js` file. Here’s an example of a `packages.gql.js`
    file:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: GraphQL模块可以在`packages/server/graphql.js`的章节文件中找到。遵循类似文件路由的设计，`componium`框架有一个特性，使其更容易为GraphQL开发模块化模式。这些模式可以在单独的文件中定义，稍后组装成由每个Componium服务器对象支持的完整模式。每个GraphQL类型定义都可以在其自己的`*.gql.js`文件中定义。以下是一个`packages.gql.js`文件的示例：
- en: '[PRE6]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'First, we define a sample definition for the package type so that we can query
    the data for that particular model:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为包类型定义一个示例定义，以便我们可以查询该特定模型的数据：
- en: '[PRE7]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding code uses the schema definition for a Package type that queries
    the entries for the objects related to the `Package` model, retrieving all the
    stored packages in the database. The `.findAll()` call is the built-in interface
    related to the ORM package that is used under the hood.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码使用了包类型的模式定义，该定义查询与`Package`模型相关的对象的条目，检索数据库中存储的所有包。`.findAll()`调用是底层的ORM包内置的接口。
- en: '![Figure 7.5: An Apollo GraphQL sandbox request](img/Figure_7.5_B19014.png.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图7.5：Apollo GraphQL沙盒请求](img/Figure_7.5_B19014.png.jpg)'
- en: 'Figure 7.5: An Apollo GraphQL sandbox request'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5：Apollo GraphQL沙盒请求
- en: The database items can now be retrieved using the query language. *Figure 7**.5*
    shows an interface of the `@apollo/server` package. GraphQL support can be enabled
    or disabled by specifying the `gql` option when we create new Componium servers,
    by calling the `app.createServer({gql:` `false})` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在可以使用查询语言检索数据库项。*图7*.*5*显示了`@apollo/server`包的界面。通过在创建新的Componium服务器时指定`gql`选项，可以通过调用`app.createServer({gql:`
    `false})`方法来启用或禁用GraphQL支持。
- en: If you are looking to learn more about GraphQL, check out some of the publications
    related to it at [packtpub.com/search?query=graphql&products=Book](https://packtpub.com/search?query=graphql&products=Book),
    especially the *Full Stack Web Development with GraphQL and React* book. Many
    aspects of GraphQL can get really complex quickly, but it is a good example of
    a feature you can add to your framework to enable a powerful query language based
    on an established specification.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于GraphQL的信息，可以查看[packtpub.com/search?query=graphql&products=Book](https://packtpub.com/search?query=graphql&products=Book)上与之相关的出版物，特别是《使用GraphQL和React进行全栈Web开发》这本书。GraphQL的许多方面可能会迅速变得非常复杂，但它是一个很好的例子，说明你可以将这个特性添加到你的框架中，以实现基于既定规范的强大查询语言。
- en: The next subsection focuses on observability, which will help to make sure the
    GraphQL feature works properly in applications and we can acquire enough visibility
    into the internals of the projects using logging.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节重点介绍可观察性，这将有助于确保GraphQL特性在应用程序中正常工作，并且我们可以通过日志记录获得足够的项目内部可见性。
- en: Observability
  id: totrans-94
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察性
- en: The final feature that is worth highlighting has to deal with **observability**.
    Our framework should offer an interface to allow developers to log essential operations
    to a file. The framework itself should automatically log any sensitive operations
    that the developer should be aware of.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 值得特别强调的最后一个特性是**可观察性**。我们的框架应该提供一个接口，允许开发者将关键操作记录到文件中。框架本身应该自动记录开发者应该注意的任何敏感操作。
- en: This is where the *winston*-based `Logger` class comes into play; you can find
    the implementation in the framework’s `packages/app/logger.js` file. winston ([github.com/winstonjs/winston](https://github.com/winstonjs/winston))
    is a logging library that can output the logs in flexible ways and is compatible
    with various deployment environments. It provides a simple and straightforward
    interface for logging, allowing developers to easily incorporate logging into
    their applications with minimal effort. This not only ensures that developers
    have granular control over what gets logged but also standardizes the way logs
    are generated across an application.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是基于*winston*的`Logger`类发挥作用的地方；你可以在框架的`packages/app/logger.js`文件中找到其实现。winston
    ([github.com/winstonjs/winston](https://github.com/winstonjs/winston))是一个可以以灵活方式输出日志的日志库，并且与各种部署环境兼容。它提供了一个简单直观的日志记录接口，允许开发者以最小的努力将日志记录轻松集成到他们的应用程序中。这不仅确保了开发者可以对记录的内容有细粒度的控制，而且也标准化了整个应用程序中日志的生成方式。
- en: 'The logger class is designed to be flexible with respect to the logging environment.
    It is configured to log to a console in non-production environments, allowing
    for real-time debugging during the development stages. In production, the logs
    are written to specified files, providing a permanent record of the application’s
    operation and behavior that can be referred back to when needed. This separation
    of environments also provides a level of safety, ensuring that sensitive data
    is not inadvertently exposed during development. These logs can then be used to
    diagnose and troubleshoot issues, enhancing the observability and reliability
    of the application. As discussed in the *GraphQL support* section earlier, we
    will use the logger to keep track of the found packages:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 日志记录器类旨在对日志环境具有灵活性。它被配置为在非生产环境中将日志记录到控制台，允许在开发阶段进行实时调试。在生产中，日志将被写入指定的文件，提供应用程序操作和行为的永久记录，在需要时可以参考。这种环境分离还提供了一定程度的安全性，确保在开发过程中不会意外泄露敏感数据。这些日志可以用来诊断和排除问题，增强应用程序的可观察性和可靠性。如之前在
    *GraphQL 支持* 部分讨论的，我们将使用日志记录器来跟踪找到的包：
- en: '[PRE8]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In development mode, this logger will provide information in the terminal console;
    this way, this information can effortlessly be seen during the feature development
    phase. Once the application is deployed and running in the production environment,
    it will log into the `error.log` and `combined.log` files. The format of the logs
    in those files will be JSON, such as the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发模式下，这个日志记录器将在终端控制台中提供信息；这样，在功能开发阶段可以轻松地看到这些信息。一旦应用程序部署并运行在生产环境中，它将记录到 `error.log`
    和 `combined.log` 文件中。这些文件中的日志格式将是 JSON，如下所示：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This `logger` class has the interface to log `.info`, `.warn`, and `.error`
    messages. It will empower developers by providing a way to keep track of the application
    behavior, debug issues, and store necessary logs that can later be parsed.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `logger` 类提供了记录 `.info`、`.warn` 和 `.error` 消息的接口。它将通过提供一种跟踪应用程序行为、调试问题和存储必要日志的方法来赋予开发者权力，这些日志可以在以后被解析。
- en: Concluding the *Architecture* section, we now have insight into entry points,
    routing, logging, database, and endpoint support. These are plenty of features
    for the first iteration of the project. Further, we will connect these features
    with an improved developer experience.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在总结 *架构* 部分时，我们现在对入口点、路由、日志记录、数据库和端点支持有了深入了解。这些都是项目第一迭代中的大量功能。进一步来说，我们将把这些功能与改进的开发者体验相结合。
- en: Developer experience
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者体验
- en: With several essential backend features built, we can now focus on the developer
    experience aspects. Earlier referenced in *Figure 7**.1*, this is the second important
    aspect of the framework we will focus on. The goal behind introducing framework-adjacent
    developer tools is to lessen the friction of adapting the features of our framework.
    It also helps to streamline the experience and create a unified way to work with
    the framework’s primitives.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建了几个基本的后端功能之后，我们现在可以专注于开发者体验方面。如之前在 *图 7**.1* 中提到的，这是框架我们将关注的第二个重要方面。引入框架相关开发者工具背后的目标是减少适应我们框架特性的摩擦。它还有助于简化体验，并创建一种统一的方式来与框架的原始功能协同工作。
- en: To enable most of this experience, we will rely on the `componium` executable
    that ships with the framework when it is installed. This executable will take
    care of a lot of mundane tasks, such as initializing applications and scaffolding
    standard components. It will also eliminate common points of friction by enabling
    features such as live server reload.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启用大部分这种体验，我们将在框架安装时依赖随框架一起提供的 `componium` 可执行文件。这个可执行文件将负责许多日常任务，例如初始化应用程序和构建标准组件。它还将通过启用如实时服务器重新加载等特性来消除常见的摩擦点。
- en: In the next three subsections, we will explore three potential developer experience
    offerings that you can provide to the users of your framework.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的三个小节中，我们将探讨三种潜在的面向开发者的体验提供方案，您可以将这些方案提供给框架的用户。
- en: Bootstrapping a new application
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引导新的应用程序
- en: The Componium framework’s `componium` executable shipped with the library simplifies
    the process of bootstrapping a new application. Rather than setting up a new application
    from scratch, the developer can just run the `npx componium init` command. This
    command will provide options to create a basic project structure with all the
    necessary configurations and dependencies set up. The initialization process saves
    a significant amount of time and ensures consistency across different projects
    built using the framework. The command has the flexibility to accept parameters
    such as `npx componium init my-app` to create a new application structure in the
    `my-app` directory. The `init` feature is great for developers, since it automates
    the repetitive and error-prone process of creating new applications from nothing.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: Componium框架中附带的可执行文件`componium`简化了启动新应用程序的过程。开发者无需从头开始设置新应用程序，只需运行`npx componium
    init`命令即可。此命令将提供选项以创建具有所有必要配置和依赖项的基本项目结构。初始化过程可以节省大量时间并确保使用该框架构建的不同项目之间的一致性。该命令具有接受参数的灵活性，例如`npx
    componium init my-app`，在`my-app`目录中创建新的应用程序结构。对于开发者来说，`init`功能非常出色，因为它自动化了从无到有创建新应用程序的重复和易出错的流程。
- en: Making this bootstrapping process easy is key for new developers to get started
    using the framework. Looking back to [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015),
    you will find that almost every framework offers one or several ways of bootstrapping
    projects, using a CLI tool or a similar mechanism.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使此启动过程变得简单对于新开发者开始使用该框架至关重要。回顾[*第1章*](B19014_01.xhtml#_idTextAnchor015)，你会发现几乎每个框架都提供一种或几种启动项目的方法，使用CLI工具或类似机制。
- en: Scaffolding
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 搭建
- en: To continue on the theme of reducing error-prone tasks, scaffolding is a highly
    beneficial feature that further enhances the developer experience. It allows developers
    to automatically generate boilerplate code for components that are supported by
    the framework. In the framework exercise of this chapter, we will support creating
    things such as models, GraphQL schemas, and routes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 为了继续探讨减少易出错任务的主题，搭建是一个高度有益的功能，它进一步增强了开发者体验。它允许开发者自动为框架支持的组件生成样板代码。在本章的框架练习中，我们将支持创建诸如模型、GraphQL模式、路由等事物。
- en: '![Figure 7.6: An example of the scaffolding experience](img/Figure_7.6_B19014.png.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图7.6：搭建体验示例](img/Figure_7.6_B19014.png.jpg)'
- en: 'Figure 7.6: An example of the scaffolding experience'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.6：搭建体验示例
- en: '*Figure 7**.6* showcases the developer experience when running the framework
    executable to scaffold some new components inside of new applications. A highly
    detailed description can be provided for each option that helps explain the potential
    options of each operation. The `create` command can also support a direct set
    of parameters to avoid the `Select` interface for more advanced users of the framework.
    The scaffolding commands can demonstrate best practices and quickly teach developers
    about the framework’s capabilities.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '*图7.6*展示了运行框架可执行文件以在新应用程序内部搭建一些新组件时的开发者体验。可以为每个选项提供高度详细说明，以帮助解释每个操作的潜在选项。`create`命令还可以支持直接设置参数，以避免框架高级用户使用`Select`界面。搭建命令可以展示最佳实践并快速教会开发者关于框架功能的知识。'
- en: In addition, the new project initialization scaffolding options can include
    the framework features a developer wants to use. For example, they can choose
    the defaults or customize the project and choose their database type, enable GraphQL
    support, opt in for the file-based router, and so on. To successfully perform
    this workflow step, the framework has to provide clear instructions related to
    initializing and setting up the project.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，新的项目初始化搭建选项可以包括开发者想要使用的框架功能。例如，他们可以选择默认设置或自定义项目，并选择他们的数据库类型，启用GraphQL支持，选择基于文件的路由器等。要成功执行此工作流程步骤，框架必须提供有关初始化和设置项目的清晰说明。
- en: Scaffolding is super common in many projects and is a must-have for new projects.
    In some cases, the scaffolding features can ship separately from the main project.
    However, providing the ability to scaffold greatly improves interaction with your
    framework.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 搭建在许多项目中都非常常见，对于新项目来说是必备的。在某些情况下，搭建功能可以与主项目分开提供。然而，提供搭建能力可以极大地提高与框架的交互。
- en: File watching
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件监控
- en: File watching is another valuable feature provided by the `componium` executable.
    In this case, it’s used for internal usage via the `componium dev` command. This
    feature watches for changes in the source code files of the application. It later
    automatically rebuilds and restarts the server whenever a change is detected.
    This means that developers can see the results of their changes faster and iterate
    faster. This file-watching infrastructure will come in handy as we further develop
    the backend features of the framework. It can also be beneficial for the next
    chapter, where we introduce frontend components that will need to be rebuilt as
    they are iterated upon.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 文件监视是`componium`可执行文件提供的另一个有价值的功能。在这种情况下，它通过`componium dev`命令用于内部使用。此功能监视应用程序源代码文件中的更改。一旦检测到更改，它将自动重新构建并重新启动服务器。这意味着开发者可以更快地看到他们更改的结果，并更快地进行迭代。随着我们进一步开发框架的后端功能，这种文件监视基础设施将非常有用。它也可以对下一章有益，在那里我们将介绍需要随着迭代而重新构建的前端组件。
- en: The combination of these features – easy initialization, detailed code scaffolding,
    and file watching – creates an excellent developer experience, as it allows developers
    to focus on the project’s requirements. We shall see how these developer features
    are relevant in the next section, as they relate to an example workflow utilizing
    our newly developed framework.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这些功能的组合——易于初始化、详细的代码脚手架和文件监视——为开发者创造了一个出色的体验，因为它允许开发者专注于项目需求。我们将在下一节中看到这些开发者功能的相关性，因为它们与利用我们新开发的框架的示例工作流程相关。
- en: The three examples of improvements to the developer experience help to define
    the specific tasks in which framework authors can invest. These enhancements aim
    to improve the overall usability of the project. In the next section, the workflow
    that we will discuss how these scaffolding and file-watching tools can be utilized
    and accompany the framework project and makes it more pleasant to use.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 三个改进开发者体验的示例有助于定义框架作者可以投资的特定任务。这些增强旨在提高项目的整体可用性。在下一节中，我们将讨论如何利用这些脚手架和文件监视工具，以及它们如何伴随框架项目，使其使用更加愉快。
- en: Developer workflow
  id: totrans-121
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开发者工作流程
- en: In the previous sections of the chapter, we identified the project goals, developed
    the architecture, and described a few sample features of the framework. In this
    workflow section, let us summarize how developers can take advantage of the project
    and understand their workflow.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的前几节中，我们确定了项目目标，开发了架构，并描述了框架的一些示例功能。在本节工作流程中，让我们总结一下开发者如何利用项目并了解他们的工作流程。
- en: Here are the parts of the workflow, including some of the steps required on
    the framework developer side to make the project available for consumption.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是工作流程的各个部分，包括框架开发者侧需要执行的一些步骤，以使项目可供使用。
- en: Framework distribution
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架分发
- en: A newly created JavaScript framework is published publicly or privately on the
    `npm` package registry. When a framework author wants to keep the project fully
    private, it can be consumed from a private Git repository within the internal
    infrastructure. This whole framework package includes a `README` file and framework
    documentation that helps external developers start building a new application.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的JavaScript框架在`npm`包注册库中公开发布或私下发布。当框架作者希望将项目完全保持私密时，它可以从内部基础设施中的私有Git仓库中消费。整个框架包包括一个`README`文件和框架文档，这些文档有助于外部开发者开始构建新的应用程序。
- en: New project requirements
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新项目需求
- en: To use an example of framework usage, a developer wants to build a sample application
    that keeps track of packages. The system needs to be able to list inbound and
    outbound packages, change the properties of those packages, and add and remove
    new ones. Ultimately, the developer would like to enable these features and deploy
    them to a remote environment, where the application interacts with a production/staging
    database environment.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以框架使用的一个例子来说，开发者想要构建一个跟踪包的示例应用程序。系统需要能够列出进站和出站的包，更改这些包的属性，并添加和删除新的包。最终，开发者希望启用这些功能并将它们部署到远程环境中，在那里应用程序与生产/预发布数据库环境交互。
- en: Starting a project
  id: totrans-128
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始一个项目
- en: To start building the application, the developer installs the framework. They
    can use a command such as `npm install -g componium`. The command globally installs
    the framework. This is similar to the `npm link` command that we used before to
    get access to the executable. However, in this case, the framework is downloaded
    from the npm package manager database. In your case, you can use the npm-linked
    version of the executable if it makes it easier.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始构建应用程序，开发者需要安装框架。他们可以使用如`npm install -g componium`这样的命令。该命令全局安装框架。这类似于我们之前使用的`npm
    link`命令，用于获取对可执行文件的访问权限。然而，在这种情况下，框架是从npm包管理器数据库中下载的。在你的情况下，如果你觉得这样更容易，可以使用可执行的npm链接版本。
- en: 'With the framework installed, the developer can now run `componium init` to
    create a new application structure. The terminal will show the following:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 安装框架后，开发者现在可以运行`componium init`来创建一个新的应用程序结构。终端将显示以下内容：
- en: '[PRE10]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Using the framework
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用框架
- en: The initialization script automatically installs the necessary parts of the
    project, including a `package.json` file. The code scaffolds the necessary files
    into the project directory based on those choices. The starting point now leaves
    the developer with a brand-new project directory, where they can begin development.
    The expectation of this workflow ensures minimal friction during installation
    and presents the developer with an example of running application code. The next
    step for the developer is to use either the `componium dev` or `componium create`
    command. The first command, `dev`, will start the development server in the project
    directory, and the second command, `create`, can scaffold new components within
    the project. It is up to the developer to decide whether they want to use the
    scaffolding helpers or write code from scratch using the provided framework documentation.
    These two commands will come in handy in the next parts of the workflow, where
    a developer can start adding new API models and server endpoints.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化脚本会自动安装项目所需的部分，包括一个`package.json`文件。根据这些选择，代码将必要的文件构建到项目目录中。现在，起点为开发者留下一个全新的项目目录，他们可以在其中开始开发。这个工作流程的预期确保了安装过程中的最小摩擦，并向开发者展示了运行应用程序代码的示例。开发者的下一步是使用`componium
    dev`或`componium create`命令。第一个命令`dev`将在项目目录中启动开发服务器，第二个命令`create`可以在项目内部构建新的组件。开发者需要决定他们是否想使用脚手架助手或根据提供的框架文档从头编写代码。这两个命令将在工作流程的下一部分中派上用场，其中开发者可以开始添加新的API模型和服务器端点。
- en: Creating an API and a model
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建API和模型
- en: Now, by following the docs on route creation and handling, the developer can
    create the necessary endpoints to support the requirements of the project that
    they are building. For example, they can begin by using the file-based router
    to define two endpoints – one to create new *package* entries and another to list
    them. To do this, they can make a directory called `api` and add a new file, `api/packages.js`.
    You can find an example of this file at `chapter7/componium/tests/sample/models/package.js`.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过遵循关于路由创建和处理的文档，开发者可以创建必要的端点来支持他们正在构建的项目需求。例如，他们可以从使用基于文件的路由器来定义两个端点开始——一个用于创建新的*包*条目，另一个用于列出它们。为此，他们可以创建一个名为`api`的目录并添加一个新文件，`api/packages.js`。你可以在`chapter7/componium/tests/sample/models/package.js`找到这个文件的示例。
- en: 'Instead of doing this manually, the scaffolding tool can also help generate
    a new route file and a new model file, later placing them into the correct directory.
    For the route generation, the command looks like this:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是手动进行，脚手架工具还可以帮助生成一个新的路由文件和一个新的模型文件，然后将它们放置到正确的目录中。对于路由生成，命令看起来是这样的：
- en: '[PRE11]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will now provide an endpoint to handle requests. The developer will likely
    start looking for ways to enrich the API endpoints with actual data. The API creation
    step requires the application author to understand the available options and the
    mechanisms to create new endpoints. Most likely, they can learn this from the
    framework documentation and provided sample apps.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这将现在提供一个端点来处理请求。开发者可能会开始寻找方法来丰富API端点以包含实际数据。API创建步骤要求应用程序作者了解可用的选项和创建新端点的机制。他们很可能会从框架文档和提供的示例应用程序中学习这些内容。
- en: Expanding the API
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展API
- en: 'With the API routes functioning, it is time to enable data persistence. In
    this case, the developer needs to add database capabilities to save and list *packages*.
    The framework already ensures that it can connect to a development database locally
    so that step is taken care of. The next step in the workflow is to add a *Package*
    model and load it in the API endpoints. The scaffolding tooling can generate a
    model file in the right location using a CLI prompt or command. For example, the
    CLI can run `componium create` to prompt the developer for the database model
    details. To successfully achieve this workflow task, the application author needs
    to be aware of the scaffolding tools or manual ways to manage database models
    within the framework. Once we create the model, we can update the `models/package.js`
    file to store the properties of different packages:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 在API路由功能正常后，现在是时候启用数据持久性了。在这种情况下，开发者需要添加数据库功能来保存和列出*包*。框架已经确保它可以连接到本地的开发数据库，因此这一步已经处理好了。工作流程的下一步是添加一个*Package*模型并在API端点中加载它。脚手架工具可以使用CLI提示或命令在正确的位置生成模型文件。例如，CLI可以运行`componium
    create`来提示开发者输入数据库模型详情。为了成功完成这个工作流程任务，应用程序作者需要了解脚手架工具或框架内管理数据库模型的手动方法。一旦我们创建了模型，我们就可以更新`models/package.js`文件来存储不同包的属性：
- en: '[PRE12]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: In the preceding code, we can both create new packages and then respond with
    all the packages in the database. Furthermore, we can split the creation logic
    and the query logic into different routes. The full packages file can be found
    in `tests/sample/routes/api/packages.js`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们既可以创建新的包，然后响应数据库中所有包的信息。此外，我们可以将创建逻辑和查询逻辑拆分到不同的路由中。完整的包文件可以在`tests/sample/routes/api/packages.js`中找到。
- en: By the end of this workflow step, the endpoint should now have the code logic
    to interact with the newly created Package model and list the records when the
    `packages.js` route is accessed.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 到这个工作流程步骤结束时，端点现在应该有了与新建的Package模型交互的代码逻辑，当访问`packages.js`路由时可以列出记录。
- en: Adding tests
  id: totrans-144
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加测试
- en: At this point in our workflow, we have a working API that interacts with the
    database. The developer has already tested the endpoints manually using sample
    requests. They can also land some functional test cases to make sure the API works
    properly. To successfully add tests, there needs to be documentation on the suggested
    ways to test endpoints. These suggestions can include the use of third-party test
    libraries or the built-in `componium-test` library from [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的工作流程的这个阶段，我们已经有一个可以与数据库交互的工作API。开发者已经手动使用示例请求测试了端点。他们还可以添加一些功能测试用例以确保API正常工作。为了成功添加测试，需要有关建议测试端点方式的文档。这些建议可以包括使用第三方测试库或来自[*第6章*](B19014_06.xhtml#_idTextAnchor089)的内置`componium-test`库。
- en: Configuring environments
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 配置环境
- en: With the routes tested, it is time to attempt to deploy the application to see
    whether it works in the remote environment. The application frameworks that we
    saw in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015) pride themselves on the
    ease of deployment. Therefore, the expectations are high to make the application
    as easy as possible to deploy.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试了路由后，现在是时候尝试将应用程序部署到远程环境，看看它是否工作正常。我们在[*第1章*](B19014_01.xhtml#_idTextAnchor015)中看到的框架以部署的简便性而自豪。因此，期望尽可能使应用程序易于部署。
- en: To successfully achieve this step, our framework provides a production configuration
    file, `config/production.json`. This JSON file contains various environment-specific
    settings that the application uses when running in the production environment.
    It is still up to the developer to properly understand how to securely specify
    the database information and other configuration options. The framework documentation
    can guide the application authors to suggest optimal ways to make this step work.
    While the framework provides this file, it’s still the responsibility of the developer
    to understand how to securely specify the required attributes. The way these details
    are specified can significantly impact the security and performance of the application,
    making it critical to get it right.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 要成功完成这一步骤，我们的框架提供了一个生产配置文件，`config/production.json`。这个JSON文件包含了应用程序在生产环境中运行时使用的各种环境特定设置。开发者仍然需要正确理解如何安全地指定数据库信息和其他配置选项。框架文档可以指导应用程序作者建议使这一步骤正常工作的最佳方式。虽然框架提供了这个文件，但开发者仍然有责任理解如何安全地指定所需的属性。这些细节的指定方式可以显著影响应用程序的安全性和性能，因此正确完成这一点至关重要。
- en: Deploying the application
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部署应用程序
- en: With the production configuration correctly configured, the developer can now
    deploy the application to their server environment and test out the new API. This
    step completes our sample workflow, and if the developer can successfully test
    out their changes and interact with the database, then the workflow is successful.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在生产配置正确配置后，开发者现在可以将应用程序部署到他们的服务器环境中并测试新的API。这一步骤完成了我们的示例工作流程，如果开发者能够成功测试他们的更改并与数据库交互，那么工作流程就是成功的。
- en: This is just one example of a framework workflow, which allows us to document
    the steps from installation to a working application. There are more steps that
    could potentially be added; it largely depends on how far we are willing to explore
    this workflow. For example, using the middleware APIs of the framework, we can
    explore how common middleware such as authentication can be easily added to the
    new endpoints. We also didn’t cover the use cases where an application author
    needs to have frontend views to manage and interact with the endpoints.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个框架工作流程的例子，它使我们能够记录从安装到运行中的应用程序的步骤。可能还有更多步骤可以添加；这很大程度上取决于我们愿意探索这个工作流程有多远。例如，使用框架的中间件API，我们可以探索如何轻松地将认证等常见中间件添加到新的端点。我们也没有涵盖应用程序作者需要前端视图来管理和与端点交互的使用案例。
- en: The process of figuring out these types of workflows can help us identify friction
    and opportunities to make the framework’s developer experience much better. It
    also ensures that we figure out what types of documentation and tooling improvements
    can be added to the project as we develop it further.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '确定这些类型的工作流程可以帮助我们识别摩擦和改进框架开发者体验的机会。它还确保我们了解在进一步开发项目时，可以添加哪些类型的文档和工具改进。 '
- en: At this point of deployment of the application, we conclude the workflow’s standard
    progression. The additional steps in the more extensive workflow can involve doing
    more in-depth database operations and using the framework’s GraphQL features.
    Overall, focusing on several of these types of workflows can help framework authors
    fine-tune how stakeholders interact with their systems. In the following section,
    we will take a look at a list of the external dependencies that made all this
    possible.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序部署的这个阶段，我们得出工作流程标准进度的结论。更广泛的工作流程中的附加步骤可能涉及进行更深入的数据库操作和使用框架的GraphQL功能。总的来说，关注这些类型的工作流程可以帮助框架作者微调利益相关者与他们的系统交互的方式。在下一节中，我们将查看使所有这一切成为可能的外部依赖项列表。
- en: Dependencies
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖项
- en: 'The workflow that we mentioned in the previous section is made possible by
    several external libraries and modules. Here’s a recap of some of the modules
    that we used in the Componium framework from this chapter:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中提到的流程是由几个外部库和模块实现的。以下是本章中Componium框架使用的一些模块的回顾：
- en: '`@apollo/server` and `@graphql-tools/schema`: The combination of these two
    tools allows us to offer the GraphQL features of this framework project. Apollo
    Server is able to integrate with Componium servers, and it also provides an easy-to-use
    sandbox to test GraphQL schemas.'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@apollo/server` 和 `@graphql-tools/schema`：这两个工具的组合使我们能够提供本框架项目的GraphQL功能。Apollo
    Server能够与Componium服务器集成，并提供一个易于使用的沙箱来测试GraphQL模式。'
- en: '`Chokidar`: This is the file-watching library that helps to create a better
    experience by watching for changes to the application files and performing steps,
    such as restarting the development server.'
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Chokidar`: 这是一个文件监视库，通过监视应用程序文件的变化并执行诸如重启开发服务器等步骤，从而帮助创建更好的体验。'
- en: '`@inquirer` and `yargs`: These libraries allow us to create the `componium`
    command-line tool. *Inquirer* can create interactive terminal interfaces, useful
    for Componium development commands, such as `componium create`. *Yargs* helps
    us work with command-line commands, flags, and options, making it easier to quickly
    develop a sleek development interface for our project.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`@inquirer`和`yargs`: 这些库允许我们创建`componium`命令行工具。*Inquirer*可以创建交互式终端界面，这对于Componium开发命令，如`componium
    create`非常有用。*Yargs*帮助我们处理命令行命令、标志和选项，使得为我们的项目快速开发一个简洁的开发界面变得更容易。'
- en: '`express` and `body-parser`: These are the underlying server libraries that
    make it possible to initialize Componium servers and add routes and middleware.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`express`和`body-parser`: 这些是底层服务器库，使得初始化Componium服务器和添加路由和中间件成为可能。'
- en: '`Winston`: This is the logging library that is used in the underlying `Logging`
    class. It helps us provide a way for the Componium applications to log to different
    types of logs.'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Winston`: 这是底层`Logging`类中使用的日志库。它帮助我们为Componium应用程序提供向不同类型的日志记录的方式。'
- en: '`sequelize`: This is the ORM layer library that helps applications integrate
    with a variety of databases.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sequelize`: 这是一个ORM层库，它帮助应用程序与各种数据库集成。'
- en: '`componium-test`: This is the testing library from [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089)
    that we can utilize to test the backend framework.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`componium-test`: 这是来自[*第6章*](B19014_06.xhtml#_idTextAnchor089)的测试库，我们可以利用它来测试后端框架。'
- en: '`debug`: This is the logging module used to track down and debug internal issues
    of a framework during development. As mentioned in [*Chapter 6*](B19014_06.xhtml#_idTextAnchor089),
    it supports scoping a debug level to a particular component by using the `DEBUG=componium:*`
    `environment` variable.'
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`debug`: 这是一个用于在开发期间追踪和调试框架内部问题的日志模块。正如[*第6章*](B19014_06.xhtml#_idTextAnchor089)中提到的，它支持通过使用`DEBUG=componium:*`环境变量将调试级别限定到特定的组件。'
- en: '`config`: This is the configuration manager module that helps store and organize
    the application configuration in different formats.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`config`: 这是一个配置管理模块，它帮助以不同格式存储和组织应用程序配置。'
- en: Some of these modules are quite common in server-side frameworks and other Node.js
    tools at large. For the purposes of your own framework, you can choose the packages
    we just discussed or find alternatives that better fit your use cases. Luckily,
    the Node.js ecosystem has a lot to offer in terms of ORM, logging, and testing
    solutions.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些模块在服务器端框架和其他Node.js工具中相当常见。对于您自己的框架，您可以选择我们刚才讨论的包，或者找到更适合您用例的替代方案。幸运的是，Node.js生态系统在ORM、日志和测试解决方案方面提供了很多选择。
- en: Summary
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have taken a step further, from the earlier experience with
    the testing framework, by composing a brand-new server-side framework that is
    capable of routing requests, handling API calls, and much more. This supports
    our plan to develop a full stack framework that covers both frontend and backend
    features, with components interacting with each other within the same unified
    vision. Our goal was to create something that is used and reused for multiple
    application use cases and feature set combinations.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们进一步发展了早期对测试框架的经验，通过构建一个全新的服务器端框架，该框架能够路由请求、处理API调用等更多功能。这支持我们的计划开发一个全栈框架，该框架涵盖前端和后端功能，组件在相同的统一愿景中相互交互。我们的目标是创建一个可用于多种应用程序用例和功能集组合的东西。
- en: We started by defining our project’s goals, and we later developed the core
    architecture aspects of the framework. This architecture included producing features
    such as server process management, environment configuration, and database interaction.
    To enable usability and empower developer productivity, we also focused on producing
    several features that focus on developer experience.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先定义了我们的项目目标，然后我们后来开发了框架的核心架构方面。这个架构包括生成诸如服务器进程管理、环境配置和数据库交互等功能。为了提高可用性和提高开发者生产力，我们还专注于生成一些专注于开发者体验的功能。
- en: This was the second practical exercise in our framework experience, and hopefully,
    this gives you even more confidence in your skills to develop your own frameworks.
    To take this a step further, the next chapter will focus on our final challenge
    – building frontend components for our full stack framework. The introduction
    of the frontend components in the next chapter will enable the whole full stack
    experience of our newly created framework.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们框架经验中的第二次实际练习，并且希望这能让你对自己的技能开发框架更有信心。为了更进一步，下一章将专注于我们的最终挑战——为我们的全栈框架构建前端组件。下一章中前端组件的引入将使我们的新创建框架的全栈体验得以实现。
