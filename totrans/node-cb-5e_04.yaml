- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Using Web Protocols
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Web 协议
- en: Node.js was built with web servers in mind. Using Node.js, we can quickly create
    a web server with a few lines of code, allowing us to customize the behavior of
    our server.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 是以构建 Web 服务器为目标的。使用 Node.js，我们可以用几行代码快速创建一个 Web 服务器，这使我们能够自定义服务器的行为。
- en: '**HTTP** stands for **HyperText Transfer Protocol** and is an application layer
    protocol that underpins the **World Wide Web** ( **WWW** ). HTTP is a stateless
    protocol that was originally designed to facilitate communication between web
    browsers and servers. The recipes in this chapter will have a large emphasis on
    how to handle and send HTTP requests. Although the recipes do not require a deep
    understanding of how HTTP operates, it would be worthwhile reading a high-level
    overview if you’re completely new to the concept. *MDN Web Docs* provides an overview
    of HTTP at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)
    .'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTTP** 代表 **超文本传输协议**，是一种支撑 **万维网**（**WWW**）的应用层协议。HTTP 是一种无状态协议，最初设计用于促进浏览器和服务器之间的通信。本章的食谱将重点介绍如何处理和发送
    HTTP 请求。尽管这些食谱不需要深入了解 HTTP 的工作原理，但如果您对这一概念完全陌生，阅读一个高级概述将是有益的。*MDN Web 文档* 提供了
    HTTP 的概述，请参阅 [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)。'
- en: This chapter will showcase the low-level core **application programming interfaces**
    ( **APIs** ) that Node.js provides for interacting with web protocols. We’ll start
    by making HTTP requests, creating an HTTP server, and learning how to handle **POST**
    requests and file uploads. Later in the chapter, we will learn how to create a
    WebSocket server and how to create a **Simple Mail Transfer Protocol** ( **SMTP**
    ) server using Node.js.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将展示 Node.js 为与 Web 协议交互提供的低级核心 **应用程序编程接口**（**APIs**）。我们将从发送 HTTP 请求、创建 HTTP
    服务器以及学习如何处理 **POST** 请求和文件上传开始。本章后面，我们将学习如何使用 Node.js 创建 WebSocket 服务器以及如何创建 **简单邮件传输协议**（**SMTP**）服务器。
- en: It’s important to understand how Node.js interacts with underlying web protocols,
    as these web protocols and fundamental concepts form the basis of most real-world
    web applications. Later, in [*Chapter 6*](B19212_06.xhtml#_idTextAnchor178) ,
    we will learn how to use web frameworks that abstract web protocols into higher-level
    APIs, but understanding how Node.js interacts with web protocols at a low level
    is important.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 理解 Node.js 如何与底层 Web 协议交互非常重要，因为这些 Web 协议和基本概念构成了大多数实际 Web 应用程序的基础。稍后，在 [*第
    6 章*](B19212_06.xhtml#_idTextAnchor178) 中，我们将学习如何使用将 Web 协议抽象为高级 API 的 Web 框架，但理解
    Node.js 在低级别如何与 Web 协议交互同样重要。
- en: 'This chapter will cover the following recipes:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下食谱：
- en: Making HTTP requests
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 发送 HTTP 请求
- en: Creating an HTTP server
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 HTTP 服务器
- en: Receiving HTTP **POST** requests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接收 HTTP **POST** 请求
- en: Handling file uploads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理文件上传
- en: Creating a WebSocket server
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 WebSocket 服务器
- en: Creating an SMTP server
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建 SMTP 服务器
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter will require you to have Node.js installed – preferably, a recent
    version of Node.js 22. Also, you will need access to both an editor and a browser
    of your choice. The code samples used in this chapter are available on GitHub
    at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter04** directory.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 本章要求您安装 Node.js – 最好是 Node.js 22 的最新版本。此外，您还需要访问您选择的编辑器和浏览器。本章使用的代码示例可在 GitHub
    上的 [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    的 **Chapter04** 目录中找到。
- en: Making HTTP requests
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发送 HTTP 请求
- en: Programs and applications often need to obtain data from another source or server.
    In modern web development, this is commonly achieved by sending an HTTP **GET**
    request to the source or server. Similarly, an application or program may also
    need to send data to other sources or servers. This is often achieved by sending
    an HTTP **POST** request containing the data to the target source or server.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 程序和应用程序通常需要从其他来源或服务器获取数据。在现代 Web 开发中，这通常是通过向来源或服务器发送 HTTP **GET** 请求来实现的。同样，应用程序或程序可能还需要将数据发送到其他来源或服务器。这通常是通过向目标来源或服务器发送包含数据的
    HTTP **POST** 请求来实现的。
- en: As well as being used to build HTTP servers, the Node.js core **http** and **https**
    modules expose APIs that can be used to send HTTP requests to other servers.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 除了用于构建 HTTP 服务器外，Node.js 的核心 **http** 和 **https** 模块还公开了可以用于向其他服务器发送 HTTP 请求的
    API。
- en: In this recipe, we’re going to use the Node.js core **http** and **https** modules
    to send both an HTTP **GET** request and an HTTP **POST** request.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 Node.js 核心模块 **http** 和 **https** 来发送 HTTP **GET** 请求和 HTTP **POST**
    请求。
- en: Getting ready
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by creating a directory named **making-requests** for this recipe. We’ll
    also create a file called **requests.js** :'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为这个菜谱创建一个名为 **making-requests** 的目录。我们还将创建一个名为 **requests.js** 的文件：
- en: '[PRE0]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: How to do it…
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: We’re going to use the Node.js core **http** module to send an HTTP **GET**
    request and an HTTP **POST** request.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Node.js 核心模块 **http** 来发送 HTTP **GET** 请求和 HTTP **POST** 请求。
- en: 'Start by importing the **http** module in your **requests.js** file:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在您的 **requests.js** 文件中导入 **http** 模块：
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we can send an HTTP **GET** request. We’re going to send a request to
    [http://example.com](http://example.com) . This can be done with one line of code:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以发送一个 HTTP **GET** 请求。我们将向 [http://example.com](http://example.com) 发送请求。这可以用一行代码完成：
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute your Node.js script with the following command. You should expect to
    see the HTML representation of [http://example.com](http://example.com) printed
    to **stdout** :'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令执行您的 Node.js 脚本。您应该会看到 [http://example.com](http://example.com) 的 HTML
    表示形式打印到 **stdout**：
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we can look at how we send an HTTP **POST** request. Start by commenting
    out the HTTP **GET** request with **//** – leaving it in will make the output
    of later steps difficult to read:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以看看我们是如何发送 HTTP **POST** 请求的。首先，用 **//** 注释掉 HTTP **GET** 请求——保留它会使后续步骤的输出难以阅读：
- en: '[PRE4]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'For our HTTP **POST** request, we will first need to define the data that we
    want to send with the request. To achieve this, we define a variable named **payload**
    containing a **JavaScript Object Notation** ( **JSON** ) representation of our
    data:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于我们的 HTTP **POST** 请求，我们首先需要定义我们要与请求一起发送的数据。为了实现这一点，我们定义一个名为 **payload** 的变量，它包含我们数据的
    **JavaScript 对象表示法** ( **JSON** ) 表示：
- en: '[PRE5]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We also need to create a configuration object for the options we want to send
    with the HTTP **POST** request. We’re going to send the HTTP **POST** request
    to [http://postman-echo.com](http://postman-echo.com) . This is a test endpoint
    that will return our HTTP headers, parameters, and content of our HTTP **POST**
    request – mirroring our request:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要为我们要与 HTTP **POST** 请求一起发送的选项创建一个配置对象。我们将向 [http://postman-echo.com](http://postman-echo.com)
    发送 HTTP **POST** 请求。这是一个测试端点，它将返回我们的 HTTP 头部、参数和 HTTP **POST** 请求的内容——镜像我们的请求：
- en: '[PRE6]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Important note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'Postman ( [http://postman.com](http://postman.com) ) is a platform for API
    development and provides a **Representational State Transfer** ( **REST** ) client
    application that you can download to use to send HTTP requests. Postman also provides
    a service named Postman Echo – this provides an endpoint that you can send your
    HTTP requests to for testing. Refer to the Postman Echo documentation here: [https://docs.postman-echo.com/?version=latest](https://docs.postman-echo.com/?version=latest)
    .'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Postman ([http://postman.com](http://postman.com) ) 是一个用于API开发的平台，并提供了一个可以下载使用的
    **表示状态转换** ( **REST** ) 客户端应用程序，用于发送HTTP请求。Postman 还提供了一个名为 Postman Echo 的服务——这提供了一个端点，您可以将其用于测试发送的HTTP请求。有关
    Postman Echo 文档，请参阅此处：[https://docs.postman-echo.com/?version=latest](https://docs.postman-echo.com/?version=latest)
    。
- en: 'To send the HTTP **POST** request, add the following code. This will write
    the responses of the HTTP status code and request body to **stdout** once the
    response is received:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要发送 HTTP **POST** 请求，请添加以下代码。这将把 HTTP 状态码和请求体的响应写入 **stdout**，一旦收到响应：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We should also catch any errors that occur on the request:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该捕获请求过程中发生的任何错误：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Finally, we need to send our request with the payload:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要携带负载发送我们的请求：
- en: '[PRE9]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, execute your program, and you should see that the Postman Echo API responds
    to our HTTP **POST** request:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，执行您的程序，您应该会看到 Postman Echo API 对我们的 HTTP **POST** 请求做出响应：
- en: '[PRE10]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We’ve learned how to use the Node.js core **http** module to send HTTP **GET**
    and HTTP **POST** requests.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了如何使用 Node.js 核心模块 **http** 来发送 HTTP **GET** 和 HTTP **POST** 请求。
- en: How it works…
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we leveraged the Node.js core **http** module to send HTTP **GET**
    and HTTP **POST** requests. The Node.js core **http** module relies on the underlying
    Node.js core **net** module.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们利用了 Node.js 核心模块 **http** 来发送 HTTP **GET** 和 HTTP **POST** 请求。Node.js
    核心模块 **http** 依赖于底层的 Node.js 核心模块 **net**。
- en: For the HTTP **GET** request, we call the **http.get()** function with two parameters.
    The first parameter is the endpoint that we wish to send the request to, and the
    second is the callback function. The callback function executes once the HTTP
    **GET** request is complete, and in this recipe, our function forwards the response
    we receive from the endpoint to **stdout** .
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 HTTP **GET** 请求，我们使用两个参数调用 **http.get()** 函数。第一个参数是我们希望发送请求的端点，第二个参数是回调函数。回调函数在
    HTTP **GET** 请求完成后执行，在这个菜谱中，我们的函数将我们从端点收到的响应转发到 **stdout**。
- en: To make the HTTP **POST** request, we use the **http.request()** function. This
    function also takes two parameters.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送 HTTP **POST** 请求，我们使用 **http.request()** 函数。此函数也接受两个参数。
- en: The first parameter to the **request()** function is the **options** object.
    In the recipe , we used the **options** object to configure which HTTP method
    to use, the hostname, the path the request should be sent to, and the headers
    to be set on the request. A full list of configuration options that can be passed
    to the **request()** function is viewable in the Node.js HTTP API documentation
    ( [https://nodejs.org/api/http.html#http_http_request_options_callback](https://nodejs.org/api/http.html#http_http_request_options_callback)
    ).
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '**request()** 函数的第一个参数是 **options** 对象。在菜谱中，我们使用 **options** 对象来配置要使用的 HTTP
    方法、主机名、请求应发送到的路径以及请求上要设置的标头。可以在 Node.js HTTP API 文档中查看可以传递给 **request()** 函数的完整配置选项列表（[https://nodejs.org/api/http.html#http_http_request_options_callback](https://nodejs.org/api/http.html#http_http_request_options_callback)）。'
- en: The second parameter to the **request()** function is the callback function
    to be executed upon completion of the HTTP **POST** request. Our request function
    writes the HTTP status code and forwards the request’s response to **standard**
    **output** ( **stdout** ).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '**request()** 函数的第二个参数是在 HTTP **POST** 请求完成后要执行的回调函数。我们的请求函数会写入 HTTP 状态码，并将请求的响应转发到
    **标准输出**（**stdout**）。'
- en: 'An error event listener was added to the request object to capture and log
    any errors to **stdout** :'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在请求对象上添加了一个错误事件监听器来捕获和记录任何错误到 **stdout**：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The **req.end(payload);** statement sends our request with the payload.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**req.end(payload);** 语句发送我们的请求并附带有效负载。'
- en: 'It’s also possible to combine this API with **Promise** syntax. Add the following
    to a file named **requestPromise.js** :'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将此 API 与 **Promise** 语法结合使用。将以下内容添加到名为 **requestPromise.js** 的文件中：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The **httpGet()** function uses a **Promise** to manage an asynchronous HTTP
    **GET** request: it resolves with the full data on successful completion and rejects
    with an error if the request fails. This setup allows for easy integration with
    **async** / **await** for handling asynchronous HTTP operations.'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '**httpGet()** 函数使用 **Promise** 来管理异步 HTTP **GET** 请求：在成功完成时解析为完整数据，如果请求失败则拒绝并返回错误。这种设置使得与
    **async** / **await** 集成处理异步 HTTP 操作变得简单。'
- en: There’s more…
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: The recipe demonstrated how to send **GET** and **POST** requests over HTTP,
    but it is also worth considering how to send requests over HTTPS. **HTTPS** stands
    for **HyperText Transfer Protocol Secure** . HTTPS is an extension of the HTTP
    protocol. Communications over HTTPS are encrypted. Node.js core provides an **https**
    module, alongside the **http** module, to be used when dealing with HTTPS communications.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 菜谱展示了如何通过 HTTP 发送 **GET** 和 **POST** 请求，但考虑如何通过 HTTPS 发送请求也同样值得。**HTTPS** 代表
    **HyperText Transfer Protocol Secure**。HTTPS 是 HTTP 协议的扩展。通过 HTTPS 的通信是加密的。Node.js
    核心提供了 **https** 模块，与 **http** 模块一起使用，用于处理 HTTPS 通信。
- en: 'It is possible to change the requests in the recipe to use HTTPS by importing
    the **https** core module and changing any instances of **http** to **https**
    . You also will need to send the request to the HTTPS endpoint:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 有可能将菜谱中的请求更改为使用 HTTPS，通过导入 **https** 核心模块并将任何 **http** 实例更改为 **https** 来实现。你还需要将请求发送到
    HTTPS 端点：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Having covered the basics with the traditional HTTP and HTTPS modules for making
    requests, let’s pivot to explore how to use **Promise** syntax and the more recently
    added Fetch API.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用传统的 HTTP 和 HTTPS 模块进行请求的基础知识之后，让我们转向探索如何使用 **Promise** 语法和最近添加的 Fetch API。
- en: Using the Fetch API
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 Fetch API
- en: Let’s explore the **Fetch API** , a modern web API designed for making HTTP
    requests. While it has been available in browsers for some time, it has more recently
    become available by default in Node.js. In Node.js, the Fetch API is a higher-level
    alternative to the core HTTP modules, offering a simplified and user-friendly
    abstraction over lower-level HTTP APIs. It embraces a **Promise** -based approach
    for handling asynchronous operations.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们探索 **Fetch API**，这是一个为发送 HTTP 请求而设计的现代 Web API。虽然它在浏览器中已经存在了一段时间，但最近它已成为
    Node.js 的默认功能。在 Node.js 中，Fetch API 是核心 HTTP 模块的高级替代品，它对底层的 HTTP API 提供了简化和用户友好的抽象。它采用基于
    **Promise** 的方法来处理异步操作。
- en: Starting from Node.js version 18, the Fetch API is readily available as a global
    API. The implementation in Node.js is powered by **undici** , an HTTP/1.1 client
    developed from scratch specifically for Node.js. You can find more information
    about **undici** at [https://undici.nodejs.org/#/](https://undici.nodejs.org/#/)
    .
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 从 Node.js 版本 18 开始，Fetch API 作为全局 API 立即可用。Node.js 中的实现由 **undici** 提供，这是一个从头开始为
    Node.js 开发的 HTTP/1.1 客户端。你可以在 [https://undici.nodejs.org/#/](https://undici.nodejs.org/#/)
    找到有关 **undici** 的更多信息。
- en: The implementation was inspired by the frequently used **node-fetch** ( [https://npmjs.com/package/node-fetch](https://npmjs.com/package/node-fetch)
    ) package. The Node.js implementation of the Fetch API strives to be as close
    to specification-compliant as possible, but some aspects of the Fetch API specification
    are more browser-oriented and are therefore omitted in the Node.js implementation.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 实现灵感来源于常用 **node-fetch** ([https://npmjs.com/package/node-fetch](https://npmjs.com/package/node-fetch))
    包。Node.js 对 Fetch API 的实现力求尽可能符合规范，但 Fetch API 规范的一些方面更偏向浏览器，因此在 Node.js 实现中被省略。
- en: Important note
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'You can directly use **undici** as a module for lower-level and more fine-grained
    control of handling HTTP requests. Read the **undici** API documentation for more
    information: [https://undici.nodejs.org/#/](https://undici.nodejs.org/#/) .'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以直接将 **undici** 作为模块用于对 HTTP 请求进行更底层和更精细的控制。阅读 **undici** API 文档以获取更多信息：[https://undici.nodejs.org/#/](https://undici.nodejs.org/#/)。
- en: 'Let us look at an example of making HTTP **GET** and HTTP **POST** requests
    using the Node.js Fetch API:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看使用 Node.js Fetch API 发送 HTTP **GET** 和 HTTP **POST** 请求的示例：
- en: 'Create a file named **fetchGet.js** and a file named **fetchPost.js** :'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **fetchGet.js** 的文件和一个名为 **fetchPost.js** 的文件：
- en: '[PRE14]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add the following to **fetchGet.js** :'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下内容添加到 **fetchGet.js** 中：
- en: '[PRE15]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'You can run this example with the following command:'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可以使用以下命令运行此示例：
- en: '[PRE16]'
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'To demonstrate making an HTTP **POST** request using the Node.js Fetch API,
    add the following to **fetchPost.js** :'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示使用 Node.js Fetch API 发送 HTTP **POST** 请求，将以下内容添加到 **fetchPost.js** 中：
- en: '[PRE17]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note the use of the configuration object to set the HTTP method to **POST**
    and set the content type.
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意使用配置对象设置 HTTP 方法为 **POST** 并设置内容类型。
- en: 'Run the example with the following command:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令运行示例：
- en: '[PRE18]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As the implementation of the Fetch API in Node.js intends to be as compatible
    with the specification as possible, you can refer to *MDN Web Docs* for more detailed
    usage information: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
    . *MDN Web Docs* provides a comprehensive and often considered canonical resource
    for web developers.'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Node.js 中 Fetch API 的实现旨在尽可能与规范兼容，你可以参考 *MDN Web 文档* 以获取更详细的使用信息：[https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)。*MDN
    Web 文档* 为网络开发者提供了一个全面且常被认为是权威的资源。
- en: Important note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: 'It’s advisable to stay informed about updates and changes to its status as
    Node.js may release newer versions that refine the Fetch API implementation. Refer
    to the API documentation: [https://nodejs.org/dist/latest-v22.x/docs/api/globals.html#fetch](https://nodejs.org/dist/latest-v22.x/docs/api/globals.html#fetch)
    .'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 建议关注其更新和状态变化，因为 Node.js 可能会发布更新版本，以改进 Fetch API 的实现。请参阅 API 文档：[https://nodejs.org/dist/latest-v22.x/docs/api/globals.html#fetch](https://nodejs.org/dist/latest-v22.x/docs/api/globals.html#fetch)。
- en: See also
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Creating an HTTP server* recipe in this chapter
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *创建 HTTP 服务器* 菜单
- en: The *Receiving HTTP POST requests* recipe in this chapter
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *接收 HTTP POST 请求* 菜单
- en: '*Chapters 3* , *6* , and *9*'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 3 章*、*第 6 章* 和 *第 9 章*'
- en: Creating an HTTP server
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 HTTP 服务器
- en: When building large complex applications, it is typical to implement HTTP servers
    using a higher-level web framework rather than interacting with core Node.js APIs.
    However, understanding the underlying APIs is important, and in some cases, only
    interacting with the underlying Node.js APIs will provide you with the fine-grained
    control required in certain circumstances.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在构建大型复杂应用程序时，通常使用高级 Web 框架来实现 HTTP 服务器，而不是与核心 Node.js API 交互。然而，理解底层 API 是很重要的，在某些情况下，仅与底层
    Node.js API 交互才能提供在某些情况下所需的细粒度控制。
- en: In the previous section, we explored foundational concepts of HTTP and relevant
    Node.js core APIs. In this tutorial, we’ll guide you through the process of building
    an HTTP server using Node.js where we’ll initially focus on handling **GET** requests
    – fundamental functionality for web servers.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了 HTTP 的基础概念以及相关的 Node.js 核心API。在本教程中，我们将指导您使用 Node.js 构建HTTP服务器的过程，我们最初将专注于处理
    **GET** 请求——这是网络服务器的基本功能。
- en: Getting ready
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'Start by creating a directory for this recipe and a file named **server.js**
    that will contain our HTTP server:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为这个食谱创建一个目录，并创建一个名为 **server.js** 的文件，该文件将包含我们的 HTTP 服务器：
- en: '[PRE19]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: How to do it…
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: For this recipe, we will be using the core Node.js **http** module. API documentation
    for the **http** module is available at [https://nodejs.org/api/http.html](https://nodejs.org/api/http.html)
    . In the recipe, we’ll create a “To Do” task server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们将使用核心 Node.js **http** 模块。**http** 模块的API文档可在 [https://nodejs.org/api/http.html](https://nodejs.org/api/http.html)
    查找。在本食谱中，我们将创建一个“待办事项”任务服务器。
- en: 'To start, we need to import the core Node.js **http** module by adding the
    following line to **server.js** :'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要通过在 **server.js** 中添加以下行来导入核心 Node.js **http** 模块：
- en: '[PRE20]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'We’ll start by defining the hostname and port for our server:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先定义服务器的域名和端口号：
- en: '[PRE21]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Next, we can create the server and add some route handling. Within the **createServer()**
    function, we will reference the **error()** , **todo()** , and **index()** functions
    that we’ll create in the following steps:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以创建服务器并添加一些路由处理。在 **createServer()** 函数中，我们将引用我们在以下步骤中创建的 **error()**、**todo()**
    和 **index()** 函数：
- en: '[PRE22]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Now, let’s create our **error()** function. This function will take a parameter
    of the response object and a status code, where the code is expected to be an
    HTTP status code:'
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的 **error()** 函数。这个函数将接受一个响应对象和一个状态码作为参数，其中代码预期是一个 HTTP 状态码：
- en: '[PRE23]'
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'We will now create our **todo()** function. For now, this function will just
    return a static JSON string representing an item on the “To Do” list:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将创建我们的 **todo()** 函数。目前，这个函数将只返回一个静态的 JSON 字符串，表示“待办事项”列表中的一个条目：
- en: '[PRE24]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The final function to create is an **index()** function, which will be called
    when we perform a **GET** request on the **/** route:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 需要创建的最后一个函数是 **index()** 函数，当我们在 **/** 路由上执行 **GET** 请求时，该函数将被调用：
- en: '[PRE25]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Finally, we need to call the **listen()** function on our server. We’ll also
    pass a callback function to the **listen()** function that will log out the address
    that the server is listening on once the server has started:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的服务器上调用 **listen()** 函数。我们还将向 **listen()** 函数传递一个回调函数，该函数将在服务器启动后记录服务器正在监听的地址：
- en: '[PRE26]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It’s now possible to start our server from our terminal:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在可以从我们的终端启动我们的服务器：
- en: '[PRE27]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In a separate terminal window, we can either use cURL to send **GET** requests
    to our server or access the various endpoints in our browser:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个单独的终端窗口中，我们可以使用 cURL 向我们的服务器发送 **GET** 请求，或者在浏览器中访问我们的各种端点：
- en: '[PRE28]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We’ve built a barebones “To Do” list server that we can send HTTP **GET** requests
    to, and the server responds with JSON data.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经构建了一个基本的“待办事项”列表服务器，我们可以向其发送 HTTP **GET** 请求，服务器会以 JSON 数据响应。
- en: How it works…
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The Node.js core **http** module provides interfaces to the features of the
    HTTP protocol.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 核心模块 **http** 提供了对 HTTP 协议功能的接口。
- en: In the recipe, we created a server using the **createServer()** function that
    is exposed by the **http** module. We passed the **createServer()** function a
    request listener function that is executed upon each request.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用 **http** 模块暴露的 **createServer()** 函数创建了一个服务器。我们向 **createServer()**
    函数传递了一个请求监听函数，该函数会在每次请求时执行。
- en: Each time a request is received to the specified route, the request listener
    function will execute. The request listener function has two parameters, **req**
    and **res** , where **req** is the request object and **res** is the response
    object. The **http** module creates the **req** object based on the data in the
    request.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 每次收到指定路由的请求时，请求监听函数都会执行。请求监听函数有两个参数，**req** 和 **res**，其中 **req** 是请求对象，**res**
    是响应对象。**http** 模块根据请求中的数据创建 **req** 对象。
- en: 'It is possible to pass the **createServer()** function an **options** object
    as the first parameter. Refer to the **http** module Node.js API documentation
    to see which parameters and options can be passed to the various **http** functions:
    [https://nodejs.org/api/http.html](https://nodejs.org/api/http.html) .'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 可以将 **options** 对象作为第一个参数传递给 **createServer()** 函数。请参阅 Node.js 的 **http** 模块
    API 文档，以了解可以传递给各种 **http** 函数的参数和选项：[https://nodejs.org/api/http.html](https://nodejs.org/api/http.html)。
- en: The **createServer()** function returns an **http.Server** object. We start
    the server by calling the **listen()** function. We pass the **listen()** function
    our **HOSTNAME** and **PORT** parameters to instruct the server which hostname
    and port it should be listening on.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '**createServer()** 函数返回一个 **http.Server** 对象。我们通过调用 **listen()** 函数来启动服务器。我们向
    **listen()** 函数传递我们的 **HOSTNAME** 和 **PORT** 参数，以指示服务器应该监听哪个主机名和端口号。'
- en: 'Our request handler in the recipe is formed of three **if** statements. The
    first **if** statement checks the **req.method** property for which HTTP method
    the incoming request was sent with:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在菜谱中的请求处理器由三个 **if** 语句组成。第一个 **if** 语句检查 **req.method** 属性，以确定传入请求使用了哪个 HTTP
    方法：
- en: '[PRE29]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: In this recipe, we only allowed **GET** requests. When any other HTTP method
    is detected on the incoming request, we return and call our error function.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们只允许 **GET** 请求。当检测到传入请求上的任何其他 HTTP 方法时，我们返回并调用我们的错误函数。
- en: 'The second two **if** statements inspect the **req.url** value:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 后两个 **if** 语句检查 **req.url** 的值：
- en: '[PRE30]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The **url** property on the request object informs us which route the request
    was sent to. The **req.url** property does not provide the full **Uniform Resource
    Locator** ( **URL** ), just the relative path or “route” segment. The **if** statements
    in this recipe control which function is called upon each request to a specific
    URL – this forms a **simple** **route handler** .
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 请求对象上的 **url** 属性告诉我们请求被发送到了哪个路由。**req.url** 属性不提供完整的 **统一资源定位符** ( **URL**
    )，只是相对路径或“路由”段。这个菜谱中的 **if** 语句控制着对特定 URL 的每个请求调用哪个函数——这形成了一个 **简单** 的 **路由处理器**。
- en: The final line of our listener function calls our **error()** function. This
    line will only be reached if none of our conditional **if** statements are satisfied.
    In our recipe, this will happen when a request is sent to any route other than
    **/** or **/todo** .
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们监听函数的最后一行调用了我们的 **error()** 函数。只有当我们的条件 **if** 语句都不满足时，这一行才会被执行。在我们的菜谱中，这将在请求发送到除
    **/** 或 **/todo** 之外的其他任何路由时发生。
- en: We pass the response object, **res** , to each of our **error()** , **todo()**
    , and **index()** functions. This object is a **Stream** object. We call **res.end()**
    to return the desired content.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将响应对象 **res** 传递给我们的每个 **error()**、**todo()** 和 **index()** 函数。此对象是一个 **Stream**
    对象。我们调用 **res.end()** 来返回所需的内容。
- en: 'For the **error()** function, we pass an additional parameter, **code** . We
    use this to pass and then return HTTP status codes. HTTP status codes are part
    of the HTTP protocol specification ( [https://tools.ietf.org/html/rfc2616#section-10](https://tools.ietf.org/html/rfc2616#section-10)
    ). The following table shows how HTTP response codes are grouped:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 **error()** 函数，我们传递一个额外的参数，**code**。我们使用它来传递并返回 HTTP 状态码。HTTP 状态码是 HTTP 协议规范的一部分（[https://tools.ietf.org/html/rfc2616#section-10](https://tools.ietf.org/html/rfc2616#section-10)）。下表显示了
    HTTP 响应代码是如何分组的：
- en: '| **Range** | **Use** |'
  id: totrans-131
  prefs: []
  type: TYPE_TB
  zh: '| **Range** | **用途** |'
- en: '| **1xx** | Information |'
  id: totrans-132
  prefs: []
  type: TYPE_TB
  zh: '| **1xx** | 信息 |'
- en: '| **2xx** | Success |'
  id: totrans-133
  prefs: []
  type: TYPE_TB
  zh: '| **2xx** | 成功 |'
- en: '| **3xx** | Redirection |'
  id: totrans-134
  prefs: []
  type: TYPE_TB
  zh: '| **3xx** | 重定向 |'
- en: '| **4xx** | Client error |'
  id: totrans-135
  prefs: []
  type: TYPE_TB
  zh: '| **4xx** | 客户端错误 |'
- en: '| **5xx** | Server error |'
  id: totrans-136
  prefs: []
  type: TYPE_TB
  zh: '| **5xx** | 服务器错误 |'
- en: Table 4.1 – Table listing HTTP status codes and their use
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 表 4.1 – 列出 HTTP 状态码及其用途的表格
- en: 'In the recipe, we returned the following error codes:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱中，我们返回了以下错误代码：
- en: 404 – Not Found
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 404 – 未找到
- en: 405 – Method Not Allowed
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 405 – 方法不允许
- en: 'The **http** module exposes a constant object that stores all the HTTP response
    codes and their corresponding descriptions: **http.STATUS_CODES** . We used this
    to return the response message with **http.STATUS_CODE** .'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '**http** 模块公开了一个常量对象，该对象存储了所有 HTTP 响应代码及其对应描述：**http.STATUS_CODES**。我们使用它来返回带有
    **http.STATUS_CODE** 的响应消息。'
- en: There’s more…
  id: totrans-142
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: 'In the recipe, we defined a constant for the **HOSTNAME** and **PORT** values
    with the following lines:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱中，我们使用以下行定义了 **HOSTNAME** 和 **PORT** 值的常量：
- en: '[PRE31]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The use of **process.env** allows the values to be set as environment variables.
    If the environmental variables are not set, then our use of the **OR** logical
    operator ( **||** ) will mean our hostname and port values default to **0.0.0.0**
    and **3000** respectively.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **process.env** 允许将值设置为环境变量。如果环境变量未设置，那么我们使用 **OR** 逻辑运算符（**||**）将意味着我们的主机名和端口号默认为
    **0.0.0.0** 和 **3000**。
- en: It’s a good practice to allow the hostname and port values to be set via environment
    variables as this allows deployment orchestrators, such as Kubernetes, to inject
    these values at runtime.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 允许通过环境变量设置主机名和端口号是一种良好的做法，因为这允许部署编排器，如 Kubernetes，在运行时注入这些值。
- en: 'It’s also possible to bind your HTTP server to a random free port. To do this,
    we set the **PORT** value to **0** . You can change our recipe code that assigns
    the **PORT** variable to the following to instruct the server to listen to a random
    free port:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将您的 HTTP 服务器绑定到随机空闲端口。为此，我们将 **PORT** 值设置为 **0**。您可以将分配 **PORT** 变量的代码更改为以下内容，以指示服务器监听随机空闲端口：
- en: '[PRE32]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Binding to any random port in Node.js is useful when deploying on platforms
    that dynamically assign ports (for example, cloud services) or in scenarios with
    potential port conflicts (for example, multiple instances running simultaneously).
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中绑定到任何随机端口在部署到动态分配端口的平台（例如，云服务）或存在潜在端口冲突的场景（例如，同时运行多个实例）时很有用。
- en: Using --env-file
  id: totrans-150
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 --env-file
- en: As of Node.js 20.6.0 and later, there is a new command-line option that can
    be used to load environment variables from files. This provides similar functionality
    to the commonly used **npm** package **dotenv** ( [https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv)
    ) by loading environment variables into **process.env** from a file containing
    the environment variables.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 截至 Node.js 20.6.0 及更高版本，有一个新的命令行选项可以用于从文件中加载环境变量。这提供了类似于常用 **npm** 包 **dotenv**（[https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv)）的功能，通过从包含环境变量的文件中加载环境变量到
    **process.env**。
- en: 'Each line in the file should consist of a key-value pair representing an environment
    variable, with the name and value separated by an equals sign ( **=** ). For example,
    you would add the following to define the **HOSTNAME** and **PORT** variables
    to the default values used in the recipe:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 文件中的每一行应包含一个键值对，表示环境变量，名称和值由等号（**=**）分隔。例如，您可以将以下内容添加到定义 **HOSTNAME** 和 **PORT**
    变量的默认值，用于菜谱：
- en: '[PRE33]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Often, this file will be called **.env** for local development, but it is also
    common to have multiple environment files representing different application environments,
    such as **.staging.env** for environment values that correspond to the staging
    application of your development.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，此文件将被称为 **.env** 用于本地开发，但通常也有多个环境文件表示不同的应用程序环境，例如 **.staging.env** 用于与您的开发中的预发布应用程序对应的环境值。
- en: 'To load the values in the environment, you need to supply the **--env-file**
    command-line option:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 要加载环境中的值，您需要提供 **--env-file** 命令行选项：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: If the same variable is defined in the environment and the file, the value from
    the environment will take precedence.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在环境和文件中定义了相同的变量，环境中的值将优先。
- en: Note that at the time of writing, this feature is designated as **Experimental**
    status, meaning the feature may be subject to breaking changes and/or removal.
    More details can be found in the official API documentation at [https://nodejs.org/docs/latest-v22.x/api/cli.html#--env-fileconfig](https://nodejs.org/docs/latest-v22.x/api/cli.html#--env-fileconfig)
    .
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在撰写本文时，此功能被指定为 **实验性** 状态，这意味着该功能可能会受到破坏性更改和/或删除的影响。更多详细信息可以在官方 API 文档中找到：[https://nodejs.org/docs/latest-v22.x/api/cli.html#--env-fileconfig](https://nodejs.org/docs/latest-v22.x/api/cli.html#--env-fileconfig)。
- en: See also
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: The *Receiving HTTP POST requests* recipe in this chapter
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 本章中的 *接收 HTTP POST 请求* 菜单
- en: '*Chapters 6* and *11*'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 6 章* 和 *第 11 章*'
- en: Receiving HTTP POST requests
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接收 HTTP POST 请求
- en: The HTTP **POST** method is employed for transmitting data to the server, in
    contrast to the HTTP **GET** method, which is utilized to retrieve data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 与用于检索数据的 HTTP **GET** 方法不同，HTTP **POST** 方法用于向服务器传输数据。
- en: To be able to receive **POST** data, we need to instruct our server on how to
    accept and handle **POST** requests. A **POST** request typically contains data
    within the body of the request, which is sent to the server to be handled. The
    submission of a web form is typically done via an HTTP **POST** request.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够接收 **POST** 数据，我们需要指导服务器如何接受和处理 **POST** 请求。一个 **POST** 请求通常在请求体中包含数据，这些数据被发送到服务器进行处理。通常，通过
    HTTP **POST** 请求提交网页表单。
- en: Important note
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: In PHP, it is possible to access **POST** data via a **$_POST** array. PHP does
    not follow the non-blocking architecture that Node.js does, which means that the
    PHP program would wait or block until the **$_POST** values are populated. Node.js,
    however, provides asynchronous interaction with HTTP data at a lower level, which
    allows us to interface with the incoming message body as a stream. This means
    that the handling of the incoming stream is within the developer’s control and
    concern.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在 PHP 中，可以通过 **$_POST** 数组访问 **POST** 数据。PHP 不遵循 Node.js 的非阻塞架构，这意味着 PHP 程序将等待或阻塞，直到
    **$_POST** 值被填充。然而，Node.js 提供了与 HTTP 数据的异步交互，在较低级别上，这允许我们将传入的消息体作为流进行接口。这意味着传入流的处理在开发者的控制之下。
- en: In this recipe, we’re going to create a web server that accepts and handles
    HTTP **POST** requests.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个接受和处理 HTTP **POST** 请求的 Web 服务器。
- en: Getting ready
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To prepare the groundwork for the recipe, we’ll start by setting up the project
    structure.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 为了为这个菜谱做准备，我们首先设置项目结构。
- en: 'Start by creating a directory for this recipe. We’ll also need a file named
    **server.js** that will contain our HTTP server:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为这个菜谱创建一个目录。我们还需要一个名为 **server.js** 的文件，该文件将包含我们的 HTTP 服务器：
- en: '[PRE35]'
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We also need to create a subdirectory called **public** , containing a file
    named **form.html** that will contain an HTML form:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建一个名为 **public** 的子目录，其中包含一个名为 **form.html** 的文件，该文件将包含一个 HTML 表单：
- en: '[PRE36]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: How to do it…
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: We’re going to create a server that accepts and handles both HTTP **GET** and
    HTTP **POST** requests using the Node.js core APIs provided by the **http** module.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个服务器，该服务器使用由 **http** 模块提供的 Node.js 核心API接受和处理 HTTP **GET** 和 HTTP **POST**
    请求。
- en: 'First, let’s set up an HTML form with input fields for forename and surname.
    Open **form.html** and add the following:'
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置一个带有名字和姓氏输入字段的 HTML 表单。打开 **form.html** 并添加以下内容：
- en: '[PRE37]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Next, open the **server.js** file and import the **fs** , **http** , and **path**
    Node.js core modules:'
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，打开 **server.js** 文件并导入 **fs**、**http** 和 **path** Node.js 核心模块：
- en: '[PRE38]'
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'On the next line, we’ll create a reference to our **form.html** file:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一行，我们将创建对 **form.html** 文件的引用：
- en: '[PRE39]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Now, add the following lines of code to **server.js** to set up the server.
    We’ll also create a **get()** function to return the form and an error function
    named **error()** :'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，将以下代码行添加到 **server.js** 文件中，以设置服务器。我们还将创建一个 **get()** 函数来返回表单，并创建一个名为 **error()**
    的错误处理函数：
- en: '[PRE40]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Start your server and confirm that you can view the form in your browser at
    **http://localhost:3000** :'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的服务器并确认您可以在浏览器中通过 **http://localhost:3000** 查看表单：
- en: '[PRE41]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Expect to see the following HTML form in your browser:'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 预期在您的浏览器中看到以下 HTML 表单：
- en: '![Figure 4.1 – Browser window depicting an HTML form](img/B19212_04_01.jpg)'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图 4.1 – 显示 HTML 表单的浏览器窗口](img/B19212_04_01.jpg)'
- en: Figure 4.1 – Browser window depicting an HTML form
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1 – 显示 HTML 表单的浏览器窗口
- en: 'In your browser, click **Submit** on the form. Notice that you receive a **Method
    Not Allowed** error message. This is because we do not yet have a conditional
    statement in our request listener function that handles **POST** requests. Let’s
    add one now. Add the following code below the **if** statement that checks for
    **GET** requests:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的浏览器中，点击表单上的 **提交** 按钮。注意，您会收到一个 **方法不被允许** 的错误消息。这是因为我们还没有在我们的请求监听器函数中添加处理
    **POST** 请求的条件语句。现在让我们添加一个。在检查 **GET** 请求的 **if** 语句下方添加以下代码：
- en: '[PRE42]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, we’ll also need to define our **post()** function. Add this below your
    **server.js** file, ideally just below the **get()** function definition:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们还需要定义我们的 **post()** 函数。在您的 **server.js** 文件下方添加此函数，理想情况下就在 **get()** 函数定义下方：
- en: '[PRE43]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Restart your server, return to **http://localhost:3000** in your browser, and
    submit the form. You should see an **OK** message returned. If you look at the
    terminal window where you’re running your server, you can see that the server
    received your data:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重新启动你的服务器，在浏览器中返回到 **http://localhost:3000**，并提交表单。你应该看到一个 **OK** 消息返回。如果你查看运行服务器的终端窗口，你可以看到服务器接收到了你的数据：
- en: '[PRE44]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: We’ve now created a server that accepts and handles both HTTP **GET** and HTTP
    **POST** requests using the Node.js core APIs provided by the **http** module.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在创建了一个服务器，它使用 **http** 模块提供的 Node.js 核心API接受并处理 HTTP **GET** 和 HTTP **POST**
    请求。
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Node.js core **http** module is built on top of and interacts with the Node.js
    core **net** module. The **net** module interacts with an underlying C library
    built into Node.js, called **libuv** . The **libuv** C library handles network
    socket **input/output** ( **I/O** ) and handles the passing of data between the
    C and JavaScript layers.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的核心 **http** 模块建立在并交互于 Node.js 的核心 **net** 模块之上。**net** 模块与 Node.js
    内置的底层 C 库交互，称为 **libuv**。**libuv** C 库处理网络套接字 **输入/输出**（**I/O**）并处理 C 和 JavaScript
    层之间的数据传递。
- en: As in previous recipes, we call the **createServer()** function, which returns
    an HTTP server object. Then, calling the **listen()** method on the server object
    instructs the **http** module to start listening for incoming data on the specified
    address and port.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的配方一样，我们调用 **createServer()** 函数，它返回一个 HTTP 服务器对象。然后，在服务器对象上调用 **listen()**
    方法指示 **http** 模块在指定的地址和端口上开始监听传入的数据。
- en: When the server receives an HTTP request, the **http** module will create objects
    representing the HTTP request ( **req** ) and the HTTP response ( **res** ). After
    this, our request handler is called with the **req** and **res** arguments.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器接收到 HTTP 请求时，**http** 模块将创建代表 HTTP 请求（**req**）和 HTTP 响应（**res**）的对象。之后，我们的请求处理器被调用，并带有
    **req** 和 **res** 参数。
- en: 'Our route handler has the following **if** statements, which inspect each request
    to see if it is an HTTP **GET** request or an HTTP **POST** request:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的路由处理器有以下 **if** 语句，它们检查每个请求以确定它是否是 HTTP **GET** 请求或 HTTP **POST** 请求：
- en: '[PRE45]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Our **get()** function sets the **Content-Type** HTTP header to **text/html**
    , as we’re expecting to return an HTML form. We call the **res.end()** function
    to finish **WriteStream** , write the response, and end the HTTP connection. Refer
    to [*Chapter 3*](B19212_03.xhtml#_idTextAnchor068) for more information on **WriteStream**
    .
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 **get()** 函数将 **Content-Type** HTTP 头设置为 **text/html**，因为我们期望返回一个 HTML 表单。我们调用
    **res.end()** 函数来完成 **WriteStream**，写入响应，并结束 HTTP 连接。有关 **WriteStream** 的更多信息，请参阅
    [*第 3 章*](B19212_03.xhtml#_idTextAnchor068)。
- en: Similarly, our **post()** function checks the **Content-Type** headers to determine
    whether we can support the supplied values. In this instance, we only accept the
    **Content-Type** header of **application/x-www-form-urlencode** , and our error
    function will be called if the request is sent with any other content type.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，我们的 **post()** 函数检查 **Content-Type** 头部以确定我们是否可以支持提供的值。在这种情况下，我们只接受 **Content-Type**
    头为 **application/x-www-form-urlencode**，如果请求发送了任何其他内容类型，我们的错误函数将被调用。
- en: Within our request handler function, we register a listener for the data event.
    Each time a chunk of data is received, we convert it to a string using the **toString()**
    method and append it to our input variable.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的请求处理器函数中，我们注册了一个数据事件的监听器。每次接收到数据块时，我们使用 **toString()** 方法将其转换为字符串，并将其追加到我们的输入变量中。
- en: Once all the data is received from the client, the **end** event is triggered.
    We pass a callback function to the end event listener, which gets called only
    once all data is received. Our callback logs the data received and returns an
    **HTTP** **OK** status message.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦从客户端接收到所有数据，就会触发 **end** 事件。我们向 **end** 事件监听器传递一个回调函数，该函数仅在接收到所有数据时被调用。我们的回调记录接收到的数据并返回一个
    **HTTP** **OK** 状态消息。
- en: There’s more…
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Node.js servers commonly allow interaction via JSON. Let’s look at how we can
    handle HTTP **POST** requests that are sending JSON data. Specifically, this means
    accepting and handling content with the **application/json** content type.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 服务器通常允许通过 JSON 进行交互。让我们看看我们如何处理发送 JSON 数据的 HTTP **POST** 请求。具体来说，这意味着接受和处理具有
    **application/json** 内容类型的内容。
- en: Let’s convert the server from this recipe to handle JSON data.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将服务器从当前配方转换为处理 JSON 数据。
- en: 'First, copy the existing **server.js** file to a new file named **json-server.js**
    :'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，将现有的 **server.js** 文件复制到一个名为 **json-server.js** 的新文件中：
- en: '[PRE46]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Then, we will change our **post()** function to check that the **Content-Type**
    header of the request is set to **application/json** :'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将更改我们的 **post()** 函数以检查请求的 **Content-Type** 标头是否设置为 **application/json**：
- en: '[PRE47]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'We also need to change our **end** event listener function to parse and return
    the JSON data:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要将我们的 **end** 事件监听器函数更改为解析并返回 JSON 数据：
- en: '[PRE48]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Let’s now test whether our server can handle the **POST** route. We will do
    this using the **cURL** command-line tool. Start your server in one terminal window:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们现在测试我们的服务器是否可以处理 **POST** 路由。我们将使用 **cURL** 命令行工具来完成此操作。在一个终端窗口中启动你的服务器：
- en: '[PRE49]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In a separate terminal window, enter the following command:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在另一个终端窗口中，输入以下命令：
- en: '[PRE50]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now, we can add the following script to our **form.html** file, which will
    convert our HTML form data into JSON and send it via a **POST** request to the
    server. Add the following after the closing form tag ( **</form>** ):'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以在我们的 **form.html** 文件中添加以下脚本，该脚本将我们的 HTML 表单数据转换为 JSON，并通过 **POST** 请求发送到服务器。在关闭表单标签（**</form>**）之后添加以下内容：
- en: '[PRE51]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Restart your JSON server with **$ node json-server.js** and navigate to **http://localhost:3000**
    in your browser. If we now complete the input fields in our browser and submit
    the form, we should see in the server logs that the request has been successfully
    sent to the server. Note that our use of **event.preventDefault()** will prevent
    the browser from redirecting the web page upon submission of the form.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **$ node json-server.js** 重新启动你的 JSON 服务器，并在浏览器中导航到 **http://localhost:3000**。如果我们现在在我们的浏览器中完成输入字段并提交表单，我们应该在服务器日志中看到请求已成功发送到服务器。注意，我们使用
    **event.preventDefault()** 将阻止浏览器在表单提交时重定向网页。
- en: Our form and server behave similarly to the server we created in the *Receiving
    HTTP POST requests* recipe, with the difference being that the frontend form interacts
    with the backend via an HTTP **POST** request that sends a JSON representation
    of the form data. The client frontend interacting with the backend server via
    JSON is typical of modern web architectures.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的表单和服务器的行为与我们在 *接收 HTTP POST 请求* 菜谱中创建的服务器类似，不同之处在于前端表单通过发送表单数据的 JSON 表示的
    HTTP **POST** 请求与后端交互。通过 JSON 与后端服务器交互的客户端前端是现代网络架构的典型做法。
- en: See also
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapters 3* , *6* , and *11*'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第3章*、*第6章* 和 *第11章*'
- en: Handling file uploads
  id: totrans-225
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理文件上传
- en: Uploading a file to the web is a common activity, be it an image, a video, or
    a document. Files require different handling compared to simple **POST** data.
    Browsers embed files being uploaded into multipart messages.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 将文件上传到网络是一个常见的活动，无论是图片、视频还是文档。与简单的 **POST** 数据相比，文件需要不同的处理。浏览器将正在上传的文件嵌入到多部分消息中。
- en: Multipart messages allow multiple pieces of content to be combined into one
    payload. To handle multipart messages, we need to use a multipart parser.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 多部分消息允许将多个内容片段组合成一个有效负载。要处理多部分消息，我们需要使用多部分解析器。
- en: In this recipe, we will use the **formidable** module as our multipart parser
    to handle file uploads. The file uploads in this recipe will be stored on disk.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将使用 **formidable** 模块作为我们的多部分解析器来处理文件上传。本菜谱中的文件上传将存储在磁盘上。
- en: Getting ready
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To get started, let’s set up the foundation for our file upload recipe.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，让我们为我们的文件上传菜谱设置基础。
- en: 'First, let’s create a new folder called **file-upload** and create a **server.js**
    file:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 **file-upload** 的新文件夹，并创建一个 **server.js** 文件：
- en: '[PRE52]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'As we will be using a **npm** module for this recipe, we need to initialize
    our project:'
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将在这个菜谱中使用 **npm** 模块，我们需要初始化我们的项目：
- en: '[PRE53]'
  id: totrans-234
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'We will also need to create two subdirectories: one named **public** to store
    our HTML form and another named **uploads** to store our uploaded files:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要创建两个子目录：一个名为 **public** 的目录用于存储我们的 HTML 表单，另一个名为 **uploads** 的目录用于存储我们的上传文件：
- en: '[PRE54]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: How to do it…
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe, we will create a server that can handle file uploads and store
    the files on the server.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个可以处理文件上传并将文件存储在服务器上的服务器。
- en: 'First, we should create an HTML form with a file input field. Create a file
    named **form.html** inside the **public** directory. Add the following content
    to **form.html** :'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们应该创建一个包含文件输入字段的 HTML 表单。在 **public** 目录中创建一个名为 **form.html** 的文件。将以下内容添加到
    **form.html** 中：
- en: '[PRE55]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we should install our multipart parser module, **formidable** :'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们应该安装我们的多部分解析器模块，**formidable**：
- en: '[PRE56]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Now, we can start creating our server. In **server.js** , we will import the
    required modules and create a variable to store the path to our **form.html**
    file:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以开始创建我们的服务器。在 **server.js** 中，我们将导入所需的模块并创建一个变量来存储我们的 **form.html** 文件的路径：
- en: '[PRE57]'
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Next, we’ll create our server with handlers for **GET** and **POST** requests.
    This is like the server we built in the *Receiving HTTP POST* *requests* recipe:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的服务器，并为 **GET** 和 **POST** 请求创建处理程序。这就像我们在 *接收 HTTP POST 请求* 食谱中构建的服务器：
- en: '[PRE58]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, we’ll add our **post()** function. This function will handle file uploads:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将添加我们的 **post()** 函数。这个函数将处理文件上传：
- en: '[PRE59]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Start the server and navigate to **http://localhost:3000** in your browser:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器并在浏览器中导航到 **http://localhost:3000**：
- en: '[PRE60]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Click the button to upload a file (it could be named **Choose File** , **Browse**
    , or similar, depending on your browser and/or operating system) and select any
    file to upload in your File Explorer. You should see the file indicate it has
    been selected. Submit the file. Your server should have successfully received
    and stored the file and responded with data about the stored file in JSON format:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击按钮上传文件（它可能被命名为 **Choose File**、**Browse** 或类似，具体取决于您的浏览器和/或操作系统）并在文件资源管理器中选择任何要上传的文件。您应该看到文件指示它已被选中。提交文件。您的服务器应该已成功接收并存储文件，并以
    JSON 格式的数据响应存储的文件：
- en: '[PRE61]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'If we list out the contents of the **uploads** directory, we should see the
    uploaded file:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们列出 **uploads** 目录的内容，我们应该看到上传的文件：
- en: '[PRE62]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: We’ve created a server that can handle file uploads and tested this by uploading
    a file through our browser.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个可以处理文件上传的服务器，并通过在浏览器中上传文件来测试了这一点。
- en: How it works…
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the first step in the recipe, we set up an HTML form with a file input. The
    **enctype="multipart/form-data"** property on the form element instructs the browser
    to set the **Content-Type** header of the request to **multipart/form-data** .
    This also instructs the browser to embed the files to be uploaded into a multipart
    message.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 在食谱的第一步中，我们设置了一个带有文件输入的 HTML 表单。表单元素上的 **enctype="multipart/form-data"** 属性指示浏览器将请求的
    **Content-Type** 标头设置为 **multipart/form-data**。这也指示浏览器将待上传的文件嵌入到多部分消息中。
- en: The **post()** function checks that the **Content-Type** header is set to **multipart/form-data**
    . If this header isn’t set, we call our error function and return a **415** HTTP
    status code with the message **Unsupported** **Media Type** .
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '**post()** 函数检查 **Content-Type** 标头是否设置为 **multipart/form-data**。如果此标头未设置，我们调用我们的错误函数并返回一个带有消息
    **Unsupported Media Type** 的 **415** HTTP 状态码。'
- en: 'Within the **post()** function, we initialized a **formidable** object with
    configuration options and assigned it to a constant named **form** :'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **post()** 函数中，我们使用配置选项初始化了一个 **formidable** 对象，并将其赋值给一个名为 **form** 的常量：
- en: '[PRE63]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: The first configuration option, **keepExtensions:true** , instructs **formidable**
    to preserve the file extension of the file being uploaded. The **uploadDir** option
    is used to instruct **formidable** where the uploaded files should be stored,
    and in the case of our recipe, we set this to the **uploads** directory.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个配置选项 **keepExtensions:true** 指示 **formidable** 保留上传文件的文件扩展名。**uploadDir**
    选项用于指示 **formidable** 应将上传的文件存储在哪里，在我们的食谱中，我们将此设置为 **uploads** 目录。
- en: Next, we call the **form.parse()** function. This function parses the request
    and collects the form data within the request. The parsed form data is passed
    to our callback function as an array of fields and an array of files.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们调用 **form.parse()** 函数。此函数解析请求并收集请求中的表单数据。解析后的表单数据作为字段数组和文件数组传递给我们的回调函数。
- en: Within our **form.parse()** callback function, we first check if any errors
    occurred during the **form.parse()** function and return an error if there was
    one. Assuming the form data was successfully parsed, we return our response to
    the request, which is an HTTP status code 200, **OK** . We also return the information
    **formidable** provides by default about our uploaded file, in a string representation
    of the JSON format.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 **form.parse()** 回调函数中，我们首先检查在 **form.parse()** 函数执行过程中是否发生了任何错误，如果有错误发生，则返回一个错误。假设表单数据成功解析，我们返回对请求的响应，这是一个
    HTTP 状态码 200，**OK**。我们还返回 **formidable** 默认提供的有关上传文件的信息，以 JSON 格式的字符串表示。
- en: The **formidable** library in Node.js uses random filenames when uploading files
    to prevent conflicts. Assigning unique names helps to avoid issues such as file
    overwriting, where multiple users might upload files with the same name, potentially
    replacing existing data. This method also helps mitigate security risks associated
    with user input by preventing deliberate attempts to overwrite sensitive files
    or predict and access files on the server.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js中的**强大**库在上传文件时使用随机文件名以防止冲突。分配唯一的名称有助于避免诸如文件覆盖等问题，例如，多个用户可能会上传同名文件，从而替换现有数据。此方法还有助于通过防止故意尝试覆盖敏感文件或预测和访问服务器上的文件来减轻与用户输入相关的安全风险。
- en: This recipe demonstrates how community modules such as **formidable** can do
    the heavy lifting and handle complex, but common, problems. In this instance,
    it saved us from writing a multipart parser from scratch. Refer to the *Consuming
    Node.js modules* recipe of [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139) for
    considerations that you should make when selecting which modules to include in
    your applications.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方演示了社区模块如**formidable**如何承担繁重的工作并处理复杂但常见的问题。在这个例子中，它使我们免于从头开始编写多部分解析器。有关在选择要包含在您的应用程序中的模块时应考虑的因素，请参阅[*第5章*](B19212_05.xhtml#_idTextAnchor139)中的*消耗Node.js模块*配方。
- en: Important note
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Allowing the upload of any file type of any size makes your server vulnerable
    to **Denial-of-Service** ( **DoS** ) attacks. Attackers could purposely try to
    upload excessively large or malicious files to slow down your server. It is recommended
    that you add both client-side and server-side validation to restrict the file
    types and sizes that your server will accept.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 允许上传任何类型和任何大小的文件会使您的服务器容易受到**拒绝服务**（**DoS**）攻击。攻击者可能会故意尝试上传过大或恶意文件来减慢您的服务器。建议您添加客户端和服务器端验证来限制服务器将接受的文件类型和大小。
- en: There’s more…
  id: totrans-268
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: In this recipe, we have seen how to handle a simple form containing just one
    file input. Now, let’s look at how we can handle the uploading of multiple files
    at a time and how we handle other types of form data alongside uploading a file.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们看到了如何处理只包含一个文件输入的简单表单。现在，让我们看看我们如何一次性处理多个文件的上传，以及我们如何在上传文件的同时处理其他类型的表单数据。
- en: Uploading multiple files
  id: totrans-270
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 上传多个文件
- en: 'In some cases, you may want to upload multiple files to a server at the same
    time. Conveniently, with **formidable** , this is supported by default. We just
    need to make one change to our **form.html** file, which is to add the **multiple**
    attribute to the input element:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在某些情况下，您可能希望同时将多个文件上传到服务器。方便的是，使用**formidable**，这默认支持。我们只需要对我们的**form.html**文件进行一个更改，即在输入元素中添加**multiple**属性：
- en: '[PRE64]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'Start the server with **node server.js** and navigate to **http://localhost:3000**
    . Now, when you click **Upload** , you should be able to select multiple files
    to upload. On macOS, to select multiple files, you can hold the *Shift* key and
    select multiple files. Then, upon submitting multiple files, **formidable** will
    return data about each of the files uploaded. Expect to see JSON output returned
    that is like the following:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 使用**node server.js**启动服务器并导航到**http://localhost:3000**。现在，当您点击**上传**时，您应该能够选择多个文件进行上传。在macOS上，要选择多个文件，您可以按住**Shift**键并选择多个文件。然后，在提交多个文件后，**formidable**将返回有关上传的每个文件的详细信息。您应该会看到如下所示的JSON输出：
- en: '[PRE65]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Processing multiple input types
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理多个输入类型
- en: It’s common for a form to contain a mixture of input types. On top of the file
    input type, it could contain text, a password, a date, or more input types. The
    **formidable** module handles mixed data types.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 表单中包含多种输入类型是很常见的。除了文件输入类型外，它还可能包含文本、密码、日期或其他输入类型。**formidable**模块可以处理混合数据类型。
- en: HTML input element
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: HTML输入元素
- en: For a full list of input types defined, refer to the MDN web documentation at
    [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input)
    .
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 对于定义的输入类型的完整列表，请参阅MDN网络文档[https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input)。
- en: Let’s extend the HTML form created in the recipe to contain some additional
    text input fields to demonstrate how **formidable** handles multiple input types.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展在配方中创建的HTML表单，以包含一些额外的文本输入字段，以展示**formidable**如何处理多个输入类型。
- en: 'First, let’s add a text input to our **form.html** file:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们向我们的**form.html**文件添加一个文本输入：
- en: '[PRE66]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Start the server with **node server.js** and navigate to **http://localhost:3000**
    . Insert text into the **user** field and select a file to be uploaded. Click
    on **Submit** .
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 **node server.js** 启动服务器，并导航到 **http://localhost:3000**。在 **user** 字段中输入文本，并选择要上传的文件。点击
    **提交**。
- en: 'You will receive a JSON response containing all your form data, like the following:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你将收到一个包含所有表单数据的 JSON 响应，如下所示：
- en: '[PRE67]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: The field information is automatically handled by the **form.parse()** function,
    making the fields accessible to the server.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 字段信息由 **form.parse()** 函数自动处理，使字段可供服务器访问。
- en: See also
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapters 5* , *6* , and *9*'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第 5 章*，*第 6 章*，和 *第 9 章*'
- en: Creating a WebSocket server
  id: totrans-288
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 WebSocket 服务器
- en: The **WebSocket protocol** enables two-way communication between a browser and
    a server. WebSockets are commonly leveraged for building real-time web applications,
    such as instant messaging clients.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: '**WebSocket 协议**允许浏览器和服务器之间进行双向通信。WebSocket 通常用于构建实时网络应用程序，如即时消息客户端。'
- en: In this recipe, we’re going to use the third-party **ws** module to create a
    WebSocket server that we can interact with via our browser.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将使用第三方 **ws** 模块创建一个我们可以通过浏览器与之交互的 WebSocket 服务器。
- en: Getting ready
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: First, we need to prepare our project directory with the necessary files for
    the recipe.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要准备我们的项目目录，包括食谱所需的必要文件。
- en: 'Start by creating a directory named **websocket-server** containing two files
    – one named **client.js** and another named **server.js** :'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先创建一个名为 **websocket-server** 的目录，包含两个文件——一个名为 **client.js**，另一个名为 **server.js**：
- en: '[PRE68]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Also, for our client, let’s create a public directory containing a file named
    **index.html** :'
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了我们的客户，让我们创建一个包含名为 **index.html** 文件的公共目录：
- en: '[PRE69]'
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'As we will be using a third-party **npm** module, we also need to initialize
    our project:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们将使用第三方 **npm** 模块，我们还需要初始化我们的项目：
- en: '[PRE70]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: How to do it…
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe, we’re going to create a WebSocket server and a client and send
    messages between the two.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们将创建一个 WebSocket 服务器和一个客户端，并在两者之间发送消息。
- en: 'Start by installing the **ws** module:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先安装 **ws** 模块：
- en: '[PRE71]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Import the **ws** module in **server.js** :'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **server.js** 中导入 **ws** 模块：
- en: '[PRE72]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Now, we can define our **WebSocketServer** instance, including which port it
    should be accessible at:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以定义我们的 **WebSocketServer** 实例，包括它应该可访问的端口号：
- en: '[PRE73]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'We need to listen for connections and messages to our **WebSocketServer** instance:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要监听对 **WebSocketServer** 实例的连接和消息：
- en: '[PRE74]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'Now, let’s create our client. Add the following to **client.js** :'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的客户端。将以下内容添加到 **client.js** 中：
- en: '[PRE75]'
  id: totrans-310
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'Open **index.html** and add the following:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 **index.html** 并添加以下内容：
- en: '[PRE76]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Now, start your server in one terminal window and your client in a second terminal
    window:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在一个终端窗口中启动你的服务器，在另一个终端窗口中启动你的客户端：
- en: '[PRE77]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: Access **http://localhost:8080** in your browser, and you should see a simple
    input box with a **Submit** button. Type **Hello** into the input box and click
    **Submit** . The WebSocket server should respond with **World!** .
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中访问 **http://localhost:8080**，你应该看到一个简单的输入框和一个 **提交** 按钮。在输入框中输入 **Hello**
    并点击 **提交**。WebSocket 服务器应该响应 **World!**。
- en: 'If we look at the terminal window where we are running our server, we should
    see that the server received the message: **Received: Hello** . This means that
    we have now got a client and server communicating over WebSockets.'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们查看运行服务器的终端窗口，我们应该看到服务器接收到了消息：**Received: Hello**。这意味着我们现在已经有一个客户端和服务器通过
    WebSocket 进行通信。'
- en: We’ve created a WebSocket server and client and demonstrated how they can exchange
    messages. Now, let’s see how it works.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了一个 WebSocket 服务器和客户端，并展示了它们如何交换消息。现在，让我们看看它是如何工作的。
- en: How it works…
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: 'In this recipe, we used the **ws** module to define a WebSocket server:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个食谱中，我们使用了 **ws** 模块来定义一个 WebSocket 服务器：
- en: '[PRE78]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: We then registered a listener for the connection event. The function passed
    to this is executed each time there is a new connection to the WebSocket. Within
    the connection event callback function, we have a socket instance in which we
    registered a listener for the message event, which gets executed each time a message
    is received on that socket.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 我们注册了一个连接事件的监听器。传递给这个函数的函数在每次有新的 WebSocket 连接时执行。在连接事件回调函数中，我们有一个 socket 实例，在其中注册了一个消息事件的监听器，该监听器在接收到该
    socket 上的消息时执行。
- en: 'For our client, we defined a regular HTTP server to serve our **index.html**
    file. Our **index.html** file contains JavaScript that is executed within the
    browser. Within this JavaScript, we created a connection to our WebSocket server,
    providing the endpoint that the **ws** object is listening to:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的客户端，我们定义了一个常规 HTTP 服务器来提供我们的 **index.html** 文件。我们的 **index.html** 文件包含在浏览器中执行的
    JavaScript。在这个 JavaScript 中，我们创建了一个连接到我们的 WebSocket 服务器，提供了 **ws** 对象正在监听的端点：
- en: '[PRE79]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: To send a message to our WebSocket server, we just call **send** on the **ws**
    object with **ws.send(msg)** .
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 要向我们的 WebSocket 服务器发送消息，我们只需在 **ws** 对象上调用 **send** 方法，使用 **ws.send(msg)** 。
- en: We wrapped the **ws.send(msg)** in an event listener. The event listener was
    listening for the “click” event on the **Submit** button, meaning that we would
    send the message to the WebSocket when the **Submit** button was clicked.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 **ws.send(msg)** 包裹在一个事件监听器中。该事件监听器正在监听 **Submit** 按钮的 “click” 事件，这意味着当
    **Submit** 按钮被点击时，我们会将消息发送到 WebSocket。
- en: 'In our script in **index.html** , we registered event listener functions on
    our WebSocket, including **onmessage** , **onclose** , and **onerror** event listeners:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 **index.html** 脚本中，我们在 WebSocket 上注册了事件监听器函数，包括 **onmessage**、**onclose**
    和 **onerror** 事件监听器：
- en: '[PRE80]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: These functions execute on their respective events. For example, the **onmessage()**
    event listener function would execute when our WebSocket receives a message. We
    use these event listeners to add output to our web page according to the event.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数在其相应的事件上执行。例如，当我们的 WebSocket 接收到消息时，**onmessage()** 事件监听器函数将执行。我们使用这些事件监听器根据事件向我们的网页添加输出。
- en: There’s more…
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容…
- en: 'Now, we’ve learned how we can communicate between a browser and a server using
    WebSockets. But it is also possible to create a WebSocket client in Node.js, enabling
    two Node.js programs to communicate over WebSockets using the following steps:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经学会了如何使用 WebSocket 在浏览器和服务器之间进行通信。但也可以在 Node.js 中创建一个 WebSocket 客户端，使两个
    Node.js 程序能够通过以下步骤使用 WebSocket 进行通信：
- en: 'Start by creating a new file within our **websocket-server** directory, named
    **node-client.js** :'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 **websocket-server** 目录内创建一个新文件，命名为 **node-client.js** ：
- en: '[PRE81]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Import the **ws** module and create a new WebSocket object that is configured
    to point to the WebSocket server we created in the *Creating a WebSocket* *server*
    recipe:'
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导入 **ws** 模块并创建一个新的 WebSocket 对象，该对象配置为指向我们在 *创建 WebSocket 服务器* 菜谱中创建的 WebSocket
    服务器：
- en: '[PRE82]'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Now, we’ll set up some listeners on our sockets. We will add listeners for
    the **open** , **close** , and **message** events:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在我们的套接字上设置一些监听器。我们将添加对 **open**、**close** 和 **message** 事件的监听：
- en: '[PRE83]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, let’s send a **''Hello''** message to the WebSocket server every 3 seconds.
    We will use the **setInterval()** function to achieve this:'
  id: totrans-337
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们每 3 秒向 WebSocket 服务器发送一个 **'Hello'** 消息。我们将使用 **setInterval()** 函数来实现这一点：
- en: '[PRE84]'
  id: totrans-338
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Start both the WebSocket server and your Node.js-based client in separate terminal
    windows:'
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在单独的终端窗口中启动 WebSocket 服务器和基于 Node.js 的客户端：
- en: '[PRE85]'
  id: totrans-340
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'You should expect to see the server responding every 3 seconds to your **''Hello''**
    message with the **World!** message:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该期望服务器每 3 秒对你的 **'Hello'** 消息做出响应，并返回 **World!** 消息：
- en: '[PRE86]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: You’ve now created a WebSocket communication between two Node.js programs.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经创建了两个 Node.js 程序之间的 WebSocket 通信。
- en: See also
  id: totrans-344
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: The *Interfacing with standard I/O* recipe in [*Chapter 2*](B19212_02.xhtml#_idTextAnchor041)
  id: totrans-345
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B19212_02.xhtml#_idTextAnchor041) 的 *与标准 I/O 接口* 菜谱
- en: The *Communicating with sockets* recipe in [*Chapter 2*](B19212_02.xhtml#_idTextAnchor041)
  id: totrans-346
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 [*第 2 章*](B19212_02.xhtml#_idTextAnchor041) 的 *通过套接字通信* 菜谱
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  id: totrans-347
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[*第 6 章*](B19212_06.xhtml#_idTextAnchor178)'
- en: Creating an SMTP server
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建 SMTP 服务器
- en: '**SMTP** is a protocol for sending emails. In this recipe, we will be setting
    up an SMTP server using a third-party **npm** module named **smtp-server** .'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**SMTP** 是一种用于发送电子邮件的协议。在本菜谱中，我们将使用名为 **smtp-server** 的第三方 **npm** 模块来设置 SMTP
    服务器。'
- en: You probably receive several automated emails per day in your inbox. In the
    *There’s more…* section, we’re going to learn how we can send an email via Node.js
    to the SMTP server we created in the recipe.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能每天都会在收件箱中收到几封自动发送的电子邮件。在 *更多内容…* 部分中，我们将学习如何通过 Node.js 向我们创建的 SMTP 服务器发送电子邮件。
- en: Getting ready
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中
- en: 'First, let’s create a directory named **server-smtp** and a file named **server.js**
    :'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们创建一个名为 **server-smtp** 的目录和一个名为 **server.js** 的文件：
- en: '[PRE87]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'As we’ll be using the third-party **smtp-server** module from **npm** , we
    will need to initialize our project:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将使用来自 **npm** 的第三方 **smtp-server** 模块，我们需要初始化我们的项目：
- en: '[PRE88]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Important note
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 重要提示
- en: Note that we could not name our directory for this recipe **smtp-server** as
    **npm** refuses to allow you to install a module where the project name is the
    same as the module. If we had named our directory **smtp-server** , our **package.json**
    name would have also been set to **smtp-server** , and we would not be able to
    install the module with the same name.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们无法将此菜谱的目录命名为 **smtp-server**，因为 **npm** 拒绝允许您安装项目名称与模块名称相同的模块。如果我们命名目录为
    **smtp-server**，我们的 **package.json** 名称也将设置为 **smtp-server**，我们将无法使用相同名称安装模块。
- en: How to do it…
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: In this recipe, we will be creating an SMTP server that can receive email messages.
    We will use the **smtp-server** module to achieve this.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个可以接收电子邮件消息的 SMTP 服务器。我们将使用 **smtp-server** 模块来实现这一点。
- en: 'First, start by installing the **smtp-server** module:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，开始安装 **smtp-server** 模块：
- en: '[PRE89]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Next, we need to open **server.js** and import the **server-smtp** module:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要打开 **server.js** 并导入 **server-smtp** 模块：
- en: '[PRE90]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'Let’s define the port that our SMTP server should be accessible at:'
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们定义 SMTP 服务器应可访问的端口号：
- en: '[PRE91]'
  id: totrans-365
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'Now, we’ll create an SMTP server object:'
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个 SMTP 服务器对象：
- en: '[PRE92]'
  id: totrans-367
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'We should also catch any errors. Register an error event listener function
    on the server object:'
  id: totrans-368
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还应该捕获任何错误。在服务器对象上注册一个错误事件监听函数：
- en: '[PRE93]'
  id: totrans-369
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Finally, we can call the **listen()** function to start our SMTP server:'
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以调用 **listen()** 函数来启动我们的 SMTP 服务器：
- en: '[PRE94]'
  id: totrans-371
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Start your SMTP server:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动您的 SMTP 服务器：
- en: '[PRE95]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'You can test a connection to your server by using either the **nc** or **telnet**
    command-line tools in a new terminal:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您可以使用新的终端中的 **nc** 或 **telnet** 命令行工具测试到服务器的连接：
- en: '[PRE96]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: We’ve now confirmed that our SMTP server is available and listening on port
    **4321** .
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经确认我们的 SMTP 服务器可用，并正在端口 **4321** 上监听。
- en: How it works…
  id: totrans-377
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the recipe, we leveraged the **smtp-server** module. This module takes care
    of the implementation of the SMTP protocol, meaning we can focus on the logic
    of our program rather than lower-level implementation details.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在菜谱中，我们利用了 **smtp-server** 模块。此模块负责 SMTP 协议的实现，这意味着我们可以专注于程序的逻辑，而不是底层实现细节。
- en: 'The **smtp-server** module provides high-level APIs. In the recipe, we used
    the following to create a new SMTP server object:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: '**smtp-server** 模块提供了高级 API。在菜谱中，我们使用了以下内容来创建一个新的 SMTP 服务器对象：'
- en: '[PRE97]'
  id: totrans-380
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: The constructor of the **SMTPServer** object accepts many parameters. A full
    list of options that can be passed to the **SMTPServer** constructor is available
    in the **nodemailer** documentation at [https://nodemailer.com/extras/smtp-server/](https://nodemailer.com/extras/smtp-server/)
    .
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: '**SMTPServer** 对象的构造函数接受许多参数。可以传递给 **SMTPServer** 构造函数的完整选项列表可在 **nodemailer**
    文档中找到，网址为 [https://nodemailer.com/extras/smtp-server/](https://nodemailer.com/extras/smtp-server/)
    。'
- en: 'In this recipe, we added the **disabledCommands: [''STARTTLS'', ''AUTH'']**
    option. This option disabled **Transport Layer Security** ( **TLS** ) support
    and authentication for simplicity. However, in production, it would not be recommended
    to disable TLS support and authentication. Instead, it would be recommended to
    enforce TLS. You can do this with the **smtp-server** module by specifying the
    **secure:true** option.'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: '在这个菜谱中，我们添加了 **disabledCommands: [''STARTTLS'', ''AUTH'']** 选项。此选项为了简化，禁用了
    **传输层安全性** ( **TLS** ) 支持和身份验证。然而，在生产环境中，不建议禁用 TLS 支持和身份验证。相反，建议强制执行 TLS。您可以使用
    **smtp-server** 模块通过指定 **secure:true** 选项来实现这一点。'
- en: Should you wish to enforce TLS for the connection, you would also need to define
    a private key and a certificate. If no certificate is provided, then the module
    will generate a self-signed certificate; however, many clients reject these certificates.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您希望强制执行连接的 TLS，您还需要定义一个私钥和证书。如果没有提供证书，则模块将生成自签名证书；然而，许多客户端会拒绝这些证书。
- en: The second option we specify on the **SMTPServer** constructor is the **logger:true**
    option, which enables logging from our SMTP server.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **SMTPServer** 构造函数中指定的第二个选项是 **logger:true** 选项，它启用了 SMTP 服务器的日志记录。
- en: To start our **SMTPServer** constructor, we call the **listen()** function on
    the **SMTPServer** object. It is possible to pass the **listen()** function a
    port, a hostname, and a callback function. In this case, we only provide the port;
    the hostname will default to **localhost** .
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 为了启动我们的 **SMTPServer** 构造函数，我们在 **SMTPServer** 对象上调用 **listen()** 函数。可以将端口号、主机名和回调函数传递给
    **listen()** 函数。在这种情况下，我们只提供了端口号；主机名将默认为 **localhost** 。
- en: There’s more…
  id: totrans-386
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多…
- en: Now that we’ve set up a simple SMTP server, we should try sending an email to
    it via Node.js.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个简单的SMTP服务器，我们应该尝试通过Node.js向其发送电子邮件。
- en: To send an email with Node.js, we can use the **nodemailer** module from **npm**
    . This module is provided by the same organization as the **smtp-server** module
    used in the *Creating an SMTP* *server* recipe.
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Node.js发送电子邮件，我们可以使用来自**npm**的**nodemailer**模块。此模块由与在*创建SMTP* *服务器*配方中使用的**smtp-server**模块相同的组织提供。
- en: 'Let’s start by installing the **nodemailer** module in our **server-smtp**
    directory:'
  id: totrans-389
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在我们的**server-smtp**目录中安装**nodemailer**模块开始：
- en: '[PRE98]'
  id: totrans-390
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Next, we’ll create a file named **send-email.js** :'
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建一个名为**send-email.js**的文件：
- en: '[PRE99]'
  id: totrans-392
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'The first line of code we need to add to our **send-email.js** file to import
    the **nodemailer** module is the following:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要添加到**send-email.js**文件以导入**nodemailer**模块的第一行代码如下：
- en: '[PRE100]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Next, we need to set up the transport object; we will configure the **transporter**
    object to connect to the SMTP server we created in the *Creating an SMTP* *server*
    recipe:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要设置传输对象；我们将配置**transporter**对象以连接到在*创建SMTP* *服务器*配方中创建的SMTP服务器：
- en: '[PRE101]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Next, we can call the **sendMail()** function on the **transporter** object:'
  id: totrans-397
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们可以在**transporter**对象上调用**sendMail()**函数：
- en: '[PRE102]'
  id: totrans-398
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: The first parameter of the **sendMail()** function is an object representing
    the email, including the email address of the sender and receiver, the subject
    line, and the text of the email. The second parameter is a callback function that
    executes once the mail is sent.
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**sendMail()**函数的第一个参数是一个表示电子邮件的对象，包括发送者和接收者的电子邮件地址、主题行和电子邮件正文。第二个参数是一个回调函数，在邮件发送后执行。'
- en: 'To test our **send-email.js** program, first start the SMTP server:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试我们的**send-email.js**程序，首先启动SMTP服务器：
- en: '[PRE103]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'In a second terminal window, run your **send-email.js** program:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个终端窗口中，运行你的**send-email.js**程序：
- en: '[PRE104]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'You should expect to see the following output from the server:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该期望从服务器看到以下输出：
- en: '[PRE105]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'You should see the output like the following from the **send-email.js** program:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你应该从**send-email.js**程序看到以下输出：
- en: '[PRE106]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: This shows that we have successfully created an SMTP server, and we’re able
    to send emails to the SMTP server from another Node.js program.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明我们已经成功创建了一个SMTP服务器，并且能够从另一个Node.js程序向SMTP服务器发送电子邮件。
- en: See also
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: '*Chapters 5* and *9*'
  id: totrans-410
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*第5章*和*第9章*'
