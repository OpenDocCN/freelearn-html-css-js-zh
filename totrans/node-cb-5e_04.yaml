- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using Web Protocols
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Node.js was built with web servers in mind. Using Node.js, we can quickly create
    a web server with a few lines of code, allowing us to customize the behavior of
    our server.
  prefs: []
  type: TYPE_NORMAL
- en: '**HTTP** stands for **HyperText Transfer Protocol** and is an application layer
    protocol that underpins the **World Wide Web** ( **WWW** ). HTTP is a stateless
    protocol that was originally designed to facilitate communication between web
    browsers and servers. The recipes in this chapter will have a large emphasis on
    how to handle and send HTTP requests. Although the recipes do not require a deep
    understanding of how HTTP operates, it would be worthwhile reading a high-level
    overview if you’re completely new to the concept. *MDN Web Docs* provides an overview
    of HTTP at [https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview](https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will showcase the low-level core **application programming interfaces**
    ( **APIs** ) that Node.js provides for interacting with web protocols. We’ll start
    by making HTTP requests, creating an HTTP server, and learning how to handle **POST**
    requests and file uploads. Later in the chapter, we will learn how to create a
    WebSocket server and how to create a **Simple Mail Transfer Protocol** ( **SMTP**
    ) server using Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: It’s important to understand how Node.js interacts with underlying web protocols,
    as these web protocols and fundamental concepts form the basis of most real-world
    web applications. Later, in [*Chapter 6*](B19212_06.xhtml#_idTextAnchor178) ,
    we will learn how to use web frameworks that abstract web protocols into higher-level
    APIs, but understanding how Node.js interacts with web protocols at a low level
    is important.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving HTTP **POST** requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling file uploads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a WebSocket server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SMTP server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter will require you to have Node.js installed – preferably, a recent
    version of Node.js 22. Also, you will need access to both an editor and a browser
    of your choice. The code samples used in this chapter are available on GitHub
    at [https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition](https://github.com/PacktPublishing/Node.js-Cookbook-Fifth-Edition)
    in the **Chapter04** directory.
  prefs: []
  type: TYPE_NORMAL
- en: Making HTTP requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programs and applications often need to obtain data from another source or server.
    In modern web development, this is commonly achieved by sending an HTTP **GET**
    request to the source or server. Similarly, an application or program may also
    need to send data to other sources or servers. This is often achieved by sending
    an HTTP **POST** request containing the data to the target source or server.
  prefs: []
  type: TYPE_NORMAL
- en: As well as being used to build HTTP servers, the Node.js core **http** and **https**
    modules expose APIs that can be used to send HTTP requests to other servers.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to use the Node.js core **http** and **https** modules
    to send both an HTTP **GET** request and an HTTP **POST** request.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating a directory named **making-requests** for this recipe. We’ll
    also create a file called **requests.js** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to use the Node.js core **http** module to send an HTTP **GET**
    request and an HTTP **POST** request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by importing the **http** module in your **requests.js** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can send an HTTP **GET** request. We’re going to send a request to
    [http://example.com](http://example.com) . This can be done with one line of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Execute your Node.js script with the following command. You should expect to
    see the HTML representation of [http://example.com](http://example.com) printed
    to **stdout** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can look at how we send an HTTP **POST** request. Start by commenting
    out the HTTP **GET** request with **//** – leaving it in will make the output
    of later steps difficult to read:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For our HTTP **POST** request, we will first need to define the data that we
    want to send with the request. To achieve this, we define a variable named **payload**
    containing a **JavaScript Object Notation** ( **JSON** ) representation of our
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to create a configuration object for the options we want to send
    with the HTTP **POST** request. We’re going to send the HTTP **POST** request
    to [http://postman-echo.com](http://postman-echo.com) . This is a test endpoint
    that will return our HTTP headers, parameters, and content of our HTTP **POST**
    request – mirroring our request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'Postman ( [http://postman.com](http://postman.com) ) is a platform for API
    development and provides a **Representational State Transfer** ( **REST** ) client
    application that you can download to use to send HTTP requests. Postman also provides
    a service named Postman Echo – this provides an endpoint that you can send your
    HTTP requests to for testing. Refer to the Postman Echo documentation here: [https://docs.postman-echo.com/?version=latest](https://docs.postman-echo.com/?version=latest)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: 'To send the HTTP **POST** request, add the following code. This will write
    the responses of the HTTP status code and request body to **stdout** once the
    response is received:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should also catch any errors that occur on the request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to send our request with the payload:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, execute your program, and you should see that the Postman Echo API responds
    to our HTTP **POST** request:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve learned how to use the Node.js core **http** module to send HTTP **GET**
    and HTTP **POST** requests.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we leveraged the Node.js core **http** module to send HTTP **GET**
    and HTTP **POST** requests. The Node.js core **http** module relies on the underlying
    Node.js core **net** module.
  prefs: []
  type: TYPE_NORMAL
- en: For the HTTP **GET** request, we call the **http.get()** function with two parameters.
    The first parameter is the endpoint that we wish to send the request to, and the
    second is the callback function. The callback function executes once the HTTP
    **GET** request is complete, and in this recipe, our function forwards the response
    we receive from the endpoint to **stdout** .
  prefs: []
  type: TYPE_NORMAL
- en: To make the HTTP **POST** request, we use the **http.request()** function. This
    function also takes two parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter to the **request()** function is the **options** object.
    In the recipe , we used the **options** object to configure which HTTP method
    to use, the hostname, the path the request should be sent to, and the headers
    to be set on the request. A full list of configuration options that can be passed
    to the **request()** function is viewable in the Node.js HTTP API documentation
    ( [https://nodejs.org/api/http.html#http_http_request_options_callback](https://nodejs.org/api/http.html#http_http_request_options_callback)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter to the **request()** function is the callback function
    to be executed upon completion of the HTTP **POST** request. Our request function
    writes the HTTP status code and forwards the request’s response to **standard**
    **output** ( **stdout** ).
  prefs: []
  type: TYPE_NORMAL
- en: 'An error event listener was added to the request object to capture and log
    any errors to **stdout** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The **req.end(payload);** statement sends our request with the payload.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to combine this API with **Promise** syntax. Add the following
    to a file named **requestPromise.js** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The **httpGet()** function uses a **Promise** to manage an asynchronous HTTP
    **GET** request: it resolves with the full data on successful completion and rejects
    with an error if the request fails. This setup allows for easy integration with
    **async** / **await** for handling asynchronous HTTP operations.'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The recipe demonstrated how to send **GET** and **POST** requests over HTTP,
    but it is also worth considering how to send requests over HTTPS. **HTTPS** stands
    for **HyperText Transfer Protocol Secure** . HTTPS is an extension of the HTTP
    protocol. Communications over HTTPS are encrypted. Node.js core provides an **https**
    module, alongside the **http** module, to be used when dealing with HTTPS communications.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to change the requests in the recipe to use HTTPS by importing
    the **https** core module and changing any instances of **http** to **https**
    . You also will need to send the request to the HTTPS endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Having covered the basics with the traditional HTTP and HTTPS modules for making
    requests, let’s pivot to explore how to use **Promise** syntax and the more recently
    added Fetch API.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Fetch API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Let’s explore the **Fetch API** , a modern web API designed for making HTTP
    requests. While it has been available in browsers for some time, it has more recently
    become available by default in Node.js. In Node.js, the Fetch API is a higher-level
    alternative to the core HTTP modules, offering a simplified and user-friendly
    abstraction over lower-level HTTP APIs. It embraces a **Promise** -based approach
    for handling asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Starting from Node.js version 18, the Fetch API is readily available as a global
    API. The implementation in Node.js is powered by **undici** , an HTTP/1.1 client
    developed from scratch specifically for Node.js. You can find more information
    about **undici** at [https://undici.nodejs.org/#/](https://undici.nodejs.org/#/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: The implementation was inspired by the frequently used **node-fetch** ( [https://npmjs.com/package/node-fetch](https://npmjs.com/package/node-fetch)
    ) package. The Node.js implementation of the Fetch API strives to be as close
    to specification-compliant as possible, but some aspects of the Fetch API specification
    are more browser-oriented and are therefore omitted in the Node.js implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'You can directly use **undici** as a module for lower-level and more fine-grained
    control of handling HTTP requests. Read the **undici** API documentation for more
    information: [https://undici.nodejs.org/#/](https://undici.nodejs.org/#/) .'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let us look at an example of making HTTP **GET** and HTTP **POST** requests
    using the Node.js Fetch API:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a file named **fetchGet.js** and a file named **fetchPost.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following to **fetchGet.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can run this example with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To demonstrate making an HTTP **POST** request using the Node.js Fetch API,
    add the following to **fetchPost.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the use of the configuration object to set the HTTP method to **POST**
    and set the content type.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the example with the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As the implementation of the Fetch API in Node.js intends to be as compatible
    with the specification as possible, you can refer to *MDN Web Docs* for more detailed
    usage information: [https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
    . *MDN Web Docs* provides a comprehensive and often considered canonical resource
    for web developers.'
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s advisable to stay informed about updates and changes to its status as
    Node.js may release newer versions that refine the Fetch API implementation. Refer
    to the API documentation: [https://nodejs.org/dist/latest-v22.x/docs/api/globals.html#fetch](https://nodejs.org/dist/latest-v22.x/docs/api/globals.html#fetch)
    .'
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating an HTTP server* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Receiving HTTP POST requests* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapters 3* , *6* , and *9*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an HTTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When building large complex applications, it is typical to implement HTTP servers
    using a higher-level web framework rather than interacting with core Node.js APIs.
    However, understanding the underlying APIs is important, and in some cases, only
    interacting with the underlying Node.js APIs will provide you with the fine-grained
    control required in certain circumstances.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous section, we explored foundational concepts of HTTP and relevant
    Node.js core APIs. In this tutorial, we’ll guide you through the process of building
    an HTTP server using Node.js where we’ll initially focus on handling **GET** requests
    – fundamental functionality for web servers.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Start by creating a directory for this recipe and a file named **server.js**
    that will contain our HTTP server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we will be using the core Node.js **http** module. API documentation
    for the **http** module is available at [https://nodejs.org/api/http.html](https://nodejs.org/api/http.html)
    . In the recipe, we’ll create a “To Do” task server.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we need to import the core Node.js **http** module by adding the
    following line to **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll start by defining the hostname and port for our server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can create the server and add some route handling. Within the **createServer()**
    function, we will reference the **error()** , **todo()** , and **index()** functions
    that we’ll create in the following steps:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create our **error()** function. This function will take a parameter
    of the response object and a status code, where the code is expected to be an
    HTTP status code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will now create our **todo()** function. For now, this function will just
    return a static JSON string representing an item on the “To Do” list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final function to create is an **index()** function, which will be called
    when we perform a **GET** request on the **/** route:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we need to call the **listen()** function on our server. We’ll also
    pass a callback function to the **listen()** function that will log out the address
    that the server is listening on once the server has started:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It’s now possible to start our server from our terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a separate terminal window, we can either use cURL to send **GET** requests
    to our server or access the various endpoints in our browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve built a barebones “To Do” list server that we can send HTTP **GET** requests
    to, and the server responds with JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js core **http** module provides interfaces to the features of the
    HTTP protocol.
  prefs: []
  type: TYPE_NORMAL
- en: In the recipe, we created a server using the **createServer()** function that
    is exposed by the **http** module. We passed the **createServer()** function a
    request listener function that is executed upon each request.
  prefs: []
  type: TYPE_NORMAL
- en: Each time a request is received to the specified route, the request listener
    function will execute. The request listener function has two parameters, **req**
    and **res** , where **req** is the request object and **res** is the response
    object. The **http** module creates the **req** object based on the data in the
    request.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to pass the **createServer()** function an **options** object
    as the first parameter. Refer to the **http** module Node.js API documentation
    to see which parameters and options can be passed to the various **http** functions:
    [https://nodejs.org/api/http.html](https://nodejs.org/api/http.html) .'
  prefs: []
  type: TYPE_NORMAL
- en: The **createServer()** function returns an **http.Server** object. We start
    the server by calling the **listen()** function. We pass the **listen()** function
    our **HOSTNAME** and **PORT** parameters to instruct the server which hostname
    and port it should be listening on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our request handler in the recipe is formed of three **if** statements. The
    first **if** statement checks the **req.method** property for which HTTP method
    the incoming request was sent with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: In this recipe, we only allowed **GET** requests. When any other HTTP method
    is detected on the incoming request, we return and call our error function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second two **if** statements inspect the **req.url** value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The **url** property on the request object informs us which route the request
    was sent to. The **req.url** property does not provide the full **Uniform Resource
    Locator** ( **URL** ), just the relative path or “route” segment. The **if** statements
    in this recipe control which function is called upon each request to a specific
    URL – this forms a **simple** **route handler** .
  prefs: []
  type: TYPE_NORMAL
- en: The final line of our listener function calls our **error()** function. This
    line will only be reached if none of our conditional **if** statements are satisfied.
    In our recipe, this will happen when a request is sent to any route other than
    **/** or **/todo** .
  prefs: []
  type: TYPE_NORMAL
- en: We pass the response object, **res** , to each of our **error()** , **todo()**
    , and **index()** functions. This object is a **Stream** object. We call **res.end()**
    to return the desired content.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the **error()** function, we pass an additional parameter, **code** . We
    use this to pass and then return HTTP status codes. HTTP status codes are part
    of the HTTP protocol specification ( [https://tools.ietf.org/html/rfc2616#section-10](https://tools.ietf.org/html/rfc2616#section-10)
    ). The following table shows how HTTP response codes are grouped:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Range** | **Use** |'
  prefs: []
  type: TYPE_TB
- en: '| **1xx** | Information |'
  prefs: []
  type: TYPE_TB
- en: '| **2xx** | Success |'
  prefs: []
  type: TYPE_TB
- en: '| **3xx** | Redirection |'
  prefs: []
  type: TYPE_TB
- en: '| **4xx** | Client error |'
  prefs: []
  type: TYPE_TB
- en: '| **5xx** | Server error |'
  prefs: []
  type: TYPE_TB
- en: Table 4.1 – Table listing HTTP status codes and their use
  prefs: []
  type: TYPE_NORMAL
- en: 'In the recipe, we returned the following error codes:'
  prefs: []
  type: TYPE_NORMAL
- en: 404 – Not Found
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 405 – Method Not Allowed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The **http** module exposes a constant object that stores all the HTTP response
    codes and their corresponding descriptions: **http.STATUS_CODES** . We used this
    to return the response message with **http.STATUS_CODE** .'
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the recipe, we defined a constant for the **HOSTNAME** and **PORT** values
    with the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The use of **process.env** allows the values to be set as environment variables.
    If the environmental variables are not set, then our use of the **OR** logical
    operator ( **||** ) will mean our hostname and port values default to **0.0.0.0**
    and **3000** respectively.
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good practice to allow the hostname and port values to be set via environment
    variables as this allows deployment orchestrators, such as Kubernetes, to inject
    these values at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also possible to bind your HTTP server to a random free port. To do this,
    we set the **PORT** value to **0** . You can change our recipe code that assigns
    the **PORT** variable to the following to instruct the server to listen to a random
    free port:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Binding to any random port in Node.js is useful when deploying on platforms
    that dynamically assign ports (for example, cloud services) or in scenarios with
    potential port conflicts (for example, multiple instances running simultaneously).
  prefs: []
  type: TYPE_NORMAL
- en: Using --env-file
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As of Node.js 20.6.0 and later, there is a new command-line option that can
    be used to load environment variables from files. This provides similar functionality
    to the commonly used **npm** package **dotenv** ( [https://www.npmjs.com/package/dotenv](https://www.npmjs.com/package/dotenv)
    ) by loading environment variables into **process.env** from a file containing
    the environment variables.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each line in the file should consist of a key-value pair representing an environment
    variable, with the name and value separated by an equals sign ( **=** ). For example,
    you would add the following to define the **HOSTNAME** and **PORT** variables
    to the default values used in the recipe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Often, this file will be called **.env** for local development, but it is also
    common to have multiple environment files representing different application environments,
    such as **.staging.env** for environment values that correspond to the staging
    application of your development.
  prefs: []
  type: TYPE_NORMAL
- en: 'To load the values in the environment, you need to supply the **--env-file**
    command-line option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: If the same variable is defined in the environment and the file, the value from
    the environment will take precedence.
  prefs: []
  type: TYPE_NORMAL
- en: Note that at the time of writing, this feature is designated as **Experimental**
    status, meaning the feature may be subject to breaking changes and/or removal.
    More details can be found in the official API documentation at [https://nodejs.org/docs/latest-v22.x/api/cli.html#--env-fileconfig](https://nodejs.org/docs/latest-v22.x/api/cli.html#--env-fileconfig)
    .
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Receiving HTTP POST requests* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Chapters 6* and *11*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving HTTP POST requests
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The HTTP **POST** method is employed for transmitting data to the server, in
    contrast to the HTTP **GET** method, which is utilized to retrieve data.
  prefs: []
  type: TYPE_NORMAL
- en: To be able to receive **POST** data, we need to instruct our server on how to
    accept and handle **POST** requests. A **POST** request typically contains data
    within the body of the request, which is sent to the server to be handled. The
    submission of a web form is typically done via an HTTP **POST** request.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: In PHP, it is possible to access **POST** data via a **$_POST** array. PHP does
    not follow the non-blocking architecture that Node.js does, which means that the
    PHP program would wait or block until the **$_POST** values are populated. Node.js,
    however, provides asynchronous interaction with HTTP data at a lower level, which
    allows us to interface with the incoming message body as a stream. This means
    that the handling of the incoming stream is within the developer’s control and
    concern.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to create a web server that accepts and handles
    HTTP **POST** requests.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prepare the groundwork for the recipe, we’ll start by setting up the project
    structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a directory for this recipe. We’ll also need a file named
    **server.js** that will contain our HTTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to create a subdirectory called **public** , containing a file
    named **form.html** that will contain an HTML form:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’re going to create a server that accepts and handles both HTTP **GET** and
    HTTP **POST** requests using the Node.js core APIs provided by the **http** module.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s set up an HTML form with input fields for forename and surname.
    Open **form.html** and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, open the **server.js** file and import the **fs** , **http** , and **path**
    Node.js core modules:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'On the next line, we’ll create a reference to our **form.html** file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, add the following lines of code to **server.js** to set up the server.
    We’ll also create a **get()** function to return the form and an error function
    named **error()** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start your server and confirm that you can view the form in your browser at
    **http://localhost:3000** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Expect to see the following HTML form in your browser:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 4.1 – Browser window depicting an HTML form](img/B19212_04_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Figure 4.1 – Browser window depicting an HTML form
  prefs: []
  type: TYPE_NORMAL
- en: 'In your browser, click **Submit** on the form. Notice that you receive a **Method
    Not Allowed** error message. This is because we do not yet have a conditional
    statement in our request listener function that handles **POST** requests. Let’s
    add one now. Add the following code below the **if** statement that checks for
    **GET** requests:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll also need to define our **post()** function. Add this below your
    **server.js** file, ideally just below the **get()** function definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Restart your server, return to **http://localhost:3000** in your browser, and
    submit the form. You should see an **OK** message returned. If you look at the
    terminal window where you’re running your server, you can see that the server
    received your data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now created a server that accepts and handles both HTTP **GET** and HTTP
    **POST** requests using the Node.js core APIs provided by the **http** module.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Node.js core **http** module is built on top of and interacts with the Node.js
    core **net** module. The **net** module interacts with an underlying C library
    built into Node.js, called **libuv** . The **libuv** C library handles network
    socket **input/output** ( **I/O** ) and handles the passing of data between the
    C and JavaScript layers.
  prefs: []
  type: TYPE_NORMAL
- en: As in previous recipes, we call the **createServer()** function, which returns
    an HTTP server object. Then, calling the **listen()** method on the server object
    instructs the **http** module to start listening for incoming data on the specified
    address and port.
  prefs: []
  type: TYPE_NORMAL
- en: When the server receives an HTTP request, the **http** module will create objects
    representing the HTTP request ( **req** ) and the HTTP response ( **res** ). After
    this, our request handler is called with the **req** and **res** arguments.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our route handler has the following **if** statements, which inspect each request
    to see if it is an HTTP **GET** request or an HTTP **POST** request:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Our **get()** function sets the **Content-Type** HTTP header to **text/html**
    , as we’re expecting to return an HTML form. We call the **res.end()** function
    to finish **WriteStream** , write the response, and end the HTTP connection. Refer
    to [*Chapter 3*](B19212_03.xhtml#_idTextAnchor068) for more information on **WriteStream**
    .
  prefs: []
  type: TYPE_NORMAL
- en: Similarly, our **post()** function checks the **Content-Type** headers to determine
    whether we can support the supplied values. In this instance, we only accept the
    **Content-Type** header of **application/x-www-form-urlencode** , and our error
    function will be called if the request is sent with any other content type.
  prefs: []
  type: TYPE_NORMAL
- en: Within our request handler function, we register a listener for the data event.
    Each time a chunk of data is received, we convert it to a string using the **toString()**
    method and append it to our input variable.
  prefs: []
  type: TYPE_NORMAL
- en: Once all the data is received from the client, the **end** event is triggered.
    We pass a callback function to the end event listener, which gets called only
    once all data is received. Our callback logs the data received and returns an
    **HTTP** **OK** status message.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Node.js servers commonly allow interaction via JSON. Let’s look at how we can
    handle HTTP **POST** requests that are sending JSON data. Specifically, this means
    accepting and handling content with the **application/json** content type.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s convert the server from this recipe to handle JSON data.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, copy the existing **server.js** file to a new file named **json-server.js**
    :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will change our **post()** function to check that the **Content-Type**
    header of the request is set to **application/json** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to change our **end** event listener function to parse and return
    the JSON data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s now test whether our server can handle the **POST** route. We will do
    this using the **cURL** command-line tool. Start your server in one terminal window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a separate terminal window, enter the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can add the following script to our **form.html** file, which will
    convert our HTML form data into JSON and send it via a **POST** request to the
    server. Add the following after the closing form tag ( **</form>** ):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Restart your JSON server with **$ node json-server.js** and navigate to **http://localhost:3000**
    in your browser. If we now complete the input fields in our browser and submit
    the form, we should see in the server logs that the request has been successfully
    sent to the server. Note that our use of **event.preventDefault()** will prevent
    the browser from redirecting the web page upon submission of the form.
  prefs: []
  type: TYPE_NORMAL
- en: Our form and server behave similarly to the server we created in the *Receiving
    HTTP POST requests* recipe, with the difference being that the frontend form interacts
    with the backend via an HTTP **POST** request that sends a JSON representation
    of the form data. The client frontend interacting with the backend server via
    JSON is typical of modern web architectures.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapters 3* , *6* , and *11*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling file uploads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Uploading a file to the web is a common activity, be it an image, a video, or
    a document. Files require different handling compared to simple **POST** data.
    Browsers embed files being uploaded into multipart messages.
  prefs: []
  type: TYPE_NORMAL
- en: Multipart messages allow multiple pieces of content to be combined into one
    payload. To handle multipart messages, we need to use a multipart parser.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will use the **formidable** module as our multipart parser
    to handle file uploads. The file uploads in this recipe will be stored on disk.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To get started, let’s set up the foundation for our file upload recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s create a new folder called **file-upload** and create a **server.js**
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we will be using a **npm** module for this recipe, we need to initialize
    our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We will also need to create two subdirectories: one named **public** to store
    our HTML form and another named **uploads** to store our uploaded files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will create a server that can handle file uploads and store
    the files on the server.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we should create an HTML form with a file input field. Create a file
    named **form.html** inside the **public** directory. Add the following content
    to **form.html** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we should install our multipart parser module, **formidable** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can start creating our server. In **server.js** , we will import the
    required modules and create a variable to store the path to our **form.html**
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create our server with handlers for **GET** and **POST** requests.
    This is like the server we built in the *Receiving HTTP POST* *requests* recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll add our **post()** function. This function will handle file uploads:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start the server and navigate to **http://localhost:3000** in your browser:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Click the button to upload a file (it could be named **Choose File** , **Browse**
    , or similar, depending on your browser and/or operating system) and select any
    file to upload in your File Explorer. You should see the file indicate it has
    been selected. Submit the file. Your server should have successfully received
    and stored the file and responded with data about the stored file in JSON format:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we list out the contents of the **uploads** directory, we should see the
    uploaded file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve created a server that can handle file uploads and tested this by uploading
    a file through our browser.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the first step in the recipe, we set up an HTML form with a file input. The
    **enctype="multipart/form-data"** property on the form element instructs the browser
    to set the **Content-Type** header of the request to **multipart/form-data** .
    This also instructs the browser to embed the files to be uploaded into a multipart
    message.
  prefs: []
  type: TYPE_NORMAL
- en: The **post()** function checks that the **Content-Type** header is set to **multipart/form-data**
    . If this header isn’t set, we call our error function and return a **415** HTTP
    status code with the message **Unsupported** **Media Type** .
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the **post()** function, we initialized a **formidable** object with
    configuration options and assigned it to a constant named **form** :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: The first configuration option, **keepExtensions:true** , instructs **formidable**
    to preserve the file extension of the file being uploaded. The **uploadDir** option
    is used to instruct **formidable** where the uploaded files should be stored,
    and in the case of our recipe, we set this to the **uploads** directory.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we call the **form.parse()** function. This function parses the request
    and collects the form data within the request. The parsed form data is passed
    to our callback function as an array of fields and an array of files.
  prefs: []
  type: TYPE_NORMAL
- en: Within our **form.parse()** callback function, we first check if any errors
    occurred during the **form.parse()** function and return an error if there was
    one. Assuming the form data was successfully parsed, we return our response to
    the request, which is an HTTP status code 200, **OK** . We also return the information
    **formidable** provides by default about our uploaded file, in a string representation
    of the JSON format.
  prefs: []
  type: TYPE_NORMAL
- en: The **formidable** library in Node.js uses random filenames when uploading files
    to prevent conflicts. Assigning unique names helps to avoid issues such as file
    overwriting, where multiple users might upload files with the same name, potentially
    replacing existing data. This method also helps mitigate security risks associated
    with user input by preventing deliberate attempts to overwrite sensitive files
    or predict and access files on the server.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe demonstrates how community modules such as **formidable** can do
    the heavy lifting and handle complex, but common, problems. In this instance,
    it saved us from writing a multipart parser from scratch. Refer to the *Consuming
    Node.js modules* recipe of [*Chapter 5*](B19212_05.xhtml#_idTextAnchor139) for
    considerations that you should make when selecting which modules to include in
    your applications.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Allowing the upload of any file type of any size makes your server vulnerable
    to **Denial-of-Service** ( **DoS** ) attacks. Attackers could purposely try to
    upload excessively large or malicious files to slow down your server. It is recommended
    that you add both client-side and server-side validation to restrict the file
    types and sizes that your server will accept.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we have seen how to handle a simple form containing just one
    file input. Now, let’s look at how we can handle the uploading of multiple files
    at a time and how we handle other types of form data alongside uploading a file.
  prefs: []
  type: TYPE_NORMAL
- en: Uploading multiple files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In some cases, you may want to upload multiple files to a server at the same
    time. Conveniently, with **formidable** , this is supported by default. We just
    need to make one change to our **form.html** file, which is to add the **multiple**
    attribute to the input element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Start the server with **node server.js** and navigate to **http://localhost:3000**
    . Now, when you click **Upload** , you should be able to select multiple files
    to upload. On macOS, to select multiple files, you can hold the *Shift* key and
    select multiple files. Then, upon submitting multiple files, **formidable** will
    return data about each of the files uploaded. Expect to see JSON output returned
    that is like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: Processing multiple input types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s common for a form to contain a mixture of input types. On top of the file
    input type, it could contain text, a password, a date, or more input types. The
    **formidable** module handles mixed data types.
  prefs: []
  type: TYPE_NORMAL
- en: HTML input element
  prefs: []
  type: TYPE_NORMAL
- en: For a full list of input types defined, refer to the MDN web documentation at
    [https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input)
    .
  prefs: []
  type: TYPE_NORMAL
- en: Let’s extend the HTML form created in the recipe to contain some additional
    text input fields to demonstrate how **formidable** handles multiple input types.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s add a text input to our **form.html** file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Start the server with **node server.js** and navigate to **http://localhost:3000**
    . Insert text into the **user** field and select a file to be uploaded. Click
    on **Submit** .
  prefs: []
  type: TYPE_NORMAL
- en: 'You will receive a JSON response containing all your form data, like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: The field information is automatically handled by the **form.parse()** function,
    making the fields accessible to the server.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapters 5* , *6* , and *9*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a WebSocket server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **WebSocket protocol** enables two-way communication between a browser and
    a server. WebSockets are commonly leveraged for building real-time web applications,
    such as instant messaging clients.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we’re going to use the third-party **ws** module to create a
    WebSocket server that we can interact with via our browser.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we need to prepare our project directory with the necessary files for
    the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a directory named **websocket-server** containing two files
    – one named **client.js** and another named **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, for our client, let’s create a public directory containing a file named
    **index.html** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we will be using a third-party **npm** module, we also need to initialize
    our project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we’re going to create a WebSocket server and a client and send
    messages between the two.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing the **ws** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the **ws** module in **server.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can define our **WebSocketServer** instance, including which port it
    should be accessible at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to listen for connections and messages to our **WebSocketServer** instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s create our client. Add the following to **client.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Open **index.html** and add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, start your server in one terminal window and your client in a second terminal
    window:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Access **http://localhost:8080** in your browser, and you should see a simple
    input box with a **Submit** button. Type **Hello** into the input box and click
    **Submit** . The WebSocket server should respond with **World!** .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we look at the terminal window where we are running our server, we should
    see that the server received the message: **Received: Hello** . This means that
    we have now got a client and server communicating over WebSockets.'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve created a WebSocket server and client and demonstrated how they can exchange
    messages. Now, let’s see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this recipe, we used the **ws** module to define a WebSocket server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: We then registered a listener for the connection event. The function passed
    to this is executed each time there is a new connection to the WebSocket. Within
    the connection event callback function, we have a socket instance in which we
    registered a listener for the message event, which gets executed each time a message
    is received on that socket.
  prefs: []
  type: TYPE_NORMAL
- en: 'For our client, we defined a regular HTTP server to serve our **index.html**
    file. Our **index.html** file contains JavaScript that is executed within the
    browser. Within this JavaScript, we created a connection to our WebSocket server,
    providing the endpoint that the **ws** object is listening to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: To send a message to our WebSocket server, we just call **send** on the **ws**
    object with **ws.send(msg)** .
  prefs: []
  type: TYPE_NORMAL
- en: We wrapped the **ws.send(msg)** in an event listener. The event listener was
    listening for the “click” event on the **Submit** button, meaning that we would
    send the message to the WebSocket when the **Submit** button was clicked.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our script in **index.html** , we registered event listener functions on
    our WebSocket, including **onmessage** , **onclose** , and **onerror** event listeners:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: These functions execute on their respective events. For example, the **onmessage()**
    event listener function would execute when our WebSocket receives a message. We
    use these event listeners to add output to our web page according to the event.
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we’ve learned how we can communicate between a browser and a server using
    WebSockets. But it is also possible to create a WebSocket client in Node.js, enabling
    two Node.js programs to communicate over WebSockets using the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a new file within our **websocket-server** directory, named
    **node-client.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Import the **ws** module and create a new WebSocket object that is configured
    to point to the WebSocket server we created in the *Creating a WebSocket* *server*
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll set up some listeners on our sockets. We will add listeners for
    the **open** , **close** , and **message** events:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, let’s send a **''Hello''** message to the WebSocket server every 3 seconds.
    We will use the **setInterval()** function to achieve this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start both the WebSocket server and your Node.js-based client in separate terminal
    windows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should expect to see the server responding every 3 seconds to your **''Hello''**
    message with the **World!** message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You’ve now created a WebSocket communication between two Node.js programs.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Interfacing with standard I/O* recipe in [*Chapter 2*](B19212_02.xhtml#_idTextAnchor041)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The *Communicating with sockets* recipe in [*Chapter 2*](B19212_02.xhtml#_idTextAnchor041)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19212_06.xhtml#_idTextAnchor178)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an SMTP server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**SMTP** is a protocol for sending emails. In this recipe, we will be setting
    up an SMTP server using a third-party **npm** module named **smtp-server** .'
  prefs: []
  type: TYPE_NORMAL
- en: You probably receive several automated emails per day in your inbox. In the
    *There’s more…* section, we’re going to learn how we can send an email via Node.js
    to the SMTP server we created in the recipe.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s create a directory named **server-smtp** and a file named **server.js**
    :'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'As we’ll be using the third-party **smtp-server** module from **npm** , we
    will need to initialize our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Note that we could not name our directory for this recipe **smtp-server** as
    **npm** refuses to allow you to install a module where the project name is the
    same as the module. If we had named our directory **smtp-server** , our **package.json**
    name would have also been set to **smtp-server** , and we would not be able to
    install the module with the same name.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, we will be creating an SMTP server that can receive email messages.
    We will use the **smtp-server** module to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, start by installing the **smtp-server** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to open **server.js** and import the **server-smtp** module:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let’s define the port that our SMTP server should be accessible at:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we’ll create an SMTP server object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We should also catch any errors. Register an error event listener function
    on the server object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we can call the **listen()** function to start our SMTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start your SMTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You can test a connection to your server by using either the **nc** or **telnet**
    command-line tools in a new terminal:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ve now confirmed that our SMTP server is available and listening on port
    **4321** .
  prefs: []
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the recipe, we leveraged the **smtp-server** module. This module takes care
    of the implementation of the SMTP protocol, meaning we can focus on the logic
    of our program rather than lower-level implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **smtp-server** module provides high-level APIs. In the recipe, we used
    the following to create a new SMTP server object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of the **SMTPServer** object accepts many parameters. A full
    list of options that can be passed to the **SMTPServer** constructor is available
    in the **nodemailer** documentation at [https://nodemailer.com/extras/smtp-server/](https://nodemailer.com/extras/smtp-server/)
    .
  prefs: []
  type: TYPE_NORMAL
- en: 'In this recipe, we added the **disabledCommands: [''STARTTLS'', ''AUTH'']**
    option. This option disabled **Transport Layer Security** ( **TLS** ) support
    and authentication for simplicity. However, in production, it would not be recommended
    to disable TLS support and authentication. Instead, it would be recommended to
    enforce TLS. You can do this with the **smtp-server** module by specifying the
    **secure:true** option.'
  prefs: []
  type: TYPE_NORMAL
- en: Should you wish to enforce TLS for the connection, you would also need to define
    a private key and a certificate. If no certificate is provided, then the module
    will generate a self-signed certificate; however, many clients reject these certificates.
  prefs: []
  type: TYPE_NORMAL
- en: The second option we specify on the **SMTPServer** constructor is the **logger:true**
    option, which enables logging from our SMTP server.
  prefs: []
  type: TYPE_NORMAL
- en: To start our **SMTPServer** constructor, we call the **listen()** function on
    the **SMTPServer** object. It is possible to pass the **listen()** function a
    port, a hostname, and a callback function. In this case, we only provide the port;
    the hostname will default to **localhost** .
  prefs: []
  type: TYPE_NORMAL
- en: There’s more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that we’ve set up a simple SMTP server, we should try sending an email to
    it via Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: To send an email with Node.js, we can use the **nodemailer** module from **npm**
    . This module is provided by the same organization as the **smtp-server** module
    used in the *Creating an SMTP* *server* recipe.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s start by installing the **nodemailer** module in our **server-smtp**
    directory:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we’ll create a file named **send-email.js** :'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first line of code we need to add to our **send-email.js** file to import
    the **nodemailer** module is the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to set up the transport object; we will configure the **transporter**
    object to connect to the SMTP server we created in the *Creating an SMTP* *server*
    recipe:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we can call the **sendMail()** function on the **transporter** object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The first parameter of the **sendMail()** function is an object representing
    the email, including the email address of the sender and receiver, the subject
    line, and the text of the email. The second parameter is a callback function that
    executes once the mail is sent.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To test our **send-email.js** program, first start the SMTP server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In a second terminal window, run your **send-email.js** program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE104]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should expect to see the following output from the server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the output like the following from the **send-email.js** program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE106]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This shows that we have successfully created an SMTP server, and we’re able
    to send emails to the SMTP server from another Node.js program.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Chapters 5* and *9*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
