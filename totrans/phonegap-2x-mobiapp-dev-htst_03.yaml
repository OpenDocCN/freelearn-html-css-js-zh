- en: Chapter 3. Being Productive
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: PhoneGap can be used for more than simple games and social media apps; it can
    also be used to create productivity apps that can be very useful. To do that,
    however, we need to learn about how to store persistent data using PhoneGap's
    File APIs. In this project, we'll do just that. We'll build a simple note-taking
    app named Filer that uses the File API to manage the available notes.
  prefs: []
  type: TYPE_NORMAL
- en: What do we build?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, Filer is more about file management than it is about taking notes,
    but it is absolutely critical that you get file management right. Users don't
    take it kindly when an app corrupts or loses their data, so you must make sure
    to manage it correctly. Once that is accomplished, you can move on to making the
    app more complex. Thankfully, the concepts you learn in this project can be applied
    to all your future apps.
  prefs: []
  type: TYPE_NORMAL
- en: What does it do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name implies, the app permits the user to *file* away notes for later
    retrieval. Doing this requires the use of the File APIs provided by PhoneGap.
    Not only do we need to be able to save and load notes, but we need to manage them
    as well. This includes removing notes at the user's request, renaming them, and
    duplicating them as well.
  prefs: []
  type: TYPE_NORMAL
- en: Once a note is created or opened, the app itself becomes very simple, essentially
    a large `TEXTAREA` element that will accept any kind of text you want to put in
    it. We'll also take a look at good ways to save and retrieve the data you enter.
  prefs: []
  type: TYPE_NORMAL
- en: Why is it great?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This app is a great way to learn the File APIs present in PhoneGap to manage
    files that your App needs in order to save and retrieve data. We'll also consider
    how to present this to the user in a form they can easily understand.
  prefs: []
  type: TYPE_NORMAL
- en: How are we going to do it?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll be going about creating this app much like we have the past apps, using
    the following pointers:'
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the data model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the data models
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the documents view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the file view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What do I need to get started?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You should be able to create your project and set it up much the same way as
    the prior apps. Call this project `Filer`.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, if you want, you can include the sharing libraries from the second
    project. We'll not use them directly, but there is a challenge at the end of the
    project that asks you to add sharing. If you intend to do this, you might as well
    add everything now.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the user interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, get your paper and pencil out or use your favorite image editor. Like
    in previous projects, we'll design our views using sketches and wireframes first,
    then flesh them out a bit more to design the graphical assets.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As in previous projects, the first view is the start view, but since it is
    the same as all the prior apps, we won''t go into detail about it here (refer
    to the *Designing the UI/interactions* section of [Project 1](ch01.html "Chapter 1. Let''s
    Get Local!"), *Let''s Get Local!*). Instead, let''s go to the documents view,
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this view we've actually got two looks; the left is for the iPhone, while
    the right is for Android. The reason for the two different looks is simply how
    a lot of apps do things on each platform. You typically see large, horizontal
    scrolling interfaces on iOS, and on Android you typically see vertical lists representing
    files.
  prefs: []
  type: TYPE_NORMAL
- en: Let's go over how this view works. The button in the navigation bar, named **Create**,
    allows the user to create a new note. Below the navigation bar is the list of
    files that are available. On the first run, of course, this will be empty, but
    as files are created, they are added here. This view will scroll as needed in
    order to show the entire list.
  prefs: []
  type: TYPE_NORMAL
- en: Each item in the list will have the same contents, even though they are arranged
    and sized differently. The first is the icon that represents the item; many apps
    will render a version of the content as this icon. To avoid complexity, we won't
    do that here; we'll use a static image instead. Tapping on the icon will open
    the note. The next is the icon's label, this shows the name of the file. When
    pressed, however, it will allow the user to rename the file.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below the file name are the following three icons:'
  prefs: []
  type: TYPE_NORMAL
- en: For duplicating (copying) the note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For sharing the note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For destroying (deleting) the note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: At first, none of this is terribly difficult, and really, it isn't. But the
    way the File APIs are implemented, it does take a bit of work to get right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move on to the file view, seen in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'This view is pretty simple: it displays the contents of the note and allows
    the user to edit it. Notice that there''s no **Save** button; the idea is that
    the notes will save themselves automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: When the view first appears, the keyboard won't be visible. This allows the
    user to see the note fill the screen. Once the note is tapped, however, the keyboard
    will appear, and the user will be able to change the note to their desire.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve created the wireframes, let''s go into our graphics program
    and create our resources. Here''s what we came up with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We'll take most of the interface here as images, the icons, the large paper
    image, and the navigation bar and view background itself as well. For Android,
    only the icons and the paper image matter; the latter two are for iOS only.
  prefs: []
  type: TYPE_NORMAL
- en: The icons themselves are obtainable from App-Bits for free ([http://app-bits.com/free-icons.html](http://app-bits.com/free-icons.html)),
    and the background texture is from Subtle Patterns, again for free ([http://subtlepatterns.com](http://subtlepatterns.com)).
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this task, we created the desired look and feel, and generated the necessary
    resources for our app.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the data model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go ahead and get your paper and pencil out again. We need to design the data
    model for the app. We''ll have two portions: one to manage the list of available
    documents, and another to manage a single document.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here''s what our model looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The first model, named **FilerDocuments,** is responsible for managing all the
    files available to the app, while the one on the right, named **FilerDocument**,
    is responsible only for a single note. The latter is responsible for loading a
    note and saving a note, while the former is responsible for reading an entire
    directory of notes and then managing them via renames, copies, and deletes.
  prefs: []
  type: TYPE_NORMAL
- en: A few notes of interest before we wrap this task up. Notice all methods that
    end with `…Success`. This is simply due to the way the File API is structured;
    everything is done asynchronously so you have to write each call to it with callbacks
    to both a `success` and a `failure` function. The `success` function points at
    the corresponding `Success` method, while the `failure` function points at the
    generic `dispatchFailure` method. (Failures are pretty generic; we want to log
    the failure, whereas successes may require additional steps to complete an operation.)
  prefs: []
  type: TYPE_NORMAL
- en: The `fileSystem` and `fileEntry` properties are also related to the File API.
    The `fileEntry` property is a pointer to a specific file, while the `fileSystem`
    property is a pointer to a specific directory on the device. (PhoneGap lets you
    specify if the directory should be a persistent one or a temporary one; we're
    using persistent.)
  prefs: []
  type: TYPE_NORMAL
- en: On the second model, note the title and text properties as well as the associated
    `get`/`set` methods. This is the actual data of a single note; everything else
    was simply to manage it.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created our data model for the document manager and a single note. In the
    next task, we'll implement both.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the data models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point you should have your project already created. We're going to be
    creating two models under the `www/models` directory, named `filerDocuments.js`
    and `filerDocument.js`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s get started by working on the Documents model that manages all the available
    documents:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This is the beginning of our constructor for the `Filers` object. The `completion`
    and `failure` variables are passed in because at the end of the constructor we
    will kick off a directory read operation and we want to alert the application
    when we're finished (or we get an error).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `state` property will store the current progress of an operation, which
    should make it easier to debug if an operation fails.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `completion` function here initially receives the completion but it also
    stores the `completion` function used by other functions within the object. This
    is because an operation may take several steps, each requiring an interim `completion`
    method. This just happens to be one from the app, not from within our object.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `documents` property stores the information received from the filesystem
    on each file we can read. It's not the actual document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `fileSystem` property points at the persistent storage on the device. Most
    operations begin by asking for a filesystem, and we can speed it up by saving
    it the first time we ask. Then other operations can use our cached value.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Just like `completion`, this is the `failure` function. `dispatchFailure()`
    will be called first, which then calls this one, if it is non-null.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For some of our operations, we have to store the information about a specific
    file; we do that using the `fileEntry` property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `loadFileSystem()` function can be called by the app at any time, but it
    is usually called when the app suspects that the documents available to us have
    changed. Say there may be a new one out there, and we want to be sure to display
    it to the user. Most of the operations in this class will try to re-read the directory
    after an operation (like renaming a file), but not every operation supports this,
    and this doesn't stop documents from appearing that we didn't explicitly create
    (say, from an iTunes import).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `getFilesystem()` function does the first thing we have to do when asking
    to see what files we have available to us: requests the filesystem. In this case,
    we''re asking for the persistent filesystem so that the data is stored permanently.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Generally, I like to keep `success`/`failure` methods close to the invoking
    method, but failures can be handled pretty generically (in our case), and so I
    just have one `failure` function that all our operations can call. It records
    a nice log message for us, and then checks to see if the app has registered a
    failure callback, and if it has, we'll call it too.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: When we're in the preceding function, we've got a valid filesystem. We save
    it for later use, and then we also call `getDocuments()` to start the process
    of getting every document our app can access.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In order to go over every entry in the directory of the filesystem we've got,
    we have to create a directory reader. We can do this by using the `directoryEntry`
    function passed to us (which is pointing to the filesystem we requested). Once
    we have that, we ask it to read all the entries and call `getDocumentsSuccess()`
    when it is finished.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding function, we read through all the entries given to us. One
    should never assume that all the entries in a directory are something that our
    app can handle, so we screen for subdirectories (which we won't be creating, so
    it won't be anything we can deal with), and then we also check for the file extension.
    If it is `.fln`, we assume the file is one of ours and add it to the list. If
    it has anything else, we ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: Once we're done iterating over the list, we call the `completion` method (if
    it exists) so that the app can do what it wants with the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The prior two methods are pretty self-explanatory. The first returns the number
    of documents we were able to get from the directory, and the second returns the
    information obtained for a specific document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This method isn't playing games; it'll physically remove the document at the
    specified index. Our app will ask the user first if they'd like to remove the
    document, so that it can't be accidentally called, but this function won't ask
    anyone if it is okay on its own. So be careful when calling it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: After a successful delete, we need to re-read the filesystem so that our `documents`
    array is up-to-date. We do this by calling `getFileSystem()`. You may wonder how
    the `completion` method defined in `deleteDocumentAtIndex` gets called, though.
    It gets called at the end of `getFileSystem()`. It checks to see if the `completion`
    property has been set (which we do at the beginning of `deleteDocumentAtIndex`),
    and if it has, it calls it. This is a pattern a lot of our operations will follow.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Renaming a document is simply a `moveTo` operation to the same directory. It
    follows the same pattern of operation as the preceding `delete` operation. Note
    that there is no check here for the new name of the file for if it isn't already
    being used by an existing file. If there is a name conflict, the new file will
    overwrite the old file, not likely something you want to occur. Since the preceding
    `deletion` method doesn't ask, we won't ask here either, but it is something you
    should do in the app itself.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Copying is again remarkably similar to renaming, as seen in the prior code;
    the difference is that we use `copyTo` instead of `moveTo`. The operation is also
    a bit different; if you were to try to copy over an existing document, the attempt
    fails, unlike moving over an existing document.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The `createDocument()` method creates a new file in the directory and after
    it does so, it re-reads the filesystem. This demonstrates an alternative to using
    `…Success()` methods. It works just the same, though. Just like renaming, this
    can be dangerous if a file with the same name already exists, so be sure to check
    before calling this method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: As seen in the prior code, opening a document is very similar to creating a
    document, except we don't ask the filesystem to create it if it doesn't exist.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Some operations, such as creating and opening a document, also set the `fileEntry`
    property to the newly opened document. This is handy for use when asking a note
    to open itself. It can read in contents of the file in this property.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As we mentioned prior to looking at the code for our model, we said that we'd
    initiate a directory read upon creation, and this is what we're doing at the end
    of the model. That way, when we create an object, it will instantly go to work
    reading the entries in the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the code for a single document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code should be self-explanatory now. Next up, in the following
    code, we see how to read the contents of a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When requesting to read a file, we have to call the `file()` method of the file's
    corresponding `fileEntry`. If it finds the file, it'll call `gotFile()` , but
    if it can't read it, for some reason, it'll call `dispatchFailure()`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Once we've got the file, we have to create a `FileReader` variable for it. Unlike
    other API calls, we have to set up some event handlers, but they mean the same
    thing here as `completion` and `failure`. Then we ask the reader to read the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Once we are here, `e.target.result` has the contents of the entire file. Now
    we can try to load it in.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: If there's nothing in the file, we set up some reasonable defaults. Notice that
    we're using `JSON` here. This is because we'll be storing our file in the `JSON`
    file format.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we try to parse the contents of the file as `JSON`. This is where the
    `try/catch` block comes in. If we can't parse the contents of the file, we'll
    get an error and we can call the `failure` function. But if we do parse it correctly,
    we can set our own `title` and `text` to the file's `title` and `text`, and we'll
    have successfully loaded the file's contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Saving a file isn't terribly different than loading a file, except that we can
    create the file writer directly from the `fileEntry` property rather than calling
    `file()` first. In `gotFileWriter` , though, we have to set similar events before
    calling `write()` with the file contents. We `stringify` the results of `serialize()`
    so that it is in a proper `JSON` format.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Speaking of serialization, here's the method that does it. Not hard, but you
    may be asking why we didn't just stringify `self`. And that's a great question.
    Turns out you can't stringify objects that contain methods, because it will lose
    those methods; so that's one reason. Another reason is that we really don't need
    to save the entire object, just the title and the text; so instead of saving a
    lot of stuff we don't need, we'll just return an object that has exactly what
    we need.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Like our first model, we ask the document here to load its file contents immediately
    upon creation.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this section, we created two data models, one for the list of available documents
    in a directory, and the second for the actual note itself.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The File API is notoriously hard to get used to, especially for programmers
    who assume that the order of processing is always the next statement after this
    one. The File API, however, does things differently, by requiring each operation
    to have a `success` and `failure` callback. Furthermore, there are several operations
    when reading or saving a file (or when reading a directory), and as such the callback
    chain can start to get pretty confusing. This is generally why I try to make separate
    functions instead of inline callbacks, but there are times when inline callbacks
    make the most sense.
  prefs: []
  type: TYPE_NORMAL
- en: The File API can do more than what we've covered here, so you'd do well to go
    take a look at it at [http://docs.phonegap.com/en/edge/cordova_file_file.md.html#File](http://docs.phonegap.com/en/edge/cordova_file_file.md.html#File).
    Just remember how the callbacks work and you'll be fine, even if your code will
    feel a bit spaghetti-ish.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing documents view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The documents view will be used to display the list of available documents to
    the end user. It will also permit the user to create a document, rename a document,
    copy a document, and delete a document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a quick look at the finished product, on iOS first:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing documents view](img/9403_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Android, the view will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing documents view](img/9403_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Notice that the screenshot for the iPhone has a totally different look and feel
    than the Android screenshot. While many apps for the iPhone use the alternative
    method used for Android, the method of scrolling horizontally through large document
    representations is more common on the iPhone, and is what we use here. Thankfully,
    it only takes a small code change and some CSS to render the two disparate looks.
    Otherwise, they function identically.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As always, we''re going to start with the HTML portion of the view. The boilerplate
    portion is virtually identical to our previous apps, so we''ll start with the
    template instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This template defines the HTML for each document we display. It's not terribly
    complicated. Note that we have `onClick` handlers for each portion of the template
    that can respond to touch, but beyond that the style is controlled in `style.css`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the code that powers this view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: First up, our properties. `lastScrollLeft` is for maintaining our scroll position
    when we switch between views. `myScroll` will hold our scroller (for iOS and Android),
    and `availableDocuments` will hold all the documents the filesystem has for our
    app.
  prefs: []
  type: TYPE_NORMAL
- en: The `initializeView()` method is so similar to our previous projects (refer
    to the *Implementing the start view* section of [Project 1](ch01.html "Chapter 1. Let's
    Get Local!"), *Let's Get Local!*), I'll go ahead and skip it and jump to `displayAvailableDocuments()`
    (which the `initializeView()` method does call).
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: First, we create a new `DOCS.Filers` object. Remember that this will immediately
    send a request to the filesystem for all the files it contains that we can use.
    When it successfully completes that request, it will call `documentsView.documentIterator()`,
    a method that will go over each item in the list and render the preceding template.
    If it fails, however, it calls the `failure` function defined earlier and displays
    an alert message.
  prefs: []
  type: TYPE_NORMAL
- en: This is big; we're no longer using the in-built `alert()` method! Instead, we're
    creating a new `Alert` object with the title of `Oops!` and `I couldn't read your
    persistent storage!` Granted, not the best error message in the world, but if
    this does occur, we're essentially toast anyway. The bigger issue is that this
    object, which we'll cover in more detail as we progress through this task, provides
    us with platform-specific non-native alerts. This means we can customize them
    to our needs; in this case that isn't much, we're displaying an error message,
    but the `PKUI.MESSAGE` namespace provides options for prompts as well. The `Alert`
    object also gives us the ability to specify a callback when a button is pressed,
    very useful if we need to ask a Yes/No question.
  prefs: []
  type: TYPE_NORMAL
- en: The next method, `reloadAvailableDocuments()`, is so similar to the earlier
    method that I'll also skip it. It's only used when the file view is being popped
    off the view stack.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty simple function: all we do is iterate through the documents
    that are returned from the filesystem and create a new instance of the `documentsView_documentTemplate`
    template. We''re using a new convenience method called `PKUTIL.instanceOfTemplate()`
    to make this easier. It will take a DOM element and an object containing the properties
    that should be replaced, in this case, `title` and `index`, along with their corresponding
    values. (The `substr()` method is used to chop off the file extension.)'
  prefs: []
  type: TYPE_NORMAL
- en: This method is doing the same thing we were doing manually before, using `replace()`,
    but it does it better. If you hadn't noticed, we were cleverly avoiding using
    the same substitution variable in our templates more than once. This is because
    `replace()` only replaces one instance at a time. Our convenience method keeps
    calling `replace()` until all instances are replaced, which means we can now use
    `%TITLE%` and `%INDEX%` all we want.
  prefs: []
  type: TYPE_NORMAL
- en: The portion of code specific to iOS simply determines the width of the content
    area for scrolling purposes. For Android, this code isn't executed.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Opening a document occurs when a user taps on the document's icon. (For Android,
    this is something you should think about changing, but for the purposes of this
    app, we'll keep consistent).
  prefs: []
  type: TYPE_NORMAL
- en: We call `openDocumentAtIndex()` and pass along the `completion` and `failure`
    functions that are called when the document is opened. The `success` method will
    set the `fileEntry` property of the `fileView` method and then push it on to the
    screen. This act will trigger loading the contents as well. Failure will log the
    error to the console, though you probably should add a meaningful error alert
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Welcome to the wonderful world of chaining callbacks! We have two steps to create
    a document. First, we ask the user what they want to name the document (using
    an admittedly obtuse default). Then we create the document, which means we have
    to have another success/failure callback. If we fail to create the document, we
    create another alert to further confuse matters.
  prefs: []
  type: TYPE_NORMAL
- en: The big deal, though, is that our initial request of the user is actually giving
    them a chance to type something in to our alert message! We've not done this yet
    in any of our apps, and this is monumental. Furthermore, we have custom buttons—a
    `Don't Create` button and a `Create` button.
  prefs: []
  type: TYPE_NORMAL
- en: If you're wondering what the `<` and `>` are in the preceding code attached
    to the buttons – great catch! These are used primarily for iOS, though you could
    extend these to the other platforms as well. iOS has the concept of a destructive
    action; these buttons should always be colored red. (Or, if the locale that you
    are targeting uses a different color, use that color instead.) It also has the
    concept of **Cancel** button colors (typically a darker gray). To add to it, we
    decided to color buttons that would go to the next step in the process green.
  prefs: []
  type: TYPE_NORMAL
- en: Each of these gets a special character at the end of the button's name. For
    example, `Cancel<` would color the button a darker color and use the text of `Cancel`
    for the button. `Go>` would use `Go` as the text, and color the button green.
    `Delete*`, on the other hand, would use `Delete` as the text, but color the button
    red.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just so you have a good idea of what an alert/prompt will look like on each
    system, here''s an example for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Android, the view will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting on with it](img/9403_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Renaming a document is somewhat similar to creating a new document, except
    that we won''t display the document at the end. We will ask the user what the
    new name should be, and if they choose to continue, we''ll try to perform the
    function. The following code snippet can be used for this action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: If there is a failure of some sort, we'll indicate this by displaying an error,
    once as a `failure` function, and second in the `catch` portion of the `try`/`catch`
    block.
  prefs: []
  type: TYPE_NORMAL
- en: Note that, as written, we make no check here to see if the new name would conflict
    with another file. Therefore, if the user renamed one file to the name of another,
    the previous file would be overwritten. You should add an additional check in
    your code to make sure that the new file name doesn't already exist.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `copyDocument()` method is nearly identical, so we''ll skip it and move
    on to the `deleteDocument()` method shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Deleting a document is much more simple than copying or renaming one, so we're
    not delving as deep in a callback chain here. The primary thing I wanted to point
    out was the use of the `*` to indicate that the `Remove` button would display
    as a red button to warn the user that it was a destructive action on iOS. Android
    silently ignores this flag, though you could modify the framework to display similar
    colors as well on Android
  prefs: []
  type: TYPE_NORMAL
- en: The remaining methods are similar to those in the previous views, so we'll go
    ahead and skip them.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Though there is a lot of room to improve, we've created a pretty good document
    manager for our app. We've permitted the user to rename their files, delete them,
    copy them, open them, and create them, all things a good file manager should do.
    The only thing we didn't do was permit the user to share them, though the intent
    is there with the pleasant **Share** icon. This was only in the interest of space,
    and because it is a subject that we've covered before.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are plenty of things we *haven''t* covered in this file manager of ours,
    and they''re big ones and definitely things you need to think about implementing
    on your own. The code itself would be self-explanatory, so we won''t go into great
    detail, but here are the primary issues:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Filenames can''t contain certain characters: Everyone handles this somewhat
    differently; you could display an error to the user indicating that they need
    to pick different characters or you could silently change them to something else
    (typical for iOS). Either way, you should check for them prior to creating a new
    file or renaming/copying a document.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Create/Rename operations can overwrite existing data: You''d think that since
    a copy operation will fail if the destination file exists, that rename/create
    would also. Unfortunately, no. They''ll just overwrite the file. You must iterate
    over the entire directory structure in order to determine if you''re about to
    overwrite an existing file! Users don''t like losing data, even if they themselves
    were the cause.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Opening a document for non-iOS users: Android users shouldn''t need to know
    that tapping the icon will open the document; they''ll assume the entire area
    is tappable (minus the icons). So it would be a good idea to give them another
    icon for renaming a file and allow the filename itself (as well as the document
    icon) to open the file instead of renaming the file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'iOS document images should reflect the contents of the file: This one''s harder
    to implement, granted, but typically the document icon would contain some portion
    of the actual contents of the file. There are various ways of doing this, from
    reading the actual contents in and displaying them over the DOM (and clipping
    them after some portion) to rendering them to an HTML `canvas` tag and saving
    the result as a thumbnail. Either way, it''s something the user will expect.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing the file view
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This view is pretty easy; actually it''s essentially a big `TEXTAREA` element
    with some code to automatically save the contents every few seconds. Let''s take
    a look at how it will render on each platform, first for iOS:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the file view](img/9403_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For Android, the view will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Implementing the file view](img/9403_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: All of these look pretty similar and reflect the simplicity of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Getting on with it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The HTML portion of the view is much like prior views, so we''ll skip that
    for now. Just know that there is a `TEXTAREA` element named `fileView_text` that
    our code will reference. There is also an `onClick` handler on the title bar to
    enable changing the title of the note. These are seen in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: As always, we have several properties. The first is intended to store information
    about the file we're currently working on, while the second is the actual document
    contents. The last property will store a value returned by `setInterval()`, this
    is used to call our auto-save functionality every few seconds.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Here we just provide a way for the `documentView` method to tell us which file
    to work with.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next method, `initializeView()`, is similar enough to the other views that
    we''ll skip over it. Next up is `entitleDocument()` shown in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: When the title is tapped, we'll display a prompt to the user that enables them
    to change the title of the note.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Loading the contents of a specific document is accomplished by creating a new
    `DOC.Filer()` object using the contents of our `fileEntry` property. This is assumed
    to have been set by `documentView` prior to pushing us onto the view stack.
  prefs: []
  type: TYPE_NORMAL
- en: Upon successfully parsing the document, we set the navigation bar's title to
    the document's title, and the `TEXTAREA` element's contents to the note's text.
    Then we set up the auto-save at an interval of five seconds.
  prefs: []
  type: TYPE_NORMAL
- en: If, for some reason, we can't open the file, we'll display an error, but we'll
    also pop ourselves off the view stack. No sense in displaying an editor if we
    can't even open the file.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Saving the contents is a simple affair. We copy the text from the `TEXTAREA`
    element and put in the `Filer` object. Then we ask it to save the contents of
    the file. If it is successful, we just log a message to the console (something
    you'd remove in a production app), and if it isn't, we display an error and pop
    the view. (Whether popping the view is a good idea or not is debatable.)
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `viewWillAppear()` method is pretty simple: we kick off a load of our note.
    This means that by setting `fileEntry` and pushing us on the view stack, we''ll
    automatically load the contents of the note.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: Our `viewWillHide()` method is a little more complex. Here we disable our auto-save.
    After all, we don't want to be saving a document that is no longer open. Then
    we force-save the document. Perhaps the user is navigating back in between an
    auto-save interval; they wouldn't want to lose any data, right?
  prefs: []
  type: TYPE_NORMAL
- en: After we save the contents, we also force the `documentsView` method to reload
    the list of documents. This isn't a big deal when we're-editing existing documents,
    but it is a big deal when we're creating new documents, as we want the file manager
    to be able to display our newly created note.
  prefs: []
  type: TYPE_NORMAL
- en: What did we do?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a simple text editor view that can open file contents and save them
    back again. It implements a simple auto-save function as well.
  prefs: []
  type: TYPE_NORMAL
- en: What else do I need to know?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Most of the devices that you will be targeting use soft keyboards for input.
    This means that some portion of the screen will be covered by the onscreen keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: How each device does this differs by platform and type of keyboard. For example,
    Android permits many different keyboards to be installed, and not every keyboard
    does things the same way.
  prefs: []
  type: TYPE_NORMAL
- en: Essentially, though, what happens is the available real-estate is moved or resized
    to permit the onscreen keyboard. This means our user interface also moves along
    with the keyboard. Whether or not this is done fluidly depends on the platform
    (and on Android, the keyboard itself, to some extent). iOS does this the best;
    there's a minimum of fuss involved, and the display scrolls neatly to ensure the
    text remains on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Android has a tendency to flicker a bit while they do this, unfortunately, and
    there's very little we can do to control how the keyboard itself appears.
  prefs: []
  type: TYPE_NORMAL
- en: One interesting option would be to implement the soft keyboard ourselves in
    pure HTML, CSS, and JavaScript. Technically this can work, but it remains a pretty
    large hack, and your soft keyboard won't really ever act like the legitimate keyboard
    on the platform. (And on Android, fans of a particular keyboard configuration
    will instantly hate it.) You'd also have to take into account the case when a
    user has connected a Bluetooth keyboard. This typically prevents the soft keyboard
    from appearing, which means the full real-estate of the screen is used for our
    display. Since there's no way (short of developing our own plugin) to determine
    if a hard keyboard is attached, we highly advise against using this option.
  prefs: []
  type: TYPE_NORMAL
- en: Some Android distributions also add an interesting quirk. It appears that `input`
    and `textarea` elements actually display another editable region above themselves
    when being edited. On my phone, this was visible by having a portion of the flashing
    cursor visible just underneath the current editor, almost as if the DOM element
    was just a mirror of a native input element. It wouldn't have been noticeable
    except for the fact that they were slightly misaligned. Odd, anyway, and I thought
    I would mention it.
  prefs: []
  type: TYPE_NORMAL
- en: Game Over..... Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've accomplished quite a lot in this task and while none if it is particularly
    glorious, it is absolutely necessary for what's ahead. Our apps must be able to
    store data permanently and they must also be able to retrieve that same data.
    Likewise, they need to provide methods for managing that data, including renaming,
    duplicating, and deleting it.
  prefs: []
  type: TYPE_NORMAL
- en: Can you take the HEAT? The Hotshot Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are several ways you can improve upon this app:'
  prefs: []
  type: TYPE_NORMAL
- en: Our app only asks the user if they really want to delete a file, but other operations
    are equally dangerous. Add in confirmations if the action the user is about to
    perform would overwrite data (for example, renaming a document to an existing
    document's name or creating a document with the same name as an existing document).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add functionality to check if the filename a user is supplying is valid. Then,
    either indicate this to the user or silently change the invalid characters to
    valid characters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don't provide subdirectory functionality, but there's no reason why you couldn't.
    In fact, we explicitly ignore subdirectories in our code, as they add a lot of
    complexity to the file management system. Why don't you add subdirectory management
    to the app?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instead of storing notes, perhaps you could store some forms instead. Perhaps
    simple addresses or reminders—really, just about anything.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
