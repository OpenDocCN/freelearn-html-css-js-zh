- en: Reusing Code Through Generic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is built from notions introduced by the previous chapters. The
    chapter built on top of notions by enhancing type by making them generic. Basic
    topics such as defining a generic class and interface are covered. Through the
    chapter, we move into more advanced topics such as generic constraints are part
    of the content. The goal of this chapter is to make your code more generic to
    increase the reusability of your classes, functions, and structures, to reduce
    the burden of duplicating code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The content in this chapter covers the following:'
  prefs: []
  type: TYPE_NORMAL
- en: How generic can make your code reusable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accepted kinds of data structure for generic type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to constrain the generic type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic and intersection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Default generic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic optional type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic constraints with a union type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Restricting string choices with `keyof`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Limiting the access to members of a generic type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing your type creation with a mapped type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic type in TSX file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic code to increase reusability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Generic is available in almost all typed language. It allows transforming your
    code in a reusable fashion without having to rely on unsafe casting to retrieve
    the value stored in an object. Without generic, there are different ways to achieve
    reusability. For example, you can have an interface with an `any` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'That would make the field open to receive any kind of object, hence being reusable
    for many scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A slightly better way would be to specify whether we want to accept primitives
    or only objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'In both cases, the problem comes when we want to use the reusable field. The
    same result occurs with `any` or `object`, which is that we do not have access
    to the original variable''s member because we do not have a way to know what was
    the original type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'In this code, it is impossible to use `.test` of the entity without casting
    back to the entity. In that particular type, it is an anonymous type but still
    possible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'However, generic can remove this hinder to access the original type by bringing
    the type of the object into the definition of the type without tampering the type
    to be isolated with a single type. To create a generic function, interface, or
    class, you need to use the smaller or bigger sign, `< >`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The name between the brackets does not matter. In the following code, we are
    using the entity with two custom interfaces and use them as type `T`. We are also
    using a number directly. We can use all the possible types because we do not have
    a generic constraint, yet, in place:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The biggest advantage is that if we access the object, the field entity is
    of a `T` type, which changes depending on how the object was created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Accepted kinds of data structure for generic type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The concept of generic spreads beyond just interfaces. Generic is available
    for types but also with classes, and it can transform a function as well. The
    disposition of the brackets that define the generic type goes right after the
    interface name, type, or the class name. We will see later that it must also go
    after the name of a function. Generic can be used to have a generic field, generic
    parameter, generic return type, and generic variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'A generic type can have many generics at the same time, allowing multiple fields
    or function parameters to have a different kind of type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Constaining a generic type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In a previous code example in this chapter, we used the type object to make
    sure no primitives were passed in an interface. The problem with the use of an
    object is that you do not get back the initial type when you get back the entity.
    The following code illustrates the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to keep the original type and have a constraint to not allow
    a primitive with the keyword `extends`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `extends` keyword allows specifying the minimum structure that must be
    present in the object passed to the generic type. In that case, we were passing
    an object. However, we could extend any minimum structure, interface, or type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code example has two variables that do not compile. The first
    one, the variable is set to a wrong object. The third variable is set to a string,
    but the generic constraint cannot be fulfilled by the string because it doesn''t
    have the id:number field. The second variable compiles because of the entity respect
    the constraint. Finally, here is an example of having a generic with a constraint
    that is an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Other than having access back to the full original type, generic with constraint
    allows accessing the constrain field from the class or function that implements
    the generic. The first code example, with `function`, has the constraint directly
    at the function signature. It allows accessing only the field from the constraint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, a class lets you use inside any of its functions, the field from
    the generic constraint. In the following code, the function loops the generic
    list of `T`. Since `T` is extending `ObjectWithId` that has `what` property and
    `id`; both are accessible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Generic and intersection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Generic and intersection work well together. It allows the use of an undetermined
    type and creates a second one with the combination of a known type or another
    generic. In the following code, there is a generic function that takes a type
    `T` that must respect to a minimum the structure of the `User` object. The return
    type of the function is the generic type passed by a parameter intersected by
    a new `WithId` structure. It means that whatever the type passed will be enhanced
    with the new structure. In the code, the `Developer` type is passed to the function
    and the function returns `Developer+WithId`. It is a new type, not defined anywhere,
    but is still strongly typed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The code shows that we can use the return type and have all three members available.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is possible to intersect many generic types together, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `merge` function takes two different types and merges them using the JavaScript
    `assign` function. The function returns the intersection of both types. If we
    dig into the definition of the `Object.assign` function, we realize that this
    one is also leveraging the intersection with generic. Here is the definition file
    of `Object.assign` for ES2015:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Default generic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The more you work with generic, the more you may find that for a particular
    case in your system you are using always the same type. It could almost not be
    generic but be of a specific type. In that case, it is interesting to use a default
    type for your generic. A default generic type allows avoids having to specify
    a type. A default generic is also known as an optional type.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript uses the type specified in the generic signature after the equals
    sign:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Three variables are declared. The first and second ones are exactly the same:
    they expect an object with an `id` of a `string` type. The last is a number. The
    reason the first and second are exactly the same is that the first declaration
    relies on the default type. The default type is specified in the generic definition
    of the interface after the name of the type, `T`. The use of the equals signs
    allows the assignation.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the case of multiple defaults, only optional typing can be used if no type
    is optional afterward. The following code shows the same interface, the first
    one does not compile because it has the optional generic type before a required
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Default generic can have constraints and it deems to respect constraint with
    its default type. The following code does not work because the default type is
    set to be a number. However, the constraint mentions that the structure must have
    an id of type `number`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if we change the default type to be `User<number>` it compiles. The
    reason is that user interface has an `id` field of type `T`. The default type
    is not compatible with the constraint extended, which requires an `id` of a `number`
    type. This means that without explicitly mentioning the generic type of `User`
    in the default signature, the code does not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: A default type is used when a type is not explicit or when TypeScript cannot
    infer the type.
  prefs: []
  type: TYPE_NORMAL
- en: Generic optional type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A generic type can be optional in a function or a class. When optional and
    generic, the type becomes an empty object or undefined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Providing a default value to an optional type changes the parameter from an
    empty object to the default type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Generic constraints with a union type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is some room for using a union in the `extends` clause of a generic definition.
    While you cannot use `discriminator`, you can compare against an array. The following
    object allows a type and an array of the same type. You can narrow down to any
    of the two types using `instanceOf` and manipulate the parameter value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Trying to extend two different objects with a discriminator does not work at
    the moment.
  prefs: []
  type: TYPE_NORMAL
- en: Restricting string choices with keyof
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The use of string in JavaScript is omnipresent. One pattern is to access a
    member of an object dynamically with the square bracket:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the code is that `name` is a string and could be anything.
    We could set between brackets` firstname`, and the code would compile. At runtime,
    the console would show `undefined`. To avoid falling into the pitfall of selecting
    a member that does not exist, we can use `keyof`, which will return a union of
    all members of an object. The union is a `string literal` of all members' names.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before going with `keyof`, create a `function` that tries to access a property
    by a string fail, without defining an index signature (see *Index signature* in
    this book):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the same function with `keyof` will work without an index signature.
    The reason is that TypeScript knows that you do not try to access a field that
    might not exist. The goal of accessing with the square bracket is to access members
    that exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `keyof` allows specifying in a string format the only field from the type
    after the `keyof` keyword. In the code example before, only the string `name`,
    `birthdate` and `isHappy` can be entered without having the compiler show an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Limiting the access to members of a generic type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to use generic with `keyof` in a constraint to only specify in
    a string format member name from the generic object.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we are passing an object in the first parameter, and
    in the second accepting only the member name of the first parameter object. The
    constraint syntax is the same using `extends` followed by `keyof` and the first
    generic type. The return type is the return type of the selected member, which
    is accessible by using the first generic with the index signature of the second
    generic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The syntax provides a good type safety, in terms of specifying members of an
    object that can be from a variety of potential types, and also provides safety
    in terms of the return type. If `name` changes from `string` to a rich object
    (with many members), the code consuming the return of this function will break
    at compilation time. It's the same if the name changes, the refactoring tool will
    change it. However, if the change is done without using any refactoring tool,
    the compiler will catch that the name is not a valid one.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code shows how `keyof` can be used to make sure a function returns
    the name of the desired member. The first time the function is called, it returns
    `name`; however, the second invocation does not compile because the name of the
    member does not exist in the generic type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Reducing your type creation with mapped type
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you start typing all your objects, you may fall into the situation where
    you need to have almost the same type but with some minor differences. You may
    want the exact same property but all readable, when the main type has a few read-only
    types. You may want to have all field optionals to allow partial object updates
    or you may want to seal an object by making all its properties read-only. You
    might even want to have all your properties to be a string because your form handle
    string values only, but later has the real interface or type with the good type.
    TypeScript allows creating dynamic type from an existing one. This transformation
    of the type is named *mapped type*. Mapped type allows reducing the burden of
    duplicating an object just to change a property on the type, while keeping the
    same structure of your definition.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript comes with many mapped types that you can use without having to
    build your own mapped type. Here are two common ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The first one, `Readonly`, takes a generic type and loops all its members and
    adds `readonly`. It also returns the same type with `T[P]`. The second one, `Partial`,
    adds the *?* character after the name, which means that every field becomes optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we want to have the variable to be sealed and completely not editable, we
    can use `Readonly`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to allow someone to modify only a part of your entity and then
    merge the result, you can use `Partial`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'You can create your own mapped type by using the type keyword and creating
    a name with an *in* operator to loop the member and defining the transformation.
    It is important to notice that we do not manipulate the data, only the type. It
    means that if you are changing the type that you still need to manipulate the
    object to have the expected shape that will fulfil the mapped type. Here are two
    examples of the custom type. The first one returns a string for all members. The
    second removes the `Readonly`. You can see the minus sign before the property,
    which indicates to TypeScript that the modifier of the member is taken away:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Mapped type can be stacked to create a final type that combines all mapped
    types. In the following example, we stack two mapped types:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The code is legit but does not work. The reason is that TypeScript figures out
    that the `e1.id` is of type number and something tries to cast it into a string
    that does not occur automatically. As mentioned, a mapped type is only good as
    a cast and requires you to have the proper code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a quick and small function that does the trick. Do not use this code
    in production, since it does not cover the transformation into a string property
    (especially with `object` and `array`), but it illustrates the required transformation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Generic type in TSX File
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TSX is the equivalent of JSX, the JavaScript XML extension language. For a
    long period of time, TypeScript was supporting TSX but wasn''t friendly with generic.
    The main reason is that TSX and the generic syntax share the angle brackets, which
    was causing the compiler to misinterpret the generic type when in a TSX file.
    However, the situation has changed, and TypeScript distinguishes when the square
    brackets are to explicitly define the type of a generic component. In the following
    snippet, you can see the `CallGenericComponent` that tries to render a generic
    component. The return is using an initial opening angle bracket to initialize
    the TSX component. The following and second opening angle bracket is to define
    the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The use of the angle brackets allows to avoids defining the component as a variable
    and having to instantiate it, which was not only required multiple lines but also
    to cast with any. Furthermore, the readability was compromised and the intention
    was unclear to an external pair of eyes.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we saw how to transform your code by using generic. TypeScript
    provides constraints to limit what can be passed into generic, and we saw how
    to leverage the constraint to guide the user as to what can be passed. We also
    saw how powerful the use of `keyof` is, allowing us to dynamically get members
    from a type. We saw how to manipulate type in a generic way, with mapped type.
  prefs: []
  type: TYPE_NORMAL
