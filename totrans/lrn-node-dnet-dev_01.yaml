- en: Chapter 1. Why Node.js?
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 1 章. 为什么选择 Node.js？
- en: Node.js is still relatively new compared to platforms such as .NET and Java,
    but has become very popular in a short time, and has even started influencing
    these platforms. This is thanks to its distinctive programming model, extensive
    ecosystem, and powerful tooling.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 与 .NET 和 Java 等平台相比，Node.js 仍然相对较新，但它在短时间内变得非常流行，甚至开始影响这些平台。这得益于其独特的编程模型、广泛的生态系统和强大的工具。
- en: These factors make Node.js a compelling alternative to other platforms. They
    can also make it intimidating. Its distinctive programming model may seem quite
    alien compared to other platforms. The sheer range of available libraries and
    tools can be bewildering.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这些因素使 Node.js 成为其他平台的有力替代品。它们也可能使其令人畏惧。与其他平台相比，其独特的编程模型可能显得相当陌生。可用的库和工具的范围可能令人困惑。
- en: This book will guide you through Node.js so you can start using it in your applications.
    It will help you to understand Node.js, navigate its ecosystem, and leverage your
    existing development skills in this new environment.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本书将引导您了解 Node.js，以便您可以在应用程序中使用它。它将帮助您理解 Node.js，导航其生态系统，并利用您现有的开发技能在这个新环境中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the Node.js platform
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Node.js 平台
- en: Seeing how its execution model works
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解其执行模型如何工作
- en: Exploring the Node.js ecosystem
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 探索 Node.js 生态系统
- en: Looking at JavaScript as a language choice
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 JavaScript 视为语言选择
- en: Considering the range of use cases for Node.js
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑 Node.js 的使用案例范围
- en: What is Node.js?
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是 Node.js？
- en: Node.js consists of a JavaScript engine together with low-level APIs for core
    server-side functionality. The execution engine is the same V8 engine developed
    for the Chrome web browser. Node.js takes this engine and embeds it in a standalone
    application that can run JavaScript outside the browser.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 由一个 JavaScript 引擎和用于核心服务器端功能的高级 API 组成。执行引擎是专为 Chrome 浏览器开发的 V8 引擎。Node.js
    将此引擎嵌入到一个独立的应用程序中，可以在浏览器之外运行 JavaScript。
- en: 'In Node.js, the standard APIs found in browsers to support client-side web
    development, such as the **Document Object Model** **(DOM)** and `XMLHttpRequest`,
    are not present. Instead, there are APIs to support general-purpose application
    development. These core APIs cover low-level functionality such as the following:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中，浏览器中用于支持客户端 Web 开发的标准 API，如 **文档对象模型** **(DOM)** 和 `XMLHttpRequest`，并不存在。相反，有
    API 支持通用应用程序开发。这些核心 API 覆盖以下低级功能：
- en: Networking and security
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络和安全
- en: Accessing the file system
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 访问文件系统
- en: Defining and requiring modules
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和引入模块
- en: Raising and consuming events
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出和消费事件
- en: Handling binary data streams
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理二进制数据流
- en: Compression
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 压缩
- en: UTF-8 support
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UTF-8 支持
- en: Retrieving basic information about the OS
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取关于操作系统的基本信息
- en: Managing child processes
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 管理子进程
- en: Some of these APIs may already be familiar from developing client-side JavaScript.
    For example, the Timers API exposes the familiar `setTimeout` and `setInterval`
    functions.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 其中一些 API 可能已经从客户端 JavaScript 开发中熟悉。例如，Timers API 揭示了熟悉的 `setTimeout` 和 `setInterval`
    函数。
- en: Node.js also provides several tools to help with the development process. These
    include console logging, debugging, a **Read-Eval-Print Loop** (**REPL**) (or
    interactive console), and basic assertions for testing.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 还提供了一些工具来帮助开发过程。这些包括控制台日志记录、调试、**读取-评估-打印循环**（**REPL**）（或交互式控制台）以及基本的断言用于测试。
- en: Understanding the Node.js execution model
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 Node.js 执行模型
- en: The execution model of Node.js follows that of JavaScript in the browser. It
    is quite different from that of most general-purpose programming platforms.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 的执行模型遵循浏览器中 JavaScript 的执行模型。它与大多数通用编程平台的执行模型相当不同。
- en: Stated formally, Node.js has a single-threaded, non-blocking, event-driven execution
    model. We will define each of these terms in this section.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 正式来说，Node.js 具有单线程、非阻塞、事件驱动的执行模型。我们将在本节中定义这些术语中的每一个。
- en: Non-blocking
  id: totrans-27
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 非阻塞
- en: Put simply, Node.js recognizes that many programmes spend most of their time
    waiting for other things to happen, for example, slow I/O operations such as disk
    access and network requests.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，Node.js 认识到许多程序的大部分时间都在等待其他事情发生，例如，慢速 I/O 操作，如磁盘访问和网络请求。
- en: 'Node.js addresses this by making these operations non-blocking. This means
    that program execution can continue while they happen. For example, the filesystem
    API''s `stat` function for retrieving statistics about a file may be called as
    follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js通过使这些操作非阻塞来解决这个问题。这意味着程序执行可以在它们发生时继续。例如，文件系统API的`stat`函数用于检索关于文件的统计信息，可以如下调用：
- en: '[PRE0]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Two arguments are passed to the `fs.stat` function: the name of the file that
    we are interested in, and a **callback function**. The `fs.stat` call returns
    immediately, returning control of execution to the current thread but not returning
    a value. If there are further commands following the `fs.stat` call, these will
    then be executed. Otherwise, the thread is released to perform other work. The
    callback function is invoked (that is ''*called back*'') only after the runtime
    has finished communicating with the filesystem. The result of the filesystem operation
    is passed into the callback function.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`fs.stat`函数传递了两个参数：我们感兴趣的文件的名称和一个**回调函数**。`fs.stat`调用立即返回，将执行控制权交还给当前线程，但不返回值。如果`fs.stat`调用之后还有其他命令，那么这些命令将被执行。否则，线程将被释放以执行其他工作。回调函数仅在运行时与文件系统通信完成后被调用（即''*回调*''）。文件系统操作的结果传递给回调函数。'
- en: This non-blocking approach is also called **asynchronous** programming. Other
    platforms support this (for example, C#'s `async`/`await` keywords and .NET's
    Task Parallel Library). However, it is baked in to Node.js in a way that makes
    it simple and natural to use. Asynchronous API methods are all called in the same
    way as `fs.stat`. They all take a callback function that gets passed error and
    result arguments.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这种非阻塞方法也称为**异步**编程。其他平台也支持这种编程（例如，C#的`async`/`await`关键字和.NET的Task Parallel Library）。然而，在Node.js中，它被内建得既简单又自然。异步API方法都像`fs.stat`一样调用。它们都接受一个回调函数，该函数传递错误和结果参数。
- en: Event-driven
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 事件驱动
- en: The event-driven nature of Node.js describes how operations are scheduled. In
    typical procedural environments, a program has an entry point that executes a
    set of commands until completion, or enters a loop and performs some processing
    on each iteration.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的事件驱动特性描述了操作是如何被安排的。在典型的过程式环境中，一个程序有一个入口点，执行一系列命令直到完成，或者进入循环并在每次迭代中执行一些处理。
- en: Node.js has a built-in **event loop**, which isn't exposed to the developer.
    It is the job of the event loop to decide which piece of code to execute next.
    Typically, this will be a callback function that is ready to run in response to
    some other event. For example, a filesystem operation may have completed, a timeout
    may have expired, or a new network request may have arrived.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js有一个内置的**事件循环**，它不对开发者公开。事件循环的职责是决定接下来执行哪段代码。通常，这将是一个准备好运行的回调函数，作为对其他事件的响应。例如，文件系统操作可能已完成，超时可能已过期，或者可能已到达新的网络请求。
- en: This built-in event loop simplifies asynchronous programming by providing a
    consistent approach and avoiding the need for applications to manage their own
    scheduling.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 这个内置的事件循环通过提供一致的方法并避免应用程序需要管理自己的调度，简化了异步编程。
- en: Single-threaded
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单线程
- en: The single-threaded nature of Node.js simply means that there is only one thread
    of execution in each process. Also, each piece of code is guaranteed to run to
    completion without being interrupted by other operations. This greatly simplifies
    development and makes programs easier to reason about. It removes the possibility
    for a range of concurrency issues. For example, it is not necessary to synchronize/lock
    access to shared in-process state as it is in Java or .NET. A process can't deadlock
    itself or create race conditions within its own code. Single-threaded programming
    is only feasible if the thread never gets blocked waiting for long-running work
    to complete. Thus, this simplified programming model is made possible by the non-blocking
    nature of Node.js.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的单线程特性简单来说就是每个进程中只有一个执行线程。此外，每一块代码都保证能够运行完成，而不会被其他操作中断。这极大地简化了开发，并使得程序更容易推理。它消除了各种并发问题的可能性。例如，不需要像Java或.NET那样同步/锁定对共享进程内状态的访问。一个进程不能自己死锁或在其代码中创建竞态条件。单线程编程只有在线程永远不会因为长时间运行的工作而阻塞等待时才是可行的。因此，这种简化的编程模型是由Node.js的非阻塞特性实现的。
- en: Introducing the Node.js ecosystem
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍Node.js生态系统
- en: The built-in Node.js APIs provide a low-level core for creating applications.
    Applications typically only use a small number of these APIs directly. They often
    use third-party library modules that provide higher-level abstractions for application
    development.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 内置的 Node.js API 为创建应用程序提供了一个低级核心。应用程序通常只直接使用这些 API 的一小部分。它们通常使用第三方库模块，这些模块为应用程序开发提供了更高层次的抽象。
- en: Node.js has its own package manager, **npm**. This is similar to .NET's NuGet
    or the package management aspects of Java's Maven. Applications specify their
    dependencies in a simple JSON file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 有自己的包管理器，**npm**。这与 .NET 的 NuGet 或 Java 的 Maven 的包管理方面类似。应用程序在简单的 JSON
    文件中指定它们的依赖项。
- en: The **npm registry** provides a central repository for packages. This registry
    has grown rapidly and is already much larger (in terms of number of available
    packages) than the corresponding repositories for other platforms (see [http://www.modulecounts.com/](http://www.modulecounts.com/)).
    There are hundreds of thousands of packages available, providing a vast array
    of functionality.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm 注册表**提供了一个包的中央存储库。这个注册表迅速增长，并且已经比其他平台的相应存储库大得多（在可用的包数量方面）（见 [http://www.modulecounts.com/](http://www.modulecounts.com/)）。有数十万个包可供选择，提供了广泛的功能。'
- en: The **npm command line tool** can be used to download packages and install new
    ones. Library dependencies are installed locally to each application. Some packages
    provide command-line tools, which may be installed globally rather than under
    a specific project.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '**npm 命令行工具**可以用来下载包和安装新的包。库依赖项被安装到每个应用程序的本地。一些包提供命令行工具，这些工具可能被全局安装而不是在特定项目下。'
- en: Many frameworks available on npm are split into a small extensible core and
    a number of composable modules. This approach makes it easy to understand the
    libraries on which your application depends, avoiding the need to reason about
    complex heavyweight frameworks.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在 npm 上可用的许多框架被分为一个小型的可扩展核心和多个可组合模块。这种方法使得理解你的应用程序所依赖的库变得容易，避免了需要推理复杂重量级框架的需求。
- en: The consistency of calling non-blocking (asynchronous) API methods in Node.js
    carries through to its third-party libraries. This consistency makes it easy to
    build applications that are asynchronous throughout.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Node.js 中调用非阻塞（异步）API 方法的一致性也体现在其第三方库中。这种一致性使得构建全异步的应用程序变得容易。
- en: Why JavaScript?
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么选择 JavaScript？
- en: JavaScript is a language that can seem unintuitive compared to other popular
    **object-oriented** (**OO**) languages. It also has a number of quirks and flaws
    that have drawn criticism (and occasional ridicule). It might then seem a surprising
    choice of language for a new programming platform. This section discusses the
    factors that make JavaScript a more appealing choice.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他流行的**面向对象**（**OO**）语言相比，JavaScript 似乎是一种不太直观的语言。它还有一些怪癖和缺陷，这引起了批评（以及偶尔的嘲笑）。因此，它可能是一个新的编程平台的选择似乎令人惊讶。本节讨论了使
    JavaScript 成为更具吸引力的选择的因素。
- en: A clear canvas
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清晰的画布
- en: The size and complexity of JavaScript is part of its appeal. The core language
    itself, which doesn't include APIs such as the DOM, is small and simple. This
    makes it easy for Node.js to establish its own styles and conventions.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 的大小和复杂性是其吸引力的一部分。核心语言本身（不包括 DOM 等API）小巧简单。这使得 Node.js 能够建立自己的风格和约定。
- en: The new APIs provided by Node.js and the consistent approach to asynchronous
    programming wouldn't be possible in a more complex language with a larger pre-existing
    standard class library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js 提供的新 API 和一致的异步编程方法在更复杂、具有更大预存标准类库的语言中是不可能的。
- en: Functional nature
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数性
- en: JavaScript was first built as a programming language for client-side functionality
    in the browser. This might not make it an obvious choice for general-purpose programming.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 最初被构建为浏览器客户端功能的一种编程语言。这可能不会让它成为通用编程的明显选择。
- en: In fact, these two use cases do have something important in common. User interface
    code is naturally event-driven (for example, binding event handlers to button
    clicks). Node.js makes this a virtue by applying an event-driven approach to general-purpose
    programming.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这两个用例确实有一些重要的共同点。用户界面代码自然是事件驱动的（例如，将事件处理器绑定到按钮点击）。Node.js 通过将事件驱动方法应用于通用编程来使这一点成为优点。
- en: JavaScript supports functions as first-class objects. This means it's easy to
    create functions dynamically and pass around references to them. This fits in
    well with the asynchronous, non-blocking approach of Node.js. In particular, it's
    easy to expose and use APIs based around callback functions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript支持将函数作为一等对象。这意味着可以动态地创建函数并传递它们的引用。这与Node.js的异步、非阻塞方法很好地结合在一起。特别是，基于回调函数的API的暴露和使用变得非常容易。
- en: A bright future
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 光明的未来
- en: JavaScript has received a lot of attention in the last several years as it has
    become more widely used for providing rich functionality on the Web. Browser vendors
    have put a huge amount of engineering effort into improving the performance of
    JavaScript. Node.js benefits from this directly via its use of Chrome's V8 engine.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去几年中，JavaScript因其被广泛用于在Web上提供丰富功能而受到了很多关注。浏览器供应商投入了大量的工程努力来提高JavaScript的性能。Node.js通过使用Chrome的V8引擎直接受益于这一点。
- en: The JavaScript language itself is undergoing some major changes for the better.
    The ECMAScript 2015 standard (previously known as ES6) represents the most significant
    revision of the language in its history. It introduces features that make the
    language more intuitive and less verbose. It also addresses flaws that JavaScript
    has been criticized for in the past, removing gotchas and making programs easier
    to reason about.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript语言本身正在进行一些重大的改进，以使其变得更好。ECMAScript 2015标准（之前称为ES6）代表了该语言历史上最重大的修订。它引入了使语言更直观、更简洁的功能。它还解决了JavaScript过去被批评的缺陷，消除了陷阱，使程序更容易推理。
- en: When to use Node.js
  id: totrans-58
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 何时使用Node.js
- en: As discussed earlier in this chapter, Node.js recognizes that I/O is a bottleneck
    for many applications. On most programming platforms, threads will waste time
    blocking on I/O operations. There are approaches developers can take to avoid
    this, but these all involve adding some complexity to their code. In Node.js,
    the platform itself provides a completely natural approach.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所讨论的，Node.js认识到I/O是许多应用的瓶颈。在大多数编程平台上，线程会在I/O操作上浪费时间。开发者可以采取一些方法来避免这种情况，但这些方法都需要在他们的代码中增加一些复杂性。在Node.js中，平台本身提供了一个完全自然的方法。
- en: Writing web applications
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写Web应用
- en: 'The flagship use case for Node.js is building web applications. These are inherently
    event-driven as most or all processing takes place in response to HTTP requests.
    Also, many websites do little computational heavy-lifting of their own. They tend
    to perform a lot of I/O operations:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js的旗舰用例是构建Web应用。这些应用本质上是事件驱动的，因为大多数或所有处理都是在响应HTTP请求时进行的。此外，许多网站本身进行的计算工作量很小。它们倾向于执行大量的I/O操作：
- en: Streaming requests from the client
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端流式请求
- en: Talking to a database, locally or over the network
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与本地或通过网络与数据库通信
- en: Pulling in data from remote APIs over the network
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过网络从远程API拉取数据
- en: Reading files from disk to send back to the client
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从磁盘读取文件以发送回客户端
- en: These factors make I/O operations a likely bottleneck for web applications.
    The non-blocking programming model of Node.js allows web applications to make
    the most of a single thread. As soon as any of these I/O operations starts, the
    thread is immediately free to pick up and start processing another request. Processing
    of each request continues via asynchronous callbacks when I/O operations complete.
    The processing thread is only kicking off and linking together these operations,
    never waiting for them to complete. This allows Node.js to handle a much higher
    rate of requests per thread than other platforms. You can also still make use
    of multiple threads (for example, on multi-core CPUs) by simply running multiple
    instances of the Node.js process.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 这些因素使得I/O操作很可能是Web应用的瓶颈。Node.js的非阻塞编程模型允许Web应用充分利用单线程。一旦这些I/O操作中的任何一个开始，线程就会立即空闲出来，开始处理另一个请求。当I/O操作完成时，每个请求的处理将通过异步回调继续进行。处理线程只是启动并链接这些操作，而不会等待它们完成。这使得Node.js能够比其他平台处理每线程的请求数量要高得多。你也可以通过简单地运行多个Node.js进程实例来利用多个线程（例如，在多核CPU上）。
- en: Identifying other use cases
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别其他用例
- en: There are of course some applications that don't perform much I/O and are more
    likely to be CPU bound. Node.js would be less suitable for computationally-intensive
    applications. Programs that do a lot of processing of in-memory data are less
    concerned about I/O.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，也有一些应用程序的I/O操作不多，更可能是CPU密集型的。Node.js对于计算密集型应用程序可能不太适合。处理内存中大量数据的程序对I/O的关注较少。
- en: 'Web applications are not the only I/O-heavy applications though. Other classes
    of program that could be a good candidate for Node.js include the following:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然Web应用程序不是唯一的高I/O应用程序，但以下类别的程序也可能是Node.js的良好候选者：
- en: Tools that manipulate large amounts of data on disk
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作磁盘上大量数据的工具
- en: Supervisor programs coordinating other software or hardware
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 协调其他软件或硬件的监督程序
- en: Non-browser GUI applications that need to respond to user input
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要响应用户输入的非浏览器图形用户界面应用程序
- en: Node.js is especially suitable for *glue* applications that pull together functionality
    from other remote services. The increasing popularity of microservices as an architectural
    pattern makes this kind of application more common.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js特别适合作为*粘合剂*应用程序，将来自其他远程服务的功能组合在一起。微服务作为架构模式日益流行，使得这类应用程序更加常见。
- en: Why now?
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么现在？
- en: Node.js has been around for several years, but now is the perfect time to start
    using it if you haven't already.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js已经存在了几年，但如果你还没有开始使用它，现在正是时候。
- en: The release of Node.js v4 towards the end of 2015 consolidated the project's
    governance model and heralds Node.js coming to maturity. It also allows the project
    to keep more up to date with the V8 engine. This means that Node.js can benefit
    more directly from ongoing development on V8\. For example, security and performance
    improvements to V8 will now make their way into Node.js much sooner.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: Node.js v4在2015年底的发布巩固了项目的治理模式，预示着Node.js的成熟。它还允许项目与V8引擎保持更紧密的更新。这意味着Node.js可以更直接地从V8的持续开发中受益。例如，V8的安全性和性能改进现在将更快地进入Node.js。
- en: As discussed earlier in this chapter, the release of the ECMAScript 2015 standard
    makes JavaScript a much more appealing language. It pulls in useful features from
    other popular OO languages and resolves a number of long-standing flaws in JavaScript.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如本章前面所讨论的，ECMAScript 2015标准的发布使JavaScript成为一个更具吸引力的语言。它从其他流行的面向对象语言中引入了有用的功能，并解决了JavaScript中一些长期存在的问题。
- en: Meanwhile, the ecosystem of third party libraries and tools around Node.js and
    JavaScript continues to grow. Node.js is treated as a first-class citizen by major
    hosting platforms. Companies such as Google and Microsoft are also throwing their
    weight behind JavaScript and related technologies.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，围绕Node.js和JavaScript的第三方库和工具生态系统继续增长。Node.js被主要托管平台视为一等公民。像Google和Microsoft这样的公司也在支持JavaScript和相关技术。
- en: Summary
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have understood Node.js and its distinctive execution model,
    explored the growing ecosystem around Node.js and JavaScript, seen the reasons
    for JavaScript as a language choice, and described the kinds of application that
    can benefit from Node.js.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们已经了解了Node.js及其独特的执行模型，探讨了围绕Node.js和JavaScript不断发展的生态系统，看到了选择JavaScript作为语言的原因，并描述了可以从Node.js中受益的应用类型。
- en: Now that you know how Node.js works and when to use it, it's time to dive in
    and get our first Node.js application up and running.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了Node.js的工作原理以及何时使用它，是时候深入其中，并启动我们的第一个Node.js应用程序。
