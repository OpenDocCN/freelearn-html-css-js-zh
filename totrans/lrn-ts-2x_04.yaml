- en: Object-Oriented Programming with TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we learned how to work with functions and how to take
    advantage of some asynchronous programming APIs. In this chapter, we are going
    to learn how to implement TypeScript applications using the **object-oriented
    programming** (**OOP**) paradigm. We are going to learn about the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Association, aggregation, and composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mixins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Generic constraints
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interfaces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SOLID principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We should already be familiar with the basics of TypeScript classes, as we
    have declared some of them in previous chapters. We will now look at some details
    and OOP concepts through examples. Let''s start by declaring a simple class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We use classes to represent the type of an object or entity. A **class** is
    composed of a name, **properties** (also known as **attributes**), and **methods**.
    Both methods and properties are known as **members**. Class properties are used
    to describe the object's characteristics, while class methods are used to describe
    its behavior.
  prefs: []
  type: TYPE_NORMAL
- en: The class in the preceding example is named `Person` and contains three attributes
    or properties (`name`, `surname`, and `email`) and two methods (`constructor`
    and `greet`).
  prefs: []
  type: TYPE_NORMAL
- en: 'A **constructor** is a special method used by the `new` keyword to create **instances**
    (also known as **objects**) of our class. We have declared a variable named `me`,
    which holds an instance of the `Person` class. The `new` keyword uses the `Person`
    class''s constructor to return an object whose type is `Person`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Strict property initialization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since the release of TypeScript 2.7, a compile-time error will be thrown if
    strict mode is enabled and we forget to initialize one of the properties of a
    class. For example, the following class initializes the property named `height`
    using a method, and the property named `width` using its constructor. TypeScript
    knows that if an instance of the class is created, a value will be assigned to
    the `width` property. However, it has no way to ensure that a value is assigned
    to the `height` property. If strict mode is enabled, an error will be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `!` operator to let TypeScript know that we don''t want an error
    to be thrown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'It is very common to encounter this compilation error when we define a class
    without a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can use the `!` operator to solve the compile-time error when we don''t
    want to define a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, we can initialize the properties with a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most fundamental OOP features is its capability to extend existing
    classes. This feature is known as **inheritance** and allows us to create a new
    class (child class) that inherits all the properties and methods from an existing
    class (parent class). Child classes can include additional properties and methods
    that are not available in the parent class.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to use the `Person` class that we declared in the preceding section
    as the parent class of a child class named `Teacher`. We can extend the parent
    class (`Person`) by using the reserved keyword `extends`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `Teacher` class will inherit all the attributes and methods from its parent
    class. However, we have also added a new method named `teach` to the `Teacher` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we create instances of the `Person` and `Teacher` classes, we will be able
    to see that both instances share the same attributes and methods except for the
    `teach` method, which is only available for the instance of the `Teacher` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Depth of the inheritance tree (DIT)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also declare a new class that inherits from a class, which is already
    inheriting from another class. In the following code snippet, we declare a class
    called `SchoolPrincipal` that `extends` the `Teacher` class, which extends the
    `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create an instance of the `SchoolPrincipal` class, we will be able to
    access all the properties and methods from its parent classes (`SchoolPrincipal`,
    `Teacher`, and `Person`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is **not recommended to have too many levels in the inheritance tree**. A
    class situated too deeply in the inheritance tree will be relatively complex to
    develop, test, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, we don't have a specific rule that we can follow when we are
    unsure whether we should increase the **depth of the inheritance tree** (**DIT**).
  prefs: []
  type: TYPE_NORMAL
- en: We should use inheritance in such a way that it helps us to reduce the complexity
    of our application and not the opposite. We should try to keep the DIT between
    zero and four because a value greater than four would compromise encapsulation
    and increase complexity.
  prefs: []
  type: TYPE_NORMAL
- en: Access modifiers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TypeScript allows us to restrict the access to the properties and methods of
    a class using the `public`, `private`, and `protected` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: The public access modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If we use the `public` modifier, the method or property can be accessed by
    other objects. The following example redeclares the `Person` and `Teacher` classes
    that we have used in the preceding section. It is important to note that the `public`
    access modifier is used in all the properties of the class, but for this example,
    we are going to pay special attention to the property named `email`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create an instance of both the `Person` and `Teacher` classes, we will
    be able to confirm that the `email` property can be accessed by both instances
    and by an external object such as the `console` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The private access modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we use the `private` modifier, the method or property can only be accessed
    by the object that owns them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example redeclares, once more, the classes that we declared in
    the preceding example, but uses the `private` access modifier instead of the `public`
    modifier. The example also adds a couple of extra methods to the classes to demonstrate
    the implications of using a `private` access modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create an instance of both the `Person` and `Teacher` classes, we will
    be able to observe that the `getEmail` method, which belongs to the `Person` instance,
    can access the `private` property. However, the `private` property, `email`, cannot
    be accessed from the method named `shareEmail`, which is declared by the derived  `Teacher` class. Also,
    other objects (such as the `console` object) cannot access the `private` property.
    This code snippet confirms that the `email` property can only be accessed by the
    instances of the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'We can update the `Teacher` class to use the public `getEmail` method instead
    of trying to access the `private` property directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The protected access modifier
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we use the `protected` modifier, the method or property can only be accessed
    by the object that owns them or instances of the derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example declares, once more, the classes that we declared in
    the preceding examples, but uses the `protected` access modifier instead of the
    `public` modifier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'If we create an instance of both the `Person` and `Teacher` classes, we will
    be able to observe that the `protected` property, `email`, can be accessed from
    the method named `shareEmail`, which is declared by the derived  `Teacher` class. However,
    other objects (such as the `console` object) cannot access the `private` property.
    This code snippet confirms that the `email` property can only be accessed by the
    instances of the `Person` class or derived classes, but it cannot be accessed
    by other objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Parameter properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In TypeScript, when we declare a class, we can define its properties and initialize
    some or all of the properties using the class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: However, we can use an alternative syntax, which allows us to declare the properties
    and initialize them using the class constructor in a less verbose way. We only
    need to remove the property declarations and its initialization, and add access
    modifiers to the arguments of the constructor of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code snippet declares a class with an identical behavior to the
    following class. However, it uses the parameter properties syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Class expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use two different APIs to declare a class. The first one is the class
    declaration syntax that we used during the preceding section. The second one is
    an alternative syntax known as a class expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet redeclares the `Person` class that we declared in
    the preceding section using the class expression syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'There are no differences between the creation of an instance of a class declared
    using the class expression syntax and one declared using the class declaration
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Static members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can use the `static` keyword to enable the usage properties and methods
    in a class without needing to create an instance of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can observe in the preceding code snippet, the `TemperatureConverter` class
    has two static methods named `CelsiusToFahrenheit` and `FahrenheitToCelsius`.
    We can invoke these methods without creating an instance of the `TemperatureConverter`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'When a method or property is not static, we refer to it as an instance method
    or an instance property. It is possible to declare classes that have both static
    and instance methods or properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding class declares a vector in a 3D space. The vector class has instance
    methods to calculate the length of the vector and to normalize it (change its
    length to `1` without changing its direction). We can create instances of the
    class using the class constructor and the `new` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'However, the class also has a static method named `GetDefault`, which can be
    used to create a default instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Optional members
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can define optional class properties and methods by appending the `?` character
    at the end of the name of a property or method. This behavior is like the behavior
    that we observed in [Chapter 3](82486ffc-fd37-49ec-938f-0e2aec26ebf8.xhtml), *Working
    with Functions,* when we learned how to use the `?` character to declare optional
    arguments in a function.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet defines a class named `Vector` with an optional
    property named `z`. When we define a `Vector` instance using numeric values for
    the properties `x` and `y`, the `Vector` has two dimensions. When we define a
    `Vector` instance using numeric values for the properties `x`, `y`, and `z`, the
    `Vector` has three dimensions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet declares a `Vector` instance using only two constructor
    arguments. As a result, the optional property, `z`, will be `undefined`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The following code snippet declares a `Vector` instance using three constructor
    arguments. As a result, the optional property, `z`, will be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Read-only properties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `readonly` keyword is a modifier that can be applied to the properties of
    a class. When a property declaration includes a `readonly` modifier, assignments
    to the property can only take place as part of the declaration or in a constructor
    in the same class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example showcases how the `readonly` modifier prevents assignments
    to the  `x`, `y`, and `z` properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can fix the compilation errors in the preceding code snippet by modifying
    the `normalize` method so that it returns a new vector (instead of modifying the
    original vector):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Method overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we will need a child class to provide a specific implementation of
    a method that is already provided by its parent class. We can use the reserved
    keyword `super` for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: We are going to use, once more, the `Person` and `Teacher` classes declared
    during the *Inheritance* section in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine that we want to add a new attribute to list the teacher''s subjects,
    and we want to be able to initialize this attribute through the teacher constructor.
    We are going to use the `super` keyword to explicitly reference the parent class
    constructor inside the child class constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We have also used the `super` keyword to extend an existing method, such as
    `greet`. This OOP language feature that allows a subclass or child class to provide
    a specific implementation of a method that is already provided by its parent classes
    is known as **method overriding**.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we can create an instance of the `Person` and `Teacher` classes
    to observe their differences:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Generic classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned how to work with generic functions. Now,
    we will look at how to work with generic classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just like with generic functions, generic classes can help us to avoid the
    duplication of code. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'We have declared a class named `User` with two properties named `name` and
    `password`. We will now declare a class named `UserQueue`. A queue is a data structure
    that we can use to store a list of items. Items can be added at the end of the
    list and removed from the beginning of the list. For this reason, a queue is considered
    a **first-in-first-out** (**FIFO**) data structure. The `UserQueue` class doesn''t
    use generics:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Please note the array shift method removes the first element from an array and
    returns that removed element.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have finished declaring the `UserQueue` class, we can create an instance
    and invoke the `push` and `pop` methods to add and remove items, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If we also need to create a new queue with items of a different type, we could
    end up duplicating a lot of code that looks almost identical:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'If the number of entities grows, we will continue to repeatedly duplicate code.
    We could use the `any` type to avoid this problem, but then we would be losing
    the type checks at compile time:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'A much better solution is to create a generic queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The generic queue code is identical to `UserQueue` and `CarQueue`, except for
    the type of the `items` property. We have replaced the hardcoded reference to
    the `User` and `Car` entities and replaced them with the generic type `T`. We
    can now declare as many kinds of queues as we might need without duplicating a
    single line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Generic constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we might need to restrict the use of a generic class. For example,
    we can add a new feature to the generic queue. The new feature is going to validate
    the entities before they are added to the queue.
  prefs: []
  type: TYPE_NORMAL
- en: 'One possible solution would be to use the `typeof` operator to identify the
    type of the generic type parameter `T` within a generic class or function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: The problem is that we will have to modify our `Queue` class to add extra logic
    with each new kind of entity. We will not add the validation rules into the `Queue` class
    because a generic class should not know the type used as the generic type.
  prefs: []
  type: TYPE_NORMAL
- en: 'A better solution is to add a method named `validate` to the entities. The
    method will throw and exception if the entity is invalid:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code snippet throws a compilation error because we can use the
    generic repository with any type, but not all types have a method named `validate`.
    Fortunately, this issue can easily be resolved by using a generic constraint.
    Constraints will restrict the types that we can use as the generic type parameter
    `T`. We are going to declare a constraint, so only the types that implement an
    interface named `Validatable` can be used with the generic method. Let''s start
    by declaring the `Validatable` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can proceed to implement the interface. In this case, we must implement
    the `validate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s declare a generic repository and add a type constraint so that
    only types that implement the `Validatable` interface are accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Even though we have used an interface, we used the `extends` keyword and not
    the `implements` keyword to declare the constraint in the preceding example. There
    is no special reason for that. This is just the way the TypeScript constraint's
    syntax works.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we should be ready to see the new validation feature in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: If we attempt to use a class that doesn't implement the `Validatable` as the
    generic parameter `T`, we will get a compilation error.
  prefs: []
  type: TYPE_NORMAL
- en: Multiple types in generic type constraints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can only refer to one type when declaring a generic type constraint. Let''s
    imagine that we need a generic class to be constrained, so it only allows types
    that extend the following two interfaces:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'We may think that we can define the required generic constraint as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'However, this code snippet will throw a compilation error. We cannot specify
    multiple types when declaring a generic type constraint. However, we can work
    around this issue by using `Foo` and `Bar` in a superinterface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`Foo` and `Bar` are now superinterfaces because they are the parent interfaces
    of the `FooBar` interface. We can then declare the constraint using the new `FooBar`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The new operator in generic types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create a new object within a generic piece of code, we need to use the constructor
    function of the type. This means that instead of using `t: T` as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'We should use `t: { new(): T;}`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Association, aggregation, and composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In OOP, classes can have a relationship with each other. In this section, we
    are going to talk about three different types of relationships between classes.
  prefs: []
  type: TYPE_NORMAL
- en: Association
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We call **association** those relationships whose objects have an independent
    life cycle where there is no ownership of the objects. Let''s take a look at an
    example of a teacher and a student. Multiple students can be associated with a
    single teacher, and a single student can be associated with multiple teachers,
    but both have independent life cycles (both can create and delete independently).
    So, when a teacher leaves the school, we don''t need to delete any students, and
    when a student leaves the school, we don''t need to delete any teachers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cecece17-72dc-449d-a149-21a299988965.png)'
  prefs: []
  type: TYPE_IMG
- en: Aggregation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We call **aggregation** those relationships whose objects have an independent
    life cycle, but there is ownership, and child objects cannot belong to another
    parent object. Let''s take an example of a cell phone and a cell phone battery.
    A single battery can belong to a phone, but if the phone stops working, and we
    delete it from our database, the phone battery will not be deleted because it
    may still be functional. So, in aggregation, while there is ownership, objects
    have their life cycle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f95aba88-a80e-4594-acbb-81bbdd3e2f36.png)'
  prefs: []
  type: TYPE_IMG
- en: Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We use the term **composition** to refer to relationships whose objects don't
    have an independent life cycle, and if the parent object is deleted, all child
    objects will also be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take an example of the relationship between questions and answers. Single
    questions can have multiple answers, and answers cannot belong to multiple questions.
    If we delete questions, answers will automatically be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Objects with a dependent life cycle (answers in the example) are known as **weak
    entities**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/25cdb92f-3463-4193-8161-f24756777bec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Sometimes, it can be a complicated process to decide if we should use association,
    aggregation, or composition. This difficulty is caused in part because aggregation
    and composition are subsets of association, which means they are specific cases
    of association:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/851875e3-9a74-4a7e-a9de-fd009c0d5fb7.png)'
  prefs: []
  type: TYPE_IMG
- en: It is also important to mention that, in general, we should try to **use composition
    over inheritance** whenever it is possible. Inheritance tightly couples derived
    classes to their respective base classes and it can become a maintainability issue
    over time. Composition can lead to much less tightly coupled code than inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Mixins (multiple inheritance)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sometimes, we will find scenarios in which it would be useful to be able to
    declare a class that inherits from two or more classes simultaneously (known as
    **multiple inheritance**).
  prefs: []
  type: TYPE_NORMAL
- en: We are going to create an example to demonstrate how multiple inheritance works.
    We are going to avoid adding any code to the methods in this example because we
    want to avoid the possibility of getting distracted by the details. We should
    focus on the inheritance tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to start by declaring a class named `Animal` that has only one
    method, named `eat`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the `Animal` class, we are going to declare two new classes
    named `WingedAnimal` and `Mammal`. Both classes are inherited from the `Animal`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have our classes ready, we are going to try to implement a class
    named `Bat`. Bats are mammals and have wings. This means that we need to create
    a new class named `Bat`, which will extend both the `Mammal` and `WingedAnimal` classes.
    We might think that this seems logical, however, if we attempt to do this, we
    will encounter a compilation error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: This error is thrown because TypeScript doesn't support multiple inheritance.
    This means that a class can only extend one class. Most OOP languages such as
    C# or TypeScript do not support multiple inheritance because it can potentially
    increase the complexity of applications and lead to a well-defined problem known
    as the diamond problem.
  prefs: []
  type: TYPE_NORMAL
- en: The diamond problem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, a class inheritance diagram can take a diamond-like shape (as seen
    in the following diagram). This kind of class inheritance diagram can potentially
    lead us to a design issue known as the **diamond problem**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6671b510-494d-465d-ac95-c9e6f72a073e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If multiple inheritance was allowed and we encounter an inheritance tree with
    a diamond shape, we would not face any problems while using a method that is exclusive
    to only one of the classes in the inheritance tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: The problem takes place when we try to invoke one of the `Bat` class's parent
    methods, and it is unclear or ambiguous which of the parent's implementations
    of that method should be invoked. For example, if we could add a method named
    move to both the `Mammal` and the `WingedAnimal` classes and try to invoke it
    from an instance of `Bat`, we would get an ambiguous call error.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing mixins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know why multiple inheritance can be potentially dangerous, we will
    introduce a feature known as **mixins**. Mixins are an alternative to multiple
    inheritance with some limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are going to re-declare the `Mammal` and `WingedAnimal` classes to showcase
    how to work with mixins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The two classes presented in the preceding example are not much different from
    the ones that we declared in the preceding sections. We have added some logic
    to the `breath` and `fly` methods, so we can have some values to help us understand
    this demonstration. It is also important to note that the `Mammal` and `WingedAnimal`
    classes no longer extend the `Animal` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Bat` class needs some important additions. We are going to use the `reserved`
    keyword `implements` to indicate that `Bat` will implement the functionality declared
    in the `Mammal` and `WingedAnimal` classes. We are also going to add the signature
    of each of the methods that the `Bat` class will implement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to copy the following function somewhere in our code to be able to
    apply mixins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: The preceding function is a well-known pattern and can be found in many books
    and online references, including the official *TypeScript Handbook*. Don't worry
    if you don't fully understand it at this point because it uses some concepts (such
    as An iterator is a behavioral design pattern which
  prefs: []
  type: TYPE_NORMAL
- en: porotypes) that will not be covered until [Chapter 6](5ed09f02-12d7-499b-9569-5246882ddbbc.xhtml),
    *Understanding the Runtime*.
  prefs: []
  type: TYPE_NORMAL
- en: 'This function iterates each property of the parent classes (contained in an
    array named `bases`) and copies the implementation to a child class (`derived`).
    We only need to declare this function once in our entire application. Once we
    have done it, we can use it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'The child class (`Bat`) will then contain each of the properties and methods
    of the two parent classes (`WingedAnimal` and `Mammal`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: 'As we said at the beginning of this section, mixins have some limitations:'
  prefs: []
  type: TYPE_NORMAL
- en: The first limitation is that we can only inherit the properties and methods
    from one level in the inheritance tree. This explains why we removed the `Animal`
    class before applying the mixins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second limitation is that if two or more of the parent classes contain a
    method with the same name, the method that is going to be inherited will be taken
    from the last class passed in the `bases` array to the `applyMixins` function.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will now see an example that presents both of these limitations.
  prefs: []
  type: TYPE_NORMAL
- en: 'To show the first limitation, we will re-declare the `Animal` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then declare the `Mammal` and `WingedAnimal` classes, but this time,
    they will extend the `Animal` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then declare again the `Bat` class. This class will implement both
    the `Mammal` and `WindgedAnimal` classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'We are ready to invoke the `applyMixins` function. Notice how we pass `Mammal`
    before `WingedAnimal` in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create an instance of `Bat`, and we will be able to observe that
    the `eat` method has not been inherited from the `Animal` class due to the first
    limitation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Each of the parent class''s methods has been inherited without issues:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: 'The `move` method has issues because according to the second limitation, only
    the implementation of the last parent class passed to the `applyMixins` method
    will be implemented. In this case, the implementation is inherited from the `WingedAnimal`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: 'To finalize, we will see the effect of switching the order of the parent classes
    when invoking the `applyMixins` method. Notice how we have passed `WingedAnimal`
    before `Mammal` in the array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: Iterables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An iterator is a behavioral design pattern that is common in OOP. An iterator
    is an object that implements an interface such as the following one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding interface allows us to retrieve the items available in a collection.
    The iterator result allows us to know if we have reached the last item in the
    collection and to access the values in the collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: 'We can create custom iterators by implementing the `IterableIterator` interface.
    We will need to implement the next method and a method named `Symbol.iterator`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: We can use brackets to define the name of a property or method using the value
    of a variable as the name of the method or property. In this case, the `Symbol.iterator`
    is used as the name of the method. The `Symbol` iterator contains the unique string
    `@@iterator`. This name is a special name for a method because whenever an object
    needs to be iterated (such as at the beginning of a `for...of` loop), its `@@iterator`
    method is called with no arguments, and the returned iterator is used to obtain
    the values to be iterated.
  prefs: []
  type: TYPE_NORMAL
- en: 'After declaring the class, we can create instances and iterate their values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding iterable never stops returning values, but we can also declare
    an instance with a fixed number of items and iterate the items using a `for...of`
    loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that some additional types are required by asynchronous iterators if we
    are targeting ES5 or ES3\. You will need to add `esnext.asynciterable` to your
    `tsconfig.json` file. We are also going to need to enable an additional setting
    in our `tsconfig.json` to provide full support for iterables (for example, using
    `for...of` control flow statements, the spread operator or object destructuring)
    when targeting ES3 or ES5:'
  prefs: []
  type: TYPE_NORMAL
- en: '`"lib": [`'
  prefs: []
  type: TYPE_NORMAL
- en: '`              "es2015.promise",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`              "dom",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`              "es5",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`              "es5",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`              "es2015.generator",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`              "es2015.iterable",`'
  prefs: []
  type: TYPE_NORMAL
- en: '`              "esnext.asynciterable" // new`'
  prefs: []
  type: TYPE_NORMAL
- en: '`]`'
  prefs: []
  type: TYPE_NORMAL
- en: You might also need a recent version of Node.js as the preceding example will
    not work in old versions of Node.js. We will learn more about the `lib` setting
    in [Chapter 9](ac5e3625-104c-4f8b-89de-1e0435de5309.xhtml), *Automating Your Development
    Workflow*.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Abstract classes are base classes that can be extended by other classes. The
    `abstract` keyword is used to define abstract classes as well as abstract methods
    within an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: The methods in an abstract class that are preceded by the `abstract` keyword
    cannot contain an implementation and must be implemented by the derived classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Abstract methods may look like interface methods. However, an abstract class
    may contain implementation details for some of its members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'It is not possible to create an instance of an abstract class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are probably the feature that you will miss the most while developing
    large-scale web applications with JavaScript if you have a background in object-oriented
    statically-typed programming languages such as Java or C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Traditionally, in OOP, we say that a class can extend only one class and implement
    one or more interfaces. An interface can implement one or more interfaces and
    cannot extend another class or interface. Wikipedia''s definition of interfaces
    in OOP is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '"In object-oriented languages, the term interface is often used to define an
    abstract type that contains no data or code, but defines behaviors as method signatures."'
  prefs: []
  type: TYPE_NORMAL
- en: 'In TypeScript, interfaces don''t strictly follow this definition. The two main
    differences are that in TypeScript:'
  prefs: []
  type: TYPE_NORMAL
- en: An interface can extend a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An interface can define data and behaviors as opposed to only behaviors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For example, we can define an interface named `Weapon`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: The `Weapon` interface defines the behavior shared by all weapons (a weapon
    can be used to try to hit an enemy, but each kind of weapon has a different range).
    However, the interface does not define the details of each if its implementations
    (the specific range of each kind of weapon).
  prefs: []
  type: TYPE_NORMAL
- en: 'Implementing an interface can be understood as signing a contract. An interface
    is a contract, and when we sign it (implement it), we must follow its rules. The
    interface rules are the signatures of the methods and properties, and we must
    implement them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: The two preceding classes implement the methods defined by the `Weapon` interface.
    Both classes share the same public API but have different internal implementations.
    We will see many more examples of interfaces through the rest of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID principles, encapsulation, and polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the early days of software development, developers used to write code with
    procedural programming languages. In procedural programming languages, the programs
    follow a top-to-bottom approach, and the logic is wrapped with functions.
  prefs: []
  type: TYPE_NORMAL
- en: New styles of computer programming, such as modular programming or structured
    programming, emerged when developers realized that procedural computer programs
    could not provide them with the desired level of abstraction, maintainability,
    and reusability.
  prefs: []
  type: TYPE_NORMAL
- en: The development community created a series of recommended practices and design
    patterns to improve the level of abstraction and reusability of procedural programming
    languages, but some of these guidelines required a certain level of expertise.
    To facilitate adherence to these guidelines, a new style of computer programming
    known as **object-oriented programming** (**OOP**) was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Developers quickly noticed some common OOP mistakes and came up with five rules
    that every OOP developer should follow to create a system that is easy to maintain
    and extend over time. These five rules are known as the SOLID principles. SOLID
    is an acronym introduced by Michael Feathers. Each of the characters in the acronym
    represents one of the following principles:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Single responsibility principle** (**SRP**): This principle states that a
    software component (function, class, or module) should focus on one unique task
    (have only one responsibility).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open/closed principle** (**OCP**): This principle states that software entities
    should be designed with application growth (new code) in mind (be open to extension),
    but that application growth should require as few changes to the existing code
    as possible (be closed for modification).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Liskov substitution principle** (**LSP**): This principle states that we
    should be able to replace a class in a program with another class if both classes
    implement the same interface. After replacing the class, no other changes should
    be required, and the program should continue to work as it did originally.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Interface segregation principle** (**ISP**): This principle states that we
    should split interfaces that are very large (general-purpose interfaces) into
    smaller and more specific ones (many client-specific interfaces) so that clients
    will only need to know about the methods that are of interest to them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dependency inversion principle** (**DIP**): This principle states that entities
    should depend on abstractions (interfaces) as opposed to depending on concretion
    (classes).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to learn how to write TypeScript code that adheres
    to these principles so that our applications are easy to maintain and extend over
    time.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID – the single responsibility principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'All our classes should adhere to the **single responsibility principle** (**SRP**).
    The `Person` class declared during the very first example in this chapter represents
    a person, including all of their characteristics (attributes) and behaviors (methods).
    We are going to modify the preceding class by adding an `email` as validation
    logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: When an object doesn't follow the SRP and it knows too much (has too many properties)
    or does too much (has too many methods), we say that the object is a `God` object.
    The `Person` class here is a `God` object because we have added a method named
    `validateEmail` that is not related to the `Person` class's behavior.
  prefs: []
  type: TYPE_NORMAL
- en: Deciding which attributes and methods should or should not be part of a class
    is a relatively subjective decision. If we spend some time analyzing our options,
    we should be able to identify ways to improve the design of our classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can refactor the `Person` class by declaring an `Email` class, which is
    responsible for email validation, and use it as an attribute in the `Person` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have an `Email` class, we can remove the responsibility of validating
    the emails from the `Person` class and update its `email` attribute to use the  `Email`
    type instead of `string`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: Making sure that a class has a single responsibility makes it easier to see
    what it does and how we can extend/improve it.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can further improve our `Person` and `Email` classes declared in the previous
    section by increasing the level of abstraction of our classes. For example, when
    we use the `Email` class, we don't need to be aware of the existence of the `validateEmail`
    method; this method could be invisible from outside the `Email` class. As a result,
    the `Email` class would be much simpler to understand.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we increase the level of abstraction of an object, we can say that we
    are encapsulating some logic. Encapsulation is also known as **information hiding**.
    For example, the `Email` class allows us to use emails without having to worry
    about email validation because the class will deal with it for us. We can make
    this clearer by using access modifiers (`public` or `private`) to flag all the
    class attributes and methods that we want to abstract from the use of the `Email`
    class as `private`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then simply use the `Email` class without needing to explicitly perform
    any kind of validation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: SOLID – the open/closed principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **open/closed principle** (**OCP**)  recommends that we design our classes
    and methods in a way that enables us to extend their behavior (open for extension)
    in the future without modifying their current behavior (closed for modification).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet is not great because it does not adhere to the open/closed
    principle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code does not adhere to the open/closed principle because if
    we need to extend our program to also support circles, we will need to modify
    the existing `AreaCalculator` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: 'A better solution is to add the area calculation as a method of the shapes
    so that when we add a new shape (extension), we don''t need to change the existing
    `AreaCalculator` class (modification):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: The second approach follows the second SOLID principle, the open/closed principle,
    as we can create new entities, and the generic repository will continue to work
    (open for extension), but no additional changes to it will be required (closed
    for modification).
  prefs: []
  type: TYPE_NORMAL
- en: Polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Polymorphism is the ability to present the same interface for differing underlying
    forms (data types). Polymorphism is often referred to as the third pillar of object-oriented
    programming, after encapsulation and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Polymorphism is what enabled us to implement the LSP in the preceding section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: Objects of the derived class (`Circle` and `Rectangle`) may be treated as objects
    of a base class (`Shape`) in places such as method parameters (such  as the `area`
    method). Base classes may define and implement abstract methods, and derived classes
    can override them, which means they provide their definition and implementation.
  prefs: []
  type: TYPE_NORMAL
- en: SOLID – the Liskov substitution principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Liskov substitution principle** (**LSP**) states, *Subtypes must be substitutable
    for their base types*. Let's look at an example to understand what this means.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will declare a class named `PersistanceService`, the responsibility of which
    is to persist some object into some sort of storage. We will start by declaring
    the following interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: 'After declaring the `PersistanceServiceInterface` interface, we can implement
    it. We will use cookies as the storage for the application''s data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: 'We will continue by declaring a class named `FavouritesController`, which has
    a dependency on `PersistanceServiceInterface`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: 'We can finally create an instance of `FavouritesController` and pass an instance
    of `CookiePersitanceService` via its constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: 'The LSP allows us to replace a dependency with another implementation if both
    implementations are based in the same base type; so, if we decide to stop using
    cookies as storage and use the HTML5 local storage API instead, we can declare
    a new implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then replace it without having to add any changes to the `FavouritesController`
    controller class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: SOLID – the interface segregation principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are used to declare how two or more software components cooperate
    and exchange information with each other. This declaration is known as an **application
    programming interface** (**API**). In the previous example, our interface was
    `PersistanceServiceInterface`, and it was implemented by the classes `LocalStoragePersitanceService`
    and `CookiePersitanceService`. The interface was consumed by the `FavouritesController`
    class, so we say that this class is a client of the `PersistanceServiceInterface` API.
  prefs: []
  type: TYPE_NORMAL
- en: The **interface segregation principle** (**ISP**) states that no client should
    be forced to depend on methods it does not use. To adhere to the ISP, we need
    to keep in mind that when we declare the API (how two or more software components
    cooperate and exchange information with each other) of our application's components,
    the declaration of many client-specific interfaces is better than the declaration
    of one general-purpose interface. Let's look at an example.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we design an API to control all the elements in a vehicle (engine, radio,
    heating, navigation, and lights), we could have one general-purpose interface,
    that allows us to control every single element of the vehicle:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: If a class has a dependency (client) in the `VehicleInterface` interface but
    it only wants to use the radio methods, we would be facing a violation of the
    ISP because, as we have already seen, a client shouldn't  be forced to depend
    on methods it does not use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to split the `VehicleInterface` interface into many client-specific
    interfaces so that our class can adhere to the ISP by depending only on the `RadioInterface`
    interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: SOLID – the dependency inversion principle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **dependency inversion** (**DI**) principle states, *Depend upon abstractions.
    Do not depend upon concretions*. In the LSP, we implemented a class named `FavouritesController`.
    In the example, it was possible to replace an implementation of `PersistanceServiceInterface`
    with another without having to perform any additional change to `FavouritesController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We followed the DI principle, as `FavouritesController` has a dependency upon
    `PersistanceServiceInterface` (abstraction):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/438ea4e3-82fe-4d79-a90f-cfae68e79262.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: 'Rather than `FavouritesController` having a dependency on `LocalStoragePersitanceService`
    or `CookiePersitanceService` (concretions) directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3538b3eb-29c5-409e-96c4-1ccd68bde2a0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding can be implemented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: If we compare the two diagrams, we will notice that the direction arrow that
    links the dependent and the dependency has been inverted thanks to the introduction
    of the interface (abstraction). This should help us to understand why this principle
    is known as the dependency inversion principle.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned how to work with classes and interfaces in
    depth. We were able to make our application more maintainable by using techniques
    such as encapsulation and dependency inversion. In the next chapter, we will learn
    how to work with dependencies.
  prefs: []
  type: TYPE_NORMAL
