- en: Security
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Security is crucial for every application that you plan to build. Security is
    a very complex topic that should be analyzed and implemented considering best
    practices and standards. The **Open Web Application Security Project** (**OWASP**) organization
    is a worldwide non-profit organization focused on improving the security of the
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: All the applications implement at least a simple security layer known as the
    authentication and authorization layer, which is responsible for restricting some
    access and features according to the permissions granted to a user based on the
    credentials provided to the application. Although this chapter is focused on how
    to secure our Aurelia applications, we will implement a simple authentication
    and authorization API as an example to integrate with our Aurelia web application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding JSON Web Tokens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom authentication and authorization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Auth0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Social login with Auth0
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single sign-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding JSON Web Tokens
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have implemented a RESTful API that serves the information to be displayed
    into our Aurelia web app. This API doesn't have any security mechanism, so if
    any malicious users get the endpoint URL, they can run malicious scripts against
    our application and ruin our application. For that reason, we should reject any
    management operations performed by unauthorized users.
  prefs: []
  type: TYPE_NORMAL
- en: Our app should implement a mechanism to manage user's access and privileges.
    There are many ways to implement authentication and authorization. For our application,
    we will be using an open standard in the industry called **JSON Web Token** (**JWT**).
  prefs: []
  type: TYPE_NORMAL
- en: JWT
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: JWTs are an open, industry standard, RFC 7519 ([https://tools.ietf.org/html/rfc7519.html](https://tools.ietf.org/html/rfc7519.html))
    method for representing claims securely between two parties. The way we use them
    is simple. First, we authenticate to the backend server by providing a username
    or password. If our credentials are correct, the backend server will generate
    a token that will contain the user information that should be persisted in the
    client side using a local storage mechanism. This JWT should be passed to the
    server in every request so that the server can recognize who the user is and what
    permissions this user has; with this information, the server allows or denies
    the user request.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand how this works. Navigate to [https://jwt.io/](https://jwt.io/);
    scroll down a little, and you will find the example section similar to the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2a724d0-8083-4afb-80ea-bb168770cb33.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s read the information from right to left. On the right, we have the Decoded section
    that has three sections:'
  prefs: []
  type: TYPE_NORMAL
- en: 'HEADER: Contains the information about the **algorithm** used to **encrypt**
    the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'PAYLOAD: The piece of **information** that we will define and use in our application,
    for example, user information'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'VERIFY SIGNATURE: The signature of the token; we will define a **secret value**
    to encrypt our token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the left Encoded, we can see the result of the final token encrypted based
    on the information of these three sections mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: As you might guess, this encrypted value is calculated in our backend server.
    This token is delivered to the user every time they log in to the application.
    They save this token on the client side and then send it on every request using
    the `Authorization` HTTP header. Let's see how all this works.
  prefs: []
  type: TYPE_NORMAL
- en: Custom authentication and authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now understand the two main concepts behind application security that
    you have to implement in all your projects.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing authentication
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Authentication is the process where we validate the identity of a given user
    and check whether the user has valid credentials to access our application or
    backend API. With authentication, we restrict the access to users who are not
    members of our application.
  prefs: []
  type: TYPE_NORMAL
- en: We will create a basic authentication API as the goal of this book is to show
    you how you can secure your Aurelia application. We won't go into further details
    about the backend implementation. We will create a hard-coded authentication flow,
    but you can integrate it with a database using Mongoose, as described in Chapter
    6,* Storing Our Data in MongoDB*.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let''s get our hands dirty. Open the backend project, create a new file
    in the `routes` folder called `security-api.js`, and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: First, we import `express` and create an instance of the `Router` class. Secondly,
    we define a function called `logIn`, where we will implement the logic to authenticate
    the user and generate the JWT. Then, we will define a `/auth` route to process
    a `POST` endpoint. Finally, we export the API to be used in the main `server.js`
    file.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s create a simple authentication logic. The backend expects a username
    and password with the value of the administrator. If these values are provided,
    it will return a valid token; otherwise, it will return `null`. Apply the following
    changes to the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The code is very straightforward. First, we compare the value in a simple `if`
    conditional, and we created a `userData` object, which will contain the user information,
    in this case just a name value is provided. Finally, we will call a `generateToken`
    function and pass `userData` to return a valid token.
  prefs: []
  type: TYPE_NORMAL
- en: Let's implement the `generateToken` function.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use an NPM module to generate JWT called `jsonwebtoken`. Open a new
    console and write the following command into the `wc-backend` folder to install
    the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation is finished. Open `security-api.js`,and let''s import
    our library, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'With our dependency imported in our file, let''s implement the `generateToken`
    function. Apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all! Let''s understand the code. We call the sign function of the `jwt`
    object to create our token. We pass the following information to the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '`userData`: The piece of information we want to tokenize'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`secret`: A secret value that is used to encrypt and validate the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`expiration`: The expiration date of the token'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now we are ready with the authentication logic. To finish our implementation,
    we have to make this logic available via our REST Controller.
  prefs: []
  type: TYPE_NORMAL
- en: The authentication REST controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already defined the route that will be responsible to make our logic
    available as a REST endpoint, so the only step required is to call our `logIn`
    function. Go ahead and apply the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: First, we extract the `username` and `password` from the `req.body` object.
    After that, we call the `logIn` function and host the result in the `token` variable.
    If the `token` is not null, we respond with a successful response by calling the
    `res.send` function. If the token is null, we pass an `Error` object into the
    next parameter, which will raise a global exception along with a failed response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, we have to modify the `server.js`file to register our API to express,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to test our implementation. In a new Terminal window, run
    the following `curl` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If everything is well implemented, you should receive an encrypted JWT as a
    response.
  prefs: []
  type: TYPE_NORMAL
- en: Cool! It's time to play with authorization. Keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing authorization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With authentication, we ensure that our application is being used by an authorized
    person with valid credentials. In most of the applications that you will build
    in the future, you will find that there are users who have different permissions
    on the application. For example, a given student might have the permissions to
    see their grade, but a student is not able to modify the grades. Otherwise, a
    user who is a teacher can update grades and access other features that a student
    cannot.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will implement authorization using another NPM module `express-jwt-permissions`.
    By using this module, we will be able to implement authorization in a very simple
    way. Open the `security-api.js`file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: That's all! The previous library will look into the JWT and check whether it
    has the `permissions` attribute defined. If so, we will extract this information
    and restrict access to users who do not have the admin permission. In the next
    section, we will implement the admin REST controller and see how we restrict the
    access to more details.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, we are ready to start the Admin API implementation!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Admin API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to understand how authorization works, let''s implement a basic Admin
    API that will be accessed only by the administrator of our site. Our application
    has two principal types of users:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Normal**: This user is able to see the featured matches and the score'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Admin**: This user is responsible to create new matches and update the score'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will use two open source NPM modules to manage the restriction workflow
    in our backend. The following diagram explains this flow in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/723782aa-7a9b-4e58-a8da-8e4202c53208.png)'
  prefs: []
  type: TYPE_IMG
- en: Everything starts with a user request that tries to access a restricted endpoint.
    The backend first validates whether a valid token is present in the HTTP request;
    this validation is performed by the `express-jwt` module. Secondly, if the request
    has a valid token, the flow will check whether the token has valid permissions
    to access the restricted endpoint; this validation is performed by `express-jwt-permissions`.
    If the request has a valid token and has permissions, the user request will be
    able to access the restricted endpoint and perform the action.
  prefs: []
  type: TYPE_NORMAL
- en: Managing matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To create a match, we will need to create a valid Match database schema. We
    already know how to do it using Mongoose. Let's do it.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Match schema
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Create the `match.js`file in the `src/models` folder. Then, add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We have defined three attributes, the first two—`team_1` and `team_2`—will store
    the information of the two teams playing. The `score` of the match. That's all
    we need for our model.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the REST controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a new file in the `src/routes`folder named `admin-api.js`.
    Then, write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: You are very familiar with this code structure. First, we import the modules
    required to define our REST controller. Secondly, we create a `/admin/match/:id?`
    route and define the `POST` method to create a new match and another PUT method
    to update the scores.
  prefs: []
  type: TYPE_NORMAL
- en: Pay attention to the route definition; we are declaring an optional path variable
    called `:id`. To make a path optional, we add the `?` operator after its name.
  prefs: []
  type: TYPE_NORMAL
- en: So far so good. Let's implement them.
  prefs: []
  type: TYPE_NORMAL
- en: Creating Matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a new `Match` is simple. We just need to import the `Match` model
    and call its built-in `save` method, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the `Match` model. Then, in the `POST` method, we create a
    new `Match` object and call the `save` function. If the operation is successful,
    we send the new `Match` via the `res.json` method. To test our creation logic,
    we need to configure the `server.js` to use our new Admin API, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we have applied the previous change, open a new terminal to test things
    out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Cool! Now we have our creation logic up and running with a great real example.
  prefs: []
  type: TYPE_NORMAL
- en: List Matches
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To list our matches, we won't need security, because all the users should be
    able to get the full list of matches in the applications. So let's implement the
    `matches` API.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, create a new file called `matches-api.js` into the `src/routes` folder
    and apply the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have to configure the `server.js`file to map our `Match` APIs. In
    the `server.js`file, apply the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! Let''s test things out. Open a Terminal window and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: That's it! We have our public `Match` API.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the Scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To update the `score`, we will require the ID of the match to look up for an
    existing one. If a valid match is found, we will apply the updates. If no match
    is found, we have to respond with a `404 not found` HTTP response. Otherwise,
    we respond with a `Success 200` HTTP response.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by creating the `updateScore` function, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s call our function in the PUT HTTP verb, as illustrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! Let''s test things out. Execute the following `curl` command to update
    the match we created earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note that the `team_1` (`Peru` team) now has `21` goals in its score, and the
    `Chile` team has `0`.
  prefs: []
  type: TYPE_NORMAL
- en: Awesome! Now we are able to create a new Match and update the scores. Let's
    use `express-jwt` and `express-jwt-permissions` to secure our APIs. Keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Securing the REST controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now it''s time to secure our API. To do this, let''s start by installing our
    two NPM modules. Open a Terminal window and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Once the installation is done, let's validate our token.
  prefs: []
  type: TYPE_NORMAL
- en: Validate token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every HTTP request has to send the JWT in its authorization header. The `express-jwt`
    middleware will check whether a valid token has been passed. If so, the request
    will continue its flow, otherwise the backend will respond with an unauthorized
    exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and apply the following changes to the `admin-api.js`file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we start importing the `express-jwt` module and instantiate a new constant
    called `auth`. Secondly, we use the `auth` function and pass a JSON object that
    has the `secret` attribute; we will use the same secret value we used to sign
    our tokens in `security-api.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `auth` function is responsible for checking whether a valid token has been
    passed in the authorization header. Let''s try to create a new `Match` entity
    without passing a valid token. Open the Terminal window and execute the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, this time we are receiving an error message that says that
    our backend API is waiting for a valid token and none has been provided. So, to
    tackle this situation, we will need to create a valid token first. Let''s create
    a valid token by calling our security API and logging in as admins. Execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: A new valid token has been created for me. Be aware that this token has a random
    value, so the token generated for you will be completely different.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have a valid token, let''s try again; however, this time we will pass
    the token using the `Authorization` HTTP headers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! Now we are able to create a new `Match`. Pay attention to the syntax
    that we have used to pass the token. We have used the `Authorization: Bearer <token>`
    syntax.'
  prefs: []
  type: TYPE_NORMAL
- en: We have protected our API, but what about if we have two different types of
    administrators? Let's say that one group of administrators can be limited to only
    add `Match` entities, and the other group of administrators is limited to only
    update the scores. We need a way to manage this separation of roles. Let's learn
    how permissions work.
  prefs: []
  type: TYPE_NORMAL
- en: Validate permissions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Permissions allow us to limit the access to a group of resources. You should
    be aware that authentication is not enough if we want to secure our backend APIs.
    To implement permissions, open the `admin-api.js`file and apply the following
    changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: First, we start by initializing a `guard` constant. Secondly, we call `guard.check`;
    this function will look for the `admin:create:match` permission in the JWT. Remember
    that these permissions have to be present in the token. If the user has permission,
    the flow will continue and the new `Match` will be created. Otherwise, we will
    receive a `Could not find permissions` error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s try to create a new `Match`; execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s interesting! Although we are authenticated and are passing a valid
    token, why are we not able to create the `Match`? Let''s look at the user token
    generation logic. Open the `security-api.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, our token doesn''t have the permissions defined. Let''s fix
    this by adding the right permissions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: That's all. Let's generate a new token by logging in again, and let's test things
    out.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, execute the following command to generate a valid token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Cool! this new token contains the permissions. Next, let''s try to create the
    new `Match` again by passing this new token:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Hot dog! We are now able to manage authentication and authorization in our backend
    API. Of course, you can improve this security authentication by saving a collection
    of users in a MongoDB database and create different users with different roles.
    Also, implement `log out` using `express-jwt-blacklist` and in another fashion,
    but for the purpose of this book, we are good with this basic implementation.
    Keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Auth0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing authentication and authorization by ourselves might become a really
    difficult task to do. Imagine that you need to implement security logic for web
    applications, mobile applications, and desktop apps. Even your customer might
    ask you to integrate their applications to social networks and use multifactor
    authentication or use a password-less method. Although we have implemented the
    security for our application, we encourage you not to write security code yourself
    unless you are creating a really simple application.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this section, we will implement authentication and authorization using
    one popular service called Auth0 ([https://auth0.com](https://auth0.com)). This
    service will help us empower our authentication flows, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Social login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Single sign-on
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Email authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multifactor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Password-less authentication
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fingerprint login
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: LDAP integration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, Auth0 provides monitoring and other out-of-the-box services that will
    help us manage our user's information.
  prefs: []
  type: TYPE_NORMAL
- en: A simple example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although we use our custom implementation for the world cup application, we
    have prepared a simple example to show you how to use Auth0 with Aurelia. You
    can download the code from [https://github.com/EriksonMurrugarra/AureliaAuth0](https://github.com/EriksonMurrugarra/AureliaAuth0).
  prefs: []
  type: TYPE_NORMAL
- en: Auth0 implements JWT; this should ring a bell for you, because we have implemented
    our custom Auth0 implementation using JWT. Let's start by creating a free account
    on Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an account
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, navigate to the official Auth0 site, [https://auth0.com](https://auth0.com),
    and click on the SIGN UP button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/64ab4512-aa22-4725-940a-c9e9ed7db6cf.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, fill the form with your email and password, and click on the SIGN UP button
    or use your social network accounts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a432796a-b2b4-4dc3-b9f1-ef532e3b613b.png)'
  prefs: []
  type: TYPE_IMG
- en: Once the sign-up process is complete, you should be redirected to your administration
    dashboard. The administration dashboard will allow you to configure the different
    security mechanisms that you can implement in just a few seconds. Let's continue
    by registering an application to generate some valid configuration values to connect
    our Aurelia application to Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: Registering an Auth0 client application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you have previous experience of working with third-party service providers,
    you might have noted that in order to use their services, you have to register
    an application in order to get some private keys that you will use to access your
    third-party provider's resource. The same happens with Auth0; we should first
    register an application and then use the keys generated to configure our apps.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the dashboard page, go ahead and select the Applications menu and click
    on the CREATE CLIENT button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0af642dc-d0cd-41c3-bb85-9b262c9d6775.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After clicking on the CREATE CLIENT button, fill the following form with your
    application''s name and select Single Page Application for the client type; then,
    click on CREATE:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a3539d94-cb2d-41d1-8b4d-5c5b79383d9a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we create the client, a new configuration page will be displayed. Navigate
    to the Settings tab and you will see the following configuration values:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Name: The name of our application'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Domain: The domain you previously registered in the sign-up process'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client ID: A unique ID that makes your application unique'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Client Secret: The secret value used to sign the JWT that Auth0 will generate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allowed Callback URL: The list of URL that Auth0 will redirect when the authentication
    is a success'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'That''s it. Before we explore the application''s code, let''s start understanding
    how Auth0 manages authentication by analyzing the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bcee34dc-5eab-475e-8c88-d95bf08b82a9.png)'
  prefs: []
  type: TYPE_IMG
- en: The flow begins when the User wants to log in to the application. You might
    have a kind of Navigation bar with a button that when clicked on will trigger
    a JavaScript function that will call an Auth0 JavaScript login function. Secondly,
    the user will be redirected to a built-in Auth0 Login Form and will have to enter
    their credentials to sign up. The credentials entered by the users are validated
    by Auth0; if the Auth0 finds a valid user with the provided credentials, it will
    generate a valid JWT that will be sent to the user/Aurelia app. This JWT will
    be used to access your backend resources. Remember that you can use the Client
    Secret property to decrypt the token in the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring our example application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, we will need to download the source code from the GitHub repository
    at [https://github.com/EriksonMurrugarra/AureliaAuth0](https://github.com/EriksonMurrugarra/AureliaAuth).
    Let''s open a Terminal window in the folder of your preference and run the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the source code is downloaded, we will need to install the dependencies
    and run the application. Let''s get into the source code folder and execute the
    following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s open a new browser and navigate to [http://localhost:9000](http://localhost:9000),
    which will display a simple home page with a Log In option in the Navigation bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e415a435-9158-4cda-b22b-36ced3142b62.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Cool! We have our application up and running, but we will need to configure
    it first before we can log in successfully. Go ahead and open the following `auth-service.js`
    file located in the `src` folder. We will need to replace the values for the configuration
    values that we got when we created our client application on Auth0\. In our case,
    the values are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: It's important to mention that the `redirectUri` should be registered in Auth0
    in the application settings in Allowed Callback URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Cool! Save the changes and click on the LOG IN button to be redirected to the
    following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e95aa9bc-bfd6-48be-b0a0-67aa82fc10b0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The previous page is provided by Auth0; you might note that the URL has changed.
    It means that every time that our users are asked to log in, they will be redirected
    to Auth0\. As you haven''t created any user account yet, you will need to sign
    up first. Once you are done with the registration process, you will be redirected
    to the home page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/77b34e64-3aaa-426f-b3d8-1b9f0df94bda.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it! Now you are logged in to the application using a more secure strategy.
    Remember that you should never implement authentication and authentication yourself.
    It is best practice to use a third-party service. The developers who created the
    services such as Auth0 will definitely have had years of experience creating the
    most secure authentication and authorization mechanism than you.
  prefs: []
  type: TYPE_NORMAL
- en: Social Login with Auth0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There is an important truth behind the human behavior when they are in front
    of any registration form. Most of your users will hate your application if you
    make them waste their valid time asking for personal information that they have
    already filled in their favorite social network. Even if you try to create the
    best user experience for your SIGN UP form, they will avoid them. So, how do we
    make our users happy and avoid them having to do this horrible sign-up process?
    Social Login integration to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: Implementing Social Login might be repetitive work in case you have multiple
    social networks that you need to integrate into your application. Instead of implementing
    everything yourself, why don't we use an existing service that can help us in
    this process? Auth0 to the rescue!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement Social Login in just 3 minutes. Yeah! you read well, just
    3 minutes. Go ahead and navigate to your Auth0 dashboard at [https://manage.auth0.com](https://manage.auth0.com) and
    navigate to the Connections/Social menu. Then, go ahead and activate the social
    networks that you want to integrate with your authentication flow, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d1724f15-8f04-49f5-96fa-32dafa5b6107.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, I have enabled Google and Facebook for the authentication flow.
    Remember that you will need to register an application on Facebook and Twitter
    first and then use the keys generated to configure the Social Login methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'We are almost done. To finish the process, we just need to tell our client
    application that we want to enable social login. To do this, let''s navigate to
    the Clients menu and get into the MyAuth0App client application. Then, navigate
    to the Connections tab and enable Facebook and Twitter in the Social section,
    as demonstrated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c7cc56ad-644e-4a5e-827d-d51b1ebda387.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once we have everything configured, the next time when your users try to log
    in to the application, they will see the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e54f530f-d07e-4f6f-8c57-b40d3dc51c1c.png)'
  prefs: []
  type: TYPE_IMG
- en: Cool! Now we know how to integrate our applications to allow our users to sign
    in to our application, allowing them to use their favorite social network accounts.
  prefs: []
  type: TYPE_NORMAL
- en: Single sign-on
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are implementing a big enterprise solution that consists of different
    distributed applications that require authentication and authorization but require
    to use the same user''s database, you will need to implement a different flow
    to manage the authentication in all these independent applications. This mechanism
    is called **single sign-on** (**SSO**), which will basically ask for login once
    in any of your applications and will reuse the same generated token in all the
    applications. The following diagram explains this flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b8322976-0b08-43a9-a2c9-48f6004c0048.png)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding illustration, there are three applications. Let's suppose that
    these three different applications are developed by the same company and the employees
    use the three applications. Imagine that in order to access each application,
    the employees have to log in to each application using different credentials,
    or they can choose to use the same username and password for the three apps.
  prefs: []
  type: TYPE_NORMAL
- en: Why should our users log in again to another application if these applications
    share the same user information? First, a user will log in to the server and retrieve
    a valid token. Once the first application is logged in to, it can save the token
    as cookies or in `LocalStorage` in the browser. When the user accesses Application
    02, the app should detect that there is an existing token and should use it to
    access the server without asking for credentials.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know how SSO works, You are free to implement SSO by yourself or
    use an external service. Auth0 has an awesome support for SSO.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we created a custom implementation to manage authentication
    and authorization in order to protect the use of our API from unauthorized users.
    You have seen that implementing Auth0 on your own might be a difficult task and
    will require more security layers than the ones we have implemented. A good practice
    is to use an external service to implement authentication and authorization in
    your projects. We created a simple application that uses one of the most popular
    third-party services, called Auth0.
  prefs: []
  type: TYPE_NORMAL
- en: We also covered how to integrate social login to our application, but we implemented
    this feature using Auth0 built-in social connection features. You can implement
    social authentication on your own, but again, it is better to spend energy on
    your application login rather than wasting time implementing features that can
    be achieved in no time using a third-party service.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how SSO works in theory and learned that it is a simple process
    reusing the user token in all your different applications.
  prefs: []
  type: TYPE_NORMAL
- en: That's it! In the next chapter, you will learn how to apply end-to-end tests
    on your Aurelia applications. Keep reading!
  prefs: []
  type: TYPE_NORMAL
