- en: Security
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安全性
- en: Security is crucial for every application that you plan to build. Security is
    a very complex topic that should be analyzed and implemented considering best
    practices and standards. The **Open Web Application Security Project** (**OWASP**) organization
    is a worldwide non-profit organization focused on improving the security of the
    applications.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性对于你计划构建的每一个应用程序都至关重要。安全性是一个非常复杂的话题，应该考虑最佳实践和标准来分析和实施。**开放网络应用安全项目**（**OWASP**）组织是一个全球性的非营利组织，专注于提高应用程序的安全性。
- en: All the applications implement at least a simple security layer known as the
    authentication and authorization layer, which is responsible for restricting some
    access and features according to the permissions granted to a user based on the
    credentials provided to the application. Although this chapter is focused on how
    to secure our Aurelia applications, we will implement a simple authentication
    and authorization API as an example to integrate with our Aurelia web application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序至少实现了一个简单的安全层，称为身份验证和授权层，它负责根据提供给应用程序的凭证限制某些访问和功能。尽管本章的重点是如何保护我们的 Aurelia
    应用程序，但我们将实现一个简单的身份验证和授权 API 作为示例，以集成到我们的 Aurelia 网络应用程序中。
- en: 'In this chapter, we will be covering the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Understanding JSON Web Tokens
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 JSON Web Tokens
- en: Custom authentication and authorization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义身份验证和授权
- en: Introducing Auth0
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Auth0
- en: Social login with Auth0
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Auth0 进行社交登录
- en: Single sign-on
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单点登录
- en: Understanding JSON Web Tokens
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 JSON Web Tokens
- en: We have implemented a RESTful API that serves the information to be displayed
    into our Aurelia web app. This API doesn't have any security mechanism, so if
    any malicious users get the endpoint URL, they can run malicious scripts against
    our application and ruin our application. For that reason, we should reject any
    management operations performed by unauthorized users.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了一个 RESTful API，该 API 为我们的 Aurelia 网络应用程序提供显示信息。这个 API 没有任何安全机制，所以如果任何恶意用户获取端点
    URL，他们可以针对我们的应用程序运行恶意脚本并破坏我们的应用程序。因此，我们应该拒绝任何未经授权用户执行的管理操作。
- en: Our app should implement a mechanism to manage user's access and privileges.
    There are many ways to implement authentication and authorization. For our application,
    we will be using an open standard in the industry called **JSON Web Token** (**JWT**).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的应用程序应该实现一个机制来管理用户的访问和权限。实现身份验证和授权有许多方法。对于我们的应用程序，我们将使用一个行业中的开放标准，称为**JSON
    Web Token**（**JWT**）。
- en: JWT
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JWT
- en: JWTs are an open, industry standard, RFC 7519 ([https://tools.ietf.org/html/rfc7519.html](https://tools.ietf.org/html/rfc7519.html))
    method for representing claims securely between two parties. The way we use them
    is simple. First, we authenticate to the backend server by providing a username
    or password. If our credentials are correct, the backend server will generate
    a token that will contain the user information that should be persisted in the
    client side using a local storage mechanism. This JWT should be passed to the
    server in every request so that the server can recognize who the user is and what
    permissions this user has; with this information, the server allows or denies
    the user request.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: JWTs 是一种开放、行业标准的 RFC 7519 方法，用于在双方之间安全地表示声明。我们使用它们的方式很简单。首先，我们通过提供用户名或密码来验证后端服务器。如果我们的凭证正确，后端服务器将生成一个包含应在客户端使用本地存储机制持久化的用户信息的令牌。这个
    JWT 应该在每次请求中传递给服务器，以便服务器可以识别用户是谁以及该用户有什么权限；有了这些信息，服务器允许或拒绝用户请求。
- en: 'Let''s understand how this works. Navigate to [https://jwt.io/](https://jwt.io/);
    scroll down a little, and you will find the example section similar to the following
    image:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们了解它是如何工作的。导航到 [https://jwt.io/](https://jwt.io/)；向下滚动一点，你会找到一个类似于以下图像的示例部分：
- en: '![](img/b2a724d0-8083-4afb-80ea-bb168770cb33.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b2a724d0-8083-4afb-80ea-bb168770cb33.png)'
- en: 'Let''s read the information from right to left. On the right, we have the Decoded section
    that has three sections:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 从右到左读取信息。在右侧，我们有解码部分，它包含三个部分：
- en: 'HEADER: Contains the information about the **algorithm** used to **encrypt**
    the token'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 头部：包含用于**加密**令牌的**算法**信息
- en: 'PAYLOAD: The piece of **information** that we will define and use in our application,
    for example, user information'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 负载：我们将定义并用于我们应用程序中的**信息**片段，例如，用户信息
- en: 'VERIFY SIGNATURE: The signature of the token; we will define a **secret value**
    to encrypt our token'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证签名：令牌的签名；我们将定义一个 **密钥值** 来加密我们的令牌
- en: In the left Encoded, we can see the result of the final token encrypted based
    on the information of these three sections mentioned earlier.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧的编码中，我们可以看到基于前面提到的三个部分信息的最终令牌加密结果。
- en: As you might guess, this encrypted value is calculated in our backend server.
    This token is delivered to the user every time they log in to the application.
    They save this token on the client side and then send it on every request using
    the `Authorization` HTTP header. Let's see how all this works.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所猜，这个加密值是在我们的后端服务器中计算的。每次用户登录应用程序时，都会将此令牌发送给用户。他们在客户端保存此令牌，然后在每次请求中使用 `Authorization`
    HTTP头将其发送。让我们看看这一切是如何工作的。
- en: Custom authentication and authorization
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义身份验证和授权
- en: Let's now understand the two main concepts behind application security that
    you have to implement in all your projects.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来了解应用安全背后的两个主要概念，这些概念你必须在你所有的项目中实现。
- en: Implementing authentication
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现身份验证
- en: Authentication is the process where we validate the identity of a given user
    and check whether the user has valid credentials to access our application or
    backend API. With authentication, we restrict the access to users who are not
    members of our application.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 身份验证是一个验证给定用户身份并检查用户是否有有效凭证访问我们的应用程序或后端API的过程。通过身份验证，我们限制了非我们应用程序成员的访问。
- en: We will create a basic authentication API as the goal of this book is to show
    you how you can secure your Aurelia application. We won't go into further details
    about the backend implementation. We will create a hard-coded authentication flow,
    but you can integrate it with a database using Mongoose, as described in Chapter
    6,* Storing Our Data in MongoDB*.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个基本的身份验证API，因为本书的目标是向你展示如何保护你的Aurelia应用。我们不会深入探讨后端实现的细节。我们将创建一个硬编码的身份验证流程，但你可以使用Mongoose将其与数据库集成，如第6章“将我们的数据存储在MongoDB”中所述。
- en: 'So, let''s get our hands dirty. Open the backend project, create a new file
    in the `routes` folder called `security-api.js`, and write the following code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们动手实践。打开后端项目，在 `routes` 文件夹中创建一个名为 `security-api.js` 的新文件，并编写以下代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, we import `express` and create an instance of the `Router` class. Secondly,
    we define a function called `logIn`, where we will implement the logic to authenticate
    the user and generate the JWT. Then, we will define a `/auth` route to process
    a `POST` endpoint. Finally, we export the API to be used in the main `server.js`
    file.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入 `express` 并创建 `Router` 类的一个实例。其次，我们定义一个名为 `logIn` 的函数，我们将在这个函数中实现用户认证和生成JWT的逻辑。然后，我们将定义一个
    `/auth` 路由来处理 `POST` 端点。最后，我们将API导出以在主 `server.js` 文件中使用。
- en: The authentication logic
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 身份验证逻辑
- en: 'Let''s create a simple authentication logic. The backend expects a username
    and password with the value of the administrator. If these values are provided,
    it will return a valid token; otherwise, it will return `null`. Apply the following
    changes to the code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的身份验证逻辑。后端期望提供一个用户名和密码，其值为管理员。如果提供了这些值，它将返回一个有效的令牌；否则，它将返回 `null`。对以下代码进行以下更改：
- en: '[PRE1]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The code is very straightforward. First, we compare the value in a simple `if`
    conditional, and we created a `userData` object, which will contain the user information,
    in this case just a name value is provided. Finally, we will call a `generateToken`
    function and pass `userData` to return a valid token.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 代码非常直接。首先，我们在简单的 `if` 条件中比较值，并创建了一个 `userData` 对象，该对象将包含用户信息，在这种情况下只提供了一个名称值。最后，我们将调用一个
    `generateToken` 函数并将 `userData` 传递给它以返回一个有效的令牌。
- en: Let's implement the `generateToken` function.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们实现 `generateToken` 函数。
- en: Generating the token
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生成令牌
- en: 'We will use an NPM module to generate JWT called `jsonwebtoken`. Open a new
    console and write the following command into the `wc-backend` folder to install
    the module:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个名为 `jsonwebtoken` 的NPM模块来生成JWT。打开一个新的控制台，在 `wc-backend` 文件夹中输入以下命令来安装模块：
- en: '[PRE2]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Once the installation is finished. Open `security-api.js`,and let''s import
    our library, as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，打开 `security-api.js`，然后按照以下方式导入我们的库：
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'With our dependency imported in our file, let''s implement the `generateToken`
    function. Apply the following changes:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的文件中导入依赖项后，让我们实现 `generateToken` 函数。应用以下更改：
- en: '[PRE4]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'That''s all! Let''s understand the code. We call the sign function of the `jwt`
    object to create our token. We pass the following information to the function:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！让我们理解一下代码。我们调用`jwt`对象的`sign`函数来创建我们的令牌。我们将以下信息传递给该函数：
- en: '`userData`: The piece of information we want to tokenize'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`userData`: 我们想要标记化的信息'
- en: '`secret`: A secret value that is used to encrypt and validate the token'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`secret`: 用于加密和验证令牌的秘密值'
- en: '`expiration`: The expiration date of the token'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`expiration`: 令牌的过期日期'
- en: Now we are ready with the authentication logic. To finish our implementation,
    we have to make this logic available via our REST Controller.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好了认证逻辑。为了完成我们的实现，我们必须通过我们的REST控制器提供此逻辑。
- en: The authentication REST controller
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 认证REST控制器
- en: 'We have already defined the route that will be responsible to make our logic
    available as a REST endpoint, so the only step required is to call our `logIn`
    function. Go ahead and apply the following change:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经定义了负责将我们的逻辑作为REST端点提供的路由，所以唯一需要做的步骤就是调用我们的`logIn`函数。继续并应用以下更改：
- en: '[PRE5]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: First, we extract the `username` and `password` from the `req.body` object.
    After that, we call the `logIn` function and host the result in the `token` variable.
    If the `token` is not null, we respond with a successful response by calling the
    `res.send` function. If the token is null, we pass an `Error` object into the
    next parameter, which will raise a global exception along with a failed response.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们从`req.body`对象中提取`username`和`password`。之后，我们调用`logIn`函数并将结果存储在`token`变量中。如果`token`不为空，我们通过调用`res.send`函数返回一个成功的响应。如果令牌为空，我们将一个`Error`对象传递给下一个参数，这将引发一个全局异常并返回一个失败的响应。
- en: 'Lastly, we have to modify the `server.js`file to register our API to express,
    as follows:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们必须修改`server.js`文件以将我们的API注册到express中，如下所示：
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we are ready to test our implementation. In a new Terminal window, run
    the following `curl` command:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经准备好测试我们的实现了。在一个新的终端窗口中，运行以下`curl`命令：
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If everything is well implemented, you should receive an encrypted JWT as a
    response.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切实施得当，你应该会收到一个加密的JWT作为响应。
- en: Cool! It's time to play with authorization. Keep reading!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在是时候玩授权了。继续阅读！
- en: Implementing authorization
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现授权
- en: With authentication, we ensure that our application is being used by an authorized
    person with valid credentials. In most of the applications that you will build
    in the future, you will find that there are users who have different permissions
    on the application. For example, a given student might have the permissions to
    see their grade, but a student is not able to modify the grades. Otherwise, a
    user who is a teacher can update grades and access other features that a student
    cannot.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 通过认证，我们确保我们的应用程序是由一个拥有有效凭证的授权人员使用的。在您未来构建的大多数应用程序中，您会发现有不同权限的用户。例如，一个学生可能有查看成绩的权限，但学生无法修改成绩。否则，一个教师可以更新成绩并访问学生无法访问的其他功能。
- en: 'We will implement authorization using another NPM module `express-jwt-permissions`.
    By using this module, we will be able to implement authorization in a very simple
    way. Open the `security-api.js`file and apply the following changes:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用另一个NPM模块`express-jwt-permissions`来实现授权。通过使用此模块，我们将能够以非常简单的方式实现授权。打开`security-api.js`文件并应用以下更改：
- en: '[PRE8]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: That's all! The previous library will look into the JWT and check whether it
    has the `permissions` attribute defined. If so, we will extract this information
    and restrict access to users who do not have the admin permission. In the next
    section, we will implement the admin REST controller and see how we restrict the
    access to more details.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！之前的库将检查JWT是否定义了`permissions`属性。如果是这样，我们将提取此信息并限制没有管理员权限的用户访问。在下一节中，我们将实现管理员REST控制器并查看我们是如何限制对更多细节的访问的。
- en: Having said that, we are ready to start the Admin API implementation!
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们已经准备好开始实施管理员API了！
- en: Creating the Admin API
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建管理员API
- en: 'In order to understand how authorization works, let''s implement a basic Admin
    API that will be accessed only by the administrator of our site. Our application
    has two principal types of users:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解授权是如何工作的，让我们实现一个基本的仅由我们网站管理员访问的Admin API。我们的应用程序有两种主要类型的用户：
- en: '**Normal**: This user is able to see the featured matches and the score'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**正常**: 此用户能够查看特色比赛和得分'
- en: '**Admin**: This user is responsible to create new matches and update the score'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**管理员**: 此用户负责创建新比赛和更新得分'
- en: 'We will use two open source NPM modules to manage the restriction workflow
    in our backend. The following diagram explains this flow in more detail:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在后端使用两个开源NPM模块来管理限制工作流程。以下图表更详细地解释了这个流程：
- en: '![](img/723782aa-7a9b-4e58-a8da-8e4202c53208.png)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/723782aa-7a9b-4e58-a8da-8e4202c53208.png)'
- en: Everything starts with a user request that tries to access a restricted endpoint.
    The backend first validates whether a valid token is present in the HTTP request;
    this validation is performed by the `express-jwt` module. Secondly, if the request
    has a valid token, the flow will check whether the token has valid permissions
    to access the restricted endpoint; this validation is performed by `express-jwt-permissions`.
    If the request has a valid token and has permissions, the user request will be
    able to access the restricted endpoint and perform the action.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的操作都是从用户请求开始的，该请求试图访问一个受限的端点。后端首先验证HTTP请求中是否存在有效的令牌；这个验证是由`express-jwt`模块执行的。其次，如果请求有一个有效的令牌，流程将检查该令牌是否有访问受限端点的有效权限；这个验证是由`express-jwt-permissions`执行的。如果请求有一个有效的令牌并且有权限，用户请求将能够访问受限端点并执行操作。
- en: Managing matches
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理比赛
- en: To create a match, we will need to create a valid Match database schema. We
    already know how to do it using Mongoose. Let's do it.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个比赛，我们需要创建一个有效的Match数据库模式。我们已经知道如何使用Mongoose来做这件事。让我们来做。
- en: Creating the Match schema
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建Match模式
- en: 'Create the `match.js`file in the `src/models` folder. Then, add the following
    code:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在`src/models`文件夹中创建`match.js`文件。然后，添加以下代码：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We have defined three attributes, the first two—`team_1` and `team_2`—will store
    the information of the two teams playing. The `score` of the match. That's all
    we need for our model.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 我们定义了三个属性，前两个`team_1`和`team_2`将存储两支参赛队伍的信息。比赛的`score`。这就是我们模型所需的所有内容。
- en: Creating the REST controller
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建REST控制器
- en: 'Let''s start by creating a new file in the `src/routes`folder named `admin-api.js`.
    Then, write the following code:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从在`src/routes`文件夹中创建一个名为`admin-api.js`的新文件开始。然后，编写以下代码：
- en: '[PRE10]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: You are very familiar with this code structure. First, we import the modules
    required to define our REST controller. Secondly, we create a `/admin/match/:id?`
    route and define the `POST` method to create a new match and another PUT method
    to update the scores.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 你非常熟悉这种代码结构。首先，我们导入定义我们的REST控制器所需的模块。其次，我们创建一个`/admin/match/:id?`路由并定义创建新比赛的`POST`方法以及更新分数的另一个`PUT`方法。
- en: Pay attention to the route definition; we are declaring an optional path variable
    called `:id`. To make a path optional, we add the `?` operator after its name.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意路由定义；我们声明了一个名为`:id`的可选路径变量。为了使路径可选，我们在其名称后添加了`?`运算符。
- en: So far so good. Let's implement them.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止一切顺利。让我们来实现它们。
- en: Creating Matches
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建比赛
- en: 'Creating a new `Match` is simple. We just need to import the `Match` model
    and call its built-in `save` method, as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的`Match`很简单。我们只需要导入`Match`模型并调用其内置的`save`方法，如下所示：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'First, we import the `Match` model. Then, in the `POST` method, we create a
    new `Match` object and call the `save` function. If the operation is successful,
    we send the new `Match` via the `res.json` method. To test our creation logic,
    we need to configure the `server.js` to use our new Admin API, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们导入`Match`模型。然后，在`POST`方法中，我们创建一个新的`Match`对象并调用`save`函数。如果操作成功，我们通过`res.json`方法发送新的`Match`。为了测试我们的创建逻辑，我们需要配置`server.js`以使用我们的新Admin
    API，如下所示：
- en: '[PRE12]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Once we have applied the previous change, open a new terminal to test things
    out:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们应用了前面的更改，打开一个新的终端来测试一下：
- en: '[PRE13]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Cool! Now we have our creation logic up and running with a great real example.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们有了我们的创建逻辑，并且有一个很好的真实示例。
- en: List Matches
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 列出比赛
- en: To list our matches, we won't need security, because all the users should be
    able to get the full list of matches in the applications. So let's implement the
    `matches` API.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 要列出我们的比赛，我们不需要安全措施，因为所有用户都应该能够获取应用程序中比赛的完整列表。所以让我们实现`matches` API。
- en: 'So, create a new file called `matches-api.js` into the `src/routes` folder
    and apply the following code:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在`src/routes`文件夹中创建一个名为`matches-api.js`的新文件，并应用以下代码：
- en: '[PRE14]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Next, we have to configure the `server.js`file to map our `Match` APIs. In
    the `server.js`file, apply the following change:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须配置`server.js`文件以映射我们的`Match` API。在`server.js`文件中，应用以下更改：
- en: '[PRE15]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Cool! Let''s test things out. Open a Terminal window and execute the following
    command:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们来测试一下。打开一个终端窗口并执行以下命令：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That's it! We have our public `Match` API.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！我们有了我们的公共`Match` API。
- en: Updating the Scores
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新分数
- en: To update the `score`, we will require the ID of the match to look up for an
    existing one. If a valid match is found, we will apply the updates. If no match
    is found, we have to respond with a `404 not found` HTTP response. Otherwise,
    we respond with a `Success 200` HTTP response.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 `score`，我们需要查找现有比赛的 ID。如果找到一个有效的比赛，我们将应用更新。如果没有找到比赛，我们必须响应一个 `404 not found`
    HTTP 响应。否则，我们响应一个 `Success 200` HTTP 响应。
- en: 'Let''s start by creating the `updateScore` function, as shown:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建 `updateScore` 函数，如下所示：
- en: '[PRE17]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now, let''s call our function in the PUT HTTP verb, as illustrated:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们按照以下方式调用我们的 PUT HTTP 动词中的函数：
- en: '[PRE18]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Cool! Let''s test things out. Execute the following `curl` command to update
    the match we created earlier:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！让我们测试一下。执行以下 `curl` 命令来更新我们之前创建的比赛：
- en: '[PRE19]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note that the `team_1` (`Peru` team) now has `21` goals in its score, and the
    `Chile` team has `0`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`team_1`（秘鲁队）现在在它的分数中有了 `21` 个进球，而智利队有 `0` 个。
- en: Awesome! Now we are able to create a new Match and update the scores. Let's
    use `express-jwt` and `express-jwt-permissions` to secure our APIs. Keep reading!
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们能够创建一个新的比赛并更新分数了。让我们使用 `express-jwt` 和 `express-jwt-permissions` 来保护我们的
    API。继续阅读！
- en: Securing the REST controller
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护 REST 控制器
- en: 'Now it''s time to secure our API. To do this, let''s start by installing our
    two NPM modules. Open a Terminal window and run the following command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候保护我们的 API 了。为了做到这一点，让我们首先安装我们的两个 NPM 模块。打开终端窗口并运行以下命令：
- en: '[PRE20]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Once the installation is done, let's validate our token.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，让我们验证我们的令牌。
- en: Validate token
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证令牌
- en: Every HTTP request has to send the JWT in its authorization header. The `express-jwt`
    middleware will check whether a valid token has been passed. If so, the request
    will continue its flow, otherwise the backend will respond with an unauthorized
    exception.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 HTTP 请求都必须在授权头中发送 JWT。`express-jwt` 中间件将检查是否传递了有效令牌。如果是，请求将继续其流程，否则后端将响应一个未授权异常。
- en: 'Go ahead and apply the following changes to the `admin-api.js`file:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下更改应用到 `admin-api.js` 文件中：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'First, we start importing the `express-jwt` module and instantiate a new constant
    called `auth`. Secondly, we use the `auth` function and pass a JSON object that
    has the `secret` attribute; we will use the same secret value we used to sign
    our tokens in `security-api.js`:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们开始导入 `express-jwt` 模块并创建一个新的常量 `auth`。其次，我们使用 `auth` 函数并传递一个具有 `secret`
    属性的 JSON 对象；我们将使用与我们在 `security-api.js` 中签名令牌相同的密钥值：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'The `auth` function is responsible for checking whether a valid token has been
    passed in the authorization header. Let''s try to create a new `Match` entity
    without passing a valid token. Open the Terminal window and execute the following
    command:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`auth` 函数负责检查是否在授权头中传递了有效的令牌。让我们尝试不传递有效令牌创建一个新的 `Match` 实体。打开终端窗口并执行以下命令：'
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As you can see, this time we are receiving an error message that says that
    our backend API is waiting for a valid token and none has been provided. So, to
    tackle this situation, we will need to create a valid token first. Let''s create
    a valid token by calling our security API and logging in as admins. Execute the
    following command:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这次我们收到了一个错误消息，表示我们的后端 API 正在等待一个有效令牌，但没有提供。因此，为了应对这种情况，我们需要首先创建一个有效令牌。让我们通过调用我们的安全
    API 并以管理员身份登录来创建一个有效令牌。执行以下命令：
- en: '[PRE24]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: A new valid token has been created for me. Be aware that this token has a random
    value, so the token generated for you will be completely different.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 为我创建了一个新的有效令牌。请注意，此令牌具有随机值，因此为您生成的令牌将完全不同。
- en: 'Once we have a valid token, let''s try again; however, this time we will pass
    the token using the `Authorization` HTTP headers, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有了有效的令牌，我们再次尝试；然而，这次我们将使用 `Authorization` HTTP 头部传递令牌，如下所示：
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Cool! Now we are able to create a new `Match`. Pay attention to the syntax
    that we have used to pass the token. We have used the `Authorization: Bearer <token>`
    syntax.'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '太棒了！现在我们能够创建一个新的 `Match`。请注意我们传递令牌时使用的语法。我们使用了 `Authorization: Bearer <token>`
    语法。'
- en: We have protected our API, but what about if we have two different types of
    administrators? Let's say that one group of administrators can be limited to only
    add `Match` entities, and the other group of administrators is limited to only
    update the scores. We need a way to manage this separation of roles. Let's learn
    how permissions work.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经保护了我们的 API，但如果我们有两种不同类型的管理员怎么办？比如说，一组管理员只能添加 `Match` 实体，而另一组管理员只能更新分数。我们需要一种方式来管理这种角色分离。让我们学习权限是如何工作的。
- en: Validate permissions
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 验证权限
- en: 'Permissions allow us to limit the access to a group of resources. You should
    be aware that authentication is not enough if we want to secure our backend APIs.
    To implement permissions, open the `admin-api.js`file and apply the following
    changes:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 权限允许我们限制对一组资源的访问。你应该意识到，如果我们想保护我们的后端API，仅进行身份验证是不够的。要实现权限，请打开`admin-api.js`文件并应用以下更改：
- en: '[PRE26]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we start by initializing a `guard` constant. Secondly, we call `guard.check`;
    this function will look for the `admin:create:match` permission in the JWT. Remember
    that these permissions have to be present in the token. If the user has permission,
    the flow will continue and the new `Match` will be created. Otherwise, we will
    receive a `Could not find permissions` error.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们初始化一个`guard`常量。其次，我们调用`guard.check`；这个函数将在JWT中查找`admin:create:match`权限。记住，这些权限必须存在于令牌中。如果用户有权限，流程将继续，并创建新的`Match`。否则，我们将收到`无法找到权限`错误。
- en: 'Let''s try to create a new `Match`; execute the following command:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们尝试创建一个新的`Match`；执行以下命令：
- en: '[PRE27]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'That''s interesting! Although we are authenticated and are passing a valid
    token, why are we not able to create the `Match`? Let''s look at the user token
    generation logic. Open the `security-api.js` file:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣！尽管我们已经进行了身份验证并传递了一个有效的令牌，但我们为什么不能创建`Match`？让我们看看用户令牌生成逻辑。打开`security-api.js`文件：
- en: '[PRE28]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'As you can see, our token doesn''t have the permissions defined. Let''s fix
    this by adding the right permissions:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所见，我们的令牌没有定义权限。让我们通过添加正确的权限来解决这个问题：
- en: '[PRE29]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: That's all. Let's generate a new token by logging in again, and let's test things
    out.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 那就结束了。让我们再次登录以生成一个新的令牌，并测试一下。
- en: 'First, execute the following command to generate a valid token:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，执行以下命令以生成一个有效的令牌：
- en: '[PRE30]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Cool! this new token contains the permissions. Next, let''s try to create the
    new `Match` again by passing this new token:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这个新的令牌包含了权限。接下来，让我们尝试再次通过传递这个新的令牌来创建新的`Match`：
- en: '[PRE31]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Hot dog! We are now able to manage authentication and authorization in our backend
    API. Of course, you can improve this security authentication by saving a collection
    of users in a MongoDB database and create different users with different roles.
    Also, implement `log out` using `express-jwt-blacklist` and in another fashion,
    but for the purpose of this book, we are good with this basic implementation.
    Keep reading!
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 热狗！我们现在能够管理后端API中的身份验证和授权。当然，你可以通过在MongoDB数据库中保存用户集合并创建具有不同角色的不同用户来提高这种安全身份验证。此外，使用`express-jwt-blacklist`实现`登出`，以另一种方式，但出于本书的目的，我们对此基本实现感到满意。继续阅读！
- en: Introducing Auth0
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍Auth0
- en: Managing authentication and authorization by ourselves might become a really
    difficult task to do. Imagine that you need to implement security logic for web
    applications, mobile applications, and desktop apps. Even your customer might
    ask you to integrate their applications to social networks and use multifactor
    authentication or use a password-less method. Although we have implemented the
    security for our application, we encourage you not to write security code yourself
    unless you are creating a really simple application.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 自己管理身份验证和授权可能变得非常困难。想象一下，你需要为Web应用程序、移动应用程序和桌面应用程序实现安全逻辑。甚至你的客户可能要求你将他们的应用程序集成到社交网络中，并使用多因素身份验证或无密码方法。尽管我们已经为我们的应用程序实现了安全措施，但我们鼓励你除非你正在创建一个非常简单的应用程序，否则不要自己编写安全代码。
- en: 'So, in this section, we will implement authentication and authorization using
    one popular service called Auth0 ([https://auth0.com](https://auth0.com)). This
    service will help us empower our authentication flows, such as these:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本节中，我们将使用一个名为Auth0（[https://auth0.com](https://auth0.com)）的流行服务来实现身份验证和授权。此服务将帮助我们增强我们的身份验证流程，例如：
- en: Social login
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 社交登录
- en: Single sign-on
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单点登录
- en: Email authentication
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 邮箱身份验证
- en: Multifactor
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 多因素
- en: Password-less authentication
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无密码身份验证
- en: Fingerprint login
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指纹登录
- en: LDAP integration
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: LDAP集成
- en: Also, Auth0 provides monitoring and other out-of-the-box services that will
    help us manage our user's information.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Auth0还提供监控和其他开箱即用的服务，这些服务将帮助我们管理我们的用户信息。
- en: A simple example
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 一个简单的例子
- en: Although we use our custom implementation for the world cup application, we
    have prepared a simple example to show you how to use Auth0 with Aurelia. You
    can download the code from [https://github.com/EriksonMurrugarra/AureliaAuth0](https://github.com/EriksonMurrugarra/AureliaAuth0).
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们为世界杯应用程序使用了自定义实现，但我们已经准备了一个简单的示例来向您展示如何使用 Auth0 与 Aurelia。您可以从 [https://github.com/EriksonMurrugarra/AureliaAuth0](https://github.com/EriksonMurrugarra/AureliaAuth0)
    下载代码。
- en: Auth0 implements JWT; this should ring a bell for you, because we have implemented
    our custom Auth0 implementation using JWT. Let's start by creating a free account
    on Auth0.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: Auth0 实现了 JWT；这应该让您想起，因为我们使用 JWT 实现了我们的自定义 Auth0 实现。让我们首先在 Auth0 上创建一个免费账户。
- en: Creating an account
  id: totrans-158
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建账户
- en: 'First, navigate to the official Auth0 site, [https://auth0.com](https://auth0.com),
    and click on the SIGN UP button:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，导航到官方 Auth0 网站，[https://auth0.com](https://auth0.com)，并点击“注册”按钮：
- en: '![](img/64ab4512-aa22-4725-940a-c9e9ed7db6cf.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/64ab4512-aa22-4725-940a-c9e9ed7db6cf.png)'
- en: 'Then, fill the form with your email and password, and click on the SIGN UP button
    or use your social network accounts:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，填写表单中的电子邮件和密码，并点击“注册”按钮或使用您的社交网络账户：
- en: '![](img/a432796a-b2b4-4dc3-b9f1-ef532e3b613b.png)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a432796a-b2b4-4dc3-b9f1-ef532e3b613b.png)'
- en: Once the sign-up process is complete, you should be redirected to your administration
    dashboard. The administration dashboard will allow you to configure the different
    security mechanisms that you can implement in just a few seconds. Let's continue
    by registering an application to generate some valid configuration values to connect
    our Aurelia application to Auth0.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成注册过程，您应该会被重定向到您的管理仪表板。管理仪表板将允许您在几秒钟内配置可以实施的不同安全机制。让我们继续注册一个应用程序以生成一些有效的配置值，以便将我们的
    Aurelia 应用程序连接到 Auth0。
- en: Registering an Auth0 client application
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册 Auth0 客户端应用程序
- en: If you have previous experience of working with third-party service providers,
    you might have noted that in order to use their services, you have to register
    an application in order to get some private keys that you will use to access your
    third-party provider's resource. The same happens with Auth0; we should first
    register an application and then use the keys generated to configure our apps.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有与第三方服务提供商合作的经验，您可能会注意到，为了使用他们的服务，您必须注册一个应用程序以获取一些私钥，您将使用这些私钥来访问第三方提供商的资源。Auth0
    也是如此；我们应该首先注册一个应用程序，然后使用生成的密钥来配置我们的应用程序。
- en: 'On the dashboard page, go ahead and select the Applications menu and click
    on the CREATE CLIENT button:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在仪表板页面上，继续选择“应用程序”菜单并点击“创建客户端”按钮：
- en: '![](img/0af642dc-d0cd-41c3-bb85-9b262c9d6775.png)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0af642dc-d0cd-41c3-bb85-9b262c9d6775.png)'
- en: 'After clicking on the CREATE CLIENT button, fill the following form with your
    application''s name and select Single Page Application for the client type; then,
    click on CREATE:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 点击“创建客户端”按钮后，填写以下表单中的应用程序名称，并选择客户端类型为单页应用程序；然后，点击“创建”：
- en: '![](img/a3539d94-cb2d-41d1-8b4d-5c5b79383d9a.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/a3539d94-cb2d-41d1-8b4d-5c5b79383d9a.png)'
- en: 'Once we create the client, a new configuration page will be displayed. Navigate
    to the Settings tab and you will see the following configuration values:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 创建客户端后，将显示一个新的配置页面。导航到“设置”选项卡，您将看到以下配置值：
- en: 'Name: The name of our application'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称：我们应用程序的名称
- en: 'Domain: The domain you previously registered in the sign-up process'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 域名：您在注册过程中之前注册的域名
- en: 'Client ID: A unique ID that makes your application unique'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端 ID：一个独特的 ID，使您的应用程序独一无二
- en: 'Client Secret: The secret value used to sign the JWT that Auth0 will generate'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端密钥：用于签署 Auth0 将生成的 JWT 的密钥值
- en: 'Allowed Callback URL: The list of URL that Auth0 will redirect when the authentication
    is a success'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 允许的回调 URL：当身份验证成功时，Auth0 将重定向到的 URL 列表
- en: 'That''s it. Before we explore the application''s code, let''s start understanding
    how Auth0 manages authentication by analyzing the following diagram:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些。在我们探索应用程序的代码之前，让我们通过分析以下图表来了解 Auth0 如何管理身份验证：
- en: '![](img/bcee34dc-5eab-475e-8c88-d95bf08b82a9.png)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bcee34dc-5eab-475e-8c88-d95bf08b82a9.png)'
- en: The flow begins when the User wants to log in to the application. You might
    have a kind of Navigation bar with a button that when clicked on will trigger
    a JavaScript function that will call an Auth0 JavaScript login function. Secondly,
    the user will be redirected to a built-in Auth0 Login Form and will have to enter
    their credentials to sign up. The credentials entered by the users are validated
    by Auth0; if the Auth0 finds a valid user with the provided credentials, it will
    generate a valid JWT that will be sent to the user/Aurelia app. This JWT will
    be used to access your backend resources. Remember that you can use the Client
    Secret property to decrypt the token in the backend.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 流程从用户想要登录应用程序时开始。你可能有一个导航栏，其中有一个按钮，点击后会触发一个 JavaScript 函数，该函数将调用 Auth0 JavaScript
    登录函数。其次，用户将被重定向到内置的 Auth0 登录表单，并需要输入他们的凭据以进行注册。用户输入的凭据将由 Auth0 验证；如果 Auth0 找到具有提供的凭据的有效用户，它将生成一个有效的
    JWT，并将其发送到用户/Aurelia 应用程序。此 JWT 将用于访问你的后端资源。请记住，你可以在后端使用客户端密钥属性来解密令牌。
- en: Exploring our example application
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索我们的示例应用程序
- en: 'First, we will need to download the source code from the GitHub repository
    at [https://github.com/EriksonMurrugarra/AureliaAuth0](https://github.com/EriksonMurrugarra/AureliaAuth).
    Let''s open a Terminal window in the folder of your preference and run the following
    command:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要从 GitHub 仓库 [https://github.com/EriksonMurrugarra/AureliaAuth0](https://github.com/EriksonMurrugarra/AureliaAuth)
    下载源代码。让我们在你的首选文件夹中打开一个终端窗口，并运行以下命令：
- en: '[PRE32]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Once the source code is downloaded, we will need to install the dependencies
    and run the application. Let''s get into the source code folder and execute the
    following commands:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 下载源代码后，我们需要安装依赖项并运行应用程序。让我们进入源代码文件夹，并执行以下命令：
- en: '[PRE33]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s open a new browser and navigate to [http://localhost:9000](http://localhost:9000),
    which will display a simple home page with a Log In option in the Navigation bar:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开一个新的浏览器，并导航到 [http://localhost:9000](http://localhost:9000)，这将显示一个简单的首页，在导航栏中有一个登录选项：
- en: '![](img/e415a435-9158-4cda-b22b-36ced3142b62.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e415a435-9158-4cda-b22b-36ced3142b62.png)'
- en: 'Cool! We have our application up and running, but we will need to configure
    it first before we can log in successfully. Go ahead and open the following `auth-service.js`
    file located in the `src` folder. We will need to replace the values for the configuration
    values that we got when we created our client application on Auth0\. In our case,
    the values are the following:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们的应用程序已经启动并运行，但在成功登录之前，我们首先需要对其进行配置。请打开位于 `src` 文件夹中的以下 `auth-service.js`
    文件。我们需要替换我们在 Auth0 上创建客户端应用程序时获得的配置值。在我们的例子中，这些值如下：
- en: '[PRE34]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: It's important to mention that the `redirectUri` should be registered in Auth0
    in the application settings in Allowed Callback URLs.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 需要强调的是，`redirectUri` 应该在 Auth0 的应用程序设置中的允许回调 URL 中注册。
- en: 'Cool! Save the changes and click on the LOG IN button to be redirected to the
    following page:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！保存更改并点击 LOG IN 按钮，将被重定向到以下页面：
- en: '![](img/e95aa9bc-bfd6-48be-b0a0-67aa82fc10b0.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e95aa9bc-bfd6-48be-b0a0-67aa82fc10b0.png)'
- en: 'The previous page is provided by Auth0; you might note that the URL has changed.
    It means that every time that our users are asked to log in, they will be redirected
    to Auth0\. As you haven''t created any user account yet, you will need to sign
    up first. Once you are done with the registration process, you will be redirected
    to the home page:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 上一页由 Auth0 提供；你可能注意到 URL 已经更改。这意味着每次我们的用户被要求登录时，他们都会被重定向到 Auth0。由于你还没有创建任何用户账户，你首先需要注册。完成注册过程后，你将被重定向到主页：
- en: '![](img/77b34e64-3aaa-426f-b3d8-1b9f0df94bda.png)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/77b34e64-3aaa-426f-b3d8-1b9f0df94bda.png)'
- en: That's it! Now you are logged in to the application using a more secure strategy.
    Remember that you should never implement authentication and authentication yourself.
    It is best practice to use a third-party service. The developers who created the
    services such as Auth0 will definitely have had years of experience creating the
    most secure authentication and authorization mechanism than you.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！现在你已经使用更安全的策略登录到应用程序。请记住，你永远不应该自己实现身份验证和授权。最佳实践是使用第三方服务。创建 Auth0 等服务的开发者肯定有多年创建比你自己更安全的身份验证和授权机制的经验。
- en: Social Login with Auth0
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Auth0 进行社交登录
- en: There is an important truth behind the human behavior when they are in front
    of any registration form. Most of your users will hate your application if you
    make them waste their valid time asking for personal information that they have
    already filled in their favorite social network. Even if you try to create the
    best user experience for your SIGN UP form, they will avoid them. So, how do we
    make our users happy and avoid them having to do this horrible sign-up process?
    Social Login integration to the rescue!
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当人们面对任何注册表单时，背后有一个重要的真理。如果你的用户在他们的最喜欢的社交网络中已经填写了个人信息，而你让他们浪费有效时间再次填写这些信息，他们中的大多数都会讨厌你的应用程序。即使你试图为你的注册表单创造最佳的用户体验，他们也会避免使用它。那么，我们如何让我们的用户开心，并避免他们不得不进行这个可怕的注册过程呢？社交登录集成来拯救！
- en: Implementing Social Login might be repetitive work in case you have multiple
    social networks that you need to integrate into your application. Instead of implementing
    everything yourself, why don't we use an existing service that can help us in
    this process? Auth0 to the rescue!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要将多个社交网络集成到你的应用程序中，实现社交登录可能是一项重复性的工作。为什么不使用一个现有的服务来帮助我们完成这个过程呢？Auth0来拯救！
- en: 'Let''s implement Social Login in just 3 minutes. Yeah! you read well, just
    3 minutes. Go ahead and navigate to your Auth0 dashboard at [https://manage.auth0.com](https://manage.auth0.com) and
    navigate to the Connections/Social menu. Then, go ahead and activate the social
    networks that you want to integrate with your authentication flow, as follows:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在3分钟内实现社交登录。是的！你没看错，只需3分钟。请继续，导航到你的Auth0仪表板[https://manage.auth0.com](https://manage.auth0.com)，然后导航到“连接/社交”菜单。接下来，激活你想要集成到认证流程中的社交网络，如下所示：
- en: '![](img/d1724f15-8f04-49f5-96fa-32dafa5b6107.png)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d1724f15-8f04-49f5-96fa-32dafa5b6107.png)'
- en: As you can see, I have enabled Google and Facebook for the authentication flow.
    Remember that you will need to register an application on Facebook and Twitter
    first and then use the keys generated to configure the Social Login methods.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我已经为认证流程启用了Google和Facebook。记住，你首先需要在Facebook和Twitter上注册一个应用程序，然后使用生成的密钥来配置社交登录方法。
- en: 'We are almost done. To finish the process, we just need to tell our client
    application that we want to enable social login. To do this, let''s navigate to
    the Clients menu and get into the MyAuth0App client application. Then, navigate
    to the Connections tab and enable Facebook and Twitter in the Social section,
    as demonstrated:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完成了。为了完成这个过程，我们只需要告诉我们的客户端应用程序我们想要启用社交登录。为此，让我们导航到“客户端”菜单，进入MyAuth0App客户端应用程序。然后，导航到“连接”标签，在社交部分启用Facebook和Twitter，如下所示：
- en: '![](img/c7cc56ad-644e-4a5e-827d-d51b1ebda387.png)'
  id: totrans-201
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7cc56ad-644e-4a5e-827d-d51b1ebda387.png)'
- en: 'Once we have everything configured, the next time when your users try to log
    in to the application, they will see the following form:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们配置好了一切，下次当你的用户尝试登录应用程序时，他们将看到以下表单：
- en: '![](img/e54f530f-d07e-4f6f-8c57-b40d3dc51c1c.png)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e54f530f-d07e-4f6f-8c57-b40d3dc51c1c.png)'
- en: Cool! Now we know how to integrate our applications to allow our users to sign
    in to our application, allowing them to use their favorite social network accounts.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！现在我们知道了如何集成我们的应用程序，让我们的用户能够登录我们的应用程序，并使用他们最喜欢的社交网络账户。
- en: Single sign-on
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单点登录
- en: 'If you are implementing a big enterprise solution that consists of different
    distributed applications that require authentication and authorization but require
    to use the same user''s database, you will need to implement a different flow
    to manage the authentication in all these independent applications. This mechanism
    is called **single sign-on** (**SSO**), which will basically ask for login once
    in any of your applications and will reuse the same generated token in all the
    applications. The following diagram explains this flow:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在实施一个由不同分布式应用程序组成的大型企业解决方案，这些应用程序需要认证和授权，但需要使用相同的用户数据库，你将需要实现不同的流程来管理所有这些独立应用程序的认证。这种机制被称为**单点登录**（**SSO**），它基本上会在你的任何应用程序中要求登录一次，并将重用生成的相同令牌在所有应用程序中。以下图表解释了这个流程：
- en: '![](img/b8322976-0b08-43a9-a2c9-48f6004c0048.png)'
  id: totrans-207
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b8322976-0b08-43a9-a2c9-48f6004c0048.png)'
- en: In the preceding illustration, there are three applications. Let's suppose that
    these three different applications are developed by the same company and the employees
    use the three applications. Imagine that in order to access each application,
    the employees have to log in to each application using different credentials,
    or they can choose to use the same username and password for the three apps.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示意图中，有三个应用程序。让我们假设这三个不同的应用程序是由同一家公司开发的，员工使用这三个应用程序。想象一下，为了访问每个应用程序，员工必须使用不同的凭证登录到每个应用程序，或者他们可以选择为三个应用程序使用相同的用户名和密码。
- en: Why should our users log in again to another application if these applications
    share the same user information? First, a user will log in to the server and retrieve
    a valid token. Once the first application is logged in to, it can save the token
    as cookies or in `LocalStorage` in the browser. When the user accesses Application
    02, the app should detect that there is an existing token and should use it to
    access the server without asking for credentials.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 如果这些应用程序共享相同用户信息，为什么我们的用户还需要再次登录到另一个应用程序呢？首先，用户将登录到服务器并检索一个有效的令牌。一旦第一个应用程序登录，它就可以将令牌作为cookies或存储在浏览器的`LocalStorage`中。当用户访问应用程序02时，应用应该检测到存在一个现有的令牌，并应该使用它来访问服务器，而无需请求凭证。
- en: Now that you know how SSO works, You are free to implement SSO by yourself or
    use an external service. Auth0 has an awesome support for SSO.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了SSO的工作原理，你可以自由地自己实现SSO或使用外部服务。Auth0对SSO提供了出色的支持。
- en: Summary
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a custom implementation to manage authentication
    and authorization in order to protect the use of our API from unauthorized users.
    You have seen that implementing Auth0 on your own might be a difficult task and
    will require more security layers than the ones we have implemented. A good practice
    is to use an external service to implement authentication and authorization in
    your projects. We created a simple application that uses one of the most popular
    third-party services, called Auth0.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个自定义实现来管理认证和授权，以保护我们的API免受未经授权用户的使用。你已经看到，自己实现Auth0可能是一项艰巨的任务，并且需要比我们实现的多出更多的安全层。一个好的做法是在你的项目中使用外部服务来实现认证和授权。我们创建了一个简单的应用程序，它使用了一个最受欢迎的第三方服务，名为Auth0。
- en: We also covered how to integrate social login to our application, but we implemented
    this feature using Auth0 built-in social connection features. You can implement
    social authentication on your own, but again, it is better to spend energy on
    your application login rather than wasting time implementing features that can
    be achieved in no time using a third-party service.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还介绍了如何将社交登录集成到我们的应用程序中，但我们使用Auth0内置的社交连接功能来实现这一功能。你可以自己实现社交认证，但再次强调，最好将精力集中在你的应用程序登录上，而不是浪费时间实现那些可以迅速通过第三方服务实现的功能。
- en: We looked at how SSO works in theory and learned that it is a simple process
    reusing the user token in all your different applications.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们探讨了SSO在理论上的工作方式，并了解到它是一个简单的流程，即在所有不同的应用程序中重复使用用户令牌。
- en: That's it! In the next chapter, you will learn how to apply end-to-end tests
    on your Aurelia applications. Keep reading!
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些！在下一章中，你将学习如何在Aurelia应用程序上应用端到端测试。继续阅读！
