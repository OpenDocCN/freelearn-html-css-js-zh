- en: Chapter 9. Building a Physics Car Game with Box2D and Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*2D Physics Engines is a hot topic in game development. With the help of a
    physics engine, we can easily create a playable game by just defining an environment
    and a simple rule. Taking existing games as examples, players in the Angry Birds
    game fly birds to destroy the enemy''s castle. In Cut the Rope, candy drops into
    the monster''s mouth to progress to the next level.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Box2D JavaScript library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a static ground body in the physics world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Drawing the physics world on the Canvas
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a dynamic box in the physics world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advancing the world time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding wheels to the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the physics car
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding force to the car with a keyboard input
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking a collision in the Box2D world
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding level support to our car game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Replacing the Box2D outline drawing with graphics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding a final touch to make the game fun to play
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows what we will get by the end of this chapter;
    it is a car game in which a player moves the car towards the destination point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building a Physics Car Game with Box2D and Canvas](img/B04290_09_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can also play the game at [http://makzan.net/html5-games/car-game/](http://makzan.net/html5-games/car-game/)
    to get a glimpse of the final result.
  prefs: []
  type: TYPE_NORMAL
- en: So, let's get on with it.
  prefs: []
  type: TYPE_NORMAL
- en: Installing the Box2D JavaScript library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, suppose that we want to create a car game. We apply force to the car to
    make it move forward. The car moves on a ramp and then flies through the air.
    Afterwards, the car falls on the destination ramp and the game finishes. Every
    collision in every part of the physics world counts on this movement. If we have
    to make this game from scratch, then we have to calculate at least the velocity
    and angle of each part. Luckily, the physics library helps us to handle all these
    physical problems. All we have to do is to create the physics model and present
    it in the canvas. The engine we use is Box2D.
  prefs: []
  type: TYPE_NORMAL
- en: Box2D is a 2D physics simulation engine. The original Box2D was written in C
    by Erin Catto. It was later ported to Flash ActionScript. Later on, its 2.1a version
    was ported to JavaScript. You can find the JavaScript version of Box2D 2.1a in
    their Google Code project at [https://code.google.com/p/box2dweb/](https://code.google.com/p/box2dweb/).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: At the time of writing this book, Google Code announced that they would close
    down in 2016\. I have forked the library into a URL ([https://github.com/makzan/Box2DWeb-Fork](https://github.com/makzan/Box2DWeb-Fork))
    in case the original repository is not accessible.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – installing the Box2D physics library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will set up the Box2D library. We must carry out the following steps to
    prepare our project:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's set up our game project. Create a folder with the following file
    structure. The HTML file contains an HTML template with empty content and includes
    all the scripts and style files. You may find the full document's source in the
    code bundle. Please also download the Box2D source file into the `js` folder.![Time
    for action – installing the Box2D physics library](img/B04290_09_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the HTML body, we must define a canvas, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We must then alias several Box2D classes that we will use in our game; this
    makes it easier to refer them in the code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we will create an empty world to test our Box2D library installation.
    Open the `box2dcargame.js` JavaScript file and put the following code in the file
    to create the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Open the `index.html` file in a web browser. We should see a grey canvas with
    nothing there.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We have not presented the physics world to the canvas yet. This is why we only
    see a blank canvas on the page. However, we have printed the newly created world
    in the console log. The following screenshot shows the console tracing the world
    object with many properties beginning with `m_`. These are the physical states
    of the world:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Time for action – installing the Box2D physics library](img/B04290_09_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just installed the Box2D JavaScript library and created an empty world
    to test the installation.
  prefs: []
  type: TYPE_NORMAL
- en: Using b2World to create a new world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `b2World` class is a core class in the Box2D environment. All our physics
    bodies, including the ground and car, are created in this world. The following
    code shows us how to create a world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `b2World` class takes two arguments to initialize, which are listed in
    the following table with their description:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Type | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `gravity` | b2Vec2 | This represents the gravity of the world |'
  prefs: []
  type: TYPE_TB
- en: '| `doSleep` | Bool | This defines whether the world ignores slept objects or
    not |'
  prefs: []
  type: TYPE_TB
- en: Setting the gravity of the world
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have to define the gravity of the world. The gravity is defined by `b2Vec2`.
    The `b2Vec2` class is a vector of *x* and *y* axes. Therefore, the following code
    defines gravity with 10 units downwards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting Box2D to ignore the sleeping object
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A sleeping body is a dynamic body that skips simulation until it wakes up. The
    physics library calculates the mathematical data and collision of all the bodies
    in the world. The performance will slow down when there are too many bodies in
    the world to get calculated in every frame. When a sleeping body collides with
    another object, it will wake up and then turn back to sleeping mode again until
    the next collision.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a static ground body in the physics world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The world is empty now. If we are going to place objects there, the objects
    will fall and finally leave our sight. Now, suppose we want to create a static
    ground body in the world so that objects can stand on it. We can do this in Box2D.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating a ground in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to create a static ground:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `box2dcargame.js` JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the following `pxPerMeter` variable in the file; this is the unit setting
    in the Box2D world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following function to the end of the JavaScript file; this creates
    a fixed body as the playground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `createGround` function in the `initGame` function after we have created
    the world as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As we are still defining the logic and have not yet presented the physics world
    visually, we will see nothing if we open the browser. However, it is worth getting
    into the habit of trying it and inspecting the console window for an error message
    if there is any.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have created a ground body with the shape and body definitions. This is a
    common process that we will use a lot to create different kinds of physical bodies
    in the world. So, let's get into the details of how we made it.
  prefs: []
  type: TYPE_NORMAL
- en: Pixel per meter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The size and position unit in Box2D is calculated in meters. We use pixels in
    screen. Therefore, we define a variable that converts a unit between meters and
    screen pixels. We set the value to 30, which indicates that 30 pixels equal to
    1 meter. You can explore different values for your physics world.
  prefs: []
  type: TYPE_NORMAL
- en: We should not use 1 pixel to 1 meter, otherwise our object would become very
    large in the Box2D scale. Imagine we have a car with 100 px width, it will become
    100 meters long, which is not realistic at all. By defining 30 px/meter, or any
    reasonable value, an object with width 100 px on screen will be about 3.33 meters
    long in simulation, which Box2D can handle well. For more details, please refer
    to the Box2D manual section 1.7 at [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html).
  prefs: []
  type: TYPE_NORMAL
- en: Creating a shape with a fixture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A fixture contains the physics properties and its shape. The physics properties
    define density, friction, and restitution, where restitution is basically the
    bounciness of the object. A shape defines the geometrical data. The shape can
    be a circle, rectangle, or a polygon. The following code that we used in the preceding
    example defines a box shape definition. The `SetAsBox` function takes two arguments:
    half width and half height. It is a half value, so the final area of the shape
    is four times the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Creating a body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After defining the fixture, we can then create a body definition with the given
    shape definition. Then, we set the initial position of the body and finally ask
    the world instance to create a body from our body definition. The following code
    shows how we create a body in the world with the given shape definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: A body can be either a static body or a dynamic body. Static bodies are immovable
    and will not have collisions with other static bodies. Therefore, these bodies
    can be used as the ground or walls to become the level environment. On the other
    hand, a dynamic body will move following a collision with other bodies (static
    or dynamic) and due to gravity. We will create a dynamic box body later.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the bouncing effect with the restitution property
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The restitution value is between 0 and 1\. In our case, the box is falling on
    the ground. When the restitution value is 0 on both the ground and the box, the
    box does not bounce at all. When either the box or the ground has a restitution
    value of 1, the collision is perfectly elastic.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When two bodies collide, the restitution value of that collision is the maximum
    value between both restitution values of both the bodies. Therefore, if a box
    with a restitution value of 0.4 drops on the ground with a restitution value of
    0.6, this collision will use 0.6 to calculate the bouncing velocity.
  prefs: []
  type: TYPE_NORMAL
- en: Drawing the physics world in the canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created the ground, but it is only in the mathematics model. We do not
    see anything in the canvas because we have not drawn anything on it yet. In order
    to show what the physics looks like, we have to draw something according to the
    physics world.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – drawing the physics world into the Canvas
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to draw the useful debug view:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, open the `box2dcargame.js` JavaScript file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a function that draws the debugging lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a `showDebugDraw` function call at the end of the `initGame` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, reopen the game in a browser, and we should see the outline of the ground
    body in the canvas, as shown in the following screenshot:![Time for action – drawing
    the physics world into the Canvas](img/B04290_09_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have just defined a method that asks the Box2D engine to draw the physics
    bodies in a canvas. This is useful for debugging before we successfully add our
    own graphics. We can set what to display via the `SetFlags` method.
  prefs: []
  type: TYPE_NORMAL
- en: The flags are bitwise variable. This means that each bit in the flag controls
    one drawing type. We combine the flag by using the bitwise operator or (`|`).
    For example, we show the shape and joint with the following code.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'There are different types of debug drawings besides the shape and joint:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Bit flag | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `e_aabbBit` | This draws all the bounding boxes |'
  prefs: []
  type: TYPE_TB
- en: '| `e_centerOfMassBit` | This draws the center of the mass |'
  prefs: []
  type: TYPE_TB
- en: '| `e_controllerBit` | This draws all the dynamics controllers |'
  prefs: []
  type: TYPE_TB
- en: '| `e_jointBit` | This draws all the joint connections |'
  prefs: []
  type: TYPE_TB
- en: '| `e_pairBit` | This draws the broad-phrase collision pairs |'
  prefs: []
  type: TYPE_TB
- en: '| `e_shapeBit` | This draws all the shapes |'
  prefs: []
  type: TYPE_TB
- en: Creating a dynamic box in the physics world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine now that we drop a box into the world. The box falls from the air and
    finally hits the ground. The box bounces up a little and finally lands on the
    ground. This is different from what we created in the last section. In the last
    section, we created a static ground, which was immovable and could not be affected
    by gravity. Now, we will create a dynamic box.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – putting a dynamic box in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to create our first dynamic body:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open our JavaScript file and add the following box creation code to the page
    loaded event handler. Place the code after the `createGround` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to call our newly created `createBox` function. Place the following
    code after we call the `createGround` function inside `initGame`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will test the physics world in a browser. You should see that a box
    is created at the given initial position. However, the box is not falling down;
    this is because we still have to do something to make it fall:![Time for action
    – putting a dynamic box in the world](img/B04290_09_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a dynamic body in the world. In contrast to the ground body
    that is immovable, this box is affected by the gravity and the velocity changes
    during a collision. When a body contains a shape with any mass or density, it
    is a dynamic body. Otherwise, it is static. Therefore, we define a density to
    our box. Box2D will make it dynamic and calculate the mass according to the density
    and size of the body automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Advancing the world time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The box is dynamic but it does not fall down. Are we doing anything wrong here?
    The answer is no. We have set up the box correctly, but we forget to advance the
    time in the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: In the Box2D physics world, all calculations are done in a systematic iteration.
    The world calculates the physical transformation of all things according to the
    current step. When we move the `step` to the next level, the world calculates
    again as the new state.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – setting up the world step loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will make the world time advance by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to advance the world step, we have to call the `step` function in
    the world instance periodically. We used `setTimeout` to keep calling the `step`
    function. Put the following function in our JavaScript logic file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will set up an interval in the `initGame` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will again simulate the world in a browser. The box is created at the initialized
    position and falls on the ground correctly. The following screenshot shows the
    sequence of a box dropping on the ground:![Time for action – setting up the world
    step loop](img/B04290_09_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have advanced the time of the world. Now, the physics library simulates the
    world in a frequency of 60 times per second. In the game loop, we call the `Step`
    function to the Box2D world. The `Step` function simulates the physics world one
    step forward. During the step, the physics engine calculates everything that happens
    in the world, including forces and gravity.
  prefs: []
  type: TYPE_NORMAL
- en: Adding wheels to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we have a box in the game. Imagine now we create two circular bodies as
    the wheels. Then, we will have the basic components of a car—the body and the
    wheels.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – putting two circles in the world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will add two circles to the world by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `html5games.box2dcargame.js` JavaScript file to add the wheel bodies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following code after the box creation code. This calls the `createWheel`
    function which we will write to create a circular shaped body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now let''s work on the `createWheel` function. We design this function to create
    a circle-shaped body in the given world at the given *x* and *y* coordinates in
    the world. To do this, put the following function in our JavaScript logic file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now reload the physics world in a web browser. This time, we should
    see a result similar to the one shown in the following screenshot, with a box
    and two wheels falling down from air:![Time for action – putting two circles in
    the world](img/B04290_09_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When simulating the physics world, both the box and wheels drop and collide
    with each other and the ground.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a circular body is similar to creating a box body. The only difference
    is that we use a `CircleDef` class instead of the box shape definition. In the
    circle definition, we define the circle size by using the `radius` property instead
    of the `extents` property.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a physical car
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have prepared the car box body and two wheel bodies. We are just one step
    away from making a car. Imagine that now we have a glue stick to glue the wheels
    to the car body. Then, the car and wheels will not separate anymore, and we will
    have a car. We can use **joint** to achieve this. In this section, we will use
    `joint` to stick the wheels and the car body together.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – connecting the box and two circles with a revolute joint
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to create a car with the box and wheels:'
  prefs: []
  type: TYPE_NORMAL
- en: We are still working only on the logic part. Open our JavaScript logic file
    in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Create a function named `createCarAt`, which takes the coordinates as arguments.
    Then, move the body and the wheel creation code in this function. Afterwards,
    add the following highlighted joint creation code. At last, return the car body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `initGame` function, we created two wheels. Remove these lines of code
    that calls the `createWheel` function in the `initGame` function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, all we need to do is create a car with the initial position. Add the
    following code to the `initGame` function after calling the `createGround` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is time to save the file and run the physics world in a browser. At this
    time, the wheels and the car body are not separate pieces. They glue together
    as a car and drop on the ground correctly, as shown in the following screenshot:![Time
    for action – connecting the box and two circles with a revolute joint](img/B04290_09_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A joint is useful to add constraint between two bodies (or between a body and
    the world). There are many kinds of joints and what we used in this example is
    called the **revolute joint**.
  prefs: []
  type: TYPE_NORMAL
- en: Using a revolute joint to create an anchor point between two bodies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The revolute joint sticks two bodies together with a common anchor point. The
    two bodies are then glued together and are only allowed to rotate based on the
    common anchor point. The left-hand side of the following screenshot shows that
    the two bodies are connected with an anchor. In our code example, we set the anchor
    point to be exactly the center point of the wheel. The right-hand side of the
    following screenshot shows how we set the joint. The wheel rotates because the
    rotation origin is at the center. This setup makes the car and wheels look real:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using a revolute joint to create an anchor point between two bodies](img/B04290_09_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'There are other types of joints that are useful in different ways. Joints are
    useful to create a game environment, and as there are several types of joints,
    each joint type is worth a try, and you should think about how to use them. The
    following link consists of the Box2D manual that explains each type of joint and
    how we can use them on different environment setups: [http://www.box2d.org/manual.html#_Toc258082974](http://www.box2d.org/manual.html#_Toc258082974).'
  prefs: []
  type: TYPE_NORMAL
- en: Adding force to the car with a keyboard input
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have the car ready now. Let's move it with our keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding force to the car
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to take the keyboard input:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `box2dcargame.js` JavaScript file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the page loaded event handler, we add the following `keydown` event handler
    at the beginning of the code. This listens to the right arrow key and the left
    arrow key to apply force in different directions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We have added forces to bodies. We need to clear forces in each step, otherwise
    the force accumulates:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the files and run our game in the browser. When you press the *arrow* keys,
    the car starts moving. If you keep pressing the key, the world will keep adding
    force to the car and make it speed away:![Time for action – adding force to the
    car](img/B04290_09_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created an interaction with our car body. We can move the car left and
    right by pressing the arrow keys. It seems like the game is getting interesting
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Applying force to a body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can apply force to any body by calling the `ApplyForce` function in that
    body. The following code shows the usage of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This function takes two arguments, which are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Argument | Type | Discussion |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `force` | `b2Vec2` | This is the force vector to apply to the body |'
  prefs: []
  type: TYPE_TB
- en: '| `point` | `b2Vec2` | This is the point where the force is applied |'
  prefs: []
  type: TYPE_TB
- en: Clearing Force
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After we apply the force to bodies, the force would constantly apply to that
    body until we clear it. In most cases, we clear the force after each step.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the difference between ApplyForce and ApplyImpulse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Besides the `ApplyForce` function, we can also move any body by using the `ApplyImpulse`
    function. Both functions move the body, but they move them using a different approach.
    If we want to change the instance velocity of a body, then we use `ApplyImpulse`
    once on the body to change its velocity to meet our target value. On the other
    hand, we need to constantly apply force to a body to increase the speed.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we want to increase the velocity of the car, similar to like
    stepping on the pedal, we need to apply force to the car. If we are creating a
    ball game in which we need to kick-start the ball, we may use the `ApplyImpulse`
    function to add an instance impulse to the ball's body.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Can you think about a different situation where we will need to apply force
    or impulse to the body?
  prefs: []
  type: TYPE_NORMAL
- en: Adding ramps to our game environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we can move the car. However, the environment is not interesting enough
    to play. Imagine now there are some ramps for the car to jump, and there is a
    gap between two platforms over which a player has to fly the car. It will become
    more interesting to play with different ramp setups.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – creating the world with ramps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to create a ramp in the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: We open the game logic JavaScript file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `createGround` function, we update the function to take four arguments.
    The changed code is highlighted as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have a function to create the ground body. We will now replace the
    ground creation code in the page loaded handler function with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file and preview the game in a browser. We should now see a ramp and
    a destination platform, as shown in the following screenshot. Try to control the
    car by making it jump over the ramp to reach the destination without falling down.
    Refresh the page to restart the game if you fail:![Time for action – creating
    the world with ramps](img/B04290_09_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just wrapped the ground box creating code with a function so that we can
    easily create a combination of ground bodies. These ground bodies composite the
    level environment of the game.
  prefs: []
  type: TYPE_NORMAL
- en: In addition, this is the first time we are rotating a body. We set the rotation
    of the body by using the `rotation` property which takes a value in radians. By
    setting the rotation of a box, we can have a ramp with a varying slope setup in
    our game.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have set up a ramp now, and we can play with the car within the environment.
    How about using different kinds of joints to set up the playground? For example,
    how about a pulley joint to act as a lift? On the other hand, how about including
    a dynamic board with a joint at the center?
  prefs: []
  type: TYPE_NORMAL
- en: Checking collisions in the Box2D world
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Box2D physics library calculates all collisions automatically. Imagine now
    that we set up a ground body as the destination. Players win when they successfully
    move the car to hit the destination. As Box2D already calculates all collisions,
    all we have to do is get the detected collision list and determine whether our
    car has hit the destination ground.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – checking a collision between the car and the destination body
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to handle collision:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we start from our game logic. Open the `box2dcargame.js` JavaScript file
    in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We set up a destination ground in the ground creation code and assign it to
    our `gamewinWall` reference inside the `carGame` global object instance as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we move on to the `step` function. In each step, we get the complete
    contact list from the world and check whether any two colliding objects are the
    car and the destination ground:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When we call our game loop function, `updateWorld`, we call our newly-created
    collision checking function.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now save the code and open the game in a browser again. This time, we
    have to open the console window to track whether we get the **Level** **Passed!**
    output when the car hits the wall. Try to finish the game, and we should see the
    output in the console once the car hits the destination:![Time for action – checking
    a collision between the car and the destination body](img/B04290_09_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created the game winning logic by checking the collision contacts. The
    player wins when the car successfully reaches the destination ground object.
  prefs: []
  type: TYPE_NORMAL
- en: Getting the collision contact list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In each step, Box2D calculates all collisions and puts them into a **contact**
    **list** in the `world` instance. We can get the contact list by using the `carGame.world.GetContactList()`
    function. The returned contact list is a **link** **list**. We can travel through
    the entire link list by using the following `for` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: When we get the collided shapes, we check whether the body of that shape is
    a car or the destination body. As the car shape may be in fixture 1 or fixture
    2, and the same applies to `gamewinWall`, we need to check both the combinations.
    The additional `isTouching` function provides a more accurate collision-checking
    between the fixtures.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We created a game over dialog in [Chapter 7](ch07.html "Chapter 7. Saving the
    Game's Progress"), *Saving the Game's Progress*. How about using that technique
    here to create a dialog showing the player passed the level when they hit the
    winning wall? This will also be useful as a level transition later when we add
    different level setups to the game.
  prefs: []
  type: TYPE_NORMAL
- en: Restarting the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You may have already tried refreshing the page several times in the last example
    to make the car successfully jump to the destination. Imagine now if we could
    press a key to reinitialize the world. Then, we can follow the trial-and-error
    method until success.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – restarting the game while pressing the R key
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will assign the *R* key as the restart key for our game. Now, let''s perform
    the following set of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Again, we only need to change the JavaScript file. Open the `box2dcargame.js`
    JavaScript file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need a function to remove all the bodies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We move the create world, ramp, and the car code into a function named `restartGame`.
    They were originally in the page loaded handler function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, in the `initGame` function, we call the `restartGame` function to initialize
    the game as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we add the following highlighted code to the `keydown` handler to
    restart the game when the *R* key is pressed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'How about restarting the game when the player passes the level? To do this,
    add the following highlighted code inside the logic where we checked the collision
    between the car and the winning flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is time to test the game in a browser. Try playing the game and press the
    *R* key to restart the game.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We refractored our code to create a `restartGame` function. The world is destroyed
    and initialized again each time we call this function. We can destroy the existing
    world and create a new empty one by creating a new world instance of our world
    variable as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now the only way to restart the game is by pressing the restart key. How about
    creating a ground at the bottom of the world that checks for any falling cars?
    When the car drops and hits the bottom ground, we know that the player has failed
    and then they can restart the game.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a level support to our car game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine now that we can level up to the next environment setup after finishing
    each game. We will need several environment setups for each level.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – loading the game with levels data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will refractor our code to support the loading of static ground bodies from
    a levels data structure. Let''s work on it by carrying out the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `box2dcargame.js` JavaScript file in a text editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will need each ground setup on each level. Put the following code at the
    top of the JavaScript file. It is an array of levels. Each level is another array
    of objects with the position, dimension, and rotation of the static ground body:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `restartGame` function with the following code. This changes the
    function to accept a `level` argument. Then, create the ground or car by the level
    data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the page loaded handler function, change the `restartGame` function called
    by providing `currentLevel` as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We also need to provide the `currentLevel` value in the restart key handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Lastly, change the following highlighted code in the game''s win logic. We
    move a level up in the game when the car hits the destination:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now run the game in the web browser. Finish the level and the game should
    restart at the next level:![Time for action – loading the game with levels data](img/B04290_09_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We just created a data structure to store the levels. Then, we created the game
    with the given level number and constructed the world with the level data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Each level data is an array of objects. Each object contains properties of
    each ground body in the world. This includes basic properties such as position,
    size, and rotation. There is also a property named `type`. It defines whether
    the body is a normal box body, car data, or the destination winning ground:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'When creating the world, we use the following code to loop through all objects
    in the level array. We then create the car and ground bodies and reference the
    game winning ground according to the type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we have several levels setup for our game. How about duplicating the level
    data to create more interesting levels to play? Create your own levels and play
    with them. It is just like how a kid builds blocks and plays with them.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the Box2D outline drawing with graphics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have created a game that is at least playable with several levels. However,
    they are just some outline boxes. We cannot even distinguish between the destination
    body and other ground bodies in the game. Imagine now that the destination is
    a racing flag and there is a car graphic to represent it. This will make the game's
    purpose clearer.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding a flag graphic and a car graphic to the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to draw two graphics on our physics objects:'
  prefs: []
  type: TYPE_NORMAL
- en: We will first download the graphics we need for this example. To download the
    graphics, go to [http://mak.la/book-assets](http://mak.la/book-assets).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Put the image files for this chapter in the `images` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, it is time to edit the `index.html` file. Add the following HTML markup
    to the `body` section:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We want to hide the asset DIV that contains our `img` tags. Open the `cargame.css`
    file and add the following CSS rule to keep the asset DIV out of our sight:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We will now move on to the logic part. Open the `box2dcargame.js` JavaScript
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `restartGame` function, add the highlighted code to assign the reference
    of the `flag` image to the winning destination flag:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, assign the reference of the `bus` image tag to the user data in the car
    shape. Add the following highlighted code to the car box definition creation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: We used to get the reference of an element by the jQuery `$(selector)` method.
    The jQuery selector returns an array of the element objects with additional jQuery
    data wrapped. If we want to get the original document element reference, then
    we can either use the `document.getElementById` method or `$(selector).get(0)`.
    As `$(selector)` returns an array, `get(0)` gives the first original document
    element in the list
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then, we need to handle the wheels. We assign the `wheel` image tag to the wheel
    body's `userData` property. Add the following highlighted code to the `createWheel`
    function
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We have to draw the images in the canvas. Create a new `drawWorld` function
    in the `box2dcargame.js` file with the following code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, call the `drawWorld` function in the `updateWorld` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all files and run the game in a web browser. We should see a yellow bus
    graphic, two wheels, and a flag as the destination. Play the game now and the
    game should move on to the next level when the bus hits the flag:![Time for action
    – adding a flag graphic and a car graphic to the game](img/B04290_09_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are now presenting our game with minimal graphics. At least, players easily
    know what they are controlling and where they should go.
  prefs: []
  type: TYPE_NORMAL
- en: The Box2D library uses a canvas to render the physics world. Therefore, all
    techniques that we learned about a canvas can be applied here. In [Chapter 5](ch05.html
    "Chapter 5. Building a Canvas Game's Masterclass"), *Building a Canvas Game's
    Masterclass*, we learned the use of the `drawImage` function to display an image
    in the canvas. We used this technique to draw the flag graphic in the canvas of
    the physics world.
  prefs: []
  type: TYPE_NORMAL
- en: Using userData in shape and body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How do we know which physics body needs to be displayed as the flag image? There
    is a property named `userData` in every Box2D shape and body. This property is
    used to store any custom data related to that shape or body. For example, we may
    store the filename of the graphic file or just directly store the reference to
    the image tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have a list of image tags referencing the graphic assets that we need in
    the game. However, we do not want to display the image tags—they are just for
    the purpose of loading and referencing. We hide the asset image tags by setting
    their position out of the HTML bound with the following CSS style. We do not use
    `display:none` because we cannot get the width and height of the element that
    is not displayed at all. We need the width and height to position graphics correctly
    in the physics world:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Drawing graphics in every frame according to the state of its physics body
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The drawing from Box2D is just for development use before we replace it with
    our graphics.
  prefs: []
  type: TYPE_NORMAL
- en: The following code checks whether the shape has user data assigned to it. In
    our example, the user data is used to reference the `image` tag of a graphics
    asset. We get the `image` tag and pass it to the Canvas context `drawImage` function
    to draw.
  prefs: []
  type: TYPE_NORMAL
- en: 'All box and circle shapes in Box2D have the origin point at the center. However,
    the image drawing in the canvas needs the top-left point. Therefore, we have both
    *x* and *y* coordinates and offset of top-left *x* and *y* points, which is a
    negative half width and height of the image:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Rotating and translating an image in the canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We used the `drawImage` function to draw an image directly with the coordinates.
    However, the situation is different here. We need to rotate the drawn image. This
    is done by rotating the context before drawing and then restoring the rotation
    afterwards. We can do this by saving the context state, translating it, rotating
    it, and then calling the `restore` function. The following code shows how we draw
    an image at a given position and rotation. The `topleftX` and `topleftY` are the
    offset distances from the image''s center origin to the top-left point:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We do not need to make the physics body area exactly the same as its graphics.
    For example, if we have a round circular chicken, we can represent it in the physics
    world by just a ball body. Using a simple physics body can improve the performance
    a lot.
  prefs: []
  type: TYPE_NORMAL
- en: Have a go hero
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have learned using CSS3 transitions to animate a scoreboard. How about applying
    it to this car game? Moreover, how about adding some engine sounds to the car?
    Just try applying what we have learned throughout this book to give players a
    complete game experience.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a final touch to make the game fun to play
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Imagine now that we want to publish the game. The game logic is basically there,
    but it looks quite ugly with the black and white environment. In this section,
    we will add some final touches to the game so that it is much more attractive.
    We will also apply some constraints to limit the time of `ApplyForce`. This constraint
    makes the game more fun because it requires a player to think before he applies
    too much force to the car.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – decorating the game and adding a fuel limitation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to turn our debug draw into a rich graphical
    game:'
  prefs: []
  type: TYPE_NORMAL
- en: First, we need some background images for the starting screen, game winning
    screen, and environment backgrounds for each level. These graphics can be found
    from the code bundle named `box2d_final_game`. The following screenshot shows
    the graphics that we need in this section:![Time for action – decorating the game
    and adding a fuel limitation](img/B04290_09_16.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open the `index.html` file and replace the canvas element with the following
    markup. This creates two more game components named `current level` and `fuel`
    `remaining`, and it groups the game components into a `game-container` DIV:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we will copy the `cargame.css` file from the code bundle. This contains
    several class-style definitions for the game. The game should look similar to
    the one shown in the following screenshot after we have applied the new stylesheet:![Time
    for action – decorating the game and adding a fuel limitation](img/B04290_09_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we will move on to the JavaScript part. Open the `html5games.box2dcargame.js`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the `carGame` object declaration with the following additional variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we have the starting screen. Instead of starting the game once, the page
    is loaded. We''ll display the starting screen and wait for the player to click
    on the game canvas. Add the following logic to the `initGame` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we need to handle the game-winning screen when the player passes all
    levels. In the winning flag-collision-checking logic, we use the following logic
    to determine if we show the next level or the ending screen. Find the `console.log("Level
    Passed!");` code in the file and replace the `restartGame` function call with
    the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we will handle the game playing background. We prepared each game background
    for each level setting. We will switch the background in the `restartGame` function,
    which corresponds to reconstructing the world:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With the game graphics now, we do not need the physics object outline drawing
    any more. We can turn off the debug drawing by setting the `shouldDrawDebug` object
    to `false`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's add some constraints. Remember that in our level data, we include
    a mystery fuel data for the car. This is an indicator of how much fuel the car
    contains. We will use this fuel to limit the player's input. The fuel reduces
    each time a force is applied to the car. The player cannot apply any additional
    force once the fuel runs out. This limitation makes the game more fun to play.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update the arrow keys'' `keydown` function with the following logic. The new
    code is highlighted here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In addition, in the car-creating logic in the restart game function, we initialize
    the fuel as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, run the game in a browser. We should get five graphic levels. The following
    screenshot shows how the last four levels look:![Time for action – decorating
    the game and adding a fuel limitation](img/B04290_09_18.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After passing all the levels, we will get the following winning screen:![Time
    for action – decorating the game and adding a fuel limitation](img/B04290_09_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just decorated our game with more graphics. We also drew each level environment,
    a background image. The following screenshot illustrates how the visual ground
    represents the logical physics boxes. Unlike the car and the winning flag, the
    ground graphics are not associated with the physics ground. This is just a background
    image with the graphics in their respective positions. We can use this approach
    because those logical boxes will never move:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_09_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'We can then prepare several CSS styles for each level with the level number
    in the class name, such as `.gamebg-level1` and `.gamebg-level2`. With each class
    linked with each level background, we can change the background when switching
    a level using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Adding fuel to add a constraint when applying force
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we limit the player''s input by providing limited fuel to use. The fuel
    decreases when players apply force to the car. We used the following `keydown`
    logic to decrease the fuel and prevent additional force when the car is running
    out of fuel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: Presenting the remaining fuel in a CSS3 progress bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In our game, we present the remaining fuel as a progress bar. The progress
    bar is actually a DIV inside another DIV. The following markup shows the structure
    of the progress bar. The outer DIV defines the maximum value and the inner DIV
    shows the actual value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot illustrates the structure of the progress bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Presenting the remaining fuel in a CSS3 progress bar](img/B04290_09_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'With this structure, we can show specific progress by setting the width as
    a percentage value. We use the following code to update the progress bar according
    to the percentage of the fuel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: This is the basic logic to set up a progress bar and control it with the width
    style.
  prefs: []
  type: TYPE_NORMAL
- en: Adding touch support for tablets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We added touch support in [Chapter 6](ch06.html "Chapter 6. Adding Sound Effects
    to Your Games"), *Adding Sound Effects to Your Games*. In this game, we will add
    touch support to make it playable on tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Time for action – adding touch support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Carry out the following steps to make our game work in a tablet with touch
    inputs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `index.html` file, we add the following touch controls before the end of
    the `#game-container`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can also add a `<meta>` tag inside the `<head>` tag to control the viewport
    to fit the game into the iPad's 1024 px width.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For these controls, we add some basic styles to position them. To do this,
    append the following code to the `cargame.css` file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we move to the `box2dcargame.js` file, and we add a function named `handleTouchInputs()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We call our `handleTouchInputs` function within the `initGame` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We apply the force continuously until the touch up event. We can slightly adjust
    the value to fit the tablet. To do this, add the following code at the end of
    the existing `updateWorld` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save all the files and run the game in a tablet, say an iPad or an Android,
    and we should be able to control the car by pressing the left and right sides
    of the game. We can also restart the level by pressing the restart button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*What just happened?*'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just added touch support to our game to make it playable on a tablet. We
    created two touch areas for the left and right force. We also created a restart
    button that''s only viewable on touch devices:'
  prefs: []
  type: TYPE_NORMAL
- en: '![What just happened?](img/B04290_09_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We listen to the `touchstart` and `touchend` event on these buttons. The `touchstart`
    event is not like the `keydown` event that keeps firing the events. We need a
    Boolean to know whether the touch has started and keep a track until it ends.
    During touch pressing, we apply the forces in the `updateWorld` method. The frequency
    is different, so we adjusted the value of force and fuel consumption to make it
    work better in tablets.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the viewport scale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When designing mobile web pages, we often use viewport to tell the browser
    to use the device width as the web page''s view port width:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: In games, especially games that require tapping frequently, we may want to fix
    the zooming feature by setting the same value to the minimum scale and the maximum
    scale. Moreover, we can control the scale value to zoom the game to fit the tablet
    devices.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: Touch-specific buttons
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'There is no keyboard on tablet and mobile devices. We have to create on-screen
    inputs for these devices. We created three on-screen buttons in this game example:
    left, right and restart buttons. We hid these buttons in the desktop by checking
    the availability of `window.Touch`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You learned a lot in this chapter about using the Box2D physics engine to create
    a car adventure game in canvas.
  prefs: []
  type: TYPE_NORMAL
- en: Specifically, we set up the game with the JavaScript physics engine. Then, we
    created static and dynamic bodies in the physics world. We set up the car by using
    joints to constrain bodies and wheels. We controlled the car with keyboard inputs
    by adding force to it. At last, we determined game-over and level-up by adding
    collisions in the physics world. We have now learned how to use the Box2D physics
    library to create a canvas-based physics game.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to discuss different distribution channels
    and put our game into a native Mac application.
  prefs: []
  type: TYPE_NORMAL
