- en: Chapter 9. Building a Physics Car Game with Box2D and Canvas
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 9 章. 使用 Box2D 和 Canvas 构建物理赛车游戏
- en: '*2D Physics Engines is a hot topic in game development. With the help of a
    physics engine, we can easily create a playable game by just defining an environment
    and a simple rule. Taking existing games as examples, players in the Angry Birds
    game fly birds to destroy the enemy''s castle. In Cut the Rope, candy drops into
    the monster''s mouth to progress to the next level.*'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '*2D 物理引擎是游戏开发中的热门话题。借助物理引擎，我们只需定义环境和简单规则，就能轻松创建一个可玩的游戏。以现有游戏为例，在愤怒的小鸟游戏中，玩家操控小鸟摧毁敌人的城堡。在割绳子游戏中，糖果掉入怪物的嘴里，以进入下一关。*'
- en: 'In this chapter, we will learn the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下主题：
- en: Installing the Box2D JavaScript library
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安装 Box2D JavaScript 库
- en: Creating a static ground body in the physics world
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物理世界中创建静态地面体
- en: Drawing the physics world on the Canvas
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在画布上绘制物理世界
- en: Creating a dynamic box in the physics world
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在物理世界中创建动态盒子
- en: Advancing the world time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前进世界时间
- en: Adding wheels to the game
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为游戏添加轮子
- en: Creating the physics car
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建物理赛车
- en: Adding force to the car with a keyboard input
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用键盘输入给汽车添加力
- en: Checking a collision in the Box2D world
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Box2D 世界中检查碰撞
- en: Adding level support to our car game
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的赛车游戏添加关卡支持
- en: Replacing the Box2D outline drawing with graphics
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用图形替换 Box2D 轮廓绘制
- en: Adding a final touch to make the game fun to play
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加最终细节，使游戏更有趣
- en: 'The following screenshot shows what we will get by the end of this chapter;
    it is a car game in which a player moves the car towards the destination point:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了本章结束时我们将得到的结果；这是一个玩家将汽车移动到目标点的赛车游戏：
- en: '![Building a Physics Car Game with Box2D and Canvas](img/B04290_09_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![使用 Box2D 和 Canvas 构建物理赛车游戏](img/B04290_09_01.jpg)'
- en: You can also play the game at [http://makzan.net/html5-games/car-game/](http://makzan.net/html5-games/car-game/)
    to get a glimpse of the final result.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在 [http://makzan.net/html5-games/car-game/](http://makzan.net/html5-games/car-game/)
    上玩游戏，以一窥最终结果。
- en: So, let's get on with it.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: Installing the Box2D JavaScript library
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Box2D JavaScript 库
- en: Now, suppose that we want to create a car game. We apply force to the car to
    make it move forward. The car moves on a ramp and then flies through the air.
    Afterwards, the car falls on the destination ramp and the game finishes. Every
    collision in every part of the physics world counts on this movement. If we have
    to make this game from scratch, then we have to calculate at least the velocity
    and angle of each part. Luckily, the physics library helps us to handle all these
    physical problems. All we have to do is to create the physics model and present
    it in the canvas. The engine we use is Box2D.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设我们想要创建一个赛车游戏。我们给汽车施加力使其向前移动。汽车在斜坡上移动，然后飞入空中。之后，汽车落在目标斜坡上，游戏结束。物理世界的每个部分的碰撞都影响着这个运动。如果我们必须从头开始制作这个游戏，那么我们必须至少计算每个部分的速率和角度。幸运的是，物理库帮助我们处理所有这些物理问题。我们只需要创建物理模型并在画布上展示它。我们使用的引擎是
    Box2D。
- en: Box2D is a 2D physics simulation engine. The original Box2D was written in C
    by Erin Catto. It was later ported to Flash ActionScript. Later on, its 2.1a version
    was ported to JavaScript. You can find the JavaScript version of Box2D 2.1a in
    their Google Code project at [https://code.google.com/p/box2dweb/](https://code.google.com/p/box2dweb/).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D 是一个 2D 物理仿真引擎。原始的 Box2D 是由 Erin Catto 用 C 语言编写的。后来被移植到 Flash ActionScript。后来，其
    2.1a 版本被移植到 JavaScript。你可以在他们的 Google Code 项目中找到 Box2D 2.1a 的 JavaScript 版本，网址为
    [https://code.google.com/p/box2dweb/](https://code.google.com/p/box2dweb/)。
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: At the time of writing this book, Google Code announced that they would close
    down in 2016\. I have forked the library into a URL ([https://github.com/makzan/Box2DWeb-Fork](https://github.com/makzan/Box2DWeb-Fork))
    in case the original repository is not accessible.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在撰写本书时，Google Code 宣布他们将在 2016 年关闭。为了以防原始仓库不可访问，我已经将该库分叉到一个 URL ([https://github.com/makzan/Box2DWeb-Fork](https://github.com/makzan/Box2DWeb-Fork))。
- en: Time for action – installing the Box2D physics library
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 安装 Box2D 物理库
- en: 'We will set up the Box2D library. We must carry out the following steps to
    prepare our project:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将设置 Box2D 库。我们必须执行以下步骤来准备我们的项目：
- en: First, let's set up our game project. Create a folder with the following file
    structure. The HTML file contains an HTML template with empty content and includes
    all the scripts and style files. You may find the full document's source in the
    code bundle. Please also download the Box2D source file into the `js` folder.![Time
    for action – installing the Box2D physics library](img/B04290_09_21.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们设置我们的游戏项目。创建一个具有以下文件结构的文件夹。HTML 文件包含一个带有空内容的 HTML 模板，并包含所有脚本和样式文件。您可以在代码包中找到完整文档的源代码。请还将
    Box2D 源文件下载到 `js` 文件夹中。![是时候安装 Box2D 物理库了](img/B04290_09_21.jpg)
- en: 'In the HTML body, we must define a canvas, as follows:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 HTML 主体中，我们必须定义一个画布，如下所示：
- en: '[PRE0]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We must then alias several Box2D classes that we will use in our game; this
    makes it easier to refer them in the code:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须然后为我们将要在游戏中使用的几个 Box2D 类别设置别名；这使得在代码中引用它们更容易：
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, we will create an empty world to test our Box2D library installation.
    Open the `box2dcargame.js` JavaScript file and put the following code in the file
    to create the world:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将创建一个空的世界来测试我们的 Box2D 库安装。打开 `box2dcargame.js` JavaScript 文件，并在文件中放入以下代码以创建世界：
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Open the `index.html` file in a web browser. We should see a grey canvas with
    nothing there.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在网页浏览器中打开 `index.html` 文件。我们应该看到一个没有任何内容的灰色画布。
- en: 'We have not presented the physics world to the canvas yet. This is why we only
    see a blank canvas on the page. However, we have printed the newly created world
    in the console log. The following screenshot shows the console tracing the world
    object with many properties beginning with `m_`. These are the physical states
    of the world:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有将物理世界呈现到画布上。这就是为什么我们在页面上只看到一个空白的画布。然而，我们在控制台日志中打印了新创建的世界。以下截图显示了控制台跟踪具有以
    `m_` 开头的许多属性的世界对象。这些都是世界的物理状态：
- en: '![Time for action – installing the Box2D physics library](img/B04290_09_02.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![是时候安装 Box2D 物理库了](img/B04290_09_02.jpg)'
- en: '*What just happened?*'
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: We have just installed the Box2D JavaScript library and created an empty world
    to test the installation.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚安装了 Box2D JavaScript 库并创建了一个空的世界来测试安装。
- en: Using b2World to create a new world
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 b2World 创建一个新的世界
- en: 'The `b2World` class is a core class in the Box2D environment. All our physics
    bodies, including the ground and car, are created in this world. The following
    code shows us how to create a world:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`b2World` 类是 Box2D 环境中的核心类。我们所有的物理体，包括地面和汽车，都是在该世界中创建的。以下代码显示了如何创建一个世界：'
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The `b2World` class takes two arguments to initialize, which are listed in
    the following table with their description:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '`b2World` 类初始化时需要两个参数，如下表所示，包括它们的描述：'
- en: '| Argument | Type | Discussion |'
  id: totrans-42
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `gravity` | b2Vec2 | This represents the gravity of the world |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| `gravity` | b2Vec2 | 这代表了世界的重力 |'
- en: '| `doSleep` | Bool | This defines whether the world ignores slept objects or
    not |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| `doSleep` | Bool | 这定义了世界是否忽略休眠对象 |'
- en: Setting the gravity of the world
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置世界的重力
- en: 'We have to define the gravity of the world. The gravity is defined by `b2Vec2`.
    The `b2Vec2` class is a vector of *x* and *y* axes. Therefore, the following code
    defines gravity with 10 units downwards:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须定义世界的重力。重力由 `b2Vec2` 定义。`b2Vec2` 类是一个 *x* 和 *y* 轴的向量。因此，以下代码使用 10 个单位向下定义了重力：
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Setting Box2D to ignore the sleeping object
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将 Box2D 设置为忽略休眠对象
- en: A sleeping body is a dynamic body that skips simulation until it wakes up. The
    physics library calculates the mathematical data and collision of all the bodies
    in the world. The performance will slow down when there are too many bodies in
    the world to get calculated in every frame. When a sleeping body collides with
    another object, it will wake up and then turn back to sleeping mode again until
    the next collision.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 休眠体是一个动态体，它跳过模拟直到它醒来。物理库计算世界中所有体的数学数据和碰撞。当世界中存在太多体需要每帧计算时，性能会变慢。当一个休眠体与另一个对象碰撞时，它会醒来，然后再次进入休眠模式，直到下一次碰撞。
- en: Creating a static ground body in the physics world
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在物理世界中创建一个静态地面体
- en: The world is empty now. If we are going to place objects there, the objects
    will fall and finally leave our sight. Now, suppose we want to create a static
    ground body in the world so that objects can stand on it. We can do this in Box2D.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 世界现在是空的。如果我们要在那里放置对象，对象将会落下并最终离开我们的视线。现在，假设我们想在世界上创建一个静态地面体，以便对象可以站在上面。我们可以在
    Box2D 中做到这一点。
- en: Time for action – creating a ground in the world
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候创建世界中的地面了
- en: 'Carry out the following steps to create a static ground:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤创建静态地面：
- en: Open the `box2dcargame.js` JavaScript file.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`box2dcargame.js` JavaScript 文件。
- en: 'Define the following `pxPerMeter` variable in the file; this is the unit setting
    in the Box2D world:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件中定义以下`pxPerMeter`变量；这是 Box2D 世界中的单位设置：
- en: '[PRE5]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Add the following function to the end of the JavaScript file; this creates
    a fixed body as the playground:'
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下函数添加到 JavaScript 文件的末尾；这创建了一个固定体作为游乐场：
- en: '[PRE6]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Call the `createGround` function in the `initGame` function after we have created
    the world as follows:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建世界后，在`initGame`函数中调用`createGround`函数，如下所示：
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: As we are still defining the logic and have not yet presented the physics world
    visually, we will see nothing if we open the browser. However, it is worth getting
    into the habit of trying it and inspecting the console window for an error message
    if there is any.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们仍在定义逻辑并且尚未以视觉方式展示物理世界，如果我们打开浏览器，我们将看不到任何东西。然而，养成尝试并检查控制台窗口以查找错误消息的习惯是值得的。
- en: '*What just happened?*'
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have created a ground body with the shape and body definitions. This is a
    common process that we will use a lot to create different kinds of physical bodies
    in the world. So, let's get into the details of how we made it.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经使用形状和体定义创建了一个地面体。这是一个常见的流程，我们将经常使用它来在世界上创建不同类型的物理体。所以，让我们深入了解我们是如何做到这一点的。
- en: Pixel per meter
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 像素每米
- en: The size and position unit in Box2D is calculated in meters. We use pixels in
    screen. Therefore, we define a variable that converts a unit between meters and
    screen pixels. We set the value to 30, which indicates that 30 pixels equal to
    1 meter. You can explore different values for your physics world.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Box2D 中，大小和位置单位以米计算。我们在屏幕上使用像素。因此，我们定义了一个变量来转换米和屏幕像素之间的单位。我们将值设置为 30，这意味着
    30 像素等于 1 米。你可以探索你物理世界中的不同值。
- en: We should not use 1 pixel to 1 meter, otherwise our object would become very
    large in the Box2D scale. Imagine we have a car with 100 px width, it will become
    100 meters long, which is not realistic at all. By defining 30 px/meter, or any
    reasonable value, an object with width 100 px on screen will be about 3.33 meters
    long in simulation, which Box2D can handle well. For more details, please refer
    to the Box2D manual section 1.7 at [http://www.box2d.org/manual.html](http://www.box2d.org/manual.html).
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不应该使用 1 像素等于 1 米，否则我们的对象在 Box2D 规模下会变得非常大。想象一下，我们有一辆宽度为 100 px 的汽车，它将变成 100
    米长，这完全不现实。通过定义 30 px/meter 或任何合理的值，屏幕上宽度为 100 px 的对象在模拟中大约是 3.33 米长，这是 Box2D 可以很好地处理的。更多详情，请参阅
    Box2D 手册第 1.7 节，[http://www.box2d.org/manual.html](http://www.box2d.org/manual.html)。
- en: Creating a shape with a fixture
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用夹具创建形状
- en: 'A fixture contains the physics properties and its shape. The physics properties
    define density, friction, and restitution, where restitution is basically the
    bounciness of the object. A shape defines the geometrical data. The shape can
    be a circle, rectangle, or a polygon. The following code that we used in the preceding
    example defines a box shape definition. The `SetAsBox` function takes two arguments:
    half width and half height. It is a half value, so the final area of the shape
    is four times the value:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 夹具包含物理属性及其形状。物理属性定义密度、摩擦和恢复，其中恢复基本上是物体的弹性。形状定义了几何数据。形状可以是圆形、矩形或多边形。我们之前示例中使用的以下代码定义了一个箱形形状定义。`SetAsBox`函数接受两个参数：半宽和半高。这是一个半值，所以形状的最终面积是值的四倍：
- en: '[PRE8]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Creating a body
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建一个体
- en: 'After defining the fixture, we can then create a body definition with the given
    shape definition. Then, we set the initial position of the body and finally ask
    the world instance to create a body from our body definition. The following code
    shows how we create a body in the world with the given shape definition:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在定义了夹具之后，我们就可以使用给定的形状定义创建一个体定义。然后，我们设置体的初始位置，最后请求世界实例根据我们的体定义创建一个体。以下代码展示了如何使用给定的形状定义在世界中创建一个体：
- en: '[PRE9]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: A body can be either a static body or a dynamic body. Static bodies are immovable
    and will not have collisions with other static bodies. Therefore, these bodies
    can be used as the ground or walls to become the level environment. On the other
    hand, a dynamic body will move following a collision with other bodies (static
    or dynamic) and due to gravity. We will create a dynamic box body later.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一个物体可以是静态物体或动态物体。静态物体是不可移动的，并且不会与其他静态物体发生碰撞。因此，这些物体可以用作地面或墙壁，成为关卡环境。另一方面，动态物体会根据与其他物体（静态或动态）的碰撞以及重力而移动。我们将在后面创建一个动态箱子体。
- en: Setting the bouncing effect with the restitution property
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用恢复系数属性设置弹跳效果
- en: The restitution value is between 0 and 1\. In our case, the box is falling on
    the ground. When the restitution value is 0 on both the ground and the box, the
    box does not bounce at all. When either the box or the ground has a restitution
    value of 1, the collision is perfectly elastic.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 恢复系数的值在0到1之间。在我们的例子中，箱子正落在地面上。当地面和箱子上的恢复系数都是0时，箱子根本不会弹跳。当箱子或地面有一个恢复系数为1时，碰撞是完全弹性的。
- en: Tip
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: When two bodies collide, the restitution value of that collision is the maximum
    value between both restitution values of both the bodies. Therefore, if a box
    with a restitution value of 0.4 drops on the ground with a restitution value of
    0.6, this collision will use 0.6 to calculate the bouncing velocity.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个物体相撞时，该碰撞的恢复系数是两个物体各自恢复系数的最大值。因此，如果一个恢复系数为0.4的箱子掉在恢复系数为0.6的地面上，这个碰撞将使用0.6来计算弹跳速度。
- en: Drawing the physics world in the canvas
  id: totrans-79
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在画布中绘制物理世界
- en: We have created the ground, but it is only in the mathematics model. We do not
    see anything in the canvas because we have not drawn anything on it yet. In order
    to show what the physics looks like, we have to draw something according to the
    physics world.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经创建了地面，但它只存在于数学模型中。我们在画布上没有看到任何东西，因为我们还没有在上面绘制任何东西。为了展示物理的样子，我们必须根据物理世界绘制一些东西。
- en: Time for action – drawing the physics world into the Canvas
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 是时候将物理世界绘制到画布上了
- en: 'Carry out the following steps to draw the useful debug view:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以绘制有用的调试视图：
- en: 'First, open the `box2dcargame.js` JavaScript file:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，打开`box2dcargame.js` JavaScript 文件：
- en: '[PRE10]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a function that draws the debugging lines:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个绘制调试线的函数：
- en: '[PRE11]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add a `showDebugDraw` function call at the end of the `initGame` method:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`initGame`方法的末尾添加`showDebugDraw`函数调用：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Now, reopen the game in a browser, and we should see the outline of the ground
    body in the canvas, as shown in the following screenshot:![Time for action – drawing
    the physics world into the Canvas](img/B04290_09_03.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中重新打开游戏，我们应该在画布中看到地体的轮廓，如下面的截图所示：![是时候将物理世界绘制到画布上了](img/B04290_09_03.jpg)
- en: '*What just happened?*'
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We have just defined a method that asks the Box2D engine to draw the physics
    bodies in a canvas. This is useful for debugging before we successfully add our
    own graphics. We can set what to display via the `SetFlags` method.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚定义了一个方法，该方法要求 Box2D 引擎在画布中绘制物理体。在我们成功添加自己的图形之前，这对于调试很有用。我们可以通过`SetFlags`方法设置要显示的内容。
- en: The flags are bitwise variable. This means that each bit in the flag controls
    one drawing type. We combine the flag by using the bitwise operator or (`|`).
    For example, we show the shape and joint with the following code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 标志是位变量。这意味着标志中的每个位都控制一种绘制类型。我们通过使用位运算符或（`|`）组合标志。例如，我们使用以下代码显示形状和关节。
- en: '[PRE13]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'There are different types of debug drawings besides the shape and joint:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 除了形状和关节之外，还有不同类型的调试绘制：
- en: '| Bit flag | Discussion |'
  id: totrans-95
  prefs: []
  type: TYPE_TB
  zh: '| 位标志 | 讨论 |'
- en: '| --- | --- |'
  id: totrans-96
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '| `e_aabbBit` | This draws all the bounding boxes |'
  id: totrans-97
  prefs: []
  type: TYPE_TB
  zh: '| `e_aabbBit` | 这会绘制所有的边界框 |'
- en: '| `e_centerOfMassBit` | This draws the center of the mass |'
  id: totrans-98
  prefs: []
  type: TYPE_TB
  zh: '| `e_centerOfMassBit` | 这会绘制质心 |'
- en: '| `e_controllerBit` | This draws all the dynamics controllers |'
  id: totrans-99
  prefs: []
  type: TYPE_TB
  zh: '| `e_controllerBit` | 这会绘制所有的动态控制器 |'
- en: '| `e_jointBit` | This draws all the joint connections |'
  id: totrans-100
  prefs: []
  type: TYPE_TB
  zh: '| `e_jointBit` | 这会绘制所有的关节连接 |'
- en: '| `e_pairBit` | This draws the broad-phrase collision pairs |'
  id: totrans-101
  prefs: []
  type: TYPE_TB
  zh: '| `e_pairBit` | 这会绘制广泛的碰撞对 |'
- en: '| `e_shapeBit` | This draws all the shapes |'
  id: totrans-102
  prefs: []
  type: TYPE_TB
  zh: '| `e_shapeBit` | 这会绘制所有的形状 |'
- en: Creating a dynamic box in the physics world
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在物理世界中创建动态箱子
- en: Imagine now that we drop a box into the world. The box falls from the air and
    finally hits the ground. The box bounces up a little and finally lands on the
    ground. This is different from what we created in the last section. In the last
    section, we created a static ground, which was immovable and could not be affected
    by gravity. Now, we will create a dynamic box.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，我们将一个盒子放入世界中。盒子从空中落下，最终撞到地面。盒子弹起一点，最终再次落在地面上。这与我们在上一节中创建的不同。在上一节中，我们创建了一个静态地面，它是不可移动的，不能受到重力的影响。现在，我们将创建一个动态的盒子。
- en: Time for action – putting a dynamic box in the world
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 – 将动态盒子放入世界
- en: 'Carry out the following steps to create our first dynamic body:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建我们的第一个动态物体：
- en: 'Open our JavaScript file and add the following box creation code to the page
    loaded event handler. Place the code after the `createGround` function:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开我们的JavaScript文件，并将以下盒子创建代码添加到页面加载事件处理程序中。将代码放置在`createGround`函数之后：
- en: '[PRE14]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We need to call our newly created `createBox` function. Place the following
    code after we call the `createGround` function inside `initGame`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要调用我们新创建的`createBox`函数。在`initGame`中调用`createGround`函数之后放置以下代码。
- en: Now, we will test the physics world in a browser. You should see that a box
    is created at the given initial position. However, the box is not falling down;
    this is because we still have to do something to make it fall:![Time for action
    – putting a dynamic box in the world](img/B04290_09_04.jpg)
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将在浏览器中测试物理世界。你应该会看到在给定的初始位置创建了一个盒子。然而，盒子并没有掉下来；这是因为我们还需要做一些事情来让它掉下来：![动作时间
    – 将动态盒子放入世界](img/B04290_09_04.jpg)
- en: '*What just happened?*'
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just created a dynamic body in the world. In contrast to the ground body
    that is immovable, this box is affected by the gravity and the velocity changes
    during a collision. When a body contains a shape with any mass or density, it
    is a dynamic body. Otherwise, it is static. Therefore, we define a density to
    our box. Box2D will make it dynamic and calculate the mass according to the density
    and size of the body automatically.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚在世界上创建了一个动态物体。与不可移动的地面物体相比，这个盒子受到重力的影响，并且在碰撞期间速度会发生变化。当一个物体包含任何质量或密度的形状时，它就是一个动态物体。否则，它是静态的。因此，我们为盒子定义了一个密度。Box2D会使其成为动态的，并自动根据物体的密度和大小计算质量。
- en: Advancing the world time
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前进世界时间
- en: The box is dynamic but it does not fall down. Are we doing anything wrong here?
    The answer is no. We have set up the box correctly, but we forget to advance the
    time in the physics world.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 盒子是动态的，但它没有掉下来。我们在这里做错了什么吗？答案是：没有。我们已经正确设置了盒子，但我们忘记了在物理世界中前进时间。
- en: In the Box2D physics world, all calculations are done in a systematic iteration.
    The world calculates the physical transformation of all things according to the
    current step. When we move the `step` to the next level, the world calculates
    again as the new state.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在Box2D物理世界中，所有计算都是在系统迭代中完成的。世界根据当前步骤计算所有物体的物理变换。当我们移动`step`到下一个级别时，世界会根据新的状态再次计算。
- en: Time for action – setting up the world step loop
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动作时间 – 设置世界步骤循环
- en: 'We will make the world time advance by carrying out the following steps:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过执行以下步骤来使世界时间前进：
- en: 'In order to advance the world step, we have to call the `step` function in
    the world instance periodically. We used `setTimeout` to keep calling the `step`
    function. Put the following function in our JavaScript logic file:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了前进世界步骤，我们必须定期调用世界实例中的`step`函数。我们使用了`setTimeout`来持续调用`step`函数。将以下函数放入我们的JavaScript逻辑文件中：
- en: '[PRE15]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Next, we will set up an interval in the `initGame` method:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将在`initGame`方法中设置一个时间间隔：
- en: '[PRE16]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: We will again simulate the world in a browser. The box is created at the initialized
    position and falls on the ground correctly. The following screenshot shows the
    sequence of a box dropping on the ground:![Time for action – setting up the world
    step loop](img/B04290_09_05.jpg)
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在浏览器中再次模拟世界。盒子在初始化位置创建，并正确地落在地面上。以下截图显示了盒子掉落在地面上的序列：![动作时间 – 设置世界步骤循环](img/B04290_09_05.jpg)
- en: '*What just happened?*'
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We have advanced the time of the world. Now, the physics library simulates the
    world in a frequency of 60 times per second. In the game loop, we call the `Step`
    function to the Box2D world. The `Step` function simulates the physics world one
    step forward. During the step, the physics engine calculates everything that happens
    in the world, including forces and gravity.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经推进了世界的时间。现在，物理库以每秒 60 次的频率模拟世界。在游戏循环中，我们调用 `Step` 函数到 Box2D 世界。`Step` 函数模拟物理世界向前一步。在步骤中，物理引擎计算世界中发生的一切，包括力和重力。
- en: Adding wheels to the game
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向游戏中添加轮子
- en: Now, we have a box in the game. Imagine now we create two circular bodies as
    the wheels. Then, we will have the basic components of a car—the body and the
    wheels.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们在游戏中有一个盒子。想象一下，我们现在创建两个圆形体作为轮子。然后，我们将拥有汽车的基本组件——车身和轮子。
- en: Time for action – putting two circles in the world
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 在世界中放置两个圆形
- en: 'We will add two circles to the world by carrying out the following steps:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过以下步骤添加两个圆形到世界中：
- en: Open the `html5games.box2dcargame.js` JavaScript file to add the wheel bodies.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `html5games.box2dcargame.js` JavaScript 文件以添加轮子体。
- en: 'Add the following code after the box creation code. This calls the `createWheel`
    function which we will write to create a circular shaped body:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在盒子创建代码之后添加以下代码。这调用我们将要编写的 `createWheel` 函数，以创建一个圆形形状的体：
- en: '[PRE17]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Now let''s work on the `createWheel` function. We design this function to create
    a circle-shaped body in the given world at the given *x* and *y* coordinates in
    the world. To do this, put the following function in our JavaScript logic file:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们来处理 `createWheel` 函数。我们设计这个函数，在给定的世界中，在给定的 *x* 和 *y* 坐标处创建一个圆形体。为此，将以下函数放入我们的
    JavaScript 逻辑文件中：
- en: '[PRE18]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: We will now reload the physics world in a web browser. This time, we should
    see a result similar to the one shown in the following screenshot, with a box
    and two wheels falling down from air:![Time for action – putting two circles in
    the world](img/B04290_09_06.jpg)
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在网页浏览器中重新加载物理世界。这次，我们应该看到以下截图所示的结果，其中有一个盒子和两个轮子从空中落下：![行动时间 – 在世界中放置两个圆形](img/B04290_09_06.jpg)
- en: '*What just happened?*'
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: When simulating the physics world, both the box and wheels drop and collide
    with each other and the ground.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当模拟物理世界时，盒子和轮子都会掉落并相互碰撞以及与地面碰撞。
- en: Creating a circular body is similar to creating a box body. The only difference
    is that we use a `CircleDef` class instead of the box shape definition. In the
    circle definition, we define the circle size by using the `radius` property instead
    of the `extents` property.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 创建圆形体与创建盒子体类似。唯一的区别是我们使用 `CircleDef` 类而不是盒子形状定义。在圆形定义中，我们使用 `radius` 属性而不是 `extents`
    属性来定义圆形大小。
- en: Creating a physical car
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建物理汽车
- en: We have prepared the car box body and two wheel bodies. We are just one step
    away from making a car. Imagine that now we have a glue stick to glue the wheels
    to the car body. Then, the car and wheels will not separate anymore, and we will
    have a car. We can use **joint** to achieve this. In this section, we will use
    `joint` to stick the wheels and the car body together.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好了汽车盒子体和两个轮子体。我们离制作汽车只差一步。想象一下，现在我们有一根胶棒来将轮子粘到汽车体上。然后，汽车和轮子将不再分离，我们将拥有汽车。我们可以使用
    **关节** 来实现这一点。在本节中，我们将使用 `joint` 将轮子和汽车体粘在一起。
- en: Time for action – connecting the box and two circles with a revolute joint
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用旋转关节连接盒子和两个圆形
- en: 'Carry out the following steps to create a car with the box and wheels:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以创建带有盒子和轮子的汽车：
- en: We are still working only on the logic part. Open our JavaScript logic file
    in a text editor.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们目前只在工作逻辑部分。在文本编辑器中打开我们的 JavaScript 逻辑文件。
- en: 'Create a function named `createCarAt`, which takes the coordinates as arguments.
    Then, move the body and the wheel creation code in this function. Afterwards,
    add the following highlighted joint creation code. At last, return the car body:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `createCarAt` 的函数，该函数接受坐标作为参数。然后，将体和轮子创建代码移动到这个函数中。之后，添加以下高亮的关节创建代码。最后，返回汽车体：
- en: '[PRE19]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In the `initGame` function, we created two wheels. Remove these lines of code
    that calls the `createWheel` function in the `initGame` function.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `initGame` 函数中，我们创建了两个轮子。从 `initGame` 函数中移除调用 `createWheel` 函数的这些代码行。
- en: 'Then, all we need to do is create a car with the initial position. Add the
    following code to the `initGame` function after calling the `createGround` function:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们只需要创建一个具有初始位置的汽车。在调用 `createGround` 函数后，将以下代码添加到 `initGame` 函数中：
- en: '[PRE20]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: It is time to save the file and run the physics world in a browser. At this
    time, the wheels and the car body are not separate pieces. They glue together
    as a car and drop on the ground correctly, as shown in the following screenshot:![Time
    for action – connecting the box and two circles with a revolute joint](img/B04290_09_07.jpg)
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候保存文件并在浏览器中运行物理世界了。在这个时候，车轮和车身还不是分离的部件。它们粘合在一起形成一个汽车，并正确地落在地面上，如下面的截图所示：![操作时间
    – 使用旋转关节连接方框和两个圆圈](img/B04290_09_07.jpg)
- en: '*What just happened?*'
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: A joint is useful to add constraint between two bodies (or between a body and
    the world). There are many kinds of joints and what we used in this example is
    called the **revolute joint**.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 关节有助于在两个物体（或物体和世界之间）之间添加约束。有许多种类的关节，而我们在这个例子中使用的是**旋转关节**。
- en: Using a revolute joint to create an anchor point between two bodies
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用旋转关节在两个物体之间创建锚点
- en: 'The revolute joint sticks two bodies together with a common anchor point. The
    two bodies are then glued together and are only allowed to rotate based on the
    common anchor point. The left-hand side of the following screenshot shows that
    the two bodies are connected with an anchor. In our code example, we set the anchor
    point to be exactly the center point of the wheel. The right-hand side of the
    following screenshot shows how we set the joint. The wheel rotates because the
    rotation origin is at the center. This setup makes the car and wheels look real:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 旋转关节通过一个共同的锚点将两个物体粘合在一起。然后，两个物体粘合在一起，并且只能根据共同的锚点旋转。以下截图的左侧显示了两个物体通过一个锚点连接。在我们的代码示例中，我们将锚点设置为正好是车轮的中心点。以下截图的右侧显示了如何设置关节。车轮旋转，因为旋转原点在中心。这种设置使汽车和车轮看起来更真实：
- en: '![Using a revolute joint to create an anchor point between two bodies](img/B04290_09_08.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![使用旋转关节在两个物体之间创建锚点](img/B04290_09_08.jpg)'
- en: 'There are other types of joints that are useful in different ways. Joints are
    useful to create a game environment, and as there are several types of joints,
    each joint type is worth a try, and you should think about how to use them. The
    following link consists of the Box2D manual that explains each type of joint and
    how we can use them on different environment setups: [http://www.box2d.org/manual.html#_Toc258082974](http://www.box2d.org/manual.html#_Toc258082974).'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 有其他类型的关节，以不同的方式有用。关节对于创建游戏环境很有用，由于有几种类型的关节，每种类型的关节都值得尝试，你应该考虑如何使用它们。以下链接包含Box2D手册，解释了每种类型的关节以及我们如何在不同的环境设置中使用它们：[http://www.box2d.org/manual.html#_Toc258082974](http://www.box2d.org/manual.html#_Toc258082974)。
- en: Adding force to the car with a keyboard input
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用键盘输入向汽车添加力
- en: We have the car ready now. Let's move it with our keyboard.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好了汽车。让我们用键盘来移动它。
- en: Time for action – adding force to the car
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作时间 – 向汽车添加力
- en: 'Carry out the following steps to take the keyboard input:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以获取键盘输入：
- en: Open the `box2dcargame.js` JavaScript file in a text editor.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开`box2dcargame.js` JavaScript文件。
- en: 'In the page loaded event handler, we add the following `keydown` event handler
    at the beginning of the code. This listens to the right arrow key and the left
    arrow key to apply force in different directions:'
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面加载事件处理程序中，我们在代码的开头添加了以下`keydown`事件处理程序。它监听右箭头键和左箭头键，以在不同方向上施加力：
- en: '[PRE21]'
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We have added forces to bodies. We need to clear forces in each step, otherwise
    the force accumulates:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经向物体添加了力。我们需要在每一步中清除力，否则力会累积：
- en: '[PRE22]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Save the files and run our game in the browser. When you press the *arrow* keys,
    the car starts moving. If you keep pressing the key, the world will keep adding
    force to the car and make it speed away:![Time for action – adding force to the
    car](img/B04290_09_09.jpg)
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件并在浏览器中运行我们的游戏。当你按下*箭头*键时，汽车开始移动。如果你持续按住键，世界将不断向汽车添加力，使其加速：![操作时间 – 向汽车添加力](img/B04290_09_09.jpg)
- en: '*What just happened?*'
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just created an interaction with our car body. We can move the car left and
    right by pressing the arrow keys. It seems like the game is getting interesting
    now.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚与我们的车身创建了交互。我们可以通过按箭头键来左右移动汽车。现在游戏看起来越来越有趣了。
- en: Applying force to a body
  id: totrans-167
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对物体施加力
- en: 'We can apply force to any body by calling the `ApplyForce` function in that
    body. The following code shows the usage of the function:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过在物体中调用`ApplyForce`函数来对任何物体施加力。以下代码显示了该函数的用法：
- en: '[PRE23]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This function takes two arguments, which are listed in the following table:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数接受两个参数，如下表所示：
- en: '| Argument | Type | Discussion |'
  id: totrans-171
  prefs: []
  type: TYPE_TB
  zh: '| 参数 | 类型 | 讨论 |'
- en: '| --- | --- | --- |'
  id: totrans-172
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| `force` | `b2Vec2` | This is the force vector to apply to the body |'
  id: totrans-173
  prefs: []
  type: TYPE_TB
  zh: '| `force` | `b2Vec2` | 这是施加到物体上的力向量 |'
- en: '| `point` | `b2Vec2` | This is the point where the force is applied |'
  id: totrans-174
  prefs: []
  type: TYPE_TB
  zh: '| `point` | `b2Vec2` | 这是施加力的点 |'
- en: Clearing Force
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清除力
- en: After we apply the force to bodies, the force would constantly apply to that
    body until we clear it. In most cases, we clear the force after each step.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们对物体施加力之后，该力会持续作用于该物体，直到我们清除它。在大多数情况下，我们在每一步之后清除力。
- en: Understanding the difference between ApplyForce and ApplyImpulse
  id: totrans-177
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解 ApplyForce 和 ApplyImpulse 之间的区别
- en: Besides the `ApplyForce` function, we can also move any body by using the `ApplyImpulse`
    function. Both functions move the body, but they move them using a different approach.
    If we want to change the instance velocity of a body, then we use `ApplyImpulse`
    once on the body to change its velocity to meet our target value. On the other
    hand, we need to constantly apply force to a body to increase the speed.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `ApplyForce` 函数之外，我们还可以通过使用 `ApplyImpulse` 函数移动任何物体。这两个函数都会移动物体，但它们使用不同的方法。如果我们想改变物体的实例速度，那么我们就在物体上使用一次
    `ApplyImpulse` 来改变其速度以达到我们的目标值。另一方面，我们需要持续对物体施加力以增加速度。
- en: For example, if we want to increase the velocity of the car, similar to like
    stepping on the pedal, we need to apply force to the car. If we are creating a
    ball game in which we need to kick-start the ball, we may use the `ApplyImpulse`
    function to add an instance impulse to the ball's body.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们想增加汽车的速度，类似于踩油门，我们需要对汽车施加力。如果我们正在创建一个需要踢球开始的游戏，我们可能使用 `ApplyImpulse`
    函数向球的物体添加实例冲量。
- en: Have a go hero
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: Can you think about a different situation where we will need to apply force
    or impulse to the body?
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到一个不同的情况，我们将在其中需要向物体施加力或冲量吗？
- en: Adding ramps to our game environment
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向我们的游戏环境添加斜坡
- en: Now, we can move the car. However, the environment is not interesting enough
    to play. Imagine now there are some ramps for the car to jump, and there is a
    gap between two platforms over which a player has to fly the car. It will become
    more interesting to play with different ramp setups.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以移动汽车。然而，环境还不够有趣，无法进行游戏。想象一下，现在有一些斜坡供汽车跳跃，并且有两个平台之间的一个间隙，玩家必须驾驶汽车飞越。不同的斜坡设置将使游戏更有趣。
- en: Time for action – creating the world with ramps
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 - 使用斜坡创建世界
- en: 'Carry out the following steps to create a ramp in the physics world:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤在物理世界中创建斜坡：
- en: We open the game logic JavaScript file.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们打开游戏逻辑 JavaScript 文件。
- en: 'In the `createGround` function, we update the function to take four arguments.
    The changed code is highlighted as follows:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `createGround` 函数中，我们将函数更新为接受四个参数。更改的代码如下所示：
- en: '[PRE24]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now, we have a function to create the ground body. We will now replace the
    ground creation code in the page loaded handler function with the following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有一个创建地面物体的函数。我们将现在用以下代码替换页面加载处理函数中的地面创建代码：
- en: '[PRE25]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Save the file and preview the game in a browser. We should now see a ramp and
    a destination platform, as shown in the following screenshot. Try to control the
    car by making it jump over the ramp to reach the destination without falling down.
    Refresh the page to restart the game if you fail:![Time for action – creating
    the world with ramps](img/B04290_09_10.jpg)
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件，并在浏览器中预览游戏。我们现在应该看到一个斜坡和一个目标平台，如下面的截图所示。尝试通过让汽车跳过斜坡到达目的地而不掉下来来控制汽车。如果失败，请刷新页面重新开始游戏：![行动时间
    - 使用斜坡创建世界](img/B04290_09_10.jpg)
- en: '*What just happened?*'
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just wrapped the ground box creating code with a function so that we can
    easily create a combination of ground bodies. These ground bodies composite the
    level environment of the game.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚将地面盒子的创建代码封装在一个函数中，这样我们就可以轻松地创建地面物体的组合。这些地面物体组合了游戏关卡环境。
- en: In addition, this is the first time we are rotating a body. We set the rotation
    of the body by using the `rotation` property which takes a value in radians. By
    setting the rotation of a box, we can have a ramp with a varying slope setup in
    our game.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这是我们第一次旋转物体。我们通过使用 `rotation` 属性来设置物体的旋转，该属性接受弧度值。通过设置盒子的旋转，我们可以在游戏中设置具有不同斜率的斜坡。
- en: Have a go hero
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: We have set up a ramp now, and we can play with the car within the environment.
    How about using different kinds of joints to set up the playground? For example,
    how about a pulley joint to act as a lift? On the other hand, how about including
    a dynamic board with a joint at the center?
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个斜坡，我们可以在环境中驾驶汽车。那么，使用不同类型的关节来设置游乐场怎么样？例如，使用滑轮关节作为提升装置怎么样？另一方面，包含一个带有中心关节的动态板怎么样？
- en: Checking collisions in the Box2D world
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在Box2D世界中检查碰撞
- en: The Box2D physics library calculates all collisions automatically. Imagine now
    that we set up a ground body as the destination. Players win when they successfully
    move the car to hit the destination. As Box2D already calculates all collisions,
    all we have to do is get the detected collision list and determine whether our
    car has hit the destination ground.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D物理库自动计算所有碰撞。想象一下，我们现在设置一个地面身体作为目标。当玩家成功将汽车移动到撞击目标时，玩家获胜。由于Box2D已经计算了所有碰撞，我们只需要获取检测到的碰撞列表并确定我们的汽车是否撞击了目标地面。
- en: Time for action – checking a collision between the car and the destination body
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 检查汽车和目标身体的碰撞
- en: 'Carry out the following steps to handle collision:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来处理碰撞：
- en: Again, we start from our game logic. Open the `box2dcargame.js` JavaScript file
    in a text editor.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们从游戏逻辑开始。在文本编辑器中打开`box2dcargame.js`JavaScript文件。
- en: 'We set up a destination ground in the ground creation code and assign it to
    our `gamewinWall` reference inside the `carGame` global object instance as follows:'
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在创建地面的代码中设置了一个目标地面，并将其分配给`carGame`全局对象实例中的`gamewinWall`引用，如下所示：
- en: '[PRE26]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next, we move on to the `step` function. In each step, we get the complete
    contact list from the world and check whether any two colliding objects are the
    car and the destination ground:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们转到`step`函数。在每一步中，我们从世界中获取完整的接触列表并检查是否有两个碰撞对象是汽车和目标地面：
- en: '[PRE27]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: When we call our game loop function, `updateWorld`, we call our newly-created
    collision checking function.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们调用我们的游戏循环函数`updateWorld`时，我们调用我们新创建的碰撞检查函数。
- en: '[PRE28]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We will now save the code and open the game in a browser again. This time, we
    have to open the console window to track whether we get the **Level** **Passed!**
    output when the car hits the wall. Try to finish the game, and we should see the
    output in the console once the car hits the destination:![Time for action – checking
    a collision between the car and the destination body](img/B04290_09_11.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将保存代码并在浏览器中再次打开游戏。这次，我们必须打开控制台窗口来跟踪当汽车撞到墙时是否得到**通过关卡**的输出。尝试完成游戏，一旦汽车撞到目标，我们应该在控制台中看到输出：![行动时间
    – 检查汽车和目标身体的碰撞](img/B04290_09_11.jpg)
- en: '*What just happened?*'
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: We just created the game winning logic by checking the collision contacts. The
    player wins when the car successfully reaches the destination ground object.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过检查碰撞接触创建了游戏胜利逻辑。当汽车成功到达目标地面对象时，玩家获胜。
- en: Getting the collision contact list
  id: totrans-211
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 获取碰撞接触列表
- en: 'In each step, Box2D calculates all collisions and puts them into a **contact**
    **list** in the `world` instance. We can get the contact list by using the `carGame.world.GetContactList()`
    function. The returned contact list is a **link** **list**. We can travel through
    the entire link list by using the following `for` loop:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在每一步中，Box2D计算所有碰撞并将它们放入`world`实例的**接触** **列表**中。我们可以通过使用`carGame.world.GetContactList()`函数来获取接触列表。返回的接触列表是一个**链表**。我们可以通过以下`for`循环遍历整个链表：
- en: '[PRE29]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: When we get the collided shapes, we check whether the body of that shape is
    a car or the destination body. As the car shape may be in fixture 1 or fixture
    2, and the same applies to `gamewinWall`, we need to check both the combinations.
    The additional `isTouching` function provides a more accurate collision-checking
    between the fixtures.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们获取到碰撞的形状时，我们检查该形状的身体是汽车还是目标身体。由于汽车形状可能在固定装置1或固定装置2中，同样也适用于`gamewinWall`，我们需要检查这两种组合。额外的`isTouching`函数提供了更精确的固定装置之间的碰撞检查。
- en: '[PRE30]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Have a go hero
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 来吧，英雄
- en: We created a game over dialog in [Chapter 7](ch07.html "Chapter 7. Saving the
    Game's Progress"), *Saving the Game's Progress*. How about using that technique
    here to create a dialog showing the player passed the level when they hit the
    winning wall? This will also be useful as a level transition later when we add
    different level setups to the game.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 7 章](ch07.html "第 7 章。保存游戏进度") 中创建了一个游戏结束对话框，*保存游戏进度*。那么，我们是否可以使用那种技术在这里创建一个对话框，当玩家击中胜利墙壁时显示他们通过了关卡？这在我们添加不同关卡设置到游戏中作为关卡过渡时也将非常有用。
- en: Restarting the game
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 重新启动游戏
- en: You may have already tried refreshing the page several times in the last example
    to make the car successfully jump to the destination. Imagine now if we could
    press a key to reinitialize the world. Then, we can follow the trial-and-error
    method until success.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经在上一个例子中尝试刷新页面几次，以使汽车成功跳到目的地。现在想象一下，如果我们能按一个键来重新初始化世界。然后，我们可以通过试错法直到成功。
- en: Time for action – restarting the game while pressing the R key
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 按下 R 键重新启动游戏
- en: 'We will assign the *R* key as the restart key for our game. Now, let''s perform
    the following set of steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将把 *R* 键分配为我们的游戏的重启键。现在，让我们执行以下步骤：
- en: Again, we only need to change the JavaScript file. Open the `box2dcargame.js`
    JavaScript file in a text editor.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次，我们只需要更改 JavaScript 文件。在文本编辑器中打开 `box2dcargame.js` JavaScript 文件。
- en: 'We need a function to remove all the bodies:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个函数来移除所有身体：
- en: '[PRE31]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'We move the create world, ramp, and the car code into a function named `restartGame`.
    They were originally in the page loaded handler function:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将创建世界、坡道和汽车代码移动到一个名为 `restartGame` 的函数中。它们最初位于页面加载处理函数中：
- en: '[PRE32]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Then, in the `initGame` function, we call the `restartGame` function to initialize
    the game as follows:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在 `initGame` 函数中，我们调用 `restartGame` 函数以如下方式初始化游戏：
- en: '[PRE33]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Finally, we add the following highlighted code to the `keydown` handler to
    restart the game when the *R* key is pressed:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将以下突出显示的代码添加到 `keydown` 处理程序中，以便在按下 *R* 键时重新启动游戏：
- en: '[PRE34]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'How about restarting the game when the player passes the level? To do this,
    add the following highlighted code inside the logic where we checked the collision
    between the car and the winning flag:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当玩家通过关卡时，我们是否应该重新启动游戏？为此，在检查汽车和胜利旗帜之间碰撞的逻辑中添加以下突出显示的代码：
- en: '[PRE35]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: It is time to test the game in a browser. Try playing the game and press the
    *R* key to restart the game.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候在浏览器中测试游戏了。尝试玩游戏并按下 *R* 键重新启动游戏。
- en: '*What just happened?*'
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么事？*'
- en: 'We refractored our code to create a `restartGame` function. The world is destroyed
    and initialized again each time we call this function. We can destroy the existing
    world and create a new empty one by creating a new world instance of our world
    variable as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 我们重构了代码以创建一个 `restartGame` 函数。每次调用此函数时，世界都会被销毁并重新初始化。我们可以通过创建世界变量的新世界实例来销毁现有世界并创建一个新空的世界，如下所示：
- en: '[PRE36]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Have a go hero
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: Now the only way to restart the game is by pressing the restart key. How about
    creating a ground at the bottom of the world that checks for any falling cars?
    When the car drops and hits the bottom ground, we know that the player has failed
    and then they can restart the game.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 现在唯一重新启动游戏的方法是按重启键。我们是否可以在世界的底部创建一个检查任何掉落汽车的地面？当汽车掉落并击中底部地面时，我们知道玩家失败了，然后他们可以重新启动游戏。
- en: Adding a level support to our car game
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为我们的汽车游戏添加关卡支持
- en: Imagine now that we can level up to the next environment setup after finishing
    each game. We will need several environment setups for each level.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，在完成每场比赛后，我们可以升级到下一个环境设置。我们将需要每个级别的几个环境设置。
- en: Time for action – loading the game with levels data
  id: totrans-241
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 使用关卡数据加载游戏
- en: 'We will refractor our code to support the loading of static ground bodies from
    a levels data structure. Let''s work on it by carrying out the following steps:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重构我们的代码以支持从关卡数据结构中加载静态地面身体。让我们通过执行以下步骤来完成这项工作：
- en: Open the `box2dcargame.js` JavaScript file in a text editor.
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文本编辑器中打开 `box2dcargame.js` JavaScript 文件。
- en: 'We will need each ground setup on each level. Put the following code at the
    top of the JavaScript file. It is an array of levels. Each level is another array
    of objects with the position, dimension, and rotation of the static ground body:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将需要每个级别的每个地面设置。在 JavaScript 文件顶部放置以下代码。这是一个级别数组。每个级别是另一个包含位置、尺寸和旋转的静态地面身体的数组：
- en: '[PRE37]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Replace the `restartGame` function with the following code. This changes the
    function to accept a `level` argument. Then, create the ground or car by the level
    data:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`restartGame`函数替换为以下代码。这更改了函数以接受`level`参数。然后根据级别数据创建地面或汽车：
- en: '[PRE38]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the page loaded handler function, change the `restartGame` function called
    by providing `currentLevel` as follows:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在页面加载处理函数中，通过提供`currentLevel`来调用`restartGame`函数，如下所示：
- en: '[PRE39]'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We also need to provide the `currentLevel` value in the restart key handler:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要在重启键处理程序中提供`currentLevel`值：
- en: '[PRE40]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Lastly, change the following highlighted code in the game''s win logic. We
    move a level up in the game when the car hits the destination:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，更改游戏胜利逻辑中以下突出显示的代码。当汽车撞击目的地时，我们在游戏中提升一个级别：
- en: '[PRE41]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We will now run the game in the web browser. Finish the level and the game should
    restart at the next level:![Time for action – loading the game with levels data](img/B04290_09_12.jpg)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将在网络浏览器中运行游戏。完成关卡后，游戏应该从下一级重新启动：![行动时间 – 使用关卡数据加载游戏](img/B04290_09_12.jpg)
- en: '*What just happened?*'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We just created a data structure to store the levels. Then, we created the game
    with the given level number and constructed the world with the level data.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚创建了一个用于存储级别的数据结构。然后，我们使用给定的级别编号创建游戏，并使用级别数据构建世界。
- en: 'Each level data is an array of objects. Each object contains properties of
    each ground body in the world. This includes basic properties such as position,
    size, and rotation. There is also a property named `type`. It defines whether
    the body is a normal box body, car data, or the destination winning ground:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 每个级别数据都是一个对象数组。每个对象包含世界中每个地面物体的属性。这包括基本属性，如位置、大小和旋转。还有一个名为`type`的属性。它定义了该物体是普通框体、汽车数据还是目的地胜利地面：
- en: '[PRE42]'
  id: totrans-258
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'When creating the world, we use the following code to loop through all objects
    in the level array. We then create the car and ground bodies and reference the
    game winning ground according to the type:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建世界时，我们使用以下代码遍历级别数组中的所有对象。然后根据类型创建汽车和地面物体，并引用游戏胜利的地面：
- en: '[PRE43]'
  id: totrans-260
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Have a go hero
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: Now, we have several levels setup for our game. How about duplicating the level
    data to create more interesting levels to play? Create your own levels and play
    with them. It is just like how a kid builds blocks and plays with them.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们为游戏设置了几个级别。关于复制级别数据以创建更多有趣的关卡如何？创建你自己的级别并与它们一起玩耍。这就像一个孩子搭建积木并与之玩耍一样。
- en: Replacing the Box2D outline drawing with graphics
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用图形替换Box2D轮廓绘制
- en: We have created a game that is at least playable with several levels. However,
    they are just some outline boxes. We cannot even distinguish between the destination
    body and other ground bodies in the game. Imagine now that the destination is
    a racing flag and there is a car graphic to represent it. This will make the game's
    purpose clearer.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个至少可以玩几个级别的游戏。然而，它们只是一些轮廓框。我们甚至无法在游戏中区分目的地物体和其他地面物体。想象一下，目的地是一个赛车旗帜，有一个代表它的汽车图形。这将使游戏的目的更加清晰。
- en: Time for action – adding a flag graphic and a car graphic to the game
  id: totrans-265
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 向游戏中添加旗帜图形和汽车图形
- en: 'Carry out the following steps to draw two graphics on our physics objects:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤在物理对象上绘制两个图形：
- en: We will first download the graphics we need for this example. To download the
    graphics, go to [http://mak.la/book-assets](http://mak.la/book-assets).
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先下载本例所需的图形。要下载图形，请访问[http://mak.la/book-assets](http://mak.la/book-assets)。
- en: Put the image files for this chapter in the `images` folder.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将本章的图像文件放入`images`文件夹。
- en: 'Now, it is time to edit the `index.html` file. Add the following HTML markup
    to the `body` section:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候编辑`index.html`文件了。将以下HTML标记添加到`body`部分：
- en: '[PRE44]'
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'We want to hide the asset DIV that contains our `img` tags. Open the `cargame.css`
    file and add the following CSS rule to keep the asset DIV out of our sight:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们想隐藏包含我们的`img`标签的资产DIV。打开`cargame.css`文件，并添加以下CSS规则以使资产DIV不在我们的视线中：
- en: '[PRE45]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We will now move on to the logic part. Open the `box2dcargame.js` JavaScript
    file.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们现在将进入逻辑部分。打开`box2dcargame.js` JavaScript 文件。
- en: 'In the `restartGame` function, add the highlighted code to assign the reference
    of the `flag` image to the winning destination flag:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`restartGame`函数中，添加突出显示的代码以将`flag`图像的引用分配给胜利的目的地旗帜：
- en: '[PRE46]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Next, assign the reference of the `bus` image tag to the user data in the car
    shape. Add the following highlighted code to the car box definition creation:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将`bus`图像标签的引用分配给汽车形状的用户数据。在创建汽车框定义时，添加以下突出显示的代码：
- en: '[PRE47]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Note
  id: totrans-278
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We used to get the reference of an element by the jQuery `$(selector)` method.
    The jQuery selector returns an array of the element objects with additional jQuery
    data wrapped. If we want to get the original document element reference, then
    we can either use the `document.getElementById` method or `$(selector).get(0)`.
    As `$(selector)` returns an array, `get(0)` gives the first original document
    element in the list
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们过去使用jQuery的`$(selector)`方法来获取元素的引用。jQuery选择器返回一个包含额外jQuery数据的元素对象数组。如果我们想获取原始文档元素引用，那么我们可以使用`document.getElementById`方法或`$(selector).get(0)`。因为`$(selector)`返回一个数组，所以`get(0)`给出列表中的第一个原始文档元素。
- en: Then, we need to handle the wheels. We assign the `wheel` image tag to the wheel
    body's `userData` property. Add the following highlighted code to the `createWheel`
    function
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要处理轮子。我们将`wheel`图像标签分配给轮子身体的`userData`属性。在`createWheel`函数中添加以下突出显示的代码
- en: '[PRE48]'
  id: totrans-281
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: We have to draw the images in the canvas. Create a new `drawWorld` function
    in the `box2dcargame.js` file with the following code.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须在画布上绘制图像。在`box2dcargame.js`文件中创建一个新的`drawWorld`函数，代码如下。
- en: '[PRE49]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Finally, call the `drawWorld` function in the `updateWorld` function:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`updateWorld`函数中调用`drawWorld`函数：
- en: '[PRE50]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Save all files and run the game in a web browser. We should see a yellow bus
    graphic, two wheels, and a flag as the destination. Play the game now and the
    game should move on to the next level when the bus hits the flag:![Time for action
    – adding a flag graphic and a car graphic to the game](img/B04290_09_13.jpg)
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件，并在网页浏览器中运行游戏。我们应该看到一个黄色的公交车图形，两个轮子和一个旗帜作为目的地。现在玩游戏，当公交车碰到旗帜时，游戏应该进入下一关：![添加旗帜图形和汽车图形到游戏的时间
    - action](img/B04290_09_13.jpg)
- en: '*What just happened?*'
  id: totrans-287
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*刚才发生了什么？*'
- en: We are now presenting our game with minimal graphics. At least, players easily
    know what they are controlling and where they should go.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在以最少的图形展示我们的游戏。至少，玩家可以很容易地知道他们控制的是什么，以及他们应该去哪里。
- en: The Box2D library uses a canvas to render the physics world. Therefore, all
    techniques that we learned about a canvas can be applied here. In [Chapter 5](ch05.html
    "Chapter 5. Building a Canvas Game's Masterclass"), *Building a Canvas Game's
    Masterclass*, we learned the use of the `drawImage` function to display an image
    in the canvas. We used this technique to draw the flag graphic in the canvas of
    the physics world.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D库使用画布来渲染物理世界。因此，我们可以应用我们学到的所有关于画布的技术。在[第5章](ch05.html "第5章. 构建Canvas游戏大师班")中，*构建Canvas游戏大师班*，我们学习了使用`drawImage`函数在画布中显示图像。我们使用这项技术来在物理世界的画布中绘制旗帜图形。
- en: Using userData in shape and body
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在形状和身体中使用userData
- en: How do we know which physics body needs to be displayed as the flag image? There
    is a property named `userData` in every Box2D shape and body. This property is
    used to store any custom data related to that shape or body. For example, we may
    store the filename of the graphic file or just directly store the reference to
    the image tag.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何知道哪个物理身体需要显示为旗帜图像？每个Box2D形状和身体都有一个名为`userData`的属性。这个属性用于存储与该形状或身体相关的任何自定义数据。例如，我们可能存储图形文件的文件名，或者直接存储对图像标签的引用。
- en: 'We have a list of image tags referencing the graphic assets that we need in
    the game. However, we do not want to display the image tags—they are just for
    the purpose of loading and referencing. We hide the asset image tags by setting
    their position out of the HTML bound with the following CSS style. We do not use
    `display:none` because we cannot get the width and height of the element that
    is not displayed at all. We need the width and height to position graphics correctly
    in the physics world:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一个图像标签列表，引用游戏中需要的图形资产。然而，我们不想显示图像标签——它们只是为了加载和引用的目的。我们通过以下CSS样式将资产图像标签的位置设置在HTML边界之外来隐藏它们。我们不使用`display:none`，因为我们无法获取完全不显示的元素的宽度和高度。我们需要宽度和高度来正确地在物理世界中定位图形：
- en: '[PRE51]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Drawing graphics in every frame according to the state of its physics body
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 根据物理身体的当前状态在每一帧中绘制图形
- en: The drawing from Box2D is just for development use before we replace it with
    our graphics.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D的绘制只是为了在替换我们的图形之前进行开发使用。
- en: The following code checks whether the shape has user data assigned to it. In
    our example, the user data is used to reference the `image` tag of a graphics
    asset. We get the `image` tag and pass it to the Canvas context `drawImage` function
    to draw.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码检查形状是否有分配给它的用户数据。在我们的例子中，用户数据用于引用图形资产的`image`标签。我们获取`image`标签，并将其传递给Canvas上下文的`drawImage`函数以绘制。
- en: 'All box and circle shapes in Box2D have the origin point at the center. However,
    the image drawing in the canvas needs the top-left point. Therefore, we have both
    *x* and *y* coordinates and offset of top-left *x* and *y* points, which is a
    negative half width and height of the image:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: Box2D中的所有矩形和圆形形状都以中心点为原点。然而，画布中的图像绘制需要左上角点。因此，我们既有*x*和*y*坐标，也有左上角*x*和*y*点的偏移量，这是图像负半宽度和高度：
- en: '[PRE52]'
  id: totrans-298
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Rotating and translating an image in the canvas
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在画布中旋转和移动图像
- en: 'We used the `drawImage` function to draw an image directly with the coordinates.
    However, the situation is different here. We need to rotate the drawn image. This
    is done by rotating the context before drawing and then restoring the rotation
    afterwards. We can do this by saving the context state, translating it, rotating
    it, and then calling the `restore` function. The following code shows how we draw
    an image at a given position and rotation. The `topleftX` and `topleftY` are the
    offset distances from the image''s center origin to the top-left point:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了`drawImage`函数直接用坐标绘制图像。然而，这里的情况不同。我们需要旋转绘制的图像。这是通过在绘制之前旋转上下文并在之后恢复旋转来完成的。我们可以通过保存上下文状态，平移它，旋转它，然后调用`restore`函数来实现。以下代码展示了如何在一个给定的位置和旋转下绘制图像。`topleftX`和`topleftY`是从图像中心原点到左上角点的偏移距离：
- en: '[PRE53]'
  id: totrans-301
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Tip
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: We do not need to make the physics body area exactly the same as its graphics.
    For example, if we have a round circular chicken, we can represent it in the physics
    world by just a ball body. Using a simple physics body can improve the performance
    a lot.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不需要让物理体区域与其图形完全相同。例如，如果我们有一个圆形的鸡，我们可以在物理世界中用球体来表示它。使用简单的物理体可以大大提高性能。
- en: Have a go hero
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 尝试一下英雄
- en: We have learned using CSS3 transitions to animate a scoreboard. How about applying
    it to this car game? Moreover, how about adding some engine sounds to the car?
    Just try applying what we have learned throughout this book to give players a
    complete game experience.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经学习了使用CSS3过渡来动画化得分板。那么，将它应用到这个赛车游戏中怎么样？此外，给汽车添加一些引擎声音怎么样？只需尝试应用本书中学到的知识，为玩家提供完整的游戏体验。
- en: Adding a final touch to make the game fun to play
  id: totrans-306
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加最后的修饰使游戏更有趣
- en: Imagine now that we want to publish the game. The game logic is basically there,
    but it looks quite ugly with the black and white environment. In this section,
    we will add some final touches to the game so that it is much more attractive.
    We will also apply some constraints to limit the time of `ApplyForce`. This constraint
    makes the game more fun because it requires a player to think before he applies
    too much force to the car.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，现在我们想要发布游戏。游戏逻辑基本上已经有了，但与黑白环境相比，它看起来相当丑陋。在本节中，我们将添加一些最后的修饰，使游戏更具吸引力。我们还将应用一些约束来限制`ApplyForce`的时间。这个约束使游戏更有趣，因为它要求玩家在施加过多力量到车上之前先思考。
- en: Time for action – decorating the game and adding a fuel limitation
  id: totrans-308
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动手实践 – 装饰游戏和添加燃料限制
- en: 'Carry out the following steps to turn our debug draw into a rich graphical
    game:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤将我们的调试绘制转换为丰富的图形游戏：
- en: First, we need some background images for the starting screen, game winning
    screen, and environment backgrounds for each level. These graphics can be found
    from the code bundle named `box2d_final_game`. The following screenshot shows
    the graphics that we need in this section:![Time for action – decorating the game
    and adding a fuel limitation](img/B04290_09_16.jpg)
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要一些用于起始屏幕、游戏胜利屏幕以及每个级别的环境背景的背景图像。这些图形可以从名为`box2d_final_game`的代码包中找到。以下屏幕截图显示了本节中我们需要的一些图形：![动手实践
    – 装饰游戏和添加燃料限制](img/B04290_09_16.jpg)
- en: 'Open the `index.html` file and replace the canvas element with the following
    markup. This creates two more game components named `current level` and `fuel`
    `remaining`, and it groups the game components into a `game-container` DIV:'
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`index.html`文件，将画布元素替换为以下标记。这创建了两个额外的游戏组件，名为`current level`和`fuel remaining`，并将游戏组件组合到一个`game-container`
    DIV中：
- en: '[PRE54]'
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Next, we will copy the `cargame.css` file from the code bundle. This contains
    several class-style definitions for the game. The game should look similar to
    the one shown in the following screenshot after we have applied the new stylesheet:![Time
    for action – decorating the game and adding a fuel limitation](img/B04290_09_17.jpg)
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将从代码包中复制`cargame.css`文件。这个文件包含了游戏的一些类样式定义。应用了新的样式表后，游戏应该看起来与以下屏幕截图中的相似：![动手实践
    – 装饰游戏和添加燃料限制](img/B04290_09_17.jpg)
- en: Now, we will move on to the JavaScript part. Open the `html5games.box2dcargame.js`
    file.
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将继续到JavaScript部分。打开`html5games.box2dcargame.js`文件。
- en: 'Update the `carGame` object declaration with the following additional variable:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`carGame`对象声明，添加以下附加变量：
- en: '[PRE55]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Now, we have the starting screen. Instead of starting the game once, the page
    is loaded. We''ll display the starting screen and wait for the player to click
    on the game canvas. Add the following logic to the `initGame` function:'
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们有起始屏幕。不是一次性开始游戏，而是页面加载。我们将显示起始屏幕并等待玩家点击游戏画布。将以下逻辑添加到`initGame`函数中：
- en: '[PRE56]'
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, we need to handle the game-winning screen when the player passes all
    levels. In the winning flag-collision-checking logic, we use the following logic
    to determine if we show the next level or the ending screen. Find the `console.log("Level
    Passed!");` code in the file and replace the `restartGame` function call with
    the following code:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要处理玩家通过所有级别后的游戏获胜屏幕。在获胜旗帜碰撞检查逻辑中，我们使用以下逻辑来确定是否显示下一级或结束屏幕。在文件中找到`console.log("Level
    Passed!");`代码，并将`restartGame`函数调用替换为以下代码：
- en: '[PRE57]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Then, we will handle the game playing background. We prepared each game background
    for each level setting. We will switch the background in the `restartGame` function,
    which corresponds to reconstructing the world:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将处理游戏背景。我们为每个级别的设置准备了每个游戏背景。我们将在`restartGame`函数中切换背景，这相当于重建世界：
- en: '[PRE58]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'With the game graphics now, we do not need the physics object outline drawing
    any more. We can turn off the debug drawing by setting the `shouldDrawDebug` object
    to `false`:'
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在有了游戏图形，我们不再需要物理对象轮廓绘制。我们可以通过将`shouldDrawDebug`对象设置为`false`来关闭调试绘制：
- en: '[PRE59]'
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Finally, let's add some constraints. Remember that in our level data, we include
    a mystery fuel data for the car. This is an indicator of how much fuel the car
    contains. We will use this fuel to limit the player's input. The fuel reduces
    each time a force is applied to the car. The player cannot apply any additional
    force once the fuel runs out. This limitation makes the game more fun to play.
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们添加一些约束。记住，在我们的级别数据中，我们包括了一个神秘的燃料数据，用于汽车。这是汽车燃料含量的指示器。我们将使用这个燃料来限制玩家的输入。每次对汽车施加力时，燃料都会减少。一旦燃料耗尽，玩家就不能再施加任何额外的力。这种限制使得游戏更有趣。
- en: 'Update the arrow keys'' `keydown` function with the following logic. The new
    code is highlighted here:'
  id: totrans-326
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下逻辑更新箭头键的`keydown`函数。新的代码在这里突出显示：
- en: '[PRE60]'
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'In addition, in the car-creating logic in the restart game function, we initialize
    the fuel as follows:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，在重启游戏函数中的创建汽车逻辑中，我们初始化燃料如下：
- en: '[PRE61]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: Now, run the game in a browser. We should get five graphic levels. The following
    screenshot shows how the last four levels look:![Time for action – decorating
    the game and adding a fuel limitation](img/B04290_09_18.jpg)
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在浏览器中运行游戏。我们应该得到五个图形级别。以下截图显示了最后四个级别的样子：![时间行动 – 装饰游戏和添加燃料限制](img/B04290_09_18.jpg)
- en: After passing all the levels, we will get the following winning screen:![Time
    for action – decorating the game and adding a fuel limitation](img/B04290_09_19.jpg)
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过所有级别后，我们将得到以下获胜屏幕：![时间行动 – 装饰游戏和添加燃料限制](img/B04290_09_19.jpg)
- en: '*What just happened?*'
  id: totrans-332
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We just decorated our game with more graphics. We also drew each level environment,
    a background image. The following screenshot illustrates how the visual ground
    represents the logical physics boxes. Unlike the car and the winning flag, the
    ground graphics are not associated with the physics ground. This is just a background
    image with the graphics in their respective positions. We can use this approach
    because those logical boxes will never move:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚用更多图形装饰了我们的游戏。我们还绘制了每个级别的环境，一个背景图像。以下截图说明了视觉地面如何表示逻辑物理盒子。与汽车和获胜旗帜不同，地面图形与物理地面无关。这只是一个背景图像，其中的图形位于它们相应的位置。我们可以使用这种方法，因为那些逻辑盒子永远不会移动：
- en: '![What just happened?](img/B04290_09_20.jpg)'
  id: totrans-334
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_09_20.jpg)'
- en: 'We can then prepare several CSS styles for each level with the level number
    in the class name, such as `.gamebg-level1` and `.gamebg-level2`. With each class
    linked with each level background, we can change the background when switching
    a level using the following code:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以为每个级别准备几个CSS样式，样式名称中包含级别编号，例如`.gamebg-level1`和`.gamebg-level2`。通过将每个类与每个级别背景相关联，我们可以使用以下代码在切换级别时更改背景：
- en: '[PRE62]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Adding fuel to add a constraint when applying force
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在施加力时添加燃料以添加约束
- en: 'Now, we limit the player''s input by providing limited fuel to use. The fuel
    decreases when players apply force to the car. We used the following `keydown`
    logic to decrease the fuel and prevent additional force when the car is running
    out of fuel:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们通过提供有限的燃料来限制玩家的输入。当玩家对汽车施加力时，燃料会减少。我们使用了以下 `keydown` 逻辑来减少燃料并防止汽车燃料耗尽时施加额外的力：
- en: '[PRE63]'
  id: totrans-339
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Presenting the remaining fuel in a CSS3 progress bar
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 以 CSS3 进度条的形式呈现剩余燃料
- en: 'In our game, we present the remaining fuel as a progress bar. The progress
    bar is actually a DIV inside another DIV. The following markup shows the structure
    of the progress bar. The outer DIV defines the maximum value and the inner DIV
    shows the actual value:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏中，我们将剩余燃料以进度条的形式呈现。进度条实际上是一个嵌套在另一个 DIV 中的 DIV。以下标记显示了进度条的结构。外部 DIV 定义了最大值，内部
    DIV 显示实际值：
- en: '[PRE64]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'The following screenshot illustrates the structure of the progress bar:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了进度条的结构：
- en: '![Presenting the remaining fuel in a CSS3 progress bar](img/B04290_09_15.jpg)'
  id: totrans-344
  prefs: []
  type: TYPE_IMG
  zh: '![以 CSS3 进度条的形式呈现剩余燃料](img/B04290_09_15.jpg)'
- en: 'With this structure, we can show specific progress by setting the width as
    a percentage value. We use the following code to update the progress bar according
    to the percentage of the fuel:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这种结构，我们可以通过设置宽度为百分比值来显示具体的进度。我们使用以下代码根据燃料的百分比更新进度条：
- en: '[PRE65]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This is the basic logic to set up a progress bar and control it with the width
    style.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 这是设置进度条并使用宽度样式控制它的基本逻辑。
- en: Adding touch support for tablets
  id: totrans-348
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为平板电脑添加触摸支持
- en: We added touch support in [Chapter 6](ch06.html "Chapter 6. Adding Sound Effects
    to Your Games"), *Adding Sound Effects to Your Games*. In this game, we will add
    touch support to make it playable on tablets.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在 [第 6 章](ch06.html "第 6 章。为您的游戏添加音效") *为您的游戏添加音效* 中添加了触摸支持。在本游戏中，我们将添加触摸支持以使其可在平板电脑上玩。
- en: Time for action – adding touch support
  id: totrans-350
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 行动时间 – 添加触摸支持
- en: 'Carry out the following steps to make our game work in a tablet with touch
    inputs:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以使我们的游戏在具有触摸输入的平板电脑上运行：
- en: 'In `index.html` file, we add the following touch controls before the end of
    the `#game-container`:'
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `index.html` 文件中，我们在 `#game-container` 结束前添加以下触摸控制：
- en: '[PRE66]'
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: We can also add a `<meta>` tag inside the `<head>` tag to control the viewport
    to fit the game into the iPad's 1024 px width.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还可以在 `<head>` 标签内添加一个 `<meta>` 标签来控制视口，使游戏适应 iPad 的 1024 像素宽度。
- en: '[PRE67]'
  id: totrans-355
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'For these controls, we add some basic styles to position them. To do this,
    append the following code to the `cargame.css` file:'
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于这些控制，我们添加了一些基本样式来定位它们。为此，将以下代码追加到 `cargame.css` 文件中：
- en: '[PRE68]'
  id: totrans-357
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'Now, we move to the `box2dcargame.js` file, and we add a function named `handleTouchInputs()`:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们转到 `box2dcargame.js` 文件，并添加一个名为 `handleTouchInputs()` 的函数：
- en: '[PRE69]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'We call our `handleTouchInputs` function within the `initGame` function:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们在 `initGame` 函数中调用 `handleTouchInputs` 函数：
- en: '[PRE70]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'We apply the force continuously until the touch up event. We can slightly adjust
    the value to fit the tablet. To do this, add the following code at the end of
    the existing `updateWorld` function:'
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们持续施加力直到触摸更新事件。我们可以稍微调整值以适应平板电脑。为此，在现有的 `updateWorld` 函数末尾添加以下代码：
- en: '[PRE71]'
  id: totrans-363
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Save all the files and run the game in a tablet, say an iPad or an Android,
    and we should be able to control the car by pressing the left and right sides
    of the game. We can also restart the level by pressing the restart button.
  id: totrans-364
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存所有文件，并在平板电脑上运行游戏，例如 iPad 或 Android，我们应该能够通过按下游戏的左右两侧来控制汽车。我们还可以通过按下重启按钮来重新开始关卡。
- en: '*What just happened?*'
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '*发生了什么？*'
- en: 'We just added touch support to our game to make it playable on a tablet. We
    created two touch areas for the left and right force. We also created a restart
    button that''s only viewable on touch devices:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚为我们的游戏添加了触摸支持，使其可在平板电脑上玩。我们为左右力创建了两个触摸区域。我们还创建了一个仅在触摸设备上可见的重启按钮：
- en: '![What just happened?](img/B04290_09_14.jpg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![发生了什么？](img/B04290_09_14.jpg)'
- en: We listen to the `touchstart` and `touchend` event on these buttons. The `touchstart`
    event is not like the `keydown` event that keeps firing the events. We need a
    Boolean to know whether the touch has started and keep a track until it ends.
    During touch pressing, we apply the forces in the `updateWorld` method. The frequency
    is different, so we adjusted the value of force and fuel consumption to make it
    work better in tablets.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们监听这些按钮上的 `touchstart` 和 `touchend` 事件。`touchstart` 事件与持续触发事件的 `keydown` 事件不同。我们需要一个布尔值来知道触摸是否开始，并跟踪直到结束。在触摸按下期间，我们在
    `updateWorld` 方法中施加力。频率不同，因此我们调整了力的值和燃料消耗，使其在平板电脑上运行得更好。
- en: Controlling the viewport scale
  id: totrans-369
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 控制viewport缩放
- en: 'When designing mobile web pages, we often use viewport to tell the browser
    to use the device width as the web page''s view port width:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 当设计移动网页时，我们经常使用viewport来告诉浏览器使用设备宽度作为网页的viewport宽度：
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: In games, especially games that require tapping frequently, we may want to fix
    the zooming feature by setting the same value to the minimum scale and the maximum
    scale. Moreover, we can control the scale value to zoom the game to fit the tablet
    devices.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，尤其是需要频繁点击的游戏中，我们可能想要通过设置相同的值到最小缩放和最大缩放来固定缩放功能。此外，我们可以控制缩放值来调整游戏以适应平板设备。
- en: '[PRE73]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Touch-specific buttons
  id: totrans-374
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 特定于触摸的按钮
- en: 'There is no keyboard on tablet and mobile devices. We have to create on-screen
    inputs for these devices. We created three on-screen buttons in this game example:
    left, right and restart buttons. We hid these buttons in the desktop by checking
    the availability of `window.Touch`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 平板和移动设备上没有键盘。我们必须为这些设备创建屏幕输入。在这个游戏示例中，我们创建了三个屏幕按钮：左键、右键和重新开始按钮。我们通过检查`window.Touch`的可用性来隐藏这些按钮：
- en: '[PRE74]'
  id: totrans-376
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Summary
  id: totrans-377
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You learned a lot in this chapter about using the Box2D physics engine to create
    a car adventure game in canvas.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何使用Box2D物理引擎在画布中创建汽车冒险游戏。
- en: Specifically, we set up the game with the JavaScript physics engine. Then, we
    created static and dynamic bodies in the physics world. We set up the car by using
    joints to constrain bodies and wheels. We controlled the car with keyboard inputs
    by adding force to it. At last, we determined game-over and level-up by adding
    collisions in the physics world. We have now learned how to use the Box2D physics
    library to create a canvas-based physics game.
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 具体来说，我们使用JavaScript物理引擎设置游戏。然后，我们在物理世界中创建了静态和动态物体。我们通过使用关节来约束物体和车轮来设置汽车。我们通过向汽车添加力来控制汽车，通过键盘输入。最后，我们在物理世界中添加碰撞来决定游戏结束和升级。我们现在已经学会了如何使用Box2D物理库来创建基于画布的物理游戏。
- en: In the next chapter, we are going to discuss different distribution channels
    and put our game into a native Mac application.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论不同的分销渠道并将我们的游戏放入原生Mac应用程序中。
