<html><head></head><body>
		<div id="_idContainer023">
			<h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Creating Your First 3D Scene with Three.js</h1>
			<p>In recent years, modern browsers have acquired powerful features that can be accessed directly from <strong class="bold">JavaScript</strong>. You can <a id="_idIndexMarker000"/>easily add video and <a id="_idIndexMarker001"/>audio with <strong class="bold">HTML5 tags</strong> and create interactive components through <a id="_idIndexMarker002"/>the use of <strong class="bold">HTML5 Canvas</strong>. Together with HTML5, modern browsers <a id="_idIndexMarker003"/>also support <strong class="bold">WebGL</strong>. With WebGL, you can directly make use of the processing resources of your graphics card and create high-performance 2D and 3D computer graphics. Using WebGL directly from JavaScript to create and animate 3D scenes is a very complex, verbose, and error-prone <a id="_idIndexMarker004"/>process. <strong class="bold">Three.js</strong> is a library that makes this a lot easier. The following list shows some of the things that are very easy to do <span class="No-Break">with Three.js:</span></p>
			<ul>
				<li>Create simple and complex 3D geometries and render them in <span class="No-Break">any browser</span></li>
				<li>Animate and move objects through a <span class="No-Break">3D scene</span></li>
				<li>Apply textures and materials to <span class="No-Break">your objects</span></li>
				<li>Use different light sources to illuminate <span class="No-Break">the scene</span></li>
				<li>Use models from 3D modeling software and export generated models into <span class="No-Break">these programs</span></li>
				<li>Add advanced post-processing effects to your <span class="No-Break">3D scene</span></li>
				<li>Create and work with <span class="No-Break">custom shaders</span></li>
				<li>Create, visualize, and <a id="_idIndexMarker005"/>animate <a id="_idIndexMarker006"/><span class="No-Break">point clouds</span></li>
				<li>Create <strong class="bold">virtual reality</strong> (<strong class="bold">VR</strong>) and <strong class="bold">augmented reality</strong> (<span class="No-Break"><strong class="bold">AR</strong></span><span class="No-Break">) scenes</span></li>
			</ul>
			<p>With a couple of lines of <a id="_idIndexMarker007"/>JavaScript (or <strong class="bold">TypeScript</strong>, as we’ll see later in this book), you can create anything, from simple 3D models to photorealistic scenes, all of which are rendered in real time in the browser. For instance, <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.1</em> shows an example of <a id="_idIndexMarker008"/>what can be done with Three.js (you can see the animation for yourself by opening <a href="https://threejs.org/examples/webgl_animation_keyframes.html">https://threejs.org/examples/webgl_animation_keyframes.html</a> in <span class="No-Break">your browser):</span></p>
			<div>
				<div id="_idContainer008" class="IMG---Figure">
					<img src="image/Figure_1.1_B18726.jpg" alt="Figure 1.1 – Three.js rendered and animated scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Three.js rendered and animated scene</p>
			<p>In this chapter, we’ll directly dive into Three.js and create a couple of examples that will show you how Three.js works, and that you can use to play around with and get to know Three.js a little bit. We won’t dive into all the technical details yet; you'll learn about those in the following chapters. By the end of this chapter, you’ll be able to create a scene, and run and explore all the examples in <span class="No-Break">this book.</span></p>
			<p>We’ll start this book with a short introduction to Three.js and then quickly move on to the first few examples and code samples. Before we get started, let’s quickly look at the most important browsers out there and their support for WebGL (<span class="No-Break">and WebGPU).</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">All modern browsers on desktop, as well as on mobile, currently support WebGL. Older versions of IE (those before version 11) won’t be able to run WebGL-based applications. On mobile, most browsers support WebGL. So, with WebGL, you can create interactive 3D visualizations that run very well on desktops, as well as on <span class="No-Break">mobile devices.</span></p>
			<p class="callout">In this book, we’ll focus on the WebGL-based renderer provided by Three.js. There is, however, also a CSS 3D-based renderer, which provides an easy API to create CSS 3D-based 3D scenes. A big advantage of using a CSS 3D-based approach is that this standard is supported on all mobile and desktop browsers and allows you to render HTML elements in a 3D space. We won’t go into the details of this browser but will show an example in <a href="B18726_07.xhtml#_idTextAnchor122"><span class="No-Break"><em class="italic">Chapter 7</em></span></a>, <em class="italic">Points </em><span class="No-Break"><em class="italic">and Sprites</em></span><span class="No-Break">.</span></p>
			<p class="callout">Besides WebGL, a new standard for using the GPU to render in your browser called WebGPU is being developed, which will provide even better performance than WebGL and, in the future, become the new standard. When you use Three.js, you don’t have to worry about this change. Three.js already partly supports WebGPU and as that standard matures, so will the support of this standard in Three.js. So, everything you create with Three.js will also work out of the box <span class="No-Break">with WebGPU.</span></p>
			<p>In this first chapter, you’ll directly create a 3D scene and be able to run it on a desktop or mobile device. We’ll explain the core concepts of Three.js, and if there are more advanced topics, we’ll mention in what chapter we’ll explain these in more detail. In this chapter, we’ll create two different scenes. The first one will show a basic geometry rendered in Three.js, as shown in the <span class="No-Break">following figure:</span></p>
			<div>
				<div id="_idContainer009" class="IMG---Figure">
					<img src="image/Figure_1.2_B18726.jpg" alt="Figure 1.2 – Default geometries rendered"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Default geometries rendered</p>
			<p>After that, we’ll also quickly show you how you can load external models, and how easy it is to create realistic-looking scenes. The result of the second example will look <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer010" class="IMG---Figure">
					<img src="image/Figure_1.3_B18726.jpg" alt="Figure 1.3 – Rendering an externally loaded model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Rendering an externally loaded model</p>
			<p>Before you start working on these examples, in the next couple of sections, we’ll look at the tools you need to easily work with Three.js and how you can download the examples shown in <span class="No-Break">this book.</span></p>
			<p>In this chapter, we’ll cover the <span class="No-Break">following topics:</span></p>
			<ul>
				<li>Requirements for <span class="No-Break">using Three.js</span></li>
				<li>Downloading the source code and examples used in <span class="No-Break">this book</span></li>
				<li>Testing and experimenting with <span class="No-Break">the examples</span></li>
				<li>Rendering and viewing a <span class="No-Break">3D object</span></li>
				<li>Introducing a couple of helper libraries for statistics and controlling <span class="No-Break">the scene</span></li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>Three.js is a JavaScript <strong class="bold">library</strong>, so all you need to create Three.js WebGL applications is a text editor and one of the supported browsers to render the results. I would like to recommend the following text editors, which I’ve used extensively over the last couple of years for <span class="No-Break">various projects:</span></p>
			<ul>
				<li><strong class="bold">Visual Studio Code</strong>: This free editor from Microsoft runs on all major platforms <a id="_idIndexMarker009"/>and provides great syntax highlighting and smart completion based on types, function definitions, and imported libraries. It provides a very clean interface and is great for working on JavaScript projects. It can be <a id="_idIndexMarker010"/>downloaded from here: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>. If you don’t want to download this editor, you can also just navigate to <a href="https://vscode.dev/">https://vscode.dev/</a>, which will launch an editor directly in your browser, from which you can connect to a GitHub repository or access directories on your <span class="No-Break">local filesystem.</span></li>
				<li><strong class="bold">WebStorm</strong>: This <a id="_idIndexMarker011"/>editor from <em class="italic">JetBrains</em> offers great support for editing JavaScript. It supports code completion, automatic deployment, and JavaScript debugging, directly from the editor. Besides this, WebStorm has excellent GitHub (and other version control system) support. You can download <a id="_idIndexMarker012"/>a trial edition <span class="No-Break">from </span><a href="http://www.jetbrains.com/webstorm/"><span class="No-Break">http://www.jetbrains.com/webstorm/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">Notepad++</strong>: Notepad++ is <a id="_idIndexMarker013"/>a general-purpose editor that supports code highlighting for a wide range of programming languages. It can easily lay out and format JavaScript. Note that Notepad++ is only for Windows. You can <a id="_idIndexMarker014"/>download Notepad++ <span class="No-Break">from </span><a href="http://notepad-plus-plus.org/"><span class="No-Break">http://notepad-plus-plus.org/</span></a><span class="No-Break">.</span></li>
				<li><strong class="bold">Sublime Text Editor</strong>: Sublime <a id="_idIndexMarker015"/>is a great editor that offers very good support for editing JavaScript. Besides this, it provides many very helpful selections (such as multi-line select) and edit options, which, once you get used to them, provide a really good JavaScript-editing environment. Sublime <a id="_idIndexMarker016"/>can also be tested for free and can be downloaded <span class="No-Break">from </span><a href="http://www.sublimetext.com/"><span class="No-Break">http://www.sublimetext.com/</span></a><span class="No-Break">.</span></li>
			</ul>
			<p>Even if you don’t use any of these editors, there are a lot of editors available, both open source and commercial, that you can use to edit JavaScript and create your Three.js projects, since all you need is the ability to edit text. An interesting project you might want to <a id="_idIndexMarker017"/>look at is AWS Cloud9 (<a href="http://c9.io">http://c9.io</a>). This is a cloud-based JavaScript editor that can be connected to a GitHub account. This way, you can directly access all the source code and examples from this book and experiment <span class="No-Break">with them.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">Besides these text-based editors, which you can use to edit and experiment with the sources from this book, Three.js currently also provides an <span class="No-Break">online editor.</span></p>
			<p class="callout">With this editor, which <a id="_idIndexMarker018"/>you can find at <a href="http://threejs.org/editor/">http://threejs.org/editor/</a>, you can create Three.js scenes using a <span class="No-Break">graphical approach.</span></p>
			<p>I suggest picking up Visual Studio Code. It is a very lightweight editor with great support for JavaScript and has several other extensions that make writing JavaScript <span class="No-Break">applications easier.</span></p>
			<p>Earlier, I mentioned that most modern web browsers support WebGL and can be used to run Three.js examples. I usually run my code in Firefox. The reason is that, often, Firefox has the best support and performance for WebGL and it has a great JavaScript debugger. With this debugger, as shown in the following screenshot, you can quickly pinpoint problems using, for instance, breakpoints and <span class="No-Break">console output:</span></p>
			<div>
				<div id="_idContainer011" class="IMG---Figure">
					<img src="image/Figure_1.4_B18726.jpg" alt="Figure 1.4 – Firefox debugger"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Firefox debugger</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the examples in this book will work just as well with Chrome as they do with Firefox. So, if that’s your browser of choice, you can, of course, use that <span class="No-Break">one instead.</span></p>
			<p>Throughout this book, I’ll give you pointers on debugger usage and other debugging tips and tricks. That’s enough by way of an introduction for now; let’s get the source code and start with the <span class="No-Break">first scene.</span></p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Getting the source code</h2>
			<p>All the <a id="_idIndexMarker019"/>code for this book is available on GitHub (<a href="https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition">https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition</a>). GitHub is a site that hosts Git repositories. You can use these to store, access, and version source code. There are a couple of ways that you can get the sources for yourself. You can do either of <span class="No-Break">the following:</span></p>
			<ul>
				<li>Clone the Git repository. This means you use the <strong class="source-inline">git</strong> command-line tool to get the latest version of the sources for <span class="No-Break">this book.</span></li>
				<li>Download and extract an archive from GitHub, which <span class="No-Break">contains everything.</span></li>
			</ul>
			<p>In the <a id="_idIndexMarker020"/>following two subsections, we’ll explore these options in a bit <span class="No-Break">more detail.</span></p>
			<h3>Using git to clone the repository</h3>
			<p>One way to <a id="_idIndexMarker021"/>get all the examples is to <em class="italic">clone</em> this repository using the <strong class="source-inline">git</strong> command-line tool. To do this, you need to download a Git client for your operating system. If you’ve got an up-to-date operating system, you probably already have Git installed. You can quickly check this by running the following in <span class="No-Break">a terminal:</span></p>
			<pre class="console">
$ git --version
git version 2.30.1 (Apple Git-130)</pre>
			<p>If the command isn’t installed yet, you can get a client and instructions on how to install it from here: <a href="http://git-scm.com">http://git-scm.com</a>. After installing Git, you can use the <strong class="source-inline">git</strong> command-line tool to clone this book’s repository. Open a command prompt and go to the directory where you want to download the sources. In that directory, run <span class="No-Break">the following:</span></p>
			<pre class="console">
$ git clone https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition.
git clone git@github.com:PacktPublishing/Learn-Three.js-Fourth-edition.git
Cloning into 'learning-threejs-fourth'...
remote: Enumerating objects: 96, done.
remote: Counting objects: 100% (96/96), done.
remote: Compressing objects: 100% (85/85), done.
fetch-pack: unexpected disconnect while reading sideband packet
...</pre>
			<p>After doing <a id="_idIndexMarker022"/>this, all the source code will be downloaded into the <strong class="source-inline">learning-threejs-fourth</strong> directory. From that directory, you can run all the examples explained throughout <span class="No-Break">this book.</span></p>
			<h3>Downloading and extracting the archive</h3>
			<p>If you don’t <a id="_idIndexMarker023"/>want to use <strong class="source-inline">git</strong> to download <a id="_idIndexMarker024"/>the sources directly from GitHub, you can also download an archive. Open <a href="https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition">https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition</a> in a browser and click on the <strong class="bold">Code</strong> button on the right-hand side. This will give you the option to download all the sources in a single ZIP file by clicking on the <strong class="bold">Download </strong><span class="No-Break"><strong class="bold">ZIP</strong></span><span class="No-Break"> option:</span></p>
			<div>
				<div id="_idContainer012" class="IMG---Figure">
					<img src="image/Figure_1.5_B18726.jpg" alt="Figure 1.5 – Downloading the archive from GitHub"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Downloading the archive from GitHub</p>
			<p>After extracting this to a directory of your choice, all the examples will <span class="No-Break">become available.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also download the example code files from your account at <a href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files emailed directly <span class="No-Break">to you.</span></p>
			<p>Now that <a id="_idIndexMarker025"/>you’ve downloaded or cloned the source <a id="_idIndexMarker026"/>code, let’s quickly check whether everything is working and familiarize you with the <span class="No-Break">directory structure.</span></p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Testing and experimenting with the examples</h1>
			<p>The code and examples are organized per chapter and, with the examples, we will provide a <a id="_idIndexMarker027"/>simple integrated server that you can use to <a id="_idIndexMarker028"/>access all the examples. To get this server up and running, we need to install <em class="italic">Node.js</em> and <em class="italic">npm</em>. These tools are used to manage JavaScript packages and build JavaScript applications and make it easier to modularize our Three.js code and integrate existing <span class="No-Break">JavaScript libraries.</span></p>
			<p>To install these <a id="_idIndexMarker029"/>two tools, go to <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> and select the appropriate installer for your operating system. Once installed, open a terminal and check whether everything is working. On my machine, the following versions are <span class="No-Break">being used:</span></p>
			<pre class="console">
$ npm --version
8.3.1
$ node --version
v16.14.0</pre>
			<p>Once these tools have been installed, we need to perform a few steps to get all the externally needed dependencies before we can build and access <span class="No-Break">the examples:</span></p>
			<ol>
				<li>First, we need to download the external libraries used in the examples. For instance, Three.js is one of the dependencies we need <span class="No-Break">to download.</span></li>
			</ol>
			<p>To download all the dependencies, run the following command in the directory where you downloaded or extracted all <span class="No-Break">the examples:</span></p>
			<pre class="console">
<strong class="bold">$ npm install</strong>
<strong class="bold">added 570 packages, and audited 571 packages in 21s</strong></pre>
			<p>The preceding command will start downloading all the required JavaScript libraries and store these in the <span class="No-Break"><strong class="source-inline">node_modules</strong></span><span class="No-Break"> folder.</span></p>
			<ol>
				<li value="2">Next, we need <a id="_idIndexMarker030"/>to build the examples. Doing so <a id="_idIndexMarker031"/>will combine our source code and the external libraries into a single file, which we can show in <span class="No-Break">the browser.</span></li>
			</ol>
			<p>To build the examples using <strong class="source-inline">npm</strong>, use the <span class="No-Break">following command:</span></p>
			<pre class="console">
<strong class="bold">$ npm run build</strong>
<strong class="bold">&gt; ltjs-fourth@1.0.0 build</strong>
<strong class="bold">&gt; webpack build</strong>
<strong class="bold">...</strong></pre>
			<p>Note that you only have to run the two preceding <span class="No-Break">commands once.</span></p>
			<ol>
				<li value="3">With that, all the examples will have been built and are ready for you to explore. To open these examples, you need a web server. To start a server, simply run the <span class="No-Break">following command:</span><pre class="console">
<strong class="bold">$ npm run serve</strong></pre><pre class="console">
<strong class="bold">&gt; ltjs-fourth@1.0.0 serve</strong></pre><pre class="console">
<strong class="bold">&gt; webpack serve –open</strong></pre><pre class="console">
<strong class="bold">&lt;i&gt; [webpack-dev-server] Project is running at:</strong></pre><pre class="console">
<strong class="bold">&lt;i&gt; [webpack-dev-server] Loopback: http://localhost:8080/</strong></pre><pre class="console">
<strong class="bold">&lt;i&gt; [webpack-dev-server] On Your Network (Ipv4): http://192.168.68.144:8080/</strong></pre><pre class="console">
<strong class="bold">&lt;i&gt; [webpack-dev-server] On Your Network (Ipv6): http://[fe80::1]:8080/</strong></pre><pre class="console">
<strong class="bold">…</strong></pre></li>
			</ol>
			<p>At this point, you’ll probably notice that <strong class="source-inline">npm</strong> has already opened your default browser and shows <a id="_idIndexMarker032"/>the content of <strong class="source-inline">http://localhost:8080</strong> (if this isn’t the case, just open your browser of choice and <a id="_idIndexMarker033"/>navigate to <strong class="source-inline">http://localhost:8080</strong>). You’ll be presented with an overview of all the chapters. In each of these subfolders, you’ll find the examples that are explained in <span class="No-Break">that chapter:</span></p>
			<div>
				<div id="_idContainer013" class="IMG---Figure">
					<img src="image/Figure_1.6_B18726.jpg" alt="Figure 1.6 – Overview of all the chapters and examples"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Overview of all the chapters and examples</p>
			<p>One very interesting feature of this server is that we can now see the changes we make to the source code immediately reflected in the browser. If you have started the server by running <strong class="source-inline">npm run serve</strong>, open up the <strong class="source-inline">chapter-01/geometries.js</strong> example from the sources you’ve downloaded in your editor and change something; you’ll see <a id="_idIndexMarker034"/>that this is also changed at the same time in <a id="_idIndexMarker035"/>your browser after you have saved the change. This makes testing changes and fine-tuning colors and lights much easier. If you open the <strong class="source-inline">chapter-01/geometries.js</strong> file in your code editor, and you open the <strong class="source-inline">http://localhost:8080/chapter-01/geometries.html</strong> example in your browser, you can see this in action. In your editor, change the color of the cube. To do so, find the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
initScene(props)(({ scene, camera, renderer, orbitControls }) =&gt; {
  const geometry = new THREE.BoxGeometry();
  const cubeMaterial = new THREE.MeshPhongMaterial({
    color: 0xFF0000,
  });</pre>
			<p>Change it to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
initScene(props)(({ scene, camera, renderer, orbitControls }) =&gt; {
  const geometry = new THREE.BoxGeometry();
  const cubeMaterial = new THREE.MeshPhongMaterial({
    color: 0x0000FF,
  });</pre>
			<p>Now, when you save the file, you’ll immediately see that the color of the cube in the browser changes, without you having to refresh the browser or do <span class="No-Break">anything else.</span></p>
			<p class="callout-heading">Note</p>
			<p class="callout">The setup we’re working with in this book is one of many different approaches you can use to develop web applications. Alternatively, you can include Three.js (and other libraries) directly in your HTML file or use an approach with <strong class="source-inline">import-maps</strong>, as is done with the example on the Three.js website. All of these have advantages and disadvantages. For this book, we’ve chosen an approach that makes it easy to experiment with the sources and get direct feedback in the browser, and closely resembles how these kinds of applications are <span class="No-Break">built normally.</span></p>
			<p>A good starting <a id="_idIndexMarker036"/>point to understand how everything <a id="_idIndexMarker037"/>works together is by looking at the HTML file that we opened in <span class="No-Break">the browser.</span></p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Exploring the HTML structure for Three.js applications</h1>
			<p>In this section, we’ll look at the source of the <strong class="source-inline">geometries.html</strong> file. You can do this by looking <a id="_idIndexMarker038"/>at the source in the browser <a id="_idIndexMarker039"/>or opening the file from the <strong class="source-inline">dist/chapter-1</strong> folder in the same location where you downloaded the source for <span class="No-Break">this book:</span></p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;style&gt;
    body {
      margin: 0;
    }
  &lt;/style&gt;
  &lt;script defer src="../js/vendors-node_modules_three_
    build_three_module_js.js"&gt;&lt;/script&gt;
  &lt;script defer src="../js/vendors-node_modules_lil-gui_
    dist_lil-gui_esm_js.js"&gt;&lt;/script&gt;
  &lt;script defer src="../js/vendors-node_modules_three_
    examples_jsm_controls_OrbitControls_js.js"&gt;&lt;/script&gt;
  &lt;script defer src="../js/geometries.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
			<p>This code <a id="_idIndexMarker040"/>is generated when you run the <strong class="source-inline">npm run build</strong> step. This will combine all the sources and external libraries you’ve <a id="_idIndexMarker041"/>used into separate source files (called bundles) and add them to this page. So, you don’t need to do this yourself. The first three <strong class="source-inline">&lt;script&gt;</strong> tags refer to any of the external libraries we use. Later in the book, we’ll introduce <a id="_idIndexMarker042"/>other libraries such as <strong class="bold">React.js</strong> and <strong class="bold">Tween.js</strong>. Those will <a id="_idIndexMarker043"/>be included in the same manner automatically. The only other elements here are <strong class="source-inline">&lt;style&gt;</strong> and <strong class="source-inline">&lt;body&gt;</strong>. <strong class="source-inline">&lt;style&gt;</strong> is used to disable any margins in the page, so we can use the complete browser viewport to show our 3D scenes. Furthermore, we’ll add the 3D scene programmatically into an empty <strong class="source-inline">&lt;body&gt;</strong> element, which we’ll explain in the <span class="No-Break">next section.</span></p>
			<p>If you do want to add custom HTML elements here, you can, of course, do that. In the root of the downloaded code, you’ll find a <strong class="source-inline">template.html</strong> file, which is used by the build process to create the individual HTML files for the examples. Anything you add there will be added to all the examples. We won’t dive too deep into how this works since that’s outside the scope of this book. However, if you want to learn more about how this works, a couple of good resources on <em class="italic">webpack</em> (which we use for this) are <span class="No-Break">as follows:</span></p>
			<ul>
				<li>The getting <a id="_idIndexMarker044"/>started with webpack guide: <a href="https://webpack.js.org/guides/getting-started/">https://webpack.js.org/guides/getting-started/</a>. This site contains a tutorial that explains the reason why we need webpack for JavaScript development, and how the basic <span class="No-Break">concepts work.</span></li>
				<li>Information <a id="_idIndexMarker045"/>on the <em class="italic">HTML webpack plugin</em>: <a href="https://github.com/jantimon/html-webpack-plugin">https://github.com/jantimon/html-webpack-plugin</a>. Here, you can find information on the webpack plugin we use to combine the sources into the separate HTML pages you see when you open the browser after running <strong class="source-inline">npm run build</strong> and then running <strong class="source-inline">npm </strong><span class="No-Break"><strong class="source-inline">run serve</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>Note that <a id="_idIndexMarker046"/>we don’t have to explicitly <a id="_idIndexMarker047"/>initialize our scene or call JavaScript. Whenever we open this page and the <strong class="source-inline">geometries.js</strong> file is loaded, the JavaScript from that file will run and create our <span class="No-Break">3D scene.</span></p>
			<p>Now that we’ve set up the basic structure, we can create and render our <span class="No-Break">first scene.</span></p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Rendering and viewing a 3D object</h1>
			<p>In this <a id="_idIndexMarker048"/>section, you’ll create your first scene, which is a simple <a id="_idIndexMarker049"/>3D scene that looks <span class="No-Break">like this:</span></p>
			<div>
				<div id="_idContainer014" class="IMG---Figure">
					<img src="image/Figure_1.8_B18726.jpg" alt="Figure 1.7 – First scene with two standard geometries"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – First scene with two standard geometries</p>
			<p>In the <a id="_idIndexMarker050"/>preceding screenshot, you can see two objects that rotate. These <a id="_idIndexMarker051"/>objects are called <em class="italic">meshes</em>. A mesh <a id="_idIndexMarker052"/>describes the geometry of an object – that is, its shape – and contains information about the material of the object. A mesh determines how the shape gets shown on screen through traits such as color, or whether the object is shiny <span class="No-Break">or transparent.</span></p>
			<p>In the previous screenshot, we can identify three of <span class="No-Break">these meshes:</span></p>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Object</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Plane</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>This is a two-dimensional rectangle that serves as the ground area. In <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.7</em>, you can see this since it shows the shadows cast by the two meshes. We will create this as a very large rectangle so that you don’t see <span class="No-Break">any edges.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Cube</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>This is a three-dimensional cube and is shown on the left of <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.7</em>. It is rendered <span class="No-Break">in </span><span class="No-Break"><em class="italic">red</em></span><span class="No-Break">.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><span class="No-Break"><strong class="bold">Torus knot</strong></span></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>This is the <em class="italic">TorusKnot</em> you can see to the right of <span class="No-Break"><em class="italic">Figure 1</em></span><em class="italic">.7</em>. This one is rendered <span class="No-Break">in </span><span class="No-Break"><em class="italic">green</em></span><span class="No-Break">.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Overview of the objects in the scene</p>
			<p>To get all <a id="_idIndexMarker053"/>this on screen, we need to perform a couple of steps, which <a id="_idIndexMarker054"/>we’ll explain in the <span class="No-Break">upcoming sections.</span></p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Setting up the scene</h2>
			<p>Each Three.js application at least needs a camera, a scene, and a renderer. The scene is the container <a id="_idIndexMarker055"/>that holds all the objects (meshes, cameras, and lights), the camera determines what part of the scene is shown when it is rendered, and the renderer takes care of creating the output on the screen, taking into account all the information from the meshes, cameras, and lights in <span class="No-Break">the scene.</span></p>
			<p>All the code we’ll be discussing can be found in the <strong class="source-inline">chapter-1/getting-started.js</strong> file. The basic structure of this file is <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import * as THREE from "three";
import Stats from 'three/examples/jsm/libs/stats.module'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'
// create a scene
...
// setup camera
...
// setup the renderer and attach to canvas
...
// add lights
...
// create a cube and torus knot and add them to the scene
...
// create a very large ground plane
...
// add orbitcontrols to pan around the scene using the
   mouse
...
// add statistics to monitor the framerate
...
// render the scene</pre>
			<p>If you look through the preceding steps, you might have noticed that a lot of these steps are the same <a id="_idIndexMarker056"/>for each scene you create. Since we’ve got a lot of examples in this book that show different features of Three.js, we’ll extract this code into a couple of helper files. We’ll show how we did this at the end of this chapter. For now, we will walk through the different steps and introduce you to the basic components of a <span class="No-Break">Three.js scene.</span></p>
			<p>First, we must create a <strong class="source-inline">THREE.Scene</strong>. This is a basic container that will hold all of the meshes, lights, and cameras and has a couple of simple properties, which we’ll explore in more depth in the <span class="No-Break">next chapter:</span></p>
			<pre class="source-code">
// basic scene setup
const scene = new THREE.Scene();
scene.backgroundColor = 0xffffff;
scene.fog = new THREE.Fog(0xffffff, 0.0025, 50);</pre>
			<p>Here, we will create the container object that will hold all our objects, set the background color of this scene to white (<strong class="source-inline">0xffffff</strong>), and enable the fog effect in this scene. With fog enabled, objects further away from the camera will slowly get hidden <span class="No-Break">by fog.</span></p>
			<p>The next step is creating the camera and <span class="No-Break">the renderer:</span></p>
			<pre class="source-code">
// setup camera and basic renderer
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.x = -3;
camera.position.z = 8;
camera.position.y = 2;
// setup the renderer and attach to canvas
const renderer = new THREE.WebGLRenderer({ antialias: true
  });
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.VSMShadowMap;
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0xffffff);
document.body.appendChild(renderer.domElement);</pre>
			<p>In the <a id="_idIndexMarker057"/>preceding code, we created a <strong class="source-inline">PerspectiveCamera</strong>, which determines what part of the scene is rendered. Don’t worry too much about the parameters at this point, since we’ll discuss those in detail in <a href="B18726_03.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>, <em class="italic">Working with Light Sources in Three.js</em>. We also positioned the camera at the specified <em class="italic">x-</em>, <em class="italic">y-</em>, and <em class="italic">z-</em>oordinates. The camera will, by default, look at the center of the scene (which is <strong class="source-inline">0</strong>, <strong class="source-inline">0</strong>, <strong class="source-inline">0</strong>), so we don’t need to change anything <span class="No-Break">for that.</span></p>
			<p>In this code fragment, we also created a <strong class="source-inline">WebGLRenderer</strong>, which we will use to render the view from the camera on the scene. Ignore the other properties for now; we’ll explain these <a id="_idIndexMarker058"/>in the next few chapters when we dive into the details of <strong class="source-inline">WebGLRenderer</strong> and how you can fine-tune the colors and work with shadows. One interesting part to notice is <strong class="source-inline">document.body.appendChild(renderer.domElement)</strong>. This step adds an HTML <strong class="source-inline">canvas</strong> element to the page, which shows the output of the renderer. You can see this when you inspect the page in <span class="No-Break">your browser:</span></p>
			<div>
				<div id="_idContainer015" class="IMG---Figure">
					<img src="image/Figure_1.9_B18726.jpg" alt="Figure 1.9 – Canvas added by Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Canvas added by Three.js</p>
			<p>At this point, we’ve got an empty <strong class="source-inline">THREE.Scene</strong>, a <strong class="source-inline">THREE.PerspectiveCamera</strong>, and a <strong class="source-inline">THREE.WebGLRenderer</strong>. If we add some objects to the scene, we can already show some output on the screen. Before we do this, though, we’ll add a couple of <span class="No-Break">additional components:</span></p>
			<ul>
				<li><strong class="bold">OrbitControls</strong>: This will <a id="_idIndexMarker059"/>allow you to use the mouse to rotate and pan around <span class="No-Break">the scene</span></li>
				<li><strong class="bold">Lights</strong>: This allows <a id="_idIndexMarker060"/>us to use some more advanced materials, cast shadows, and generally make our scene <span class="No-Break">look better</span></li>
			</ul>
			<p>In the next section, we’ll first add <span class="No-Break">the lights.</span></p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Adding lights</h2>
			<p>If we don’t <a id="_idIndexMarker061"/>have lights in the scene, most materials will be rendered in black. So, to see our meshes (and get shadows), we’re going to add some lights to the scene. In this case, we’re going to add <span class="No-Break">two lights:</span></p>
			<ul>
				<li><strong class="source-inline">THREE.AmbientLight</strong>: This is <a id="_idIndexMarker062"/>just a simple light that affects everything with the same intensity <span class="No-Break">and color.</span></li>
				<li><strong class="source-inline">THREE.DirectionalLight</strong>: This <a id="_idIndexMarker063"/>is a light source whose rays are cast in parallel to one another. This is pretty much how we experience the light of <span class="No-Break">the Sun.</span></li>
			</ul>
			<p>The following code fragment shows how to <span class="No-Break">do this:</span></p>
			<pre class="source-code">
// add lights
scene.add(new THREE.AmbientLight(0x666666))
const dirLight = new THREE.DirectionalLight(0xaaaaaa)
dirLight.position.set(5, 12, 8)
dirLight.castShadow = true
// and some more shadow related properties</pre>
			<p>And once again, these lights can be configured in various ways, the details of which we’ll explain in <a href="B18726_03.xhtml#_idTextAnchor040"><span class="No-Break"><em class="italic">Chapter 3</em></span></a>. At this point, we’ve got all the components ready to render a scene, so let’s add <span class="No-Break">the meshes.</span></p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Adding the meshes</h2>
			<p>In the <a id="_idIndexMarker064"/>following code fragment, we create the three meshes in <span class="No-Break">our scene:</span></p>
			<pre class="source-code">
// create a cube and torus knot and add them to the scene
const cubeGeometry = new THREE.BoxGeometry();
const cubeMaterial = new THREE.MeshPhongMaterial({ color:
  0x0000FF });
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
cube.position.x = -1;
cube.castShadow = true;
scene.add(cube);
const torusKnotGeometry = new THREE.TorusKnotBufferGeometry(0.5, 0.2, 100, 100);
const torusKnotMat = new THREE.MeshStandardMaterial({
  color: 0x00ff88,
  roughness: 0.1,
});
const torusKnotMesh = new THREE.Mesh(torusKnotGeometry, torusKnotMat);
torusKnotMesh.castShadow = true;
torusKnotMesh.position.x = 2;
scene.add(torusKnotMesh);
// create a very large ground plane
const groundGeometry = new THREE.PlaneBufferGeometry(10000,
  10000)
const groundMaterial = new THREE.MeshLambertMaterial({
  color: 0xffffff
})
const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial)
groundMesh.position.set(0, -2, 0)
groundMesh.rotation.set(Math.PI / -2, 0, 0)
groundMesh.receiveShadow = true
scene.add(groundMesh)
);</pre>
			<p>Here, we have <a id="_idIndexMarker065"/>created a cube, a torus knot, and the ground. All these meshes follow the <span class="No-Break">same idea:</span></p>
			<ol>
				<li value="1">We create the shape – that is, the geometry of the objects: a <strong class="source-inline">THREE.BoxGeometry</strong>, a <strong class="source-inline">THREE.TorusKnotBufferGeometry</strong>, and <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">THREE.PlaneBufferGeometry</strong></span><span class="No-Break">.</span></li>
				<li>We create the material. In this case, we use a <strong class="source-inline">THREE.MeshPhongMaterial</strong> for the cube, a <strong class="source-inline">THREE.MeshStandardMaterial</strong> for the torus knot, and a <strong class="source-inline">THREE.MeshLambertMaterial</strong> for the ground. The color of the cube is blue, the color of the torus knot is greenish, and the color of the ground is white. In <a href="B18726_04.xhtml#_idTextAnchor056"><span class="No-Break"><em class="italic">Chapter 4</em></span></a>, <em class="italic">Working with Three.js Materials</em>, we’re going to explore all these materials, where they can best be used, and how to <span class="No-Break">configure them.</span></li>
				<li>We tell Three.js that the cube and the torus knot cast shadows and that the ground will <span class="No-Break">receive shadows.</span></li>
				<li>Finally, from the shape and the material, we create a <strong class="source-inline">THREE.Mesh</strong>, position the mesh, and add it to <span class="No-Break">the scene.</span></li>
			</ol>
			<p>At this point, we just have to call <strong class="source-inline">renderer.render(scene, camera)</strong>. You will see the result on <span class="No-Break">your screen:</span></p>
			<div>
				<div id="_idContainer016" class="IMG---Figure">
					<img src="image/Figure_1.10_B18726.jpg" alt="Figure 1.10 – Geometries renderer – static"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Geometries renderer – static</p>
			<p>If you’ve <a id="_idIndexMarker066"/>got the source file (<strong class="source-inline">chapter-01/getting-started.js</strong>), open it in your editor; now is also a good time to experiment a bit with the settings. By changing the <strong class="source-inline">torusKnot.postion.x</strong>, <strong class="source-inline">torusKnot.position.y</strong>, and <strong class="source-inline">torusKnot.position.z</strong> settings, you can move the torus knot around the scene (changes are applied after you save the file in the editor). You can also easily change the color of the meshes by changing the <strong class="source-inline">color</strong> property of <span class="No-Break">the materials.</span></p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Adding an animation loop</h2>
			<p>At this point, the scene is very static. You can’t move the camera around, and nothing is moving. If we <a id="_idIndexMarker067"/>want to animate the scene, the first thing that we need to do is find some way to re-render the scene at a specific interval. Before HTML5 and the related JavaScript APIs came along, the way to do this was by using the <strong class="source-inline">setInterval(function,interval)</strong> function. With <strong class="source-inline">setInterval</strong>, we could specify a function that, for instance, would be called every 100 milliseconds. The problem with this function is that it doesn’t take into account what is happening in the browser. If you were browsing another tab, this function would still be fired every couple of milliseconds. Besides that, <strong class="source-inline">setInterval</strong> isn’t synchronized <a id="_idIndexMarker068"/>when the the screen is redrawn. This can lead to higher CPU usage, flickering, and generally <span class="No-Break">poor performance.</span></p>
			<p>Luckily, modern browsers have a solution for that with the <span class="No-Break"><strong class="source-inline">requestAnimationFrame</strong></span><span class="No-Break"> function.</span></p>
			<h3>Introducing requestAnimationFrame</h3>
			<p>With <strong class="source-inline">requestAnimationFrame</strong>, you can specify a function that is called at an interval. However, you <a id="_idIndexMarker069"/>don’t define this interval. This <a id="_idIndexMarker070"/>interval is defined by the browser. You do any drawing you need to do in the supplied function, and the browser will make sure it is painted as smoothly and efficiently as possible. Using this is simple. We just add the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();</pre>
			<p>In the preceding <strong class="source-inline">animate</strong> function, we called <strong class="source-inline">requestAnimationFrame</strong> again, to keep the animation going. The only thing we need to change in the code is that instead of calling <strong class="source-inline">renderer.render</strong> after we’ve created the complete scene, we call the <strong class="source-inline">animate()</strong> function once to initiate the animation. If you run this, you won’t see any changes yet compared to the previous example because we haven’t changed anything in this <strong class="source-inline">animate()</strong> function. Before we add additional functionality to this function though, we will introduce a <a id="_idIndexMarker071"/>small helper library called <strong class="bold">stats.js</strong>, which gives us information about the frame rate the animation is running at. This library, from the same author as Three.js, renders a small graph that shows us information about the rate at which the scene <span class="No-Break">is rendered.</span></p>
			<p>To add these statistics, all we need to do is import the correct module and add it to <span class="No-Break">our page:</span></p>
			<pre class="source-code">
import Stats from 'three/examples/jsm/libs/stats.module'
const stats = Stats()
document.body.appendChild(stats.dom)</pre>
			<p>If you leave <a id="_idIndexMarker072"/>it at this, you’ll see a nice stats counter <a id="_idIndexMarker073"/>in the top left of your screen, but nothing will happen. The reason is that we need to tell this element when we’re in the <strong class="source-inline">requestAnimationFrame</strong> loop. For this, we just need to add the following to our <span class="No-Break"><strong class="source-inline">animate</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
function animate() {
  requestAnimationFrame(animate);
  stats.update();
  renderer.render(scene, camera);
}
animate();</pre>
			<p>If you <a id="_idIndexMarker074"/>open the <strong class="source-inline">chapter-1/getting-started.html</strong> example, you’ll see that it shows a <strong class="bold">frames per second</strong> (<strong class="bold">FPS</strong>) counter in the top left of <span class="No-Break">your screen:</span></p>
			<div>
				<div id="_idContainer017" class="IMG---Figure">
					<img src="image/Figure_1.11_B18726.jpg" alt="Figure 1.11 – FPS statistics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – FPS statistics</p>
			<p>In the <strong class="source-inline">chapter-1/getting-started.html</strong> example, you can already see that the torus <a id="_idIndexMarker075"/>knot and cube are moving around <a id="_idIndexMarker076"/>their axes. In the following section, we’ll explain how you do this by extending the <span class="No-Break"><strong class="source-inline">animate()</strong></span><span class="No-Break"> function.</span></p>
			<h3>Animating the meshes</h3>
			<p>With <strong class="source-inline">requestAnimationFrame</strong> and <a id="_idIndexMarker077"/>the statistics <a id="_idIndexMarker078"/>configured, we’ve got a place to put our animation code. All we need to do is add this to the <span class="No-Break"><strong class="source-inline">animate()</strong></span><span class="No-Break"> function:</span></p>
			<pre class="source-code">
cube.rotation.x += 0.01;
cube.rotation.y += 0.01;
cube.rotation.z += 0.01;
torusKnotMesh.rotation.x -= 0.01;
torusKnotMesh.rotation.y += 0.01;
torusKnotMesh.rotation.z -= 0.01;</pre>
			<p>That looks simple, right? What we do is increase the rotation property of each of the axes by 0.01 every time the <strong class="source-inline">animate()</strong> function is called, which shows up as the meshes <a id="_idIndexMarker079"/>smoothly rotating around all of their axes. If we <a id="_idIndexMarker080"/>change the position instead of the rotation around the axes, we can move the <span class="No-Break">meshes around:</span></p>
			<pre class="source-code">
let step = 0;
animate() {
  ...
  step += 0.04;
  cube.position.x = 4*(Math.cos(step));
  cube.position.y = 4*Math.abs(Math.sin(step));
  ...
}</pre>
			<p>With the cube, we have already changed the <strong class="source-inline">rotation</strong> property; now, we’re also going to change its <strong class="source-inline">position</strong> property in the scene. We want the cube to bounce from one point in the scene to another with a nice, smooth curve. For this, we need to change its position on the <em class="italic">X</em>-axis, as well as the <em class="italic">y</em>-axis. The <strong class="source-inline">Math.cos</strong> and <strong class="source-inline">Math.sin</strong> functions help us create a smooth trajectory using the <strong class="source-inline">step</strong> variable. I won’t go into the details of how this works here. For now, all you need to know is that <strong class="source-inline">step+=0.04</strong> defines the speed of the bouncing sphere. If you want to enable this for yourself, open up the <strong class="source-inline">chapter-1/geometries.js</strong> file and uncomment the section from the <strong class="source-inline">animate()</strong> function. Once you’ve done this, you’ll see something like this on screen, where the blue cube is dancing around <span class="No-Break">the scene:</span></p>
			<div>
				<div id="_idContainer018" class="IMG---Figure">
					<img src="image/Figure_1.12_B18726.jpg" alt="Figure 1.12 – Jumping blue cube"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Jumping blue cube</p>
			<h3>Enabling orbit controls</h3>
			<p>If you try and move the scene around with your mouse, nothing much will happen. That is because <a id="_idIndexMarker081"/>we added the camera to a fixed position, and we didn’t update its position in the animate loop. We can, of course, do this in the same manner as <a id="_idIndexMarker082"/>we did to the position of the cube, but Three.js comes with several <em class="italic">controls</em> that allow you to easily pan around the scene and move the camera around. For this example, we’ll introduce <strong class="source-inline">THREE.OrbitControls</strong>. With these controls, you can use your mouse to move the camera around the scene and look at different objects. All we need to do to get this working is create a new instance of these controls, attach them to the camera, and call the <strong class="source-inline">update</strong> function from our <span class="No-Break">animation loop:</span></p>
			<pre class="source-code">
const orbitControls = new OrbitControls(camera, renderer.
  domElement)
// and the controller has a whole range of other properties we can set
function animate() {
  ...
  orbitControls.update();
}</pre>
			<p>Now, you can <a id="_idIndexMarker083"/>use your mouse to navigate around the scene. This <a id="_idIndexMarker084"/>is already enabled in the <span class="No-Break"><strong class="source-inline">chapter-1/getting-started.html</strong></span><span class="No-Break"> example:</span></p>
			<div>
				<div id="_idContainer019" class="IMG---Figure">
					<img src="image/Figure_1.13_B18726.jpg" alt="Figure 1.13 – Zoom﻿ing in with orbit controls"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – Zooming in with orbit controls</p>
			<p>Before wrapping up this section, we will add one more element to our basic scene. When <a id="_idIndexMarker085"/>working with 3D scenes, animations, colors, and properties, it often <a id="_idIndexMarker086"/>requires a bit of experimenting to get the correct color, animation speed, or material property. It would be very easy if you had a simple <strong class="bold">GUI</strong> that allowed you to change these kinds of properties on the fly. Luckily, <span class="No-Break">you do!</span></p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Using lil-gui to control properties and make experimenting easier</h2>
			<p>In the <a id="_idIndexMarker087"/>previous example, we added <a id="_idIndexMarker088"/>a little bit of animation for the torus knot and the cube. Now, we’ll create a simple UI element that allows us to control the speed of the rotations and the movement. For this, we’re going to use the <strong class="source-inline">lil-gui</strong> library <a id="_idIndexMarker089"/>from <a href="https://lil-gui.georgealways.com/">https://lil-gui.georgealways.com/</a>. This library allows us to quickly create a simple control UI to make experimenting with the scene easier. It can be added <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
import GUI from "lil-gui";
...
const gui = new GUI();
const props = {
  cubeSpeed: 0.01,
  torusSpeed: 0.01,
};
gui.add(props, 'cubeSpeed', -0.2, 0.2, 0.01)
gui.add(props, 'torusSpeed', -0.2, 0.2, 0.01)
function animate() {
  ...
  cube.rotation.x += props.cubeSpeed;
  cube.rotation.y += props.cubeSpeed;
  cube.rotation.z += props.cubeSpeed;
  torusKnotMesh.rotation.x -= props.torusSpeed;
  torusKnotMesh.rotation.y += props.torusSpeed;
  torusKnotMesh.rotation.z -= props.torusSpeed;
  ...
}</pre>
			<p>In the preceding code fragment, we created a new control element (<strong class="source-inline">new GUI</strong>) and configured two controls: <strong class="source-inline">cubeSpeed</strong> and <strong class="source-inline">torusSpeed</strong>. In each animation step, we’ll just look <a id="_idIndexMarker090"/>up the current values <a id="_idIndexMarker091"/>and use those to rotate the meshes. Now, we can experiment with the properties without having to switch between the browser and the editor. You’ll see this UI in most of the examples in this book where we provide it so that you can easily play around with the different options provided by the materials, the lights, and the other Three.js objects. In the following screenshot, you can see the controls you can use to control the scene in the top-right part of <span class="No-Break">the screen:</span></p>
			<div>
				<div id="_idContainer020" class="IMG---Figure">
					<img src="image/Figure_1.14_B18726.jpg" alt="Figure 1.14 – Using controls to modify the properties of the scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – Using controls to modify the properties of the scene</p>
			<p>Before we move on to the last section of this chapter, here’s a quick note on what we’ve shown so far. You can imagine that most scenes will need pretty much the same setup. They all <a id="_idIndexMarker092"/>need some lights, a camera, a scene, and maybe a ground floor. To avoid having to add all this to each example, we’ve <a id="_idIndexMarker093"/>externalized most of these common elements to a set of helper libraries. That way, we can keep the examples nice and clean so that they only show you the code relevant to that example. If you’re interested in how that’s set up, you can look at the files from the <strong class="source-inline">bootstrap</strong> folder, which brings this <span class="No-Break">approach together.</span></p>
			<p>In the previous example, we rendered some simple meshes in the scene and positioned them directly. Sometimes, though, it is hard to determine where to position objects, or how far we should rotate them. Three.js provides several different helpers that provide you with additional information about the scene. In the next section, we’ll look at a couple of these <span class="No-Break">helper functions.</span></p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Helper objects and util functions</h1>
			<p>Before we move on to the next chapter, we’re going to quickly introduce a couple of helper functions <a id="_idIndexMarker094"/>and objects. These helpers make it easier to position <a id="_idIndexMarker095"/>objects and see what is happening in a scene. The easiest way to see this in action is to open the <strong class="source-inline">chapter-01/porsche.html</strong> example in <span class="No-Break">your browser:</span></p>
			<div>
				<div id="_idContainer021" class="IMG---Figure">
					<img src="image/Figure_1.15_B18726.jpg" alt="Figure 1.15 – Porsche example with helper"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – Porsche example with helper</p>
			<p>On the right-hand side of the screen, at the bottom of the menu, you will see three buttons in the controls: <strong class="bold">Toggle AxesHelper</strong>, <strong class="bold">Toggle GridHelper</strong>, and <strong class="bold">Toggle PolarGridHelper</strong>. When you click on any of them, Three.js will add an overlay to the screen that can help you orient and position meshes, determine needed rotations, and check the sizes of your objects. For instance, when we toggle <strong class="bold">AxesHelper</strong>, we will see the <em class="italic">x-</em>, <em class="italic">y-</em>, and <em class="italic">z-a</em>xes in <span class="No-Break">the scene:</span></p>
			<div>
				<div id="_idContainer022" class="IMG---Figure">
					<img src="image/Figure_1.16_B18726.jpg" alt="Figure 1.16 – Porsche example with AxesHelper enabled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – Porsche example with AxesHelper enabled</p>
			<p>Note that <a id="_idIndexMarker096"/>in this example, you can see a more extensive control UI, where <a id="_idIndexMarker097"/>you can also control various aspects <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">WebGLRenderer</strong></span><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Summary</h1>
			<p>That’s it for this first chapter. In this chapter, you learned how to set up your development environment, how to get the code, and how to get started with the examples provided in this book. Then, you learned that to render a scene with Three.js, you have to create a <strong class="source-inline">THREE.Scene</strong> object and add a camera, a light source, and the objects that you want to render. We also showed you how you can expand this basic scene by adding animations. Lastly, we added a couple of helper libraries. We used <em class="italic">lil-GUI</em>, which allows you to quickly create control UIs, and we added an FPS counter, which provided feedback on the frame rate and other metrics using which your scene <span class="No-Break">is rendered.</span></p>
			<p>All these items will help you understand the examples in upcoming chapters and make it easier for you to experiment with the more advanced examples and start modifying those to your liking. Should stuff break or not result in what you expect in the next few chapters when you experiment, remember what we showed you in this chapter: use the JavaScript console to get additional information, add debug statements, use the helpers provided by Three.js, or add custom <span class="No-Break">control elements.</span></p>
			<p>In the next chapter, we’ll expand on the basic setup shown here and you’ll learn more about the most important building blocks that you can use <span class="No-Break">in Three.js.</span></p>
		</div>
	</body></html>