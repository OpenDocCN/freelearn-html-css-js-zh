<html><head></head><body>
		<div><h1 id="_idParaDest-15" class="chapter-number"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Creating Your First 3D Scene with Three.js</h1>
			<p>In recent years, modern browsers have acquired powerful features that can be accessed directly from <strong class="bold">JavaScript</strong>. You can <a id="_idIndexMarker000"/>easily add video and <a id="_idIndexMarker001"/>audio with <strong class="bold">HTML5 tags</strong> and create interactive components through <a id="_idIndexMarker002"/>the use of <strong class="bold">HTML5 Canvas</strong>. Together with HTML5, modern browsers <a id="_idIndexMarker003"/>also support <strong class="bold">WebGL</strong>. With WebGL, you can directly make use of the processing resources of your graphics card and create high-performance 2D and 3D computer graphics. Using WebGL directly from JavaScript to create and animate 3D scenes is a very complex, verbose, and error-prone <a id="_idIndexMarker004"/>process. <strong class="bold">Three.js</strong> is a library that makes this a lot easier. The following list shows some of the things that are very easy to do with Three.js:</p>
			<ul>
				<li>Create simple and complex 3D geometries and render them in any browser</li>
				<li>Animate and move objects through a 3D scene</li>
				<li>Apply textures and materials to your objects</li>
				<li>Use different light sources to illuminate the scene</li>
				<li>Use models from 3D modeling software and export generated models into these programs</li>
				<li>Add advanced post-processing effects to your 3D scene</li>
				<li>Create and work with custom shaders</li>
				<li>Create, visualize, and <a id="_idIndexMarker005"/>animate <a id="_idIndexMarker006"/>point clouds</li>
				<li>Create <strong class="bold">virtual reality</strong> (<strong class="bold">VR</strong>) and <strong class="bold">augmented reality</strong> (<strong class="bold">AR</strong>) scenes</li>
			</ul>
			<p>With a couple of lines of <a id="_idIndexMarker007"/>JavaScript (or <strong class="bold">TypeScript</strong>, as we’ll see later in this book), you can create anything, from simple 3D models to photorealistic scenes, all of which are rendered in real time in the browser. For instance, <em class="italic">Figure 1</em><em class="italic">.1</em> shows an example of <a id="_idIndexMarker008"/>what can be done with Three.js (you can see the animation for yourself by opening <a href="https://threejs.org/examples/webgl_animation_keyframes.html">https://threejs.org/examples/webgl_animation_keyframes.html</a> in your browser):</p>
			<div><div><img src="img/Figure_1.1_B18726.jpg" alt="Figure 1.1 – Three.js rendered and animated scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1 – Three.js rendered and animated scene</p>
			<p>In this chapter, we’ll directly dive into Three.js and create a couple of examples that will show you how Three.js works, and that you can use to play around with and get to know Three.js a little bit. We won’t dive into all the technical details yet; you'll learn about those in the following chapters. By the end of this chapter, you’ll be able to create a scene, and run and explore all the examples in this book.</p>
			<p>We’ll start this book with a short introduction to Three.js and then quickly move on to the first few examples and code samples. Before we get started, let’s quickly look at the most important browsers out there and their support for WebGL (and WebGPU).</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All modern browsers on desktop, as well as on mobile, currently support WebGL. Older versions of IE (those before version 11) won’t be able to run WebGL-based applications. On mobile, most browsers support WebGL. So, with WebGL, you can create interactive 3D visualizations that run very well on desktops, as well as on mobile devices.</p>
			<p class="callout">In this book, we’ll focus on the WebGL-based renderer provided by Three.js. There is, however, also a CSS 3D-based renderer, which provides an easy API to create CSS 3D-based 3D scenes. A big advantage of using a CSS 3D-based approach is that this standard is supported on all mobile and desktop browsers and allows you to render HTML elements in a 3D space. We won’t go into the details of this browser but will show an example in <a href="B18726_07.xhtml#_idTextAnchor122"><em class="italic">Chapter 7</em></a>, <em class="italic">Points </em><em class="italic">and Sprites</em>.</p>
			<p class="callout">Besides WebGL, a new standard for using the GPU to render in your browser called WebGPU is being developed, which will provide even better performance than WebGL and, in the future, become the new standard. When you use Three.js, you don’t have to worry about this change. Three.js already partly supports WebGPU and as that standard matures, so will the support of this standard in Three.js. So, everything you create with Three.js will also work out of the box with WebGPU.</p>
			<p>In this first chapter, you’ll directly create a 3D scene and be able to run it on a desktop or mobile device. We’ll explain the core concepts of Three.js, and if there are more advanced topics, we’ll mention in what chapter we’ll explain these in more detail. In this chapter, we’ll create two different scenes. The first one will show a basic geometry rendered in Three.js, as shown in the following figure:</p>
			<div><div><img src="img/Figure_1.2_B18726.jpg" alt="Figure 1.2 – Default geometries rendered"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2 – Default geometries rendered</p>
			<p>After that, we’ll also quickly show you how you can load external models, and how easy it is to create realistic-looking scenes. The result of the second example will look like this:</p>
			<div><div><img src="img/Figure_1.3_B18726.jpg" alt="Figure 1.3 – Rendering an externally loaded model"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3 – Rendering an externally loaded model</p>
			<p>Before you start working on these examples, in the next couple of sections, we’ll look at the tools you need to easily work with Three.js and how you can download the examples shown in this book.</p>
			<p>In this chapter, we’ll cover the following topics:</p>
			<ul>
				<li>Requirements for using Three.js</li>
				<li>Downloading the source code and examples used in this book</li>
				<li>Testing and experimenting with the examples</li>
				<li>Rendering and viewing a 3D object</li>
				<li>Introducing a couple of helper libraries for statistics and controlling the scene</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Technical requirements</h1>
			<p>Three.js is a JavaScript <strong class="bold">library</strong>, so all you need to create Three.js WebGL applications is a text editor and one of the supported browsers to render the results. I would like to recommend the following text editors, which I’ve used extensively over the last couple of years for various projects:</p>
			<ul>
				<li><strong class="bold">Visual Studio Code</strong>: This free editor from Microsoft runs on all major platforms <a id="_idIndexMarker009"/>and provides great syntax highlighting and smart completion based on types, function definitions, and imported libraries. It provides a very clean interface and is great for working on JavaScript projects. It can be <a id="_idIndexMarker010"/>downloaded from here: <a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>. If you don’t want to download this editor, you can also just navigate to <a href="https://vscode.dev/">https://vscode.dev/</a>, which will launch an editor directly in your browser, from which you can connect to a GitHub repository or access directories on your local filesystem.</li>
				<li><strong class="bold">WebStorm</strong>: This <a id="_idIndexMarker011"/>editor from <em class="italic">JetBrains</em> offers great support for editing JavaScript. It supports code completion, automatic deployment, and JavaScript debugging, directly from the editor. Besides this, WebStorm has excellent GitHub (and other version control system) support. You can download <a id="_idIndexMarker012"/>a trial edition from <a href="http://www.jetbrains.com/webstorm/">http://www.jetbrains.com/webstorm/</a>.</li>
				<li><strong class="bold">Notepad++</strong>: Notepad++ is <a id="_idIndexMarker013"/>a general-purpose editor that supports code highlighting for a wide range of programming languages. It can easily lay out and format JavaScript. Note that Notepad++ is only for Windows. You can <a id="_idIndexMarker014"/>download Notepad++ from <a href="http://notepad-plus-plus.org/">http://notepad-plus-plus.org/</a>.</li>
				<li><strong class="bold">Sublime Text Editor</strong>: Sublime <a id="_idIndexMarker015"/>is a great editor that offers very good support for editing JavaScript. Besides this, it provides many very helpful selections (such as multi-line select) and edit options, which, once you get used to them, provide a really good JavaScript-editing environment. Sublime <a id="_idIndexMarker016"/>can also be tested for free and can be downloaded from <a href="http://www.sublimetext.com/">http://www.sublimetext.com/</a>.</li>
			</ul>
			<p>Even if you don’t use any of these editors, there are a lot of editors available, both open source and commercial, that you can use to edit JavaScript and create your Three.js projects, since all you need is the ability to edit text. An interesting project you might want to <a id="_idIndexMarker017"/>look at is AWS Cloud9 (<a href="http://c9.io">http://c9.io</a>). This is a cloud-based JavaScript editor that can be connected to a GitHub account. This way, you can directly access all the source code and examples from this book and experiment with them.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Besides these text-based editors, which you can use to edit and experiment with the sources from this book, Three.js currently also provides an online editor.</p>
			<p class="callout">With this editor, which <a id="_idIndexMarker018"/>you can find at <a href="http://threejs.org/editor/">http://threejs.org/editor/</a>, you can create Three.js scenes using a graphical approach.</p>
			<p>I suggest picking up Visual Studio Code. It is a very lightweight editor with great support for JavaScript and has several other extensions that make writing JavaScript applications easier.</p>
			<p>Earlier, I mentioned that most modern web browsers support WebGL and can be used to run Three.js examples. I usually run my code in Firefox. The reason is that, often, Firefox has the best support and performance for WebGL and it has a great JavaScript debugger. With this debugger, as shown in the following screenshot, you can quickly pinpoint problems using, for instance, breakpoints and console output:</p>
			<div><div><img src="img/Figure_1.4_B18726.jpg" alt="Figure 1.4 – Firefox debugger"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4 – Firefox debugger</p>
			<p class="callout-heading">Note</p>
			<p class="callout">All the examples in this book will work just as well with Chrome as they do with Firefox. So, if that’s your browser of choice, you can, of course, use that one instead.</p>
			<p>Throughout this book, I’ll give you pointers on debugger usage and other debugging tips and tricks. That’s enough by way of an introduction for now; let’s get the source code and start with the first scene.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Getting the source code</h2>
			<p>All the <a id="_idIndexMarker019"/>code for this book is available on GitHub (<a href="https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition">https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition</a>). GitHub is a site that hosts Git repositories. You can use these to store, access, and version source code. There are a couple of ways that you can get the sources for yourself. You can do either of the following:</p>
			<ul>
				<li>Clone the Git repository. This means you use the <code>git</code> command-line tool to get the latest version of the sources for this book.</li>
				<li>Download and extract an archive from GitHub, which contains everything.</li>
			</ul>
			<p>In the <a id="_idIndexMarker020"/>following two subsections, we’ll explore these options in a bit more detail.</p>
			<h3>Using git to clone the repository</h3>
			<p>One way to <a id="_idIndexMarker021"/>get all the examples is to <em class="italic">clone</em> this repository using the <code>git</code> command-line tool. To do this, you need to download a Git client for your operating system. If you’ve got an up-to-date operating system, you probably already have Git installed. You can quickly check this by running the following in a terminal:</p>
			<pre class="console">
$ git --version
git version 2.30.1 (Apple Git-130)</pre>
			<p>If the command isn’t installed yet, you can get a client and instructions on how to install it from here: <a href="http://git-scm.com">http://git-scm.com</a>. After installing Git, you can use the <code>git</code> command-line tool to clone this book’s repository. Open a command prompt and go to the directory where you want to download the sources. In that directory, run the following:</p>
			<pre class="console">
$ git clone https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition.
git clone git@github.com:PacktPublishing/Learn-Three.js-Fourth-edition.git
Cloning into 'learning-threejs-fourth'...
remote: Enumerating objects: 96, done.
remote: Counting objects: 100% (96/96), done.
remote: Compressing objects: 100% (85/85), done.
fetch-pack: unexpected disconnect while reading sideband packet
...</pre>
			<p>After doing <a id="_idIndexMarker022"/>this, all the source code will be downloaded into the <code>learning-threejs-fourth</code> directory. From that directory, you can run all the examples explained throughout this book.</p>
			<h3>Downloading and extracting the archive</h3>
			<p>If you don’t <a id="_idIndexMarker023"/>want to use <code>git</code> to download <a id="_idIndexMarker024"/>the sources directly from GitHub, you can also download an archive. Open <a href="https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition">https://github.com/PacktPublishing/Learn-Three.js-Fourth-edition</a> in a browser and click on the <strong class="bold">Code</strong> button on the right-hand side. This will give you the option to download all the sources in a single ZIP file by clicking on the <strong class="bold">Download </strong><strong class="bold">ZIP</strong> option:</p>
			<div><div><img src="img/Figure_1.5_B18726.jpg" alt="Figure 1.5 – Downloading the archive from GitHub"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5 – Downloading the archive from GitHub</p>
			<p>After extracting this to a directory of your choice, all the examples will become available.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You can also download the example code files from your account at <a href="http://www.packtpub.com">http://www.packtpub.com</a> for all the Packt Publishing books you have purchased. If you purchased this book elsewhere, you can visit <a href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files emailed directly to you.</p>
			<p>Now that <a id="_idIndexMarker025"/>you’ve downloaded or cloned the source <a id="_idIndexMarker026"/>code, let’s quickly check whether everything is working and familiarize you with the directory structure.</p>
			<h1 id="_idParaDest-19"><a id="_idTextAnchor018"/>Testing and experimenting with the examples</h1>
			<p>The code and examples are organized per chapter and, with the examples, we will provide a <a id="_idIndexMarker027"/>simple integrated server that you can use to <a id="_idIndexMarker028"/>access all the examples. To get this server up and running, we need to install <em class="italic">Node.js</em> and <em class="italic">npm</em>. These tools are used to manage JavaScript packages and build JavaScript applications and make it easier to modularize our Three.js code and integrate existing JavaScript libraries.</p>
			<p>To install these <a id="_idIndexMarker029"/>two tools, go to <a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a> and select the appropriate installer for your operating system. Once installed, open a terminal and check whether everything is working. On my machine, the following versions are being used:</p>
			<pre class="console">
$ npm --version
8.3.1
$ node --version
v16.14.0</pre>
			<p>Once these tools have been installed, we need to perform a few steps to get all the externally needed dependencies before we can build and access the examples:</p>
			<ol>
				<li>First, we need to download the external libraries used in the examples. For instance, Three.js is one of the dependencies we need to download.</li>
			</ol>
			<p>To download all the dependencies, run the following command in the directory where you downloaded or extracted all the examples:</p>
			<pre class="console">
<strong class="bold">$ npm install</strong>
<strong class="bold">added 570 packages, and audited 571 packages in 21s</strong></pre>
			<p>The preceding command will start downloading all the required JavaScript libraries and store these in the <code>node_modules</code> folder.</p>
			<ol>
				<li value="2">Next, we need <a id="_idIndexMarker030"/>to build the examples. Doing so <a id="_idIndexMarker031"/>will combine our source code and the external libraries into a single file, which we can show in the browser.</li>
			</ol>
			<p>To build the examples using <code>npm</code>, use the following command:</p>
			<pre class="console">
<strong class="bold">$ npm run build</strong>
<strong class="bold">&gt; ltjs-fourth@1.0.0 build</strong>
<strong class="bold">&gt; webpack build</strong>
<strong class="bold">...</strong></pre>
			<p>Note that you only have to run the two preceding commands once.</p>
			<ol>
				<li value="3">With that, all the examples will have been built and are ready for you to explore. To open these examples, you need a web server. To start a server, simply run the following command:<pre class="console">
<strong class="bold">$ npm run serve</strong></pre><pre class="console">
<strong class="bold">&gt; ltjs-fourth@1.0.0 serve</strong></pre><pre class="console">
<strong class="bold">&gt; webpack serve –open</strong></pre><pre class="console">
<strong class="bold">&lt;i&gt; [webpack-dev-server] Project is running at:</strong></pre><pre class="console">
<strong class="bold">&lt;i&gt; [webpack-dev-server] Loopback: http://localhost:8080/</strong></pre><pre class="console">
<strong class="bold">&lt;i&gt; [webpack-dev-server] On Your Network (Ipv4): http://192.168.68.144:8080/</strong></pre><pre class="console">
<strong class="bold">&lt;i&gt; [webpack-dev-server] On Your Network (Ipv6): http://[fe80::1]:8080/</strong></pre><pre class="console">
<strong class="bold">…</strong></pre></li>
			</ol>
			<p>At this point, you’ll probably notice that <code>npm</code> has already opened your default browser and shows <a id="_idIndexMarker032"/>the content of <code>http://localhost:8080</code> (if this isn’t the case, just open your browser of choice and <a id="_idIndexMarker033"/>navigate to <code>http://localhost:8080</code>). You’ll be presented with an overview of all the chapters. In each of these subfolders, you’ll find the examples that are explained in that chapter:</p>
			<div><div><img src="img/Figure_1.6_B18726.jpg" alt="Figure 1.6 – Overview of all the chapters and examples"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.6 – Overview of all the chapters and examples</p>
			<p>One very interesting feature of this server is that we can now see the changes we make to the source code immediately reflected in the browser. If you have started the server by running <code>npm run serve</code>, open up the <code>chapter-01/geometries.js</code> example from the sources you’ve downloaded in your editor and change something; you’ll see <a id="_idIndexMarker034"/>that this is also changed at the same time in <a id="_idIndexMarker035"/>your browser after you have saved the change. This makes testing changes and fine-tuning colors and lights much easier. If you open the <code>chapter-01/geometries.js</code> file in your code editor, and you open the <code>http://localhost:8080/chapter-01/geometries.html</code> example in your browser, you can see this in action. In your editor, change the color of the cube. To do so, find the following code:</p>
			<pre class="source-code">
initScene(props)(({ scene, camera, renderer, orbitControls }) =&gt; {
  const geometry = new THREE.BoxGeometry();
  const cubeMaterial = new THREE.MeshPhongMaterial({
    color: 0xFF0000,
  });</pre>
			<p>Change it to the following:</p>
			<pre class="source-code">
initScene(props)(({ scene, camera, renderer, orbitControls }) =&gt; {
  const geometry = new THREE.BoxGeometry();
  const cubeMaterial = new THREE.MeshPhongMaterial({
    color: 0x0000FF,
  });</pre>
			<p>Now, when you save the file, you’ll immediately see that the color of the cube in the browser changes, without you having to refresh the browser or do anything else.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The setup we’re working with in this book is one of many different approaches you can use to develop web applications. Alternatively, you can include Three.js (and other libraries) directly in your HTML file or use an approach with <code>import-maps</code>, as is done with the example on the Three.js website. All of these have advantages and disadvantages. For this book, we’ve chosen an approach that makes it easy to experiment with the sources and get direct feedback in the browser, and closely resembles how these kinds of applications are built normally.</p>
			<p>A good starting <a id="_idIndexMarker036"/>point to understand how everything <a id="_idIndexMarker037"/>works together is by looking at the HTML file that we opened in the browser.</p>
			<h1 id="_idParaDest-20"><a id="_idTextAnchor019"/>Exploring the HTML structure for Three.js applications</h1>
			<p>In this section, we’ll look at the source of the <code>geometries.html</code> file. You can do this by looking <a id="_idIndexMarker038"/>at the source in the browser <a id="_idIndexMarker039"/>or opening the file from the <code>dist/chapter-1</code> folder in the same location where you downloaded the source for this book:</p>
			<pre class="source-code">
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;style&gt;
    body {
      margin: 0;
    }
  &lt;/style&gt;
  &lt;script defer src="../js/vendors-node_modules_three_
    build_three_module_js.js"&gt;&lt;/script&gt;
  &lt;script defer src="../js/vendors-node_modules_lil-gui_
    dist_lil-gui_esm_js.js"&gt;&lt;/script&gt;
  &lt;script defer src="../js/vendors-node_modules_three_
    examples_jsm_controls_OrbitControls_js.js"&gt;&lt;/script&gt;
  &lt;script defer src="img/geometries.js"&gt;&lt;/script&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;/body&gt;
&lt;/html&gt;</pre>
			<p>This code <a id="_idIndexMarker040"/>is generated when you run the <code>npm run build</code> step. This will combine all the sources and external libraries you’ve <a id="_idIndexMarker041"/>used into separate source files (called bundles) and add them to this page. So, you don’t need to do this yourself. The first three <code>&lt;script&gt;</code> tags refer to any of the external libraries we use. Later in the book, we’ll introduce <a id="_idIndexMarker042"/>other libraries such as <code>&lt;style&gt;</code> and <code>&lt;body&gt;</code>. <code>&lt;style&gt;</code> is used to disable any margins in the page, so we can use the complete browser viewport to show our 3D scenes. Furthermore, we’ll add the 3D scene programmatically into an empty <code>&lt;body&gt;</code> element, which we’ll explain in the next section.</p>
			<p>If you do want to add custom HTML elements here, you can, of course, do that. In the root of the downloaded code, you’ll find a <code>template.html</code> file, which is used by the build process to create the individual HTML files for the examples. Anything you add there will be added to all the examples. We won’t dive too deep into how this works since that’s outside the scope of this book. However, if you want to learn more about how this works, a couple of good resources on <em class="italic">webpack</em> (which we use for this) are as follows:</p>
			<ul>
				<li>The getting <a id="_idIndexMarker044"/>started with webpack guide: <a href="https://webpack.js.org/guides/getting-started/">https://webpack.js.org/guides/getting-started/</a>. This site contains a tutorial that explains the reason why we need webpack for JavaScript development, and how the basic concepts work.</li>
				<li>Information <a id="_idIndexMarker045"/>on the <em class="italic">HTML webpack plugin</em>: <a href="https://github.com/jantimon/html-webpack-plugin">https://github.com/jantimon/html-webpack-plugin</a>. Here, you can find information on the webpack plugin we use to combine the sources into the separate HTML pages you see when you open the browser after running <code>npm run build</code> and then running <code>npm </code><code>run serve</code>.</li>
			</ul>
			<p>Note that <a id="_idIndexMarker046"/>we don’t have to explicitly <a id="_idIndexMarker047"/>initialize our scene or call JavaScript. Whenever we open this page and the <code>geometries.js</code> file is loaded, the JavaScript from that file will run and create our 3D scene.</p>
			<p>Now that we’ve set up the basic structure, we can create and render our first scene.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor020"/>Rendering and viewing a 3D object</h1>
			<p>In this <a id="_idIndexMarker048"/>section, you’ll create your first scene, which is a simple <a id="_idIndexMarker049"/>3D scene that looks like this:</p>
			<div><div><img src="img/Figure_1.8_B18726.jpg" alt="Figure 1.7 – First scene with two standard geometries"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.7 – First scene with two standard geometries</p>
			<p>In the <a id="_idIndexMarker050"/>preceding screenshot, you can see two objects that rotate. These <a id="_idIndexMarker051"/>objects are called <em class="italic">meshes</em>. A mesh <a id="_idIndexMarker052"/>describes the geometry of an object – that is, its shape – and contains information about the material of the object. A mesh determines how the shape gets shown on screen through traits such as color, or whether the object is shiny or transparent.</p>
			<p>In the previous screenshot, we can identify three of these meshes:</p>
			<table id="table001-1" class="No-Table-Style">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><strong class="bold">Object</strong></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p><strong class="bold">Description</strong></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><strong class="bold">Plane</strong></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>This is a two-dimensional rectangle that serves as the ground area. In <em class="italic">Figure 1</em><em class="italic">.7</em>, you can see this since it shows the shadows cast by the two meshes. We will create this as a very large rectangle so that you don’t see any edges.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><strong class="bold">Cube</strong></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>This is a three-dimensional cube and is shown on the left of <em class="italic">Figure 1</em><em class="italic">.7</em>. It is rendered in <em class="italic">red</em>.</p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style T---Body">
							<p><strong class="bold">Torus knot</strong></p>
						</td>
						<td class="No-Table-Style T---Body">
							<p>This is the <em class="italic">TorusKnot</em> you can see to the right of <em class="italic">Figure 1</em><em class="italic">.7</em>. This one is rendered in <em class="italic">green</em>.</p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.8 – Overview of the objects in the scene</p>
			<p>To get all <a id="_idIndexMarker053"/>this on screen, we need to perform a couple of steps, which <a id="_idIndexMarker054"/>we’ll explain in the upcoming sections.</p>
			<h2 id="_idParaDest-22"><a id="_idTextAnchor021"/>Setting up the scene</h2>
			<p>Each Three.js application at least needs a camera, a scene, and a renderer. The scene is the container <a id="_idIndexMarker055"/>that holds all the objects (meshes, cameras, and lights), the camera determines what part of the scene is shown when it is rendered, and the renderer takes care of creating the output on the screen, taking into account all the information from the meshes, cameras, and lights in the scene.</p>
			<p>All the code we’ll be discussing can be found in the <code>chapter-1/getting-started.js</code> file. The basic structure of this file is as follows:</p>
			<pre class="source-code">
import * as THREE from "three";
import Stats from 'three/examples/jsm/libs/stats.module'
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls'
// create a scene
...
// setup camera
...
// setup the renderer and attach to canvas
...
// add lights
...
// create a cube and torus knot and add them to the scene
...
// create a very large ground plane
...
// add orbitcontrols to pan around the scene using the
   mouse
...
// add statistics to monitor the framerate
...
// render the scene</pre>
			<p>If you look through the preceding steps, you might have noticed that a lot of these steps are the same <a id="_idIndexMarker056"/>for each scene you create. Since we’ve got a lot of examples in this book that show different features of Three.js, we’ll extract this code into a couple of helper files. We’ll show how we did this at the end of this chapter. For now, we will walk through the different steps and introduce you to the basic components of a Three.js scene.</p>
			<p>First, we must create a <code>THREE.Scene</code>. This is a basic container that will hold all of the meshes, lights, and cameras and has a couple of simple properties, which we’ll explore in more depth in the next chapter:</p>
			<pre class="source-code">
// basic scene setup
const scene = new THREE.Scene();
scene.backgroundColor = 0xffffff;
scene.fog = new THREE.Fog(0xffffff, 0.0025, 50);</pre>
			<p>Here, we will create the container object that will hold all our objects, set the background color of this scene to white (<code>0xffffff</code>), and enable the fog effect in this scene. With fog enabled, objects further away from the camera will slowly get hidden by fog.</p>
			<p>The next step is creating the camera and the renderer:</p>
			<pre class="source-code">
// setup camera and basic renderer
const camera = new THREE.PerspectiveCamera(
  75,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.x = -3;
camera.position.z = 8;
camera.position.y = 2;
// setup the renderer and attach to canvas
const renderer = new THREE.WebGLRenderer({ antialias: true
  });
renderer.outputEncoding = THREE.sRGBEncoding;
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.VSMShadowMap;
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.setClearColor(0xffffff);
document.body.appendChild(renderer.domElement);</pre>
			<p>In the <a id="_idIndexMarker057"/>preceding code, we created a <code>PerspectiveCamera</code>, which determines what part of the scene is rendered. Don’t worry too much about the parameters at this point, since we’ll discuss those in detail in <a href="B18726_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>, <em class="italic">Working with Light Sources in Three.js</em>. We also positioned the camera at the specified <em class="italic">x-</em>, <em class="italic">y-</em>, and <em class="italic">z-</em>oordinates. The camera will, by default, look at the center of the scene (which is <code>0</code>, <code>0</code>, <code>0</code>), so we don’t need to change anything for that.</p>
			<p>In this code fragment, we also created a <code>WebGLRenderer</code>, which we will use to render the view from the camera on the scene. Ignore the other properties for now; we’ll explain these <a id="_idIndexMarker058"/>in the next few chapters when we dive into the details of <code>WebGLRenderer</code> and how you can fine-tune the colors and work with shadows. One interesting part to notice is <code>document.body.appendChild(renderer.domElement)</code>. This step adds an HTML <code>canvas</code> element to the page, which shows the output of the renderer. You can see this when you inspect the page in your browser:</p>
			<div><div><img src="img/Figure_1.9_B18726.jpg" alt="Figure 1.9 – Canvas added by Three.js"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.9 – Canvas added by Three.js</p>
			<p>At this point, we’ve got an empty <code>THREE.Scene</code>, a <code>THREE.PerspectiveCamera</code>, and a <code>THREE.WebGLRenderer</code>. If we add some objects to the scene, we can already show some output on the screen. Before we do this, though, we’ll add a couple of additional components:</p>
			<ul>
				<li><strong class="bold">OrbitControls</strong>: This will <a id="_idIndexMarker059"/>allow you to use the mouse to rotate and pan around the scene</li>
				<li><strong class="bold">Lights</strong>: This allows <a id="_idIndexMarker060"/>us to use some more advanced materials, cast shadows, and generally make our scene look better</li>
			</ul>
			<p>In the next section, we’ll first add the lights.</p>
			<h2 id="_idParaDest-23"><a id="_idTextAnchor022"/>Adding lights</h2>
			<p>If we don’t <a id="_idIndexMarker061"/>have lights in the scene, most materials will be rendered in black. So, to see our meshes (and get shadows), we’re going to add some lights to the scene. In this case, we’re going to add two lights:</p>
			<ul>
				<li><code>THREE.AmbientLight</code>: This is <a id="_idIndexMarker062"/>just a simple light that affects everything with the same intensity and color.</li>
				<li><code>THREE.DirectionalLight</code>: This <a id="_idIndexMarker063"/>is a light source whose rays are cast in parallel to one another. This is pretty much how we experience the light of the Sun.</li>
			</ul>
			<p>The following code fragment shows how to do this:</p>
			<pre class="source-code">
// add lights
scene.add(new THREE.AmbientLight(0x666666))
const dirLight = new THREE.DirectionalLight(0xaaaaaa)
dirLight.position.set(5, 12, 8)
dirLight.castShadow = true
// and some more shadow related properties</pre>
			<p>And once again, these lights can be configured in various ways, the details of which we’ll explain in <a href="B18726_03.xhtml#_idTextAnchor040"><em class="italic">Chapter 3</em></a>. At this point, we’ve got all the components ready to render a scene, so let’s add the meshes.</p>
			<h2 id="_idParaDest-24"><a id="_idTextAnchor023"/>Adding the meshes</h2>
			<p>In the <a id="_idIndexMarker064"/>following code fragment, we create the three meshes in our scene:</p>
			<pre class="source-code">
// create a cube and torus knot and add them to the scene
const cubeGeometry = new THREE.BoxGeometry();
const cubeMaterial = new THREE.MeshPhongMaterial({ color:
  0x0000FF });
const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
cube.position.x = -1;
cube.castShadow = true;
scene.add(cube);
const torusKnotGeometry = new THREE.TorusKnotBufferGeometry(0.5, 0.2, 100, 100);
const torusKnotMat = new THREE.MeshStandardMaterial({
  color: 0x00ff88,
  roughness: 0.1,
});
const torusKnotMesh = new THREE.Mesh(torusKnotGeometry, torusKnotMat);
torusKnotMesh.castShadow = true;
torusKnotMesh.position.x = 2;
scene.add(torusKnotMesh);
// create a very large ground plane
const groundGeometry = new THREE.PlaneBufferGeometry(10000,
  10000)
const groundMaterial = new THREE.MeshLambertMaterial({
  color: 0xffffff
})
const groundMesh = new THREE.Mesh(groundGeometry, groundMaterial)
groundMesh.position.set(0, -2, 0)
groundMesh.rotation.set(Math.PI / -2, 0, 0)
groundMesh.receiveShadow = true
scene.add(groundMesh)
);</pre>
			<p>Here, we have <a id="_idIndexMarker065"/>created a cube, a torus knot, and the ground. All these meshes follow the same idea:</p>
			<ol>
				<li value="1">We create the shape – that is, the geometry of the objects: a <code>THREE.BoxGeometry</code>, a <code>THREE.TorusKnotBufferGeometry</code>, and a <code>THREE.PlaneBufferGeometry</code>.</li>
				<li>We create the material. In this case, we use a <code>THREE.MeshPhongMaterial</code> for the cube, a <code>THREE.MeshStandardMaterial</code> for the torus knot, and a <code>THREE.MeshLambertMaterial</code> for the ground. The color of the cube is blue, the color of the torus knot is greenish, and the color of the ground is white. In <a href="B18726_04.xhtml#_idTextAnchor056"><em class="italic">Chapter 4</em></a>, <em class="italic">Working with Three.js Materials</em>, we’re going to explore all these materials, where they can best be used, and how to configure them.</li>
				<li>We tell Three.js that the cube and the torus knot cast shadows and that the ground will receive shadows.</li>
				<li>Finally, from the shape and the material, we create a <code>THREE.Mesh</code>, position the mesh, and add it to the scene.</li>
			</ol>
			<p>At this point, we just have to call <code>renderer.render(scene, camera)</code>. You will see the result on your screen:</p>
			<div><div><img src="img/Figure_1.10_B18726.jpg" alt="Figure 1.10 – Geometries renderer – static"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.10 – Geometries renderer – static</p>
			<p>If you’ve <a id="_idIndexMarker066"/>got the source file (<code>chapter-01/getting-started.js</code>), open it in your editor; now is also a good time to experiment a bit with the settings. By changing the <code>torusKnot.postion.x</code>, <code>torusKnot.position.y</code>, and <code>torusKnot.position.z</code> settings, you can move the torus knot around the scene (changes are applied after you save the file in the editor). You can also easily change the color of the meshes by changing the <code>color</code> property of the materials.</p>
			<h2 id="_idParaDest-25"><a id="_idTextAnchor024"/>Adding an animation loop</h2>
			<p>At this point, the scene is very static. You can’t move the camera around, and nothing is moving. If we <a id="_idIndexMarker067"/>want to animate the scene, the first thing that we need to do is find some way to re-render the scene at a specific interval. Before HTML5 and the related JavaScript APIs came along, the way to do this was by using the <code>setInterval(function,interval)</code> function. With <code>setInterval</code>, we could specify a function that, for instance, would be called every 100 milliseconds. The problem with this function is that it doesn’t take into account what is happening in the browser. If you were browsing another tab, this function would still be fired every couple of milliseconds. Besides that, <code>setInterval</code> isn’t synchronized <a id="_idIndexMarker068"/>when the the screen is redrawn. This can lead to higher CPU usage, flickering, and generally poor performance.</p>
			<p>Luckily, modern browsers have a solution for that with the <code>requestAnimationFrame</code> function.</p>
			<h3>Introducing requestAnimationFrame</h3>
			<p>With <code>requestAnimationFrame</code>, you can specify a function that is called at an interval. However, you <a id="_idIndexMarker069"/>don’t define this interval. This <a id="_idIndexMarker070"/>interval is defined by the browser. You do any drawing you need to do in the supplied function, and the browser will make sure it is painted as smoothly and efficiently as possible. Using this is simple. We just add the following code:</p>
			<pre class="source-code">
function animate() {
  requestAnimationFrame(animate);
  renderer.render(scene, camera);
}
animate();</pre>
			<p>In the preceding <code>animate</code> function, we called <code>requestAnimationFrame</code> again, to keep the animation going. The only thing we need to change in the code is that instead of calling <code>renderer.render</code> after we’ve created the complete scene, we call the <code>animate()</code> function once to initiate the animation. If you run this, you won’t see any changes yet compared to the previous example because we haven’t changed anything in this <code>animate()</code> function. Before we add additional functionality to this function though, we will introduce a <a id="_idIndexMarker071"/>small helper library called <strong class="bold">stats.js</strong>, which gives us information about the frame rate the animation is running at. This library, from the same author as Three.js, renders a small graph that shows us information about the rate at which the scene is rendered.</p>
			<p>To add these statistics, all we need to do is import the correct module and add it to our page:</p>
			<pre class="source-code">
import Stats from 'three/examples/jsm/libs/stats.module'
const stats = Stats()
document.body.appendChild(stats.dom)</pre>
			<p>If you leave <a id="_idIndexMarker072"/>it at this, you’ll see a nice stats counter <a id="_idIndexMarker073"/>in the top left of your screen, but nothing will happen. The reason is that we need to tell this element when we’re in the <code>requestAnimationFrame</code> loop. For this, we just need to add the following to our <code>animate</code> function:</p>
			<pre class="source-code">
function animate() {
  requestAnimationFrame(animate);
  stats.update();
  renderer.render(scene, camera);
}
animate();</pre>
			<p>If you <a id="_idIndexMarker074"/>open the <code>chapter-1/getting-started.html</code> example, you’ll see that it shows a <strong class="bold">frames per second</strong> (<strong class="bold">FPS</strong>) counter in the top left of your screen:</p>
			<div><div><img src="img/Figure_1.11_B18726.jpg" alt="Figure 1.11 – FPS statistics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.11 – FPS statistics</p>
			<p>In the <code>chapter-1/getting-started.html</code> example, you can already see that the torus <a id="_idIndexMarker075"/>knot and cube are moving around <a id="_idIndexMarker076"/>their axes. In the following section, we’ll explain how you do this by extending the <code>animate()</code> function.</p>
			<h3>Animating the meshes</h3>
			<p>With <code>requestAnimationFrame</code> and <a id="_idIndexMarker077"/>the statistics <a id="_idIndexMarker078"/>configured, we’ve got a place to put our animation code. All we need to do is add this to the <code>animate()</code> function:</p>
			<pre class="source-code">
cube.rotation.x += 0.01;
cube.rotation.y += 0.01;
cube.rotation.z += 0.01;
torusKnotMesh.rotation.x -= 0.01;
torusKnotMesh.rotation.y += 0.01;
torusKnotMesh.rotation.z -= 0.01;</pre>
			<p>That looks simple, right? What we do is increase the rotation property of each of the axes by 0.01 every time the <code>animate()</code> function is called, which shows up as the meshes <a id="_idIndexMarker079"/>smoothly rotating around all of their axes. If we <a id="_idIndexMarker080"/>change the position instead of the rotation around the axes, we can move the meshes around:</p>
			<pre class="source-code">
let step = 0;
animate() {
  ...
  step += 0.04;
  cube.position.x = 4*(Math.cos(step));
  cube.position.y = 4*Math.abs(Math.sin(step));
  ...
}</pre>
			<p>With the cube, we have already changed the <code>rotation</code> property; now, we’re also going to change its <code>position</code> property in the scene. We want the cube to bounce from one point in the scene to another with a nice, smooth curve. For this, we need to change its position on the <em class="italic">X</em>-axis, as well as the <em class="italic">y</em>-axis. The <code>Math.cos</code> and <code>Math.sin</code> functions help us create a smooth trajectory using the <code>step</code> variable. I won’t go into the details of how this works here. For now, all you need to know is that <code>step+=0.04</code> defines the speed of the bouncing sphere. If you want to enable this for yourself, open up the <code>chapter-1/geometries.js</code> file and uncomment the section from the <code>animate()</code> function. Once you’ve done this, you’ll see something like this on screen, where the blue cube is dancing around the scene:</p>
			<div><div><img src="img/Figure_1.12_B18726.jpg" alt="Figure 1.12 – Jumping blue cube"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.12 – Jumping blue cube</p>
			<h3>Enabling orbit controls</h3>
			<p>If you try and move the scene around with your mouse, nothing much will happen. That is because <a id="_idIndexMarker081"/>we added the camera to a fixed position, and we didn’t update its position in the animate loop. We can, of course, do this in the same manner as <a id="_idIndexMarker082"/>we did to the position of the cube, but Three.js comes with several <em class="italic">controls</em> that allow you to easily pan around the scene and move the camera around. For this example, we’ll introduce <code>THREE.OrbitControls</code>. With these controls, you can use your mouse to move the camera around the scene and look at different objects. All we need to do to get this working is create a new instance of these controls, attach them to the camera, and call the <code>update</code> function from our animation loop:</p>
			<pre class="source-code">
const orbitControls = new OrbitControls(camera, renderer.
  domElement)
// and the controller has a whole range of other properties we can set
function animate() {
  ...
  orbitControls.update();
}</pre>
			<p>Now, you can <a id="_idIndexMarker083"/>use your mouse to navigate around the scene. This <a id="_idIndexMarker084"/>is already enabled in the <code>chapter-1/getting-started.html</code> example:</p>
			<div><div><img src="img/Figure_1.13_B18726.jpg" alt="Figure 1.13 – Zoom﻿ing in with orbit controls"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.13 – Zooming in with orbit controls</p>
			<p>Before wrapping up this section, we will add one more element to our basic scene. When <a id="_idIndexMarker085"/>working with 3D scenes, animations, colors, and properties, it often <a id="_idIndexMarker086"/>requires a bit of experimenting to get the correct color, animation speed, or material property. It would be very easy if you had a simple <strong class="bold">GUI</strong> that allowed you to change these kinds of properties on the fly. Luckily, you do!</p>
			<h2 id="_idParaDest-26"><a id="_idTextAnchor025"/>Using lil-gui to control properties and make experimenting easier</h2>
			<p>In the <a id="_idIndexMarker087"/>previous example, we added <a id="_idIndexMarker088"/>a little bit of animation for the torus knot and the cube. Now, we’ll create a simple UI element that allows us to control the speed of the rotations and the movement. For this, we’re going to use the <code>lil-gui</code> library <a id="_idIndexMarker089"/>from <a href="https://lil-gui.georgealways.com/">https://lil-gui.georgealways.com/</a>. This library allows us to quickly create a simple control UI to make experimenting with the scene easier. It can be added as follows:</p>
			<pre class="source-code">
import GUI from "lil-gui";
...
const gui = new GUI();
const props = {
  cubeSpeed: 0.01,
  torusSpeed: 0.01,
};
gui.add(props, 'cubeSpeed', -0.2, 0.2, 0.01)
gui.add(props, 'torusSpeed', -0.2, 0.2, 0.01)
function animate() {
  ...
  cube.rotation.x += props.cubeSpeed;
  cube.rotation.y += props.cubeSpeed;
  cube.rotation.z += props.cubeSpeed;
  torusKnotMesh.rotation.x -= props.torusSpeed;
  torusKnotMesh.rotation.y += props.torusSpeed;
  torusKnotMesh.rotation.z -= props.torusSpeed;
  ...
}</pre>
			<p>In the preceding code fragment, we created a new control element (<code>new GUI</code>) and configured two controls: <code>cubeSpeed</code> and <code>torusSpeed</code>. In each animation step, we’ll just look <a id="_idIndexMarker090"/>up the current values <a id="_idIndexMarker091"/>and use those to rotate the meshes. Now, we can experiment with the properties without having to switch between the browser and the editor. You’ll see this UI in most of the examples in this book where we provide it so that you can easily play around with the different options provided by the materials, the lights, and the other Three.js objects. In the following screenshot, you can see the controls you can use to control the scene in the top-right part of the screen:</p>
			<div><div><img src="img/Figure_1.14_B18726.jpg" alt="Figure 1.14 – Using controls to modify the properties of the scene"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.14 – Using controls to modify the properties of the scene</p>
			<p>Before we move on to the last section of this chapter, here’s a quick note on what we’ve shown so far. You can imagine that most scenes will need pretty much the same setup. They all <a id="_idIndexMarker092"/>need some lights, a camera, a scene, and maybe a ground floor. To avoid having to add all this to each example, we’ve <a id="_idIndexMarker093"/>externalized most of these common elements to a set of helper libraries. That way, we can keep the examples nice and clean so that they only show you the code relevant to that example. If you’re interested in how that’s set up, you can look at the files from the <code>bootstrap</code> folder, which brings this approach together.</p>
			<p>In the previous example, we rendered some simple meshes in the scene and positioned them directly. Sometimes, though, it is hard to determine where to position objects, or how far we should rotate them. Three.js provides several different helpers that provide you with additional information about the scene. In the next section, we’ll look at a couple of these helper functions.</p>
			<h1 id="_idParaDest-27"><a id="_idTextAnchor026"/>Helper objects and util functions</h1>
			<p>Before we move on to the next chapter, we’re going to quickly introduce a couple of helper functions <a id="_idIndexMarker094"/>and objects. These helpers make it easier to position <a id="_idIndexMarker095"/>objects and see what is happening in a scene. The easiest way to see this in action is to open the <code>chapter-01/porsche.html</code> example in your browser:</p>
			<div><div><img src="img/Figure_1.15_B18726.jpg" alt="Figure 1.15 – Porsche example with helper"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.15 – Porsche example with helper</p>
			<p>On the right-hand side of the screen, at the bottom of the menu, you will see three buttons in the controls: <strong class="bold">Toggle AxesHelper</strong>, <strong class="bold">Toggle GridHelper</strong>, and <strong class="bold">Toggle PolarGridHelper</strong>. When you click on any of them, Three.js will add an overlay to the screen that can help you orient and position meshes, determine needed rotations, and check the sizes of your objects. For instance, when we toggle <strong class="bold">AxesHelper</strong>, we will see the <em class="italic">x-</em>, <em class="italic">y-</em>, and <em class="italic">z-a</em>xes in the scene:</p>
			<div><div><img src="img/Figure_1.16_B18726.jpg" alt="Figure 1.16 – Porsche example with AxesHelper enabled"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.16 – Porsche example with AxesHelper enabled</p>
			<p>Note that <a id="_idIndexMarker096"/>in this example, you can see a more extensive control UI, where <a id="_idIndexMarker097"/>you can also control various aspects of <code>WebGLRenderer</code>.</p>
			<h1 id="_idParaDest-28"><a id="_idTextAnchor027"/>Summary</h1>
			<p>That’s it for this first chapter. In this chapter, you learned how to set up your development environment, how to get the code, and how to get started with the examples provided in this book. Then, you learned that to render a scene with Three.js, you have to create a <code>THREE.Scene</code> object and add a camera, a light source, and the objects that you want to render. We also showed you how you can expand this basic scene by adding animations. Lastly, we added a couple of helper libraries. We used <em class="italic">lil-GUI</em>, which allows you to quickly create control UIs, and we added an FPS counter, which provided feedback on the frame rate and other metrics using which your scene is rendered.</p>
			<p>All these items will help you understand the examples in upcoming chapters and make it easier for you to experiment with the more advanced examples and start modifying those to your liking. Should stuff break or not result in what you expect in the next few chapters when you experiment, remember what we showed you in this chapter: use the JavaScript console to get additional information, add debug statements, use the helpers provided by Three.js, or add custom control elements.</p>
			<p>In the next chapter, we’ll expand on the basic setup shown here and you’ll learn more about the most important building blocks that you can use in Three.js.</p>
		</div>
	</body></html>