<html><head></head><body>
		<div><h1 class="chapter-number" id="_idParaDest-15"><a id="_idTextAnchor014"/>1</h1>
			<h1 id="_idParaDest-16"><a id="_idTextAnchor015"/>Introduction to Microservices</h1>
			<p>As human beings, we all go through various stages of development. With each stage we reach, even if it seems like the best at the time, we later realize we still have a long way to go. Each period has its problems, and depending on their size and nature, they require different solutions. </p>
			<p>We humans tend to simplify things. That is why we build our lives around problems and their corresponding solutions. Finding solutions to problems has been our main goal throughout history, perhaps due to our instinct to survive.</p>
			<p>If we consider each piece of software as an individual, they also have problems to solve. Depending on the size and shape of the problems, software has a different structure, which we call <strong class="bold">architecture</strong>. The size and nature of the problems directly affect the architecture of the software. One of these architectural approaches we use is called microservices.</p>
			<p><strong class="bold">Microservices</strong> are important <a id="_idIndexMarker000"/>when it comes to building scalable distributed applications that respond to modern-day concerns. It is also a de facto requirement for most huge companies when they interview you as a developer. The vast majority of technologies we use nowadays try to support microservice development out of the box. So, being a software engineer without microservice knowledge doesn’t make you an ideal candidate in the modern IT world.</p>
			<p>Starting from this chapter, we’re going to dive into the world of microservices. We will build strong theoretical knowledge before moving on to practical sections.</p>
			<p>First, we will go back and try to understand what type of popular approaches were there before microservices. Microservices are important, but understanding the need to apply them is foremost.</p>
			<p>In this chapter, we’re going to cover the following topics:</p>
			<ul>
				<li>Introducing microservices</li>
				<li>Exploring the monolith approach</li>
				<li>What is service-oriented architecture?</li>
				<li>The differences between SOA and microservices</li>
				<li>Advantages of microservices</li>
				<li>Disadvantages of microservices</li>
			</ul>
			<h1 id="_idParaDest-17"><a id="_idTextAnchor016"/>Introducing microservices</h1>
			<p>A microservice architecture<a id="_idIndexMarker001"/> decomposes an application into loosely coupled, independently deployable services that own their data and communicate through lightweight protocols. It breaks down large applications into smaller, self-contained business capabilities, enabling faster development, easier scaling, and better fault tolerance. Microservices enable continuous delivery and agile development by allowing teams to independently build, test, and deploy features. You can imagine an application as an orchestra, where each microservice is a musician playing their part, but in perfect harmony with the others, to create a beautiful symphony.</p>
			<p>What we’ve just mentioned sounds like a <em class="italic">silver bullet</em> but as you know, nothing is free and there is no one-size-fits-all solution to the problems we face. The same applies to microservices.</p>
			<p>We, as software developers, love to learn new trends and try to apply them to our practice. But after delving into the details, we understand that every trend is just an encapsulation of old knowledge. Before applying any architecture to software, it is always better to engage in careful planning, discussion, collaboration, and analysis.</p>
			<h2 id="_idParaDest-18"><a id="_idTextAnchor017"/>Moving toward microservices</h2>
			<p>Creating software is more<a id="_idIndexMarker002"/> than just learning a programming language and applying syntactical elements of it to code, to build things. It’s like wielding a hammer and nails; having them in your arsenal doesn’t make you a skilled builder. Similarly, having all the tools doesn’t make you a good software developer.</p>
			<p>As you embark on creating a basic <code>hello world</code> type application, it remains just that – <em class="italic">basic</em>. However, it is important to understand that such simple applications don’t warrant payment. If you want your application to have value, it must address tangible real-world challenges – in short, it should hold business value. Adding more business value also brings complexity. In most cases, more business means more complexity. After some time, you’ll realize that instead of dealing with a business, you’re starting to deal with the complexity that your business brought to your application.</p>
			<p>In navigating complexity, we aim to<a id="_idIndexMarker003"/> break it down into smaller, maintainable, extensible, and reusable components. Only by doing so can we effectively handle the complexity and future changes. In programming, the only true constant is the need to embrace changes, a principle that remains as-is, not just during the process of creating the application, but until the end.</p>
			<p>This constant change forces us to not only master the selected programming language but also to have an understanding of the business domain. Naturally, this leads to us adopting a design-oriented mindset. Without having good knowledge of business, it is almost impossible to develop valuable software.</p>
			<p>Although the simple applications we write to learn a language may seem useless, when we connect the dots, we get closer to the truth. Isn’t our whole life spent in search of truth? Soon, you’ll realize that the software that meets the customer’s business requirements is the software that matters, and that reflects the truth.</p>
			<p>If you start your development process without carefully analyzing and designing, you’re going to pay a higher price throughout the development itself. The earlier you start with design and analysis, the less likely you are to run into a bigger problem at a later stage. We call our first not properly analyzed and designed application <strong class="bold">a big ball of mud</strong> that uses <em class="italic">spaghetti-driven development</em>:</p>
			<p>In software design, the phrase <em class="italic">a big ball of mud</em> is used to <a id="_idIndexMarker004"/>draw attention to an <strong class="bold">anti-pattern</strong> or a design approach that produces undesirable results. Let’s understand this phrase in more depth.</p>
			<h2 id="_idParaDest-19"><a id="_idTextAnchor018"/>Understanding a big ball of mud</h2>
			<p>The main issue with a big ball of mud is the lack of structure and organization. The absence of modularity and distinct issue <a id="_idIndexMarker005"/>separation in the code base leads to a complex network of interconnected files and functions. Imagine a house that is just a <a id="_idIndexMarker006"/>disorganized jumble of rooms and materials with no walls or other distinguishing features. Because everything in it is connected, changes that are made in one part could have a disastrous effect on other parts. It’s like pulling on a loose thread in a badly tailored sweater – you run the risk of the entire garment coming apart. Similarly code fragments are dispersed throughout the code base, which causes inefficiencies when performing maintenance.</p>
			<p>Due to the absence of structure and documentation, maintaining the code base and adding new features is challenging for developers. Imagine attempting to navigate a house devoid of layout or<a id="_idIndexMarker007"/> labels; it’s nearly impossible.</p>
			<p>Because of their close coupling, changes in one area can unintentionally disturb seemingly unrelated components. Because of its fragility, the software is prone to mistakes and regressions. Imagine a house built with weak, interconnected supports so that even a small outside force could result in serious harm.</p>
			<p>A big ball of mud may<a id="_idIndexMarker008"/> seem like the right choice at first in small, simple projects, but as the project grows and develops, its complexity quickly increases. To guarantee long-term maintainability, scalability, and developer satisfaction, this design approach must be avoided at all costs.</p>
			<p>Guess what? I already know that you’ve gone through this stage – the stage of applying and failing with a big ball of mud. These difficulties helped you learn more rather than learn from success.</p>
			<p>Every difficulty teaches us something, right? Until one year in my life, I was always grateful for the good things in my life. But over time, I realized that it was those difficulties that made me who I am. After I changed my way of thinking, I began to thank the difficulties in my life and those who made me suffer. If you could go back and remove the difficulties in your life, believe me, you would also remove your present self. Difficulties strengthen you and make you a strong person.</p>
			<p>Mankind is a creature that rarely listens to advice. We have to get into trouble – we have to experiment with trouble. I know that the downsides I mentioned about a big ball of mud in this section only make sense to those who have gone through this difficulty. In the end, we all learn through experimenting.</p>
			<p>As a novice software developer, it’s beneficial to experiment with a big ball of mud at some point. You’ll quickly discover that while it provides a swift start, its efficiency dwindles over time.</p>
			<p>Let’s try to summarize the disadvantages of a big ball of mud:</p>
			<ul>
				<li><strong class="bold">Unplanned and chaotic</strong>: The appearance of a big ball of mud is the result of poor design and coding techniques<a id="_idIndexMarker009"/> rather than a deliberate architectural decision.</li>
				<li><strong class="bold">Tight coupling</strong>: The code is tightly <a id="_idIndexMarker010"/>interconnected; changes that are made to one section run the risk of having unexpected effects in unrela<a id="_idTextAnchor019"/>ted areas.</li>
				<li><strong class="bold">Difficulty in understanding and maintaining</strong>: The code base is messy and lacks documentation, making it hard for developers to grasp and modify.</li>
				<li><strong class="bold">Error-prone and fragile</strong>: The code base leads to unpredictable errors and regressions with modifications. In a big ball of mud system, everything is tightly connected like a big mess of wires. This <a id="_idIndexMarker011"/>makes it hard to know what happens when you change one part, like trying to fix one loose wire in a tangled mess. This can easily lead to unexpected problems and things breaking, like causing a short circuit in the tangled wires, making it harder to develop and maintain the system in the long run.</li>
				<li><strong class="bold">Reduced developer productivity</strong>: You spend more time on maintaining the code base instead of focusing on new features.</li>
				<li><strong class="bold">Limited scaling and growth</strong>: A rigid code structure makes it difficult to introduce new features or adapt to changes:</li>
			</ul>
			<div><div><img alt="Figure 1.1: A quality diagram of a big ball of mud" src="img/B09148_01_001.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.1: A quality diagram of a big ball of mud</p>
			<p>When writing a program, we see that it becomes more of a problem than a solution within a short time (see <em class="italic">Figure 1</em><em class="italic">.1</em>). The preceding graph tracks how a project progresses over time. Time is on the bottom (X-axis) and features added are on the side (Y-axis).</p>
			<p>Starting a project without a <a id="_idIndexMarker012"/>clear plan, such as using the big ball of mud approach, might seem easy at first. Imagine building with blocks – no instructions are needed and you can put things together quickly. But for these projects, as they get more<a id="_idIndexMarker013"/> features (higher Y-axis value), the overall quality suffers (gets worse).</p>
			<p>In the short term (a few weeks), both well-designed projects and big ball of mud projects might seem similar. But over time, the quality of the messy project goes downhill.</p>
			<p>Overall, while a big ball of mud approach might seem faster initially, it ultimately creates more problems in the long run. It’s like taking a shortcut that might save you time now but leads to bigger issues later on.</p>
			<p>One of the factors that turned our code into a big ball of mud over time was a lack of planning and organization. Planning and organizational structure are the attributes we usually use when building<a id="_idIndexMarker014"/> microservice architecture.</p>
			<h2 id="_idParaDest-20"><a id="_idTextAnchor020"/>Understanding the software development process</h2>
			<p>The development process not only covers <a id="_idIndexMarker015"/>coding – it is also about business, communication, discussion, analyzing, designing, testing, and deploying. Let’s call these the <strong class="bold">attributes</strong> of the software development process (see <em class="italic">Figure 1</em><em class="italic">.2</em>). Software development is much more than just writing code lines. While coding is <a id="_idIndexMarker016"/>certainly an important part, it’s only one piece of the puzzle. Because of that, it is essential to understand the core needs and goals of the business:</p>
			<div><div><img alt="Figure 1.2: Software development life cycle" src="img/B09148_01_002.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.2: Software development life cycle</p>
			<p>The following list provides comprehensive insights into the software development process:</p>
			<ul>
				<li>The need to solve specific problems and think in terms of the business landscape is what drives software development. For developers to create software solutions that are not only relevant, but also meaningful, they must have a deep understanding of market dynamics, industry, and user requirements.</li>
				<li>Effective collaboration and transparent communication are the backbone of success at every stage. Developers engage with a range of stakeholders, including business<a id="_idIndexMarker017"/> analysts, designers, testers, and clients. Clear communication ensures that everyone<a id="_idIndexMarker018"/> is on the same page regarding objectives, requirements, and project milestones.</li>
				<li>Discussing the ideas, obstacles, and potential solutions is very important. Effective brainstorming sessions, code reviews, and attentive user feedback all contribute to the quality<a id="_idIndexMarker019"/> of software. Open communication makes problem-solving more efficient.</li>
				<li>It is essential to carry out a thorough analysis of the requirements, user behavior patterns, and data insights. To create a solid software design strategy, developers must carefully analyze existing solutions, identify user needs, and break down complex problems.</li>
				<li>Careful consideration must be given to the architecture, functionality, and user interface of the software. Software that has been carefully designed is easy to use, effective, and maintain. A friendly user experience is the result of close collaboration between developers and designers.</li>
				<li>Strict testing procedures are essential to guarantee the functionality, dependability, and conformity of the software regarding user expectations. Different testing approaches address different areas, such as performance benchmarks and core functionality.</li>
				<li>Ensuring that end users can access the software is the last step. This is usually called <strong class="bold">deployment</strong>. This includes<a id="_idIndexMarker020"/> setting up the infrastructure, taking stringent security precautions, and, if needed, providing thorough user training to optimize usability and adoption rates.</li>
			</ul>
			<p>Now that we understand the <a id="_idIndexMarker021"/>software development process, let’s take a deeper look at the monolith approach to software development.</p>
			<h1 id="_idParaDest-21"><a id="_idTextAnchor021"/>Exploring the monolith approach</h1>
			<p>Say we have an e-commerce site with a single code base that was developed years ago. Over time, features and functionalities were added randomly, leading to messy code that contains duplication, is hard to maintain, and is <a id="_idIndexMarker022"/>difficult to troubleshoot. Here is the first suggested transition so that you can make your application responsive or alive again:</p>
			<ul>
				<li><strong class="bold">Analyze the current state of your application</strong>: You need to identify key pain points affecting developer productivity and user experience. Try to divide the problem into smaller pieces. Trying to cover everything at once will lead you to more difficulties. Focus on specific modules or functionalities within the larger code base for initial refactoring. You need to understand dependencies, duplication, and complexity in your application.</li>
				<li><strong class="bold">Communication and collaborative planning</strong>: The next steps are identifying the areas for improvement and agreeing on common architectural principles. Emphasize the phased approach, starting with small, isolated modules and demonstrating progress before moving on.</li>
				<li><strong class="bold">Choose a monolith architecture</strong>: Decide which architectural style and pattern (layered, tiered, MVC, MVVM, and so on) aligns best with your needs in the given context.</li>
				<li><strong class="bold">Start small and iterate</strong>: Set small goals and apply iterative development.</li>
				<li><strong class="bold">Make improvements</strong>: Eliminate code duplication, clean up spaghetti code (a term that’s used for unstructured and difficult-to-understand programming code), and improve documentation.</li>
				<li><strong class="bold">Application</strong>: After each refactoring step, it is better to apply unit, integration, and regression testing to ensure code functionality and identify potential regression in your application.</li>
				<li><strong class="bold">Feedback</strong>: Gather feedback from developers and users throughout the process to adapt and refine the approach.</li>
			</ul>
			<p>Welcome – you’re in the world of monoliths! But what is the concept of monolith?</p>
			<div><div><img alt="Figure 1.3: Monolith architecture" src="img/B09148_01_003.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.3: Monolith architecture</p>
			<p>Many online articles delve into the specifics of monolith architecture but rarely touch upon the broader concept, called the monolith approach. This isn’t surprising as the architecture has clear-cut <a id="_idIndexMarker023"/>characteristics. We love to be concrete and as developers, we are rarely theory lovers. However, it’s important to keep in mind that the monolith approach covers a greater variety of options.</p>
			<p>The <strong class="bold">monolith approach</strong> is a broader concept that refers to a general way of building software as a single, self-contained unit. It can be implemented using various architectures, not just the traditional monolith architectures we know.  It highlights simplicity, rapid development, and tight integration. The monolith approach is architecture-agnostic, meaning it can be implemented using various architectural styles or patterns, or even without a specific architectural framework at all, so long as the core principle of consolidating components into a single unit is maintained.</p>
			<p>On the other hand, <strong class="bold">monolith architecture</strong> (see <em class="italic">Figure 1</em><em class="italic">.3</em>) is a specific software architecture where everything, from UI to business<a id="_idIndexMarker024"/> logic to data access, is built as a single, tightly coupled unit. It often uses a single code base, programming language, and database.</p>
			<p>Monolith architecture refers to the specific architectural design or pattern that’s used to implement the monolith approach. It includes all of the technological choices and structural design of the monolithic system, including the arrangement of modules, the interactions between components, and the data management process.</p>
			<p>The monolith approach itself doesn’t dictate a specific architecture. However, certain architectural styles and patterns naturally align with and support the monolith approach more effectively than others. Examples include the layered architecture, the MVC architecture, and the N-tier architecture. The monolith approach can also be implemented without strictly adhering to a specific architecture, especially for smaller projects. The key feature here is to maintain a single code base and deployment unit. Whether you choose a structured style or a more organic approach, the core principle remains: build a cohesive <a id="_idIndexMarker025"/>software unit. Understanding this distinction forces you to make informed decisions when navigating the vast world of software architectures. So, while the monolith approach promotes the development of software as a unified entity, the monolith architecture determines how that unity is achieved and maintained. Knowing this difference allows you to navigate the wide world of software architectures with knowledge and confidence.</p>
			<p>While not without its drawbacks, the monolith approach offers several advantages, particularly for certain types of projects. These <a id="_idIndexMarker026"/>advantages are listed here:</p>
			<ul>
				<li><strong class="bold">Simplicity and speed</strong>: Monolith architecture enables faster development and deployment cycles by consolidating the entire system into a single codebase, reducing the overhead of managing multiple services.</li>
				<li><strong class="bold">Maintainability and control</strong>: Having everything in one place allows for easier management, control over application performance, and a unified approach to maintaining and securing the system</li>
				<li><strong class="bold">Performance and cost</strong>: This architecture offers the advantage of reduced complexity, leading to lower infrastructure costs and optimized performance for applications with straightforward requirements.</li>
				<li><strong class="bold">Additional benefits</strong>: It provides practical advantages for simpler projects, making it easier to manage data and application operations, especially for smaller teams.</li>
			</ul>
			<p>Even though the monolithic approach has benefits, such as speed and simplicity, not all projects can benefit from it. To help determine whether the monolithic approach is right for your project, consider these general guidelines:</p>
			<ul>
				<li><strong class="bold">Simple and well-defined applications</strong>: A monolith works well in applications that have a defined <a id="_idIndexMarker027"/>scope and few functionalities. Simple mobile apps, internal tools, and basic e-commerce sites are a few examples.</li>
				<li><strong class="bold">Quick product launches and idea testing</strong>: This is made possible by the agility of a monolithic architecture, which is useful if your project requires for quick development cycles or frequent prototyping.</li>
				<li><strong class="bold">Small teams with limited experience</strong>: Initially, managing and maintaining a monolith may be more manageable for teams that lack experience with distributed systems <a id="_idIndexMarker028"/>or microservices.</li>
				<li><strong class="bold">Tight data coupling and consistency</strong>: Monolithic architectures are advantageous for applications that rely heavily on consistent data across multiple functionalities. It guarantees data integrity throughout the application and simplifies data management.</li>
				<li><strong class="bold">Limited scalability requirements</strong>: Without the hassle of scaling microservices, a monolithic architecture might be able to satisfy your scalability requirements if your application expects stable user traffic and moderate growth projections.</li>
			</ul>
			<p>The best architecture depends on your specific application’s requirements. Here, you must consider factors such as scalability, complexity, technology needs, and development team structure. As we mentioned previously, there’s no one-size-fits-all solution in software development.</p>
			<p>While the monolith approach has its benefits, it’s not suitable for every application. It’s better not to use monolith when it comes to the following aspects:</p>
			<ul>
				<li>Building a highly scalable application</li>
				<li>Applications with constantly evolving features, modularity, and independent deployment</li>
				<li>If your application requires integrating diverse technologies or frameworks, also referred to as heterogeneous technologies</li>
				<li>If high availability and resilience are critical and one of the important attributes for your system is fault-tolerance</li>
				<li>If different teams work on distinct functionalities – that is, if there is independent development and deployment across teams</li>
				<li>When you have large teams and distributed development</li>
			</ul>
			<p>Besides its pros and cons, Monolith <a id="_idIndexMarker029"/>is usually a preferable architecture for getting started but not the only architecture to build better applications. We have another preferable architecture called <strong class="bold">service-oriented approach</strong> (<strong class="bold">SOA</strong>) that we plan to dive into details starting from the next page.</p>
			<h1 id="_idParaDest-22"><a id="_idTextAnchor022"/>What is service-oriented architecture?</h1>
			<p>A monolithic architecture <a id="_idIndexMarker030"/>unifies all of the components/elements – including the user interface and data access – into a single code base, promoting simplicity and quick development. Although it’s not impossible, combining different technologies into <em class="italic">one system</em> can be difficult to maintain and unfeasible at times. In the absence of contemporary methodologies such as feature flags and blue-green deployment, it becomes necessary to deploy the entire application every time you want to update a monolithic application. There are difficulties with organizing and delivering the application smoothly, which could mess up its launch.</p>
			<p>On the other hand, SOA (see <em class="italic">Figure 1</em><em class="italic">.4</em>) focuses on modularity and reuse, breaking down functionalities into independent <a id="_idIndexMarker031"/>services that communicate with each other through <strong class="bold">application programming </strong><strong class="bold">interfaces</strong> (<strong class="bold">API</strong>s).</p>
			<p>SOA can be defined as multiple, smaller, and often coarser-grained services, each with a specific function. This modularity offers advantages such as flexibility and scalability. Services in SOA can be deployed and scaled independently, meaning you can update or scale one service without affecting others. This is a key benefit of SOA.</p>
			<p>The analogy from moving from monolith to SOA can be described like this: You have a big method/function that does everything (similar to a monolith). After some time, some other parts of your functionalities are required so that these functionalities can be reused. Instead of copying it, you’re breaking this giant method into reusable parts (similar to SOA). In this case, the method calls are going to be our API calls:</p>
			<div><div><img alt="Figure 1.4: An overview of service-oriented approach" src="img/B09148_01_004.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.4: An overview of service-oriented approach</p>
			<p>Consider multiple applications (as shown in <em class="italic">Figure 1</em><em class="italic">.4</em> – account management, CRM, and sales management) that need to share common functionalities. Instead of duplicating them for every application, we provide a service-oriented approach. At first glance, it may look like they are <em class="italic">perfect</em> grained services, but our focus is just to <em class="italic">share</em> common behavior<a id="_idIndexMarker032"/> that supports scaling and reusing.</p>
			<p>To encapsulate communication complexity, we may use a service bus, which allows us to write additional logic and move the complexity to the outside of the application, which acts as a mediator. This is one of the signs that we should use architectural mediators in applications.</p>
			<p>Think of two functions within a single program and one directly calls the other. In SOA, each function becomes a standalone service, communicating through a defined interface. This enables independent deployment, updates, and even development by different teams.</p>
			<p>Imagine building with Lego bricks instead of monolithic blocks. That’s the essence of SOA: breaking down applications into reusable, independent services, each focused on a specific task. Instead of hard-coded connections, they<a id="_idIndexMarker033"/> communicate through standard<a id="_idIndexMarker034"/> protocols such as <strong class="bold">REST</strong> or <strong class="bold">SOAP</strong>, making them platform-agnostic and adaptable.</p>
			<p>SOA offers numerous advantages that can <a id="_idIndexMarker035"/>significantly improve the flexibility, agility, and efficiency of your organization’s IT infrastructure. Let’s discover its key benefits:</p>
			<ul>
				<li><strong class="bold">Business agility</strong>: SOA supports fast development and deployment, helping businesses quickly adapt to market changes and align their software with evolving business objectives.</li>
				<li><strong class="bold">Technical advantages</strong>: SOA offers flexibility and scalability, allowing for easier integration, upgrades, and reuse of<a id="_idIndexMarker036"/> components across the system without disrupting the overall functionality.</li>
				<li><strong class="bold">Operational benefits</strong>: SOA streamlines operations by reducing maintenance overhead and improving system reliability, while enhancing security through centralized management.</li>
			</ul>
			<p>Although SOA has many advantages, there are drawbacks as well:</p>
			<ul>
				<li><strong class="bold">Enhanced complexity</strong>: SOA introduces more <a id="_idIndexMarker037"/>complexity by requiring careful coordination between independent services, demanding skilled personnel, and detailed planning for development, testing, and maintenance.</li>
				<li><strong class="bold">Possible problems with performance</strong>: SOA can introduce latency due to network-based service interactions, adding complexity when ensuring secure and efficient communication between services.</li>
				<li><strong class="bold">Other difficulties</strong>: SOA comes with high upfront costs and requires skilled professionals, making it <a id="_idIndexMarker038"/>challenging to maintain service coordination, manage responsibilities, and ensure smooth integration as the system evolves.</li>
			</ul>
			<p>SOA is one step toward microservices. Most of the core ideas of microservices come from SOA.</p>
			<p>In the final section of this chapter, we’ll understand the benefits and challenges of the microservices architecture.</p>
			<h1 id="_idParaDest-23"><a id="_idTextAnchor023"/>The differences between SOA and microservices</h1>
			<p>Microservices architecture simplifies building distributed, flexible, and scalable software. Instead of one monolithic<a id="_idIndexMarker039"/> system, it divides an application into small, standalone services, each of them focused on a specific task. These services communicate<a id="_idIndexMarker040"/> through simple interfaces, allowing for independent deployment and easy integration. When developing properly designed microservices, we get loosely coupled, reusable, extensible, and easily maintainable applications.</p>
			<p>When comparing microservices to SOA, they may seem similar in concept. SOA and microservices architecture are both architectural styles that are used for building distributed systems, but they have some key differences. Let’s compare them:</p>
			<ul>
				<li><strong class="bold">Scope and granularity</strong>: Services in SOA are like big boxes containing multiple functionalities that are meant to be reused across different applications. Microservices are like tiny, specialized tools, each focusing on one specific task or feature within an application.</li>
				<li><strong class="bold">Communication protocols</strong>: Services in SOA mostly communicate using strict protocols, such as <strong class="bold">SOAP</strong>, <strong class="bold">XML-RPC</strong>, <strong class="bold">WSDL</strong>, and <strong class="bold">UDDI</strong>. Microservices prefer lightweight protocols such as <strong class="bold">RESTful HTTP</strong> or <a id="_idIndexMarker041"/>messaging queues, allowing for more flexible communication.</li>
				<li><strong class="bold">Technology stack</strong>: SOA can work with different technologies and platforms. Microservices often use containerization tools such as <strong class="bold">Docker</strong> and orchestration tools such as <strong class="bold">Kubernetes</strong> for easier deployment and management.</li>
				<li><strong class="bold">Dependency management</strong>: Services in SOA can have intricate dependencies that require careful coordination. Microservices strive for loose coupling, reducing dependencies between services to simplify development and deployment.</li>
				<li><strong class="bold">Deployment and scaling</strong>: Services in SOA are often centrally deployed and scaled at the service level. Microservices are deployed separately, allowing individual scaling and better resource utilization.</li>
				<li><strong class="bold">Organizational impact</strong>: Once SOA is implemented, significant organizational changes may be required for<a id="_idIndexMarker042"/> coordination and management. Microservices promote decentralization of management by giving small, cross-disciplinary teams the autonomy to control their services.</li>
			</ul>
			<p>The difference between <em class="italic">approach</em> and <em class="italic">architecture</em>, especially regarding microservices, is important.</p>
			<p>The microservice approach is all about how we think when designing software. It’s like having a mindset or philosophy of breaking down big, complicated systems into smaller, easier-to-handle parts. Each<a id="_idIndexMarker043"/> of these parts focuses on one specific task. It’s somewhat abstract and emphasizes concepts such as <strong class="bold">modularity</strong> (allowing for simple replacement), <strong class="bold">scalability</strong> (allowing for increased work), and <strong class="bold">flexibility</strong> (allowing for change adaptation):</p>
			<div><div><img alt="Figure 1.5: Microservices architecture" src="img/B09148_01_005.jpg"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 1.5: Microservices architecture</p>
			<p>Every approach has its pros and cons. Nothing is ideal. To identify it from the Microservices perspective, let’s talk about the advantages and disadvantages of Microservices.</p>
			<h1 id="_idParaDest-24"><a id="_idTextAnchor024"/>Advantages of microservices</h1>
			<p>In this section, we’ll look at the many<a id="_idIndexMarker044"/> reasons that make microservices an important part of software development:</p>
			<ul>
				<li><strong class="bold">Scalability</strong>: You can scale each microservice independently based on demand, ensuring resources are allocated where needed for optimal performance and cost-effectiveness.</li>
				<li><strong class="bold">Flexibility and agility</strong>: Teams can work on different services simultaneously, speeding up development and making updates easier. Being agile is essential to adapting to the ever-shifting demands and markets of businesses.</li>
				<li><strong class="bold">Fault isolation</strong>: If one microservice fails, it doesn’t necessarily affect others, thanks to their independence. This isolation improves system reliability by minimizing downtime.</li>
				<li><strong class="bold">Technology diversity</strong>: Multiple programming languages and technologies can be used in a single application thanks to microservices. Teams are encouraged to explore and be creative by selecting the finest tools for each service.</li>
				<li><strong class="bold">Easy maintenance and updates</strong>: Compared to huge monolithic programs, smaller services are easier to comprehend, manage, and update. Risks are decreased because modifications to one service won’t inadvertently affect others.</li>
				<li><strong class="bold">Scalable development</strong><em class="italic"> </em><strong class="bold">teams</strong>: Small, cross-functional teams can now own separate services thanks to microservices. This configuration promotes creativity, accelerates decision-making, and heightens accountability.</li>
				<li><strong class="bold">Improved fault tolerance</strong>: Microservices make it simpler to implement redundancy and failover techniques at the service level. This increases the system’s ability to withstand setbacks.</li>
				<li><strong class="bold">Improved deployment practices</strong>: <strong class="bold">Continuous integration</strong> and <strong class="bold">continuous deployment</strong> (<strong class="bold">CI/CD</strong>), two contemporary<a id="_idIndexMarker045"/> deployment techniques, mesh nicely with <strong class="bold">microservices</strong> architecture. Time to market is shortened by the release process being streamlined by automated deployment pipelines for every service.</li>
				<li><strong class="bold">Improved use of resources</strong>: Resource allocation based on the unique requirements of each service is made possible by granular scaling, which maximizes resource efficiency and reduces costs.</li>
				<li><strong class="bold">Encouragement of cooperation</strong>: Encouraging cooperation between the development and operations teams through microservices makes it easier to implement DevOps principles. At the <a id="_idIndexMarker046"/>service level, feedback loops, automation, and monitoring can be put into place to improve overall quality and efficiency.</li>
				<li><strong class="bold">Huge and complicated systems</strong>: Microservices can help you simplify huge and complex applications as you can divide them into smaller, more manageable parts.</li>
				<li><strong class="bold">Handles many users</strong>: Because microservices allow you to scale each component individually to effectively handle the load, they are ideal for apps that experience high traffic or a large number of users.</li>
				<li><strong class="bold">Requires frequent updates or new features</strong>: Microservices allow you to swiftly react to changing needs by allowing you to change individual components without affecting the entire application.</li>
				<li><strong class="bold">Uses different technologies</strong>: Microservices let you use different tools and programming languages for different parts of your app so that you can pick the best one for each job.</li>
				<li><strong class="bold">Built by many teams</strong>: If your app is being worked on by lots of different teams, microservices let each team work on their part, without getting in each other’s way.</li>
				<li><strong class="bold">Needs to stay running</strong>: Microservices help your app stay up and running, even if one part fails. This is because each part is separate. As a result, problems in one area don’t crash the whole thing.</li>
				<li><strong class="bold">Works in the cloud</strong>: Microservices are a good fit for apps that run in the cloud because they’re designed to work well with cloud technology. Plus, tools such as containers and orchestrators <a id="_idIndexMarker047"/>make it even easier to manage them in the cloud.</li>
			</ul>
			<p>In summary, microservices provide a modern, flexible method for developing software, allowing businesses to innovate rapidly, grow effectively, and release high-caliber software products into the market more quickly. However, don’t attempt to use them for every kind of application you’re creating.</p>
			<p>Although microservices offer many advantages, you should be aware that they also come with some additional complexity, such as having to manage several moving components and more communication being required between services.</p>
			<h1 id="_idParaDest-25"><a id="_idTextAnchor025"/>Disadvantages of microservices</h1>
			<p>Throughout this chapter, we learned that the main reason for having various architectures in software<a id="_idIndexMarker048"/> development is a sign that there is no single truth and that depending on the requirements, architecture may vary. Every approach in design has its disadvantages and before applying any architecture, you should carefully analyze and understand them.</p>
			<p>Here are some important disadvantages of microservices:</p>
			<ul>
				<li><strong class="bold">Increased complexity in development</strong>: Breaking down a system into smaller services can lead to increased complexity in development, deployment, and testing.</li>
				<li><strong class="bold">Interservice communication</strong>: Managing communication between microservices can become complex, requiring careful design and implementation of APIs and protocols.</li>
				<li><strong class="bold">Infrastructure complexity</strong>: Managing and deploying a large number of microservices can introduce operational overhead, including the need for sophisticated orchestration and monitoring tools.</li>
				<li><strong class="bold">Infrastructure cost</strong>: The overhead of managing multiple services and the associated infrastructure can lead to increased costs, particularly in terms of hosting and operational expenses.</li>
				<li><strong class="bold">Security issues</strong>: A larger number of services means a larger attack surface, potentially increasing the security risk.</li>
				<li><strong class="bold">Communication security</strong>: Securing <a id="_idIndexMarker049"/>communication between microservices requires additional attention to prevent unauthorized access.</li>
				<li><strong class="bold">Coordination and communication</strong>: Teams need to coordinate effectively to ensure that changes in one service do not adversely affect others.</li>
				<li><strong class="bold">Data consistency</strong>: Maintaining consistency across microservices can be challenging, especially when dealing with distributed databases. Ensuring data integrity and consistency becomes a complex task.</li>
				<li><strong class="bold">Team expertise</strong>: Developers<a id="_idIndexMarker050"/> need expertise in both the domain and technology stack of their specific microservice, potentially limiting flexibility in task assignments.</li>
			</ul>
			<p>Therefore, we should carefully consider if microservices are the correct choice for our project based on the expertise of our team, the requirements of our application, and the readiness of our organization for the shift.</p>
			<h1 id="_idParaDest-26"><a id="_idTextAnchor026"/>Summary</h1>
			<p>This chapter introduced you to microservices. We talked about coding without proper design and analysis, which brings us to a big ball of mud. Having no clear architecture is similar to having no map in the middle of the ocean.</p>
			<p>Our first step was starting with monoliths. We talked about the advantages and disadvantages of the monolith approach and tried to understand the differences between approach and architecture.</p>
			<p>Nowadays, requirements for applications are broader and more complex, and always trying to deal with them using a monolith approach may not be a good solution. To add important attributes, such as “distributed,” to the architecture, we considered SOA while discussing its pros and cons.</p>
			<p>The final destination for us was microservices. We provided a clear definition for it and tried to understand the advantages and disadvantages of using them.</p>
			<p>Microservices bring a lot of interesting challenges to our lives and one of them is communication. Dividing a big problem into smaller chunks is good but making proper communication between the chunks isn’t easy. When you’re ready, turn to the next chapter to explore it with me.</p>
		</div>
	</body></html>