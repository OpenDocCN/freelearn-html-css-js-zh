<html><head></head><body>
        

                            
                    <h1 class="header-title">Getting Started with TypeScript</h1>
                
            
            
                
<p>In this chapter, we will look at TypeScript and see how to use TypeScript in a new project or an existing JavaScript project. We will see how to adapt the environment of your current build setup. TypeScript can be supported by a variety of build tools, such as Grunt, Gulp, webpack, or simply by using the <strong>command-line interface</strong> (<strong>CLI</strong>). We also look at the best options, among all the ones available, for getting started with TypeScript.</p>
<p>Before configuring any build tool, it's important to understand that all of them use the same TypeScript compiler, often called a transpiler. The TypeScript compiler is available by using npm:</p>
<pre><strong>npm install -g typescript</strong></pre>
<p>Npm might not be installed by default on your computer. If that is the case, the previous instruction will fail. It means you need to install Node.js. You can install Node.js by going to the official website, <a href="https://nodejs.org/">https://nodejs.org/</a>.<a href="https://nodejs.org/"/></p>
<p>At any time, you can verify that you have Node.js, npm, and TypeScript installed by using the following command:</p>
<pre><strong>node -v</strong><br/><strong>npm -v</strong><br/><strong>tsc -v</strong></pre>
<p>TSC is the executable for the TypeScript compiler. This is the one that is used by all build tools. Grunt, Gulp, and webpack use TSC via their own plugin infrastructures that map TSC features to their platform. Note that recent TSC features might take a few weeks before reaching these platforms. This might explain the differences in compiler options when using these three build systems. In contrast, using a TSC CLI ensures that you are using TypeScript directly.</p>
<p>This chapter covers the following:</p>
<ul>
<li>Grunt</li>
<li>Gulp</li>
<li>Webpack </li>
<li>NMP/CLI </li>
<li>TypeScript compiler</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Grunt</h1>
                
            
            
                
<p>Grunt is a JavaScript task runner. It can be installed using NPM, which is used to list all its plugins:</p>
<pre><strong>npm install -g grunt-cli</strong></pre>
<p>In the case of a new project, make sure that <kbd>package.json</kbd> exists in the root of your TypeScript project. You can generate a simple one by using <kbd>npm init</kbd>.</p>
<p>Once it is done, you can install Grunt into your project:</p>
<pre><strong>npm install grunt --save-dev</strong></pre>
<p>Once Grunt is available on your machine and specified in your project, you need to get a TypeScript plugin. Grunt has two plugins named <kbd>grunt -TypeScript</kbd> and <kbd>grunt-TS</kbd>. The former has not been maintained for a few years and lacks the latest TypeScript compiler configuration. I strongly suggest using the latter:</p>
<pre><strong>npm install grunt-ts --save-dev</strong></pre>
<p>The last package should be installed as a dev dependency for Grunt to compile TypeScript and to install it locally. Grunt will search for the package locally. Omitting TypeScript as a local dependency will result in the following error when executing Grunt.</p>
<p>ENOENT: no such file or directory, open <kbd>'/.../node_modules/grunt-ts/node_modules/typescript/package.json'</kbd> Use <kbd>--force</kbd> to continue.</p>
<p>Installing TypeScript locally as a <kbd>dev</kbd> dependency is easy:</p>
<pre><strong>npm install typescript --save-dev</strong></pre>
<p>Prior to <kbd>grunt-ts</kbd> version 6, TypeScript and Grunt were installed during the installation of <kbd>grunt-ts</kbd>. This is not the case anymore, so they must be added manually.</p>
<p>The next step is to configure Grunt to use a TypeScript plugin. If you are not using Grunt, you need to create a <kbd>Gruntfile.js</kbd> at the root of your project. Otherwise, you can edit your existing one. The plugin allows you to specify many TypeScript options in the <kbd>Gruntfile.js</kbd>, but a good practice is to limit TypeScript options directly in the file and to leverage the TypeScript configuration file. By configuring TypeScript outside Grunt, this gives you the possibility of compiling your code without Grunt, or migrating to another build tool without having to duplicate or change TypeScript preferences.</p>
<p>A minimalist Grunt configuration with the sole purpose of compiling TypeScript into JavaScript may look like the following:</p>
<pre>module.exports = function(grunt) {<br/> grunt.initConfig({<br/>   ts: {<br/>    default : {<br/>     tsconfig: './tsconfig.json'<br/>    }<br/>   }<br/> });<br/> grunt.loadNpmTasks("grunt-ts");<br/> grunt.registerTask("default", ["ts"]);<br/>};</pre>
<p>The Grunt configuration creates a default task that executes a custom <kbd>ts</kbd> task that links to the <kbd>tsconfig.json</kbd> file, which is the default TypeScript configuration file.</p>
<p>The <kbd>tsconfig.json</kbd> file can look like the following one, which takes every TypeScript file with the extension <kbd>.ts</kbd> and will compile them outputting the result in the <kbd>build</kbd> folder:</p>
<pre>{<br/> "compilerOptions": {<br/>   "rootDir": "src",<br/>   "outDir": "build",<br/> }<br/>}</pre>
<p>When using <kbd>grunt</kbd> and <kbd>grunt-ts</kbd>, you must ensure that that the JSON is valid with no-trailing commas in the <kbd>tsconfig.json</kbd> file. Otherwise, you may get the following error:</p>
<pre>tsconfig error: "Error parsing \"./tsconfig.json\".  It may not be valid JSON in UTF-8."</pre>
<p>To test the configuration, create a simple <kbd>index.ts</kbd> file in an <kbd>src</kbd> folder at the root of the project. You can type <kbd>console.log('test')</kbd>. After, run <kbd>grunt</kbd> in a command line at the root of your project as well. This will create a <kbd>build</kbd> folder with an <kbd>index.js</kbd> file containing the same line of code. It will also create the <kbd>js.map</kbd> file that will let you debug in your browser directly in TypeScript's code.</p>
<p>If, for some reason, you do not want to rely on <kbd>tsconfig.json</kbd>, it's possible to specify the source and destination directly into <kbd>Gruntfile.js</kbd> file:</p>
<div><pre>module.exports = function (grunt) {<br/> grunt.initConfig({<br/>  ts: {<br/>   default: {<br/>    src: ["src/**/*.ts"],<br/>     outDir: "build",<br/>     options: {<br/>     rootDir: "src"<br/>    }<br/>   }<br/>  }<br/> });<br/> grunt.loadNpmTasks("grunt-ts");<br/> grunt.registerTask("default", ["ts"]);<br/>};</pre></div>
<p>In the end, <kbd>grunt-ts</kbd> wraps the TypeScript command line. It provides options such as the <em>fast compilation</em>, which compile, only what has changed since the last compilation. It is also an interesting option if you are already using Grunt in your project and want to start using TypeScript without modifying your build process.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gulp</h1>
                
            
            
                
<p>Gulp is an automation toolkit that has a TypeScript plugin as well. There are two plugins available in NPM, which are <kbd>gulp-tsb</kbd> and <kbd>gulp-typescript</kbd>. The latter is the most popular and more maintained. You can fetch <kbd>gulp</kbd> and the plugin by using the following command:</p>
<pre><strong>npm install -g gulp</strong><br/><strong>npm install --save-dev gulp-typescript</strong></pre>
<p>If you do not have a Gulp configuration file, you will need to create one at the root of your <kbd>gulpfile.js</kbd> project.</p>
<p>The configuration without an explicit option will rely on the default configuration. It means that configuring Gulp can be as simple as piping the source into the TypeScript plugin and then piping the result into the destination folder where the <kbd>build</kbd> files, that is the JavaScript file, will be placed for consumption. Once the following code is placed in <kbd>gulpfile.js</kbd>, you can execute it by using <kbd>gulp</kbd> in the command line. This will execute the <em>default task</em> once, automatically:</p>
<pre>var gulp = require("gulp");<br/>var ts = require("gulp-typescript");<br/><br/>gulp.task("default", function () {<br/> var tsResult = gulp.src("src/**/*.ts")<br/> .pipe(ts());<br/> return tsResult.js.pipe(gulp.dest("build"));<br/>});</pre>
<p>It is possible to have a task in Gulp to build incrementally a TypeScript file that changes instead of building all of them. This can be useful on a big project to reduce the time between the edition and the access to the result. This is similar to the <em>fast compilation</em> of Grunt. To have an ongoing compilation, you must create a new Gulp task. In this example, we will change Gulp to rely on <kbd>tsconfig.json</kbd> file, which will allow us to separate the TypeScript compiler option from the Gulp configuration:</p>
<pre>var gulp = require('gulp');<br/>var ts = require('gulp-typescript');<br/>var tsProject = ts.createProject('tsconfig.json');<br/><br/>gulp.task('scripts', function() {<br/> return gulp.src('src/**/*.ts')<br/> .pipe(tsProject())<br/> .pipe(gulp.dest('build'));<br/>});<br/>gulp.task('watch', ['scripts'], function() {<br/> gulp.watch('src/**/*.ts', ['scripts']);<br/>});</pre>
<p>To run the <kbd>watch</kbd> task, you need to execute Gulp followed by the name of the task: <kbd>gulp watch</kbd>. Unlike Grunt, Gulp will not produce the <kbd>map</kbd> file. It requires an additional Gulp plugin. Because the sourceMap is crucial to have an efficient debugging environment, it is keen to download the <kbd>gulp-sourcemap</kbd> package and change the previous configuration to the following. But first, let's download the <kbd>gulp-sourcemaps</kbd> package:</p>
<pre><strong>npm install --save-dev gulp-sourcemaps</strong></pre>
<p>And then create a new task:</p>
<pre>var sourcemaps = require('gulp-sourcemaps');<br/>gulp.task('scriptswithsourcemap', function () {<br/> return gulp.src('src/**/*.ts')<br/> .pipe(sourcemaps.init())<br/> .pipe(tsProject())<br/> .pipe(sourcemaps.write('.', { includeContent: false, sourceRoot: '.'}))<br/> .pipe(gulp.dest('build'));<br/>});</pre>
<p>The configuration will create the source map in a file with the same name as the JavaScript file generated but with a different extension. The extension will be <kbd>.jsmap</kbd>. If you want to have the mapping directly in the JavaScript file, you can remove the two arguments passed in the <kbd>write</kbd> function. I suggest having a single script task that produces the source map in a file to separate the mapping from the code generated, and to always have the source map created. It's a small tax on the compilation and a huge gain in debugging.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Webpack</h1>
                
            
            
                
<p>Webpack is one of the most commonly used ways to automate workflow when working with JavaScript and web development. Its main purpose is to bundle, but it can do many sequential steps, such as compiling TypeScript. Similarly to Grunt and Gulp, webpack has two loaders (similar to a plugin) for TypeScript. One is called <kbd>ts-loader</kbd> and the second <kbd>awesome-typescript-loader</kbd>. While with Grunt and Gulp, it was a clear which one users prefer, this is not the case with Webpack. Both loaders are similar in terms of popularity. It is also not difficult to change between the two if needed. Originally, <kbd>awesome-typescript-loader</kbd> was faster than <kbd>ts-loader</kbd> but with the evolution of TypeScript, the difference is often minimal. Also, there is sometimes an issue with an advanced feature in one or the other, and so it is practical to be able to switch depending on how your project. I'll present <kbd>ts-loader</kbd>, which is a little more popular, still actively maintained, and has a little more usage than the <kbd>awesome-typescript-loader</kbd>.</p>
<p>In the case, you are not yet using <kbd>webpack</kbd>, we need to install it:</p>
<pre><strong>npm install --save-dev webpack</strong><br/><strong>npm install --save-dev webpack-cli</strong></pre>
<p>Once webpack is installed, you can install the TypeScript loader:</p>
<pre><strong>npm install --save-dev ts-loader</strong></pre>
<p>Once all the tools are installed, you can configure webpack to bundle the JavaScript produced by the <kbd>webpack</kbd> loader. However, <kbd>webpack.config.js</kbd> is needed at the root of your project. Like any Webpack configuration, the entry property must be defined. Make sure you are referring to the TypeScript file. The output is also specified in the output property. Webpack requires mentioning the extension to be analyzed. In TypeScript case it is <kbd>.ts</kbd>, but if you are working with React you might want to also add <kbd>.tsx</kbd> under <kbd>resolve:extensions</kbd>. Finally, the <kbd>ts-loader</kbd> is specified under <kbd>module:rules</kbd>. Once again, the extension of TypeScript is required and the name of the loader:</p>
<pre>module.exports = {<br/> mode: "development",<br/> devtool: "source-map",<br/> entry: "./src/index.ts",<br/> output: {<br/>  path: __dirname + "/build",<br/>  filename: "bundle.js"<br/> },<br/> resolve: {<br/>  extensions: [".ts"]<br/> },<br/> module: {<br/>  rules: [<br/>  { test: /\.ts$/, loader: "ts-loader" }<br/>  ]<br/> }<br/>};</pre>
<p>You can run the webpack command line (<kbd>cli</kbd>) by accessing the binary file, which will read the <kbd>webpack.config.js</kbd> file:</p>
<pre><strong>node node-modules/webpack-cli/bin/cli.js</strong></pre>
<p>If you want to avoid referencing <kbd>node_modules</kbd>, you can install <kbd>webpack-cli</kbd> in your global space, using <kbd>npm install -g webpack-cli</kbd>.</p>
<p>Here are a few little details about webpack. There is an additional module that divides the production of the bundle and compilation, compared to just validating TypeScript. These modules might be interesting when your project starts to grow and you want to have a faster compilation pace. Feel free to check <kbd>fork-ts-checker-webpack-plugin</kbd> and <kbd>thread-loader</kbd>. Before diving into other libraries, <kbd>ts-loader</kbd> has a way to incrementally build and to use the TypeScript watch API to avoid building everything all the time. This will increase your performance on every compilation. To allow the watch, change the rule of <kbd>ts-loader</kbd> to the following:</p>
<pre>rules: [<br/> {<br/> test: /\.ts$/,<br/> use: [<br/>  {<br/>   loader: 'ts-loader',<br/>   options: {<br/>    transpileOnly: true,<br/>    experimentalWatchApi: true,<br/>   },<br/>  },<br/> ],<br/> }<br/>]</pre>
<p>A final detail about webpack is its dependency on <kbd>tsconfig.json</kbd> for all TypeScript related configurations. Grunt and Gulp allow you to override configurations inside their tool configuration, which is not the case with webpack. When bundling, webpack produces <kbd>bundle.js.map</kbd>, but only if the dev tool specifies a configuration. However, you must set the <kbd>tsconfig.json</kbd> "sourceMap" to <kbd>true</kbd> to have a mapping that works with TypeScript.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">NPM/CLI</h1>
                
            
            
                
<p>Almost all web projects use NPM. NPM is the mechanism we used to fetch TypeScript. This one creates <kbd>package.json</kbd> at the root of your project and can be used to launch TypeScript directly. This is possible because TypeScript has a CLI called <strong>tsc</strong> (<strong>TypeScript compiler</strong>).</p>
<p>NPM configuration has a section named <kbd>scripts</kbd> where you can add any command you want. You can create a <kbd>build</kbd> one that invokes tsc. Without any parameters, tsc uses <kbd>tsconfig.json</kbd> at the root of your project. In the following snippet, the "build" script is defined. To run the command, the use of the <kbd>run</kbd> command of NPM is needed, that is, <kbd>npm run build</kbd>:</p>
<pre><strong>"scripts": {</strong><br/><strong>"build": "node_modules/typescript/bin/tsc"</strong><br/><strong>},</strong></pre>
<p>With a TypeScript configuration file that specifies the source map, the <kbd>rootDir</kbd>, and <kbd>outDir</kbd> the result will be the same as Gulp and Grunt (different from webpack since it won't be bundled):</p>
<pre><strong>{</strong><br/><strong> "compilerOptions": {</strong><br/><strong> "rootDir": "src",</strong><br/><strong> "outDir": "build",</strong><br/><strong> "sourceMap": true</strong><br/><strong> }</strong><br/><strong>}</strong></pre>
<p>This is often not the preferred configuration because of how simplistic and limited it is. However, it's possible to have several commands executed one after the other, using the double ampersand (<kbd>&amp;&amp;</kbd>) to create a chain of commands. This option is fast, doesn't require any dependency on NPM libraries, and is often enough to get started at a basic level.</p>
<p>The advantage of the NPM and CLI approach is that TypeScript can be executed easily. Hence, if you have a custom build system you can easily plug TypeScript by invoking the CLI.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">TypeScript compiler</h1>
                
            
            
                
<p>Considering all the tooling available to compile TypeScript to JavaScript, one pillar concept remains the same: you must know which configuration to use. Insofar that you are not responsible for configuring the compiler, you could skip this section – configuring TypeScript is something you do rarely and when it works as desired it can stay unaltered for a very long time. However, to have an understanding of the capability of TypeScript, you need to know some of the core options. In this section, we will see the main settings that you can enable and customize for your project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Files location</h1>
                
            
            
                
<p>This section is all about the configuration of files in the file system. It guides TypeScript on where to find different files in your machine, as well as where to generate JavaScript files.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">rootDir and outDir</h1>
                
            
            
                
<p>The most basic configuration that you need to set for your project is to indicate to TypeScript where to get TypeScript files and where to publish the result of the compilation. Where will be the TypeScript (<kbd>.ts</kbd>) files and the JavaScript (<kbd>.js</kbd>) files be produced. This is done by specifying <kbd>rootDir</kbd> and <kbd>outDir</kbd>. Avoiding <kbd>rootDir</kbd> might give you a surprise in <kbd>outDir</kbd>. By default, TypeScript computes what it should be and tries to find a common path, which is the longest common prefix of all your input files. That has the drawback of being inconsistent when the file structures change. Recently, TypeScript changed its behavior to have a default to <kbd>.</kbd>, which alleviate the issue. Nevertheless, having an explicit configuration is the best practice to avoid confusion as to which version of TypeScript this new rule was applied.</p>
<p>Example:</p>
<pre><strong>rootDir:src</strong><br/><strong>outDir:build</strong></pre>


            

            
        
    

        

                            
                    <h1 class="header-title">baseUrl and paths</h1>
                
            
            
                
<p>Confusion can arise when the baseUrl and paths come into play. The baseUrl allows specifying with a non-relative name to be resolved. Paths work closely with the baseUrl and is a map of key-value allowing a name to be used as a link to a specific path to the library, using the baseUrl as the root.</p>
<p>Here is an example:</p>
<pre>{<br/> "compilerOptions": {<br/> "baseUrl": ".", // This must be specified if "paths" is.<br/> "paths": {<br/> "jquery": ["node_modules/jquery/dist/jquery"] // This mapping is relative to "baseUrl"<br/> }<br/> }<br/>}</pre>
<p>In code:</p>
<pre><strong>Import * from "jquery"</strong></pre>
<p>Paths can also be used for more advanced scenarios where you can define fallback folders. As good practice, I would advise using a relative path as much as possible and avoid complicated structures and potential resolving issues.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">sourceRoot and sourceMap and mapRoot</h1>
                
            
            
                
<p>The sourceMap property is a boolean that when set to <kbd>true</kbd> will generate the mapping between the generated JavaScript and TypeScript. This is a good option to turn on if you do debug in a browser and want to step in the TypeScript code instead of stepping into the generated code. It simplifies the debugging because you are working in exactly the same area. This is most of the time turned on.</p>
<p>However, sourceRoot is rarely used in normal circumstances. It is available if you move the sourceMap somewhere else to indicate at runtime where to find the sourceMap. This will alter the generated sourceMap path. The following code shows a comment indicating the path of the map file. SourceRoot would change the portion before <kbd>index.js.map</kbd>:</p>
<pre>const text = "Text for test1";<br/>console.log(text);<br/>//# sourceMappingURL=index.js.map</pre>
<p>Similarly, mapRoot allows changing the source if the map files are in a different place than the JavaScript file. The difference between sourceRoot and mapRoot is this time we alter the map file instead of the JavaScript file. In the following partial extraction of a code of a map file, we see paths that can be modified by mapRoot:</p>
<pre><strong>{"version":3,"file":"index.js","sourceRoot":"","sources":["../src/index.ts"]......</strong></pre>
<p>The moment to use or the other depending on how you configure positions your built files. If you move the map somewhere else, then <kbd>sourceRoot</kbd> is interesting. However, if you keep the map but move the JavaScript somewhere else than you may change mapRoot. I mention these configurations for the sole reason that you may already have a JavaScript project that you want to migrate to TypeScript. Depending on your existing configuration, you may need to tweak these configurations. However, for any standard project, no modification should be made to these configurations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Files and include and exclude</h1>
                
            
            
                
<p>Included is an array that specifies the glob pattern that in turn specifies which files/folders are to be included in the compilation. The array <kbd>exclude</kbd> complements <kbd>include</kbd> and removes files to be compiled. When both properties are specified, <kbd>exclude</kbd> will filter out from the list included files from <kbd>include</kbd>. By default, <kbd>include</kbd> includes all TypeScript files under the <kbd>rootDir</kbd>, hence no need to add an entry to <kbd>**/*.ts</kbd>.</p>
<p>Files are rarely used because it is less flexible than <kbd>include</kbd>. It allows specifying by path and name which file to compile, instead of using a glob pattern. The pattern approach is more flexible allowing you to configure once instead of having to continually modify the configuration file by adding and removing entries in Files.</p>
<p>Here is an example:</p>
<pre><strong>"include": [</strong><br/><strong> "src/**/*"</strong><br/><strong> ],</strong><br/><strong> "exclude": [</strong><br/><strong> "node_modules",</strong><br/><strong> "dont/compile/*.mock.ts"</strong><br/><strong> ]</strong></pre>
<p>A final word on these three file configurations is that, contrary to most options, these ones don't reside under <kbd>compilerOptions</kbd> but are directly set at the root of the <kbd>tsconfig.json</kbd> file.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Outfile</h1>
                
            
            
                
<p>The outfile is an option that can be useful if you have a need to generate a single JavaScript file from many TypeScript files. When using the outfile, you can remove <kbd>outDir</kbd> and set a path relative to the root of your project, followed with the name and the extension of the generated file:</p>
<pre>{<br/> "compilerOptions": {<br/> "rootDir": "src",<br/> "outDir": "build",<br/> "target": "es6",<br/> "sourceMap": true,<br/> "outFile": "build/mySingleFile.js"<br/> }<br/>}</pre>
<p>The example code above creates a single file but also the <kbd>sourceMap</kbd> file because of the <kbd>sourceMap</kbd>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Type</h1>
                
            
            
                
<p>This section contains information about TypeScript's type. The first configuration gives TypeScript a hint as to where to look for types and also if TypeScript must generate the definition file or not when compiling.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">typeRoots and types</h1>
                
            
            
                
<p>By default, every type provided inside a <kbd>node_modules</kbd> library, which includes all specific <kbd>@types/</kbd> and package with <kbd>.d.ts</kbd> directly inside the library's folder, are read by the TypeScript compiler. However, in some scenarios where there is no definition file available and you need to provide a custom one then you need to specify where the definition file is located. This can be done by using in which you can specify a folder where you define all your definition files. The caveat is that you will need to specify <kbd>node_modules</kbd> if you want TypeScript to keep look for definition files in <kbd>node_modules</kbd>.</p>
<pre>{<br/> "compilerOptions": {<br/> "typeRoots" : ["./typings", “./node_modules”]<br/> }<br/>}</pre>
<p>The Types configuration allows cherry-picking which file TypeScript will include. It works in collaboration with typeRoots and is an array. It whitelists the type name.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Declaration and declarationdir</h1>
                
            
            
                
<p>If you are building a library instead of a website or program, it might be wise to provide the definition file along with the generated JavaScript file. The reason is that when building a library in TypeScript, we never share the actual TypeScript (<kbd>.ts</kbd>) files but instead share the JavaScript files. The rationale is that TypeScript is just a superset of JavaScript and we want to expose our code to the largest audience available. By providing the JavaScript files we are allowing every JavaScript developer to consume our work. However, TypeScript coders are at rest. To fix this issue, we can provide a definition file (<kbd>.d.ts</kbd>) that contains all the signature functions as well as exported variables. The TypeScript compiler lets you generate the definition file automatically by using <kbd>declaration</kbd>.</p>
<p>The option is <kbd>boolean</kbd>:</p>
<pre>{<br/> "compilerOptions": {<br/> "declaration" : true<br/> }<br/>}</pre>
<p>By default, the declaration files produced are by TypeScript file and located at the same place as the TypeScript file. It means that the end result is for each JavaScript (<kbd>.js</kbd>) you will see a brother declaration file (<kbd>.d.ts</kbd>) next to it:</p>
<pre>{<br/> "compilerOptions": {<br/> "declaration" : true,<br/> "declarationDir": "definitionfiles/here"<br/> }<br/>}</pre>
<p>There is a caveat with <kbd>declarationDir</kbd>, which is that it cannot be used with <kbd>outFile</kbd>. You will get a compilation-error mentioning that both options cannot be defined at the same time:</p>
<pre>error TS5053: Option 'declarationDir' cannot be specified with option 'outFile'.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Configuration file</h1>
                
            
            
                
<p>TypeScript has its own configuration file that is a convenient way to avoid passing every option by command-line arguments. The file resides at the root of your project. One possibility is to have several configuration files that can be used in different situations. This is possible by providing <strong>tsc</strong> with the option <kbd>-p</kbd> followed by the name of the configuration. The following three command-line invocations show one without any parameter, which is doing exactly the same compilation as the second line. Nonetheless, the third compilation instruction is different, pointing to a completely new set of options:</p>
<pre><strong>tsc</strong><br/><strong>tsc -p tsconfig.json</strong><br/><strong>tsc -p tsconfig.test.json</strong></pre>
<p>One benefit of configuration files is the possibility of reusability by extending configuration. You can see this principle like object-oriented inheritance – one file can inherit from another one. This can be done by using the <kbd>extends</kbd> property as a key and the file to inherit from as a value. The file provided must be relative to the root of your project.It can or not have the extension (<kbd>.json</kbd>):</p>
<pre>{<br/> "extends": "./tsconfig.json",<br/> "compilerOptions": {<br/> "outDir": "buildtest",<br/> "sourceMap": false,<br/> "declaration": false<br/> }<br/>}</pre>
<p>The following example shows a command that invokes a compilation with the option in <kbd>tsconfig.test.json</kbd> and has a small set of instructions:</p>
<pre><strong>tsc -p tsconfig.test.json</strong></pre>
<p> The first one is which file to extend. In that case, it could also have been <kbd>./tsconfig</kbd> without the extension. The file overrides <kbd>outDir</kbd> that is also provided in the <kbd>tsconfig.json</kbd> file and adds additional values. A good pattern is to have a <kbd>base</kbd> configuration, which has a configuration that you know will be shared across many of your configurations.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Module and ModuleResolution</h1>
                
            
            
                
<p>A key concept of code separation in JavaScript is a module. A module brings the notion of importing and exporting code. The capability increases the ability to share the code by specifying a specific name and which part of a code may be exported. Then, other software can import the code and leverage its functionalities. However, there is not a single way to craft a module. TypeScript lets you write your code in a single way and to produce, during compilation, an output that respects different popular module syntax. Here is a list of modules that TypeScript can interpret:</p>
<pre>"None", "CommonJS", "AMD", "System", "UMD", "ES6", "ES2015" or "ESNext".</pre>
<p>The <kbd>module</kbd> option can be seen as how TypeScript produces the module and <kbd>moduleResolution</kbd> as how it reads a module. There are two ways that TypeScript can understand an <kbd>import</kbd> statement: class and node. The former is the traditional TypeScript way, which has different rules to find a file that is imported. The more popular choice is <kbd>node</kbd>.</p>
<p>Regardless of the module resolution option, you should try to use relative resolution by specifying in your import a path from the file you are importing. Relative import is denoted by having a path that starts with a single dot or a double dot to move backward. Here are few relative imports:</p>
<pre><strong>import x from "./sameFolder";</strong><br/><strong>import y from "../parent/folder";</strong><br/><strong>import z from "../../../deeper/";</strong></pre>
<p>The reason for using this is the clarity of where the code is imported. Using the absolute resolution brings confusion because it relies on other configurations like <kbd>baseUrl</kbd> as well as <kbd>moduleResolution</kbd>.</p>
<p>On the contrary, an import that relies on a more complex resolution is non-relative and looks like the following:</p>
<pre><strong>import a from "module123";</strong></pre>
<p>Without going into all the complex rules, the last example in classic would look for the module next to the file that is importing it and go down the folder structure without trying to import the module from <kbd>node_modules</kbd>. However, if <kbd>moduleResolution</kbd> is set to <kbd>node</kbd> than the first check would be to look-up in the <kbd>node_modules</kbd> folder for a <kbd>module123</kbd>. As you see, if you are using a common name, you may load an unexpected module.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">ECMAScript</h1>
                
            
            
                
<p>This section contains Typescript configurations related to the type of ECMAScript produced, as well as additional packages that can be incorporated.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Target</h1>
                
            
            
                
<p>The target option must be specified but rarely changed. This option indicates to TypeScript which version of the JavaScript files to produce. By default, it produces an ECMAScript 3 version, which doesn’t have all the built-in features that TypeScript allows. However, TypeScript can still produce such old versions of ECMAScript by producing JavaScript code that mimics the features. This comes with a price of performance penalty at runtime, but it is a great way to build modern code with an older browser. Here is the actual target that you can specify:</p>
<pre>"ES3", "ES5", "ES6"/"ES2015", "ES2016", "ES2017" or "ESNext"</pre>
<p>If you are deploying for the web in general, ES5 is a safe bet with 100% support for all browsers. But, ES6 is very close, and Chrome supports 98% of its features, Firefox 97%, and Edge 96%.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lib</h1>
                
            
            
                
<p>TypeScript can inject the core library of ECMAScript into the produced code. By default, some libraries are automatically added. For example, if you specify a target of ES5, TypeScript adds the library: DOM, ES5, and ScriptHost. You can manually add an additional library. For example, if you would like to use iterable you can add the string <kbd>ES2015.Iterable</kbd> in the lib array. You can use a feature that is beyond your main target as well. For example, you can have a target of ES2015 and uses an ES2018 feature. See "target" as a main set of features to be included in the compilation and <kbd>lib</kbd> as a subset of additional features that you can add to the compilation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Compiler strictness</h1>
                
            
            
                
<p>TypeScript has many option around how strict the compiler must analyze your code. This section shows you the difference between each setting, allowing you to start slowly and progressively if you are coming from an existing JavaScript.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Strict</h1>
                
            
            
                
<p>This is the option that turns every configuration to strict. This is what you should use if you start a new TypeScript project coming from JavaScript.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">StrictFunctionTypes</h1>
                
            
            
                
<p>This is an advanced check that does not allow bivariance for arguments of a function. It uses contravariance. What it means is that if a function is expecting a type A as a parameter, you cannot set a function that has a type B that inherits a type A – you must only pass a type A. The following won't compile with <kbd>StrictFunctionTypes</kbd> with a <kbd>true</kbd> value. The strict option is useful to avoid a passing object that has more members than the expected type. The following example has <kbd>B</kbd> as the <kbd>firstName</kbd> field and inherits <kbd>A</kbd>, hence the name:</p>
<pre>interface A {<br/> name: string;<br/>}<br/><br/>interface B extends A {<br/> firstName: string;<br/>}<br/><br/>declare let f1: (x: A) =&gt; void;<br/>declare let f2: (x: B) =&gt; void;<br/><br/>f1 = f2; // DOESNT COMPILE<br/>f2 = f1;</pre>
<p>During compilation, TypeScript finds that the argument is passed to an object with more members and won't compile:</p>
<pre>Error message :  Type 'A' is not assignable to type 'B'. Property 'firstName' is missing in type 'A'.</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">StrictPropertyInitialization and StricNullChecks</h1>
                
            
            
                
<p><kbd>StrictPropertyInitialization</kbd> property should always be set to true. It ensures that all properties of a class are initialized with a direct association at the declaration level or in the constructor of the class.</p>
<pre>class A {<br/> public field1: number;<br/>}</pre>
<p>The example does not compile because <kbd>Field1</kbd> is a number that is not defined. The value of the field is undefined. There are many solutions to keep the strictness and make the code compliant. The first solution is to set a value at the initialization:</p>
<pre>class A {<br/> public field1: number = 1;<br/>}</pre>
<p>Setting a default value at initialization is not always possible. In some cases, it's possible to specify the value at construction type:</p>
<pre>class A {<br/> public field1: number;<br/> constructor(p:number){<br/>   This.field1 = p;<br/> }<br/>}</pre>
<p>A third way to compile the code is to use the bang operator (<kbd>!</kbd>) after the member's name. The operator indicates to TypeScript that the value will be provided later. The scenario in which a late initialization occurs is often by some injection framework or by using a function to initialize the class.</p>
<p>One caveat to having <kbd>strictPropertyInitialization</kbd> do this job is a dependency on another strict property that must be enabled – the <kbd>strictNullChecks</kbd>. The null check should also always be set to true at all times. Without this, a field identified as a type will automatically accept null and undefined as a valid type. It is less confusing and more declarative to only support a field with an explicit type and in the case of null or/and undefined to use the property definition that we will see later in this book.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we put in place different configurations allowing you to start coding with TypeScript in a straightforward way. After setting up your working environment to your liking, we briefly mentioned the most important compiler options to get you started on the right path. TypeScript is a flexible compiler, and you should be rapidly up-to-speed developing because of how the settings can be selected.</p>
<p>In the next chapter, we will look at programming with TypeScript by introducing how ECMAScript primitive type can be strongly typed.</p>


            

            
        
    </body></html>