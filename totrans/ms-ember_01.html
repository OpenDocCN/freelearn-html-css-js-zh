<html><head></head><body>
<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01" class="calibre1"/>Chapter 1. Introduction to Ember.js</h1></div></div></div><p class="calibre7">This chapter will introduce <strong class="calibre8">Ember.js</strong>, including <a id="id0" class="calibre1"/>its origin, release cycle, and its key elements. It will focus on describing the different functions that can be undertaken once an application is created. Therefore, a better understanding of the following will be gained at the end of the chapter:</p><div><ul class="itemizedlist"><li class="listitem">Ember.js's origin</li><li class="listitem">Downloading Ember.js and its dependencies</li><li class="listitem">Creating a basic Ember.js application</li><li class="listitem">Ember.js application concepts</li></ul></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_1"><a id="ch01lvl1sec08" class="calibre1"/>The origin of Ember.js</h1></div></div></div><p class="calibre7">Ember.js <a id="id1" class="calibre1"/>is a fun and productive open source JavaScript framework used for creating ambitious web applications. It powers complex client-side applications and guarantees development productivity through use of common web conventions over trivial configurations. Its<a id="id2" class="calibre1"/> official website is <a class="calibre1" href="http://emberjs.com">http://emberjs.com</a>.</p><p class="calibre7">It was forked from SproutCore by Yehuda Katz and Tom Dale. SproutCore is an MVC framework that strives to provide a robust JavaScript widget toolkit similar to Apple's Cocoa API for Max OS X. The additional user interface widget feature was found to be unnecessary to most developers, hence the fork. The result was a more lightweight, easy-to-use library that still lived up to the promise of:</p><div><ul class="itemizedlist"><li class="listitem">Reducing development time</li><li class="listitem">Creating robust applications through use of common client-side web application development best practices</li><li class="listitem">Friendly API that makes client-side programming fun</li></ul></div><p class="calibre7">Ember.js has a wide range of applications. It is well suited for applications that display dynamic data and have increased user interaction. Such applications include task managers, dashboards, forums, chat and messaging applications, and so on. Think of applications such as Gmail, Facebook, and Twitter. That being said, Ember.js is not ideal for static websites.</p><p class="calibre7">Ember.js is <a id="id3" class="calibre1"/>used by many companies throughout the world including, but not limited to, Apple, Groupon, Square, Zendesk, and Tilde Inc.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec09" class="calibre1"/>Downloading Ember.js</h1></div></div></div><p class="calibre7">One of <a id="id4" class="calibre1"/>the most asked questions is, where do I download Ember.js from? The most stable version of library can be downloaded from <a class="calibre1" href="http://emberjs.com/builds/#/release">http://emberjs.com/builds/#/release</a>. However, the home page (<a class="calibre1" href="http://emberjs.com/">http://emberjs.com/</a>) usually contains a link to a starter kit that also contains the required dependencies. At the time of writing this book, the current stable version of Ember.js is version 1.7.0, which we will be using throughout the book. In our case, we will be using the corresponding starter kit from <a class="calibre1" href="https://github.com/emberjs/starter-kit/archive/v1.7.0.zip">https://github.com/emberjs/starter-kit/archive/v1.7.0.zip</a>, which you should download and unarchive into your working directory.</p><p class="calibre7">Upgrading Ember.js has been made much easier. New releases are usually announced at <a class="calibre1" href="http://emberjs.com/blog/tags/releases.html">http://emberjs.com/blog/tags/releases.html</a> and go in detail to discuss what to expect in the release.</p><p class="calibre7">Now, after unarchiving the provided starter kit, under <code class="email">js/libs</code>, we notice the two basic requirements<a id="id5" class="calibre1"/> for running Ember.js:</p><div><ul class="itemizedlist"><li class="listitem"><strong class="calibre8">jQuery</strong>: Ember.js <a id="id6" class="calibre1"/>uses jQuery for fundamental functions such as HTTP requests, DOM manipulation, and events management. jQuery is the most popular DOM manipulation library; hence, readers with past experience in it will feel at home. This also means that we will be able to easily integrate our favorite third-party jQuery libraries into our Ember.js applications.</li><li class="listitem"><strong class="calibre8">Handlebars</strong>: This <a id="id7" class="calibre1"/>is the template engine library that Ember.js uses to display reactive pages to the users through autoupdates and better user interactions. It's worth noting that we can still use other template engines such as Ender or Jade with a little bit of effort.</li></ul></div><p class="calibre7">The index file loaded these files as:</p><div><pre class="programlisting">  &lt;script src="img/jquery-1.10.2.js"&gt;&lt;/script&gt;
  &lt;script src="img/handlebars-1.1.2.js"&gt;&lt;/script&gt;
  &lt;script src="img/ember-1.7.0.js"&gt;&lt;/script&gt;
  &lt;script src="img/app.js"&gt;&lt;/script&gt;</pre></div><p class="calibre7">The <code class="email">app.js</code> file contains all our application code but later on we may separate application concerns into more files when the application grows. It's worth noting that the order in which the scripts are loaded is important. Once the page loads, Ember.js logs the dependencies used together with their versions, as shown in the following screenshot:</p><div><img src="img/00002.jpeg" alt="Downloading Ember.js" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The two libraries <a id="id8" class="calibre1"/>and Ember.js can be accessed from the global scope as <code class="email">jQuery</code> (or <code class="email">$</code> ), <code class="email">Handlebars</code>, and <code class="email">Ember</code> (or <code class="email">Em</code>) respectively, as shown in the following code:</p><div><pre class="programlisting">console.log(jQuery);
console.log(Handlebars);
console.log(Ember);</pre></div><div><h3 class="title2"><a id="tip02" class="calibre1"/>Tip</h3><p class="calibre7">
<strong class="calibre8">Downloading the example code</strong>
</p><p class="calibre7">You can download the example code files for all Packt books you have purchased from your account at <a class="calibre1" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="calibre1" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec10" class="calibre1"/>Creating your first application</h1></div></div></div><p class="calibre7">The application <a id="id9" class="calibre1"/>script file (<code class="email">js/app.js</code>) in the starter kit contains a basic Ember.js application. If you load the <code class="email">index.html</code> file in your browser, you should see the three primary colors displayed:</p><div><pre class="programlisting">App = Ember.Application.create();

App.Router.map(function() {
  // put your routes here
});

App.IndexRoute = Ember.Route.extend({
  model: function() {
    return ['red', 'yellow', 'blue'];
  }
});</pre></div><p class="calibre7">What steps led to the result?</p><div><ul class="itemizedlist"><li class="listitem">First, an Ember.js application was created which then created a router.</li><li class="listitem">The router that is responsible for state management transitioned the application into two states, the first of which was the application state. This state resulted in the application template being rendered into the DOM, hence the <strong class="calibre8">Welcome to Ember.js</strong> message.</li><li class="listitem">Superseding the application state was the index state whose route, <code class="email">App.IndexRoute</code> rendered the index template inside the application template.</li><li class="listitem">The index route also provided the template, the lists, and the colors as the model context.</li></ul></div><p class="calibre7">This can be summarized as in the following figure:</p><div><img src="img/00003.jpeg" alt="Creating your first application" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">This example<a id="id10" class="calibre1"/> alone has introduced some of the following key Ember.js concepts.</p></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec07" class="calibre1"/>Router</h2></div></div></div><p class="calibre7">The<a id="id11" class="calibre1"/> router<a id="id12" class="calibre1"/> coordinates the application's state with the browser's location. It supports traditional web features such as navigation of the application's history using the browser's back and forward buttons, as well as linking back to the application using links.</p><p class="calibre7">Depending on the current URL, it calls matched routes that render several nested templates on a page. Each of these templates has a model context. The router is automatically created by an application on initialization. Therefore, we only need to call its <code class="email">map</code> method to define the application routes, as shown in the following code:</p><div><pre class="programlisting">App.Router.map(function() {
  // put your routes here
});</pre></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec01" class="calibre1"/>Route</h3></div></div></div><p class="calibre7">The <a id="id13" class="calibre1"/>route<a id="id14" class="calibre1"/> is primarily responsible for providing a template's model context. It's defined from the <code class="email">Ember.Route</code> class, as shown:</p><div><pre class="programlisting">App.IndexRoute = Ember.Route.extend();</pre></div><p class="calibre7">It will be covered extensively in <a class="calibre1" title="Chapter 3. Routing and State Management" href="part0029_split_000.html#page">Chapter 3</a>, <em class="calibre9">Routing and State Management</em>.</p></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_2"><a id="ch01lvl2sec08" class="calibre1"/>Controller</h2></div></div></div><p class="calibre7">A <a id="id15" class="calibre1"/>controller<a id="id16" class="calibre1"/> proxies models provided by routes and further decorates them with display logic. They are also the channel of communication between the different states of an application through explicit dependency specification, as we shall learn in <a class="calibre1" title="Chapter 5. Controllers" href="part0061_split_000.html#page">Chapter 5</a>, <em class="calibre9">Controllers</em>. To create controllers, we extend the <code class="email">Ember.Controller</code> class, as shown in the following line of code:</p><div><pre class="programlisting">App.IndexController = Ember.Controller.extend();</pre></div></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_3"><a id="ch01lvl2sec09" class="calibre1"/>View</h2></div></div></div><p class="calibre7">Views<a id="id17" class="calibre1"/> are used to<a id="id18" class="calibre1"/> manage events. They delegate user-generated events back to controllers and routes. Views are typically used to integrate other DOM manipulation libraries, for example, third-party jQuery packages. They are usually created from the <code class="email">Ember.View</code> class:</p><div><pre class="programlisting">App.IndexView = Ember.View.extend();</pre></div><p class="calibre7">We will discuss them in detail in <a class="calibre1" title="Chapter 6. Views and Event Management" href="part0069_split_000.html#page">Chapter 6</a>, <em class="calibre9">Views and Event Management</em>.</p><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec02" class="calibre1"/>Template</h3></div></div></div><p class="calibre7">A<a id="id19" class="calibre1"/> template<a id="id20" class="calibre1"/> is set of expressions that are compiled down to HTML and rendered into the DOM. Templates are usually defined with the following signature:</p><div><pre class="programlisting">&lt;script type="text/x-handlebars" id="index"&gt;
&lt;!-- our template goes in here -- &gt;
&lt;/script&gt;</pre></div></div><div><div><div><div><h3 class="title2"><a id="ch01lvl3sec03" class="calibre1"/>Component</h3></div></div></div><p class="calibre7">The <a id="id21" class="calibre1"/>component<a id="id22" class="calibre1"/> is a new concept in Ember.js that enables creation of reusable elements in accordance to the <strong class="calibre8">W3C Web Components</strong>
<a id="id23" class="calibre1"/> specification. These elements are ideally not application-specific and can therefore be reused in other applications.</p></div></div></div>

<div><div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec11" class="calibre1"/>Initializing the application</h1></div></div></div><p class="calibre7">An Ember.js application <a id="id24" class="calibre1"/>is created by instantiating the <code class="email">Ember.Application</code> class:</p><div><pre class="programlisting">App = Ember.Application.create();</pre></div><p class="calibre7">A few things happen when an application is first created.</p><p class="calibre7">A new namespace is created for the app on which we define views, controllers, and routes. This prevents us from polluting the global scope. Therefore, defining a route, for example, should be attached to it as:</p><div><pre class="programlisting">App.IndexRoute = Ember.Route.extend({
  model: function() {
    return ['red', 'yellow', 'blue'];
  }
});</pre></div><p class="calibre7">Ember.js usually initializes the application by calling its <code class="email">initialize</code> method. This initialization can be delayed by calling the application's <code class="email">deferReadiness</code> method and then recommenced with <code class="email">advanceReadiness</code>. For example, imagine our application needed to load the Google Client library beforehand, as shown:</p><div><pre class="programlisting">&lt;script src="img/client.js?onload=onLoadCallback"&gt;&lt; /script&gt;
&lt;script src="img/app.js"&gt;</pre></div><p class="calibre7">Here's how our application would finalize its readiness as soon as the library is loaded:</p><div><pre class="programlisting">App = Em.Application.create();
App.deferReadiness();
window.onLoadCallback = function(){
  App.advanceReadiness();
}</pre></div><p class="calibre7">Now that our application is ready to use the SDK, we would load any currently logged-in user using an initializer via a promise. Initializers are called when the application is being initialized and are therefore a good opportunity to perform various functions, such as inject dependencies using the application's container. This container is used to organize the different components within the application and can be referenced as:</p><div><pre class="programlisting">App.__container__</pre></div><p class="calibre7">For example, internally, an instance of a route could be accessed as:</p><div><pre class="programlisting">App.__container__.lookup('route:index');</pre></div><p class="calibre7">Since we have now loaded the third-party library, we can proceed to create a user initializer that would load any currently logged-in user:</p><div><pre class="programlisting">Ember.Application.initializer({
  name: 'user',
  initialize: function(container, App) {

    var user = new Ember.RSVP.Promise(function(resolve, reject) {

      var opts = {
        'client_id': '-- --',
        'scope': 'email',
        'immediate': false
      };
      gapi
        .auth
        .authorize(opts, function(res){

          if (!res || res.error) {
            return reject();
          }
          resolve(res);
        });

    });

    container.register('user:main', user);
    container.lookup('user:main');
  }
});

Ember.Application.initializer({
  name: 'injectUser',
  initialize: function(container, App) {
    container.typeInjection('controller', 'user', 'user:main');
    container.typeInjection('route', 'user', 'user:main');
  }
});</pre></div><p class="calibre7">The two blocks <a id="id25" class="calibre1"/>demonstrate the two uses of the application container as mentioned in the preceding code. The first one shows how to register an accessible application component; in this case, the user will now be accessed as:</p><div><pre class="programlisting">App.__container__.lookup('user:main');</pre></div><p class="calibre7">This user first starts off as a promise in the initializer. A <strong class="calibre8">promise</strong>
<a id="id26" class="calibre1"/> is a stateful object whose value can be set at a later point in time. We will not cover much about promises in this chapter but one thing to note is that once the sign-in process completes, the sign-in callback <code class="email">gapi.auth.authorize</code> either rejects or resolves the promise. Resolving the promise transitions the user object from the pending state to the fulfilled state.</p><p class="calibre7">The second block <a id="id27" class="calibre1"/>demonstrates dependency injection, which we also talked about earlier. In this case, we will now be able to access this user in routes and controllers as shown in the following code:</p><div><pre class="programlisting">this.get('user');</pre></div></div>

<div><div><div><div><div><h2 class="title1" id="calibre_pb_1"><a id="ch01lvl2sec10" class="calibre1"/>Embedding Ember.js applications</h2></div></div></div><p class="calibre7">An <a id="id28" class="calibre1"/>Ember.js application can be embedded into an existing page by specifying the application's <code class="email">rootElement</code>. This attribute is a jQuery selector. For example, to embed the application into a <code class="email">#chat-container</code> element, use the following lines of code:</p><div><pre class="programlisting">App = Ember.Application.create({
   rootElement: '#chat-container'
});</pre></div><p class="calibre7">This is useful when we are creating such applications as widgets. Specifying the root element ensures that only events invoked inside the element are managed by the Ember.js application.</p></div></div>
<div><div><div><div><h1 class="title" id="calibre_pb_0"><a id="ch01lvl1sec12" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This chapter has been an introductory guide to Ember.js. It focused on introducing the key elements that compose an Ember.js application. These elements inherit from the <code class="email">Ember.Object</code> primitive, which will be discussed in the next chapter.</p></div></body></html>