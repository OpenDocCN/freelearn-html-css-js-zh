- en: Transforming Your Code into Object-Oriented
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented has its own set of jargon, and TypeScript relies on much of
    it. In this chapter, all the concepts of object-oriented that TypeScript supports
    are discussed with examples. We will see what a class is and how to instantiate
    a class into an object. We will also see how a constructor can be strongly typed
    with TypeScript, and how, with a shorthand syntax, we can assign a class's fields
    directly from the constructor. We will cover the principle of encapsulation with
    visibility, how to implement an interface, and how to bring abstraction to a class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: What is a class and how do we define one?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How type comes into play with a class's constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is encapsulation using `public`, `private`, and `protected`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the definition of a field with a value set at construction time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is static?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use cases for a non-public constructor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using an object from a class versus an object literal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How an interface can be useful in object-oriented
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bringing abstraction with an abstract class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to have a property that is read-only
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Enforcing a specific constructor from an interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is a class and how do we define one?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the core of object-oriented is the class. A class is a definition of what
    is available for an object once instantiated. A class holds variables and functions
    that were judged cohesive by the developer. A class can share information across
    all instances of the same class or have its own data, which is unique from the
    beginning of the life of the object until its death.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of a class starts with the keyword `class` followed by the name
    of the class. It is similar to the creation of an interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'A class can define variables and functions. Each of them is `public` by default,
    meaning that they are accessible from outside the class by the name of the instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once a class is defined, it can be instantiated. An instantiation means that
    a class becomes concrete and the life cycle for its content starts. To create
    an instance of a class, the `new` keyword must be used. After `new` comes the
    name of the class with parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How type comes into play with a class's constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The instantiation of a class calls the constructor of the class. If this one
    is not defined, nothing is called. When no constructor is defined, the parentheses
    do not have any argument. The constructor''s goal is to provide initialization
    of data to the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'In the case where the parameters are defined, the initialization must provide
    all the non-optional parameters. In the following code, the instantiation calls
    the constructor that has two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'A constructor is similar to a function but cannot have an override. There is
    only a single constructor that can be defined. By default, it is `public` if no
    visibility is provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'However, a constructor can be overloaded by many signatures. Similar to a function,
    the use of many definitions is possible with the use of a semicolon. In the following
    example, you can see that it is possible to instantiate the class with a single
    number or with a number and a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'If a class extends another class, it must call `super` with the parameter of
    the right type to the base class. The class that inherits the second class does
    not need to have the same number of constructor parameters, nor the same type.
    What is important is the call to `super` to respect the type of the extended class.
    In the following example, `MyClass` has a constructor that takes a number and
    a string. The class that extends `MyClass`, `MyClass2`, must call `super` with
    a number and a string. The example illustrates that the value can come from the
    constructor of the class or can be computed directly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: What is encapsulation using public, private, and protected
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The use of `var`, `let`, and `const` is not available at a class level. Class
    declares by using the `public`, `private`, and `protected` encapsulation visibility
    keywords. The scope is conscribed to the class with some minor difference between
    the three.
  prefs: []
  type: TYPE_NORMAL
- en: 'A class variable with the `public` keyword declaration allows the variable
    to be available inside and outside the class. The `public` modifier brings the
    instance of the class to allow it to read and write the value outside the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'On the other hand, the `private` declaration restrains the access to the class
    itself. This is true for reading and writing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a `protected` encapsulation is similar to `private` but it allows
    us to read and to write the value of the `protected` variable outside the class
    itself. However, the access is restricted to the class that declares the `protected`
    and the class that extends this one. A `protected` variable or function shares
    access down the hierarchy of classes. That means that all classes that inherit
    a class with `protected` members have access to the `protected` member:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the example, the child class has access to the base class members that are
    `public` and `protected`. Once the child class is instantiated, only `public`
    variables are available. Private members are only available in the class where
    they are defined. This is true for variables and functions.
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the definition of a field with a value set at construction time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It can be cumbersome to always set values from the constructor to a field.
    A possibility is to assign the field directly from the constructor signature into
    the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'By setting the visibility of the encapsulation of each parameter of the constructor,
    a member is created with the same type. In the preceding example, two fields are
    created for the class with the name and the type of the parameter. The following
    code is exactly the same as the previous example, which is heavier in terms of
    definition and assignation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: What is static?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A static member is a member that can be accessed without instantiating the class.
    Everything that is static is shared across all instances for the life of your
    system. Static variables and functions are associated with the class, not an instance
    of the class or a particular object. If you are coming from JavaScript, you can
    see static as being a member associated with the prototype chain instance of the
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Contrary to many other languages, TypeScript does not allow us to have a static
    class. It does not remove much, because if you need to have a static class, you
    just need to have the function directly inside the module instead of being in
    a class. If you want to have all your static classes inside a class and prevent
    the consumer of your library from instantiating the class, you can mark the class
    as abstract. An abstract class cannot be instantiated without being extended:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Static members can be from all encapsulation visibilities: `public`, `protected`,
    or `private`. However, only `public` visibility is accessible from outside the
    class. The `private` and `protected` are available within the class that defines
    the status members. A protected member can be accessed from a class that extends
    another class with static members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Only `public static` members are accessible from outside the class. The `private`
    and `protected` are accessible within the class. To use any static members, the
    name of the class must be specified before the use of the member. This rule is
    also needed when inside the class. The `this` pointer is only available within
    an instance, and since static is not part of any instance but part of `class`,
    it cannot be reached with the instance''s `this` pointer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Use cases for a non-public constructor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `private` constructor revokes the possibility to instantiate the class from
    the outside. The following code does not compile because the constructor is `private`.
    The same would also be true if the constructor were `protected`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In that case, the only way to instantiate the class is by using a `public static`
    function that creates the object of the type class and returns it. In the following
    code, the `private` constructor creates an instance; to access this instance, `GetInstance`
    is used, which is static and does not need to have an instance to be called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: A known pattern is to have a `SingletonClass`. Only a single instance of the
    class exists and this control can be managed by having a single function that
    uses `new` once and then always returns the same instance. Another use case is
    to have a factory that creates all the instances.
  prefs: []
  type: TYPE_NORMAL
- en: Using an object from a class versus an object literal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'An object literal is quick to build and does not need to have the data passed
    down a constructor or `public` members to fill an object. An object literal is
    an efficient way to move data around. You can read a JSON file, receive the data
    from an Ajax call or from many sources, and cast to the desired type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'However, if you have many functions or more complex logic that needs to be
    encapsulated, a class is more pragmatic. The reason is that using an object literal
    would require assigning the function on each instance manually. Also, a class
    can contain a `private` function that you may not want to expose, provide encapsulation
    with `private`/`protected` and interfaces. An object literal''s fields are `public`
    and accessible. In the following example, we see data returned from an Ajax call.
    The expected type is `ObjectDefinition`, which has a function. The function doesn''t
    come for free like with a class during the initialization. Hence, it must be attached
    to the object. In that case, we need to refer to a variable that has a function.
    This can be tedious with complex definitions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'It is possible to reduce the burden of the previous example by having a `function`
    that builds each object literal by attaching the functions. In that case, the
    `function` returns the type of the object literal. This `function` acts as a constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The same code with a class looks like the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In that particular case, what can be interesting is to divide the fields from
    the functions and pass all the fields by an interface in the constructor. Here
    is a third version using an interface for the variables and the functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In terms of testability, a class has the advantage of allowing any of the members
    to be stubbed easily. Here is a simple example with the Jest library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: How an interface can be useful in object-oriented
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An interface serves many roles. We saw that you can define a contract for particular
    objects with an interface. However, interfaces can do much more.
  prefs: []
  type: TYPE_NORMAL
- en: 'An interface defines which members you want the consumer of your library to
    see and use. The `public`, `private`, and `protected` visibility keywords serve
    the same purpose. However, in some cases, you may need to have `public` members
    and still not allow everyone to use them. One reason can be that you want to have
    deep access to unit testing, hence having most of your members `public` allows
    you to black boxing functions testing. However, it might expose too much. Therefore,
    an interface can define every member that is accessible and be implemented by
    a class. Instead of passing the reference to the class directly, the interface
    is distributed externally while you can use the class internally:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The class has two `private` functions that are executed by the main function,
    named `mainFunction`. However, the encapsulation does not allow us to unit test
    the `private` function without using some hack to access these functions. We want
    to avoid casting the main object to any to access the function because, if these
    functions change, the test might fail not because of wrong logic but because TypeScript
    was not able to refactor the function since the type was coerced to any. A better
    practice is to use an interface to keep the type present at all times:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Everything is `public`, however, all the system is using `IClassA` instead of
    the class directly providing the encapsulation desired. The unit test can use
    the class and access the original `private` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A second case where the interface shines is that it allows us to have many
    concrete implementations of a specific type. You can define an interface that
    will be consumed by a function and has many implementations of this one. In the
    following example, we have a `consume` function that takes `IElement` as input.
    There are two concrete implementations of `IElement`, which gives the code the
    flexibility to have many element implementations. This help to reduce customized
    code in the consuming function by having a type that represents the minimum set
    of members needed to perform the task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Bringing abstraction with an abstract class
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstraction is an object-oriented concept that allows us to have a base class
    that delegates the implementation of a function to the class that extends the
    `abstract` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example creates the main class by instantiating the custom logic
    class. It invokes the main function, which will execute the `abstract` function.
    To the `MainClass` class, the `abstract` function is a black box. It only knows
    its name, parameter types, and returns types. The example executes the commented
    block code A-C-B in that particular order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The `abstract` is powerful when you pass a computed value to the `abstract`
    class and that this one also returns a result of a custom computation. Here is
    a second version that shows how two different implementations can occur while
    the main class remains unchanged. The main class is now named `Calculus` and has
    a `public` function that takes two numbers and returns a `Boolean`. It does some
    operations on the parameters and calls the delegated logic. The treatment of the
    value is unknown to the main class. The significant part of the operation is the
    result that is then used. On the side of the class that consumes the `abstract`
    class by extending the class. It has to provide all abstract functions or fields.
    Every `abstract` member becomes a `public` field at the extended level. In the
    example, the logic multiplies the two values that return the specified type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The code could have been written in a non-object-oriented way by providing
    by parameter the logic to execute. Here is the same version of the code without
    an `abstract`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The version without an `abstract` takes in the constructor of the class the
    function to be called instead of the abstract function. The substitution between
    the two is a matter of preference. The main difference between the two is that
    using abstract force the `abstract` implementation to be public when the delegate
    function can remain `private`. However, the way to work around the visibility
    issue is to initialize with the base class instead of the child class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: How to have a property that is read-only
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Read-only fields can be initialized once and don''t need to be changed during
    the lifetime of the instance. The `readonly` keyword can be used in an interface
    to specify that once the field is set, the value doesn''t change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'It can be at the class level where the value can be only set directly at the
    declaration or in the constructor. When a value is initialized next to the field''s
    declaration, this one can still be redefined by the constructor. The following
    example shows this edge case. However, it is possible to only set it at declaration
    or just at the `constructor` level, which is often the case:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Read-only with `static` can be useful to have constant for a particular class.
    The use of `const` is not allowed at a class level. If you want to centralize
    a value in the context of a particular class, the use of `public`, `static`, and
    `readonly` is an acceptable pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Enforcing a specific constructor from an interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is tricky because you cannot enforce by an interface the shape of a constructor.
    However, you can use an interface to ensure a class passed by the parameter has
    a specific constructor. The process requires two interfaces. One is the return
    type of the construction, and one is the interface used in the parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The first interface in this example has two members: one field and one function.
    The definition of the interface doesn''t matter, it can be anything you want to
    get an instance of the function. The second interface has a constructor function,
    known as *newable*. It uses the `new` keyword with the input parameters and what
    it needs to create. The type should be the first interface created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to create a function that takes the `newable` function and
    sets it as a parameter type. Optionally, you can have more parameters. In the
    example, a value for the constructor is passed. The return type of the function
    must be the type that the `newable` function returns. In this function, you can
    call `new` followed by the parameter of the interface that has the definition
    of the `newable` function. The code instantiates an instance of the class passed
    by the parameter. Only classes that respect the type contract of the `newable`
    function are accepted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the `Implementation1` class implements the returned implementation,
    hence will be a candidate for this function. It also has the constructor that
    takes a single-number parameter that will be invoked by the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'On the other hand, the following code does not compile because the class does
    not inherit the returned type defined by the `newable` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'An example that might not look valid but that compiles is the following code.
    It extends the returned class but does not respect the `newable` function argument
    that requires it to have a value. It is valid because the definition is only about
    the returned object and not the constructor. The constructor is called with a
    parameter, but the class doesn''t have to handle it. In the following code, printing
    the `arguments` variable shows that it has the `1` value passed as the first parameter
    even if not explicitly required by the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we visited many object-oriented features. TypeScript is closing
    the gap with well-known programming languages that are object-oriented such as C#
    or Java. TypeScript, being a superset of JavaScript, must palliate some weakness
    of JavaScript in this regard but finish with its head-up with many features that
    are acceptable to write a professional application in an object-oriented fashion.
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to work with encapsulation, which allows us to control the visibility
    of fields and functions. We discussed ways to strongly type a constructor, as
    well as how to use an interface to be implemented by a class. Within a class,
    we saw how to have static functions and abstraction functions. The next chapter
    will cover how we can identify precisely which type, object, or variable we are
    manipulating, allowing us to leverage specific members that are unique to each
    of them. We will see how to use JavaScript typecheckers, such as `typeof` and
    `instanceof`, and how to pattern with discriminator and defined guard for a structured
    type.
  prefs: []
  type: TYPE_NORMAL
