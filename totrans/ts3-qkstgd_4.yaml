- en: Transforming Your Code into Object-Oriented
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将您的代码转换为面向对象
- en: Object-oriented has its own set of jargon, and TypeScript relies on much of
    it. In this chapter, all the concepts of object-oriented that TypeScript supports
    are discussed with examples. We will see what a class is and how to instantiate
    a class into an object. We will also see how a constructor can be strongly typed
    with TypeScript, and how, with a shorthand syntax, we can assign a class's fields
    directly from the constructor. We will cover the principle of encapsulation with
    visibility, how to implement an interface, and how to bring abstraction to a class.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象有其自己的术语集，TypeScript 依赖于其中很多。在本章中，我们将使用示例讨论 TypeScript 支持的所有面向对象的概念。我们将看到类是什么以及如何将类实例化为对象。我们还将看到如何使用
    TypeScript 强类型化构造函数，以及如何使用简写语法直接从构造函数分配类的字段。我们将涵盖封装的可见性原则，如何实现接口，以及如何将抽象引入类。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What is a class and how do we define one?
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是什么以及我们如何定义一个？
- en: How type comes into play with a class's constructor
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类型如何与类的构造函数相互作用
- en: What is encapsulation using `public`, `private`, and `protected`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `public`、`private` 和 `protected` 的封装是什么
- en: Reducing the definition of a field with a value set at construction time
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在构造时设置值的字段定义的简化
- en: What is static?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是静态？
- en: Use cases for a non-public constructor
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非公共构造函数的使用场景
- en: Using an object from a class versus an object literal
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从类或对象字面量中使用对象
- en: How an interface can be useful in object-oriented
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口如何在面向对象中发挥作用
- en: Bringing abstraction with an abstract class
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用抽象类引入抽象
- en: How to have a property that is read-only
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何拥有只读属性
- en: Enforcing a specific constructor from an interface
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 强制从接口实现特定构造函数
- en: What is a class and how do we define one?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类是什么以及我们如何定义一个？
- en: At the core of object-oriented is the class. A class is a definition of what
    is available for an object once instantiated. A class holds variables and functions
    that were judged cohesive by the developer. A class can share information across
    all instances of the same class or have its own data, which is unique from the
    beginning of the life of the object until its death.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的核心是类。类是对一个对象一旦实例化后可用的定义。类包含开发者认为具有凝聚力的变量和函数。类可以共享同一类的所有实例的信息，或者拥有其自己的数据，这些数据从对象生命周期的开始到结束都是独一无二的。
- en: 'The creation of a class starts with the keyword `class` followed by the name
    of the class. It is similar to the creation of an interface:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 类的创建从关键字 `class` 开始，后面跟着类的名称。它与创建接口类似：
- en: '[PRE0]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'A class can define variables and functions. Each of them is `public` by default,
    meaning that they are accessible from outside the class by the name of the instance:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 类可以定义变量和函数。默认情况下，它们都是 `public` 的，这意味着可以通过实例的名称从类外部访问：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Once a class is defined, it can be instantiated. An instantiation means that
    a class becomes concrete and the life cycle for its content starts. To create
    an instance of a class, the `new` keyword must be used. After `new` comes the
    name of the class with parentheses:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦定义了类，就可以实例化它。实例化意味着类变得具体，其内容的生命周期开始。要创建类的实例，必须使用 `new` 关键字。在 `new` 之后是类的名称，后面跟着括号：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: How type comes into play with a class's constructor
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类型如何与类的构造函数相互作用
- en: 'The instantiation of a class calls the constructor of the class. If this one
    is not defined, nothing is called. When no constructor is defined, the parentheses
    do not have any argument. The constructor''s goal is to provide initialization
    of data to the class:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 类的实例化调用类的构造函数。如果没有定义，则不调用任何内容。当没有定义构造函数时，括号没有任何参数。构造函数的目的是为类提供数据初始化：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the case where the parameters are defined, the initialization must provide
    all the non-optional parameters. In the following code, the instantiation calls
    the constructor that has two parameters:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在参数已定义的情况下，初始化必须提供所有非可选参数。在以下代码中，实例化调用具有两个参数的构造函数：
- en: '[PRE4]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'A constructor is similar to a function but cannot have an override. There is
    only a single constructor that can be defined. By default, it is `public` if no
    visibility is provided:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数类似于函数但不能有重写。只能定义一个构造函数。如果没有提供可见性，默认情况下它是 `public` 的：
- en: '[PRE5]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'However, a constructor can be overloaded by many signatures. Similar to a function,
    the use of many definitions is possible with the use of a semicolon. In the following
    example, you can see that it is possible to instantiate the class with a single
    number or with a number and a string:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，构造函数可以通过多个签名进行重载。类似于函数，可以使用分号使用多个定义。在下面的例子中，你可以看到可以使用单个数字或数字和字符串来实例化类：
- en: '[PRE6]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'If a class extends another class, it must call `super` with the parameter of
    the right type to the base class. The class that inherits the second class does
    not need to have the same number of constructor parameters, nor the same type.
    What is important is the call to `super` to respect the type of the extended class.
    In the following example, `MyClass` has a constructor that takes a number and
    a string. The class that extends `MyClass`, `MyClass2`, must call `super` with
    a number and a string. The example illustrates that the value can come from the
    constructor of the class or can be computed directly:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类扩展了另一个类，它必须使用正确的类型参数调用`super`。继承第二个类的类不需要有相同数量的构造函数参数，也不需要相同的类型。重要的是`super`调用要尊重扩展类的类型。在下面的例子中，`MyClass`有一个接受数字和字符串的构造函数。扩展`MyClass`的类`MyClass2`必须使用数字和字符串调用`super`。这个例子说明了值可以来自类的构造函数，也可以直接计算：
- en: '[PRE7]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: What is encapsulation using public, private, and protected
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用`public`、`private`和`protected`进行封装是什么意思
- en: The use of `var`, `let`, and `const` is not available at a class level. Class
    declares by using the `public`, `private`, and `protected` encapsulation visibility
    keywords. The scope is conscribed to the class with some minor difference between
    the three.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在类级别上不可使用`var`、`let`和`const`。类通过使用`public`、`private`和`protected`封装可见性关键字来声明。作用域被限制在类中，三者之间有一些细微的差别。
- en: 'A class variable with the `public` keyword declaration allows the variable
    to be available inside and outside the class. The `public` modifier brings the
    instance of the class to allow it to read and write the value outside the class:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`public`关键字声明的类变量允许变量在类内外都可用。`public`修饰符将类的实例化，允许它在外部读取和写入值：
- en: '[PRE8]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'On the other hand, the `private` declaration restrains the access to the class
    itself. This is true for reading and writing:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`private`声明限制了对其本身的访问。这在读取和写入时都适用：
- en: '[PRE9]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Finally, a `protected` encapsulation is similar to `private` but it allows
    us to read and to write the value of the `protected` variable outside the class
    itself. However, the access is restricted to the class that declares the `protected`
    and the class that extends this one. A `protected` variable or function shares
    access down the hierarchy of classes. That means that all classes that inherit
    a class with `protected` members have access to the `protected` member:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`protected`封装类似于`private`，但它允许我们在类外部本身读取和写入`protected`变量的值。然而，访问被限制在声明`protected`的类以及扩展这个类的类。`protected`变量或函数在类层次结构中共享访问权限。这意味着所有继承具有`protected`成员的类的类都可以访问`protected`成员：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: In the example, the child class has access to the base class members that are
    `public` and `protected`. Once the child class is instantiated, only `public`
    variables are available. Private members are only available in the class where
    they are defined. This is true for variables and functions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例中，子类可以访问基类的`public`和`protected`成员。一旦子类被实例化，只有`public`变量可用。私有成员仅在其定义的类中可用。这对于变量和函数都适用。
- en: Reducing the definition of a field with a value set at construction time
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在构造时将字段定义的值集减小的操作
- en: 'It can be cumbersome to always set values from the constructor to a field.
    A possibility is to assign the field directly from the constructor signature into
    the class:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 总是从构造函数设置值到字段可能会很麻烦。一种可能性是直接从构造函数签名将字段赋值到类中：
- en: '[PRE11]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By setting the visibility of the encapsulation of each parameter of the constructor,
    a member is created with the same type. In the preceding example, two fields are
    created for the class with the name and the type of the parameter. The following
    code is exactly the same as the previous example, which is heavier in terms of
    definition and assignation:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 通过设置构造函数中每个参数的封装可见性，创建了一个具有相同类型的成员。在先前的例子中，为类创建了两个字段，分别对应参数的名称和类型。下面的代码与先前的例子完全相同，但在定义和赋值方面更为复杂：
- en: '[PRE12]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: What is static?
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是静态的？
- en: A static member is a member that can be accessed without instantiating the class.
    Everything that is static is shared across all instances for the life of your
    system. Static variables and functions are associated with the class, not an instance
    of the class or a particular object. If you are coming from JavaScript, you can
    see static as being a member associated with the prototype chain instance of the
    instance.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员是可以不实例化类即可访问的成员。所有静态成员在整个系统生命周期内都是共享的。静态变量和函数与类相关联，而不是与类的实例或特定对象相关联。如果你来自
    JavaScript，你可以将静态视为与实例的原型链实例关联的成员。
- en: 'Contrary to many other languages, TypeScript does not allow us to have a static
    class. It does not remove much, because if you need to have a static class, you
    just need to have the function directly inside the module instead of being in
    a class. If you want to have all your static classes inside a class and prevent
    the consumer of your library from instantiating the class, you can mark the class
    as abstract. An abstract class cannot be instantiated without being extended:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 与许多其他语言相反，TypeScript 不允许我们拥有静态类。它并没有减少多少，因为如果你需要一个静态类，你只需要将函数直接放在模块内部，而不是放在类中。如果你想将所有静态类放在一个类中，并防止你的库的用户实例化该类，你可以将类标记为抽象。抽象类不能在不被扩展的情况下实例化：
- en: '[PRE13]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Static members can be from all encapsulation visibilities: `public`, `protected`,
    or `private`. However, only `public` visibility is accessible from outside the
    class. The `private` and `protected` are available within the class that defines
    the status members. A protected member can be accessed from a class that extends
    another class with static members:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 静态成员可以是所有封装可见性：`public`、`protected` 或 `private`。然而，只有 `public` 可见性可以从类外部访问。`private`
    和 `protected` 在定义状态成员的类内部可用。受保护的成员可以从扩展了具有静态成员的另一个类的类中访问：
- en: '[PRE14]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Only `public static` members are accessible from outside the class. The `private`
    and `protected` are accessible within the class. To use any static members, the
    name of the class must be specified before the use of the member. This rule is
    also needed when inside the class. The `this` pointer is only available within
    an instance, and since static is not part of any instance but part of `class`,
    it cannot be reached with the instance''s `this` pointer:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 只有 `public static` 成员可以从类外部访问。`private` 和 `protected` 在类内部可访问。要使用任何静态成员，必须在成员使用之前指定类的名称。这个规则在类内部也是必要的。`this`
    指针仅在实例内部可用，由于静态不是任何实例的一部分，而是 `class` 的一部分，因此不能通过实例的 `this` 指针访问：
- en: '[PRE15]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Use cases for a non-public constructor
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非公共构造函数的使用场景
- en: 'A `private` constructor revokes the possibility to instantiate the class from
    the outside. The following code does not compile because the constructor is `private`.
    The same would also be true if the constructor were `protected`:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`private` 构造函数取消了从外部实例化类的可能性。以下代码无法编译，因为构造函数是 `private` 的。如果构造函数是 `protected`
    的，情况也会相同：'
- en: '[PRE16]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In that case, the only way to instantiate the class is by using a `public static`
    function that creates the object of the type class and returns it. In the following
    code, the `private` constructor creates an instance; to access this instance, `GetInstance`
    is used, which is static and does not need to have an instance to be called:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，实例化类的唯一方法是通过使用创建类型为 `class` 的对象的 `public static` 函数，并返回它。在以下代码中，`private`
    构造函数创建了一个实例；要访问此实例，使用 `GetInstance`，它是一个静态方法，不需要实例即可调用：
- en: '[PRE17]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: A known pattern is to have a `SingletonClass`. Only a single instance of the
    class exists and this control can be managed by having a single function that
    uses `new` once and then always returns the same instance. Another use case is
    to have a factory that creates all the instances.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个已知的模式是拥有一个 `SingletonClass`。该类只有一个实例存在，并且可以通过使用一次 `new` 并始终返回相同实例的单个函数来管理这种控制。另一个用例是拥有一个创建所有实例的工厂。
- en: Using an object from a class versus an object literal
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用类对象与对象字面量
- en: 'An object literal is quick to build and does not need to have the data passed
    down a constructor or `public` members to fill an object. An object literal is
    an efficient way to move data around. You can read a JSON file, receive the data
    from an Ajax call or from many sources, and cast to the desired type:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 对象字面量构建快速，不需要通过构造函数或 `public` 成员传递数据来填充对象。对象字面量是移动数据的高效方式。你可以读取 JSON 文件，从 Ajax
    调用或许多其他来源接收数据，并将其转换为所需类型：
- en: '[PRE18]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'However, if you have many functions or more complex logic that needs to be
    encapsulated, a class is more pragmatic. The reason is that using an object literal
    would require assigning the function on each instance manually. Also, a class
    can contain a `private` function that you may not want to expose, provide encapsulation
    with `private`/`protected` and interfaces. An object literal''s fields are `public`
    and accessible. In the following example, we see data returned from an Ajax call.
    The expected type is `ObjectDefinition`, which has a function. The function doesn''t
    come for free like with a class during the initialization. Hence, it must be attached
    to the object. In that case, we need to refer to a variable that has a function.
    This can be tedious with complex definitions:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您有许多函数或更复杂的逻辑需要封装，类更实用。原因是使用对象字面量需要手动在每个实例上分配函数。此外，类可以包含您可能不想公开的`private`函数，提供`private`/`protected`和接口的封装。对象字面量的字段是`public`且可访问的。在以下示例中，我们看到从Ajax调用返回的数据。预期的类型是`ObjectDefinition`，它有一个函数。这个函数不像类在初始化期间那样免费提供。因此，它必须附加到对象上。在这种情况下，我们需要引用一个具有函数的变量。对于复杂的定义，这可能会很繁琐：
- en: '[PRE19]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'It is possible to reduce the burden of the previous example by having a `function`
    that builds each object literal by attaching the functions. In that case, the
    `function` returns the type of the object literal. This `function` acts as a constructor:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过有一个`function`来构建每个对象字面量，通过附加函数来减轻前面示例的负担。在这种情况下，`function`返回对象字面量的类型。这个`function`充当构造函数：
- en: '[PRE20]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The same code with a class looks like the following code:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 使用类编写的相同代码如下所示：
- en: '[PRE21]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In that particular case, what can be interesting is to divide the fields from
    the functions and pass all the fields by an interface in the constructor. Here
    is a third version using an interface for the variables and the functions:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个特定的情况下，有趣的是将字段从函数中分离出来，并通过构造函数使用接口传递所有字段。以下是使用接口变量和函数的第三个版本：
- en: '[PRE22]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In terms of testability, a class has the advantage of allowing any of the members
    to be stubbed easily. Here is a simple example with the Jest library:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在可测试性的方面，类具有允许任何成员容易被模拟的优势。以下是一个使用Jest库的简单示例：
- en: '[PRE23]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: How an interface can be useful in object-oriented
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 接口在面向对象中的用途
- en: An interface serves many roles. We saw that you can define a contract for particular
    objects with an interface. However, interfaces can do much more.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 接口扮演着许多角色。我们看到了您可以使用接口为特定对象定义一个合同。然而，接口可以做更多的事情。
- en: 'An interface defines which members you want the consumer of your library to
    see and use. The `public`, `private`, and `protected` visibility keywords serve
    the same purpose. However, in some cases, you may need to have `public` members
    and still not allow everyone to use them. One reason can be that you want to have
    deep access to unit testing, hence having most of your members `public` allows
    you to black boxing functions testing. However, it might expose too much. Therefore,
    an interface can define every member that is accessible and be implemented by
    a class. Instead of passing the reference to the class directly, the interface
    is distributed externally while you can use the class internally:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 接口定义了您希望库的消费者看到和使用哪些成员。`public`、`private`和`protected`可见性关键字服务于相同的目的。然而，在某些情况下，您可能需要具有`public`成员，同时又不允许每个人使用它们。一个原因可能是您希望对单元测试有深入访问，因此将大多数成员设置为`public`允许您进行黑盒函数测试。然而，这可能会暴露太多。因此，接口可以定义所有可访问的成员，并由类实现。您可以直接传递类的引用，而接口则在外部分布，您可以在内部使用类：
- en: '[PRE24]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The class has two `private` functions that are executed by the main function,
    named `mainFunction`. However, the encapsulation does not allow us to unit test
    the `private` function without using some hack to access these functions. We want
    to avoid casting the main object to any to access the function because, if these
    functions change, the test might fail not because of wrong logic but because TypeScript
    was not able to refactor the function since the type was coerced to any. A better
    practice is to use an interface to keep the type present at all times:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 类有两个由主函数`mainFunction`调用的`private`函数。然而，封装不允许我们不使用一些黑客手段来访问这些函数而进行单元测试。我们希望避免将主对象强制转换为任何类型来访问函数，因为这些函数如果发生变化，测试可能会失败，不是因为逻辑错误，而是因为TypeScript无法重构函数，因为类型被强制转换为任何类型。更好的做法是使用接口来保持类型始终存在：
- en: '[PRE25]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Everything is `public`, however, all the system is using `IClassA` instead of
    the class directly providing the encapsulation desired. The unit test can use
    the class and access the original `private` function.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然一切都是`公共`的，但整个系统都在使用`IClassA`而不是直接提供所需封装的类。单元测试可以使用该类并访问原始的`私有`函数。
- en: 'A second case where the interface shines is that it allows us to have many
    concrete implementations of a specific type. You can define an interface that
    will be consumed by a function and has many implementations of this one. In the
    following example, we have a `consume` function that takes `IElement` as input.
    There are two concrete implementations of `IElement`, which gives the code the
    flexibility to have many element implementations. This help to reduce customized
    code in the consuming function by having a type that represents the minimum set
    of members needed to perform the task:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个案例中，接口的亮点在于它允许我们有许多特定类型的具体实现。你可以定义一个接口，该接口将被函数消费，并且有多个此类实现。在以下示例中，我们有一个`consume`函数，它接受`IElement`作为输入。`IElement`有两个具体实现，这使代码具有许多元素实现的灵活性。这有助于通过具有表示执行任务所需的最小成员集的类型来减少消费函数中的自定义代码：
- en: '[PRE26]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Bringing abstraction with an abstract class
  id: totrans-83
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用抽象类引入抽象
- en: Abstraction is an object-oriented concept that allows us to have a base class
    that delegates the implementation of a function to the class that extends the
    `abstract` class.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象是一种面向对象的概念，它允许我们有一个基类，该类将函数的实现委托给扩展`抽象`类的类。
- en: 'The following example creates the main class by instantiating the custom logic
    class. It invokes the main function, which will execute the `abstract` function.
    To the `MainClass` class, the `abstract` function is a black box. It only knows
    its name, parameter types, and returns types. The example executes the commented
    block code A-C-B in that particular order:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例通过实例化自定义逻辑类来创建主类。它调用主函数，该函数将执行`抽象`函数。对于`MainClass`类，`抽象`函数是一个黑盒。它只知道其名称、参数类型和返回类型。示例按照特定的顺序执行注释块代码A-C-B：
- en: '[PRE27]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The `abstract` is powerful when you pass a computed value to the `abstract`
    class and that this one also returns a result of a custom computation. Here is
    a second version that shows how two different implementations can occur while
    the main class remains unchanged. The main class is now named `Calculus` and has
    a `public` function that takes two numbers and returns a `Boolean`. It does some
    operations on the parameters and calls the delegated logic. The treatment of the
    value is unknown to the main class. The significant part of the operation is the
    result that is then used. On the side of the class that consumes the `abstract`
    class by extending the class. It has to provide all abstract functions or fields.
    Every `abstract` member becomes a `public` field at the extended level. In the
    example, the logic multiplies the two values that return the specified type:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 当将计算值传递给`抽象`类并且该类也返回自定义计算的结果时，`抽象`功能非常强大。这里有一个第二版本，展示了在主类保持不变的情况下，如何出现两种不同的实现。主类现在命名为`Calculus`，有一个`公共`函数，该函数接受两个数字并返回一个`布尔值`。它对参数进行一些操作并调用委托逻辑。对值的处理对主类来说是未知的。操作的重要部分是随后使用的那个结果。在通过扩展类消费`抽象`类的类的一侧。它必须提供所有抽象函数或字段。每个`抽象`成员在扩展级别都成为`公共`字段。在示例中，逻辑将两个值相乘并返回指定的类型：
- en: '[PRE28]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The code could have been written in a non-object-oriented way by providing
    by parameter the logic to execute. Here is the same version of the code without
    an `abstract`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 代码可以通过提供执行逻辑的参数以非面向对象的方式编写。以下是相同代码的版本，没有使用`抽象`：
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The version without an `abstract` takes in the constructor of the class the
    function to be called instead of the abstract function. The substitution between
    the two is a matter of preference. The main difference between the two is that
    using abstract force the `abstract` implementation to be public when the delegate
    function can remain `private`. However, the way to work around the visibility
    issue is to initialize with the base class instead of the child class:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 没有使用`抽象`的版本将函数调用传递给类的构造函数，而不是传递抽象函数。这两种方法之间的替换是个人偏好的问题。两者之间的主要区别在于，使用抽象强制`抽象`实现为公共的，而委托函数可以保持`私有`。然而，解决可见性问题的一种方法是用基类而不是子类进行初始化：
- en: '[PRE30]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: How to have a property that is read-only
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何拥有只读属性
- en: 'Read-only fields can be initialized once and don''t need to be changed during
    the lifetime of the instance. The `readonly` keyword can be used in an interface
    to specify that once the field is set, the value doesn''t change:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 只读字段只能初始化一次，在实例的生命周期内不需要更改。可以使用`readonly`关键字在接口中指定一旦字段被设置，值就不会改变：
- en: '[PRE31]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'It can be at the class level where the value can be only set directly at the
    declaration or in the constructor. When a value is initialized next to the field''s
    declaration, this one can still be redefined by the constructor. The following
    example shows this edge case. However, it is possible to only set it at declaration
    or just at the `constructor` level, which is often the case:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以在类级别，此时值只能直接在声明或构造函数中设置。当值在字段声明旁边初始化时，这个值仍然可以被构造函数重新定义。以下示例展示了这种边缘情况。然而，它只可以在声明或仅在`constructor`级别设置，这通常是情况：
- en: '[PRE32]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Read-only with `static` can be useful to have constant for a particular class.
    The use of `const` is not allowed at a class level. If you want to centralize
    a value in the context of a particular class, the use of `public`, `static`, and
    `readonly` is an acceptable pattern:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用`static`的只读可以用来为特定类创建一个常量。在类级别不允许使用`const`。如果你想在特定类的上下文中集中一个值，使用`public`、`static`和`readonly`是一个可接受的模式：
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Enforcing a specific constructor from an interface
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从接口强制执行特定的构造函数
- en: 'This is tricky because you cannot enforce by an interface the shape of a constructor.
    However, you can use an interface to ensure a class passed by the parameter has
    a specific constructor. The process requires two interfaces. One is the return
    type of the construction, and one is the interface used in the parameter:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棘手，因为你不能通过接口强制执行构造函数的形状。然而，你可以使用接口来确保通过参数传递的类具有特定的构造函数。这个过程需要两个接口。一个是构造的返回类型，另一个是用于参数的接口：
- en: '[PRE34]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The first interface in this example has two members: one field and one function.
    The definition of the interface doesn''t matter, it can be anything you want to
    get an instance of the function. The second interface has a constructor function,
    known as *newable*. It uses the `new` keyword with the input parameters and what
    it needs to create. The type should be the first interface created:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，第一个接口有两个成员：一个字段和一个函数。接口的定义无关紧要，它可以是你想要获取函数实例的任何内容。第二个接口有一个构造函数，称为*newable*。它使用`new`关键字和输入参数以及它需要创建的内容。类型应该是创建的第一个接口：
- en: '[PRE35]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The next step is to create a function that takes the `newable` function and
    sets it as a parameter type. Optionally, you can have more parameters. In the
    example, a value for the constructor is passed. The return type of the function
    must be the type that the `newable` function returns. In this function, you can
    call `new` followed by the parameter of the interface that has the definition
    of the `newable` function. The code instantiates an instance of the class passed
    by the parameter. Only classes that respect the type contract of the `newable`
    function are accepted:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个函数，该函数接受`newable`函数并将其设置为参数类型。可选地，你可以有更多参数。在示例中，传递了一个构造函数的值。函数的返回类型必须是`newable`函数返回的类型。在这个函数中，你可以调用`new`后跟具有`newable`函数定义的接口参数。代码实例化了通过参数传递的类的实例。只有遵守`newable`函数类型合同的类才被接受：
- en: '[PRE36]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: In the preceding code, the `Implementation1` class implements the returned implementation,
    hence will be a candidate for this function. It also has the constructor that
    takes a single-number parameter that will be invoked by the function.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Implementation1`类实现了返回的实现，因此将成为此函数的候选者。它还有一个接受单个数字参数的构造函数，该参数将由函数调用。
- en: 'On the other hand, the following code does not compile because the class does
    not inherit the returned type defined by the `newable` function:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，以下代码无法编译，因为该类没有继承由`newable`函数定义的返回类型：
- en: '[PRE37]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'An example that might not look valid but that compiles is the following code.
    It extends the returned class but does not respect the `newable` function argument
    that requires it to have a value. It is valid because the definition is only about
    the returned object and not the constructor. The constructor is called with a
    parameter, but the class doesn''t have to handle it. In the following code, printing
    the `arguments` variable shows that it has the `1` value passed as the first parameter
    even if not explicitly required by the class:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一个可能看起来不合法但可以编译的示例代码。它扩展了返回的类，但不尊重需要它具有值的`newable`函数参数。这是有效的，因为定义仅关于返回的对象，而不是构造函数。构造函数使用参数调用，但类不必处理它。在下面的代码中，打印`arguments`变量显示它具有作为第一个参数传递的`1`值，即使类没有明确要求：
- en: '[PRE38]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Summary
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we visited many object-oriented features. TypeScript is closing
    the gap with well-known programming languages that are object-oriented such as C#
    or Java. TypeScript, being a superset of JavaScript, must palliate some weakness
    of JavaScript in this regard but finish with its head-up with many features that
    are acceptable to write a professional application in an object-oriented fashion.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了众多面向对象特性。TypeScript正在缩小与已知面向对象编程语言（如C#或Java）的差距。作为JavaScript的超集，TypeScript必须弥补JavaScript在这方面的一些弱点，但最终凭借其众多特性，以面向对象的方式编写专业应用程序成为可能。
- en: We saw how to work with encapsulation, which allows us to control the visibility
    of fields and functions. We discussed ways to strongly type a constructor, as
    well as how to use an interface to be implemented by a class. Within a class,
    we saw how to have static functions and abstraction functions. The next chapter
    will cover how we can identify precisely which type, object, or variable we are
    manipulating, allowing us to leverage specific members that are unique to each
    of them. We will see how to use JavaScript typecheckers, such as `typeof` and
    `instanceof`, and how to pattern with discriminator and defined guard for a structured
    type.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了如何使用封装，这使我们能够控制字段和函数的可见性。我们讨论了如何强类型化构造函数，以及如何使用接口让类实现。在一个类内部，我们看到了如何拥有静态函数和抽象函数。下一章将介绍我们如何精确地识别我们正在操作的类型、对象或变量，从而利用它们各自独特的特定成员。我们将看到如何使用JavaScript类型检查器，如`typeof`和`instanceof`，以及如何对结构化类型使用判别器和定义守卫。
