<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Patterns and Architectures in JavaScript and TypeScript</h1></div></div></div><p>In the previous four chapters, we've walked through common and classical design patterns and discussed some of their variants in JavaScript or TypeScript. In this chapter, we'll continue with some architecture and patterns closely related to the language and their common applications. We don't have many pages to expand and certainly cannot cover everything in a single chapter, so please take it as an appetizer and feel free to explore more.</p><p>Many topics in this chapter are related to asynchronous programming. We'll start with a web architecture for Node.js that's based on Promise. This is a larger topic that has interesting ideas involved, including abstractions of responses and permissions, as well as error handling tips. Then we'll talk about how to organize modules with <strong>ECMAScript</strong> (<strong>ES</strong>) module syntax. And this chapter will end with several useful asynchronous techniques.</p><p>Overall, we'll have the following topics covered in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Architecture and techniques related to Promise</li><li class="listitem" style="list-style-type: disc">Abstraction of responses and permissions in a web application</li><li class="listitem" style="list-style-type: disc">Modularizing a project to scale</li><li class="listitem" style="list-style-type: disc">Other useful asynchronous techniques</li></ul></div><div><div><h3 class="title"><a id="note49"/>Note</h3><p>Again, due to the limited length, some of the related code is aggressively simplified and nothing more than the idea itself can be applied practically.</p></div></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec43"/>Promise-based web architecture</h1></div></div></div><p>To have a better understanding of the differences between Promises and traditional callbacks, consider an asynchronous task like this:</p><pre class="programlisting">function process(callback) { &#13;
  stepOne((error, resultOne) =&gt; { &#13;
    if (error) { &#13;
      callback(error); &#13;
       return; &#13;
      } &#13;
 &#13;
  stepTwo(resultOne, (error, resultTwo) =&gt; { &#13;
    if (error) { &#13;
      callback(error); &#13;
        return; &#13;
    } &#13;
 &#13;
    callback(undefined, resultTwo + 1); &#13;
    }); &#13;
  }); &#13;
} &#13;
 &#13;
</pre><p>If we write preceding above in Promise style, it would be as follows:</p><pre class="programlisting">function process() { &#13;
  return stepOne() &#13;
    .then(result =&gt; stepTwo(result)) &#13;
    &#13;
.then(result =&gt; result + 1); &#13;
}&#13;
</pre><p>As in the preceding example, Promise makes it easy and <em>natural</em> to write asynchronous operations with a flat chain instead of nested callbacks. But the most exciting thing about Promise might be the benefits it brings to error handling. In a Promise-based architecture, throwing an error can be safe and pleasant. You don't have to explicitly handle errors when chaining asynchronous operations, and this makes mistakes less likely to happen.</p><p>With the growing usage with ES6 compatible runtimes, Promise is already there out of the box. And we actually have plenty of polyfills for Promises (including my <code class="literal">
<em>ThenFail</em>
</code> written in TypeScript), as people who write JavaScript roughly refer to the same group of people who created wheels.</p><p>Promises work well with other Promises:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A <em>Promises/A+</em> -compatible implementation should work with other <em>Promises/A+</em> -compatible implementations</li><li class="listitem" style="list-style-type: disc">Promises work best in a Promise-based architecture</li></ul></div><p>If you are new to Promise, you might be complaining about using Promises with a callback-based project. Using asynchronous helpers such as <code class="literal">Promise.each</code> (non-standard) provided by Promise libraries is a common reason for people to try out Promise, but it turns out they have better alternatives (for a callback-based project) such as the popular <code class="literal">async</code> library.</p><p>The reason that makes you decide to switch should not be these helpers (as there are a lot of them for old-school callbacks as well), but an easier way to handle errors or to take advantage of the ES <code class="literal">async</code>/<code class="literal">await</code> feature, which is based on Promise.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec112"/>Promisifying existing modules or libraries</h2></div></div></div><p>Though Promises do best in a Promise-based architecture, it is still possible to begin using Promise with a smaller scope by promisifying existing modules or libraries.</p><p>Let's take Node.js style callbacks as an example:</p><pre class="programlisting">import * as FS from 'fs'; &#13;
 &#13;
FS.readFile('some-file.txt', 'utf-8', (error, text) =&gt; { &#13;
  if (error) { &#13;
    console.error(error); &#13;
    return; &#13;
  } &#13;
 &#13;
  console.log('Content:', text); &#13;
});  &#13;
</pre><p>You may expect a promisified version of the <code class="literal">readFile</code> function to look like the following:</p><pre class="programlisting">FS &#13;
  .readFile('some-file.txt', 'utf-8') &#13;
  .then(text =&gt; { &#13;
    console.log('Content:', text); &#13;
  }) &#13;
  .catch(reason =&gt; { &#13;
    Console.error(reason); &#13;
  }); &#13;
</pre><p>The implementation of the promisified function <code class="literal">readFile</code> can be easy:</p><pre class="programlisting">function readFile(path: string, options: any): Promise&lt;string&gt; { &#13;
  return new Promise((resolve, reject) =&gt; { &#13;
    FS.readFile(path, options, (error, result) =&gt; { &#13;
      if (error) { &#13;
        reject(error); &#13;
      } else { &#13;
        resolve(result); &#13;
      } &#13;
    }); &#13;
  }); &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note50"/>Note</h3><p>I am using the type <code class="literal">any</code> here for parameter options to reduce the size of the code example, but I would suggest not using <code class="literal">any</code> whenever possible in practice.</p></div></div><p>There are libraries that are able to promisify methods automatically. Though, unfortunately, you might need to write declaration files yourself for the promisified methods if there are no promisified version available.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec113"/>Views and controllers in Express</h2></div></div></div><p>Many of us may have already worked with frameworks such as <strong>Express</strong>. And this is how we render a view or response with JSON in Express:</p><pre class="programlisting">import * as Path from 'path'; &#13;
import * as express from 'express'; &#13;
 &#13;
let app = express(); &#13;
 &#13;
app.set('engine', 'hbs'); &#13;
app.set('views', Path.join(__dirname, '../views')); &#13;
 &#13;
app.get('/page', (req, res) =&gt; { &#13;
  res.render('page', { &#13;
    title: 'Hello, Express!', &#13;
    content: '...' &#13;
  }); &#13;
}); &#13;
 &#13;
app.get('/data', (req, res) =&gt; { &#13;
  res.json({ &#13;
    version: '0.0.0', &#13;
    items: [] &#13;
  }); &#13;
}); &#13;
 &#13;
app.listen(1337); &#13;
</pre><p>We will usually separate controllers from the routing configuration:</p><pre class="programlisting">import { Request, Response } from 'express'; &#13;
 &#13;
export function page(req: Request, res: Response): void { &#13;
  res.render('page', { &#13;
    title: 'Hello, Express!', &#13;
    content: '...' &#13;
  }); &#13;
} &#13;
</pre><p>Thus we may have a better idea of existing routes, and have controllers managed more easily. Furthermore, automated routing could be introduced so that we don't always need to update routing manually:</p><pre class="programlisting">import * as glob from 'glob'; &#13;
 &#13;
let controllersDir = Path.join(__dirname, 'controllers'); &#13;
 &#13;
let controllerPaths = glob.sync('**/*.js', { &#13;
    cwd: controllersDir &#13;
}); &#13;
 &#13;
for (let path of controllerPaths) { &#13;
    let controller = require(Path.join(controllersDir, path)); &#13;
    let urlPath = path.replace(/\\/g, '/').replace(/\.js$/, ''); &#13;
 &#13;
    for (let actionName of Object.keys(controller)) { &#13;
        app.get( &#13;
            `/${urlPath}/${actionName}`, &#13;
            controller[actionName] &#13;
        ); &#13;
    } &#13;
} &#13;
</pre><p>The implementation above is certainly too simple to cover daily use, but it shows a rough idea of how automated routing could work: via conventions based on file structures.</p><p>Now, if we are working with asynchronous code written in Promises, an action in the controller could be like the following:</p><pre class="programlisting">export function foo(req: Request, res: Response): void { &#13;
    Promise &#13;
        .all([ &#13;
            Post.getContent(), &#13;
            Post.getComments() &#13;
        ]) &#13;
        .then(([post, comments]) =&gt; { &#13;
            res.render('foo', { &#13;
                post, &#13;
                comments &#13;
            }); &#13;
        }); &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note51"/>Note</h3><p>We are destructuring  an array within a parameter. <code class="literal">Promise.all</code> returns a Promise of an array with elements corresponding to the values of the resolvables passed in. (A resolvable means a normal value or a Promise-like object that may resolve to a normal value.)</p></div></div><p>But that's not enough; we still need to handle errors properly, or in some Promise implementations, the preceding code may fail in silence because the Promise chain is not handled by a rejection handler (which is terrible). In Express, when an error occurs, you should call <code class="literal">next</code> (the third argument passed into the callback) with the error object:</p><pre class="programlisting">import { Request, Response, NextFunction } from 'express'; &#13;
 &#13;
export function foo( &#13;
  req: Request, &#13;
  res: Response, &#13;
  <strong>next: NextFunction</strong> &#13;
): void { &#13;
  Promise &#13;
    // ... &#13;
    <strong>.catch(reason =&gt; next(reason));</strong> &#13;
} &#13;
</pre><p>Now, we are fine with the correctness of this approach, but that's simply not how Promises work. Explicit error handling with callbacks could be eliminated in the scope of controllers, and the easiest way is to return the Promise chain and hand over to code that was previously doing routing logic. So the controller could be written like this:</p><pre class="programlisting">
<strong>export function foo(req: Request, res: Response) { &#13;
  return Promise &#13;
</strong>    .all([ &#13;
      Post.getContent(), &#13;
      Post.getComments() &#13;
    ]) &#13;
    .then(([post, comments]) =&gt; { &#13;
      res.render('foo', { &#13;
        post, &#13;
        comments &#13;
            }); &#13;
        }); &#13;
}&#13;
</pre><p>But, could we make it even better?</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec114"/>Abstraction of responses</h2></div></div></div><p>We've already been returning a Promise to tell whether an error occurs. So now the returned Promise indicates the status of the response: success or failure. But why we are still calling <code class="literal">res.render()</code> for rendering the view? The returned promise object could be the response itself rather than just an error indicator.</p><p>Think about the controller again:</p><pre class="programlisting">export class Response { }&#13;
&#13;
export class PageResponse extends Response {    &#13;
  constructor(view: string, data: any) { }&#13;
}&#13;
&#13;
<strong>export function foo(req: Request) {</strong> &#13;
  return Promise &#13;
    .all([ &#13;
      Post.getContent(), &#13;
      Post.getComments() &#13;
    ]) &#13;
    .then(([post, comments]) =&gt; { &#13;
      <strong>return new PageResponse('foo', { &#13;
        post, &#13;
        comments</strong> &#13;
      }); &#13;
    }); &#13;
} &#13;
</pre><p>The response object returned could vary for different response outputs. For example, it could be either a <code class="literal">PageResponse</code> like it is in the preceding example, a <code class="literal">JSONResponse</code>, a <code class="literal">StreamResponse</code>, or even a simple <code class="literal">Redirection</code>.</p><p>As, in most cases, <code class="literal">PageResponse</code> or <code class="literal">JSONResponse</code> is applied, and the view of a <code class="literal">PageResponse</code> can usually be implied by the controller path and action name, it is useful to have those two responses automatically generated from a plain data object with a proper view to render with:</p><pre class="programlisting">export function foo(req: Request) { &#13;
  return Promise &#13;
    .all([ &#13;
      Post.getContent(), &#13;
      Post.getComments() &#13;
    ]) &#13;
    .then(([post, comments]) =&gt; { &#13;
      return { &#13;
        post, &#13;
        comments &#13;
      }; &#13;
    }); &#13;
} &#13;
 &#13;
</pre><p>And that's how a Promise-based controller should respond. With this idea, let's update the routing code with the abstraction of responses. Previously, we were passing controller actions directly as Express request handlers. Now we need to do some wrapping up with the actions by resolving the return value, and applying operations based on the resolved result:</p><div><ol class="orderedlist arabic"><li class="listitem">If it fulfils and it's an instance of <code class="literal">Response</code>, apply it to the <code class="literal">res</code> object passed in by Express.</li><li class="listitem">If it fulfils and it's a plain object, construct a <code class="literal">PageResponse</code> or a <code class="literal">JSONResponse</code> if no view found and apply it to the <code class="literal">res</code> object.</li><li class="listitem">If it rejects, call the <code class="literal">next</code> function with the reason.</li></ol></div><p>Previously, it was like this:</p><pre class="programlisting">app.get(`/${urlPath}/${actionName}`, controller[actionName]); &#13;
</pre><p>Now it gets a few more lines:</p><pre class="programlisting">let action = controller[actionName]; &#13;
 &#13;
app.get(`/${urlPath}/${actionName}`, (req, res, next) =&gt; { &#13;
  Promise &#13;
    .resolve(action(req)) &#13;
    .then(result =&gt; { &#13;
      if (result instanceof Response) { &#13;
        result.applyTo(res); &#13;
      } else if (existsView(actionName)) { &#13;
        new PageResponse(actionName, result).applyTo(res); &#13;
      } else { &#13;
        new JSONResponse(result).applyTo(res); &#13;
      } &#13;
    }) &#13;
    .catch(reason =&gt; next(reason)); &#13;
}); &#13;
</pre><p>However, so far we can handle only <code class="literal">GET</code> requests as we hardcoded <code class="literal">app.get()</code> in our router implementation. The poor view-matching logic can hardly be used in practice either. We need to make the actions configurable, and ES decorators could do nice work here:</p><pre class="programlisting">export default class Controller { &#13;
  @get({ &#13;
    view: 'custom-view-path' &#13;
  }) &#13;
    foo(req: Request) { &#13;
      return { &#13;
        title: 'Action foo', &#13;
        content: 'Content of action foo' &#13;
      }; &#13;
    } &#13;
} &#13;
</pre><p>I'll leave the implementation to you, and feel free to make it awesome.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec115"/>Abstraction of permissions</h2></div></div></div><p>Permissions play an important role in a project, especially in systems that have different user groups, for example, a forum. The abstraction of permissions should be extendable to satisfy changing requirements, and it should be easy to use as well.</p><p>Here, we are going to talk about the abstraction of permission in the level of controller actions. Consider the legibility of performing one or more actions as a <em>
<strong>privilege</strong>.</em> The permission of a user may consist of several privileges and usually most users at the same level would have the same set of privileges. So we may have a larger concept, namely <em>
<strong>groups</strong>.</em>
</p><p>The abstraction could either work based on both groups and privileges or based on privileges only (groups are then just aliases to sets of privileges):</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Abstractions that validate based on privileges and groups at the same time is easier to build. You do not need to create a large list of which actions can be performed for a certain group of users; granular privileges are only required when necessary.</li><li class="listitem" style="list-style-type: disc">Abstractions that validate based on privileges have better control and more flexibility for describing the permission. For example, you can remove a small set of privileges from the permission of a user easily.</li></ul></div><p>However, both approaches have similar upper-level abstractions and differ mostly in implementation. The general structure of the permission abstractions we've talked about is as follows:</p><p>
</p><div><img src="img/image_07_001.jpg" alt="Abstraction of permissions"/></div><p>
</p><p>The participants include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Privilege</strong>: Describes detailed privileges corresponding to specific actions</li><li class="listitem" style="list-style-type: disc"><strong>Group</strong>: Defines a set of privileges</li><li class="listitem" style="list-style-type: disc"><strong>Permission</strong>: Describes what a user is capable of doing; consists of groups the user belongs to and privileges the user has</li><li class="listitem" style="list-style-type: disc"><strong>Permission descriptor</strong>: Describes how the permission of a user would be sufficient; consists of <em>possible</em> groups and privileges</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec116"/>Expected errors</h2></div></div></div><p>A great concern wiped away by using Promises is that we do not need to worry about throwing an error in a <code class="literal">callback</code> would crash the application most of the time. The error will flow through the Promises chain and, if not caught, will be handled by our router. Errors can be roughly divided into <strong>expected errors</strong> and <strong>unexpected errors</strong>. Expected errors are usually caused by incorrect input or foreseeable exceptions, and unexpected errors are usually caused by bugs or other libraries the project relies on.</p><p>For expected errors, we usually want to give user-friendly responses with readable error messages and codes, so that users can help themselves to find solutions or report to us with useful context. For unexpected errors, we would also want reasonable responses (usually messages described as unknown errors), a detailed server-side log (including the real error name, message, stack information, and so on), and even alarms for getting the team notified as soon as possible.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec34"/>Defining and throwing expected errors</h3></div></div></div><p>The router will need to handle different types of errors, and an easy way to achieve that is to subclass a universal <code class="literal">ExpectedError</code> class and throw its instances out:</p><pre class="programlisting">import ExtendableError from 'extendable-error'; &#13;
 &#13;
class ExpectedError extends ExtendableError { &#13;
  constructor( &#13;
    message: string, &#13;
    public code: number &#13;
  ) { &#13;
    super(message); &#13;
  } &#13;
} &#13;
</pre><div><div><h3 class="title"><a id="note52"/>Note</h3><p>The <code class="literal">extendable-error</code> is a package of mine that handles stack trace and the <code class="literal">message</code> property. You can directly extend the <code class="literal">Error</code> class as well.</p></div></div><p>Thus, when receiving an expected error, we can safely output its message as part of the response. And if it's not an instance of <code class="literal">ExpectedError</code>, we can then output predefined <code class="literal">unknown</code> error messages and have detailed error information logged.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec35"/>Transforming errors</h3></div></div></div><p>Some errors, such as those caused by unstable networks or remote services, are expected; we may want to catch those errors and throw them out again as expected errors. But it is rather trivial to actually do that. A centralized error-transforming process can then be applied to reduce the efforts required to manage those errors.</p><p>The transforming process includes two parts: filtering (or matching) and transforming. There are many approaches to filter errors, such as the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Filter by error class</strong>: Many third-party libraries throw errors of certain classes. Taking Sequelize (a popular Node.js ORM) as an example, it throws <code class="literal">DatabaseError</code>, <code class="literal">ConnectionError</code>, <code class="literal">ValidationError</code>, and so on. By filtering errors by checking whether they are instances of a certain error class, we may easily pick up target errors from the pile.</li><li class="listitem" style="list-style-type: disc"><strong>Filter by string or regular expression</strong>: Sometimes a library might be throwing errors that are instances of an <code class="literal">Error</code> class itself instead of its subclasses; this makes those errors harder to distinguish from others. In this situation, we may filter those errors by their message, with keywords or regular expressions.</li><li class="listitem" style="list-style-type: disc"><strong>Filter by scope</strong>: It's possible that instances of the same error class with the same error message should result in different responses. One of the reasons might be that the operation that throws a certain error is at a lower level, but is being used by upper structures within different scopes. Thus, a <code class="literal">scope</code> mark could be added for those errors and make them easier to be filtered.</li></ul></div><p>There could be more ways to filter errors, and they are usually able to cooperate as well. By properly applying those filters and transforming errors, we can reduce noise for analyzing what's going on within a system and locate problems faster if they show up.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec44"/>Modularizing project</h1></div></div></div><p>Before ES6, there were a lot of module solutions for JavaScript that worked. The two most famous of them are AMD and commonjs. AMD is designed for asynchronous module loading, which is mostly applied in browsers, while commonjs does module loading synchronously, and that's the way the Node.js module system works.</p><p>To make it work asynchronously, writing an AMD module takes more characters. And due to the popularity of tools such as browserify and webpack, commonjs becomes popular even for browser projects.</p><p>The proper granularity of internal modules could help a project keep its structure healthy. Consider a project structure like this:</p><pre class="programlisting">project &#13;
├─controllers &#13;
├─core &#13;
│  │ index.ts &#13;
│  │ &#13;
│  ├─product &#13;
│  │   index.ts &#13;
│  │   order.ts &#13;
│  │   shipping.ts &#13;
│  │ &#13;
│  └─user &#13;
│      index.ts &#13;
│      account.ts &#13;
│      statistics.ts &#13;
│ &#13;
├─helpers &#13;
├─models &#13;
├─utils &#13;
└─views &#13;
</pre><p>Assume we are writing a controller file that's going to import a module defined by the <code class="literal">core/product/order.ts</code> file. Previously, with the commonjs <code class="literal">require</code> style, we would want to write the following:</p><pre class="programlisting">const Order = require('../core/product/order'); &#13;
</pre><p>Now, with the new ES <code class="literal">import</code> syntax, it would be as follows:</p><pre class="programlisting">import * as Order from '../core/product/order'; &#13;
</pre><p>Wait, isn't that essentially the same? Sort of. But you may have noticed several <code class="literal">index.ts</code> files I've put into folders. Now, in the file <code class="literal">core/product/index.ts</code>, we can have the following:</p><pre class="programlisting">import * as Order from './order'; &#13;
import * as Shipping from './shipping'; &#13;
 &#13;
export { Order, Shipping } &#13;
</pre><p>Alternatively, we could have the following:</p><pre class="programlisting">export * from './order'; &#13;
export * from './shipping'; &#13;
</pre><p>What's the difference? The ideas behind those two approaches of <strong>re-exporting</strong> modules can vary. The first style works better when we treat <code class="literal">Order</code> and <code class="literal">Shipping</code> as namespaces, under which the entity names may not be easy to distinguish from one group to another. With this style, the files are the natural boundaries of building those namespaces. The second style weakens the namespace property of two files and uses them as tools to organize objects and classes under the same larger category.</p><p>A good thing about using those files as namespaces is that multiple-level re-exporting is fine while weakening namespaces makes it harder to understand different identifier names as the number of re-exporting levels grows.</p></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec45"/>Asynchronous patterns</h1></div></div></div><p>When we are writing JavaScript with network or file system I/O, there is a 95% chance that we are doing it asynchronously. However, an asynchronous code may tremendously decrease the determinability at the dimension of time. But we are so lucky that JavaScript is usually single-threaded; this makes it possible for us to write predictable code without mechanisms such as locks most of the time.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec117"/>Writing predictable code</h2></div></div></div><p>The predictable code relies on predictable tools (if you are using any). Consider a helper like this:</p><pre class="programlisting">type Callback = () =&gt; void; &#13;
 &#13;
let isReady = false; &#13;
let callbacks: Callback[] = []; &#13;
 &#13;
setTimeout(() =&gt; { &#13;
  callbacks.forEach(callback =&gt; callback()); &#13;
  callbacks = undefined; &#13;
  }, 100); &#13;
export function ready(callback: Callback): void { &#13;
  if (!callbacks) { &#13;
    callback(); &#13;
  } else { &#13;
    callbacks.push(callback); &#13;
  } &#13;
} &#13;
</pre><p>This module exports a <code class="literal">ready</code> function, which will invoke the callbacks passed in when "ready". It will assure that callbacks will be called even if added after that. However, you cannot say for sure whether the callback will be called in the current event loop:</p><pre class="programlisting">import { ready } from './foo'; &#13;
 &#13;
let i = 0; &#13;
 &#13;
ready(() =&gt; { &#13;
  console.log(i); &#13;
}); &#13;
 &#13;
i++; &#13;
</pre><p>In the preceding example, <code class="literal">i</code> could either be 0 or <code class="literal">1</code> when the callback gets called. Again, this is not wrong, or even bad, it just makes the code less predictable. When someone else reads this piece of code, he or she will need to consider two possibilities of how this program would run. To avoid this issue, we can simply wrap up the synchronous invocation with <code class="literal">setImmediate</code> (it may fallback to <code class="literal">setTimeout</code> in older browsers):</p><pre class="programlisting">export function ready(callback: Callback): void { &#13;
  if (!callbacks) { &#13;
   <strong> setImmediate(() =&gt; callback());</strong> &#13;
  } else { &#13;
    callbacks.push(callback); &#13;
  } &#13;
}&#13;
</pre><p>Writing predictable code is actually more than writing predictable asynchronous code. The highlighted line above can also be written as <code class="literal">setImmediate(callback)</code>, but that would make people who read your code think twice: how will <code class="literal">callback</code> get called and what are the <code class="literal">arguments</code>?</p><p>Consider the line of code below:</p><pre class="programlisting">let results = ['1', '2', '3'].map(parseInt); &#13;
</pre><p>What's the value of the array <code class="literal">results</code>? Certainly not <code class="literal">[1, 2, 3]</code>. Because the callback passed to the method <code class="literal">map</code> receives several arguments: value of current item, index of current item, and the whole array, while the function <code class="literal">parseInt</code> accepts two arguments: string to parse, and radix. So <code class="literal">results</code> are actually the results of the following snippet:</p><pre class="programlisting">[parseInt('1', 0), parseInt('2', 1), parseInt('3', 2)]; &#13;
</pre><p>However, it is actually okay to write <code class="literal">setImmediate(callback)</code> directly, as the APIs of those functions (including <code class="literal">setTimeout</code>, <code class="literal">setInterval</code>, <code class="literal">process.nextTick</code>, and so on) are designed to be used in this way. And it is fair to assume people who are going to maintain this project know that as well. But for other asynchronous functions whose signatures are not well known, it is recommended to call them with explicit arguments.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec118"/>Asynchronous creational patterns</h2></div></div></div><p>We talked about many creational patterns in <a class="link" href="ch03.html" title="Chapter 3. Creational Design Patterns">Chapter 3</a>, <em>Creational Design Patterns</em>. While a constructor cannot be asynchronous, some of those patterns may have problems applying to asynchronous scenarios. But others need only slight modifications for asynchronous use.</p><p>In <a class="link" href="ch04.html" title="Chapter 4. Structural Design Patterns">Chapter 4</a>, <em>Structural Design Patterns</em> we walked through the Adapter Pattern with a storage example that opens the database and creates a storage object asynchronously:</p><pre class="programlisting">class Storage { &#13;
  private constructor() { } &#13;
 &#13;
  open(): Promise&lt;Storage&gt; { &#13;
    return openDatabase()             &#13;
      .then(db =&gt; new Storage(db)) &#13;
  } &#13;
} &#13;
</pre><p>And in the Proxy Pattern, we made the storage object immediately available from its constructor. When a method of the object is called, it waits for the initialization to complete and finishes the operation:</p><pre class="programlisting">class Storage { &#13;
  private dbPromise: Promise&lt;IDBDatabase&gt;; &#13;
 &#13;
  get dbReady(): Promise&lt;IDBDatabase&gt; {         &#13;
    if (this.dbPromise) { &#13;
      return this.dbPromise; &#13;
    } &#13;
     &#13;
    // ...     } &#13;
 &#13;
  get&lt;T&gt;(): Promise&lt;T&gt; { &#13;
    return this             &#13;
      .dbReady &#13;
      .then(db =&gt; { &#13;
        // ... &#13;
      }); &#13;
  } &#13;
} &#13;
</pre><p>A drawback of this approach is that all members that rely on initialization have to be asynchronous, though most of the time they just are asynchronous.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec119"/>Asynchronous middleware and hooks</h2></div></div></div><p>The concept of middleware is widely used in frameworks such as Express. Middleware usually processes its target in serial. In Express, middleware is applied roughly in the order it is added while there are not different phases. Some other frameworks, however, provide hooks for different phases in time. For example, there are hooks that will be triggered <em>before install</em>, <em>after install</em>, <em>after uninstall</em>, and so on.</p><div><div><h3 class="title"><a id="note53"/>Note</h3><p>The middleware mechanism of Express is actually a variant of the Chain of Responsibility Pattern. And depending on the specific middleware to be used, it can act more or less like hooks instead of a responsibility chain.</p></div></div><p>The reasons to implement middleware or hooks vary. They may include the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Extensibility</strong>: Most of the time, they are applied due to the requirement of extensibility. New rules and processes could be easily added by new middleware or hooks.</li><li class="listitem" style="list-style-type: disc"><strong>Decoupling interactions with business logic</strong>: A module that should only care about business logic could need potential interactions with an interface. For example, we might expect to be able to either enter or update credentials while processing an operation, without restarting everything. Thus we can create a middleware or a hook, so that we don't need to have them tightly coupled.</li></ul></div><p>The implementation of asynchronous middleware could be interesting. Take the Promise version as an example:</p><pre class="programlisting">type Middleware = (host: Host) =&gt; Promise&lt;void&gt;; &#13;
 &#13;
class Host { &#13;
  middlewares: Middleware[] = []; &#13;
 &#13;
  start(): Promise&lt;void&gt; { &#13;
    return this &#13;
      .middlewares &#13;
      .reduce((promise, middleware) =&gt; { &#13;
        return promise.then(() =&gt; middleware(this)); &#13;
      }, Promise.resolve()); &#13;
  } &#13;
} &#13;
</pre><p>Here, we're using <code class="literal">reduce</code> to do the trick. We passed in a Promise fulfilled with undefined as the initial value, and chained it with the result of <code class="literal">middleware(this)</code>. And this is actually how the <code class="literal">Promise.each</code> helper is implemented in many Promise libraries.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec120"/>Event-based stream parser</h2></div></div></div><p>When creating an application relies on socket, we usually need a lightweight "protocol" for the client and server to communicate. Unlike XHR that already handles everything, by using socket, you will need to define the boundaries so data won't be mixed up.</p><p>Data transferred through a socket might be concatenated or split, but TCP connection ensures the order and correctness of bytes gets transferred. Consider a tiny protocol that consists of only two parts: a 4-byte unsigned integer followed by a JSON string with byte length that matches the 4-byte unsigned integer.</p><p>For example, for JSON <code class="literal">"{}"</code>, the data packet would be as follows:</p><pre class="programlisting">Buffer &lt;00 00 00 02 7b 7d&gt; &#13;
</pre><p>To build such a data packet, we just need to convert the JSON string to <code class="literal">Buffer</code> (with encoding such as <code class="literal">utf-8</code>, which is default encoding for Node.js), and then prepend its length:</p><pre class="programlisting">function buildPacket(data: any): Buffer { &#13;
  let json = JSON.stringify(data); &#13;
  let jsonBuffer = new Buffer(json); &#13;
 &#13;
  let packet = new Buffer(4 + jsonBuffer.length); &#13;
 &#13;
  packet.writeUInt32BE(jsonBuffer.length, 0); &#13;
  jsonBuffer.copy(packet, 4, 0); &#13;
 &#13;
  return packet; &#13;
} &#13;
</pre><p>A socket client emits a <code class="literal">data</code> event when it receives new buffers. Assume we are going to send the following JSON strings:</p><pre class="programlisting">// 00 00 00 02 7b 7d &#13;
{} &#13;
 &#13;
// 00 00 00 0f 7b 22 6b 65 79 22 3a 22 76 61 6c 75 65 22 7d &#13;
{"key":"value"} &#13;
</pre><p>We may be receiving them like this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get two buffers separately; each of them is a complete packet with length and JSON bytes</li></ul></div><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Get one single buffer with two buffers concatenated</li><li class="listitem" style="list-style-type: disc">Get two, or more than two, buffers; at least one of the previously sent packets gets split into several ones.</li></ul></div><p>The entire process is happening asynchronously. But just like the socket client emits a <code class="literal">data</code> event, the parser can just emit its own <code class="literal">data</code> event when a complete packet gets parsed. The parser for parsing our tiny protocol may have only two states, corresponding to header (JSON byte length) and body (JSON bytes), and the emitting of the <code class="literal">data</code> event happens after successfully parsing the body:</p><pre class="programlisting">class Parser extends EventEmitter { &#13;
  private buffer = new Buffer(0); &#13;
  private state = State.header; &#13;
 &#13;
  append(buffer: Buffer): void { &#13;
    this.buffer = Buffer.concat([this.buffer, buffer]); &#13;
    this.parse(); &#13;
  } &#13;
 &#13;
  private parse(): void { } &#13;
 &#13;
  private parseHeader(): boolean { } &#13;
 &#13;
  private parseBody(): boolean { } &#13;
} &#13;
</pre><p>Due to the limitation of length, I'm not going to put the complete implementation of the parser here. For the complete code, please refer to the file <code class="literal">src/event-based-parser.ts</code> in the code bundle of <a class="link" href="ch07.html" title="Chapter 7. Patterns and Architectures in JavaScript and TypeScript">Chapter 7</a>, <em>Patterns and Architectures in JavaScript and TypeScript</em>.</p><p>Thus the use of such a parser could be as follows:</p><pre class="programlisting">import * as Net from 'net'; &#13;
 &#13;
let parser = new Parser(); &#13;
let client = Net.connect(port); &#13;
 &#13;
client.on('data', (data: Buffer) =&gt; { &#13;
  parser.append(data); &#13;
}); &#13;
 &#13;
parser.on('data', (data: any) =&gt; { &#13;
  console.log('Data received:', data); &#13;
});  &#13;
</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec46"/>Summary</h1></div></div></div><p>In this chapter, we discussed some interesting ideas and an architecture formed by those ideas. Most of the topics focus on a small scope and do their own job, but there are also ideas about putting a whole system together.</p><p>The code that implements techniques such as expected error and the approach to managing modules in a project is not hard to apply. But with proper application, it can bring notable convenience to the entire project.</p><p>However, as I have already mentioned at the beginning of this chapter, there are too many beautiful things in JavaScript and TypeScript to be covered or even mentioned in a single chapter. Please don't stop here, and keep exploring.</p><p>Many patterns and architectures are the result of some fundamental principles in software engineering. Those principles might not always be applicable in every scenario, but they may help when you feel confused. In the next chapter, we are going to talk about SOLID principles in object-oriented design and find out how those principles may help form a useful pattern.</p></div></body></html>