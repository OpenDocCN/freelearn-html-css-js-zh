- en: Chapter 5. Managing Colors, Images, and Fonts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A website isn't a great website without some form of color, imagery, or fonts—a
    mix of these will add interest, express content more clearly where words might
    be insufficient, and generally help maintain visitor engagement.
  prefs: []
  type: TYPE_NORMAL
- en: 'Users of existing preprocessors will of course be familiar with libraries such
    as the Compass authoring framework for SASS from [http://www.compass-style.org](http://www.compass-style.org);
    what if we could produce similar effects, but much faster, and without the need
    for dependencies? No problem, with PostCSS, we can pick and choose which plugins
    are needed for our site, and begin to build up a processor that suits our needs.
    We will cover a number of topics throughout this chapter, which will include:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of plugins available to handle colors, images, and fonts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating image sprites using existing preprocessors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding SVG support using existing preprocessors
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transitioning to using PostCSS plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Manipulating colors and color palettes using PostCSS plugins
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's make a start…!
  prefs: []
  type: TYPE_NORMAL
- en: Adding color, fonts, and media to sites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*A picture paints a thousand words…*'
  prefs: []
  type: TYPE_NORMAL
- en: Originally created in the 1920s, this phrase is so apt in the world of digital
    content—writing a hundred words doesn't have the same appeal if we can replace
    it with a single image and still convey the same meaning!
  prefs: []
  type: TYPE_NORMAL
- en: A part of any developer or designer's work will be to source the right images
    or fonts, or choose the right colors, and include them on the site they are building
    so they can be referenced at the appropriate point. We'll explore some of the
    plugins and tricks we can use to modify colors, but for now, let's take a look
    at some of the plugins available for manipulating images and fonts within a site.
  prefs: []
  type: TYPE_NORMAL
- en: Maintaining asset links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When sourcing media for a site, the usual process will be to create a folder
    for fonts, another for images, and so on, if any part of the process is likely
    to fail, then it is likely to be with applying incorrect links in our code. The
    risk of this happening will of course increase if we have a particularly complex
    folder structure!
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead, we can take an alternative approach: why not get PostCSS (or a plugin)
    to do the work for us?'
  prefs: []
  type: TYPE_NORMAL
- en: We can use the `postcss-assets` plugin for this purpose; if we specify a name,
    it will look in the files relative to the source file, then file paths specified
    in the loadPaths configuration option, and finally search in the URL specified
    in the basePath config path. The beauty of this is that we can simply reference
    the image name, and provided PostCSS finds an image with the same name in one
    of these preassigned locations, then it will substitute in the appropriate path
    for us at compilation.
  prefs: []
  type: TYPE_NORMAL
- en: If a link needs to change, then no problem, we can either add a new one in,
    or modify the existing one; CSS styles will be updated at the next compilation.
    Let's put this into practice, using the `postcss-assets` plugin, in a simple demo.
  prefs: []
  type: TYPE_NORMAL
- en: Automating links to assets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember the moody landscape image from [Chapter 4](ch04.html "Chapter 4. Building
    Media Queries"), *Building Media Queries*?
  prefs: []
  type: TYPE_NORMAL
- en: In our first example, we're going to rework this demo, but this time use the
    `postcss-assets` plugin (available from [https://github.com/borodean/postcss-assets](https://github.com/borodean/postcss-assets))
    to automate the insertion of links for all of our assets. We'll focus on images
    and fonts, but this can equally apply to media such as videos as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a screenshot to remind ourselves of that image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Automating links to assets](img/BO5194_05_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and download a copy of the `Tuturial19` folder from the code download
    that accompanies this book, save this at the root of our project area. This contains
    a partially reworked version of the demo from [Chapter 4](ch04.html "Chapter 4. Building
    Media Queries"), *Building Media Queries*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go ahead and remove any copies of `gulpfile.js` and `package.json` from
    the root of our project area—we'll start this chapter with fresh copies from our
    code download.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We now need to install the `postcss-assets` plugin, so fire up a Node.js command
    prompt session, enter this command, and then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Don't close it, we will use it again shortly!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We need to extract copies of the `gulpfile.js` and `package.json` files from
    the code download—go ahead and save them to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The sharp-eyed amongst you will note we are not installing any other plugins—we're
    using ones that we have already installed in earlier exercises; the `package.json`
    file will include references to these and the `postcss-assets` file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the `Tutorial19` folder, look for and copy the `styles – pre-compile.css`
    file to the `src` folder in our project area; rename it to `styles.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revert back to the Node.js command prompt window, then enter gulp at the prompt
    and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should have a `maps` folder and two CSS stylesheets (one
    full version, one minified)—if we copy these back to the `css` folder in the `Tutorial19`
    folder, then run the demo, we should see a familiar image of a landscape with
    early mist, as shown at the start of this demo.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Okay, the image is displayed, along with the text in Roboto font, but how does
    it all work? It's worth taking a few moments to explore the code; setting it up
    correctly will help save you a lot of time!
  prefs: []
  type: TYPE_NORMAL
- en: Most of what is in the gulp file you will recognize from earlier demos—we've
    included the same linting, renaming, and source map creations as before. In addition
    to the new assets task (to handle our asset links), we've removed the `autoprefixer`
    task; we're not calling anything that requires vendor prefixes, so there is no
    need to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The key process in the gulp file centers on this code—this creates, and substitutes
    in, the correct asset links. We start with the options configuration object—the
    `loadPaths` take care of the asset locations, and `relativeTo` tells the plugin
    to set relative links in relation to the `dest/` folder. In this case, `loadPaths`
    defines specific folders to use; we use `relativeTo` to make these paths relative:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `dest/` folder is used in our creation process—in reality, this would be
    the location of our CSS style sheets on the production server. This next simple
    task simply calls the `postcss-assets` plugin, and processes each style sheet
    found in the `src` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We then simply call the task, if we were to call gulp from a command prompt,
    then it will run all of these tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: All in all, a very simple but highly effective tool, it removes the need to
    insert any links manually, provided we've included them within the configuration
    object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alright…let''s move on: we''ve covered a simple method to ensure we always
    have the right links for font or image files. There is still an element of manual
    work required though—do we really need to include all of the lines added for our
    custom font?'
  prefs: []
  type: TYPE_NORMAL
- en: Well, we could always just use a font hosted on Google, but that destroys the
    point of using PostCSS! Instead, we can simply use the custom font name in our
    style sheet, but get PostCSS to add in the custom font-face declaration automatically
    at compilation. Intrigued? Let's take a look at how, as part of our next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: Managing fonts with PostCSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In our previous demo, we explored a means to automatically add links using
    PostCSS—it shortcuts the need to worry about providing the right locations for
    files. The trouble is, when used with custom fonts, it still requires too much
    work (yes, I know, we humans are inherently lazy!). There is a better alternative:'
  prefs: []
  type: TYPE_NORMAL
- en: Enter the `postcss-fontpath` plugin, available from [https://github.com/seaneking/postcss-fontpath](https://github.com/seaneking/postcss-fontpath);
    this is a simple plugin that requires limited information about our custom font,
    and in return will produce the full font-face declaration at the compilation stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, rather than talk about it, why don''t we put it to use? Let''s revisit
    the responsive image demo we covered in the previous demo, and alter our style
    sheet to use the fontpath plugin to handle our custom font:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by extracting a copy of the `Tutorial20` folder from the code download
    that accompanies this book, and save the folder to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, take a copy of `package.json` and `gulpfile.js` files from the `Tutorial20`
    folder, and replace the existing versions that are at the root of our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and fire up a Node.js command prompt, and change the working folder
    to that of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the command prompt, enter this command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Although we've installed the plugin explicitly, we can easily install it using
    just `npm install`; the presence of the `package.json` file in the folder will
    tell NPM what to install (in this case the missing `postcss-fontpath` plugin).
    Keep the session open, we will use it again shortly.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Take a copy of `styles – pre-compile.css` from the `css – completed version`
    folder, and save this as `styles.css` into the `src` folder at the root of our
    project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revert back to the Node.js command prompt window, then enter `gulp` at the prompt,
    and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should see the, by now, familiar style sheets and source
    map appear in the `dest` folder; copy these to the `css` folder within the `Tutorial20`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point, we should now have a working demo; we won't see anything intrinsically
    different, but know that at compilation, PostCSS has automatically added the right
    font-face declarations for our font.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty about this plugin is in its simplicity—it needs no more than the
    addition of a simple command in the main task:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'There is no need to have to specify any additional configuration elements or
    rules, the plugin does exactly what it says on the tin, so to speak! Although
    we''ve not achieved anything ground-breaking with this example, it does serve
    to illustrate some key points about using PostCSS:'
  prefs: []
  type: TYPE_NORMAL
- en: PostCSS works best when plugins concentrate on a single task and don't try to
    achieve everything under the sun in one go. Adhering to the single responsibility
    principle means we can reduce duplication, make the plugin more robust, and avoid
    instances where changes can end up breaking functionality elsewhere in our processor!
    This plugin is perfect—it just provides a font-face declaration for the specified
    font, and nothing else.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sometimes, when choosing the right plugin in PostCSS, there will be occasions
    when we choose something that later turns out not to work as expected. A case
    in point is the `postcss-font-magician` plugin (available from [https://github.com/jonathantneal/postcss-font-magician](https://github.com/jonathantneal/postcss-font-magician));
    it has the right idea of providing font-face declarations, but tries to provide
    them for Google-hosted fonts, locally hosted fonts, Bootstrap, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: Unfortunately, the net result is that at the time of writing, not all of the
    functionality appears to work as expected, so it is at this point where we have
    to look for alternatives.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you would like to explore more, then the `postcss.parts` directory (at [http://www.postcss.parts](http://www.postcss.parts))
    has more options available; two that might be of interest are the `Assets Rebase`
    plugin (from [https://github.com/devex-web-frontend/postcss-assets-rebase](https://github.com/devex-web-frontend/postcss-assets-rebase)),
    and the PostCSS `Font Pack` plugin, from [https://github.com/jedmao/postcss-font-pack](https://github.com/jedmao/postcss-font-pack).
    We will cover the latter plugin in more detail in [Chapter 8](ch08.html "Chapter 8. Creating
    PostCSS Plugins"), *Creating PostCSS Plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, so we have our text in place: it does look a little boring, doesn''t
    it? Well, we can fix that by adding images. So, how exactly can PostCSS help us,
    I hear you ask?'
  prefs: []
  type: TYPE_NORMAL
- en: It can help in a number of ways—instead of using plain colors, we can begin
    to mix some together, for example. Or how about using image sprites? A pain to
    create manually, right? Not with PostCSS. I'll bet you've seen some of the image
    filters you can use on images (such as sepia or tint), but found that they don't
    work in every browser right?
  prefs: []
  type: TYPE_NORMAL
- en: 'These are just some of the ways that PostCSS can help us, and we will cover
    all of these and more throughout this chapter. Let''s make a start though on working
    with images: our first demo will cover the creation of image sprites. We''ll start
    with a quick recap of the SASS process, before switching to using PostCSS.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating image sprites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with something easy: I''m sure that at some point you will either
    have used or created image sprites, right? If you''re a SASS developer, no doubt
    you will have availed yourself of the sprite mixins from Compass, and used an
    app such as **Koala** to compile, or compiled directly from the command line.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A copy of the relevant files for creating sprites using Compass can be found
    in the code download that accompanies this book, in the `Tutorial21A` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The process is relatively straightforward, but you still have to set up a `Compass`
    project, install a GUI application (if you're using one), and so on, which is
    a real pain! We could use an online application such as **SpritePad** ([http://spritepad.wearekiss.com/](http://spritepad.wearekiss.com/))
    instead, but again that's a manual process, and it's prone to error. Instead,
    we can easily use PostCSS to help us here —over and above the normal variables
    that we declare at the top of any gulp file, there is very little required in
    order to produce basic image sprites. Let's take a look at creating one now, using
    the `p` `ostcss-sprites` plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Demo – creating a credit card icon bar
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How many times have you bought something from an e-commerce site? If you've
    bought as much as I have online, then no doubt you will have seen shopping carts
    with assorted payment card icons. These may be small, but they are nevertheless
    key to our site—after all, how can we tell if using a particular credit card might
    fail, if the online retailer doesn't accept Mastercard, for example? Seems obvious,
    but it's not always easy to tell.
  prefs: []
  type: TYPE_NORMAL
- en: 'Leaving that aside, it is a cinch to create an image sprite with PostCSS; gone
    is the dependency on SASS: in its place we can use the `postcss-sprites` plugin
    (available from [https://github.com/2createStudio/postcss-sprites](https://github.com/2createStudio/postcss-sprites))
    to produce our composite image. Let''s dive in and take a look.'
  prefs: []
  type: TYPE_NORMAL
- en: For this demo, we will use the credit card icons available at [http://findicons.com/pack/2102/credit_card_debit_card](http://findicons.com/pack/2102/credit_card_debit_card);
    please feel free to substitute if you would like to use different icons.
  prefs: []
  type: TYPE_NORMAL
- en: 'All of the code for this tutorial can be found in the `Tutorial21B` folder,
    in the code download—we will start afresh by installing the `postcss-sprites`
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and fire up a Node.js command prompt, and change the working folder
    to that of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the command prompt, enter the command shown in this screenshot, then press
    *Enter*, once Node has confirmed successful installation, and minimize the window,
    as we will return to it later in this exercise:![Demo – creating a credit card
    icon bar](img/BO5194_05_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Go ahead and fire up your text editor, then add the following lines—these represent
    four credit card icons we would typically add to any online e-commerce site:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file as `style.css`, and store it in the `src` folder of our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the same folder, create a folder called `img` at the root of our project
    area; extract copies of the icons stored in the code download that accompanies
    this book, and save them to the `img` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the code download that accompanies this book, go ahead and extract a copy
    of `gulpfile.js`, and save this to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revert back to the Node.js window, then at the prompt, enter `gulp` and press
    *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our code will now be compiled, if all is well, we should see something akin
    to this when viewing the `style.css` file within the `dest` folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this stage, we can then copy the code to our website, along with image—instead
    of using four separate icons (which each require separate calls to the server),
    we can cache the single icon. This will result in faster response times with fewer
    calls to our server. The compiled style sheet can be found in the `dest` folder,
    with the composite image one level up, in the `img` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Demo – creating a credit card icon bar](img/BO5194_05_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Even though this is a simple process, it''s worth noting a key point with how
    our gulp file has been configured—the use of a configuration object for the `sprites`
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s not a process we''ve used to date, but it does not mean that it is any
    less useful—it simply boils down to a matter of personal preference and readability.
    It does make it easier to read the calls for each plugin we assign; in this instance,
    we''re only using one, but you can imagine what it will be like with multiple
    plugins in use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Okay, let''s change tack and take a look at a different side to using images
    with PostCSS: using SVG format images. Standard images don''t always scale well,
    particularly when used in a responsive environment; sometimes we might use retina
    images instead, but an alternative to consider is the use of SVG images.'
  prefs: []
  type: TYPE_NORMAL
- en: Working with SVG in PostCSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The rapidly increasing use of mobile devices makes creating responsive content
    a must; the traditional route is using something akin to `max-width: 100%` to
    control the size of an element on screen.'
  prefs: []
  type: TYPE_NORMAL
- en: A better alternative is to use SVG—this maintains quality, even when resized;
    standard image formats will become pixelated if resized to an excessive size.
    For those of you who have previously used SASS, then there isn't any in-built
    support for SVG as such; the most we can hope to achieve is efficient nesting
    within our style sheet.
  prefs: []
  type: TYPE_NORMAL
- en: An example of what we might use can be found in the `sass` folder within the
    `Tutorial22` folder in the code download that accompanies this book.
  prefs: []
  type: TYPE_NORMAL
- en: If we're a regular user of SVG images within SASS, then it is likely we would
    use a library such as `sass-svg`, from [https://github.com/davidkpiano/sass-svg](https://github.com/davidkpiano/sass-svg).
    Moving away from SASS to PostCSS is easy; the PostCSS ecosystem has a number of
    plugins we can use to manipulate images. Let's take a look at how, using the `postcss-svg`
    plugin.
  prefs: []
  type: TYPE_NORMAL
- en: Altering icon images using PostCSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ll use the `postcss-svg` plugin (from [https://github.com/Pavliko/postcss-svg](https://github.com/Pavliko/postcss-svg)),
    to manipulate some icons from the `Evil Icon` package (available from [https://github.com/outpunk/gulp-evil-icons](https://github.com/outpunk/gulp-evil-icons)),
    as part of the next demo:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin by extracting a copy of the `Tutorial22` folder from the code download
    that accompanies this book. Save it to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From within the `Tutorial22` folder, extract copies of the `gulpfile.js` and
    `package.json` files, and use them to replace any that are currently stored at
    the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and extract a copy of `style – pre-compile.css` from the same folder;
    save this as `style.css` within the `src` folder. Do the same for the `index.html`
    file as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In a break to previous demos, we need an additional `css` folder—go ahead and
    create one within the `dest` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, fire up a Node.js command prompt, and change the working folder to that
    of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We need to install the `postcss-svg` plugin, so at the command prompt, enter
    this command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once completed, enter `gulp` at the command prompt, then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should see the usual two style sheets appear in the `/dest/css`
    folder, along with a source `map` folder. The HTML markup file will appear in
    the `dest` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you don't see the source map or minified versions appear, then rerun `gulp`—sometimes
    these files will only appear if a compiled `style.css` file is present.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the contents of the `dest` folder to the `css` folder within the `Tutorial22`
    folder—if all is well, we should see these icons appear when previewing the results
    in a browser:![Altering icon images using PostCSS](img/BO5194_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although this is a simple demo, we've covered some useful tips and tricks within;
    it's worth taking some time to explore how the demo was put together in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the results in more detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are several key elements to this exercise that are worthy of attention,
    the use of a CDN link and Node to provide the style sheet and icons for Evil Icons,
    the compiled HTML file and the references to use within our custom style sheet.
    We will cover all of these, but first let's explore the gulp file in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: 'We begin with these two lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should not be surprised to see the latter, but the former is present as
    the `Evil Icons` library can be installed using the `gulp-evil-icons` package.
    There are a number of different options available for installing, but as we're
    already using Gulp, it makes sense to continue using the task runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we spread our work over two tasks—the first compiles the HTML code to
    assign the relevant icon image to our `<icon>` statements within our markup:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the colors requires the use of the `postcss-svg` plugin, here referenced
    by `postcssSVG`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We of course had to update our default task, if we simply call `gulp` at the
    command line, then it will know to run all of these tasks in turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The last step also applies a similar update to our watch facility:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If we then take a look within the HTML markup, we can see a link to the `Evil
    Icons` library that was installed using Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'We then put our customizations into a separate style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'These look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the results in more detail](img/BO5194_05_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this stage, the CSS styles may look simple, but the HTML markup is anything
    but; the `postcss-svg` plugin has added an in-line version of our icons to the
    HTML markup, with the appropriate edits made from our custom style sheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring the results in more detail](img/BO5194_05_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Sometimes, it is easy to wonder if using SVG is worth the extra markup, the
    main benefit being that if it is added in-line, then we reduce the number of calls
    to external resources; any content that requires altering can be done, without
    sacrificing the quality of our images.
  prefs: []
  type: TYPE_NORMAL
- en: Considering alternative options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We concentrated on using the `postcss-svg` plugin throughout our exercise,
    as a start to manipulating SVG images within the PostCSS system; there are some
    more options available, which may be of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`postcss-write-svg`: This plugin (available at [https://github.com/jonathantneal/postcss-write-svg](https://github.com/jonathantneal/postcss-write-svg))
    allows us to write inline SVGs in CSS.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcss-inline-svg`: Another plugin (from [https://github.com/TrySound/postcss-inline-svg](https://github.com/TrySound/postcss-inline-svg)),
    which in-lines SVG images and allows us to customize their styles.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcss-svgo`: This plugin (available at [https://github.com/ben-eb/postcss-svgo](https://github.com/ben-eb/postcss-svgo))
    processes inline SVG using the SVG Optimizer Tool for Node.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have a need to provide a fall-back position for SVG files, then you can
    try the `postcss-svg-fallback` plugin, available from [https://github.com/justim/postcss-svg-fallback](https://github.com/justim/postcss-svg-fallback)—
    we will use this plugin later, in [Chapter 8](ch08.html "Chapter 8. Creating PostCSS
    Plugins"), *Creating PostCSS Plugins*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, let''s change tack: using SVG images can be a little heavy handed if
    all we need is a straightforward format for displaying images, right? Well, we
    could use standard formats, or one which has superior quality while maintaining
    smaller sizes. I''m talking about the lesser-known WebP format from Google—let''s
    dig in and find out more about this format, and why it deserves more attention.'
  prefs: []
  type: TYPE_NORMAL
- en: Adding support for WebP images
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manipulating SVG images is an acquired art, and in some instances, it will clearly
    be overkill for what we need to achieve.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, for those occasions where we need the detail in our images, we might
    normally use the JPEG format, or potentially PNG as an alternative. There's nothing
    wrong with either, but, it's old hat, and I do like to push the boundaries of
    what is possible! In addition, the JPEG image format is lossy and does not support
    alpha channels; PNG images are lossless, but suffer from larger file sizes for
    more complex images. If all we did was simply insert images onto a page, then
    PostCSS wouldn't be helpful here; instead, how about considering a different format
    altogether?
  prefs: []
  type: TYPE_NORMAL
- en: Enter Google's **WebP**. You'd be forgiven for thinking "Web…what?", as it isn't
    a common format! Part of this can be attributed to the lack of take-up; the only
    browsers to support it natively are Chrome, Android, and Opera. That doesn't mean
    to say it should be discounted. The format can offer some significant space savings
    over standard image formats such as JPEG or PNG, while maintaining superior quality.
    We can even get PostCSS to do most of the work for us, to boot! Let's explore
    the nuts and bolts of this in more detail, with a simple demo.
  prefs: []
  type: TYPE_NORMAL
- en: Switching WebP images in and out
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Image switching is nothing new, we covered one aspect back in [Chapter 4](ch04.html
    "Chapter 4. Building Media Queries"), *Building Media Queries*, when we used PostCSS
    to switch-in hi-res images when supported in the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can use a similar technique, but this time with image formats, Google''s
    WebP format was designed as a replacement for the myriad of other image formats
    available for the web. In an ideal world, we would use the new `<picture>` tag
    to take care of switching images automatically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: It's not supported in all browsers, so instead, we can use a mix of PostCSS
    and Modernizr to apply the same effect. The plugin we need for this task is the
    `webpcss` plugin (available from [https://github.com/lexich/webpcss](https://github.com/lexich/webpcss))—we
    will need to run `npm install gulp-webp --save-dev` in a Node.js command prompt
    session to install the plugin. Let's dive in and take a look at it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For best results, I would recommend using Chrome throughout these two demos,
    support can be added for Windows and other browsers, by visiting [https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/).
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the differences in file sizes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we get stuck into using PostCSS, let''s take a moment to perform a quick
    test. The files for this tutorial are in the `Tutorial 23` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: In the code download that accompanies this book, go ahead and extract a copy
    of `landscape – original version.jpg`, and rename it as `landscape.jpg`. The size
    should be around 11.5 MB in size.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the image to the root of our project area—we also need a copy of `cwebp.exe`,
    so go ahead and extract that to our project area as well.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire up a command prompt session, change the working folder to our project area,
    enter `gulp`, and then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should see the results of our conversion, and the new WebP-format
    image appear in our project area:![Viewing the differences in file sizes](img/BO5194_05_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try performing the same process with a PNG format image; here are the results
    of a similar test I performed, with a PNG version of our landscape image:![Viewing
    the differences in file sizes](img/BO5194_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In both cases, the image sizes reduced significantly, the JPEG version dropped
    from around 12.5 MB to just over 7 MB; the PNG format shrunk from an enormous
    25 MB to around the same size!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To learn more about using the WebP format, take a look at the documentation
    on the Google Developers site at [https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, time for another demo! Let''s now make use of PostCSS to create our styles
    for both standard JPEG format, and WebP equivalents:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the differences in file sizes](img/BO5194_05_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'For this demo, we''ll use the `gulp-webpcss` plugin, available from [https://github.com/lexich/webpcss](https://github.com/lexich/webpcss):'
  prefs: []
  type: TYPE_NORMAL
- en: Go ahead and download a copy of the `Tuturial23` folder from the code download
    that accompanies this book, save this at the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go ahead and remove any copies of `gulpfile.js` and `package.json` from
    the root of our project area; we need to replace them with copies from the `Tutorial23`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With these files in place, we still need to install the plugins, in a Node.js
    command prompt window, change the working folder to our project, then run these
    commands, pressing *Enter* after each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note the order of the parameters in these commands, if they are written in a
    different order, they will not install.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Copy the `style – pre-compile.css` file from the `Tutorial23` folder to the
    `src` folder at the root of our project area, then rename it as `style.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fire up a Node.js command prompt, change the working folder to our project area,
    then enter `gulp` at the prompt and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should see the code shown in this screenshot when viewing
    the contents of the compiled file; the converted image will also appear in the
    `img` folder:![Viewing the differences in file sizes](img/BO5194_05_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `img` folder into the `img` folder within the `Tutorial23`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `style.css` file from the `dest` folder into the `css` folder within
    the `Tutorial23` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go ahead and run `index.html` in a browser, if all is well, we should see something
    akin to the screenshot at the start of this exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If we run the same `index.html` in Google Chrome or Firefox, at first we should
    not see any difference—we''ll only see the difference when viewing the compiled
    source within the Developer Toolbar in Chrome:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Viewing the differences in file sizes](img/BO5194_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The real benefit, though, is in the `img` folder within our project area, the
    original JPEG image we use is 222 KB; however, the WebP is a fraction of this
    size: it weighs in at just 82 KB. See what I mean about the saving in space?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, onwards we go: time to focus on another area of site building, which
    is manipulating colors. Colors play a key role within any site, as they make up
    a part of the message to the end user; let''s dive in and take a look at some
    of the options available when using PostCSS.'
  prefs: []
  type: TYPE_NORMAL
- en: Manipulating colors and color palettes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A challenge that any developer or designer will face is which color should be
    used on a site—a nice shade of red, or how about sea blue, for example? It doesn't
    matter whether they are responsible for choosing the shade to use, or if they
    have to pick the right RGB or HEX color to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'Irrespective of where responsibilities lie, we still have to choose a color,
    and there is a good chance we won''t be choosing one that comes from the default
    256-color palette, but one that is likely to be a lighter or darker shade, or
    perhaps a mix of two colors:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Manipulating colors and color palettes](img/BO5194_05_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Anyone used to working with SASS will already be aware of functions such as
    `lighten()`, `darken()` or `saturate()`—the great thing about PostCSS is that
    we can replicate similar functionality for those who want to move away from the
    dependency of SASS.
  prefs: []
  type: TYPE_NORMAL
- en: To see how easy it is to use, we're going to combine the power of two plugins
    for PostCSS—`postcss-color-palette` (available at [https://github.com/zaim/postcss-color-palette](https://github.com/zaim/postcss-color-palette)),
    and `postcss-color-mix` (from [https://github.com/iamstarkov/postcss-color-mix](https://github.com/iamstarkov/postcss-color-mix)).
    The former allows us to choose one or more colors from any of three palettes,
    while `postcss-color-mix` will mix specific colors to make a new color. There
    are reasons for using these plugins, which will become clear; for now, let's get
    stuck in and watch these plugins in action.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying and mixing colors using palettes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this exercise, we're going to take a look at mixing colors; `postcss-color-palette`
    allows us to choose multiple colors by name (and not by number!), then converts
    them to HEX equivalent values. We can then either create gradient-type effects,
    or simply mix the colors together (using `postcss-color-mix`) to produce a new
    color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s make a start:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by extracting a copy of the `Tutorial24` folder from the code download
    that accompanies this book; save the folder to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Tutorial24` folder, copy the `package.json` and `gulpfile.js` files
    to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We also need our stylesheet, for this, go ahead and copy the `style – pre-compile.css`
    file from the same folder and drop this into the `src` folder in our project area.
    Rename it as `style.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At this point we need to install the plugin, for this, so go ahead and fire
    up a Node.js command prompt session, then change the working folder to our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, enter the command shown in this screenshot, then press *Enter*,
    if all is well, we should see confirmation that the plugin has installed correctly:![Displaying
    and mixing colors using palettes](img/BO5194_05_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Repeat step 5, but this time, run the command shown in this screenshot:![Displaying
    and mixing colors using palettes](img/BO5194_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the prompt, enter `gulp`, then press *Enter*—PostCSS will go away and compile
    the style sheet, and drop the compiled results into the `dest` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the contents of the `dest` folder (which will be the uncompressed and minified
    style sheets, along with a source map file) to the `css` folder within the `Tutorial24`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try previewing `index.html` at the root of our `Tutorial24` folder; if all is
    well, we should see our mixed colors, as shown in this screenshot:![Displaying
    and mixing colors using palettes](img/BO5194_05_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Okay, the colors I''ve chosen clearly aren''t going to win any style awards
    any time soon, but they help serve a purpose: it is very easy to use proper color
    names, if preferred, while still allowing PostCSS to compile them into valid HEX
    values. That aside, let''s take a moment to consider the code we''ve used in this
    demo—it does raise a few key points, which we should cover, when using these plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting our demo in more detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The demo we''ve created follows similar principles to most other demos we''ve
    built so far; we begin with declaring variables to store instances of our plugins,
    thus:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The magic then happens in this task, within our `gulp` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we've specified a palette to use, the `mrmrs` option is the default,
    but we can equally use `material` or `flatui` as alternatives. All three reference
    the `webcolors` plugin from [https://github.com/zaim/webcolors/](https://github.com/zaim/webcolors/);
    this package could be expanded to include other palettes if desired.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the links to our two plugins in place, and the task set up, we can then
    begin to specify rules within our style sheet, which will use the plugins. We''ve
    created three, and all three use the `postcss-color-palette` to determine what
    the HEX value should be for each color; the third and final mixes the two colors
    together once HEX values have been assigned:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Getting the mix of the color right for the third rule isn't easy, the key to
    a successful mix is to avoid using colors that are in the same spectrum; the closer
    they are, the less impact the mix will have!
  prefs: []
  type: TYPE_NORMAL
- en: If you want a quick way to gauge how well colors have mixed, then try [http://jackiebalzer.com/color](http://jackiebalzer.com/color)—this
    demo has a `mix()` option in it, which will compile them in the browser and avoid
    the need to run the compilation process manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve covered some of the plugins that are likely to be more popular; there
    are more available via the `PostCSS.parts` directory, which may be of interest:'
  prefs: []
  type: TYPE_NORMAL
- en: '`colorguard`: Helps maintain a consistent color palette'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcss-ase-colors`: Replaces color names with values read from an ASE palette
    file; this is perfect if you happen to be a user of Adobe PhotoShop, InDesign,
    or Illustrator'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcss-shades-of-gray`: Helps keep grayscale colors consistent to a gray
    palette'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`postcss-color-pantone`: Transforms Pantone color to RGB.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In the meantime, let''s move on: we''ve explored using palettes to select our
    colors, before mixing them to create new ones. This is just scratching the surface
    of what is possible; how about creating different *shades* of colors, using functions
    such as `darken()`, `tint()` or `lightness()`? Such functions already exist in
    most preprocessors, such as SASS; let''s explore how we can achieve the same results
    using PostCSS plugins.'
  prefs: []
  type: TYPE_NORMAL
- en: Creating color functions with PostCSS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In our journey through manipulating colors using PostCSS, we've so far seen
    how to define colors using palettes—this may work in some instances, but there
    will be occasions when we need to specify a color that doesn't feature in a palette.
  prefs: []
  type: TYPE_NORMAL
- en: We can always try to specify the value manually, but what happens if we need
    to alter it? Do we try to find every instance of it, and risk the possibility
    of missing an instance?
  prefs: []
  type: TYPE_NORMAL
- en: The answer is no. Instead, we can use the `postcss-color-function` plugin to
    create our colors dynamically; we can then assign the resulting value to a variable
    if we find ourselves frequently using this color. We can use this route to produce
    some nice shades of colors, so let's get stuck in and explore using this plugin
    in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Adjusting colors using functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A useful facility within most CSS preprocessors is the ability to create new
    colors dynamically, we can do this either by adjusting a color channel, or applying
    a filter effect to the color, such as making it darker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adjusting colors using functions](img/BO5194_05_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The benefit of this is simple, it allows us to reduce the number of base colors
    we assign by default; the remaining colors can be created automatically. If we
    need to change one of our base colors, then any colors created dynamically should
    still work.
  prefs: []
  type: TYPE_NORMAL
- en: Thankfully, we can achieve the same effects within PostCSS, to do this, we need
    to make use of the `postcss-color-function` plugin, available from [https://github.com/postcss/postcss-color-function](https://github.com/postcss/postcss-color-function).
    We'll also be using the `css-color-converter` plugin, to help manage conversion
    between different color formats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s explore this in more detail with a simple demo:'
  prefs: []
  type: TYPE_NORMAL
- en: We start by extracting a copy of the `Tutorial25` folder from within the code
    download that accompanies this book—go ahead and save this to our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the project area already has a `package.json` and/or a `gulpfile.js` present,
    then remove them; replace them with the files from within the `Tutorial25` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although we have the right configuration files in place, we still need to install
    the plugin—go ahead and fire up a Node.js command prompt session, then change
    the working folder to our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, enter these commands, pressing *Enter* after each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At this point, we can now go ahead and compile our style sheet—look for `styles
    – pre-compile.css` from within the `css – completed version` subfolder, and save
    it to the `src` folder within our project area as `style.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Switch to the Node.js command prompt from earlier, then enter `gulp` at the
    prompt and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should see the by now compiled style sheets appear (both
    uncompressed and minified), along with the source map in the `dest` folder. Copy
    the contents of this folder to the `css` folder within the `Tutorial25` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try previewing the results within a browser, if the compilation was successful,
    we should see four boxes with different shades of red appear, as shown at the
    start of this exercise. The question is though, we've seen the results appear,
    but how does PostCSS know to create these colors?
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting our demo
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It''s a good question, the conversion process is very simple; the trick to
    it, though, lies not within compiling, but working out how to achieve the color!
    Odd as it may seem, choosing the color isn''t as easy as it looks; let me explain
    more:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The compilation process is, like other PostCSS plugins, very easy to configure—we
    begin of course with creating a variable that defines the `color-function` plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we add a reference to our principal gulp task, here we''ve used both
    `autoprefixer` and the `color-function` plugin together, but the former isn''t
    strictly needed, as we''re not adding any vendor prefixes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The real magic, though, is in the colors we assign within our style sheet—our
    first box is a control, with a standard red color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next up, we''re adding a `tint` of `60%` to `box1`, which has the effect of
    turning it a light pink:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '`Box2` goes the other way, even though we''ve used a lightness filter (where
    you might expect a similar result as `box1`), the negative number makes it a brown-red
    color:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The final box, `box3`, continues the brown theme from `box2`, but makes it
    lighter. Note though, that in the comment, this shade is what would be produced
    if we had applied a sepia tone:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The question is, how would we know that this is indeed a sepia filter being
    applied?
  prefs: []
  type: TYPE_NORMAL
- en: At face value, it looks like we've selected red, then altered each channel by
    a specific amount to get the final result.
  prefs: []
  type: TYPE_NORMAL
- en: A drawback of using this plugin is that it doesn't have functions to support
    all of the equivalent CSS3 filters available today; it does mean we have to be
    resourceful, and calculate what the color should be directly. We will be able
    to change that in the next demo—there will be occasions when we need to create
    our own custom filters; a good example is sepia. It does mean more work upfront,
    but it allows us to then call a `sepia()` function by name, rather than approximate
    the final result.
  prefs: []
  type: TYPE_NORMAL
- en: If you struggle to find what a color should be once a filter is applied, take
    a look at [http://jackiebalzer.com/color](http://jackiebalzer.com/color); this
    is a great site that allows us to choose a color and see what the results are
    when filters are applied. It is written for SASS, but the end result will be identical
    for PostCSS. A site such as ColorHexa.com ([http://www.colorhexa.com](http://www.colorhexa.com))
    is a good help too, we can use it to verify what color values should be when a
    filter has been applied.
  prefs: []
  type: TYPE_NORMAL
- en: On we go. We discovered during our exercise that the `postcss-color-function`
    plugin doesn't cover all of the CSS3 filters that we can use in CSS; for the `sepia`
    example, we had to assign a calculated color value, rather than applying a filter
    effect. Let's fix that now. With a bit of upfront rework to our demo, we can create
    our own custom functions. It means that if, for example, we want a sepia effect,
    then we can call `sepia()`, rather than calculate what the final color should
    be!
  prefs: []
  type: TYPE_NORMAL
- en: Creating colors with PostCSS filters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our previous demo, we took a look at programmatically changing colors—this
    is a function that has been present in most CSS processors (such as SASS or Less)
    for some time.
  prefs: []
  type: TYPE_NORMAL
- en: There may be occasions where we require a finer degree of control over changing
    colors, and that simply using existing functions provided by the `postcss-color-function`
    plugin isn't sufficient, or that the desired filter isn't available. If we're
    feeling inclined, we can create our own color functions; for this, we can use
    the `postcss-functions` plugin, available from [https://github.com/andyjansson/postcss-functions](https://github.com/andyjansson/postcss-functions),
    to expose the use of JavaScript functions in our task file.
  prefs: []
  type: TYPE_NORMAL
- en: It's worth noting, though, that if a CSS3 filter doesn't exist, then most can
    be created using a combination of different calculations (such as the `sepia`
    example from the previous demo). This may technically work okay, but it is easier
    to simply reference a sepia filter by name, rather than work out that `#box3`
    has a sepia effect applied!
  prefs: []
  type: TYPE_NORMAL
- en: 'I feel a demo coming on, so without further ado, here''s a screenshot of what
    we''re going to create:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating colors with PostCSS filters](img/BO5194_05_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In short, we're using a standard shade of red (`#ff0000`, just to be clear!),
    and calculating various shades using a tint, darken, or sepia filter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at how to create these colors in more detail:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll start by extracting a copy of the `Tutorial26` folder from the code download
    that accompanies this book; save it to the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, go ahead and remove any copies of `gulpfile.js` and `package.json` from
    the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Tutorial26` folder, copy both `package.json` and `gulpfile.js` to
    the root of our project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With these files in place, we still need to install the plugins. In a Node.js
    command prompt window, change the working folder to our project, then enter these
    commands, and press *Enter* after each:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: From the `Tutorial26` folder, copy `style – pre-compile.css` to the `src` folder
    in the project area; rename it to `style.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Revert back to the Node.js command prompt window, then at the prompt, enter
    `gulp` and press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all is well, we should see a source map and two compiled style sheets appear
    in the `dest` folder; copy these to the `css` folder within the `Tutorial26` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Try running the demo in a browser. If all is well, we should see four boxes
    appear, with various shades of red, as shown at the start of this exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we take a look at the contents of the `gulp` task file in more detail, it
    will look larger than previous exercises; it might look like we're doing more,
    but in reality, a lot of it we've already seen before, in earlier demos. Let's
    take a look at it in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring our demo in more detail
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we open up our gulp task file, we can see it contains a number of functions,
    along with tasks that we've used in previous demos, such as `lint-styles`. The
    key in this demo is the three color functions, along with the main part of the
    `autoprefixer` task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the `color` functions, using `darkenColor` as our example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We begin by extracting the decimal value, then subtracting it (as `frac`) from
    `1`. This gives us our adjust value, or the value by how much we will darken our
    colors. Next up, we convert the color used (in this case, red) to a valid RGBA
    value, and split it into the RGBA array. We then multiply each array value from
    `rgba` by the darken value, and reform it as a valid color, before converting
    it to a HEX value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once each function has been created, we can then reference it from our gulp
    task, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: All of the functions use a similar process, but the main calculations that use
    the values from the `rgba[]` array, such as adding a tint (`tintColor`), or working
    in a sepia effect (`sepiaColor`), will be different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The question you may ask though, is where do we get the calculations from?
    Well, there are plenty of sources available on the Internet, such as this link
    on Stack Overflow: [http://stackoverflow.com/questions/6615002/given-an-rgb-value-how-do-i-create-a-tint-or-shade](http://stackoverflow.com/questions/6615002/given-an-rgb-value-how-do-i-create-a-tint-or-shade).
    Another alternative that may be worth a look is on Chris Coyier''s CSS Tricks
    site, at [https://css-tricks.com/snippets/javascript/lighten-darken-color/](https://css-tricks.com/snippets/javascript/lighten-darken-color/).
    In reality though, the best site I''ve seen so far is in the CamanJS library,
    at [http://www.camanjs.com](http://www.camanjs.com); the examples in this demo
    are based on the functions available from this library at [http://camanjs.com/docs/filters.html](http://camanjs.com/docs/filters.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A useful little tip, if you want to check what color values should be displayed
    for a particular tint or shade, is to check out [http://highintegritydesign.com/tools/tinter-shader/](http://highintegritydesign.com/tools/tinter-shader/).
  prefs: []
  type: TYPE_NORMAL
- en: Comparing with CSS3 filters
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A key question we must ask at this stage is "why should we go through the effort
    of creating individual functions, when we could easily use a library such as CamanJS?"
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, there are some key reasons for taking the route that we used in our demo:'
  prefs: []
  type: TYPE_NORMAL
- en: CamanJS is a great library, and produces some wonderful effects, but it is an
    external dependency; we run the risk that development may be discontinued in the
    future, which might have an impact on our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using PostCSS means that we can remove the dependency on external libraries,
    we are in control over which effects should be included, and which are surplus
    to requirements. If we use a library such as `CamanJS`, then we may be forced
    to include lots of extra baggage that unnecessarily inflates our code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not every browser will support standard CSS3 filters—using PostCSS gives us
    an opportunity to design our own filters that can apply similar effects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can always use existing processors, such as SASS, but again we have a dependency
    on an external library; using PostCSS means we can still apply the same principles,
    but without the dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The key here, though, is that filter support in browsers is very good, save
    for IE—we should always consider using CSS3 filters first, but can look to create
    an IE-specific style sheet that allows us to use our own versions from within
    PostCSS.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Instagram effects to your images
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Creating filters with PostCSS shouldn't be all boring though, we can absolutely
    have some fun with filters! A quick and easy way to apply some additional style
    to an image is through the use of Instagram filters—thankfully there is a pre-built
    plugin we can use for this purpose.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the `Instagram` plugin, available from [https://github.com/azat-io/postcss-instagram](https://github.com/azat-io/postcss-instagram).
    Let''s get stuck in and create a simple demo:'
  prefs: []
  type: TYPE_NORMAL
- en: We'll begin, as always, by extracting a copy of the `Tutorial27` folder from
    the code download that accompanies this book—save this to the project area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, extract copies of `gulpfile.js` and `package.json`, replace any that are
    stored at the root of our project area, with these new copies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now need to install the `postcss-instagram` plugin, so go ahead and fire
    up a Node.js command prompt session, then change the working folder to our project
    area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the prompt, go ahead and enter this command, then press *Enter*:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Copy the `style – pre-compile.css` file to the `src` folder at the root of our
    project area, then rename it as `style.css`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the plugin is installed, enter `gulp` at the prompt, then press *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: PostCSS will go away and compile our code, if all is well, we should see the
    usual files appear in the `dest` folder; copy these to the `css` folder within
    the `Tutorial27` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At this point, if we try to preview the results in a browser, we should see
    something akin to this screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Instagram effects to your images](img/BO5194_05_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The key to this is in the main CSS style sheet, we can apply the required filter
    using nothing more than this within the rule:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Instagram effects to your images](img/BO5194_05_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: This applies the `1977` filter (one of the filters available with the plugin).
    If we take a look at the compiled code, we can see that the plugin has added some
    additional rules; one to take care of creating the filter, and two to take care
    of positioning the filter on top of the image.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take a look at the compiled code, we can see the changes made by the
    plugin:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding Instagram effects to your images](img/BO5194_05_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you really want to get into the depths, then it's worth taking a look at
    the source code for this plugin, at [https://github.com/azat-io/postcss-instagram/blob/master/index.js](https://github.com/azat-io/postcss-instagram/blob/master/index.js).
    It is fairly complex, but if you look carefully, you can see signs of the filter
    code that is used to apply the effect to our images.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Manipulating images and color can either be very rewarding, or somewhat daunting,
    depending on how simple or complicated we make our processes! Fortunately, PostCSS
    can help automate a fair degree of our processes, so let's take a moment to consider
    what we've covered throughout this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We kicked off with a look at adding media assets, and using PostCSS to automatically
    update asset links, this helps remove any risk that we inadvertently use the wrong
    link!
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on to manipulating images, we started with a look at creating
    image sprites, first using SASS, before transitioning to using PostCSS. Next up
    came a more in-depth look at altering images, where we used the `Evil Icons` SVG
    library and set up PostCSS to alter the color of each icon at compilation. We
    then moved on to learn about how we can switch in the WebP image format; while
    most people might use standard format images, we learned how easy it is to switch-in
    WebP images, when using a supported browser.
  prefs: []
  type: TYPE_NORMAL
- en: Moving on, we then turned our attention to manipulating colors through the use
    of specific palettes, we covered how you can use PostCSS to compile in human-readable
    color names, and then mix or manipulate them within our style sheet. We then amped
    things up a little, with a look at using PostCSS to apply specific color filters,
    to alter color levels in a chosen color. We then explored some of the disadvantages
    of using standard plugins, and why we might need to create our own custom filters,
    that can be applied during compilation of our code. We then rounded out the chapter
    with a quick look at using some fun Instagram filters, where we can easily see
    how multiple filters are put together to manipulate images within our site.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wow, we''ve certainly covered a lot of content! But our journey doesn''t stop
    there: in the next chapter, we''ll take a look at creating grids, which we can
    then use to construct layouts within our projects.'
  prefs: []
  type: TYPE_NORMAL
