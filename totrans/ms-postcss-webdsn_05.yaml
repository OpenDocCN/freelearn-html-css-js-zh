- en: Chapter 5. Managing Colors, Images, and Fonts
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章. 管理颜色、图像和字体
- en: A website isn't a great website without some form of color, imagery, or fonts—a
    mix of these will add interest, express content more clearly where words might
    be insufficient, and generally help maintain visitor engagement.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 一个网站如果没有某种形式的颜色、图像或字体，就不会是一个伟大的网站——这些元素的混合将增加兴趣，在文字可能不足够清晰的地方表达内容，并且通常有助于保持访客的参与度。
- en: 'Users of existing preprocessors will of course be familiar with libraries such
    as the Compass authoring framework for SASS from [http://www.compass-style.org](http://www.compass-style.org);
    what if we could produce similar effects, but much faster, and without the need
    for dependencies? No problem, with PostCSS, we can pick and choose which plugins
    are needed for our site, and begin to build up a processor that suits our needs.
    We will cover a number of topics throughout this chapter, which will include:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 现有预处理器用户当然熟悉来自 [http://www.compass-style.org](http://www.compass-style.org)
    的 Compass 编写框架等库；如果我们能够产生类似的效果，但速度更快，且无需依赖，那会怎么样？没问题，使用 PostCSS，我们可以挑选和选择我们网站所需的插件，并开始构建一个满足我们需求的处理器。在本章中，我们将涵盖多个主题，包括：
- en: An overview of plugins available to handle colors, images, and fonts
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可用于处理颜色、图像和字体的插件的概述
- en: Creating image sprites using existing preprocessors
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有预处理器创建图像精灵
- en: Adding SVG support using existing preprocessors
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用现有预处理器添加 SVG 支持
- en: Transitioning to using PostCSS plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转向使用 PostCSS 插件
- en: Manipulating colors and color palettes using PostCSS plugins
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 PostCSS 插件操作颜色和调色板
- en: Let's make a start…!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧…！
- en: Adding color, fonts, and media to sites
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向网站添加颜色、字体和媒体
- en: '*A picture paints a thousand words…*'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '*一张图片胜过千言万语…*'
- en: Originally created in the 1920s, this phrase is so apt in the world of digital
    content—writing a hundred words doesn't have the same appeal if we can replace
    it with a single image and still convey the same meaning!
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 这个短语最初是在 1920 年代创造的，在数字内容的世界里非常贴切——如果我们能用一张图片替换一百个字，并且仍然传达相同的意思，那么写一百个字就没有同样的吸引力了！
- en: A part of any developer or designer's work will be to source the right images
    or fonts, or choose the right colors, and include them on the site they are building
    so they can be referenced at the appropriate point. We'll explore some of the
    plugins and tricks we can use to modify colors, but for now, let's take a look
    at some of the plugins available for manipulating images and fonts within a site.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 任何开发人员或设计师的工作的一部分将是获取正确的图像或字体，或者选择正确的颜色，并将它们包含在他们正在构建的网站上，以便在适当的位置引用。我们将探讨我们可以使用的某些插件和技巧来修改颜色，但到目前为止，让我们看看一些可用于在网站内操作图像和字体的插件。
- en: Maintaining asset links
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 维护资产链接
- en: When sourcing media for a site, the usual process will be to create a folder
    for fonts, another for images, and so on, if any part of the process is likely
    to fail, then it is likely to be with applying incorrect links in our code. The
    risk of this happening will of course increase if we have a particularly complex
    folder structure!
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 当为网站获取媒体资源时，通常的过程是创建一个字体文件夹，另一个图像文件夹，等等，如果过程中的任何部分可能失败，那么很可能是我们在代码中应用了不正确的链接。如果我们有一个特别复杂的文件夹结构，这种风险当然会增加！
- en: 'Instead, we can take an alternative approach: why not get PostCSS (or a plugin)
    to do the work for us?'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，我们可以采取另一种方法：为什么不让我们让 PostCSS（或一个插件）为我们做这项工作呢？
- en: We can use the `postcss-assets` plugin for this purpose; if we specify a name,
    it will look in the files relative to the source file, then file paths specified
    in the loadPaths configuration option, and finally search in the URL specified
    in the basePath config path. The beauty of this is that we can simply reference
    the image name, and provided PostCSS finds an image with the same name in one
    of these preassigned locations, then it will substitute in the appropriate path
    for us at compilation.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用 `postcss-assets` 插件来完成这个目的；如果我们指定一个名称，它将在源文件相关的文件中查找，然后是 loadPaths 配置选项中指定的文件路径，最后是在
    basePath 配置路径中指定的 URL 中搜索。这种美妙的特性在于，我们可以简单地引用图像名称，只要 PostCSS 在这些预先指定的位置之一找到一个同名图像，它就会在编译时为我们替换适当的路径。
- en: If a link needs to change, then no problem, we can either add a new one in,
    or modify the existing one; CSS styles will be updated at the next compilation.
    Let's put this into practice, using the `postcss-assets` plugin, in a simple demo.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个链接需要更改，那么没问题，我们可以在其中添加一个新的，或者修改现有的一个；CSS 样式将在下一次编译时更新。让我们通过使用 `postcss-assets`
    插件，在一个简单的演示中将其付诸实践。
- en: Automating links to assets
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 自动化资产链接
- en: Remember the moody landscape image from [Chapter 4](ch04.html "Chapter 4. Building
    Media Queries"), *Building Media Queries*?
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 记得[第4章](ch04.html "第4章. 构建媒体查询")中的情绪化风景图像吗，*构建媒体查询*？
- en: In our first example, we're going to rework this demo, but this time use the
    `postcss-assets` plugin (available from [https://github.com/borodean/postcss-assets](https://github.com/borodean/postcss-assets))
    to automate the insertion of links for all of our assets. We'll focus on images
    and fonts, but this can equally apply to media such as videos as well.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的第一个例子中，我们将重构这个演示，但这次使用`postcss-assets`插件（可在[https://github.com/borodean/postcss-assets](https://github.com/borodean/postcss-assets)找到）来自动插入所有资产的链接。我们将专注于图像和字体，但这同样适用于视频等媒体。
- en: 'Here''s a screenshot to remind ourselves of that image:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一个截图来提醒我们那个图像：
- en: '![Automating links to assets](img/BO5194_05_01.jpg)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![自动化链接到资产](img/BO5194_05_01.jpg)'
- en: 'Let''s make a start:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始：
- en: Go ahead and download a copy of the `Tuturial19` folder from the code download
    that accompanies this book, save this at the root of our project area. This contains
    a partially reworked version of the demo from [Chapter 4](ch04.html "Chapter 4. Building
    Media Queries"), *Building Media Queries*.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的代码下载中下载`Tuturial19`文件夹的副本，并将其保存到我们项目区域的根目录。这包含了对[第4章](ch04.html "第4章.
    构建媒体查询")中演示的部分重构版本，即*构建媒体查询*。
- en: Next, go ahead and remove any copies of `gulpfile.js` and `package.json` from
    the root of our project area—we'll start this chapter with fresh copies from our
    code download.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请从我们项目区域的根目录中删除任何`gulpfile.js`和`package.json`的副本——我们将从这个代码下载中开始这一章的新副本。
- en: 'We now need to install the `postcss-assets` plugin, so fire up a Node.js command
    prompt session, enter this command, and then press *Enter*:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要安装`postcss-assets`插件，所以启动一个Node.js命令提示符会话，输入以下命令，然后按*Enter*键：
- en: '[PRE0]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Don't close it, we will use it again shortly!
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不要关闭它，我们很快还会用到它！
- en: We need to extract copies of the `gulpfile.js` and `package.json` files from
    the code download—go ahead and save them to the root of our project area.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要从代码下载中提取`gulpfile.js`和`package.json`文件的副本——请将它们保存到我们项目区域的根目录。
- en: The sharp-eyed amongst you will note we are not installing any other plugins—we're
    using ones that we have already installed in earlier exercises; the `package.json`
    file will include references to these and the `postcss-assets` file.
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 眼尖的你们会注意到我们没有安装任何其他插件——我们正在使用之前练习中已经安装的插件；`package.json`文件将包含对这些插件和`postcss-assets`文件的引用。
- en: In the `Tutorial19` folder, look for and copy the `styles – pre-compile.css`
    file to the `src` folder in our project area; rename it to `styles.css`.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tutorial19`文件夹中，找到并复制`styles – pre-compile.css`文件到我们项目区域的`src`文件夹中；将其重命名为`styles.css`。
- en: Revert back to the Node.js command prompt window, then enter gulp at the prompt
    and press *Enter*.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到Node.js命令提示符窗口，然后在提示符中输入`gulp`并按*Enter*键。
- en: If all is well, we should have a `maps` folder and two CSS stylesheets (one
    full version, one minified)—if we copy these back to the `css` folder in the `Tutorial19`
    folder, then run the demo, we should see a familiar image of a landscape with
    early mist, as shown at the start of this demo.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该有一个`maps`文件夹和两个CSS样式表（一个完整版本，一个压缩版本）——如果我们将这些文件复制回`Tutorial19`文件夹中的`css`文件夹，然后运行演示，我们应该看到一幅熟悉的风景图像，就像在这个演示的开始部分所展示的那样。
- en: Okay, the image is displayed, along with the text in Roboto font, but how does
    it all work? It's worth taking a few moments to explore the code; setting it up
    correctly will help save you a lot of time!
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，图像已经显示，同时还有Roboto字体中的文本，但这一切是如何工作的呢？花几分钟时间探索代码是值得的；正确设置它将帮助你们节省大量时间！
- en: Most of what is in the gulp file you will recognize from earlier demos—we've
    included the same linting, renaming, and source map creations as before. In addition
    to the new assets task (to handle our asset links), we've removed the `autoprefixer`
    task; we're not calling anything that requires vendor prefixes, so there is no
    need to use it.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在`gulp`文件中，你们大多数人都会从之前的演示中认出大部分内容——我们包括了之前的linting、重命名和源映射创建。除了新的资产任务（用于处理我们的资产链接）之外，我们还移除了`autoprefixer`任务；我们没有调用需要供应商前缀的任何内容，因此不需要使用它。
- en: 'The key process in the gulp file centers on this code—this creates, and substitutes
    in, the correct asset links. We start with the options configuration object—the
    `loadPaths` take care of the asset locations, and `relativeTo` tells the plugin
    to set relative links in relation to the `dest/` folder. In this case, `loadPaths`
    defines specific folders to use; we use `relativeTo` to make these paths relative:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Gulp文件中的关键过程集中在以下代码上——它创建并替换正确的资产链接。我们首先从选项配置对象开始——`loadPaths`负责资产位置，而`relativeTo`告诉插件相对于`dest/`文件夹设置相对链接。在这种情况下，`loadPaths`定义了要使用的特定文件夹；我们使用`relativeTo`使这些路径成为相对路径：
- en: '[PRE1]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `dest/` folder is used in our creation process—in reality, this would be
    the location of our CSS style sheets on the production server. This next simple
    task simply calls the `postcss-assets` plugin, and processes each style sheet
    found in the `src` folder:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`dest/`文件夹用于我们的创建过程中——实际上，这将是我们的生产服务器上CSS样式表的存放位置。接下来的这个简单任务只是调用`postcss-assets`插件，并处理在`src`文件夹中找到的每个样式表：'
- en: '[PRE2]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We then simply call the task, if we were to call gulp from a command prompt,
    then it will run all of these tasks:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们只需调用任务即可，如果我们从命令提示符中调用gulp，它将运行所有这些任务：
- en: '[PRE3]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: All in all, a very simple but highly effective tool, it removes the need to
    insert any links manually, provided we've included them within the configuration
    object.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 总的来说，这是一个非常简单但非常有效的工具，它消除了手动插入链接的需求，前提是我们已经将它们包含在配置对象中。
- en: 'Alright…let''s move on: we''ve covered a simple method to ensure we always
    have the right links for font or image files. There is still an element of manual
    work required though—do we really need to include all of the lines added for our
    custom font?'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧…让我们继续：我们已经介绍了一种简单的方法来确保我们始终有正确的字体或图像文件的链接。尽管如此，仍然需要一些手动工作——我们真的需要包含为我们的自定义字体添加的所有行吗？
- en: Well, we could always just use a font hosted on Google, but that destroys the
    point of using PostCSS! Instead, we can simply use the custom font name in our
    style sheet, but get PostCSS to add in the custom font-face declaration automatically
    at compilation. Intrigued? Let's take a look at how, as part of our next exercise.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们总是可以使用托管在Google上的字体，但这破坏了使用PostCSS的意义！相反，我们可以在样式表中简单地使用自定义字体名称，但让PostCSS在编译时自动添加自定义font-face声明。感兴趣吗？让我们看看如何，作为我们下一个练习的一部分。
- en: Managing fonts with PostCSS
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用PostCSS管理字体
- en: 'In our previous demo, we explored a means to automatically add links using
    PostCSS—it shortcuts the need to worry about providing the right locations for
    files. The trouble is, when used with custom fonts, it still requires too much
    work (yes, I know, we humans are inherently lazy!). There is a better alternative:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的演示中，我们探索了一种使用PostCSS自动添加链接的方法——它简化了提供文件正确位置的需求。但是，当与自定义字体一起使用时，它仍然需要太多的工作（是的，我知道，我们人类天生就懒惰！）。有一个更好的选择：
- en: Enter the `postcss-fontpath` plugin, available from [https://github.com/seaneking/postcss-fontpath](https://github.com/seaneking/postcss-fontpath);
    this is a simple plugin that requires limited information about our custom font,
    and in return will produce the full font-face declaration at the compilation stage.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 输入`postcss-fontpath`插件，可从[https://github.com/seaneking/postcss-fontpath](https://github.com/seaneking/postcss-fontpath)获取；这是一个简单的插件，它只需要我们提供有关自定义字体的一些有限信息，并在编译阶段生成完整的font-face声明。
- en: 'So, rather than talk about it, why don''t we put it to use? Let''s revisit
    the responsive image demo we covered in the previous demo, and alter our style
    sheet to use the fontpath plugin to handle our custom font:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，与其谈论它，不如让我们实际应用它？让我们回顾一下我们在上一个演示中覆盖的响应式图片演示，并修改我们的样式表以使用fontpath插件来处理我们的自定义字体：
- en: We'll start by extracting a copy of the `Tutorial20` folder from the code download
    that accompanies this book, and save the folder to the root of our project area.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从本书附带的代码下载中提取`Tutorial20`文件夹的副本，并将文件夹保存到我们的项目区域根目录。
- en: Next, take a copy of `package.json` and `gulpfile.js` files from the `Tutorial20`
    folder, and replace the existing versions that are at the root of our project
    area.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，从`Tutorial20`文件夹中复制`package.json`和`gulpfile.js`文件，并替换我们项目区域根目录中现有的版本。
- en: Go ahead and fire up a Node.js command prompt, and change the working folder
    to that of our project area.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启动一个Node.js命令提示符，并将工作文件夹更改为我们的项目区域。
- en: 'At the command prompt, enter this command, then press *Enter*:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中，输入以下命令，然后按*Enter*键：
- en: '[PRE4]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Although we've installed the plugin explicitly, we can easily install it using
    just `npm install`; the presence of the `package.json` file in the folder will
    tell NPM what to install (in this case the missing `postcss-fontpath` plugin).
    Keep the session open, we will use it again shortly.
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管我们已经明确安装了插件，但我们只需使用 `npm install` 就可以轻松安装它；文件夹中存在的 `package.json` 文件将告诉 NPM
    要安装什么（在这种情况下是缺失的 `postcss-fontpath` 插件）。保持会话开启，我们很快还会用到它。
- en: Take a copy of `styles – pre-compile.css` from the `css – completed version`
    folder, and save this as `styles.css` into the `src` folder at the root of our
    project area.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `css – completed version` 文件夹中复制 `styles – pre-compile.css`，并将其保存为 `styles.css`
    到项目区域的根目录下的 `src` 文件夹中。
- en: Revert back to the Node.js command prompt window, then enter `gulp` at the prompt,
    and press *Enter*.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Node.js 命令提示符窗口，然后在提示符中输入 `gulp`，然后按 *Enter* 键。
- en: If all is well, we should see the, by now, familiar style sheets and source
    map appear in the `dest` folder; copy these to the `css` folder within the `Tutorial20`
    folder.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该会在 `dest` 文件夹中看到现在熟悉的样式表和源映射；将这些复制到 `Tutorial20` 文件夹内的 `css` 文件夹中。
- en: At this point, we should now have a working demo; we won't see anything intrinsically
    different, but know that at compilation, PostCSS has automatically added the right
    font-face declarations for our font.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们应该已经有一个可以工作的演示了；我们可能不会看到任何本质上的不同，但要知道在编译时，PostCSS 已经自动为我们添加了正确的字体声明。
- en: 'The beauty about this plugin is in its simplicity—it needs no more than the
    addition of a simple command in the main task:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这个插件的优点在于其简单性——它不需要在主任务中添加任何额外的命令：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'There is no need to have to specify any additional configuration elements or
    rules, the plugin does exactly what it says on the tin, so to speak! Although
    we''ve not achieved anything ground-breaking with this example, it does serve
    to illustrate some key points about using PostCSS:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 没有必要指定任何额外的配置元素或规则，插件确实做到了它所说的那样！虽然我们在这个例子中没有取得任何突破性的成就，但它确实有助于说明使用 PostCSS
    的一些关键点：
- en: PostCSS works best when plugins concentrate on a single task and don't try to
    achieve everything under the sun in one go. Adhering to the single responsibility
    principle means we can reduce duplication, make the plugin more robust, and avoid
    instances where changes can end up breaking functionality elsewhere in our processor!
    This plugin is perfect—it just provides a font-face declaration for the specified
    font, and nothing else.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当插件专注于单一任务而不是试图一次性完成所有事情时，PostCSS 工作得最好。遵循单一责任原则意味着我们可以减少重复，使插件更健壮，并避免更改最终导致处理器其他地方功能中断的情况！这个插件是完美的——它只为指定的字体提供字体声明，没有其他任何功能。
- en: Sometimes, when choosing the right plugin in PostCSS, there will be occasions
    when we choose something that later turns out not to work as expected. A case
    in point is the `postcss-font-magician` plugin (available from [https://github.com/jonathantneal/postcss-font-magician](https://github.com/jonathantneal/postcss-font-magician));
    it has the right idea of providing font-face declarations, but tries to provide
    them for Google-hosted fonts, locally hosted fonts, Bootstrap, and so on.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有时候，在选择 PostCSS 中的正确插件时，可能会遇到我们选择的东西后来发现并不如预期工作的情况。一个例子是 `postcss-font-magician`
    插件（可在 [https://github.com/jonathantneal/postcss-font-magician](https://github.com/jonathantneal/postcss-font-magician)
    获取）；它有提供字体声明的好想法，但试图为 Google 托管的字体、本地托管字体、Bootstrap 等提供字体声明。
- en: Note
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Unfortunately, the net result is that at the time of writing, not all of the
    functionality appears to work as expected, so it is at this point where we have
    to look for alternatives.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不幸的是，在撰写本文时，并非所有功能似乎都按预期工作，因此我们不得不在这个时候寻找替代方案。
- en: If you would like to explore more, then the `postcss.parts` directory (at [http://www.postcss.parts](http://www.postcss.parts))
    has more options available; two that might be of interest are the `Assets Rebase`
    plugin (from [https://github.com/devex-web-frontend/postcss-assets-rebase](https://github.com/devex-web-frontend/postcss-assets-rebase)),
    and the PostCSS `Font Pack` plugin, from [https://github.com/jedmao/postcss-font-pack](https://github.com/jedmao/postcss-font-pack).
    We will cover the latter plugin in more detail in [Chapter 8](ch08.html "Chapter 8. Creating
    PostCSS Plugins"), *Creating PostCSS Plugins*.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想探索更多，那么`postcss.parts`目录（在[http://www.postcss.parts](http://www.postcss.parts)）提供了更多选项；其中两个可能对你有吸引力的是`Assets
    Rebase`插件（来自[https://github.com/devex-web-frontend/postcss-assets-rebase](https://github.com/devex-web-frontend/postcss-assets-rebase)），以及PostCSS的`Font
    Pack`插件，来自[https://github.com/jedmao/postcss-font-pack](https://github.com/jedmao/postcss-font-pack)。我们将在第8章[创建PostCSS插件](ch08.html
    "第8章。创建PostCSS插件")中更详细地介绍这个插件。
- en: 'Okay, so we have our text in place: it does look a little boring, doesn''t
    it? Well, we can fix that by adding images. So, how exactly can PostCSS help us,
    I hear you ask?'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，所以我们的文本已经准备好了：它看起来有点无聊，不是吗？嗯，我们可以通过添加图像来解决这个问题。那么，PostCSS究竟如何帮助我们呢？我听到你问道？
- en: It can help in a number of ways—instead of using plain colors, we can begin
    to mix some together, for example. Or how about using image sprites? A pain to
    create manually, right? Not with PostCSS. I'll bet you've seen some of the image
    filters you can use on images (such as sepia or tint), but found that they don't
    work in every browser right?
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 它可以通过多种方式帮助——例如，我们可以开始混合一些纯色，而不是使用纯色。或者，使用图像精灵怎么样？手动创建很痛苦，对吧？但不是用PostCSS。我敢打赌，你已经看到了一些可以在图像上使用的图像过滤器（例如，棕褐色或着色），但发现它们并不是在所有浏览器上都有效？
- en: 'These are just some of the ways that PostCSS can help us, and we will cover
    all of these and more throughout this chapter. Let''s make a start though on working
    with images: our first demo will cover the creation of image sprites. We''ll start
    with a quick recap of the SASS process, before switching to using PostCSS.'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是PostCSS能帮助我们的一些方式，我们将在本章中涵盖所有这些以及更多内容。不过，让我们先从处理图像开始：我们的第一个演示将涵盖图像精灵的创建。我们首先快速回顾一下SASS过程，然后再切换到使用PostCSS。
- en: Creating image sprites
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建图像精灵
- en: 'Let''s start with something easy: I''m sure that at some point you will either
    have used or created image sprites, right? If you''re a SASS developer, no doubt
    you will have availed yourself of the sprite mixins from Compass, and used an
    app such as **Koala** to compile, or compiled directly from the command line.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从简单的事情开始：我敢肯定，在某个时候，你要么使用过，要么创建过图像精灵，对吧？如果你是SASS开发者，毫无疑问，你已经使用了Compass的sprite混入，并使用像**Koala**这样的应用程序进行编译，或者直接从命令行编译。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A copy of the relevant files for creating sprites using Compass can be found
    in the code download that accompanies this book, in the `Tutorial21A` folder.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Compass创建精灵的相关文件可以在本书的代码下载中找到，位于`Tutorial21A`文件夹。
- en: The process is relatively straightforward, but you still have to set up a `Compass`
    project, install a GUI application (if you're using one), and so on, which is
    a real pain! We could use an online application such as **SpritePad** ([http://spritepad.wearekiss.com/](http://spritepad.wearekiss.com/))
    instead, but again that's a manual process, and it's prone to error. Instead,
    we can easily use PostCSS to help us here —over and above the normal variables
    that we declare at the top of any gulp file, there is very little required in
    order to produce basic image sprites. Let's take a look at creating one now, using
    the `p` `ostcss-sprites` plugin.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这个过程相对简单，但你仍然需要设置一个`Compass`项目，安装一个GUI应用程序（如果你在使用的话），等等，这真是个麻烦！我们可以使用一个在线应用程序，例如**SpritePad**([http://spritepad.wearekiss.com/](http://spritepad.wearekiss.com/))，但同样，这又是一个手动过程，而且容易出错。相反，我们可以轻松地使用PostCSS来帮助我们——除了在gulp文件顶部声明的正常变量之外，为了生成基本的图像精灵，所需的东西非常少。现在让我们看看如何使用`postcss-sprites`插件创建一个。
- en: Demo – creating a credit card icon bar
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 演示 - 创建信用卡图标栏
- en: How many times have you bought something from an e-commerce site? If you've
    bought as much as I have online, then no doubt you will have seen shopping carts
    with assorted payment card icons. These may be small, but they are nevertheless
    key to our site—after all, how can we tell if using a particular credit card might
    fail, if the online retailer doesn't accept Mastercard, for example? Seems obvious,
    but it's not always easy to tell.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 你有多少次在电子商务网站上购买过东西？如果你在网上购买的东西和我一样多，那么毫无疑问，你一定见过带有各种支付卡图标的购物车。这些图标可能很小，但它们对我们网站来说却至关重要——毕竟，如果在线零售商不接受万事达卡，我们如何知道使用特定的信用卡可能会失败呢？这似乎很明显，但并不总是容易判断。
- en: 'Leaving that aside, it is a cinch to create an image sprite with PostCSS; gone
    is the dependency on SASS: in its place we can use the `postcss-sprites` plugin
    (available from [https://github.com/2createStudio/postcss-sprites](https://github.com/2createStudio/postcss-sprites))
    to produce our composite image. Let''s dive in and take a look.'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 不考虑这一点，使用 PostCSS 创建图像精灵非常简单；SASS 的依赖已经消失：我们可以使用 `postcss-sprites` 插件（可在 [https://github.com/2createStudio/postcss-sprites](https://github.com/2createStudio/postcss-sprites)
    获取）来生成我们的组合图像。让我们深入探讨并查看一下。
- en: For this demo, we will use the credit card icons available at [http://findicons.com/pack/2102/credit_card_debit_card](http://findicons.com/pack/2102/credit_card_debit_card);
    please feel free to substitute if you would like to use different icons.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我们将使用在 [http://findicons.com/pack/2102/credit_card_debit_card](http://findicons.com/pack/2102/credit_card_debit_card)
    可用的信用卡图标；如果您想使用不同的图标，请随意替换。
- en: 'All of the code for this tutorial can be found in the `Tutorial21B` folder,
    in the code download—we will start afresh by installing the `postcss-sprites`
    plugin:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 本教程的所有代码都可以在 `Tutorial21B` 文件夹中找到，在代码下载中——我们将通过安装 `postcss-sprites` 插件来从头开始：
- en: Go ahead and fire up a Node.js command prompt, and change the working folder
    to that of our project area.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Node.js 命令提示符，并将工作文件夹更改为我们项目区域。
- en: At the command prompt, enter the command shown in this screenshot, then press
    *Enter*, once Node has confirmed successful installation, and minimize the window,
    as we will return to it later in this exercise:![Demo – creating a credit card
    icon bar](img/BO5194_05_02.jpg)
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符下，输入此截图所示的命令，然后按 *Enter* 键，一旦 Node 确认安装成功，请最小化窗口，因为我们将在本练习的稍后部分再次回到它：![演示
    – 创建信用卡图标栏](img/BO5194_05_02.jpg)
- en: 'Go ahead and fire up your text editor, then add the following lines—these represent
    four credit card icons we would typically add to any online e-commerce site:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在启动你的文本编辑器，然后添加以下行——这些代表我们通常添加到任何在线电子商务网站上的四个信用卡图标：
- en: '[PRE6]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Save the file as `style.css`, and store it in the `src` folder of our project
    area.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将文件保存为 `style.css`，并将其存储在我们项目区域的 `src` 文件夹中。
- en: In the same folder, create a folder called `img` at the root of our project
    area; extract copies of the icons stored in the code download that accompanies
    this book, and save them to the `img` folder.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在同一文件夹中，在项目区域的根目录创建一个名为 `img` 的文件夹；提取本书附带的代码下载中存储的图标副本，并将它们保存到 `img` 文件夹中。
- en: From the code download that accompanies this book, go ahead and extract a copy
    of `gulpfile.js`, and save this to the root of our project area.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从本书附带的代码下载中，提取 `gulpfile.js` 的副本，并将其保存到我们项目区域的根目录。
- en: Revert back to the Node.js window, then at the prompt, enter `gulp` and press
    *Enter*.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Node.js 窗口，然后在提示符下输入 `gulp` 并按 *Enter* 键。
- en: 'Our code will now be compiled, if all is well, we should see something akin
    to this when viewing the `style.css` file within the `dest` folder:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们的代码现在将被编译，我们应该在查看 `dest` 文件夹中的 `style.css` 文件时看到类似以下内容：
- en: '[PRE7]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'At this stage, we can then copy the code to our website, along with image—instead
    of using four separate icons (which each require separate calls to the server),
    we can cache the single icon. This will result in faster response times with fewer
    calls to our server. The compiled style sheet can be found in the `dest` folder,
    with the composite image one level up, in the `img` folder:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在此阶段，我们可以将代码连同图片一起复制到我们的网站上——而不是使用四个独立的图标（每个图标都需要单独调用服务器），我们可以缓存单个图标。这将导致响应时间更快，并且对服务器的调用次数更少。编译后的样式表可以在
    `dest` 文件夹中找到，组合图像位于 `img` 文件夹的上一级：
- en: '![Demo – creating a credit card icon bar](img/BO5194_05_03.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![演示 – 创建信用卡图标栏](img/BO5194_05_03.jpg)'
- en: 'Even though this is a simple process, it''s worth noting a key point with how
    our gulp file has been configured—the use of a configuration object for the `sprites`
    plugin:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这是一个简单的过程，但值得注意的是我们gulp文件配置的一个关键点——使用配置对象为`sprites`插件：
- en: '[PRE8]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'It''s not a process we''ve used to date, but it does not mean that it is any
    less useful—it simply boils down to a matter of personal preference and readability.
    It does make it easier to read the calls for each plugin we assign; in this instance,
    we''re only using one, but you can imagine what it will be like with multiple
    plugins in use:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是我们迄今为止使用过的过程，但这并不意味着它不那么有用——这仅仅是一个个人偏好和可读性的问题。它确实使得阅读我们分配给每个插件的调用变得更容易；在这个例子中，我们只使用了一个，但你可以想象如果有多个插件在使用会是什么样子：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Okay, let''s change tack and take a look at a different side to using images
    with PostCSS: using SVG format images. Standard images don''t always scale well,
    particularly when used in a responsive environment; sometimes we might use retina
    images instead, but an alternative to consider is the use of SVG images.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们改变方向，看看使用PostCSS处理图像的不同方面：使用SVG格式的图像。标准图像并不总是很好地缩放，尤其是在响应式环境中使用时；有时我们可能会使用视网膜图像，但可以考虑的一个替代方案是使用SVG图像。
- en: Working with SVG in PostCSS
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在PostCSS中使用SVG
- en: 'The rapidly increasing use of mobile devices makes creating responsive content
    a must; the traditional route is using something akin to `max-width: 100%` to
    control the size of an element on screen.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '移动设备的快速增加使得创建响应式内容变得必须；传统的做法是使用类似`max-width: 100%`的东西来控制屏幕上元素的大小。'
- en: A better alternative is to use SVG—this maintains quality, even when resized;
    standard image formats will become pixelated if resized to an excessive size.
    For those of you who have previously used SASS, then there isn't any in-built
    support for SVG as such; the most we can hope to achieve is efficient nesting
    within our style sheet.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的选择是使用SVG——即使在调整大小时也能保持质量；标准图像格式如果调整到过大的尺寸将会变得像素化。对于那些之前使用过SASS的人来说，那么并没有内置对SVG的支持；我们最多希望在我们的样式表中实现高效的嵌套。
- en: An example of what we might use can be found in the `sass` folder within the
    `Tutorial22` folder in the code download that accompanies this book.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能会使用的例子可以在本书附带的代码下载中`Tutorial22`文件夹内的`sass`文件夹中找到。
- en: If we're a regular user of SVG images within SASS, then it is likely we would
    use a library such as `sass-svg`, from [https://github.com/davidkpiano/sass-svg](https://github.com/davidkpiano/sass-svg).
    Moving away from SASS to PostCSS is easy; the PostCSS ecosystem has a number of
    plugins we can use to manipulate images. Let's take a look at how, using the `postcss-svg`
    plugin.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们是在SASS中经常使用SVG图像的用户，那么我们可能会使用像`sass-svg`这样的库，来自[https://github.com/davidkpiano/sass-svg](https://github.com/davidkpiano/sass-svg)。从SASS迁移到PostCSS很容易；PostCSS生态系统有许多插件我们可以用来操作图像。让我们看看如何使用`postcss-svg`插件来实现。
- en: Altering icon images using PostCSS
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用PostCSS修改图标图像
- en: 'We''ll use the `postcss-svg` plugin (from [https://github.com/Pavliko/postcss-svg](https://github.com/Pavliko/postcss-svg)),
    to manipulate some icons from the `Evil Icon` package (available from [https://github.com/outpunk/gulp-evil-icons](https://github.com/outpunk/gulp-evil-icons)),
    as part of the next demo:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用`postcss-svg`插件（来自[https://github.com/Pavliko/postcss-svg](https://github.com/Pavliko/postcss-svg)），来操作`Evil
    Icon`包（可在[https://github.com/outpunk/gulp-evil-icons](https://github.com/outpunk/gulp-evil-icons)找到）中的某些图标，作为下一个演示的一部分：
- en: We'll begin by extracting a copy of the `Tutorial22` folder from the code download
    that accompanies this book. Save it to the root of our project area.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将开始从本书附带的代码下载中提取`Tutorial22`文件夹的副本。将其保存到我们的项目区域根目录。
- en: From within the `Tutorial22` folder, extract copies of the `gulpfile.js` and
    `package.json` files, and use them to replace any that are currently stored at
    the root of our project area.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Tutorial22`文件夹内部，提取`gulpfile.js`和`package.json`文件的副本，并使用它们替换我们项目区域根目录下存储的任何文件。
- en: Go ahead and extract a copy of `style – pre-compile.css` from the same folder;
    save this as `style.css` within the `src` folder. Do the same for the `index.html`
    file as well.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从同一个文件夹中提取`style – pre-compile.css`的副本；将其保存为`src`文件夹内的`style.css`。同样，对`index.html`文件也做同样的处理。
- en: In a break to previous demos, we need an additional `css` folder—go ahead and
    create one within the `dest` folder.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在与之前的演示中断之后，我们需要一个额外的`css`文件夹——在`dest`文件夹内创建一个。
- en: Next, fire up a Node.js command prompt, and change the working folder to that
    of our project area.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，启动一个Node.js命令提示符，并将工作文件夹更改为我们的项目区域。
- en: 'We need to install the `postcss-svg` plugin, so at the command prompt, enter
    this command, then press *Enter*:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要安装`postcss-svg`插件，所以请在命令提示符中输入此命令，然后按*Enter*：
- en: '[PRE10]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Once completed, enter `gulp` at the command prompt, then press *Enter*.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成后，在命令提示符中输入`gulp`，然后按*Enter*。
- en: If all is well, we should see the usual two style sheets appear in the `/dest/css`
    folder, along with a source `map` folder. The HTML markup file will appear in
    the `dest` folder.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在`/dest/css`文件夹中看到通常的两个样式表，以及一个源`map`文件夹。HTML标记文件将出现在`dest`文件夹中。
- en: If you don't see the source map or minified versions appear, then rerun `gulp`—sometimes
    these files will only appear if a compiled `style.css` file is present.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果您没有看到源映射或最小化版本出现，那么请重新运行`gulp`——有时这些文件只有在存在编译后的`style.css`文件时才会出现。
- en: Copy the contents of the `dest` folder to the `css` folder within the `Tutorial22`
    folder—if all is well, we should see these icons appear when previewing the results
    in a browser:![Altering icon images using PostCSS](img/BO5194_05_04.jpg)
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`dest`文件夹的内容复制到`Tutorial22`文件夹内的`css`文件夹中——如果一切顺利，当在浏览器中预览结果时，我们应该会看到这些图标：![使用PostCSS更改图标图像](img/BO5194_05_04.jpg)
- en: Although this is a simple demo, we've covered some useful tips and tricks within;
    it's worth taking some time to explore how the demo was put together in more detail.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是一个简单的演示，但我们已经涵盖了一些有用的技巧和窍门；花些时间探索如何更详细地构建这个演示是值得的。
- en: Exploring the results in more detail
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 探索结果的详细信息
- en: There are several key elements to this exercise that are worthy of attention,
    the use of a CDN link and Node to provide the style sheet and icons for Evil Icons,
    the compiled HTML file and the references to use within our custom style sheet.
    We will cover all of these, but first let's explore the gulp file in more detail.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习有几个值得注意的关键元素，包括使用CDN链接和Node提供Evil Icons的样式表和图标、编译后的HTML文件以及在我们自定义样式表中使用的引用。我们将涵盖所有这些，但首先让我们更详细地探索gulp文件。
- en: 'We begin with these two lines:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从这两行开始：
- en: '[PRE11]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You should not be surprised to see the latter, but the former is present as
    the `Evil Icons` library can be installed using the `gulp-evil-icons` package.
    There are a number of different options available for installing, but as we're
    already using Gulp, it makes sense to continue using the task runner.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 您看到后者可能不会感到惊讶，但前者存在，因为可以使用`gulp-evil-icons`包安装`Evil Icons`库。安装有多种不同的选项可用，但既然我们已经在使用Gulp，继续使用任务运行器是有意义的。
- en: 'Next, we spread our work over two tasks—the first compiles the HTML code to
    assign the relevant icon image to our `<icon>` statements within our markup:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将工作分散到两个任务中——第一个任务将HTML代码编译，将相关的图标图像分配给我们的标记中的`<icon>`语句：
- en: '[PRE12]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'To change the colors requires the use of the `postcss-svg` plugin, here referenced
    by `postcssSVG`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 要更改颜色，需要使用`postcss-svg`插件，这里通过`postcssSVG`引用：
- en: '[PRE13]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We of course had to update our default task, if we simply call `gulp` at the
    command line, then it will know to run all of these tasks in turn:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当然必须更新我们的默认任务，如果我们简单地从命令行调用`gulp`，那么它将知道依次运行所有这些任务：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The last step also applies a similar update to our watch facility:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步也更新了我们的监视功能：
- en: '[PRE15]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'If we then take a look within the HTML markup, we can see a link to the `Evil
    Icons` library that was installed using Node.js:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们然后查看HTML标记，我们可以看到一个使用Node.js安装的`Evil Icons`库的链接：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We then put our customizations into a separate style sheet:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将自定义设置放入单独的样式表中：
- en: '[PRE17]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These look something like this:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 它们看起来像这样：
- en: '![Exploring the results in more detail](img/BO5194_05_05.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![探索结果的详细信息](img/BO5194_05_05.jpg)'
- en: 'At this stage, the CSS styles may look simple, but the HTML markup is anything
    but; the `postcss-svg` plugin has added an in-line version of our icons to the
    HTML markup, with the appropriate edits made from our custom style sheet:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，CSS样式可能看起来很简单，但HTML标记却并非如此；`postcss-svg`插件已将我们的图标以内联形式添加到HTML标记中，并从我们的自定义样式表进行了适当的编辑：
- en: '![Exploring the results in more detail](img/BO5194_05_06.jpg)'
  id: totrans-136
  prefs: []
  type: TYPE_IMG
  zh: '![探索结果的详细信息](img/BO5194_05_06.jpg)'
- en: Sometimes, it is easy to wonder if using SVG is worth the extra markup, the
    main benefit being that if it is added in-line, then we reduce the number of calls
    to external resources; any content that requires altering can be done, without
    sacrificing the quality of our images.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，很容易怀疑使用SVG是否值得额外的标记，主要好处是如果将其内联添加，那么我们可以减少对外部资源的调用；任何需要更改的内容都可以完成，而不会牺牲我们图像的质量。
- en: Considering alternative options
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 考虑替代选项
- en: 'We concentrated on using the `postcss-svg` plugin throughout our exercise,
    as a start to manipulating SVG images within the PostCSS system; there are some
    more options available, which may be of interest:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的练习中，我们专注于使用 `postcss-svg` 插件，作为在 PostCSS 系统中操作 SVG 图像的起点；还有一些其他选项可供选择，可能对你感兴趣：
- en: '`postcss-write-svg`: This plugin (available at [https://github.com/jonathantneal/postcss-write-svg](https://github.com/jonathantneal/postcss-write-svg))
    allows us to write inline SVGs in CSS.'
  id: totrans-140
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss-write-svg`：这个插件（可在 [https://github.com/jonathantneal/postcss-write-svg](https://github.com/jonathantneal/postcss-write-svg)
    获取）允许我们在 CSS 中写入内联 SVG。'
- en: '`postcss-inline-svg`: Another plugin (from [https://github.com/TrySound/postcss-inline-svg](https://github.com/TrySound/postcss-inline-svg)),
    which in-lines SVG images and allows us to customize their styles.'
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss-inline-svg`：另一个插件（来自 [https://github.com/TrySound/postcss-inline-svg](https://github.com/TrySound/postcss-inline-svg)），它将
    SVG 图像内联，并允许我们自定义它们的样式。'
- en: '`postcss-svgo`: This plugin (available at [https://github.com/ben-eb/postcss-svgo](https://github.com/ben-eb/postcss-svgo))
    processes inline SVG using the SVG Optimizer Tool for Node.'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss-svgo`：这个插件（可在 [https://github.com/ben-eb/postcss-svgo](https://github.com/ben-eb/postcss-svgo)
    获取）使用 SVG 优化工具对 Node 中的内联 SVG 进行处理。'
- en: If you have a need to provide a fall-back position for SVG files, then you can
    try the `postcss-svg-fallback` plugin, available from [https://github.com/justim/postcss-svg-fallback](https://github.com/justim/postcss-svg-fallback)—
    we will use this plugin later, in [Chapter 8](ch08.html "Chapter 8. Creating PostCSS
    Plugins"), *Creating PostCSS Plugins*.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要为 SVG 文件提供一个后备位置，那么你可以尝试使用 `postcss-svg-fallback` 插件，它可在 [https://github.com/justim/postcss-svg-fallback](https://github.com/justim/postcss-svg-fallback)
    获取——我们将在 [第 8 章](ch08.html "第 8 章。创建 PostCSS 插件") *创建 PostCSS 插件* 中使用这个插件。
- en: 'Okay, let''s change tack: using SVG images can be a little heavy handed if
    all we need is a straightforward format for displaying images, right? Well, we
    could use standard formats, or one which has superior quality while maintaining
    smaller sizes. I''m talking about the lesser-known WebP format from Google—let''s
    dig in and find out more about this format, and why it deserves more attention.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们改变一下方向：如果我们只需要一个简单的图像显示格式，使用 SVG 图像可能会有些过于复杂，对吧？嗯，我们可以使用标准格式，或者一个在保持较小尺寸的同时具有优越质量的格式。我指的是谷歌不太为人所知的
    WebP 格式——让我们深入了解这个格式，并找出为什么它值得更多的关注。
- en: Adding support for WebP images
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加对 WebP 图像的支持
- en: Manipulating SVG images is an acquired art, and in some instances, it will clearly
    be overkill for what we need to achieve.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 操作 SVG 图像是一门需要掌握的技艺，在某些情况下，它可能对我们需要达成的目标来说过于复杂。
- en: Instead, for those occasions where we need the detail in our images, we might
    normally use the JPEG format, or potentially PNG as an alternative. There's nothing
    wrong with either, but, it's old hat, and I do like to push the boundaries of
    what is possible! In addition, the JPEG image format is lossy and does not support
    alpha channels; PNG images are lossless, but suffer from larger file sizes for
    more complex images. If all we did was simply insert images onto a page, then
    PostCSS wouldn't be helpful here; instead, how about considering a different format
    altogether?
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，对于那些需要图像细节的情况，我们通常可能会使用 JPEG 格式，或者可能作为替代的 PNG。这两种格式都没有问题，但它们已经过时了，我喜欢推动可能性的边界！此外，JPEG
    图像格式是有损的，不支持 alpha 通道；PNG 图像是无损的，但对于更复杂的图像来说，文件大小会更大。如果我们只是简单地在一个页面上插入图像，那么 PostCSS
    在这里可能没有帮助；相反，我们为什么不考虑一个完全不同的格式呢？
- en: Enter Google's **WebP**. You'd be forgiven for thinking "Web…what?", as it isn't
    a common format! Part of this can be attributed to the lack of take-up; the only
    browsers to support it natively are Chrome, Android, and Opera. That doesn't mean
    to say it should be discounted. The format can offer some significant space savings
    over standard image formats such as JPEG or PNG, while maintaining superior quality.
    We can even get PostCSS to do most of the work for us, to boot! Let's explore
    the nuts and bolts of this in more detail, with a simple demo.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 进入谷歌的 **WebP**。你可能会想“Web…什么？”因为它不是一个常见的格式！这部分的缺失可以归因于缺乏采用；唯一原生支持它的浏览器是 Chrome、Android
    和 Opera。但这并不意味着我们应该将其排除在外。这种格式可以在保持优越质量的同时，比标准图像格式如 JPEG 或 PNG 节省更多的空间。我们甚至可以让
    PostCSS 为我们完成大部分工作！让我们更详细地探讨这一点，通过一个简单的示例。
- en: Switching WebP images in and out
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 切换 WebP 图像的进与出
- en: Image switching is nothing new, we covered one aspect back in [Chapter 4](ch04.html
    "Chapter 4. Building Media Queries"), *Building Media Queries*, when we used PostCSS
    to switch-in hi-res images when supported in the browser.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 图像切换并不是什么新鲜事，我们在[第4章](ch04.html "第4章。构建媒体查询")中讨论了其中一个方面，即使用PostCSS在浏览器支持时切换高分辨率图像。
- en: 'We can use a similar technique, but this time with image formats, Google''s
    WebP format was designed as a replacement for the myriad of other image formats
    available for the web. In an ideal world, we would use the new `<picture>` tag
    to take care of switching images automatically:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用类似的技术，但这次是针对图像格式，Google的WebP格式被设计为替代网络上可用的众多其他图像格式。在一个理想的世界里，我们会使用新的`<picture>`标签来自动切换图像：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: It's not supported in all browsers, so instead, we can use a mix of PostCSS
    and Modernizr to apply the same effect. The plugin we need for this task is the
    `webpcss` plugin (available from [https://github.com/lexich/webpcss](https://github.com/lexich/webpcss))—we
    will need to run `npm install gulp-webp --save-dev` in a Node.js command prompt
    session to install the plugin. Let's dive in and take a look at it in more detail.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 这在所有浏览器中都不受支持，因此，我们可以使用PostCSS和Modernizr的混合来应用相同的效果。我们需要用于此任务的插件是`webpcss`插件（可在[https://github.com/lexich/webpcss](https://github.com/lexich/webpcss)获取）——我们需要在Node.js命令提示符会话中运行`npm
    install gulp-webp --save-dev`来安装插件。让我们深入探讨并更详细地查看它。
- en: Tip
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: For best results, I would recommend using Chrome throughout these two demos,
    support can be added for Windows and other browsers, by visiting [https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/).
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 为了获得最佳效果，我建议在整个这两个演示过程中使用Chrome，通过访问[https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/)可以为Windows和其他浏览器添加支持。
- en: Viewing the differences in file sizes
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看文件大小差异
- en: 'Before we get stuck into using PostCSS, let''s take a moment to perform a quick
    test. The files for this tutorial are in the `Tutorial 23` folder:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始使用PostCSS之前，让我们花一点时间进行快速测试。本教程的文件位于`Tutorial 23`文件夹中：
- en: In the code download that accompanies this book, go ahead and extract a copy
    of `landscape – original version.jpg`, and rename it as `landscape.jpg`. The size
    should be around 11.5 MB in size.
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在本书附带的代码下载中，请提取`landscape – original version.jpg`的副本，并将其重命名为`landscape.jpg`。其大小应约为11.5
    MB。
- en: Save the image to the root of our project area—we also need a copy of `cwebp.exe`,
    so go ahead and extract that to our project area as well.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将图像保存到我们的项目区域根目录——我们还需要`cwebp.exe`的副本，所以请将其也提取到我们的项目区域。
- en: Fire up a command prompt session, change the working folder to our project area,
    enter `gulp`, and then press *Enter*.
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动一个命令提示符会话，将工作文件夹更改为我们的项目区域，输入`gulp`，然后按*Enter*。
- en: If all is well, we should see the results of our conversion, and the new WebP-format
    image appear in our project area:![Viewing the differences in file sizes](img/BO5194_05_07.jpg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该看到我们转换的结果，新的WebP格式图像将出现在我们的项目区域中：![查看文件大小差异](img/BO5194_05_07.jpg)
- en: Try performing the same process with a PNG format image; here are the results
    of a similar test I performed, with a PNG version of our landscape image:![Viewing
    the differences in file sizes](img/BO5194_05_08.jpg)
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试使用PNG格式图像执行相同的操作；以下是我进行的一个类似测试的结果，使用的是我们风景图像的PNG版本：![查看文件大小差异](img/BO5194_05_08.jpg)
- en: In both cases, the image sizes reduced significantly, the JPEG version dropped
    from around 12.5 MB to just over 7 MB; the PNG format shrunk from an enormous
    25 MB to around the same size!
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，图像大小都显著减小，JPEG版本从大约12.5 MB降至略超过7 MB；PNG格式从庞大的25 MB缩小到大约相同的大小！
- en: Note
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: To learn more about using the WebP format, take a look at the documentation
    on the Google Developers site at [https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/).
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于使用WebP格式的信息，请查看Google开发者网站上的文档[https://developers.google.com/speed/webp/](https://developers.google.com/speed/webp/)。
- en: 'Okay, time for another demo! Let''s now make use of PostCSS to create our styles
    for both standard JPEG format, and WebP equivalents:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，现在是时候进行另一个演示了！让我们现在使用PostCSS来创建标准JPEG格式和WebP等价物的样式：
- en: '![Viewing the differences in file sizes](img/BO5194_05_09.jpg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![查看文件大小差异](img/BO5194_05_09.jpg)'
- en: 'For this demo, we''ll use the `gulp-webpcss` plugin, available from [https://github.com/lexich/webpcss](https://github.com/lexich/webpcss):'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我们将使用来自[https://github.com/lexich/webpcss](https://github.com/lexich/webpcss)的`gulp-webpcss`插件：
- en: Go ahead and download a copy of the `Tuturial23` folder from the code download
    that accompanies this book, save this at the root of our project area.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请从本书附带的代码下载中下载`Tuturial23`文件夹的副本，将其保存到我们项目区域的根目录。
- en: Next, go ahead and remove any copies of `gulpfile.js` and `package.json` from
    the root of our project area; we need to replace them with copies from the `Tutorial23`
    folder.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请从我们项目区域的根目录中删除任何`gulpfile.js`和`package.json`的副本；我们需要用`Tutorial23`文件夹中的副本来替换它们。
- en: 'With these files in place, we still need to install the plugins, in a Node.js
    command prompt window, change the working folder to our project, then run these
    commands, pressing *Enter* after each:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些文件就位后，我们仍然需要安装插件，在Node.js命令提示符窗口中，将工作文件夹更改为我们的项目，然后运行以下命令，每条命令后按*Enter*键：
- en: '[PRE19]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Note the order of the parameters in these commands, if they are written in a
    different order, they will not install.
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意这些命令中参数的顺序，如果顺序不同，它们将无法安装。
- en: Copy the `style – pre-compile.css` file from the `Tutorial23` folder to the
    `src` folder at the root of our project area, then rename it as `style.css`.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Tutorial23`文件夹中的`style – pre-compile.css`文件复制到我们项目区域根目录下的`src`文件夹中，然后将其重命名为`style.css`。
- en: Fire up a Node.js command prompt, change the working folder to our project area,
    then enter `gulp` at the prompt and press *Enter*.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Node.js命令提示符，将工作文件夹更改为我们的项目区域，然后在提示符中输入`gulp`并按*Enter*键。
- en: If all is well, we should see the code shown in this screenshot when viewing
    the contents of the compiled file; the converted image will also appear in the
    `img` folder:![Viewing the differences in file sizes](img/BO5194_05_10.jpg)
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，在查看编译文件的内容时，我们应该看到这个截图所示的代码；转换后的图像也将出现在`img`文件夹中：![查看文件大小差异](img/BO5194_05_10.jpg)
- en: Copy the contents of the `img` folder into the `img` folder within the `Tutorial23`
    folder.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`img`文件夹的内容复制到`Tutorial23`文件夹内的`img`文件夹中。
- en: Copy the `style.css` file from the `dest` folder into the `css` folder within
    the `Tutorial23` folder.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`dest`文件夹中的`style.css`文件复制到`Tutorial23`文件夹内的`css`文件夹中。
- en: Go ahead and run `index.html` in a browser, if all is well, we should see something
    akin to the screenshot at the start of this exercise.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在浏览器中运行`index.html`，如果一切顺利，我们应该看到与这个练习开始时的截图类似的内容。
- en: 'If we run the same `index.html` in Google Chrome or Firefox, at first we should
    not see any difference—we''ll only see the difference when viewing the compiled
    source within the Developer Toolbar in Chrome:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Google Chrome或Firefox中运行相同的`index.html`，一开始我们不应该看到任何差异——我们只有在Chrome的开发者工具栏中查看编译的源代码时才会看到差异：
- en: '![Viewing the differences in file sizes](img/BO5194_05_11.jpg)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![查看文件大小差异](img/BO5194_05_11.jpg)'
- en: 'The real benefit, though, is in the `img` folder within our project area, the
    original JPEG image we use is 222 KB; however, the WebP is a fraction of this
    size: it weighs in at just 82 KB. See what I mean about the saving in space?'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的好处在于我们项目区域的`img`文件夹中，我们使用的原始JPEG图像大小为222 KB；然而，WebP的大小只是这个大小的几分之一：它只有82 KB。我说的节省空间的意思是什么？
- en: 'Okay, onwards we go: time to focus on another area of site building, which
    is manipulating colors. Colors play a key role within any site, as they make up
    a part of the message to the end user; let''s dive in and take a look at some
    of the options available when using PostCSS.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，继续前进：现在是时候专注于网站建设的另一个领域了，那就是操作颜色。颜色在任何一个网站上都扮演着关键角色，因为它们构成了对最终用户信息的一部分；让我们深入探讨一下使用PostCSS时可用的一些选项。
- en: Manipulating colors and color palettes
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作颜色和颜色调板
- en: A challenge that any developer or designer will face is which color should be
    used on a site—a nice shade of red, or how about sea blue, for example? It doesn't
    matter whether they are responsible for choosing the shade to use, or if they
    have to pick the right RGB or HEX color to use.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 任何开发人员或设计师都会面临的一个挑战是在网站上使用哪种颜色——比如一个漂亮的红色调，或者海蓝色如何？无论他们是否负责选择要使用的色调，或者他们是否需要选择正确的RGB或HEX颜色来使用，都无关紧要。
- en: 'Irrespective of where responsibilities lie, we still have to choose a color,
    and there is a good chance we won''t be choosing one that comes from the default
    256-color palette, but one that is likely to be a lighter or darker shade, or
    perhaps a mix of two colors:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 无论责任在哪里，我们仍然需要选择一种颜色，而且有很大可能性我们不会选择默认的256色调板中的颜色，而是选择一种更浅或更深的色调，或者可能是两种颜色的混合：
- en: '![Manipulating colors and color palettes](img/BO5194_05_12.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![操作颜色和颜色调板](img/BO5194_05_12.jpg)'
- en: Anyone used to working with SASS will already be aware of functions such as
    `lighten()`, `darken()` or `saturate()`—the great thing about PostCSS is that
    we can replicate similar functionality for those who want to move away from the
    dependency of SASS.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 任何习惯于使用SASS的人都已经熟悉`lighten()`、`darken()`或`saturate()`等函数——PostCSS的伟大之处在于我们可以为那些想要摆脱SASS依赖的人复制类似的功能。
- en: To see how easy it is to use, we're going to combine the power of two plugins
    for PostCSS—`postcss-color-palette` (available at [https://github.com/zaim/postcss-color-palette](https://github.com/zaim/postcss-color-palette)),
    and `postcss-color-mix` (from [https://github.com/iamstarkov/postcss-color-mix](https://github.com/iamstarkov/postcss-color-mix)).
    The former allows us to choose one or more colors from any of three palettes,
    while `postcss-color-mix` will mix specific colors to make a new color. There
    are reasons for using these plugins, which will become clear; for now, let's get
    stuck in and watch these plugins in action.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 为了看到使用起来有多简单，我们将结合两个PostCSS插件的强大功能——`postcss-color-palette`（可在[https://github.com/zaim/postcss-color-palette](https://github.com/zaim/postcss-color-palette)获取），以及`postcss-color-mix`（来自[https://github.com/iamstarkov/postcss-color-mix](https://github.com/iamstarkov/postcss-color-mix)）。前者允许我们从任意三个调色板中选择一个或多个颜色，而`postcss-color-mix`将混合特定颜色以生成新的颜色。使用这些插件的原因将会变得清晰；现在，让我们深入其中，看看这些插件的实际效果。
- en: Displaying and mixing colors using palettes
  id: totrans-190
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用调色板显示和混合颜色
- en: In this exercise, we're going to take a look at mixing colors; `postcss-color-palette`
    allows us to choose multiple colors by name (and not by number!), then converts
    them to HEX equivalent values. We can then either create gradient-type effects,
    or simply mix the colors together (using `postcss-color-mix`) to produce a new
    color.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，我们将研究颜色混合；`postcss-color-palette`允许我们通过名称选择多个颜色（而不是通过数字！），然后将其转换为HEX等效值。然后我们可以创建渐变效果，或者简单地混合颜色（使用`postcss-color-mix`）以生成新的颜色。
- en: 'Let''s make a start:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧：
- en: We'll start by extracting a copy of the `Tutorial24` folder from the code download
    that accompanies this book; save the folder to the root of our project area.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从本书附带的代码下载中提取`Tutorial24`文件夹的副本；将文件夹保存到我们项目区域的根目录。
- en: From the `Tutorial24` folder, copy the `package.json` and `gulpfile.js` files
    to the root of our project area.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`Tutorial24`文件夹中，将`package.json`和`gulpfile.js`文件复制到我们项目区域的根目录。
- en: We also need our stylesheet, for this, go ahead and copy the `style – pre-compile.css`
    file from the same folder and drop this into the `src` folder in our project area.
    Rename it as `style.css`.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要我们的样式表，为此，请从同一文件夹中复制`style – pre-compile.css`文件，并将其放入我们项目区域的`src`文件夹中。将其重命名为`style.css`。
- en: At this point we need to install the plugin, for this, so go ahead and fire
    up a Node.js command prompt session, then change the working folder to our project
    area.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们需要安装插件，为此，请启动一个Node.js命令提示符会话，然后更改工作文件夹到我们的项目区域。
- en: At the prompt, enter the command shown in this screenshot, then press *Enter*,
    if all is well, we should see confirmation that the plugin has installed correctly:![Displaying
    and mixing colors using palettes](img/BO5194_05_13.jpg)
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入此截图所示的命令，然后按*Enter*，如果一切顺利，我们应该会看到确认插件已正确安装的消息：![使用调色板显示和混合颜色](img/BO5194_05_13.jpg)
- en: Repeat step 5, but this time, run the command shown in this screenshot:![Displaying
    and mixing colors using palettes](img/BO5194_05_14.jpg)
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重复步骤5，但这次，运行此截图所示的命令：![使用调色板显示和混合颜色](img/BO5194_05_14.jpg)
- en: At the prompt, enter `gulp`, then press *Enter*—PostCSS will go away and compile
    the style sheet, and drop the compiled results into the `dest` folder.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入`gulp`，然后按*Enter*——PostCSS将退出并编译样式表，并将编译结果放入`dest`文件夹。
- en: Copy the contents of the `dest` folder (which will be the uncompressed and minified
    style sheets, along with a source map file) to the `css` folder within the `Tutorial24`
    folder.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`dest`文件夹的内容（将是不压缩和最小化的样式表，以及一个源映射文件）复制到`Tutorial24`文件夹内的`css`文件夹中。
- en: Try previewing `index.html` at the root of our `Tutorial24` folder; if all is
    well, we should see our mixed colors, as shown in this screenshot:![Displaying
    and mixing colors using palettes](img/BO5194_05_15.jpg)
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试预览`Tutorial24`文件夹根目录下的`index.html`；如果一切顺利，我们应该会看到我们混合的颜色，如图所示：![使用调色板显示和混合颜色](img/BO5194_05_15.jpg)
- en: 'Okay, the colors I''ve chosen clearly aren''t going to win any style awards
    any time soon, but they help serve a purpose: it is very easy to use proper color
    names, if preferred, while still allowing PostCSS to compile them into valid HEX
    values. That aside, let''s take a moment to consider the code we''ve used in this
    demo—it does raise a few key points, which we should cover, when using these plugins.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我选择的颜色显然不会很快赢得任何风格奖项，但它们有助于实现一个目的：如果愿意，使用正确的颜色名称非常容易，同时仍然允许 PostCSS 将它们编译成有效的十六进制值。抛开这一点，让我们花点时间考虑一下我们在演示中使用的代码——它确实提出了几个关键点，我们应该在使用这些插件时讨论。
- en: Dissecting our demo in more detail
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更详细地剖析我们的演示
- en: 'The demo we''ve created follows similar principles to most other demos we''ve
    built so far; we begin with declaring variables to store instances of our plugins,
    thus:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建的演示遵循了我们迄今为止构建的大多数其他演示的类似原则；我们首先声明变量来存储插件的实例，因此：
- en: '[PRE20]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The magic then happens in this task, within our `gulp` file:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 魔法就在这个任务中发生，在我们的 `gulp` 文件中：
- en: '[PRE21]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Notice that we've specified a palette to use, the `mrmrs` option is the default,
    but we can equally use `material` or `flatui` as alternatives. All three reference
    the `webcolors` plugin from [https://github.com/zaim/webcolors/](https://github.com/zaim/webcolors/);
    this package could be expanded to include other palettes if desired.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们已经指定了一个要使用的颜色板，`mrmrs` 选项是默认的，但我们同样可以使用 `material` 或 `flatui` 作为替代。所有三个都引用了来自
    [https://github.com/zaim/webcolors/](https://github.com/zaim/webcolors/) 的 `webcolors`
    插件；如果需要，这个包可以扩展以包含其他颜色板。
- en: 'With the links to our two plugins in place, and the task set up, we can then
    begin to specify rules within our style sheet, which will use the plugins. We''ve
    created three, and all three use the `postcss-color-palette` to determine what
    the HEX value should be for each color; the third and final mixes the two colors
    together once HEX values have been assigned:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在放置好我们两个插件的链接并设置好任务后，我们就可以开始在样式表中指定规则，这些规则将使用插件。我们创建了三个，并且所有三个都使用 `postcss-color-palette`
    来确定每个颜色的十六进制值；第三个和最后一个在分配了十六进制值后将两种颜色混合在一起：
- en: '[PRE22]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Getting the mix of the color right for the third rule isn't easy, the key to
    a successful mix is to avoid using colors that are in the same spectrum; the closer
    they are, the less impact the mix will have!
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第三条规则正确地混合颜色并不容易，成功混合的关键是避免使用同一光谱中的颜色；它们越接近，混合的影响就越小！
- en: If you want a quick way to gauge how well colors have mixed, then try [http://jackiebalzer.com/color](http://jackiebalzer.com/color)—this
    demo has a `mix()` option in it, which will compile them in the browser and avoid
    the need to run the compilation process manually.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想快速评估颜色混合的效果，那么试试 [http://jackiebalzer.com/color](http://jackiebalzer.com/color)——这个演示有一个
    `mix()` 选项，它将在浏览器中编译它们，避免需要手动运行编译过程。
- en: 'We''ve covered some of the plugins that are likely to be more popular; there
    are more available via the `PostCSS.parts` directory, which may be of interest:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 我们介绍了一些可能更受欢迎的插件；更多插件可以通过 `PostCSS.parts` 目录获得，这可能很有趣：
- en: '`colorguard`: Helps maintain a consistent color palette'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`colorguard`: 帮助保持颜色板的一致性'
- en: '`postcss-ase-colors`: Replaces color names with values read from an ASE palette
    file; this is perfect if you happen to be a user of Adobe PhotoShop, InDesign,
    or Illustrator'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss-ase-colors`: 将颜色名称替换为从 ASE 颜色板文件中读取的值；如果你恰好是 Adobe PhotoShop、InDesign
    或 Illustrator 的用户，这将是完美的。'
- en: '`postcss-shades-of-gray`: Helps keep grayscale colors consistent to a gray
    palette'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss-shades-of-gray`: 帮助保持灰度颜色与灰度颜色板的一致性'
- en: '`postcss-color-pantone`: Transforms Pantone color to RGB.'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`postcss-color-pantone`: 将潘通颜色转换为 RGB。'
- en: 'In the meantime, let''s move on: we''ve explored using palettes to select our
    colors, before mixing them to create new ones. This is just scratching the surface
    of what is possible; how about creating different *shades* of colors, using functions
    such as `darken()`, `tint()` or `lightness()`? Such functions already exist in
    most preprocessors, such as SASS; let''s explore how we can achieve the same results
    using PostCSS plugins.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，让我们继续前进：我们探索了使用颜色板来选择颜色，然后再混合它们以创建新的颜色。这仅仅是触及了可能性的表面；我们能否使用诸如 `darken()`、`tint()`
    或 `lightness()` 等函数来创建不同 *色调* 的颜色？这些函数在大多数预处理器中已经存在，例如 SASS；让我们探索如何使用 PostCSS
    插件实现相同的结果。
- en: Creating color functions with PostCSS
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 PostCSS 创建颜色函数
- en: In our journey through manipulating colors using PostCSS, we've so far seen
    how to define colors using palettes—this may work in some instances, but there
    will be occasions when we need to specify a color that doesn't feature in a palette.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们通过 PostCSS 操作颜色的旅程中，我们迄今为止已经看到了如何使用调色板来定义颜色——这可能在某些情况下有效，但有时我们需要指定不在调色板中的颜色。
- en: We can always try to specify the value manually, but what happens if we need
    to alter it? Do we try to find every instance of it, and risk the possibility
    of missing an instance?
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以尝试手动指定值，但如果我们需要更改它怎么办？我们是否尝试找到它的每一个实例，并冒着错过一个实例的风险？
- en: The answer is no. Instead, we can use the `postcss-color-function` plugin to
    create our colors dynamically; we can then assign the resulting value to a variable
    if we find ourselves frequently using this color. We can use this route to produce
    some nice shades of colors, so let's get stuck in and explore using this plugin
    in more detail.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 答案是否定的。相反，我们可以使用 `postcss-color-function` 插件来动态创建我们的颜色；如果我们经常使用这种颜色，我们可以将生成的值分配给一个变量。我们可以使用这种方法来产生一些漂亮的颜色阴影，所以让我们深入探索这个插件。
- en: Adjusting colors using functions
  id: totrans-223
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数调整颜色
- en: 'A useful facility within most CSS preprocessors is the ability to create new
    colors dynamically, we can do this either by adjusting a color channel, or applying
    a filter effect to the color, such as making it darker:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数 CSS 预处理器中的一个有用功能是能够动态地创建新颜色，我们可以通过调整颜色通道或应用颜色滤镜来实现，例如使其变暗：
- en: '![Adjusting colors using functions](img/BO5194_05_16.jpg)'
  id: totrans-225
  prefs: []
  type: TYPE_IMG
  zh: '![使用函数调整颜色](img/BO5194_05_16.jpg)'
- en: The benefit of this is simple, it allows us to reduce the number of base colors
    we assign by default; the remaining colors can be created automatically. If we
    need to change one of our base colors, then any colors created dynamically should
    still work.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的优点很简单，它允许我们减少默认分配的基本颜色数量；剩余的颜色可以自动创建。如果我们需要更改我们的基本颜色之一，那么任何动态创建的颜色仍然可以使用。
- en: Thankfully, we can achieve the same effects within PostCSS, to do this, we need
    to make use of the `postcss-color-function` plugin, available from [https://github.com/postcss/postcss-color-function](https://github.com/postcss/postcss-color-function).
    We'll also be using the `css-color-converter` plugin, to help manage conversion
    between different color formats.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以在 PostCSS 中实现相同的效果，为此，我们需要使用 `postcss-color-function` 插件，该插件可在 [https://github.com/postcss/postcss-color-function](https://github.com/postcss/postcss-color-function)
    获取。我们还将使用 `css-color-converter` 插件，以帮助管理不同颜色格式之间的转换。
- en: 'Let''s explore this in more detail with a simple demo:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个简单的演示来更详细地探讨这个问题：
- en: We start by extracting a copy of the `Tutorial25` folder from within the code
    download that accompanies this book—go ahead and save this to our project area.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先从本书附带的代码下载中提取 `Tutorial25` 文件夹的副本——请将其保存到我们的项目区域。
- en: If the project area already has a `package.json` and/or a `gulpfile.js` present,
    then remove them; replace them with the files from within the `Tutorial25` folder.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果项目区域已经存在 `package.json` 和/或 `gulpfile.js` 文件，那么请删除它们；用 `Tutorial25` 文件夹中的文件替换它们。
- en: Although we have the right configuration files in place, we still need to install
    the plugin—go ahead and fire up a Node.js command prompt session, then change
    the working folder to our project area.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尽管我们已经设置了正确的配置文件，但我们仍然需要安装插件——请启动一个 Node.js 命令提示符会话，然后将工作文件夹更改为我们的项目区域。
- en: 'At the prompt, enter these commands, pressing *Enter* after each:'
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符中输入以下命令，每输入一个命令后按 *Enter* 键：
- en: '[PRE23]'
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: At this point, we can now go ahead and compile our style sheet—look for `styles
    – pre-compile.css` from within the `css – completed version` subfolder, and save
    it to the `src` folder within our project area as `style.css`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 到目前为止，我们现在可以继续编译我们的样式表了——在 `css – completed version` 子文件夹中查找 `styles – pre-compile.css`，并将其保存到项目区域内的
    `src` 文件夹中作为 `style.css`。
- en: Switch to the Node.js command prompt from earlier, then enter `gulp` at the
    prompt and press *Enter*.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从之前的 Node.js 命令提示符切换过来，然后在提示符中输入 `gulp` 并按 *Enter* 键。
- en: If all is well, we should see the by now compiled style sheets appear (both
    uncompressed and minified), along with the source map in the `dest` folder. Copy
    the contents of this folder to the `css` folder within the `Tutorial25` folder.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该会看到现在编译好的样式表出现在 `dest` 文件夹中（包括未压缩和压缩版本），以及源映射文件。将此文件夹的内容复制到 `Tutorial25`
    文件夹内的 `css` 文件夹中。
- en: Try previewing the results within a browser, if the compilation was successful,
    we should see four boxes with different shades of red appear, as shown at the
    start of this exercise. The question is though, we've seen the results appear,
    but how does PostCSS know to create these colors?
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在浏览器中预览结果，如果编译成功，我们应该看到四个不同红色阴影的盒子出现，就像在这个练习的开始部分所示。问题是，我们已经看到了结果的出现，但 PostCSS
    是如何知道创建这些颜色的？
- en: Dissecting our demo
  id: totrans-238
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析我们的演示
- en: 'It''s a good question, the conversion process is very simple; the trick to
    it, though, lies not within compiling, but working out how to achieve the color!
    Odd as it may seem, choosing the color isn''t as easy as it looks; let me explain
    more:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个很好的问题，转换过程非常简单；但其中的技巧不在于编译，而在于如何实现颜色！虽然听起来很奇怪，但选择颜色并不像看起来那么简单；让我详细解释一下：
- en: 'The compilation process is, like other PostCSS plugins, very easy to configure—we
    begin of course with creating a variable that defines the `color-function` plugin:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 编译过程，就像其他 PostCSS 插件一样，非常容易配置——我们当然是从创建一个定义 `color-function` 插件的变量开始的：
- en: '[PRE24]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Next up, we add a reference to our principal gulp task, here we''ve used both
    `autoprefixer` and the `color-function` plugin together, but the former isn''t
    strictly needed, as we''re not adding any vendor prefixes:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了对我们的主要 gulp 任务的引用，在这里我们同时使用了 `autoprefixer` 和 `color-function` 插件，但前者并不是严格必要的，因为我们没有添加任何供应商前缀：
- en: '[PRE25]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The real magic, though, is in the colors we assign within our style sheet—our
    first box is a control, with a standard red color:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 真正的魔法在于我们在样式表中指定的颜色——我们的第一个盒子是一个控制，具有标准的红色：
- en: '[PRE26]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Next up, we''re adding a `tint` of `60%` to `box1`, which has the effect of
    turning it a light pink:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `box1` 上添加 `60%` 的色调，这使得它变成了浅粉色：
- en: '[PRE27]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`Box2` goes the other way, even though we''ve used a lightness filter (where
    you might expect a similar result as `box1`), the negative number makes it a brown-red
    color:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '`Box2` 则相反，尽管我们使用了亮度过滤器（你可能期望与 `box1` 类似的结果），但负数使其变成了棕色-红色：'
- en: '[PRE28]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The final box, `box3`, continues the brown theme from `box2`, but makes it
    lighter. Note though, that in the comment, this shade is what would be produced
    if we had applied a sepia tone:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个盒子 `box3` 继续从 `box2` 的棕色主题，但使其更浅。注意，在注释中，这种色调是我们应用棕褐色色调时会产生的结果：
- en: '[PRE29]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The question is, how would we know that this is indeed a sepia filter being
    applied?
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 问题在于，我们如何知道这确实是一个正在应用的棕褐色过滤器？
- en: At face value, it looks like we've selected red, then altered each channel by
    a specific amount to get the final result.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 从表面上看，我们似乎选择了红色，然后通过特定的量改变每个通道以获得最终结果。
- en: A drawback of using this plugin is that it doesn't have functions to support
    all of the equivalent CSS3 filters available today; it does mean we have to be
    resourceful, and calculate what the color should be directly. We will be able
    to change that in the next demo—there will be occasions when we need to create
    our own custom filters; a good example is sepia. It does mean more work upfront,
    but it allows us to then call a `sepia()` function by name, rather than approximate
    the final result.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此插件的一个缺点是它没有函数来支持今天可用的所有等效 CSS3 过滤器；这意味着我们必须机智，直接计算颜色应该是什么。我们将在下一个演示中能够改变这一点——会有时候我们需要创建自己的自定义过滤器；一个很好的例子是棕褐色。这确实意味着前期需要更多的工作，但它允许我们通过名称调用
    `sepia()` 函数，而不是近似最终结果。
- en: If you struggle to find what a color should be once a filter is applied, take
    a look at [http://jackiebalzer.com/color](http://jackiebalzer.com/color); this
    is a great site that allows us to choose a color and see what the results are
    when filters are applied. It is written for SASS, but the end result will be identical
    for PostCSS. A site such as ColorHexa.com ([http://www.colorhexa.com](http://www.colorhexa.com))
    is a good help too, we can use it to verify what color values should be when a
    filter has been applied.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你发现很难确定应用过滤器后颜色应该是什么，请查看 [http://jackiebalzer.com/color](http://jackiebalzer.com/color)；这是一个很棒的网站，允许我们选择一种颜色并查看应用过滤器后的结果。它是为
    SASS 编写的，但最终结果对于 PostCSS 将是相同的。ColorHexa.com ([http://www.colorhexa.com](http://www.colorhexa.com))
    这样的网站也很有帮助，我们可以用它来验证应用过滤器后应该是什么颜色值。
- en: On we go. We discovered during our exercise that the `postcss-color-function`
    plugin doesn't cover all of the CSS3 filters that we can use in CSS; for the `sepia`
    example, we had to assign a calculated color value, rather than applying a filter
    effect. Let's fix that now. With a bit of upfront rework to our demo, we can create
    our own custom functions. It means that if, for example, we want a sepia effect,
    then we can call `sepia()`, rather than calculate what the final color should
    be!
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续前进。在我们的练习中，我们发现 `postcss-color-function` 插件并没有涵盖我们可以在 CSS 中使用的所有 CSS3 过滤器；对于
    `sepia` 示例，我们必须分配一个计算后的颜色值，而不是应用过滤器效果。现在让我们解决这个问题。通过一点对演示的前期修改，我们可以创建自己的自定义函数。这意味着，例如，如果我们想要棕褐色效果，我们可以调用
    `sepia()`，而不是计算最终的颜色应该是什么！
- en: Creating colors with PostCSS filters
  id: totrans-257
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 PostCSS 过滤器创建颜色
- en: In our previous demo, we took a look at programmatically changing colors—this
    is a function that has been present in most CSS processors (such as SASS or Less)
    for some time.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前的演示中，我们查看了一种通过编程方式更改颜色的方法——这是一个在大多数 CSS 处理器（如 SASS 或 Less）中已经存在一段时间的功能。
- en: There may be occasions where we require a finer degree of control over changing
    colors, and that simply using existing functions provided by the `postcss-color-function`
    plugin isn't sufficient, or that the desired filter isn't available. If we're
    feeling inclined, we can create our own color functions; for this, we can use
    the `postcss-functions` plugin, available from [https://github.com/andyjansson/postcss-functions](https://github.com/andyjansson/postcss-functions),
    to expose the use of JavaScript functions in our task file.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们可能需要更精细地控制颜色变化，仅仅使用 `postcss-color-function` 插件提供的现有函数是不够的，或者所需的过滤器不可用。如果我们愿意，我们可以创建自己的颜色函数；为此，我们可以使用来自
    [https://github.com/andyjansson/postcss-functions](https://github.com/andyjansson/postcss-functions)
    的 `postcss-functions` 插件，在任务文件中暴露 JavaScript 函数的使用。
- en: It's worth noting, though, that if a CSS3 filter doesn't exist, then most can
    be created using a combination of different calculations (such as the `sepia`
    example from the previous demo). This may technically work okay, but it is easier
    to simply reference a sepia filter by name, rather than work out that `#box3`
    has a sepia effect applied!
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，如果 CSS3 过滤器不存在，那么大多数可以通过不同的计算组合（如上一个演示中的 `sepia` 示例）来创建。技术上这可能可以正常工作，但简单地通过名称引用棕褐色过滤器，而不是计算出
    `#box3` 应用了棕褐色效果，会更容易一些！
- en: 'I feel a demo coming on, so without further ado, here''s a screenshot of what
    we''re going to create:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我感觉一个演示即将到来，所以不再多言，以下是我们要创建的内容的截图：
- en: '![Creating colors with PostCSS filters](img/BO5194_05_17.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![使用 PostCSS 过滤器创建颜色](img/BO5194_05_17.jpg)'
- en: In short, we're using a standard shade of red (`#ff0000`, just to be clear!),
    and calculating various shades using a tint, darken, or sepia filter.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，我们使用标准的红色色调 (`#ff0000`，以便清楚！)，并使用色调、变暗或棕褐色过滤器计算各种色调。
- en: 'Let''s take a look at how to create these colors in more detail:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看如何创建这些颜色：
- en: We'll start by extracting a copy of the `Tutorial26` folder from the code download
    that accompanies this book; save it to the root of our project area.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先从本书附带的代码下载中提取 `Tutorial26` 文件夹的副本；将其保存到我们项目区域的根目录。
- en: Next, go ahead and remove any copies of `gulpfile.js` and `package.json` from
    the root of our project area.
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，请从我们项目区域的根目录中删除任何 `gulpfile.js` 和 `package.json` 的副本。
- en: From the `Tutorial26` folder, copy both `package.json` and `gulpfile.js` to
    the root of our project area.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Tutorial26` 文件夹中，将 `package.json` 和 `gulpfile.js` 复制到我们项目区域的根目录。
- en: 'With these files in place, we still need to install the plugins. In a Node.js
    command prompt window, change the working folder to our project, then enter these
    commands, and press *Enter* after each:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这些文件就位后，我们仍然需要安装插件。在 Node.js 命令提示符窗口中，将工作文件夹更改为我们的项目，然后输入以下命令，并在每个命令后按 *Enter*
    键：
- en: '[PRE30]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: From the `Tutorial26` folder, copy `style – pre-compile.css` to the `src` folder
    in the project area; rename it to `style.css`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `Tutorial26` 文件夹中，将 `style – pre-compile.css` 复制到项目区域的 `src` 文件夹中；将其重命名为 `style.css`。
- en: Revert back to the Node.js command prompt window, then at the prompt, enter
    `gulp` and press *Enter*.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回 Node.js 命令提示符窗口，然后在提示符下输入 `gulp` 并按 *Enter* 键。
- en: If all is well, we should see a source map and two compiled style sheets appear
    in the `dest` folder; copy these to the `css` folder within the `Tutorial26` folder.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，我们应该在 `dest` 文件夹中看到一个源映射和两个编译后的样式表；将这些文件复制到 `Tutorial26` 文件夹内的 `css`
    文件夹中。
- en: Try running the demo in a browser. If all is well, we should see four boxes
    appear, with various shades of red, as shown at the start of this exercise.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 尝试在浏览器中运行演示。如果一切顺利，我们应该看到四个盒子出现，它们有各种深浅的红色调，就像在这个练习的开始部分所展示的那样。
- en: If we take a look at the contents of the `gulp` task file in more detail, it
    will look larger than previous exercises; it might look like we're doing more,
    but in reality, a lot of it we've already seen before, in earlier demos. Let's
    take a look at it in more detail.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们更详细地查看`gulp`任务文件的内容，它看起来会比之前的练习更大；它可能看起来我们做了更多，但实际上，其中很多我们在早期的演示中已经见过。让我们更详细地看看它。
- en: Exploring our demo in more detail
  id: totrans-275
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更详细地探索我们的演示
- en: If we open up our gulp task file, we can see it contains a number of functions,
    along with tasks that we've used in previous demos, such as `lint-styles`. The
    key in this demo is the three color functions, along with the main part of the
    `autoprefixer` task.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开我们的gulp任务文件，我们可以看到它包含了许多函数，以及我们在之前的演示中使用过的任务，例如`lint-styles`。在这个演示中的关键是三个颜色函数，以及`autoprefixer`任务的主要部分。
- en: 'Let''s start with the `color` functions, using `darkenColor` as our example:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从`color`函数开始，以`darkenColor`为例：
- en: '[PRE31]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: We begin by extracting the decimal value, then subtracting it (as `frac`) from
    `1`. This gives us our adjust value, or the value by how much we will darken our
    colors. Next up, we convert the color used (in this case, red) to a valid RGBA
    value, and split it into the RGBA array. We then multiply each array value from
    `rgba` by the darken value, and reform it as a valid color, before converting
    it to a HEX value.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先提取十进制值，然后从`1`中减去它（作为`frac`），这给了我们调整值，或者说是我们将要加深颜色的值。接下来，我们将使用的颜色（在这种情况下，红色）转换为有效的RGBA值，并将其拆分为RGBA数组。然后我们将`rgba`数组中的每个值乘以加深值，并将其重新格式化为有效的颜色，然后再将其转换为HEX值。
- en: 'Once each function has been created, we can then reference it from our gulp
    task, as shown:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了每个函数，我们就可以从我们的gulp任务中引用它，如下所示：
- en: '[PRE32]'
  id: totrans-281
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: All of the functions use a similar process, but the main calculations that use
    the values from the `rgba[]` array, such as adding a tint (`tintColor`), or working
    in a sepia effect (`sepiaColor`), will be different.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些函数都使用类似的过程，但使用`rgba[]`数组中的值进行的主要计算，例如添加色调（`tintColor`），或者应用棕褐色效果（`sepiaColor`），将会不同。
- en: 'The question you may ask though, is where do we get the calculations from?
    Well, there are plenty of sources available on the Internet, such as this link
    on Stack Overflow: [http://stackoverflow.com/questions/6615002/given-an-rgb-value-how-do-i-create-a-tint-or-shade](http://stackoverflow.com/questions/6615002/given-an-rgb-value-how-do-i-create-a-tint-or-shade).
    Another alternative that may be worth a look is on Chris Coyier''s CSS Tricks
    site, at [https://css-tricks.com/snippets/javascript/lighten-darken-color/](https://css-tricks.com/snippets/javascript/lighten-darken-color/).
    In reality though, the best site I''ve seen so far is in the CamanJS library,
    at [http://www.camanjs.com](http://www.camanjs.com); the examples in this demo
    are based on the functions available from this library at [http://camanjs.com/docs/filters.html](http://camanjs.com/docs/filters.html).'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会问的问题，不过，我们是从哪里得到这些计算的？嗯，互联网上有许多可用的资源，例如这个Stack Overflow上的链接：[http://stackoverflow.com/questions/6615002/given-an-rgb-value-how-do-i-create-a-tint-or-shade](http://stackoverflow.com/questions/6615002/given-an-rgb-value-how-do-i-create-a-tint-or-shade)。另一个可能值得一看的替代方案是Chris
    Coyier的CSS Tricks网站，在[https://css-tricks.com/snippets/javascript/lighten-darken-color/](https://css-tricks.com/snippets/javascript/lighten-darken-color/)。然而，实际上，我迄今为止看到最好的网站是在CamanJS库中，在[http://www.camanjs.com](http://www.camanjs.com)；这个演示中的示例是基于这个库中可用的函数，在[http://camanjs.com/docs/filters.html](http://camanjs.com/docs/filters.html)。
- en: Tip
  id: totrans-284
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: A useful little tip, if you want to check what color values should be displayed
    for a particular tint or shade, is to check out [http://highintegritydesign.com/tools/tinter-shader/](http://highintegritydesign.com/tools/tinter-shader/).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要检查特定色调或阴影应该显示的颜色值，一个有用的提示是查看[http://highintegritydesign.com/tools/tinter-shader/](http://highintegritydesign.com/tools/tinter-shader/)。
- en: Comparing with CSS3 filters
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与CSS3过滤器比较
- en: A key question we must ask at this stage is "why should we go through the effort
    of creating individual functions, when we could easily use a library such as CamanJS?"
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段我们必须问的一个关键问题是：“为什么我们要费劲去创建单独的函数，当我们可以轻松地使用像CamanJS这样的库呢？”
- en: 'Well, there are some key reasons for taking the route that we used in our demo:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 嗯，我们选择在演示中使用的那种方法有一些关键原因：
- en: CamanJS is a great library, and produces some wonderful effects, but it is an
    external dependency; we run the risk that development may be discontinued in the
    future, which might have an impact on our code.
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CamanJS是一个很棒的库，可以产生一些奇妙的效果，但它是一个外部依赖；我们面临的风险是未来可能会停止开发，这可能会影响我们的代码。
- en: Using PostCSS means that we can remove the dependency on external libraries,
    we are in control over which effects should be included, and which are surplus
    to requirements. If we use a library such as `CamanJS`, then we may be forced
    to include lots of extra baggage that unnecessarily inflates our code.
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用PostCSS意味着我们可以移除对外部库的依赖，我们可以控制哪些效果应该包含，哪些是多余的。如果我们使用像`CamanJS`这样的库，我们可能被迫包含大量不必要的额外代码。
- en: Not every browser will support standard CSS3 filters—using PostCSS gives us
    an opportunity to design our own filters that can apply similar effects.
  id: totrans-291
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 并非每个浏览器都支持标准的CSS3过滤器——使用PostCSS给我们提供了一个机会来设计我们自己的过滤器，从而应用类似的效果。
- en: We can always use existing processors, such as SASS, but again we have a dependency
    on an external library; using PostCSS means we can still apply the same principles,
    but without the dependency.
  id: totrans-292
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们始终可以使用现有的处理器，例如SASS，但同样，我们依赖于外部库；使用PostCSS意味着我们仍然可以应用相同的原则，但无需依赖。
- en: The key here, though, is that filter support in browsers is very good, save
    for IE—we should always consider using CSS3 filters first, but can look to create
    an IE-specific style sheet that allows us to use our own versions from within
    PostCSS.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，关键在于浏览器对过滤器的支持非常好，除了IE——我们应该始终考虑首先使用CSS3过滤器，但可以创建一个针对IE的特定样式表，允许我们在PostCSS中使用自己的版本。
- en: Adding Instagram effects to your images
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为你的图片添加Instagram效果
- en: Creating filters with PostCSS shouldn't be all boring though, we can absolutely
    have some fun with filters! A quick and easy way to apply some additional style
    to an image is through the use of Instagram filters—thankfully there is a pre-built
    plugin we can use for this purpose.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 使用PostCSS创建过滤器不应该总是无聊的，我们可以绝对地通过过滤器玩得开心！通过使用Instagram过滤器为图片添加一些额外样式是一个快速简单的方法——幸运的是，有一个预构建的插件可以用于此目的。
- en: 'Enter the `Instagram` plugin, available from [https://github.com/azat-io/postcss-instagram](https://github.com/azat-io/postcss-instagram).
    Let''s get stuck in and create a simple demo:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 进入可从[https://github.com/azat-io/postcss-instagram](https://github.com/azat-io/postcss-instagram)获取的`Instagram`插件。让我们开始并创建一个简单的演示：
- en: We'll begin, as always, by extracting a copy of the `Tutorial27` folder from
    the code download that accompanies this book—save this to the project area.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将像往常一样，从本书附带的代码下载中提取`Tutorial27`文件夹的副本——将其保存到项目区域。
- en: Next, extract copies of `gulpfile.js` and `package.json`, replace any that are
    stored at the root of our project area, with these new copies.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，提取`gulpfile.js`和`package.json`的副本，用这些新副本替换存储在我们项目区域根目录中的任何副本。
- en: We now need to install the `postcss-instagram` plugin, so go ahead and fire
    up a Node.js command prompt session, then change the working folder to our project
    area.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要安装`postcss-instagram`插件，所以请启动一个Node.js命令提示符会话，然后更改工作文件夹到我们的项目区域。
- en: 'At the prompt, go ahead and enter this command, then press *Enter*:'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在提示符下，输入以下命令，然后按*Enter*键：
- en: '[PRE33]'
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Copy the `style – pre-compile.css` file to the `src` folder at the root of our
    project area, then rename it as `style.css`.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`style – pre-compile.css`文件复制到项目区域根目录下的`src`文件夹中，然后将其重命名为`style.css`。
- en: Once the plugin is installed, enter `gulp` at the prompt, then press *Enter*.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦插件安装完成，在提示符下输入`gulp`，然后按*Enter*键。
- en: PostCSS will go away and compile our code, if all is well, we should see the
    usual files appear in the `dest` folder; copy these to the `css` folder within
    the `Tutorial27` folder.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一切顺利，PostCSS将编译我们的代码，我们应该在`dest`文件夹中看到通常的文件；将这些文件复制到`Tutorial27`文件夹内的`css`文件夹中。
- en: 'At this point, if we try to preview the results in a browser, we should see
    something akin to this screenshot:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，如果我们尝试在浏览器中预览结果，我们应该看到类似于这个屏幕截图的内容：
- en: '![Adding Instagram effects to your images](img/BO5194_05_18.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![为你的图片添加Instagram效果](img/BO5194_05_18.jpg)'
- en: 'The key to this is in the main CSS style sheet, we can apply the required filter
    using nothing more than this within the rule:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的关键在于主CSS样式表中，我们可以在规则中使用这个来应用所需的过滤器：
- en: '![Adding Instagram effects to your images](img/BO5194_05_19.jpg)'
  id: totrans-308
  prefs: []
  type: TYPE_IMG
  zh: '![为你的图片添加Instagram效果](img/BO5194_05_19.jpg)'
- en: This applies the `1977` filter (one of the filters available with the plugin).
    If we take a look at the compiled code, we can see that the plugin has added some
    additional rules; one to take care of creating the filter, and two to take care
    of positioning the filter on top of the image.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 这将应用`1977`过滤效果（插件提供的过滤效果之一）。如果我们查看编译后的代码，我们可以看到插件添加了一些额外的规则；一个用于创建过滤效果，两个用于在图像上定位过滤效果。
- en: 'If we take a look at the compiled code, we can see the changes made by the
    plugin:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看编译后的代码，我们可以看到插件所做的更改：
- en: '![Adding Instagram effects to your images](img/BO5194_05_20.jpg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![将Instagram效果添加到你的图像](img/BO5194_05_20.jpg)'
- en: If you really want to get into the depths, then it's worth taking a look at
    the source code for this plugin, at [https://github.com/azat-io/postcss-instagram/blob/master/index.js](https://github.com/azat-io/postcss-instagram/blob/master/index.js).
    It is fairly complex, but if you look carefully, you can see signs of the filter
    code that is used to apply the effect to our images.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你真的想深入了解，那么查看这个插件的源代码是值得的，可以在[https://github.com/azat-io/postcss-instagram/blob/master/index.js](https://github.com/azat-io/postcss-instagram/blob/master/index.js)找到。它相当复杂，但如果你仔细观察，可以看到用于将效果应用到我们图像上的过滤代码的迹象。
- en: Summary
  id: totrans-313
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Manipulating images and color can either be very rewarding, or somewhat daunting,
    depending on how simple or complicated we make our processes! Fortunately, PostCSS
    can help automate a fair degree of our processes, so let's take a moment to consider
    what we've covered throughout this chapter.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 处理图像和颜色可能非常有成就感，也可能有些令人畏惧，这取决于我们使我们的过程多么简单或复杂！幸运的是，PostCSS可以帮助自动化我们相当一部分的过程，所以让我们花点时间考虑一下在这一章中我们涵盖了哪些内容。
- en: We kicked off with a look at adding media assets, and using PostCSS to automatically
    update asset links, this helps remove any risk that we inadvertently use the wrong
    link!
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从添加媒体资源开始，并使用PostCSS自动更新资源链接，这有助于消除我们意外使用错误链接的风险！
- en: We then moved on to manipulating images, we started with a look at creating
    image sprites, first using SASS, before transitioning to using PostCSS. Next up
    came a more in-depth look at altering images, where we used the `Evil Icons` SVG
    library and set up PostCSS to alter the color of each icon at compilation. We
    then moved on to learn about how we can switch in the WebP image format; while
    most people might use standard format images, we learned how easy it is to switch-in
    WebP images, when using a supported browser.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 我们接着转向图像处理，首先研究了创建图像精灵，最初使用SASS，然后过渡到使用PostCSS。接下来，我们更深入地研究了如何修改图像，我们使用了`Evil
    Icons` SVG库，并设置了PostCSS在编译时改变每个图标的颜色。然后我们继续学习如何切换到WebP图像格式；虽然大多数人可能会使用标准格式图像，但我们学习了在使用受支持的浏览器时切换WebP图像是多么容易。
- en: Moving on, we then turned our attention to manipulating colors through the use
    of specific palettes, we covered how you can use PostCSS to compile in human-readable
    color names, and then mix or manipulate them within our style sheet. We then amped
    things up a little, with a look at using PostCSS to apply specific color filters,
    to alter color levels in a chosen color. We then explored some of the disadvantages
    of using standard plugins, and why we might need to create our own custom filters,
    that can be applied during compilation of our code. We then rounded out the chapter
    with a quick look at using some fun Instagram filters, where we can easily see
    how multiple filters are put together to manipulate images within our site.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将注意力转向通过使用特定的调色板来处理颜色，我们介绍了如何使用PostCSS编译人类可读的颜色名称，然后在样式表中混合或修改它们。然后我们稍微提高了一些难度，研究了使用PostCSS应用特定的颜色过滤效果，以改变所选颜色的颜色级别。然后我们探讨了使用标准插件的一些缺点，以及为什么我们可能需要创建我们自己的自定义过滤效果，这些过滤效果可以在代码编译期间应用。然后我们以快速查看一些有趣的Instagram过滤效果结束本章，我们可以轻松地看到如何将多个过滤效果组合在一起来处理我们网站中的图像。
- en: 'Wow, we''ve certainly covered a lot of content! But our journey doesn''t stop
    there: in the next chapter, we''ll take a look at creating grids, which we can
    then use to construct layouts within our projects.'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们确实覆盖了大量的内容！但我们的旅程还没有结束：在下一章中，我们将探讨如何创建网格，然后我们可以使用这些网格在我们的项目中构建布局。
