- en: Chapter 11. Application Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our role as architects isn't just to tick the boxes, send the application to
    the client, and forget about it. We have a responsibility, both from a professional
    perspective and a business perspective to produce software that tries to exceed
    expectations. A part of this was mentioned in [Chapter 10](ch10.html "Chapter 10. Debugging
    and Performance"), *Debugging and Performance*, in which we discussed the need
    to build an application that responded quickly to user actions. Now, we'll talk
    about building a robust application, one that stands up to scrutiny when it's
    under intense use.
  prefs: []
  type: TYPE_NORMAL
- en: What does it mean for an application to be robust? It means that if we click
    on a button, we see the expected result. If we try and enter an invalid e-mail
    address, we see a validation message. If we refresh the page, we find ourselves
    on the same screen as before. If the network connection drops out, remote requests
    get retried later. If we try and break the application, and so on, can we succeed?
  prefs: []
  type: TYPE_NORMAL
- en: The core of building a robust application is that the application should always
    behave as the user expects, even in unexpected circumstances. We must recognize
    that developers (and architects) are fallible and are unlikely to be able to account
    for every possible ramification of even a minor code change; this is where bugs
    arise and why the struggle for robustness is constant and ongoing.
  prefs: []
  type: TYPE_NORMAL
- en: We need a safety net for the fallible nature of coding. If we rename a particular
    method in the product list view, can we guarantee that it won't affect the shopping
    cart? We can use find and replace in our text editor, but we can never be 100
    percent certain without refreshing the application and working through the functionality
    of the product list and the shopping cart to show that the customer requirements
    are still fulfilled.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quality assurance process is a safety net of which automated testing is a
    key component. When working with Ext JS, there are a multitude of tools that we
    can use and a range of approaches to ensure that our applications are built in
    a way that is conducive to automated testing. To this end, in this chapter, we''ll
    look at:'
  prefs: []
  type: TYPE_NORMAL
- en: The different types of test and when to use them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Keeping Ext JS code concerns separate to promote unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Naming and coding conventions to assist with integration testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing tools for unit tests and integration tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ext JS-specific testing tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The goal in this chapter is to build an understanding of the advantages of testing,
    how to write Ext JS applications that are easy to test, and how to select and
    employ suitable testing tools. When we're done, we'll have covered all of the
    subjects an Ext JS architect needs to produce exemplary products.
  prefs: []
  type: TYPE_NORMAL
- en: Total testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we'll cover two types of test, one at the detail level and
    one at the "big picture" level. The first, unit testing, is great for helping
    with the algorithms and calculations that often make up business logic; the second,
    integration testing, helps us make sure that customer requirements are met and
    the user experience is sound. Let's look at each in turn.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With unit testing, we unsurprisingly test a unit, a unit being an individual
    unit of code. This will generally be a whole class, but will focus on a single
    method depending on the circumstances. In a unit test, we''d be able to say something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To set up the test, we add the same product to the cart twice. This should
    result in one line item with a quantity of two rather than two line items, each
    with a quantity of one. In the first test, we make the assertion that the cart
    count is equal to one, assuring us that adding to the cart won''t add duplicates.
    The next test will check whether the quantity is incremented as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: It performs the same setup as the previous test, but then picks out the first
    line item in the cart and makes the assertion that its quantity is equal to two,
    one for each time the product was added to the cart.
  prefs: []
  type: TYPE_NORMAL
- en: Assert yourself
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What''s all this "assertion" business? It''s simply a way of saying, "if this
    condition isn''t met, something''s wrong". In the previous examples, if the actual
    value and the expected value aren''t equal, something''s wrong. In most unit testing
    libraries, there are lots of different assertions, such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less than
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Greater than
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is it numeric?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does it contain the specified value?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each testing library has its own flavor of assert methods. Some will use slightly
    different terminology (such as expectations or specifications). The terminology
    is less important than the principles behind unit testing, which is to put an
    isolated piece of code under intense scrutiny.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While unit testing focuses on a small piece of functionality, integration testing
    goes to the opposite extreme. Its purpose is to check whether all of the moving
    parts of the application work together correctly, replicating some of the actions
    that a real-world user would take.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this reason, integration testing will often be described as UI testing
    because it acts directly on the interface. Let''s say that we want to verify whether
    the detail window will show when a product is clicked on. We can do something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Find the link for the product in question.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simulate a click event on the link.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify that the DOM element with the product in question appeared as expected.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is completely different to the kind of focus we had with unit testing in
    which we were drilling down to a single function or class in the code. Here, the
    actions we test will span multiple classes in the application, checking whether
    they're integrated and working together correctly.
  prefs: []
  type: TYPE_NORMAL
- en: Integration and differentiation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The nature of integration testing means that it operates on the same application
    that your users can see; the tests effectively load up a browser and simulate
    the path a user would take. However, rather than moving the mouse cursor manually
    in the same way as a user, integration test frameworks generally work by picking
    out HTML elements on the screen and allowing you to perform actions directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is both good and bad. When a user negotiates a web page, they can generally
    spot the UI components they''re interested in fairly quickly, but when the person
    writing the test comes to pick out this same component, they need a way of referencing
    it. The usual approach to this is to use CSS or XPath selectors. For example,
    to reference an element on the page with an ID with CSS and then XPath, use the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, another slightly more complicated code to get the first button in a container
    is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This goes some way in demonstrating a potential pain point of writing integration
    tests. What if the ID of `someElement` changes? It'll break the test, but it's
    a fairly simple fix. What if the ID of "container" changes? Well, not only will
    it break the previous example, but it'll also break any other tests that are looking
    for buttons or other elements within this `div`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is an ongoing problem with integration testing: the fragility of tests.
    Later in the chapter, we''ll look at some methods to address this within Ext JS.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing tool time with Jasmine
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Enough theory! Let's get our hands dirty with some practical examples using
    the Alcohology app from [Chapter 9](ch09.html "Chapter 9. A Shopping Application"),
    *A Shopping Application*. First, we'll drill down into the guts of the application
    and build a unit test for some of the key business functionality. Then, we'll
    jump up to a high-level view and check whether our building blocks integrate correctly.
  prefs: []
  type: TYPE_NORMAL
- en: There are a wealth of tools we can use for both. The Ext JS framework has begun
    to build a set of unit tests to verify its behavior and cut out regressions in
    core functionality. To do so, Sencha has chosen the Jasmine library.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sencha has hinted that there'll be a big announcement surrounding testing alongside
    SenchaCon 2015\. Given that they're already using Jasmine, we can hope that it'll
    be a good bet for Ext JS application testing in the future.
  prefs: []
  type: TYPE_NORMAL
- en: 'Jasmine is a behavior-driven framework, a term that relates to the way tests
    are described. Rather than using the "assertation" terminology, it uses the "expectation"
    format that we briefly mentioned earlier in the chapter. It asks us to specify
    behavior and expect a particular result. Here''s the canonical example from Jasmine''s
    documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The `describe` method encloses one or more specifications, themselves declared
    in an `it` method, with expectations declared using the `expect` method. To translate
    the previous code to plain language, use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, this is a contrived suite, as we'd hope that true would always be
    true! However, it should serve as a useful demonstration of the general syntax
    of a Jasmine test. Before we can get going and use this on our own application,
    we need to take a little bit of time to download and set up the Jasmine library.
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine – installation and configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The simplest way of getting started with Jasmine is to download the latest version
    from the project's release page. At the time of writing this book, the current
    version is 2.1.3\. Refer to [https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases)
    for more information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Extract the ZIP file and you''ll see that the download includes some example
    specifications that we don''t need; let''s clear these out from within the new
    Jasmine directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can move the Jasmine library to the root of the Alcohology project,
    assuming our current directory is now in the Alcohology project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now fire up our application; if you''ve downloaded the project files,
    then the readme file will tell you to run `npm start` and it''ll start the Ext
    JS project and the API server. Once this is done, we can open `http://localhost:1841/tests/jasmine/SpecRunner.html`
    in our browser to run the specs, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Jasmine – installation and configuration](img/5308OT_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Jasmine spec runner before writing any specifications
  prefs: []
  type: TYPE_NORMAL
- en: 'In this screenshot, we can see the spec runner, but it''s got nothing to do.
    We''ve got a little bit more configuration to do before we can start writing some
    specifications. Let''s open up the `SpecRunner.html` file in an editor and tweak
    it to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This HTML file is really just a host for the Jasmine library, but it's also
    where we wire up Ext JS to work outside of the context of an application. By including
    the `ext-all` JavaScript file and reconfiguring `Ext.Loader` to grab any Alcohology
    classes from the correct directory, we can instantiate classes to test and Ext
    JS will automatically request the files we need from our application directory.
    All that's left to do is include the actual JavaScript specification files at
    the bottom of the head element. Here, we've already added a reference to `spec/Cart.js`.
  prefs: []
  type: TYPE_NORMAL
- en: With all of the setup out of the way, we can move on to writing some tests!
  prefs: []
  type: TYPE_NORMAL
- en: Make it happen
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier, we wrote some pseudocode to illustrate how to test the `addProduct`
    method on the cart store. Now, let''s build out the real Jasmine specification
    that accomplishes this for real. We need to create a test suite with a cart store
    that''ll be used as test subject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Our first suite is simply called `Cart store`. We have a cart variable that
    gets reassigned `beforeEach` specification is run. It's assigned an instance of
    the cart store via `Ext.create`. Thanks to our configuration in the previous section,
    `Ext.create` will use `Ext.Loader` to automatically pull in the relevant source
    code file, including any dependencies. By reinstantiating before every test, we
    can be sure that a test later in the suite won't be affected by the way an earlier
    test has manipulated the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now sketch out the functionality we''d like to test. The following code
    goes after the `beforeEach` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'If we refresh the `SpecRunner.html` page, then we''ll actually be able to see
    something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make it happen](img/5308OT_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These specifications are just placeholders, but the fact that they show up in
    the runner is useful for developers practicing test first development. We can
    write a series of specification statements that describe the functionality we
    require, then the specs, and finally, the code itself. In this way, we're specifying
    the behavior we need and the code itself follows, and we can be safe in the knowledge
    that it meets our requirements. This can be a powerful methodology for an architect
    to spell out in detail how a class should behave.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go through each spec one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'We expect that if `addProduct` is passed, something that is not a product model,
    it will throw an exception. We pass the method to the expect call prepopulated
    with an empty object literal. As this isn''t a product model—as expected—it throws
    an exception and satisfies the test as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'When the product is added to the cart, we expect that it will cause a new line
    item to be created in the store. We simply check whether the cart count is as
    expected after adding a product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After adding a product that''s already in the cart, we expect that it will
    increase the quantity of the corresponding cart line. We pass in the same product
    twice and check whether the quantity is two, as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This is a similar setup as the last test, but we are expecting that there will
    not be a duplicated cart line, but instead, there will be only one item in the
    cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of the specifications written, we can refresh the spec runner again:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Make it happen](img/5308OT_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, the specs are all in green, indicating that they have passed
    successfully.
  prefs: []
  type: TYPE_NORMAL
- en: This is just a brief primer on unit testing with Jasmine, but it demonstrates
    the power available and the utility of testing in this manner. It gives us confidence
    in the code we've written and ensures that any additions to the `addProduct` method
    won't break the functionality that already exists.
  prefs: []
  type: TYPE_NORMAL
- en: Testing with robots
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve covered a method of testing the fine detail of our code, let''s
    look at a completely different way of running functional checks across the entire
    application. For this, we''ll need a new tool: CasperJS. It allows you to drive
    a "headless browser"—one without any user interface—navigate around an application,
    and run evaluations on what we find. The first step is installation, which varies
    depending on the platform. Instructions for the same can be found at [http://docs.casperjs.org/en/latest/installation.html](http://docs.casperjs.org/en/latest/installation.html).'
  prefs: []
  type: TYPE_NORMAL
- en: When complete, we'll have a CasperJS command available to run.
  prefs: []
  type: TYPE_NORMAL
- en: 'With Jasmine, we were using the behavior-driven method of testing with expectations
    to verify the code. In CasperJS, we go back to using the assertion style of testing.
    Take a look at a minimal test script from the CasperJS documentation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty straightforward. The real magic comes when we combine this with CasperJS''s
    ability to control the headless browser and interface with the web page that forms
    our application. Check this out:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks a bit more exciting! Let''s break down what''s happening here:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new CasperJS test suite.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to the Google home page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that the page title is as expected and that we can find the search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fill in the search box and submit the form.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, when the page has loaded, assert that the URL is as expected and contains
    our search query as a parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert that there are at least ten search results on the page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Fantastic! This example shows how easy it's to use CasperJS to control a web
    page and how its testing features allow us to evaluate the content of the page
    and the behavior of an app.
  prefs: []
  type: TYPE_NORMAL
- en: The next step is to see how to use these features to test our own application,
    so let's hook CasperJS into our Alcohology project and get testing.
  prefs: []
  type: TYPE_NORMAL
- en: Up and running with CasperJS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a new subdirectory within our project at `tests/casper` and then
    create a new file in there called `Sanity.js`. We''re going to write a couple
    of simple checks to make sure the application is loading correctly. Here''s the
    starting point for the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We kick off by calling the `casper.test.begin` method, which starts off a new
    test suite and takes three arguments: a description for the suite, the number
    of tests we expect should be run, and a callback function that is called when
    the suite is created. The callback gets passed on a test object on which we can
    call various assert methods.'
  prefs: []
  type: TYPE_NORMAL
- en: We then call CasperJS's `start` method with the URL to our application. In order
    to trigger the test run, we call CasperJS's `run` method and when everything's
    complete, we call the `done` method on the test object.
  prefs: []
  type: TYPE_NORMAL
- en: The first test we're going to write will check whether the category menu on
    the left-hand side of the application is populated as expected. To do this, we'll
    look for the first menu item and check whether it contains the text we expect,
    but it complicates matters slightly when we're loading this content in with Ajax.
    We need to be able to wait for the page to load, select the relevant element,
    and check whether it contains the content we'd expect.
  prefs: []
  type: TYPE_NORMAL
- en: In order to select elements, we're going to use the CSS selector, and so on,
    but we need a mechanism to find the correct selector to use. Fortunately, Chrome
    Developer Tools will come to our rescue once more; if we right click on the **Pilsner**
    text in the top category menu item in Alcohology, then pick **Inspect Element**,
    the elements panel will display with the menu item's element selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, right-click on the element and click on the **Copy CSS Path** option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Up and running with CasperJS](img/5308OT_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The CSS select of this `div` tag will be copied to your clipboard and should
    look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now use this with CasperJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'After telling CasperJS to start and load the application''s web page, we will
    use the `waitForSelector` method to wait until the specified selector appears
    on the page; by default, it''ll wait for 5 seconds before throwing up a failure
    message. When the selector appears, the callback function is triggered and we
    use the `assertSelectorHasText` method to check whether the `div` tag has the
    correct text:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Up and running with CasperJS](img/5308OT_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Running our first CasperJS test
  prefs: []
  type: TYPE_NORMAL
- en: It's simple, but effective. If we'd broken something due to an amend in the
    code for the categories store, incorrectly bound the data to the view model, or
    some other minor change that cascaded to affect this key feature, then this test
    would immediately flag it up.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CasperJS relies on another library called PhantomJS to drive the headless browser.
    There's an issue between the two in the current version that causes the `Unsafe
    JavaScript attempt…` message that you can see in the preceding screenshot; it's
    fine to ignore it.
  prefs: []
  type: TYPE_NORMAL
- en: We can do a lot more. Although the correct text is showing, the menu isn't just
    for display purposes, and when a user clicks on a menu item, it will load the
    products with this category. Can we create a CasperJS test for this?
  prefs: []
  type: TYPE_NORMAL
- en: Of course we can! Take a look at the CasperJS API documentation at [http://docs.casperjs.org/en/latest/modules/casper.html#casper-prototype](http://docs.casperjs.org/en/latest/modules/casper.html#casper-prototype).
  prefs: []
  type: TYPE_NORMAL
- en: 'Alongside the `start` method, we have ones such as `fill` that allows you to
    complete form fields: `scrollTo`, which lets us move to a particular location
    on the page, and for our current purposes: `click`, it provides a means to click
    on an element specified by a selector. Let''s build another test using `click`
    to run a more advanced set of steps, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: Load the application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Click on the **IPA** category
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Select the **Lagunitas IPA** product
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether the product window appear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check whether the correct product name and price appear
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is a much more comprehensive test that goes some way to demonstrating
    the power of CasperJS to replicate user actions and validate the behavior of our
    application. Here''s the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The comments in the code should make it pretty self-explanatory. After setting
    out all of the selectors we need, we wait for the categories and click on the
    one that we need. Next, we wait for the product we want and click on it before
    waiting for the product window to appear and asserting on its contents. For the
    final trick, we instruct CasperJS to take a screenshot, a feature that can be
    useful for debugging or further evaluation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running this code gives us the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Up and running with CasperJS](img/5308OT_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Success! We've simulated and validated a small user path through the Alcohology
    application, checking whether several moving parts of our project work in tandem
    as expected.
  prefs: []
  type: TYPE_NORMAL
- en: The eagle-eyed reader will notice that the selectors in this example look a
    little more friendly than the ones in the first example that we grabbed using
    Google Chrome. There's a very good reason for this and it relates to a set of
    ideas surrounding making your application easier to test.
  prefs: []
  type: TYPE_NORMAL
- en: Testability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with many aspects of software development, there are many different ways
    of testing. Some will advocate a test-first methodology, where the tests are created
    first and the code will be written to satisfy these tests. Whichever method is
    used, we need to take steps to make sure our code can be tested. While this occasionally
    means adding in some helpful hooks and tricks that are only used to test, we should
    generally try to avoid this approach and look to write code that is naturally
    testable; this will often have the fortunate consequence of being better code
    too.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometime back, we talked about selectors and their relationship to testability.
    Let''s look at the selector that Chrome Developer Tools gave us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is a very specific selector and the first part of it is using an ID that
    was autogenerated by Ext JS. As soon as we add or alter the component hierarchy
    of the application or change the records being displayed on the page, this will
    break and our CasperJS tests will fail.
  prefs: []
  type: TYPE_NORMAL
- en: We can increase testability of our application by ensuring that our test code
    is less brittle. In this case, we can leverage the CSS classes that we use to
    style our application. Back in [Chapter 9](ch09.html "Chapter 9. A Shopping Application"),
    *A Shopping Application*, when we built the category list view, we set the `bodyCls`
    configuration option to `categories-body`. This gives us a great way to target
    the list that we know isn't going to randomly change.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using it in addition with the `nth-child` pseudo-selector gives us a simpler
    and more robust version of our original Developer Tools selector:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In plain language, get the element with a class of `categories-body`, find the
    second child table, which corresponds to the second row, and grab its `td` cell
    element.
  prefs: []
  type: TYPE_NORMAL
- en: Using Chrome Developer Tools is still a great way to look at the HTML structure
    of the page and work out an optimal selector for each case, but it's rarely going
    to provide the most robust selector.
  prefs: []
  type: TYPE_NORMAL
- en: Should I or shouldn't I?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There's plenty of lively debate about how testing should inform your code, if
    at all. In the last example, we had a useful CSS selector that was already being
    used for styling, but in the event we hadn't already placed it there, should it
    have been added specifically to support styling?
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, it''s a very minor change, so we probably don''t have to feel
    that bad about it. We could even wrap it in a Sencha Cmd directive to ensure that
    it doesn''t get included in production builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In general though, anything that adds complexity or maintenance overhead to
    our main code base just to improve testability should be avoided. Instead, we
    can look at ways in which the design of an application naturally promotes testability.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the book, we talked about MVC and MVVM and how one of the benefits
    of such patterns is to promote the separation of code concerns. Throughout, we've
    used events to ensure that components can "fire-and-forget" and trigger actions
    without having an awareness of other parts of the system.
  prefs: []
  type: TYPE_NORMAL
- en: This is a key feature that gives an elegant, clear design combined with a side
    benefit of separation of components. We can pluck out individual views, render
    them alone on a simple page, and perform tests on a single component in isolation.
    As in our Jasmine examples at the start of the chapter, we can take a single model
    and instantiate it without having to worry about the user interface layers.
  prefs: []
  type: TYPE_NORMAL
- en: The beauty of good application architecture is that it provides an understandable
    application that immediately lends itself to testing. Although, integration testing
    is an important weapon in our arsenal, it's much more important to ensure that
    the various parts of the machine are well built before trying to fire the whole
    thing up.
  prefs: []
  type: TYPE_NORMAL
- en: Faking it with mocks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When it''s up and running, our application still has one giant dependency:
    the server. During integration testing, this means that the server-side database
    needs to be primed with test data, and test suite will result in many requests
    being sent back and forth. In a large test suite, this can be slow and the database
    setup can be painful.'
  prefs: []
  type: TYPE_NORMAL
- en: A common resolution to this problem is to bypass the server API altogether.
    When our application makes an Ajax request, we can hijack the `XMLHttpRequest`
    and feed the calling code some static test data instead.
  prefs: []
  type: TYPE_NORMAL
- en: To demonstrate this and show the flexibility of the technique, we'll create
    a small Jasmine test case that shows how to supply a product store with mock JSON
    data. Although, faking an Ajax request is really useful in integration tests,
    this will show off the technique in a succinct way that can be used in both unit
    and integration testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be using a feature of Ext JS that isn''t included by default: `Simlets`.
    The classes that implement `Simlets` are included in the `examples` directory
    of the Ext JS distribution, so all we have to do is open up the `SpecRunner.html`
    file from earlier in the chapter and amend it to instruct `Ext.Loader` to pull
    in the files from the correct location:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'All we''ve added is the line for the `Ext.ux` path. Now, we can build our Jasmine
    test, so let''s dive straight into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Lots going on here! First, we set up a couple of variables, one to contain the
    `productStore` between tests and one containing our fake JSON.
  prefs: []
  type: TYPE_NORMAL
- en: In the `beforeEach` function call, we load in the `SimletManager` class and
    the `Product` model from Alcohology; `Ext.Loader` will pull in the files for us
    before allowing execution to proceed to the next lines. Next, we set up `SimletManager`
    by registering the URL to be intercepted and the data that should be returned
    instead of the normal server response.
  prefs: []
  type: TYPE_NORMAL
- en: This is actually all we need to set up a fake request; the rest of the code
    proceeds as if it were a normal Jasmine test in which we set two expectations
    after the product store loads, that is, there will be one returned record and
    its name will be set to `Test Product`, just like in the test data.
  prefs: []
  type: TYPE_NORMAL
- en: Running the test through the spec runner sees everything pass as expected and
    demonstrates the power of this technique. We can disconnect all of our testing
    from the backend and run independent of a database; test data is supplied directly
    in the tests and not in a database row somewhere on a server.
  prefs: []
  type: TYPE_NORMAL
- en: Continuous coverage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You've learned how to use a couple of different testing tools in this chapter,
    but what about when to use these tools?
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to code testing, there's a metric known as "code coverage" that
    tells us the percentage of our code that is covered by tests. The first thought
    of a passionate architect starting a new project is that everything should be
    covered with tests, tests everywhere!
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, there are things that we just don't need to test; as always,
    we should take a pragmatic approach. Configuration of components probably doesn't
    need to be tested; we don't need to test the return values from third-party code
    libraries; there are many examples.
  prefs: []
  type: TYPE_NORMAL
- en: Having said that, code coverage is a useful way to make sure that a certain
    level of testing is maintained in a project. For example, we might wish to have
    90 percent test coverage of our model code and only 50 percent coverage on our
    controllers, which contain more boilerplate that doesn't need to be tested. The
    exact ratios will depend on the project, the developers, and indeed the architect.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are many code coverage tools for JavaScript, one of which is Istanbul.
    It provides a comprehensive set of features to check code coverage in a variety
    of ways and reports on the level of coverage in a range of formats. You can find
    this on GitHub at [https://github.com/gotwarlost/Istanbul](https://github.com/gotwarlost/Istanbul).
  prefs: []
  type: TYPE_NORMAL
- en: 'When a project is well covered by unit tests and integration tests are in place
    to make sure the user experience remains consistent, we''re left with one part
    of the puzzle: when to run these tests?'
  prefs: []
  type: TYPE_NORMAL
- en: Of course, a developer should be running the relevant tests for the section
    of code they're working on, but in reality, a full test suite can take a long
    time to execute. In such cases, we can make use of something called **continuous
    integration** (**CI**).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Jenkins CI is an open source CI system ([http://jenkins-ci.org/](http://jenkins-ci.org/))
    and Circle CI ([https://circleci.com/](https://circleci.com/)) is paid for, but
    with a free plan.
  prefs: []
  type: TYPE_NORMAL
- en: Whenever a developer pushes new code to the source control repository, a CI
    server grabs that code and runs the tests. This enables us to see when a developer
    has committed code that breaks the current build; it also gives us peace of mind
    that a successful CI build will be one that has passed our automated checks and
    is well on its way to production.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is a huge topic with many different libraries, programs, and techniques
    vying for the attention of software architects. As with many facets of our role,
    there's never one correct answer and the most important thing is to settle on
    something that works for our particular project.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we've reviewed a range of different ideas and approaches to
    testing Ext JS and touched on the ways in which we can ensure our architectural
    decisions trickle down into making testing easier. The different extremes of test—from
    unit to integration—can always benefit when we isolate certain parts of the system
    under test, from remote requests through to separation of code concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Testing is an essential, yet often neglected part of Ext JS application architecture
    and this chapter is only an overview. This, and the other topics covered in this
    book, must be used in combination and alongside a constant search for new ideas
    in order to truly master the concepts we've touched on.
  prefs: []
  type: TYPE_NORMAL
