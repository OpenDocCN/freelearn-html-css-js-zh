- en: Chapter 11. Application Testing
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章。应用程序测试
- en: Our role as architects isn't just to tick the boxes, send the application to
    the client, and forget about it. We have a responsibility, both from a professional
    perspective and a business perspective to produce software that tries to exceed
    expectations. A part of this was mentioned in [Chapter 10](ch10.html "Chapter 10. Debugging
    and Performance"), *Debugging and Performance*, in which we discussed the need
    to build an application that responded quickly to user actions. Now, we'll talk
    about building a robust application, one that stands up to scrutiny when it's
    under intense use.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们作为架构师的角色不仅仅是勾选框，将应用程序发送给客户，然后忘记它。从专业和商业的角度来看，我们有责任生产试图超越预期的软件。其中一部分在[第10章](ch10.html
    "第10章。调试与性能")中提到，即*调试与性能*，我们讨论了构建对用户操作反应迅速的应用程序的需求。现在，我们将讨论构建一个鲁棒的应用程序，一个在重压下经得起考验的应用程序。
- en: What does it mean for an application to be robust? It means that if we click
    on a button, we see the expected result. If we try and enter an invalid e-mail
    address, we see a validation message. If we refresh the page, we find ourselves
    on the same screen as before. If the network connection drops out, remote requests
    get retried later. If we try and break the application, and so on, can we succeed?
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序要具备鲁棒性意味着什么？这意味着如果我们点击一个按钮，我们会看到预期的结果。如果我们尝试输入一个无效的电子邮件地址，我们会看到验证消息。如果我们刷新页面，我们会发现自己回到了之前的屏幕。如果网络连接断开，远程请求会在稍后重试。如果我们尝试破坏应用程序，等等，我们能否成功？
- en: The core of building a robust application is that the application should always
    behave as the user expects, even in unexpected circumstances. We must recognize
    that developers (and architects) are fallible and are unlikely to be able to account
    for every possible ramification of even a minor code change; this is where bugs
    arise and why the struggle for robustness is constant and ongoing.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 构建鲁棒应用程序的核心是应用程序应该始终按照用户的预期行为，即使在意外情况下也是如此。我们必须认识到开发者（和架构师）是会犯错的，并且不太可能考虑到即使是微小的代码更改的每一个可能的后果；这就是错误出现的原因，也是为什么对鲁棒性的追求是持续不断的。
- en: We need a safety net for the fallible nature of coding. If we rename a particular
    method in the product list view, can we guarantee that it won't affect the shopping
    cart? We can use find and replace in our text editor, but we can never be 100
    percent certain without refreshing the application and working through the functionality
    of the product list and the shopping cart to show that the customer requirements
    are still fulfilled.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要安全网来应对编码的易出错性。如果我们更改产品列表视图中的一个特定方法，我们能否保证它不会影响购物车？我们可以在文本编辑器中使用查找和替换，但我们永远无法在没有刷新应用程序并检查产品列表和购物车的功能以证明客户需求仍然得到满足的情况下，达到100%的确定性。
- en: 'A quality assurance process is a safety net of which automated testing is a
    key component. When working with Ext JS, there are a multitude of tools that we
    can use and a range of approaches to ensure that our applications are built in
    a way that is conducive to automated testing. To this end, in this chapter, we''ll
    look at:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 质量保证流程是一个安全网，其中自动化测试是其关键组成部分。当使用 Ext JS 时，我们有众多工具可以使用，以及一系列方法来确保我们的应用程序以有利于自动化测试的方式构建。为此，在本章中，我们将探讨：
- en: The different types of test and when to use them
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同的测试类型及其使用时机
- en: Keeping Ext JS code concerns separate to promote unit testing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将Ext JS代码关注点分离以促进单元测试
- en: Naming and coding conventions to assist with integration testing
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 命名和编码规范以帮助进行集成测试
- en: Testing tools for unit tests and integration tests
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试和集成测试的测试工具
- en: Ext JS-specific testing tools
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ext JS特定的测试工具
- en: The goal in this chapter is to build an understanding of the advantages of testing,
    how to write Ext JS applications that are easy to test, and how to select and
    employ suitable testing tools. When we're done, we'll have covered all of the
    subjects an Ext JS architect needs to produce exemplary products.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的目标是建立对测试优势的理解，如何编写易于测试的Ext JS应用程序，以及如何选择和运用合适的测试工具。完成之后，我们将涵盖Ext JS架构师需要生产优秀产品所需的所有主题。
- en: Total testing
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全面测试
- en: In this chapter, we'll cover two types of test, one at the detail level and
    one at the "big picture" level. The first, unit testing, is great for helping
    with the algorithms and calculations that often make up business logic; the second,
    integration testing, helps us make sure that customer requirements are met and
    the user experience is sound. Let's look at each in turn.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍两种类型的测试，一种在细节层面，另一种在“大局”层面。第一种，单元测试，非常适合帮助处理通常构成业务逻辑的算法和计算；第二种，集成测试，帮助我们确保满足客户需求并且用户体验良好。让我们逐一查看。
- en: Unit testing
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'With unit testing, we unsurprisingly test a unit, a unit being an individual
    unit of code. This will generally be a whole class, but will focus on a single
    method depending on the circumstances. In a unit test, we''d be able to say something
    like this:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用单元测试时，我们不出所料地测试一个单元，一个单元是一个单独的代码单元。这通常是一个完整的类，但会根据情况专注于单个方法。在单元测试中，我们可以说出如下内容：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To set up the test, we add the same product to the cart twice. This should
    result in one line item with a quantity of two rather than two line items, each
    with a quantity of one. In the first test, we make the assertion that the cart
    count is equal to one, assuring us that adding to the cart won''t add duplicates.
    The next test will check whether the quantity is incremented as expected:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为了设置测试，我们将同一产品添加到购物车两次。这应该导致一个数量为两个的行项目，而不是两个数量各为一的行项目。在第一个测试中，我们断言购物车计数等于一个，这确保了添加到购物车不会添加重复项。下一个测试将检查数量是否按预期增加：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: It performs the same setup as the previous test, but then picks out the first
    line item in the cart and makes the assertion that its quantity is equal to two,
    one for each time the product was added to the cart.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它执行与上一个测试相同的设置，然后选择购物车中的第一行项目，并断言其数量等于两个，每个产品被添加到购物车一次。
- en: Assert yourself
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断言自己
- en: 'What''s all this "assertion" business? It''s simply a way of saying, "if this
    condition isn''t met, something''s wrong". In the previous examples, if the actual
    value and the expected value aren''t equal, something''s wrong. In most unit testing
    libraries, there are lots of different assertions, such as:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些“断言”是什么意思？它只是说“如果这个条件不满足，就有问题”。在先前的例子中，如果实际值和预期值不相等，就有问题。在大多数单元测试库中，有许多不同的断言，例如：
- en: Equal
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等于
- en: Less than
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 小于
- en: Greater than
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 大于
- en: Is it numeric?
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是数字吗？
- en: Does it contain the specified value?
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它是否包含指定的值？
- en: Each testing library has its own flavor of assert methods. Some will use slightly
    different terminology (such as expectations or specifications). The terminology
    is less important than the principles behind unit testing, which is to put an
    isolated piece of code under intense scrutiny.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 每个测试库都有自己的断言方法风格。有些会使用稍微不同的术语（如期望或规范）。术语不如单元测试背后的原则重要，即对隔离的代码进行严格的审查。
- en: Integration testing
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 集成测试
- en: While unit testing focuses on a small piece of functionality, integration testing
    goes to the opposite extreme. Its purpose is to check whether all of the moving
    parts of the application work together correctly, replicating some of the actions
    that a real-world user would take.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然单元测试关注的是一小块功能，但集成测试则走向了相反的极端。其目的是检查应用程序的所有移动部件是否正确协同工作，复制一些现实世界用户可能会采取的操作。
- en: 'For this reason, integration testing will often be described as UI testing
    because it acts directly on the interface. Let''s say that we want to verify whether
    the detail window will show when a product is clicked on. We can do something
    like this:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，集成测试通常被称为 UI 测试，因为它直接作用于界面。假设我们想验证当点击产品时，详细窗口是否会显示。我们可以这样做：
- en: Find the link for the product in question.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到问题产品的链接。
- en: Simulate a click event on the link.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在链接上模拟点击事件。
- en: Verify that the DOM element with the product in question appeared as expected.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证问题产品所在的 DOM 元素是否按预期显示。
- en: This is completely different to the kind of focus we had with unit testing in
    which we were drilling down to a single function or class in the code. Here, the
    actions we test will span multiple classes in the application, checking whether
    they're integrated and working together correctly.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前在单元测试中拥有的那种关注点完全不同。在单元测试中，我们是深入到代码中的单个函数或类。在这里，我们要测试的操作将跨越应用程序中的多个类，检查它们是否集成并正确协同工作。
- en: Integration and differentiation
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 积分和微分
- en: The nature of integration testing means that it operates on the same application
    that your users can see; the tests effectively load up a browser and simulate
    the path a user would take. However, rather than moving the mouse cursor manually
    in the same way as a user, integration test frameworks generally work by picking
    out HTML elements on the screen and allowing you to perform actions directly.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 集成测试的本质意味着它操作的是用户可以看到的相同应用程序；测试实际上加载了一个浏览器并模拟用户会采取的路径。然而，与用户手动移动鼠标光标的方式不同，集成测试框架通常通过在屏幕上选择HTML元素并允许您直接执行操作来工作。
- en: 'This is both good and bad. When a user negotiates a web page, they can generally
    spot the UI components they''re interested in fairly quickly, but when the person
    writing the test comes to pick out this same component, they need a way of referencing
    it. The usual approach to this is to use CSS or XPath selectors. For example,
    to reference an element on the page with an ID with CSS and then XPath, use the
    following code:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这既有好的一面也有不好的一面。当用户协商网页时，他们通常可以相当快地找到他们感兴趣的用户界面组件，但当编写测试的人来挑选这个相同的组件时，他们需要一种引用它的方法。通常的做法是使用CSS或XPath选择器。例如，要使用CSS和XPath引用页面上具有ID的元素，请使用以下代码：
- en: '[PRE2]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Also, another slightly more complicated code to get the first button in a container
    is as follows:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，获取容器中第一个按钮的另一个稍微复杂一些的代码如下：
- en: '[PRE3]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This goes some way in demonstrating a potential pain point of writing integration
    tests. What if the ID of `someElement` changes? It'll break the test, but it's
    a fairly simple fix. What if the ID of "container" changes? Well, not only will
    it break the previous example, but it'll also break any other tests that are looking
    for buttons or other elements within this `div`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这在一定程度上展示了编写集成测试的潜在痛点。如果`someElement`的ID发生变化怎么办？这将破坏测试，但这是一个相当简单的修复。如果"container"的ID发生变化呢？嗯，这不仅会破坏前面的例子，还会破坏任何寻找此`div`内按钮或其他元素的测试。
- en: 'This is an ongoing problem with integration testing: the fragility of tests.
    Later in the chapter, we''ll look at some methods to address this within Ext JS.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在集成测试中持续存在的问题：测试的脆弱性。在本章的后面部分，我们将探讨一些在Ext JS中解决此问题的方法。
- en: Testing tool time with Jasmine
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Jasmine的测试工具时间
- en: Enough theory! Let's get our hands dirty with some practical examples using
    the Alcohology app from [Chapter 9](ch09.html "Chapter 9. A Shopping Application"),
    *A Shopping Application*. First, we'll drill down into the guts of the application
    and build a unit test for some of the key business functionality. Then, we'll
    jump up to a high-level view and check whether our building blocks integrate correctly.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 理论已经足够了！让我们通过使用第9章中的Alcohology应用程序（[第9章](ch09.html "第9章。购物应用程序"），“购物应用程序”）的一些实际例子来动手实践。首先，我们将深入到应用程序的内部，为一些关键业务功能构建单元测试。然后，我们将上升到高级视图，检查我们的构建块是否正确集成。
- en: There are a wealth of tools we can use for both. The Ext JS framework has begun
    to build a set of unit tests to verify its behavior and cut out regressions in
    core functionality. To do so, Sencha has chosen the Jasmine library.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用大量工具来完成这两项任务。Ext JS框架已经开始构建一系列单元测试来验证其行为并消除核心功能中的回归。为此，Sencha选择了Jasmine库。
- en: Note
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Sencha has hinted that there'll be a big announcement surrounding testing alongside
    SenchaCon 2015\. Given that they're already using Jasmine, we can hope that it'll
    be a good bet for Ext JS application testing in the future.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Sencha暗示，在2015年SenchaCon大会期间将会有关于测试的重大公告。鉴于他们已经在使用Jasmine，我们可以期待这将是未来Ext JS应用程序测试的一个很好的选择。
- en: 'Jasmine is a behavior-driven framework, a term that relates to the way tests
    are described. Rather than using the "assertation" terminology, it uses the "expectation"
    format that we briefly mentioned earlier in the chapter. It asks us to specify
    behavior and expect a particular result. Here''s the canonical example from Jasmine''s
    documentation:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: Jasmine是一个行为驱动框架，这个术语与测试的描述方式有关。它不使用“断言”术语，而是使用我们在本章前面简要提到的“期望”格式。它要求我们指定行为并期望特定的结果。以下是Jasmine文档中的典型示例：
- en: '[PRE4]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `describe` method encloses one or more specifications, themselves declared
    in an `it` method, with expectations declared using the `expect` method. To translate
    the previous code to plain language, use the following command:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`describe`方法用`expect`方法声明的期望包围一个或多个规格，这些规格本身是在`it`方法中声明的。要将前面的代码翻译成普通语言，请使用以下命令：'
- en: '[PRE5]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Obviously, this is a contrived suite, as we'd hope that true would always be
    true! However, it should serve as a useful demonstration of the general syntax
    of a Jasmine test. Before we can get going and use this on our own application,
    we need to take a little bit of time to download and set up the Jasmine library.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这是一个虚构的套件，因为我们希望总是为真！然而，它应该作为一个有用的Jasmine测试通用语法的演示。在我们能够开始使用它并应用于我们自己的应用程序之前，我们需要花点时间下载并设置Jasmine库。
- en: Jasmine – installation and configuration
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Jasmine – 安装和配置
- en: The simplest way of getting started with Jasmine is to download the latest version
    from the project's release page. At the time of writing this book, the current
    version is 2.1.3\. Refer to [https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases)
    for more information.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 开始使用Jasmine的最简单方法是下载项目发布页面上的最新版本。在撰写本书时，当前版本是2.1.3。有关更多信息，请参阅[https://github.com/jasmine/jasmine/releases](https://github.com/jasmine/jasmine/releases)。
- en: 'Extract the ZIP file and you''ll see that the download includes some example
    specifications that we don''t need; let''s clear these out from within the new
    Jasmine directory:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 解压缩ZIP文件，您会看到下载包括一些我们不需要的示例规范；让我们从新的Jasmine目录中清除这些内容：
- en: '[PRE6]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now, we can move the Jasmine library to the root of the Alcohology project,
    assuming our current directory is now in the Alcohology project:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将Jasmine库移动到Alcohology项目的根目录，假设我们的当前目录现在位于Alcohology项目中：
- en: '[PRE7]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We can now fire up our application; if you''ve downloaded the project files,
    then the readme file will tell you to run `npm start` and it''ll start the Ext
    JS project and the API server. Once this is done, we can open `http://localhost:1841/tests/jasmine/SpecRunner.html`
    in our browser to run the specs, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以启动我们的应用程序；如果您已下载项目文件，则readme文件将告诉您运行`npm start`，这将启动Ext JS项目和API服务器。一旦完成，我们就可以在我们的浏览器中打开`http://localhost:1841/tests/jasmine/SpecRunner.html`来运行规范，如图所示：
- en: '![Jasmine – installation and configuration](img/5308OT_11_01.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![Jasmine – 安装和配置](img/5308OT_11_01.jpg)'
- en: The Jasmine spec runner before writing any specifications
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 编写规范之前的Jasmine规范运行器
- en: 'In this screenshot, we can see the spec runner, but it''s got nothing to do.
    We''ve got a little bit more configuration to do before we can start writing some
    specifications. Let''s open up the `SpecRunner.html` file in an editor and tweak
    it to look like this:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个屏幕截图中，我们可以看到规范运行器，但它没有任何作用。在我们开始编写一些规范之前，我们还需要做一些配置。让我们在编辑器中打开`SpecRunner.html`文件，并调整它看起来像这样：
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This HTML file is really just a host for the Jasmine library, but it's also
    where we wire up Ext JS to work outside of the context of an application. By including
    the `ext-all` JavaScript file and reconfiguring `Ext.Loader` to grab any Alcohology
    classes from the correct directory, we can instantiate classes to test and Ext
    JS will automatically request the files we need from our application directory.
    All that's left to do is include the actual JavaScript specification files at
    the bottom of the head element. Here, we've already added a reference to `spec/Cart.js`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个HTML文件实际上只是Jasmine库的宿主，但它也是我们将Ext JS连接到应用程序上下文之外的地方。通过包含`ext-all`JavaScript文件并重新配置`Ext.Loader`以从正确的目录获取任何Alcohology类，我们可以实例化用于测试的类，并且Ext
    JS将自动从我们的应用程序目录请求所需的文件。剩下的只是将实际的JavaScript规范文件包含在head元素的底部。在这里，我们已经添加了对`spec/Cart.js`的引用。
- en: With all of the setup out of the way, we can move on to writing some tests!
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在完成所有设置后，我们可以继续编写一些测试！
- en: Make it happen
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 让它发生
- en: 'Earlier, we wrote some pseudocode to illustrate how to test the `addProduct`
    method on the cart store. Now, let''s build out the real Jasmine specification
    that accomplishes this for real. We need to create a test suite with a cart store
    that''ll be used as test subject:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们编写了一些伪代码来展示如何测试购物车存储上的`addProduct`方法。现在，让我们构建一个真正的Jasmine规范，以实现这一目标。我们需要创建一个包含购物车存储的测试套件，该存储将用作测试对象：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Our first suite is simply called `Cart store`. We have a cart variable that
    gets reassigned `beforeEach` specification is run. It's assigned an instance of
    the cart store via `Ext.create`. Thanks to our configuration in the previous section,
    `Ext.create` will use `Ext.Loader` to automatically pull in the relevant source
    code file, including any dependencies. By reinstantiating before every test, we
    can be sure that a test later in the suite won't be affected by the way an earlier
    test has manipulated the cart.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的第一个套件简单地称为`Cart store`。我们有一个购物车变量，它在`beforeEach`规范运行之前被重新分配。它通过`Ext.create`分配一个购物车存储实例。多亏了上一节中的配置，`Ext.create`将自动拉入相关的源代码文件，包括任何依赖项。通过在每次测试之前重新实例化，我们可以确保套件中较晚的测试不会受到早期测试操纵购物车的方式的影响。
- en: 'We can now sketch out the functionality we''d like to test. The following code
    goes after the `beforeEach` call:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以勾勒出我们想要测试的功能。以下代码跟在`beforeEach`调用之后：
- en: '[PRE10]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'If we refresh the `SpecRunner.html` page, then we''ll actually be able to see
    something like this:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们刷新`SpecRunner.html`页面，我们实际上能看到类似这样的内容：
- en: '![Make it happen](img/5308OT_11_02.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![让事情发生](img/5308OT_11_02.jpg)'
- en: These specifications are just placeholders, but the fact that they show up in
    the runner is useful for developers practicing test first development. We can
    write a series of specification statements that describe the functionality we
    require, then the specs, and finally, the code itself. In this way, we're specifying
    the behavior we need and the code itself follows, and we can be safe in the knowledge
    that it meets our requirements. This can be a powerful methodology for an architect
    to spell out in detail how a class should behave.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这些规范只是占位符，但它们出现在运行器中对于练习测试优先开发的开发者来说很有用。我们可以编写一系列描述所需功能的规范语句，然后是规范，最后是代码本身。这样，我们指定了所需的行为，代码本身随后跟来，我们可以放心地知道它符合我们的要求。这对于架构师来说，可以是一个强大的方法，详细说明一个类应该如何表现。
- en: 'Let''s go through each spec one by one:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐个过一遍每个规范：
- en: '[PRE11]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'We expect that if `addProduct` is passed, something that is not a product model,
    it will throw an exception. We pass the method to the expect call prepopulated
    with an empty object literal. As this isn''t a product model—as expected—it throws
    an exception and satisfies the test as follows:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 我们期望如果`addProduct`传递的不是产品模型，而是其他东西，它将抛出一个异常。我们将方法传递给预填充空对象字面量的`expect`调用。正如预期的那样，这不是产品模型，因此它抛出一个异常，并如下满足测试：
- en: '[PRE12]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'When the product is added to the cart, we expect that it will cause a new line
    item to be created in the store. We simply check whether the cart count is as
    expected after adding a product:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当产品被添加到购物车时，我们期望这将在商店中创建一个新的行项目。我们简单地检查在添加产品后购物车数量是否符合预期：
- en: '[PRE13]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After adding a product that''s already in the cart, we expect that it will
    increase the quantity of the corresponding cart line. We pass in the same product
    twice and check whether the quantity is two, as expected:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加已经存在于购物车中的产品后，我们期望这将增加相应购物行项目的数量。我们传入相同的产品两次，并检查数量是否为预期的两个：
- en: '[PRE14]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This is a similar setup as the last test, but we are expecting that there will
    not be a duplicated cart line, but instead, there will be only one item in the
    cart.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 这与上一个测试的设置类似，但我们期望不会有一个重复的购物车行，而只会在购物车中有一个项目。
- en: 'With all of the specifications written, we can refresh the spec runner again:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写完所有规范后，我们可以再次刷新规范运行器：
- en: '![Make it happen](img/5308OT_11_03.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![让事情发生](img/5308OT_11_03.jpg)'
- en: As you can see, the specs are all in green, indicating that they have passed
    successfully.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，所有规范都是绿色的，表明它们已成功通过。
- en: This is just a brief primer on unit testing with Jasmine, but it demonstrates
    the power available and the utility of testing in this manner. It gives us confidence
    in the code we've written and ensures that any additions to the `addProduct` method
    won't break the functionality that already exists.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是关于使用 Jasmine 进行单元测试的简要入门，但它展示了可用的功能和以这种方式测试的实用性。它让我们对我们的代码充满信心，并确保对`addProduct`方法的任何添加都不会破坏现有的功能。
- en: Testing with robots
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用机器人进行测试
- en: 'Now that we''ve covered a method of testing the fine detail of our code, let''s
    look at a completely different way of running functional checks across the entire
    application. For this, we''ll need a new tool: CasperJS. It allows you to drive
    a "headless browser"—one without any user interface—navigate around an application,
    and run evaluations on what we find. The first step is installation, which varies
    depending on the platform. Instructions for the same can be found at [http://docs.casperjs.org/en/latest/installation.html](http://docs.casperjs.org/en/latest/installation.html).'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一种测试代码细节的方法，接下来让我们看看一种完全不同的在整个应用程序中运行功能检查的方法。为此，我们需要一个新的工具：CasperJS。它允许你驱动一个“无头浏览器”——一个没有用户界面的浏览器——在应用程序中导航，并对我们找到的内容进行评估。第一步是安装，这取决于平台。有关说明，请参阅[http://docs.casperjs.org/en/latest/installation.html](http://docs.casperjs.org/en/latest/installation.html)。
- en: When complete, we'll have a CasperJS command available to run.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 完成后，我们将有一个可用的CasperJS命令来运行。
- en: 'With Jasmine, we were using the behavior-driven method of testing with expectations
    to verify the code. In CasperJS, we go back to using the assertion style of testing.
    Take a look at a minimal test script from the CasperJS documentation:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用Jasmine时，我们使用带有期望的行为驱动测试方法来验证代码。在CasperJS中，我们回归使用断言风格的测试。看看CasperJS文档中的一个最小测试脚本：
- en: '[PRE15]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Pretty straightforward. The real magic comes when we combine this with CasperJS''s
    ability to control the headless browser and interface with the web page that forms
    our application. Check this out:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这相当直接。真正的魔法出现在我们将它与CasperJS控制无头浏览器和与构成我们应用程序的网页交互的能力结合起来时。看看这个：
- en: '[PRE16]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This looks a bit more exciting! Let''s break down what''s happening here:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来更有趣！让我们分析一下这里发生了什么：
- en: Create a new CasperJS test suite.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的CasperJS测试套件。
- en: Navigate to the Google home page.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到Google首页。
- en: Assert that the page title is as expected and that we can find the search box.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言页面标题与预期相符，并且我们可以找到搜索框。
- en: Fill in the search box and submit the form.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填充搜索框并提交表单。
- en: Then, when the page has loaded, assert that the URL is as expected and contains
    our search query as a parameter.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，当页面加载完成后，断言URL与预期相符，并且包含我们的搜索查询作为参数。
- en: Assert that there are at least ten search results on the page.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 断言页面上至少有十个搜索结果。
- en: Fantastic! This example shows how easy it's to use CasperJS to control a web
    page and how its testing features allow us to evaluate the content of the page
    and the behavior of an app.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！这个例子展示了如何轻松使用CasperJS控制网页，以及它的测试功能如何允许我们评估页面内容和应用程序的行为。
- en: The next step is to see how to use these features to test our own application,
    so let's hook CasperJS into our Alcohology project and get testing.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是看看如何使用这些功能来测试我们自己的应用程序，所以让我们将CasperJS集成到我们的Alcohology项目中并进行测试。
- en: Up and running with CasperJS
  id: totrans-104
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用CasperJS启动
- en: 'Let''s create a new subdirectory within our project at `tests/casper` and then
    create a new file in there called `Sanity.js`. We''re going to write a couple
    of simple checks to make sure the application is loading correctly. Here''s the
    starting point for the code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在项目中的`tests/casper`子目录下创建一个新的子目录，然后在那里创建一个名为`Sanity.js`的新文件。我们将编写一些简单的检查以确保应用程序正确加载。以下是代码的起点：
- en: '[PRE17]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'We kick off by calling the `casper.test.begin` method, which starts off a new
    test suite and takes three arguments: a description for the suite, the number
    of tests we expect should be run, and a callback function that is called when
    the suite is created. The callback gets passed on a test object on which we can
    call various assert methods.'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先调用`casper.test.begin`方法，它启动一个新的测试套件并接受三个参数：套件的描述、我们期望运行的测试数量，以及当套件创建时被调用的回调函数。回调函数接收一个测试对象，我们可以调用各种断言方法。
- en: We then call CasperJS's `start` method with the URL to our application. In order
    to trigger the test run, we call CasperJS's `run` method and when everything's
    complete, we call the `done` method on the test object.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们调用CasperJS的`start`方法并传入我们应用程序的URL。为了触发测试运行，我们调用CasperJS的`run`方法，当一切完成后，我们在测试对象上调用`done`方法。
- en: The first test we're going to write will check whether the category menu on
    the left-hand side of the application is populated as expected. To do this, we'll
    look for the first menu item and check whether it contains the text we expect,
    but it complicates matters slightly when we're loading this content in with Ajax.
    We need to be able to wait for the page to load, select the relevant element,
    and check whether it contains the content we'd expect.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要编写的第一个测试将检查应用程序左侧的类别菜单是否按预期填充。为此，我们将查找第一个菜单项并检查它是否包含我们期望的文本，但当我们使用 Ajax
    加载此内容时，这会稍微复杂一些。我们需要能够等待页面加载，选择相关元素，并检查它是否包含我们期望的内容。
- en: In order to select elements, we're going to use the CSS selector, and so on,
    but we need a mechanism to find the correct selector to use. Fortunately, Chrome
    Developer Tools will come to our rescue once more; if we right click on the **Pilsner**
    text in the top category menu item in Alcohology, then pick **Inspect Element**,
    the elements panel will display with the menu item's element selected.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了选择元素，我们将使用 CSS 选择器，等等，但我们需要一个机制来找到正确的选择器。幸运的是，Chrome 开发者工具将再次伸出援手；如果我们右键单击
    Alcohology 顶部类别菜单项中的 **Pilsner** 文本，然后选择 **检查元素**，元素面板将显示并选中该菜单项的元素。
- en: 'Next, right-click on the element and click on the **Copy CSS Path** option:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，右键单击元素并点击 **复制 CSS 路径**选项：
- en: '![Up and running with CasperJS](img/5308OT_11_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![CasperJS 运行状态](img/5308OT_11_05.jpg)'
- en: 'The CSS select of this `div` tag will be copied to your clipboard and should
    look like this:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `div` 标签的 CSS 选择器将被复制到你的剪贴板，并应如下所示：
- en: '[PRE18]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We can now use this with CasperJS:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以使用 CasperJS 来做这件事：
- en: '[PRE19]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'After telling CasperJS to start and load the application''s web page, we will
    use the `waitForSelector` method to wait until the specified selector appears
    on the page; by default, it''ll wait for 5 seconds before throwing up a failure
    message. When the selector appears, the callback function is triggered and we
    use the `assertSelectorHasText` method to check whether the `div` tag has the
    correct text:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在告诉 CasperJS 开始并加载应用程序的网页后，我们将使用 `waitForSelector` 方法等待指定的选择器出现在页面上；默认情况下，它将在
    5 秒后抛出失败消息。当选择器出现时，回调函数被触发，我们使用 `assertSelectorHasText` 方法来检查 `div` 标签是否有正确的文本：
- en: '![Up and running with CasperJS](img/5308OT_11_06.jpg)'
  id: totrans-118
  prefs: []
  type: TYPE_IMG
  zh: '![CasperJS 运行状态](img/5308OT_11_06.jpg)'
- en: Running our first CasperJS test
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 运行我们的第一个 CasperJS 测试
- en: It's simple, but effective. If we'd broken something due to an amend in the
    code for the categories store, incorrectly bound the data to the view model, or
    some other minor change that cascaded to affect this key feature, then this test
    would immediately flag it up.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单，但很有效。如果我们因为对类别存储代码的修改而破坏了某些东西，错误地将数据绑定到视图模型，或者由于其他一些微小的更改而级联影响这个关键功能，那么这个测试将立即指出。
- en: Note
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: CasperJS relies on another library called PhantomJS to drive the headless browser.
    There's an issue between the two in the current version that causes the `Unsafe
    JavaScript attempt…` message that you can see in the preceding screenshot; it's
    fine to ignore it.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: CasperJS 依赖于另一个名为 PhantomJS 的库来驱动无头浏览器。在当前版本中，这两个库之间存在一个问题，导致你可以在前面的屏幕截图中看到的“不安全的
    JavaScript 尝试...”消息；忽略它是可以的。
- en: We can do a lot more. Although the correct text is showing, the menu isn't just
    for display purposes, and when a user clicks on a menu item, it will load the
    products with this category. Can we create a CasperJS test for this?
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以做更多的事情。尽管正确的文本显示出来了，但菜单不仅仅是为了显示目的，当用户点击菜单项时，它将加载这个类别的产品。我们能为此创建一个 CasperJS
    测试吗？
- en: Of course we can! Take a look at the CasperJS API documentation at [http://docs.casperjs.org/en/latest/modules/casper.html#casper-prototype](http://docs.casperjs.org/en/latest/modules/casper.html#casper-prototype).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当然可以！请查看 CasperJS API 文档[http://docs.casperjs.org/en/latest/modules/casper.html#casper-prototype](http://docs.casperjs.org/en/latest/modules/casper.html#casper-prototype)。
- en: 'Alongside the `start` method, we have ones such as `fill` that allows you to
    complete form fields: `scrollTo`, which lets us move to a particular location
    on the page, and for our current purposes: `click`, it provides a means to click
    on an element specified by a selector. Let''s build another test using `click`
    to run a more advanced set of steps, something like this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了 `start` 方法之外，我们还有 `fill` 等方法，允许你填写表单字段：`scrollTo`，它让我们移动到页面上的特定位置，以及对我们当前目的：`click`，它提供了一个通过选择器指定元素进行点击的手段。让我们使用
    `click` 构建另一个测试，以运行更高级的步骤集，类似于这样：
- en: Load the application
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 加载应用程序
- en: Click on the **IPA** category
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 点击 **IPA** 类别
- en: Select the **Lagunitas IPA** product
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择**拉古尼塔斯IPA**产品
- en: Check whether the product window appear
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查产品窗口是否出现
- en: Check whether the correct product name and price appear
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查是否正确显示了产品名称和价格
- en: 'This is a much more comprehensive test that goes some way to demonstrating
    the power of CasperJS to replicate user actions and validate the behavior of our
    application. Here''s the code:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个更全面的测试，它在一定程度上展示了CasperJS复制用户操作和验证我们应用程序行为的能力。以下是代码：
- en: '[PRE20]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The comments in the code should make it pretty self-explanatory. After setting
    out all of the selectors we need, we wait for the categories and click on the
    one that we need. Next, we wait for the product we want and click on it before
    waiting for the product window to appear and asserting on its contents. For the
    final trick, we instruct CasperJS to take a screenshot, a feature that can be
    useful for debugging or further evaluation.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中的注释应该使其相当直观。在设置好所有需要的选择器后，我们等待类别出现并点击我们需要的那个。接下来，我们等待我们想要的产品出现并点击它，然后再等待产品窗口出现并对其内容进行断言。对于最后的技巧，我们指示CasperJS进行截图，这个功能对于调试或进一步评估可能很有用。
- en: 'Running this code gives us the following screenshot:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会给我们以下截图：
- en: '![Up and running with CasperJS](img/5308OT_11_07.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![使用CasperJS启动](img/5308OT_11_07.jpg)'
- en: Success! We've simulated and validated a small user path through the Alcohology
    application, checking whether several moving parts of our project work in tandem
    as expected.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 成功！我们已经模拟并验证了Alcohology应用程序中一个小型用户路径，检查了我们的项目中的几个动态部分是否按预期协同工作。
- en: The eagle-eyed reader will notice that the selectors in this example look a
    little more friendly than the ones in the first example that we grabbed using
    Google Chrome. There's a very good reason for this and it relates to a set of
    ideas surrounding making your application easier to test.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 留意细节的读者会注意到，这个例子中的选择器看起来比我们使用Google Chrome获取的第一个例子中的选择器友好一些。这有一个非常好的原因，并且与使你的应用程序更容易测试的一系列想法有关。
- en: Testability
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试性
- en: As with many aspects of software development, there are many different ways
    of testing. Some will advocate a test-first methodology, where the tests are created
    first and the code will be written to satisfy these tests. Whichever method is
    used, we need to take steps to make sure our code can be tested. While this occasionally
    means adding in some helpful hooks and tricks that are only used to test, we should
    generally try to avoid this approach and look to write code that is naturally
    testable; this will often have the fortunate consequence of being better code
    too.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 就像软件开发中的许多方面一样，有许多不同的测试方法。有些人会提倡测试优先的方法，即首先创建测试，然后编写代码以满足这些测试。无论使用哪种方法，我们都需要采取措施确保我们的代码可以测试。虽然这偶尔意味着添加一些仅用于测试的有用钩子和技巧，但我们应该尽量避免这种方法，并努力编写自然可测试的代码；这通常会有一个幸运的结果，那就是代码质量也会更好。
- en: 'Sometime back, we talked about selectors and their relationship to testability.
    Let''s look at the selector that Chrome Developer Tools gave us:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了选择器及其与测试性的关系。让我们看看Chrome开发者工具给我们提供的那个选择器：
- en: '[PRE21]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This is a very specific selector and the first part of it is using an ID that
    was autogenerated by Ext JS. As soon as we add or alter the component hierarchy
    of the application or change the records being displayed on the page, this will
    break and our CasperJS tests will fail.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常具体的选择器，它的第一部分使用了一个由Ext JS自动生成的ID。一旦我们添加或更改应用程序的组件层次结构或更改页面上显示的记录，这就会中断，我们的CasperJS测试将失败。
- en: We can increase testability of our application by ensuring that our test code
    is less brittle. In this case, we can leverage the CSS classes that we use to
    style our application. Back in [Chapter 9](ch09.html "Chapter 9. A Shopping Application"),
    *A Shopping Application*, when we built the category list view, we set the `bodyCls`
    configuration option to `categories-body`. This gives us a great way to target
    the list that we know isn't going to randomly change.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过确保我们的测试代码不那么脆弱来提高我们应用程序的测试性。在这种情况下，我们可以利用我们用来样式化应用程序的CSS类。在[第9章](ch09.html
    "第9章。购物应用程序")中，当我们构建类别列表视图时，我们将`bodyCls`配置选项设置为`categories-body`。这为我们提供了一个很好的方法来定位我们知道不会随机更改的列表。
- en: 'Using it in addition with the `nth-child` pseudo-selector gives us a simpler
    and more robust version of our original Developer Tools selector:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 结合使用`nth-child`伪选择器，我们可以得到一个更简单、更健壮的原始开发者工具选择器版本：
- en: '[PRE22]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In plain language, get the element with a class of `categories-body`, find the
    second child table, which corresponds to the second row, and grab its `td` cell
    element.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的话说，获取具有 `categories-body` 类的元素，找到第二个子表，它对应于第二行，然后获取其 `td` 单元格元素。
- en: Using Chrome Developer Tools is still a great way to look at the HTML structure
    of the page and work out an optimal selector for each case, but it's rarely going
    to provide the most robust selector.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chrome 开发者工具仍然是一种查看页面 HTML 结构并为每种情况找到最佳选择器的好方法，但它很少能提供最健壮的选择器。
- en: Should I or shouldn't I?
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我应该做还是不应该做？
- en: There's plenty of lively debate about how testing should inform your code, if
    at all. In the last example, we had a useful CSS selector that was already being
    used for styling, but in the event we hadn't already placed it there, should it
    have been added specifically to support styling?
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 关于测试应该如何影响你的代码，如果有的话，有很多热烈的讨论。在上一个例子中，我们有一个有用的 CSS 选择器，它已经被用于样式化，但如果我们还没有将其放置在那里，是否应该专门添加它来支持样式化？
- en: 'In this case, it''s a very minor change, so we probably don''t have to feel
    that bad about it. We could even wrap it in a Sencha Cmd directive to ensure that
    it doesn''t get included in production builds:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，这是一个非常小的改动，所以我们可能不必对此感到难过。我们甚至可以用 Sencha Cmd 指令将其包装起来，以确保它不会包含在生产构建中：
- en: '[PRE23]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: In general though, anything that adds complexity or maintenance overhead to
    our main code base just to improve testability should be avoided. Instead, we
    can look at ways in which the design of an application naturally promotes testability.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，总的来说，任何仅仅为了提高可测试性而增加我们的主要代码库复杂性和维护开销的东西都应该避免。相反，我们可以考虑应用设计如何自然地促进可测试性的方法。
- en: Earlier in the book, we talked about MVC and MVVM and how one of the benefits
    of such patterns is to promote the separation of code concerns. Throughout, we've
    used events to ensure that components can "fire-and-forget" and trigger actions
    without having an awareness of other parts of the system.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书早期，我们讨论了 MVC 和 MVVM 以及这种模式的一个好处是促进代码关注点的分离。在整个过程中，我们使用事件来确保组件可以“触发并忘记”并触发操作，而无需了解系统的其他部分。
- en: This is a key feature that gives an elegant, clear design combined with a side
    benefit of separation of components. We can pluck out individual views, render
    them alone on a simple page, and perform tests on a single component in isolation.
    As in our Jasmine examples at the start of the chapter, we can take a single model
    and instantiate it without having to worry about the user interface layers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个关键特性，它提供了一个优雅、清晰的设计，同时附带组件分离的额外好处。我们可以提取单个视图，在简单的页面上单独渲染它们，并对单个组件进行隔离测试。正如我们在本章开头提到的
    Jasmine 示例一样，我们可以取一个单独的模型并实例化它，而无需担心用户界面层。
- en: The beauty of good application architecture is that it provides an understandable
    application that immediately lends itself to testing. Although, integration testing
    is an important weapon in our arsenal, it's much more important to ensure that
    the various parts of the machine are well built before trying to fire the whole
    thing up.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 好的应用程序架构之美在于它提供了一个易于理解的应用程序，它立即适合于测试。尽管集成测试是我们武器库中的重要武器，但在尝试启动整个系统之前，确保机器的各个部分都构建得很好要重要得多。
- en: Faking it with mocks
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模拟来伪造
- en: 'When it''s up and running, our application still has one giant dependency:
    the server. During integration testing, this means that the server-side database
    needs to be primed with test data, and test suite will result in many requests
    being sent back and forth. In a large test suite, this can be slow and the database
    setup can be painful.'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 当它运行起来时，我们的应用程序仍然有一个巨大的依赖：服务器。在集成测试期间，这意味着服务器端数据库需要预先填充测试数据，测试套件将导致许多请求来回发送。在一个大型测试套件中，这可能会很慢，数据库设置可能会很痛苦。
- en: A common resolution to this problem is to bypass the server API altogether.
    When our application makes an Ajax request, we can hijack the `XMLHttpRequest`
    and feed the calling code some static test data instead.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的常见方法是完全绕过服务器 API。当我们的应用程序发出 Ajax 请求时，我们可以劫持 `XMLHttpRequest` 并向调用代码提供一些静态测试数据。
- en: To demonstrate this and show the flexibility of the technique, we'll create
    a small Jasmine test case that shows how to supply a product store with mock JSON
    data. Although, faking an Ajax request is really useful in integration tests,
    this will show off the technique in a succinct way that can be used in both unit
    and integration testing.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示这一点并展示该技术的灵活性，我们将创建一个小型的 Jasmine 测试用例，展示如何向产品存储提供模拟 JSON 数据。尽管伪造 Ajax 请求在集成测试中非常有用，但这将以简洁的方式展示该技术，这种方式可以用于单元测试和集成测试。
- en: 'We''ll be using a feature of Ext JS that isn''t included by default: `Simlets`.
    The classes that implement `Simlets` are included in the `examples` directory
    of the Ext JS distribution, so all we have to do is open up the `SpecRunner.html`
    file from earlier in the chapter and amend it to instruct `Ext.Loader` to pull
    in the files from the correct location:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 Ext JS 中默认不包含的功能：`Simlets`。实现 `Simlets` 的类包含在 Ext JS 分发的 `examples` 目录中，所以我们只需要打开本章早些时候的
    `SpecRunner.html` 文件，并修改它以指导 `Ext.Loader` 从正确的位置拉入文件：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'All we''ve added is the line for the `Ext.ux` path. Now, we can build our Jasmine
    test, so let''s dive straight into the code:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加的只是一行 `Ext.ux` 路径。现在，我们可以构建我们的 Jasmine 测试，让我们直接进入代码：
- en: '[PRE25]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Lots going on here! First, we set up a couple of variables, one to contain the
    `productStore` between tests and one containing our fake JSON.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有很多事情在进行！首先，我们设置了一些变量，一个用于在测试之间包含 `productStore`，另一个包含我们的模拟 JSON。
- en: In the `beforeEach` function call, we load in the `SimletManager` class and
    the `Product` model from Alcohology; `Ext.Loader` will pull in the files for us
    before allowing execution to proceed to the next lines. Next, we set up `SimletManager`
    by registering the URL to be intercepted and the data that should be returned
    instead of the normal server response.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `beforeEach` 函数调用中，我们加载了 Alcohology 中的 `SimletManager` 类和 `Product` 模型；`Ext.Loader`
    将在允许执行继续到下一行之前为我们拉入文件。接下来，我们通过注册要拦截的 URL 和应该返回的数据而不是正常的服务器响应来设置 `SimletManager`。
- en: This is actually all we need to set up a fake request; the rest of the code
    proceeds as if it were a normal Jasmine test in which we set two expectations
    after the product store loads, that is, there will be one returned record and
    its name will be set to `Test Product`, just like in the test data.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是我们设置模拟请求所需的所有内容；其余的代码将像正常的 Jasmine 测试一样继续执行，其中我们在产品存储加载后设置两个期望，即将返回一条记录，其名称设置为
    `Test Product`，就像在测试数据中一样。
- en: Running the test through the spec runner sees everything pass as expected and
    demonstrates the power of this technique. We can disconnect all of our testing
    from the backend and run independent of a database; test data is supplied directly
    in the tests and not in a database row somewhere on a server.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 通过规格运行器运行测试，所有预期的情况都通过了，并展示了该技术的强大功能。我们可以将所有测试与后端断开连接，独立于数据库运行；测试数据直接在测试中提供，而不是在服务器上某个数据库行中。
- en: Continuous coverage
  id: totrans-168
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 持续覆盖
- en: You've learned how to use a couple of different testing tools in this chapter,
    but what about when to use these tools?
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你在本章中学习了如何使用几个不同的测试工具，但当你使用这些工具时怎么办？
- en: When it comes to code testing, there's a metric known as "code coverage" that
    tells us the percentage of our code that is covered by tests. The first thought
    of a passionate architect starting a new project is that everything should be
    covered with tests, tests everywhere!
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到代码测试时，有一个称为“代码覆盖率”的度量标准，它告诉我们我们的代码中有多少百分比被测试覆盖。一个热情的建筑师在开始一个新项目时的第一个想法是，一切都应该被测试覆盖，到处都是测试！
- en: Realistically, there are things that we just don't need to test; as always,
    we should take a pragmatic approach. Configuration of components probably doesn't
    need to be tested; we don't need to test the return values from third-party code
    libraries; there are many examples.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，有些事情我们根本不需要测试；像往常一样，我们应该采取实用主义的方法。组件的配置可能不需要测试；我们不需要测试第三方代码库的返回值；有很多例子。
- en: Having said that, code coverage is a useful way to make sure that a certain
    level of testing is maintained in a project. For example, we might wish to have
    90 percent test coverage of our model code and only 50 percent coverage on our
    controllers, which contain more boilerplate that doesn't need to be tested. The
    exact ratios will depend on the project, the developers, and indeed the architect.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，代码覆盖率是确保项目中保持一定测试水平的有用方法。例如，我们可能希望我们的模型代码有 90% 的测试覆盖率，而控制器只有 50% 的覆盖率，因为控制器中包含更多不需要测试的样板代码。确切的比率将取决于项目、开发者和架构师。
- en: Note
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are many code coverage tools for JavaScript, one of which is Istanbul.
    It provides a comprehensive set of features to check code coverage in a variety
    of ways and reports on the level of coverage in a range of formats. You can find
    this on GitHub at [https://github.com/gotwarlost/Istanbul](https://github.com/gotwarlost/Istanbul).
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 JavaScript，有许多代码覆盖率工具，其中之一是 Istanbul。它提供了一套全面的特性，以多种方式检查代码覆盖率，并以多种格式报告覆盖率水平。你可以在
    GitHub 上找到它：[https://github.com/gotwarlost/Istanbul](https://github.com/gotwarlost/Istanbul)。
- en: 'When a project is well covered by unit tests and integration tests are in place
    to make sure the user experience remains consistent, we''re left with one part
    of the puzzle: when to run these tests?'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个项目被单元测试很好地覆盖，并且有集成测试来确保用户体验保持一致时，我们只剩下拼图的一个部分：何时运行这些测试？
- en: Of course, a developer should be running the relevant tests for the section
    of code they're working on, but in reality, a full test suite can take a long
    time to execute. In such cases, we can make use of something called **continuous
    integration** (**CI**).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，开发者应该运行他们正在工作的代码部分的相应测试，但在现实中，一个完整的测试套件可能需要很长时间才能执行。在这种情况下，我们可以利用一种称为**持续集成**（**CI**）的东西。
- en: Note
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Jenkins CI is an open source CI system ([http://jenkins-ci.org/](http://jenkins-ci.org/))
    and Circle CI ([https://circleci.com/](https://circleci.com/)) is paid for, but
    with a free plan.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: Jenkins CI 是一个开源的 CI 系统（[http://jenkins-ci.org/](http://jenkins-ci.org/)），而
    Circle CI（[https://circleci.com/](https://circleci.com/））是付费的，但有一个免费计划。
- en: Whenever a developer pushes new code to the source control repository, a CI
    server grabs that code and runs the tests. This enables us to see when a developer
    has committed code that breaks the current build; it also gives us peace of mind
    that a successful CI build will be one that has passed our automated checks and
    is well on its way to production.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 每当开发者将新代码推送到源代码控制仓库时，CI 服务器就会抓取这些代码并运行测试。这使我们能够看到开发者提交了破坏当前构建的代码；这也让我们放心，成功的
    CI 构建将是通过我们的自动化检查并且正在顺利进入生产的构建。
- en: Summary
  id: totrans-180
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Testing is a huge topic with many different libraries, programs, and techniques
    vying for the attention of software architects. As with many facets of our role,
    there's never one correct answer and the most important thing is to settle on
    something that works for our particular project.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是一个庞大的主题，涉及许多不同的库、程序和技术，它们都在争夺软件架构师的关注。正如我们角色的许多方面一样，没有唯一的正确答案，最重要的是确定适合我们特定项目的方法。
- en: In this chapter, we've reviewed a range of different ideas and approaches to
    testing Ext JS and touched on the ways in which we can ensure our architectural
    decisions trickle down into making testing easier. The different extremes of test—from
    unit to integration—can always benefit when we isolate certain parts of the system
    under test, from remote requests through to separation of code concerns.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了各种不同的测试 Ext JS 的想法和方法，并触及了确保我们的架构决策能够简化测试的方法。从单元测试到集成测试，测试的不同极端总会在我们将测试系统中的某些部分隔离出来时受益，从远程请求到代码关注点的分离。
- en: Testing is an essential, yet often neglected part of Ext JS application architecture
    and this chapter is only an overview. This, and the other topics covered in this
    book, must be used in combination and alongside a constant search for new ideas
    in order to truly master the concepts we've touched on.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 测试是 Ext JS 应用程序架构的一个基本但常常被忽视的部分，而本章只是一个概述。这本书中涵盖的其他主题必须结合使用，并且要不断寻找新想法，才能真正掌握我们触及的概念。
