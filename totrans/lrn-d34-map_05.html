<html><head></head><body>
        

                            
                    <h1 class="header-title">Click-Click Boom! Applying Interactivity to Your Map</h1>
                
            
            
                
<p>In the previous chapter, you learned what is needed to build a basic map with D3.js. We also discussed the concepts of enter, update, and exit and how they apply to maps. You should also understand how D3 mixes and matches HTML with data. However, let's say you want to take it a step further and add more interactivity to your map. We covered only the tip of the iceberg regarding click events in the previous chapter. Now, it's time to dig deeper.</p>
<p>In this chapter, we will expand our knowledge of events and event types. We will progress by experimenting and building upon what you've learned. The following topics are covered in this chapter:</p>
<ul>
<li>Events and how they occur</li>
<li>Experiment 1 - hover events and tooltips</li>
<li>Experiment 2 - tooltips with visualizations</li>
<li>Experiment 3 - panning and zooming</li>
<li>Experiment 4 - orthographic projections</li>
<li>Experiment 5 - rotating orthographic projections</li>
<li>Experiment 6 - dragging orthographic projections</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Events and how they occur</h1>
                
            
            
                
<p>The following is taken directly from the w3 specifications:</p>
<p>"The Event interface is used to provide contextual information about an event to the handler processing the event. An object that implements the Event interface is generally passed as the first parameter to an event handler. More specific context information is passed to event handlers by deriving additional interfaces from Event which contain information directly relating to the type of event they accompany. These derived interfaces are also implemented by the object passed to the event listener."</p>
<p>In other words, an event is a user input action that takes place in the browser. If your user clicks, touches, drags, or rotates, an event will fire. If you have event listeners registered to those particular events, the listeners will catch the event and determine the event type. The listeners will also expose properties associated with the event. For example, if we want to add an event listener in plain JavaScript, we would add the following lines of code:</p>
<pre>&lt;body&gt; 
  &lt;button id="btn"&gt;Click me&lt;/button&gt; 
 
  &lt;script&gt; 
    varbtn = document.getElementById('btn'); 
    btn.addEventListener('click', function() { 
      console.log('Hello world'); }, false ); 
  &lt;/script&gt; 
&lt;/body&gt; </pre>
<p>Note that you first need to have the button in the DOM in order to get its ID. Once you have it, you can simply add an event listener to listen to the element's click event. The event listener will catch the click event every time it fires and logs <kbd>Hello world</kbd> to the console.</p>
<p>Until jQuery, events were very tricky, and different browsers had different ways of catching these events. However, thankfully, this is all in the past. Now, we live in a world where modern browsers are more consistent with event handling.</p>
<p>In the world of D3, you won't have to worry about this. Generating events, catching them, and reacting to them is baked into the library and works across all browsers. A good example of this is the hover event.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 1 – hover events and tooltips</h1>
                
            
            
                
<p>Building on our previous example, we can easily swap our <kbd>click</kbd> method with a <kbd>hover</kbd> method. Instead of having <kbd>var click</kbd>, we will now have <kbd>var hover</kbd> with the corresponding function. Feel free to open <kbd>example-1.html</kbd> of the <kbd>chapter-5</kbd> code base to go over the complete example (<kbd>http://localhost:8080/chapter-5/example-1.html</kbd>). Let's review the necessary code to change our click event to a hover event. In this particular case, we will need a little more CSS and HTML. In our <kbd>&lt;style&gt;</kbd> tag, add the following lines:</p>
<pre>#tooltip{ 
position: absolute; 
z-index: 2; 
background: rgba(0,153,76,0.8); 
width:130px; 
height:20px; 
color:white; 
font-size: 14px; 
padding:5px; 
top:-150px; 
left:-150px; 
font-family: "HelveticaNeue-Light", "Helvetica Neue Light", <br/> "Helvetica Neue", Helvetica, Arial, "Lucida Grande", sans-serif; 
} </pre>
<p>This style is for a basic tooltip. It is positioned <strong>absolutely</strong> so that it can take whatever <em>x</em> and <em>y</em> coordinates we give it (left and top). It also has some filler styles for the fonts and colors. The <kbd>tooltip</kbd> is styled to the element in the DOM that has the ID of <kbd>#tooltip</kbd>:</p>
<pre>&lt;div id="tooltip"&gt;&lt;/div&gt; </pre>
<p>Next, we add the logic to handle a <kbd>hover</kbd> event when it is fired:</p>
<pre>var hover = function(d) { 
  var div = document.getElementById('tooltip'); 
  div.style.left = event.pageX +'px'; 
  div.style.top = event.pageY + 'px'; 
  div.innerHTML = d.properties.NAME_1; 
}; </pre>
<p>This function, aside from logging the event, will find the DOM element with an ID of <kbd>tooltip</kbd> and position it at the <em>x</em> and <em>y</em> coordinates of the event. These coordinates are a part of the properties of the event and are named <kbd>pageX</kbd> and <kbd>pageY</kbd>, respectively. Next, we will insert text with the state name (<kbd>d.properties.NAME_1</kbd>) into the <kbd>tooltip</kbd>:</p>
<pre>//Enter 
mexico.enter() 
  .append('path') 
  .attr('d', path) 
  .on("mouseover", hover); </pre>
<p>Finally, we will change our binding from a click to a <kbd>mouseover</kbd> event in the on section of the code. We will also change the event handler to the <kbd>hover</kbd> function we created earlier.</p>
<p>Once the changes have been saved and viewed, you should notice basic tooltips on your map:</p>
<div><img height="394" width="595" src="img/e2101ebd-e276-43e9-848e-064c471387c3.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 2 – tooltips with visualizations</h1>
                
            
            
                
<p>In this next experiment, we will enhance our tooltips with additional visualizations. In a similar fashion, we will outline the additional code to provide this functionality (<kbd>http://localhost:8080/chapter-5/example-2.html</kbd>).</p>
<p>To our CSS, we will need to add the following lines of code:</p>
<pre>#tooltip svg{ 
border-top:0; 
margin-left:-5px; 
margin-top:7px; 
} </pre>
<p>This will style our SVG container (inside our tooltip DOM element) to align it with the label of the state.</p>
<p>Next, we'll include two new scripts to create visualizations:</p>
<pre>&lt;script src="img/base.js"&gt;&lt;/script&gt; 
&lt;script src="img/sparkline.js"&gt;&lt;/script&gt; </pre>
<p>The preceding JavaScript files contain the D3 code for creating a line chart visualization. The chart itself contains and leverages the <em>Towards</em> <em>Reusable Chart</em> described by Mike Bostock at: <a href="http://bost.ocks.org/mike/chart/">http://bost.ocks.org/mike/chart/</a>. Feel free to examine the code; it is a very simple visualization that follows the enter, update, and exit pattern. We will explore this chart further in <a href="ded15f0d-44ff-4b2d-a2ac-ecbba7d5dd63.xhtml">Chapter 7</a>, <em>Testing</em>:</p>
<pre>var db = d3.map(); 
var sparkline = d3.charts.sparkline().height(50).width(138); </pre>
<p>We will now declare two new variables. The <kbd>db</kbd> variable will hold a hashmap to quickly lookup values by <kbd>geoID</kbd>. The <kbd>sparkline</kbd> variable is the function that will draw our simple line chart:</p>
<pre>var setDb = function(data) { 
  data.forEach(function(d) { 
    db.set(d.geoID, [ 
       {"x": 1, "y": +d.q1}, 
       {"x": 2, "y": +d.q2}, 
       {"x": 3, "y": +d.q3}, 
       {"x": 4, "y": +d.q4} 
    ]); 
  }); 
}; </pre>
<p>This function parses data and formats it into a structure that the <kbd>sparkline</kbd> function can use to create the line chart:</p>
<pre>var geoID = function(d) { 
  return "c" + d.properties.ID_1; 
}; </pre>
<p>We will bring back our <kbd>geoID</kbd> function from <a href="c22382c6-84d9-411f-b795-681df2321005.xhtml">Chapter 4</a>, <em>Creating a Map</em>, in order to quickly create unique IDs for each state:</p>
<pre>var hover = function(d) { 
  var div = document.getElementById('tooltip'); 
  div.style.left = event.pageX +'px'; 
  div.style.top = event.pageY + 'px'; 
  div.innerHTML = d.properties.NAME_1; 
 
  var id = geoID(d); 
  d3.select("#tooltip").datum(db.get(id)).call(sparkline.draw); 
}; </pre>
<p>For our hover event handler, we need to add two new lines. First, we will declare an ID variable that holds the unique <kbd>geoID</kbd> for the state we are hovering over. Then, we will call our <kbd>sparkline</kbd> function to draw a line chart in the <kbd>tooltip</kbd> selection. The data is retrieved from the preceding <kbd>db</kbd> variable. For more information on how the call works, refer to: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call</a>:</p>
<pre>d3.csv('states-data.csv', function(data) { 
  setDb(data); 
}); </pre>
<p>We load our <kbd>.csv</kbd> file via AJAX and invoke the <kbd>setDb()</kbd> function (described earlier).</p>
<p>You should now see a map that displays a <kbd>tooltip</kbd> with a line chart for every state in Mexico. In summary:</p>
<ol>
<li>The map is drawn as usual.</li>
<li>We will create a small lookup <kbd>db</kbd> that contains additional data about each state.</li>
<li>Then, we will register a hover event that fires whenever the user's mouse passes over a state.</li>
<li>The hover event fires and retrieves data about the state.</li>
<li>The hover event also places the name of the state in the DOM and calls a function that creates a line chart with the retrieved data:
<div><img height="314" width="472" src="img/2f2788b5-1820-4e55-b32f-d3465e138d29.png"/></div>
</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 3 – panning and zooming</h1>
                
            
            
                
<p>A very common request when working with maps is to provide the ability to pan and zoom around the visualization. This is especially useful when a large map contains abundant detail. Luckily, D3 provides an event listener to help with this feature. In this experiment, we will outline the principles to provide basic panning and zooming for your map. This experiment requires us to start with <kbd>example-1.html</kbd>; however, feel free to look at <kbd>http://localhost:8080/chapter-5/example-3.html</kbd> for reference.</p>
<p>First, we will add a simple CSS class in our <kbd>&lt;style&gt;</kbd> section; this class will act as a rectangle over the entire map. This will be our zoomable area:</p>
<pre>.overlay { 
fill: none; 
pointer-events: all; 
} </pre>
<p>Next, we need to define a function to handle the event when the zoom listener is fired. The following function can be placed right below the map declaration:</p>
<pre>var zoomed = function () { 
  map.attr("transform", "translate("+ d3.event.translate + ")<br/>   scale(" + d3.event.scale + ")"); 
}; </pre>
<p>This function takes advantage of two variables exposed while panning and zooming: <kbd>d3.event.scale</kbd> and <kbd>d3.event.translate</kbd>. The variables are defined as follows:</p>
<ul>
<li><kbd>d3.event.scale</kbd>: This defines the zoom level in terms of an SVG scale.</li>
<li><kbd>d3.event.translate</kbd>: This defines the position of the map in relation to the mouse in terms of an SVG translate.</li>
</ul>
<p>With this information available, we can set the SVG attributes (scale and translate) of the map container to the event variables:</p>
<pre>var zoom = d3.behavior.zoom() 
    .scaleExtent([1, 8]) 
    .on("zoom", zoomed); 
    .size([width, height]); </pre>
<p>Similar to the hover event listener, we need to create a new zoom event listener. Create the preceding function after the <kbd>zoom()</kbd> function. Note that there is one additional setting to understand, <kbd>scaleExtent()</kbd>.</p>
<p>The <kbd>scaleExtent()</kbd> setting provides a scale range of the zooming amount. The first element in the array is the maximum that the map can zoom out. The second element in the array is the maximum that the map can zoom in. Remember that <kbd>1</kbd> is the original size of our map based on our bounding-box formula from <a href="c22382c6-84d9-411f-b795-681df2321005.xhtml">Chapter 4</a>, <em>Creating a Map</em>. The minimum value that <kbd>scaleExtent()</kbd> can be set to is <kbd>0</kbd>, to zoom out. In <kbd>example-3.html</kbd>, alter these numbers to get a feel of how they work. For example, if you change <kbd>1</kbd> to <kbd>5</kbd>, you will see that the map can zoom out to half its original size.</p>
<p>There are additional settings to this event listener that can be reviewed at: <a href="https://github.com/mbostock/d3/wiki/Zoom-Behavior">https://github.com/mbostock/d3/wiki/Zoom-Behavior</a>:</p>
<pre>svg.append("rect") 
      .attr("class", "overlay") 
      .attr("width", width) 
      .attr("height", height) 
      .call(zoom); </pre>
<p>Finally, right after the <kbd>mexico.exit</kbd> section, we will add a transparent rectangle to the entire visualization and bind the new listener. Remember that the rectangle is using the CSS class we defined at the beginning of the experiment.</p>
<p>Now, you should have full zooming and panning capabilities on the Mexican map. You can either double-click to zoom in or use your scroll wheel. The interactions should also work for swipe and pinch gestures on a tablet:</p>
<div><img height="258" width="389" src="img/644dc9cc-0d9f-452e-95b3-64cea8a3e087.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 4 – orthographic projections</h1>
                
            
            
                
<p>For the next set of experiments in this chapter, we will switch gears and look at interactivity with orthographic projections (representing a three-dimensional map on a two-dimensional screen). A better visualization to illustrate these concepts is the entire globe instead of a single country. This experiment will start with <kbd>http://localhost:8080/chapter-5/example-4.html</kbd> and require a new datafile, which is provided for you. You will notice that the code base is almost identical, with the exception of three changes that we will outline here:</p>
<pre>var height = 600; 
var width = 900; 
var projection = d3.geo.orthographic().clipAngle(90); 
var path = d3.geo.path().projection(projection); </pre>
<p>First, we will change our <kbd>d3.geo</kbd> projection from <kbd>d3.geo.mercator</kbd> to <kbd>d3.geo.orthographic</kbd>. We also have an additional setting to configure: the <kbd>clipAngle</kbd> at <kbd>90</kbd> degrees. This places an imaginary plane through the globe and clips the back of the projection:</p>
<pre>d3.json('world.json', function(data) { 
var countries = topojson.feature(data, data.objects.countries); 
var map = svg.append('g').attr('class', 'boundary'); 
var world = map.selectAll('path').data(countries.features); </pre>
<p>Next, we will substitute the old <kbd>geo-data.json</kbd> file for the new datafile, <kbd>world.json</kbd>. We will also set up new variables for our data joining in order to provide better readability in the code:</p>
<pre>world.enter() 
      .append('path') 
      .attr('d', path); </pre>
<p>As we have seen many times now, we will apply the standard <kbd>enter()</kbd> pattern. You should now have a static map of the globe, as seen in the following screenshot. You can also work directly with <kbd>example-4.html</kbd>.</p>
<p>In the last two sections, we will bring the globe to life!</p>
<div><img height="311" width="307" src="img/36a69fdf-fade-4ec3-94f7-c3e6690a03e8.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 5 – rotating orthographic projections</h1>
                
            
            
                
<p>Our previous example was very fascinating. We went from visualizing a map in two dimensions to three dimensions with just a few lines. The next step is to animate it. For this experiment, open <kbd>http://localhost:8080/chapter-5/example-5.html</kbd> in the code samples. Let's now piece it together:</p>
<pre>var i = 0; </pre>
<p>We added an index variable that will hold the rotation rate. Don't worry; we'll explain how this is used here:</p>
<pre>d3.json('world.json', function(data) { 
var countries = topojson.feature(data, data.objects.countries); 
var mexico = countries.features[102]; </pre>
<p>As Mexico is the center of the universe and requires special attention, we isolated it into its own variable by taking the corresponding feature from the countries' feature array. This will allow us to manipulate it separately from the rest of the globe:</p>
<pre>var map = svg.append('g').attr('class', 'boundary'); 
var world = map.selectAll('path').data(countries.features); 
var mexico = map.selectAll('.mexico').data([mexico]); </pre>
<p>Next, we will data join the information we isolated earlier to its own variable. This way, we will have one map that represents the entire world and another one that represents just Mexico:</p>
<pre>mexico.enter() 
  .append('path') 
  .attr('class', 'mexico') 
  .attr('d', path) 
  .style('fill', 'lightyellow').style('stroke', 'orange'); </pre>
<p>We will inject the map of Mexico and apply the <kbd>geo.path</kbd> that contains the same projection we used for the world map. We will also add a light yellow background to Mexico using the <kbd>fill</kbd> CSS style and an orange border using the stroke:</p>
<pre>setInterval(function() { 
i = i+0.2; 
      // move i around in the array to get a feel for yaw, pitch 
      // and roll 
      // see diagram 
projection.rotate([i,0,0]) 
world.attr('d', path); 
mexico.attr('d', path)<br/>   .style('fill', 'lightyellow').style('stroke', 'orange'); 
    }, 20); </pre>
<p>This is where the action starts, literally. We created an interval that executes every 20 milliseconds. This interval contains a function that utilizes our index variable and increments the value by <kbd>0.2</kbd>. This value is then applied to the <kbd>rotate</kbd> function of our projection. Specifically, we will adjust the rotation every <kbd>20</kbd> ms on this line of code:</p>
<pre>projection.rotate([i,0,0]) </pre>
<p>Yaw is represented by the first value of the array (in this case, <kbd>i</kbd>), pitch represented by the second value, and roll by the third value. Yaw, pitch, and roll are rotation angles and are applied in their respective vectors. The following image provides an illustration of how the angles rotate:</p>
<div><img src="img/4e02e608-c616-4261-b527-1a2d6c55e0c2.png"/></div>
<p>Here, we see that the yaw vector points in the <em>z</em> direction and is around the center axis. The pitch goes along our <em>x</em> axis, and the yaw goes around our <em>y</em> axis. The Greek characters (in parentheses in the preceding image) are often used to depict yaw, pitch, and roll.</p>
<p>In our case, the index variable, <kbd>i</kbd>, is increasing and is allocated to the yaw rotation. This means that our globe will spin from left to right around the center axis. If we were to swap the position of our index so that it is in the pitch location (the second array element), our globe would spin vertically:</p>
<pre>project.rotate([0,i,0]); </pre>
<p>Finally, we will use the same D3 update pattern and update all the paths with the new projection. Give it a shot, play around with the example, and see how the globe spins in different directions. When complete, you will see the rotating globe in your browser, as in the following screenshot:</p>
<div><img height="417" width="364" src="img/a7deb056-1d3c-4323-87a0-c2731f5e91f5.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Experiment 6 – dragging orthographic projections</h1>
                
            
            
                
<p>For our last example, we will add the ability to drag our globe so that the user can spin it to the left or right. Open <kbd>http://localhost:8080/chapter-5/example-6.html</kbd> from the code samples and let's get started:</p>
<pre>var dragging = function(d) { 
var c = projection.rotate(); 
projection.rotate([c[0] + d3.event.dx/2, c[1], c[2]]) 
 
world.attr('d', path); 
mexico.attr('d', path) 
        .style('fill', 'lightyellow').style('stroke', 'orange'); 
}; </pre>
<p>Our first piece of new code is our dragging event handler. This function will be executed every time the user drags the mouse on the screen. The algorithm executes the following steps:</p>
<ol>
<li>Stores the current rotation value.</li>
<li>Updates the projection's rotation based on the distance it is dragged.</li>
<li>Updates all the paths in the world map.</li>
<li>Updates all the paths in the map of Mexico.</li>
</ol>
<p>The second step deserves a little more explanation. Just like the <kbd>d3.behavior.zoom</kbd> event handler, <kbd>d3.behavior.drag</kbd> exposes information about the performed action. In this case, <kbd>d3.event.dx</kbd> and <kbd>d3.event.dy</kbd> indicate the distance dragged from the previous location. The <kbd>c[0] + d3.event.dx/2</kbd> code tells us that we need to take the previous yaw value and add the amount of drag the user is performing. We will divide the drag amount by two to slow down the rotation by half; otherwise, every pixel the user drags will correlate to <em>1</em> degree of rotation:</p>
<pre>var drag = d3.behavior.drag() 
    .on("drag", dragging); </pre>
<p>Next, we will bind our <kbd>dragging</kbd> method to our drag event, as we saw earlier, with click, hover, and zoom:</p>
<pre>svg.append("rect") 
      .attr("class", "overlay") 
      .attr("width", width) 
      .attr("height", height) 
      .call(drag); </pre>
<p>Finally, we need an area to bind our drag event. Using our previous technique, we will add a transparent rectangle on top of the visualization. This will allow us to very clearly detect the <em>x</em> and <em>y</em> positions on our SVG element.</p>
<p>Give it a spin! You'll notice that if you click-and-drag the world, it will spin in the corresponding yaw direction:</p>
<div><img height="381" width="362" src="img/3097f608-1f0f-412b-959b-d0159a2e35c5.png"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>We covered many examples to get you started with interactivity for your D3 map visualizations. We went over the basics of event handling, explored various methods to bind events to the map, outlined the two <kbd>d3.behavior</kbd> APIs, and even dipped our toes into orthographic projections. If you wish to dig deeper into world rotations, and the math involved, check out the Jason Davies article at: <a href="http://www.jasondavies.com/maps/rotate/">http://www.jasondavies.com/maps/rotate/</a>.</p>
<p>After two chapters of drawing and interacting with maps, the next chapter will explain how to obtain geo data in order to create any map you want. We'll also include some techniques to optimize the data files for viewing the web.</p>


            

            
        
    </body></html>