<html><head></head><body>
		<div><h1 id="_idParaDest-88"><em class="italic"><a id="_idTextAnchor087"/>Chapter 5</em>: Waiting for elements and network calls</h1>
			<p>I won't say I'm old, but I started browsing the internet in the late 90s. So yes, I'm old. Back then, you would sometimes have to wait over a minute to get a page loaded. You might be thinking, "So if you had 10 tabs open, that would be impossible to use." Well, browsers didn't have tabs! Downloading one single MP3 file could take you an hour.</p>
			<p>In the early 2000s, the web got into the corporate world, and we started developing business apps using websites. But that was a decision from an IT department. Old terminal apps were hard to update and introduce new features, and desktop apps were hard to distribute. Web apps were the IT department's solution, leaving users with slow and non-user-friendly web apps. </p>
			<p>Developers were trying to do their best with the tools they had back then. Pages were mostly generated on the server side using tools such as ASP 3.0 or PHP. AJAX was used for small tasks, such as loading the state's list based on a country selection without reloading the entire page.</p>
			<p>In the late 2000s, Google launched <em class="italic">Gmail</em>, showing the world how the web should look. But the bar was too high for developers. Developing those kinds of apps was unthinkable for developers just trying to build CRUD pages.</p>
			<p>Nowadays, our web looks different. Developers are now able to create rich experiences, even for more straightforward scenarios. </p>
			<p>But there is a thing that didn't change in all these years: <strong class="bold">You have to wait</strong>.</p>
			<p>You have to wait for the site to load, for the data to be refreshed, for the new page to be opened, for the form to be submitted. You have to wait.</p>
			<p>Waiting for the right moment to act is key to avoid having flaky tests. A flaky test is a test that sometimes passes and sometimes fails. You have to consider flaky tests as a bug, not in the app but in your tests. Flaky tests bring many problems:</p>
			<ul>
				<li>They are a waste of time. Nobody wants to merge a pull request with the tests in red. So, they will repeatedly run the tests until they get all the tests green.</li>
				<li>Flaky tests are a false alarm. Suppose the developer doesn't know that the test is flaky. They might try to find a non-existent bug.</li>
				<li>Flaky tests hurt your tests' reputation. The loss of reputation begins by skipping one flaky test. If you have more flaky tests, the team might move your tests to a nightly process. If your tests keep being flaky, they might be removed from the CI process. You lose, and your team losses.</li>
			</ul>
			<p>Waiting for the right moment to act is the key to making stable UI tests.</p>
			<p>In this chapter, we will learn about the tools that Puppeteer provides to act at the right moment. We will also learn different techniques and approaches, so you can know how you can wait for the page to be ready, for an input to be visible, or for a request to be made, among many other things.</p>
			<p>This chapter is about <strong class="bold">waiting</strong>, a key topic in web automation. I also want to show you a Puppeteer recorder so that you can add one more tool to your toolbox. We will cover the following topics in this chapter:</p>
			<ul>
				<li>Waiting for the page to load</li>
				<li>Waiting for elements</li>
				<li>Waiting for network calls</li>
				<li>Waiting for page events</li>
				<li>Bonus: Headless Recorder</li>
			</ul>
			<p>Let's start at the beginning. How do you know that the page is already loaded?</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Technical requirements</h1>
			<p>You will find all the code of this chapter on the GitHub repository (<a href="https://github.com/PacktPublishing/UI-Testing-with-Puppeteer">https://github.com/PacktPublishing/UI-Testing-with-Puppeteer</a>) under the <code>Chapter5</code> directory. Remember to run <code>npm install</code> on that directory and then go to the <code>Chapter5/vuejs-firebase-shopping-cart</code> directory and run <code>npm install</code> again.</p>
			<p>If you want to implement the code while following this chapter, you can start from the code you left in the <code>Chapter4</code> directory.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Waiting for the page to load</h1>
			<p>In <a href="B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Navigating through a website</em>, we talked about navigation through a site. We covered<a id="_idIndexMarker261"/> functions such as <code>goto</code>, <code>goBack</code>, <code>goForward</code>, and <code>reload</code>. One of the options these functions have is the <code>waitUntil</code> option. This option will help us determine when the function we are calling will be resolved. Let's do a quick recap. We have four options there:</p>
			<ul>
				<li><code>domcontentloaded</code>, which relies on the <code>DOMContentLoaded</code> event.</li>
				<li><code>load</code>: If you pass this option, the <code>promise</code> will be resolved when the <code>load</code> event is fired. </li>
				<li><code>networkidle0</code> will resolve the promise <em class="italic">when there are no more network connections for the past 500 ms</em>. </li>
				<li><code>networkidle2</code> will resolve the promise <em class="italic">when there are no more than 2 network connections for the past 500 ms</em>.</li>
			</ul>
			<p>Let's see how these options work with a site full of content such as <a href="https://shop.mango.com/gb">https://shop.mango.com/gb</a>. We are going to see what content is ready, depending on which <code>waitUntil</code> is used:</p>
			<div><div><img src="img/Figure_5.01_B16113.jpg" alt="Mango home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Mango home page</p>
			<p>The<a id="_idIndexMarker262"/> earliest option to be resolved is <code>DOMContentLoaded</code>:</p>
			<div><div><img src="img/Figure_5.02_B16113.jpg" alt="DOM content loaded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">DOM content loaded</p>
			<p>That page is not ready at all. Does that mean that <code>DOMContentLoaded</code> is useless? Well, it is useless in this case. If you do the same with Wikipedia, the page is so straightforward that it will be ready to automate:</p>
			<div><div><img src="img/Figure_5.03_B16113.jpg" alt="DOM content loaded in Wikipedia&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">DOM content loaded in Wikipedia</p>
			<p>Going <a id="_idIndexMarker263"/>back to the Mango page. Waiting for the <code>load</code> event gives us all the content from the page:</p>
			<div><div><img src="img/Figure_5.04_B16113.jpg" alt="Page after load&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Page after load</p>
			<p>The<a id="_idIndexMarker264"/> background video is not there yet. And the subscribe popup didn't show up. But if we want to interact with the menu bar, use the login action, or test the cookies banner, the page is ready.</p>
			<p>It would be hard to find a page where <code>networkidle0</code> and <code>networkidle2</code> behave differently that you have to pick between one or the other. In this case, we'll get an almost complete page:</p>
			<div><div><img src="img/Figure_5.05_B16113.jpg" alt="Page using networkidle0 and networkidle2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Page using networkidle0 and networkidle2</p>
			<p>The video is not being played yet, so if you want to take screenshots or generate PDF files, as we will see in <a href="B16113_07_Final_SK_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 7</em></a>, <em class="italic">Generating Content with Puppeteer</em>, this won't be enough. But we could say it's ready to be tested.</p>
			<p>So, which one is better? Should we play safe and use <code>networkidle0</code> all the time? Shouldn't that be the default then?</p>
			<p>Here's where we need to find a balance. We could just wait 10 seconds between actions, and we wouldn't have any flaky tests. But, if you have 1,000 tests (remember, you will have over 1,000 tests) with 10 actions each, that would mean that the entire test suite would take almost 14 hours to run. </p>
			<p><em class="italic">To reduce flakiness, we need to find a balance between waiting for too long and going too fast.</em></p>
			<p>Sometimes getting the DOM from the server will be enough. If we were testing Wikipedia, our links would be ready for us on the <code>DOMContentLoaded</code> event. If we want to test our home page and we wait for <code>DOMContentLoaded</code>, images won't be ready yet, but we will get the stock and price values from the server. We don't need more than that.</p>
			<p>Setting the right <code>waitUntil</code> will make your code less flaky, but unless you test a simple site such as Wikipedia, that won't be enough.</p>
			<p>The most effective way to make your code stable is by waiting for the element we want to interact with.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Waiting for elements</h1>
			<p>Before<a id="_idIndexMarker265"/> acting on an element, you need to make sure of two things: first, that the element is there, it exists in the DOM; and second, you can act on that element. In other words, it's visible to the user. Let's see how we can wait for our element to be ready.</p>
			<p>You should wait for a selector after some kind of network call. You <code>goto</code> a page, wait for a selector, and then you act. You click on a button, wait for a selector, and then you act.</p>
			<p>In some cases, the selector you need to wait for is easy to find. On our login page, we need to wait for the user name input. In other cases, such as our home page, we would need to wait for the <code>div</code> element containing all the products. It's just a little bit more complicated but still straightforward.</p>
			<p>But what if we want to test Mango's newsletter popup? Maybe the pop-up HTML is on the page, but it's not visible. Here's where I start to consider waiting as a kind of art. It's not just about automating a page. It's not only about the tool. You need to find the right selectors to make your automation code stable.</p>
			<p>We have two functions that will help us wait for elements: <code>waitForSelector</code> and <code>waitForXPath</code>. Both functions have a similar signature. <code>waitForSelector(selector, [options])</code> expects a CSS selector and an <code>options</code> object. <code>waitForXPath(XPath, [options])</code> expects an XPath expression and an <code>options</code> object.</p>
			<p>These are the <a id="_idIndexMarker266"/>available properties you will be able to set in the <code>options</code> argument:</p>
			<ul>
				<li><code>timeout</code>: We will find this option in all wait functions. We don't want our tests to get stuck. This is another cause of flaky tests. If the timeout is reached, the promise will be rejected. If we don't pass a timeout, the function will use the timeout set using <code>page.setDefaultTimeout(timeout)</code>. If <code>setDefaultTimeout</code> wasn't used, it will default to <strong class="bold">30 seconds</strong>.</li>
				<li><code>visible</code>: If <code>visible</code> is set to true, Puppeteer will not only check that the element exists in the DOM but that it is also visible. We would need to use that in our newsletter popup. This check won't be performed by default. And, again, it's something you might want to check or not, depending on your scenario.</li>
				<li><code>hidden</code>: If <code>hidden</code> is set to true, Puppeteer will check if the element is not visible or if the element is not in the DOM. This option is useful when you need to deal with loading animations. You know that the page is reading when the loading animation is hidden. <a href="http://Twitter.com">Twitter.com</a> is a great example:</li>
			</ul>
			<div><div><img src="img/Figure_5.06_B16113.jpg" alt="Loading animation on Twitter.com&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Loading animation on Twitter.com</p>
			<p>Both <code>waitForSelector</code> and <code>waitForXPath</code> will return a promise that can resolve to the following:</p>
			<ul>
				<li>An <code>ElementHandle</code>: This <a id="_idIndexMarker267"/>element handle will be the element that eventually matches the CSS selector or the XPath.</li>
				<li>Null: When <code>hidden</code> is set to true, and the element was not found in the DOM.</li>
			</ul>
			<p>There are four approaches to waiting for elements. It's not about which one is the best. These approaches will help you in different scenarios.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Await a wait function</h2>
			<p>You will find the code used in this section in the <code>stackoverflow.tests.js</code> file.</p>
			<p>If we go to<a id="_idIndexMarker268"/> Stack Overflow (<a href="https://stackoverflow.com/questions">https://stackoverflow.com/questions</a>), we will find that there are job postings on the right of the page. But as we can see, that's loaded after the page.</p>
			<div><div><img src="img/Figure_5.07_B16113.jpg" alt="Listing while loading and list once loaded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Listing while loading and list once loaded</p>
			<p>Let's say that we want to <a id="_idIndexMarker269"/>test that the page has a list of jobs by default.</p>
			<p>We could just grab the <code>LI</code> elements using <code>$$</code> and then check whether the list is empty or not:</p>
			<pre>const jobs = await page.$$('.jobs li');
expect(jobs).not.be.empty;</pre>
			<p>Honestly, this will work most of the time using a decent network, but it could also get flaky. What we need to do is wait for the elements to be loaded before checking that list. What we could do is call the <code>waitForSelector</code> function before calling <code>$$</code>:</p>
			<pre>await page.waitForSelector('.jobs li');
const jobs = await page.$$('.jobs li');
expect(jobs).not.be.empty;</pre>
			<p>As I mentioned before, <code>waitForSelector</code> returns an <code>ElementHandle</code>. It uses<code>document.querySelector</code>. That's why we can't use the result of <code>waitForSelector</code>.</p>
			<p>But if we wanted to check whether the title is <code>waitForSelector</code> function:</p>
			<pre>const title = await page.waitForSelector('#hireme .header .grid--cell.fl1');
expect(await title.evaluate(e =&gt; e.innerText)).to.contain('job');</pre>
			<p>I think that's the <a id="_idIndexMarker270"/>second time I have used the <code>evaluate</code> function. Patience – that will come in the next chapter.</p>
			<p>In case you are wondering why we didn't use the result of <code>waitForSelector</code> in the job listing example, it turns out that <code>waitForSelector</code> uses <code>document.querySelector</code> to evaluate the CSS expression. That will make <code>waitForSelector</code> return only one item.</p>
			<p>The same happens with <code>waitForXpath</code>. Unlike <code>$x</code>, that returns an array of elements. <code>waitForXpath</code> will return only one element.</p>
			<p><code>waitForSelector</code> and <code>waitForXPath</code> will save your day most of the time, but there are other scenarios we might want to consider. For instance, we might need to check network calls. We might want to wait for a request to be made or for a response to be received. Let's see how to accomplish that.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Waiting for network calls</h1>
			<p>In <a href="B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Navigating through a website</em>, we talked about <strong class="bold">requests</strong> and <strong class="bold">responses</strong>. Every page <a id="_idIndexMarker271"/>navigation begins with a request to a page. The server then processes that request and sends a response. That response generally is an HTML page, which has resources declared that need to be requested. The server will process each of those requests again and send many responses.</p>
			<p>But that's not all. Modern apps will send requests to the server based on user actions. Take <em class="italic">Google Maps</em>: the user moves the mouse, and the page will need to request a new picture of the map without reloading the entire page.</p>
			<p>We don't work on the <em class="italic">Google Maps</em> teams, but many users have reported that the home page sometimes doesn't load the product image after login. So, we could write a test to check that <em class="italic">it should load an image</em>. Oh… you thought we were going to test <em class="italic">Google Maps</em>? Not this time, sorry.</p>
			<p>In this case, we can <a id="_idIndexMarker272"/>use <code>waitForResponse(urlOrPredicate, [options])</code>. Let's unpack these arguments:</p>
			<ul>
				<li><code>urlOrPredicate</code> can be a string with the URL we want to wait for. But it can also be a function. This should be a function expecting a response, which will be the response you will want to check and return a truthy value.</li>
				<li>The only option we have in this function is <code>timeout</code>. This property has the same conditions as the one in <code>waitForSelector</code>: If not passed, Puppeteer will use <code>page.setDefaultTimeout(timeout)</code>, and if that function wasn't used, the default will be 30 seconds.</li>
			</ul>
			<p>Let's write our test. We need to log in and wait for the product image. To accomplish this, we are going to use the <strong class="bold">Arrange, Act, Await</strong> approach.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Arrange, Act, Await</h2>
			<p>This name<a id="_idIndexMarker273"/> comes from the arrange, act, assert pattern we talked about in <a href="B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, <em class="italic">Interacting with a page</em>.</p>
			<p>With this pattern, we try<a id="_idIndexMarker274"/> to prevent <strong class="bold">race conditions</strong>, a common issue in async programming, and a cause of flakiness. A race condition in async programming is when you are trying to do two or more tasks simultaneously, and the speed of one task (too fast or too slow) causes another task to never complete.</p>
			<p>Let's take, for instance, this test:</p>
			<pre>await loginModel.go();
await loginModel.login(config.username, config.password);
await page.waitForResponse(config.productImage);</pre>
			<p>First, notice something. We are not using asserts. The fact that the <code>waitForResponse</code> promise resolves is enough for us to know that the test was successful.</p>
			<p>Another important <a id="_idIndexMarker275"/>concept here is that <code>waitForReponse</code> doesn't behave in the same way as <code>waitForSelector</code>. When we use <code>waitForSelector</code>, the function will resolve when the element we are waiting for is already in the DOM. But with <code>waitForResponse</code>, if the response we are waiting for has already happened, our <code>waitForResponse</code> will time out.</p>
			<p>Our code there has a risk of flakiness. If our server is too fast serving the page after login, the image might have already been served before we wait for it. To solve that, we need to get the promise first, and then await it. This is how we could change our code:</p>
			<pre>await loginModel.go();
const promise = page.waitForResponse(config.productImage);
await loginModel.login(config.username, config.password);
await promise;</pre>
			<p>Notice that instead of awaiting the promised returned by <code>waitForResponse</code>, we are assigning that promise to a variable. We call <code>waitForResponse</code>, we keep that promise, then we act (log in). After that, we await that promise, hoping that it will be resolved at one point after the login action is complete. You can find this test in the <code>login.tests.js</code> file. There, the test is called <code>Should load image after login</code>.</p>
			<p>In the same way that we use <code>waitForResponse</code>, we can use <code>waitForRequest</code>.</p>
			<p>We would use <code>waitForRequest</code> instead of <code>waitForResponse</code> if we wanted to check whether the browser is sending a request to the server. As this function also expects a <code>predicate</code>, a function, as an argument, we can check not only for the URL but also the content of the request.</p>
			<p>Let's say that we work at The Weather Channel (<a href="https://weather.com/">https://weather.com/</a>). We want to check that the browser is sending our location. We found that the page is calling <code>redux-dal</code>. We want to wait for that request, parse the <code>params</code> object.</p>
			<div><div><img src="img/Figure_5.08_B16113.jpg" alt="The weather channel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">The weather channel</p>
			<p>We are going to solve this using the <strong class="bold">fire and forget</strong> approach.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Fire and forget</h2>
			<p>You will find the code<a id="_idIndexMarker276"/> used in this section in the <code>weather.tests.js</code> file.</p>
			<p>We call it a "fire and forget" when we call a function that returns a promise but we don't await that promise, and we don't even care about the result of that promise. "Fire and forget" is a military term that refers to a type of missile that does not require further guidance after launch. In our case, our missiles are Promises that we launch, but we don't care about the outcome of them. </p>
			<p>Let's see how a fire and forget approach would look:</p>
			<pre>const promise = page.waitForRequest(r =&gt; r.url().includes('redux-dal'));
page.goto('https://weather.com/');
const request = await promise;
const json = JSON.parse(request.postData());
expect(json[0].params.geocode).not.be.empty;</pre>
			<p>There are many <a id="_idIndexMarker277"/>new things to learn here.</p>
			<p>We fire and forget the <code>goto</code> action. We call <code>goto</code>, but we don't wait for it to finish. Doing a fire and forget means that we won't care if the promise resolves or fails. In this case, we care about the <code>request</code> promise. If <code>goto</code> fails, the <code>waitForRequest</code> will fail, and the test will fail. </p>
			<p>The second new feature we can see here is that we are waiting for a request using a predicate, a function that expects a request and returns a truthy value: <code>r =&gt; r.url().includes('redux-dal')</code>.</p>
			<p>The last thing we can learn here is that we are working with the request resolved by the <code>waitForRequest</code> promise. Once we get the request, we extract the payload using <code>postData</code>, parse it, and evaluate the content.</p>
			<p>The last feature we have to handle network calls is <code>waitForNavigation</code>. Imagine <code>waitForNavigation</code> as the <code>goto</code> function without the URL argument. It's <code>waitForNavigation([options])</code>. The options are the same options <code>goto</code> has. We can use this function to wait for navigation triggered by one action we perform.</p>
			<p>Let's take, for example, the Packtpub site (<a href="https://www.packtpub.com/">https://www.packtpub.com/</a>). We want to search for a book, press <em class="italic">Enter</em>, and wait for the page to be redirected to the results page.</p>
			<p>For this test, we are going to use our fourth approach: <code>Promise.all</code>.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Promise.all</h2>
			<p>You will find the code <a id="_idIndexMarker278"/>used in this section in the <code>packpub.tests.js</code> file.</p>
			<p>Depending on the scenario, <code>Promise.all</code> could be a shortcut for Act, Arrange, Await. In fact, I would keep the latter for more complex scenarios and use <code>Promise.all</code> if I need to wait for two tasks at the same time.</p>
			<p>Our test code <a id="_idIndexMarker279"/>would look like this with a <code>Promise.all</code>:</p>
			<pre>await page.goto('https://www.packtpub.com/');
const search = await page.$('#search');
await search.type('Puppeteer');
await Promise.all([
    page.waitForNavigation(),
    search.press('Enter')
]);
const textResult = await page.$eval('[data-ui-id="page-title-wrapper"]', e =&gt; e.innerText);
expect(textResult).to.be.equal(`Search results for: 'Puppeteer'`);</pre>
			<p>The first part is pretty straightforward. We go to the site, get the search input, and type "Puppeteer." But then, we wait for two Promises in the same <code>await</code> statement. We wait for navigation to be completed and the <code>press</code> function.</p>
			<p>Although it would be quite weird getting a race condition inside a <code>Promise.all</code>, I feel safer adding the <code>wait</code> function as the first argument of the <code>all</code> function.</p>
			<p>As I mentioned in <a href="B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting started with Puppeteer</em>, <code>Promise.all</code> will wait for all promises to finish. It will also resolve as soon as one promise fails.</p>
			<p>Now we know how to wait for elements and network calls. But let me tell you a little secret: <code>waitForRequest</code> and <code>waitForResponse</code> are just wrappers around the request and response events the page offers. Puppeteer would create a Promise, start listening to an event, and then resolve the Promise when a condition is met. The good news is that we can use this same approach to wait for many other events. </p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Waiting for page events</h1>
			<p>Events are messages<a id="_idIndexMarker280"/> that a class sends when something happens. As a consumer, you can <code>page-event-demos.js</code> file inside the <code>Chapter5</code> directory. To run that demo, you just need to run <code>node page-event-demos.js</code>.</p>
			<p>This is how you could listen to responses without the <code>waitForResponse</code>:</p>
			<pre>page.on('response', response =&gt; 
  console.log('Response URL: ' + response.url()));
await page.goto('https://www.packtpub.com/');</pre>
			<p>In the first line, we say that we want to listen to the <code>response</code> event, and when a new response arrives, we want to print the URL in the console. Then, we call the <code>goto</code> function, and all the responses will start being written in the console.</p>
			<p>Using the arrow (<code>=&gt;</code>) is a simple way to write single-line functions. But, if you open a bracket, you can write more complex functions, like the following:</p>
			<pre>page.on('response', response =&gt; {
  if(response.request().resourceType() === 'image') {
    console.log('Image URL: ' + response.url());
  }
});
await page.goto('https://www.packtpub.com/');</pre>
			<p>If you want to reuse a function, you can pass a function there:</p>
			<pre>const listenToImages = response =&gt; {
  if(response.request().resourceType() === 'image') {
    console.log('Image URL from function: ' + response.url());
  }
};
page.on('response', listenToImages);</pre>
			<p>As you can see, we can<a id="_idIndexMarker281"/> create a function, assign it to a variable – in this case, <code>listenToImages</code> – and then pass it to the <code>page.on</code> function. If you pass a function, you will be able to remove that listener:</p>
			<pre>page.removeListener('response', listenToImages);</pre>
			<p>The <code>removeListener</code> function will detach the <code>listenToImages</code> function from the <code>response</code> event.</p>
			<p>There is one more feature to add to your toolbox. You can listen to an event only once, using – you guessed it – <code>once</code>:</p>
			<pre>page.once('response', r =&gt; console.log(r.url()));</pre>
			<p><code>once</code> will attach your function to an event and remove it as soon as the first event arrives. Notice that <code>once</code> won't evaluate the result of your function. You won't be able to prevent <code>once</code> from removing your listener as soon as the first event arrives.</p>
			<p>We can now try to make our own <code>waitForResponse</code> function. We will use the approach we mentioned in <a href="B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting started with Puppeteer</em>: <em class="italic">Fulfill our own promises</em>. We can create a promise, and then we will resolve it when the condition we are waiting for is met:</p>
			<pre>await loginModel.go();
const promise = new Promise(resolve =&gt; 
  page.on('response', r =&gt; {
    if (r.url() === config.productImage) {
      resolve(r);
    }
  }));
await loginModel.login(config.username, config.password);
await promise;</pre>
			<p>In this code, we created a<a id="_idIndexMarker282"/> promise that will be resolved when the <code>resolve</code> function is called. Inside that function, we attached to the response event and, when the URL matched, we called <code>resolve</code> passing that response.</p>
			<p>In this case, using the <code>waitForResponse</code> function will be easier. But there are events that don't have a <code>waitFor</code> function, and you will need to use this approach to wait for them. Let's see what page events we have available.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>The close event</h2>
			<p>The <code>close</code> event is <a id="_idIndexMarker283"/>triggered when the page is closed. These days, it's not so common<a id="_idIndexMarker284"/> to have popups, mainly because they are not mobile-friendly. But we can still find some cases. For instance, when you want to add an account to your existing <em class="italic">Gmail</em> account. </p>
			<div><div><img src="img/Figure_5.09_B16113.jpg" alt="Popup in Gmail&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Popup in Gmail</p>
			<p>You will need to listen to that page's <code>close</code> event to know that the wizard process has finished.</p>
			<p>But that leaves us <a id="_idIndexMarker285"/>with another question. How do you get to that page? If we <a id="_idIndexMarker286"/>are testing the <em class="italic">Gmail</em> page and click on the <strong class="bold">Create account</strong> link, how do we get the popup?</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>The popup event</h2>
			<p>The<a id="_idIndexMarker287"/> page will trigger a <code>popup</code> event when it opens a new tab or window. We<a id="_idIndexMarker288"/> could do something like this:</p>
			<pre>const [newPage] = Promise.all([
  new Promise(resolve =&gt; page.once('popup', resolve)),
  page.click('someselector')
]);</pre>
			<p>One new thing we can learn here is that <code>promise.all</code> returns an array of all the responses. As we only care about the response of the first promise, we create an array with only one element <code>[newPage]</code>. </p>
			<p>If you want to listen to new pages regardless of what triggered that new page, you can also listen to browser events.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Target created event</h2>
			<p>The <code>targetcreated</code> event is<a id="_idIndexMarker289"/> triggered when a new target (page) is created inside the<a id="_idIndexMarker290"/> browser. We could do something like this:</p>
			<pre>const [newPage] = Promise.all([
  new Promise(resolve =&gt; browser.once('targetcreated', resolve )),
  page.click('someselector')
]);</pre>
			<p>In most scenarios, this will work in the same way as the <code>popup</code> event. But it's good for you to know that you also have this tool available.</p>
			<p>Let's go back to page events.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>The console event</h2>
			<p>The <code>console</code> event<a id="_idIndexMarker291"/> will be triggered every time a new line is printed on the browser <a id="_idIndexMarker292"/>console. In the same way the <code>response</code> event gives us a <code>response</code> object with all the information, the <code>console</code> event will give us a message class with the following functions:</p>
			<ul>
				<li><code>text()</code> with the text message.</li>
				<li><code>type(),</code> which will help us identify the type of the message. The most common types are: 'log', 'debug', 'info', 'error,' and 'warning'.</li>
				<li><code>location()</code>, giving us the source of the message.</li>
				<li>As <code>console.log</code> can expect objects as arguments, we can access those element handles with <code>args()</code>. </li>
			</ul>
			<p>You can use this event to check that there are no JavaScript errors during the test.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>The dialog event</h2>
			<p>The <code>dialog</code> event<a id="_idIndexMarker293"/> is important <a id="_idIndexMarker294"/>because dialogs stop the execution of a page. There are many types of dialogs, and each of them will require us to react differently. We can know the dialog type using the <code>type()</code> function. Let's take a look at the different dialog types and how we can react to them.</p>
			<h3>The alert type</h3>
			<p><code>Alert</code>  is a <a id="_idIndexMarker295"/>dialog with only an <code>dialog.accept()</code>:</p>
			<div><div><img src="img/Figure_5.10_B16113.jpg" alt="Alert"/>
				</div>
			</div>
			<p class="figure-caption">Alert</p>
			<h3>Confirm type</h3>
			<p><code>Confirm</code> is a dialog <a id="_idIndexMarker296"/>with an <code>dialog.accept()</code> or <code>dialog.dismiss()</code> to cancel it:</p>
			<div><div><img src="img/Figure_5.11_B16113.jpg" alt="Confirm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Confirm</p>
			<h3>The prompt type</h3>
			<p>The <code>prompt</code> dialog is not <a id="_idIndexMarker297"/>common these days. It's like the <code>confirm</code> dialog but it prompts an input that you can pass by passing a string to the <code>accept</code> function:</p>
			<div><div><img src="img/Figure_5.12_B16113.jpg" alt="Prompt"/>
				</div>
			</div>
			<p class="figure-caption">Prompt</p>
			<h3>The beforeunload type</h3>
			<p>You will<a id="_idIndexMarker298"/> see <code>beforeunload</code> these days, asking you if you want to leave the site without saving your changes. It works as a <code>confirm</code> dialog. You can interact with this dialog in the same way you would interact with the <code>prompt</code> dialog:</p>
			<div><div><img src="img/Figure_5.13_B16113.jpg" alt="Before unload dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Before unload dialog</p>
			<p>Let's wrap up this chapter with a new tool for our toolbox: <strong class="bold">the headless recorder</strong>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>The headless recorder</h1>
			<p>The headless recorder is a<a id="_idIndexMarker299"/> Chrome extension developed by <em class="italic">Checkly</em> (<a href="https://www.checklyhq.com/">https://www.checklyhq.com/</a>). This <a id="_idIndexMarker300"/>extension will record the actions you perform on a page and generate Puppeteer code based on those actions. I think it's a great tool to get a first draft of a Puppeteer test, and from there, start working on the final code.</p>
			<p>You can download this extension by going to the Chrome Web Store (<a href="https://chrome.google.com/webstore">https://chrome.google.com/webstore</a>) and searching for <code>Headless Recorder</code>:</p>
			<div><div><img src="img/Figure_5.14_B16113.jpg" alt="Headless Recorder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Headless Recorder</p>
			<p>Once <a id="_idIndexMarker301"/>installed, you will find a <strong class="bold">recorder icon</strong> at the top right of your browser. From there, you will have the <strong class="bold">record button</strong>, which will start to capture all the actions you perform on a page:</p>
			<div><div><img src="img/Figure_5.15_B16113.jpg" alt="Record option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Record option</p>
			<p>Once you <a id="_idIndexMarker302"/>finish performing your test actions, you click <strong class="bold">stop</strong>, and you'll get the code almost ready to be used:</p>
			<div><div><img src="img/Figure_5.16_B16113.jpg" alt="Headless Recorder result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Headless Recorder result</p>
			<p>I say almost ready <a id="_idIndexMarker303"/>because the recorder can't guess your real intentions. It's just a guide. As you can see there are selectors such as <code>.mb-3:nth-child(1) &gt; .thumbnail &gt; .card-body &gt; .row &gt; .col-6 &gt; .btn.</code> The recorder doesn't know what your intentions are behind clicking on a certain link. But it's a good start, and it can help you when your test requires many steps.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Summary</h1>
			<p>In this chapter, we learned the concept of flaky tests, and we saw many techniques and tools to prevent having flaky tests in our test suites.</p>
			<p>While we were learning about these wait tools, we saw many page events without even noticing them. Now you can not only wait for selectors and network calls but you can also deal with dialogs and popups.</p>
			<p>The last section was short, but as promised, we now have another tool in our toolbox, a headless recorder.</p>
			<p>In the next chapter, we will get into more advanced tools and learn how to execute JavaScript in the browser.</p>
		</div>
	</body></html>