<html><head></head><body>
		<div id="_idContainer079">
			<h1 id="_idParaDest-88"><em class="italic"><a id="_idTextAnchor087"/>Chapter 5</em>: Waiting for elements and network calls</h1>
			<p>I won't say I'm old, but I started browsing the internet in the late 90s. So yes, I'm old. Back then, you would sometimes have to wait over a minute to get a page loaded. You might be thinking, "So if you had 10 tabs open, that would be impossible to use." Well, browsers didn't have tabs! Downloading one single MP3 file could take you an hour.</p>
			<p>In the early 2000s, the web got into the corporate world, and we started developing business apps using websites. But that was a decision from an IT department. Old terminal apps were hard to update and introduce new features, and desktop apps were hard to distribute. Web apps were the IT department's solution, leaving users with slow and non-user-friendly web apps. </p>
			<p>Developers were trying to do their best with the tools they had back then. Pages were mostly generated on the server side using tools such as ASP 3.0 or PHP. AJAX was used for small tasks, such as loading the state's list based on a country selection without reloading the entire page.</p>
			<p>In the late 2000s, Google launched <em class="italic">Gmail</em>, showing the world how the web should look. But the bar was too high for developers. Developing those kinds of apps was unthinkable for developers just trying to build CRUD pages.</p>
			<p>Nowadays, our web looks different. Developers are now able to create rich experiences, even for more straightforward scenarios. </p>
			<p>But there is a thing that didn't change in all these years: <strong class="bold">You have to wait</strong>.</p>
			<p>You have to wait for the site to load, for the data to be refreshed, for the new page to be opened, for the form to be submitted. You have to wait.</p>
			<p>Waiting for the right moment to act is key to avoid having flaky tests. A flaky test is a test that sometimes passes and sometimes fails. You have to consider flaky tests as a bug, not in the app but in your tests. Flaky tests bring many problems:</p>
			<ul>
				<li>They are a waste of time. Nobody wants to merge a pull request with the tests in red. So, they will repeatedly run the tests until they get all the tests green.</li>
				<li>Flaky tests are a false alarm. Suppose the developer doesn't know that the test is flaky. They might try to find a non-existent bug.</li>
				<li>Flaky tests hurt your tests' reputation. The loss of reputation begins by skipping one flaky test. If you have more flaky tests, the team might move your tests to a nightly process. If your tests keep being flaky, they might be removed from the CI process. You lose, and your team losses.</li>
			</ul>
			<p>Waiting for the right moment to act is the key to making stable UI tests.</p>
			<p>In this chapter, we will learn about the tools that Puppeteer provides to act at the right moment. We will also learn different techniques and approaches, so you can know how you can wait for the page to be ready, for an input to be visible, or for a request to be made, among many other things.</p>
			<p>This chapter is about <strong class="bold">waiting</strong>, a key topic in web automation. I also want to show you a Puppeteer recorder so that you can add one more tool to your toolbox. We will cover the following topics in this chapter:</p>
			<ul>
				<li>Waiting for the page to load</li>
				<li>Waiting for elements</li>
				<li>Waiting for network calls</li>
				<li>Waiting for page events</li>
				<li>Bonus: Headless Recorder</li>
			</ul>
			<p>Let's start at the beginning. How do you know that the page is already loaded?</p>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>Technical requirements</h1>
			<p>You will find all the code of this chapter on the GitHub repository (<a href="https://github.com/PacktPublishing/UI-Testing-with-Puppeteer">https://github.com/PacktPublishing/UI-Testing-with-Puppeteer</a>) under the <strong class="source-inline">Chapter5</strong> directory. Remember to run <strong class="source-inline">npm install</strong> on that directory and then go to the <strong class="source-inline">Chapter5/vuejs-firebase-shopping-cart</strong> directory and run <strong class="source-inline">npm install</strong> again.</p>
			<p>If you want to implement the code while following this chapter, you can start from the code you left in the <strong class="source-inline">Chapter4</strong> directory.</p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Waiting for the page to load</h1>
			<p>In <a href="B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Navigating through a website</em>, we talked about navigation through a site. We covered<a id="_idIndexMarker261"/> functions such as <strong class="source-inline">goto</strong>, <strong class="source-inline">goBack</strong>, <strong class="source-inline">goForward</strong>, and <strong class="source-inline">reload</strong>. One of the options these functions have is the <strong class="source-inline">waitUntil</strong> option. This option will help us determine when the function we are calling will be resolved. Let's do a quick recap. We have four options there:</p>
			<ul>
				<li><strong class="source-inline">domcontentloaded</strong>, which relies on the <strong class="source-inline">DOMContentLoaded</strong> event.</li>
				<li><strong class="source-inline">load</strong>: If you pass this option, the <strong class="source-inline">promise</strong> will be resolved when the <strong class="source-inline">load</strong> event is fired. </li>
				<li><strong class="source-inline">networkidle0</strong> will resolve the promise <em class="italic">when there are no more network connections for the past 500 ms</em>. </li>
				<li><strong class="source-inline">networkidle2</strong> will resolve the promise <em class="italic">when there are no more than 2 network connections for the past 500 ms</em>.</li>
			</ul>
			<p>Let's see how these options work with a site full of content such as <a href="https://shop.mango.com/gb">https://shop.mango.com/gb</a>. We are going to see what content is ready, depending on which <strong class="source-inline">waitUntil</strong> is used:</p>
			<div>
				<div id="_idContainer063" class="IMG---Figure">
					<img src="image/Figure_5.01_B16113.jpg" alt="Mango home page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Mango home page</p>
			<p>The<a id="_idIndexMarker262"/> earliest option to be resolved is <strong class="source-inline">DOMContentLoaded</strong>:</p>
			<div>
				<div id="_idContainer064" class="IMG---Figure">
					<img src="image/Figure_5.02_B16113.jpg" alt="DOM content loaded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">DOM content loaded</p>
			<p>That page is not ready at all. Does that mean that <strong class="source-inline">DOMContentLoaded</strong> is useless? Well, it is useless in this case. If you do the same with Wikipedia, the page is so straightforward that it will be ready to automate:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/Figure_5.03_B16113.jpg" alt="DOM content loaded in Wikipedia&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">DOM content loaded in Wikipedia</p>
			<p>Going <a id="_idIndexMarker263"/>back to the Mango page. Waiting for the <strong class="source-inline">load</strong> event gives us all the content from the page:</p>
			<div>
				<div id="_idContainer066" class="IMG---Figure">
					<img src="image/Figure_5.04_B16113.jpg" alt="Page after load&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Page after load</p>
			<p>The<a id="_idIndexMarker264"/> background video is not there yet. And the subscribe popup didn't show up. But if we want to interact with the menu bar, use the login action, or test the cookies banner, the page is ready.</p>
			<p>It would be hard to find a page where <strong class="source-inline">networkidle0</strong> and <strong class="source-inline">networkidle2</strong> behave differently that you have to pick between one or the other. In this case, we'll get an almost complete page:</p>
			<div>
				<div id="_idContainer067" class="IMG---Figure">
					<img src="image/Figure_5.05_B16113.jpg" alt="Page using networkidle0 and networkidle2&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Page using networkidle0 and networkidle2</p>
			<p>The video is not being played yet, so if you want to take screenshots or generate PDF files, as we will see in <a href="B16113_07_Final_SK_ePub.xhtml#_idTextAnchor130"><em class="italic">Chapter 7</em></a>, <em class="italic">Generating Content with Puppeteer</em>, this won't be enough. But we could say it's ready to be tested.</p>
			<p>So, which one is better? Should we play safe and use <strong class="source-inline">networkidle0</strong> all the time? Shouldn't that be the default then?</p>
			<p>Here's where we need to find a balance. We could just wait 10 seconds between actions, and we wouldn't have any flaky tests. But, if you have 1,000 tests (remember, you will have over 1,000 tests) with 10 actions each, that would mean that the entire test suite would take almost 14 hours to run. </p>
			<p><em class="italic">To reduce flakiness, we need to find a balance between waiting for too long and going too fast.</em></p>
			<p>Sometimes getting the DOM from the server will be enough. If we were testing Wikipedia, our links would be ready for us on the <strong class="source-inline">DOMContentLoaded</strong> event. If we want to test our home page and we wait for <strong class="source-inline">DOMContentLoaded</strong>, images won't be ready yet, but we will get the stock and price values from the server. We don't need more than that.</p>
			<p>Setting the right <strong class="source-inline">waitUntil</strong> will make your code less flaky, but unless you test a simple site such as Wikipedia, that won't be enough.</p>
			<p>The most effective way to make your code stable is by waiting for the element we want to interact with.</p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Waiting for elements</h1>
			<p>Before<a id="_idIndexMarker265"/> acting on an element, you need to make sure of two things: first, that the element is there, it exists in the DOM; and second, you can act on that element. In other words, it's visible to the user. Let's see how we can wait for our element to be ready.</p>
			<p>You should wait for a selector after some kind of network call. You <strong class="source-inline">goto</strong> a page, wait for a selector, and then you act. You click on a button, wait for a selector, and then you act.</p>
			<p>In some cases, the selector you need to wait for is easy to find. On our login page, we need to wait for the user name input. In other cases, such as our home page, we would need to wait for the <strong class="source-inline">div</strong> element containing all the products. It's just a little bit more complicated but still straightforward.</p>
			<p>But what if we want to test Mango's newsletter popup? Maybe the pop-up HTML is on the page, but it's not visible. Here's where I start to consider waiting as a kind of art. It's not just about automating a page. It's not only about the tool. You need to find the right selectors to make your automation code stable.</p>
			<p>We have two functions that will help us wait for elements: <strong class="source-inline">waitForSelector</strong> and <strong class="source-inline">waitForXPath</strong>. Both functions have a similar signature. <strong class="source-inline">waitForSelector(selector, [options])</strong> expects a CSS selector and an <strong class="source-inline">options</strong> object. <strong class="source-inline">waitForXPath(XPath, [options])</strong> expects an XPath expression and an <strong class="source-inline">options</strong> object.</p>
			<p>These are the <a id="_idIndexMarker266"/>available properties you will be able to set in the <strong class="source-inline">options</strong> argument:</p>
			<ul>
				<li><strong class="source-inline">timeout</strong>: We will find this option in all wait functions. We don't want our tests to get stuck. This is another cause of flaky tests. If the timeout is reached, the promise will be rejected. If we don't pass a timeout, the function will use the timeout set using <strong class="source-inline">page.setDefaultTimeout(timeout)</strong>. If <strong class="source-inline">setDefaultTimeout</strong> wasn't used, it will default to <strong class="bold">30 seconds</strong>.</li>
				<li><strong class="source-inline">visible</strong>: If <strong class="source-inline">visible</strong> is set to true, Puppeteer will not only check that the element exists in the DOM but that it is also visible. We would need to use that in our newsletter popup. This check won't be performed by default. And, again, it's something you might want to check or not, depending on your scenario.</li>
				<li><strong class="source-inline">hidden</strong>: If <strong class="source-inline">hidden</strong> is set to true, Puppeteer will check if the element is not visible or if the element is not in the DOM. This option is useful when you need to deal with loading animations. You know that the page is reading when the loading animation is hidden. <a href="http://Twitter.com">Twitter.com</a> is a great example:</li>
			</ul>
			<div>
				<div id="_idContainer068" class="IMG---Figure">
					<img src="image/Figure_5.06_B16113.jpg" alt="Loading animation on Twitter.com&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Loading animation on Twitter.com</p>
			<p>Both <strong class="source-inline">waitForSelector</strong> and <strong class="source-inline">waitForXPath</strong> will return a promise that can resolve to the following:</p>
			<ul>
				<li>An <strong class="source-inline">ElementHandle</strong>: This <a id="_idIndexMarker267"/>element handle will be the element that eventually matches the CSS selector or the XPath.</li>
				<li>Null: When <strong class="source-inline">hidden</strong> is set to true, and the element was not found in the DOM.</li>
			</ul>
			<p>There are four approaches to waiting for elements. It's not about which one is the best. These approaches will help you in different scenarios.</p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>Await a wait function</h2>
			<p>You will find the code used in this section in the <strong class="source-inline">stackoverflow.tests.js</strong> file.</p>
			<p>If we go to<a id="_idIndexMarker268"/> Stack Overflow (<a href="https://stackoverflow.com/questions">https://stackoverflow.com/questions</a>), we will find that there are job postings on the right of the page. But as we can see, that's loaded after the page.</p>
			<div>
				<div id="_idContainer069" class="IMG---Figure">
					<img src="image/Figure_5.07_B16113.jpg" alt="Listing while loading and list once loaded&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Listing while loading and list once loaded</p>
			<p>Let's say that we want to <a id="_idIndexMarker269"/>test that the page has a list of jobs by default.</p>
			<p>We could just grab the <strong class="source-inline">LI</strong> elements using <strong class="source-inline">$$</strong> and then check whether the list is empty or not:</p>
			<p class="source-code">const jobs = await page.$$('.jobs li');</p>
			<p class="source-code">expect(jobs).not.be.empty;</p>
			<p>Honestly, this will work most of the time using a decent network, but it could also get flaky. What we need to do is wait for the elements to be loaded before checking that list. What we could do is call the <strong class="source-inline">waitForSelector</strong> function before calling <strong class="source-inline">$$</strong>:</p>
			<p class="source-code">await page.waitForSelector('.jobs li');</p>
			<p class="source-code">const jobs = await page.$$('.jobs li');</p>
			<p class="source-code">expect(jobs).not.be.empty;</p>
			<p>As I mentioned before, <strong class="source-inline">waitForSelector</strong> returns an <strong class="source-inline">ElementHandle</strong>. It uses<strong class="bold"> </strong><strong class="source-inline">document.querySelector</strong>. That's why we can't use the result of <strong class="source-inline">waitForSelector</strong>.</p>
			<p>But if we wanted to check whether the title is <strong class="bold">"jobs near you"</strong>, we could use the result of the <strong class="source-inline">waitForSelector</strong> function:</p>
			<p class="source-code">const title = await page.waitForSelector('#hireme .header .grid--cell.fl1');</p>
			<p class="source-code">expect(await title.evaluate(e =&gt; e.innerText)).to.contain('job');</p>
			<p>I think that's the <a id="_idIndexMarker270"/>second time I have used the <strong class="source-inline">evaluate</strong> function. Patience – that will come in the next chapter.</p>
			<p>In case you are wondering why we didn't use the result of <strong class="source-inline">waitForSelector</strong> in the job listing example, it turns out that <strong class="source-inline">waitForSelector</strong> uses <strong class="source-inline">document.querySelector</strong> to evaluate the CSS expression. That will make <strong class="source-inline">waitForSelector</strong> return only one item.</p>
			<p>The same happens with <strong class="source-inline">waitForXpath</strong>. Unlike <strong class="source-inline">$x</strong>, that returns an array of elements. <strong class="source-inline">waitForXpath</strong> will return only one element.</p>
			<p><strong class="source-inline">waitForSelector</strong> and <strong class="source-inline">waitForXPath</strong> will save your day most of the time, but there are other scenarios we might want to consider. For instance, we might need to check network calls. We might want to wait for a request to be made or for a response to be received. Let's see how to accomplish that.</p>
			<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/>Waiting for network calls</h1>
			<p>In <a href="B16113_03_Final_SK_ePub.xhtml#_idTextAnchor050"><em class="italic">Chapter 3</em></a>, <em class="italic">Navigating through a website</em>, we talked about <strong class="bold">requests</strong> and <strong class="bold">responses</strong>. Every page <a id="_idIndexMarker271"/>navigation begins with a request to a page. The server then processes that request and sends a response. That response generally is an HTML page, which has resources declared that need to be requested. The server will process each of those requests again and send many responses.</p>
			<p>But that's not all. Modern apps will send requests to the server based on user actions. Take <em class="italic">Google Maps</em>: the user moves the mouse, and the page will need to request a new picture of the map without reloading the entire page.</p>
			<p>We don't work on the <em class="italic">Google Maps</em> teams, but many users have reported that the home page sometimes doesn't load the product image after login. So, we could write a test to check that <em class="italic">it should load an image</em>. Oh… you thought we were going to test <em class="italic">Google Maps</em>? Not this time, sorry.</p>
			<p>In this case, we can <a id="_idIndexMarker272"/>use <strong class="source-inline">waitForResponse(urlOrPredicate, [options])</strong>. Let's unpack these arguments:</p>
			<ul>
				<li><strong class="source-inline">urlOrPredicate</strong> can be a string with the URL we want to wait for. But it can also be a function. This should be a function expecting a response, which will be the response you will want to check and return a truthy value.</li>
				<li>The only option we have in this function is <strong class="source-inline">timeout</strong>. This property has the same conditions as the one in <strong class="source-inline">waitForSelector</strong>: If not passed, Puppeteer will use <strong class="source-inline">page.setDefaultTimeout(timeout)</strong>, and if that function wasn't used, the default will be 30 seconds.</li>
			</ul>
			<p>Let's write our test. We need to log in and wait for the product image. To accomplish this, we are going to use the <strong class="bold">Arrange, Act, Await</strong> approach.</p>
			<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/>Arrange, Act, Await</h2>
			<p>This name<a id="_idIndexMarker273"/> comes from the arrange, act, assert pattern we talked about in <a href="B16113_04_Final_SK_ePub.xhtml#_idTextAnchor072"><em class="italic">Chapter 4</em></a>, <em class="italic">Interacting with a page</em>.</p>
			<p>With this pattern, we try<a id="_idIndexMarker274"/> to prevent <strong class="bold">race conditions</strong>, a common issue in async programming, and a cause of flakiness. A race condition in async programming is when you are trying to do two or more tasks simultaneously, and the speed of one task (too fast or too slow) causes another task to never complete.</p>
			<p>Let's take, for instance, this test:</p>
			<p class="source-code">await loginModel.go();</p>
			<p class="source-code">await loginModel.login(config.username, config.password);</p>
			<p class="source-code">await page.waitForResponse(config.productImage);</p>
			<p>First, notice something. We are not using asserts. The fact that the <strong class="source-inline">waitForResponse</strong> promise resolves is enough for us to know that the test was successful.</p>
			<p>Another important <a id="_idIndexMarker275"/>concept here is that <strong class="source-inline">waitForReponse</strong> doesn't behave in the same way as <strong class="source-inline">waitForSelector</strong>. When we use <strong class="source-inline">waitForSelector</strong>, the function will resolve when the element we are waiting for is already in the DOM. But with <strong class="source-inline">waitForResponse</strong>, if the response we are waiting for has already happened, our <strong class="source-inline">waitForResponse</strong> will time out.</p>
			<p>Our code there has a risk of flakiness. If our server is too fast serving the page after login, the image might have already been served before we wait for it. To solve that, we need to get the promise first, and then await it. This is how we could change our code:</p>
			<p class="source-code">await loginModel.go();</p>
			<p class="source-code">const promise = page.waitForResponse(config.productImage);</p>
			<p class="source-code">await loginModel.login(config.username, config.password);</p>
			<p class="source-code">await promise;</p>
			<p>Notice that instead of awaiting the promised returned by <strong class="source-inline">waitForResponse</strong>, we are assigning that promise to a variable. We call <strong class="source-inline">waitForResponse</strong>, we keep that promise, then we act (log in). After that, we await that promise, hoping that it will be resolved at one point after the login action is complete. You can find this test in the <strong class="source-inline">login.tests.js</strong> file. There, the test is called <strong class="source-inline">Should load image after login</strong>.</p>
			<p>In the same way that we use <strong class="source-inline">waitForResponse</strong>, we can use <strong class="source-inline">waitForRequest</strong>.</p>
			<p>We would use <strong class="source-inline">waitForRequest</strong> instead of <strong class="source-inline">waitForResponse</strong> if we wanted to check whether the browser is sending a request to the server. As this function also expects a <strong class="source-inline">predicate</strong>, a function, as an argument, we can check not only for the URL but also the content of the request.</p>
			<p>Let's say that we work at The Weather Channel (<a href="https://weather.com/">https://weather.com/</a>). We want to check that the browser is sending our location. We found that the page is calling <strong class="source-inline">redux-dal</strong>. We want to wait for that request, parse the <strong class="bold">payload</strong> (the data sent to the server), and validate that it has a geocode object inside the <strong class="source-inline">params</strong> object.</p>
			<div>
				<div id="_idContainer070" class="IMG---Figure">
					<img src="image/Figure_5.08_B16113.jpg" alt="The weather channel&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">The weather channel</p>
			<p>We are going to solve this using the <strong class="bold">fire and forget</strong> approach.</p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Fire and forget</h2>
			<p>You will find the code<a id="_idIndexMarker276"/> used in this section in the <strong class="source-inline">weather.tests.js</strong> file.</p>
			<p>We call it a "fire and forget" when we call a function that returns a promise but we don't await that promise, and we don't even care about the result of that promise. "Fire and forget" is a military term that refers to a type of missile that does not require further guidance after launch. In our case, our missiles are Promises that we launch, but we don't care about the outcome of them. </p>
			<p>Let's see how a fire and forget approach would look:</p>
			<p class="source-code">const promise = page.waitForRequest(r =&gt; r.url().includes('redux-dal'));</p>
			<p class="source-code">page.goto('https://weather.com/');</p>
			<p class="source-code">const request = await promise;</p>
			<p class="source-code">const json = JSON.parse(request.postData());</p>
			<p class="source-code">expect(json[0].params.geocode).not.be.empty;</p>
			<p>There are many <a id="_idIndexMarker277"/>new things to learn here.</p>
			<p>We fire and forget the <strong class="source-inline">goto</strong> action. We call <strong class="source-inline">goto</strong>, but we don't wait for it to finish. Doing a fire and forget means that we won't care if the promise resolves or fails. In this case, we care about the <strong class="source-inline">request</strong> promise. If <strong class="source-inline">goto</strong> fails, the <strong class="source-inline">waitForRequest</strong> will fail, and the test will fail. </p>
			<p>The second new feature we can see here is that we are waiting for a request using a predicate, a function that expects a request and returns a truthy value: <strong class="source-inline">r =&gt; r.url().includes('redux-dal')</strong>.</p>
			<p>The last thing we can learn here is that we are working with the request resolved by the <strong class="source-inline">waitForRequest</strong> promise. Once we get the request, we extract the payload using <strong class="source-inline">postData</strong>, parse it, and evaluate the content.</p>
			<p>The last feature we have to handle network calls is <strong class="source-inline">waitForNavigation</strong>. Imagine <strong class="source-inline">waitForNavigation</strong> as the <strong class="source-inline">goto</strong> function without the URL argument. It's <strong class="source-inline">waitForNavigation([options])</strong>. The options are the same options <strong class="source-inline">goto</strong> has. We can use this function to wait for navigation triggered by one action we perform.</p>
			<p>Let's take, for example, the Packtpub site (<a href="https://www.packtpub.com/">https://www.packtpub.com/</a>). We want to search for a book, press <em class="italic">Enter</em>, and wait for the page to be redirected to the results page.</p>
			<p>For this test, we are going to use our fourth approach: <strong class="source-inline">Promise.all</strong>.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>Promise.all</h2>
			<p>You will find the code <a id="_idIndexMarker278"/>used in this section in the <strong class="source-inline">packpub.tests.js</strong> file.</p>
			<p>Depending on the scenario, <strong class="source-inline">Promise.all</strong> could be a shortcut for Act, Arrange, Await. In fact, I would keep the latter for more complex scenarios and use <strong class="source-inline">Promise.all</strong> if I need to wait for two tasks at the same time.</p>
			<p>Our test code <a id="_idIndexMarker279"/>would look like this with a <strong class="source-inline">Promise.all</strong>:</p>
			<p class="source-code">await page.goto('https://www.packtpub.com/');</p>
			<p class="source-code">const search = await page.$('#search');</p>
			<p class="source-code">await search.type('Puppeteer');</p>
			<p class="source-code">await Promise.all([</p>
			<p class="source-code">    page.waitForNavigation(),</p>
			<p class="source-code">    search.press('Enter')</p>
			<p class="source-code">]);</p>
			<p class="source-code">const textResult = await page.$eval('[data-ui-id="page-title-wrapper"]', e =&gt; e.innerText);</p>
			<p class="source-code">expect(textResult).to.be.equal(`Search results for: 'Puppeteer'`);</p>
			<p>The first part is pretty straightforward. We go to the site, get the search input, and type "Puppeteer." But then, we wait for two Promises in the same <strong class="source-inline">await</strong> statement. We wait for navigation to be completed and the <strong class="source-inline">press</strong> function.</p>
			<p>Although it would be quite weird getting a race condition inside a <strong class="source-inline">Promise.all</strong>, I feel safer adding the <strong class="source-inline">wait</strong> function as the first argument of the <strong class="source-inline">all</strong> function.</p>
			<p>As I mentioned in <a href="B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting started with Puppeteer</em>, <strong class="source-inline">Promise.all</strong> will wait for all promises to finish. It will also resolve as soon as one promise fails.</p>
			<p>Now we know how to wait for elements and network calls. But let me tell you a little secret: <strong class="source-inline">waitForRequest</strong> and <strong class="source-inline">waitForResponse</strong> are just wrappers around the request and response events the page offers. Puppeteer would create a Promise, start listening to an event, and then resolve the Promise when a condition is met. The good news is that we can use this same approach to wait for many other events. </p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Waiting for page events</h1>
			<p>Events are messages<a id="_idIndexMarker280"/> that a class sends when something happens. As a consumer, you can <strong class="bold">attach</strong> a function to those events, so you can listen to those events and react accordingly. You can find the code examples of these demos in the <strong class="source-inline">page-event-demos.js</strong> file inside the <strong class="source-inline">Chapter5</strong> directory. To run that demo, you just need to run <strong class="source-inline">node page-event-demos.js</strong>.</p>
			<p>This is how you could listen to responses without the <strong class="source-inline">waitForResponse</strong>:</p>
			<p class="source-code">page.on('response', response =&gt; </p>
			<p class="source-code">  console.log('Response URL: ' + response.url()));</p>
			<p class="source-code">await page.goto('https://www.packtpub.com/');</p>
			<p>In the first line, we say that we want to listen to the <strong class="source-inline">response</strong> event, and when a new response arrives, we want to print the URL in the console. Then, we call the <strong class="source-inline">goto</strong> function, and all the responses will start being written in the console.</p>
			<p>Using the arrow (<strong class="source-inline">=&gt;</strong>) is a simple way to write single-line functions. But, if you open a bracket, you can write more complex functions, like the following:</p>
			<p class="source-code">page.on('response', response =&gt; {</p>
			<p class="source-code">  if(response.request().resourceType() === 'image') {</p>
			<p class="source-code">    console.log('Image URL: ' + response.url());</p>
			<p class="source-code">  }</p>
			<p class="source-code">});</p>
			<p class="source-code">await page.goto('https://www.packtpub.com/');</p>
			<p>If you want to reuse a function, you can pass a function there:</p>
			<p class="source-code">const listenToImages = response =&gt; {</p>
			<p class="source-code">  if(response.request().resourceType() === 'image') {</p>
			<p class="source-code">    console.log('Image URL from function: ' + response.url());</p>
			<p class="source-code">  }</p>
			<p class="source-code">};</p>
			<p class="source-code">page.on('response', listenToImages);</p>
			<p>As you can see, we can<a id="_idIndexMarker281"/> create a function, assign it to a variable – in this case, <strong class="source-inline">listenToImages</strong> – and then pass it to the <strong class="source-inline">page.on</strong> function. If you pass a function, you will be able to remove that listener:</p>
			<p class="source-code">page.removeListener('response', listenToImages);</p>
			<p>The <strong class="source-inline">removeListener</strong> function will detach the <strong class="source-inline">listenToImages</strong> function from the <strong class="source-inline">response</strong> event.</p>
			<p>There is one more feature to add to your toolbox. You can listen to an event only once, using – you guessed it – <strong class="source-inline">once</strong>:</p>
			<p class="source-code">page.once('response', r =&gt; console.log(r.url()));</p>
			<p><strong class="source-inline">once</strong> will attach your function to an event and remove it as soon as the first event arrives. Notice that <strong class="source-inline">once</strong> won't evaluate the result of your function. You won't be able to prevent <strong class="source-inline">once</strong> from removing your listener as soon as the first event arrives.</p>
			<p>We can now try to make our own <strong class="source-inline">waitForResponse</strong> function. We will use the approach we mentioned in <a href="B16113_01_Final_SK_ePub.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>, <em class="italic">Getting started with Puppeteer</em>: <em class="italic">Fulfill our own promises</em>. We can create a promise, and then we will resolve it when the condition we are waiting for is met:</p>
			<p class="source-code">await loginModel.go();</p>
			<p class="source-code">const promise = new Promise(resolve =&gt; </p>
			<p class="source-code">  page.on('response', r =&gt; {</p>
			<p class="source-code">    if (r.url() === config.productImage) {</p>
			<p class="source-code">      resolve(r);</p>
			<p class="source-code">    }</p>
			<p class="source-code">  }));</p>
			<p class="source-code">await loginModel.login(config.username, config.password);</p>
			<p class="source-code">await promise;</p>
			<p>In this code, we created a<a id="_idIndexMarker282"/> promise that will be resolved when the <strong class="source-inline">resolve</strong> function is called. Inside that function, we attached to the response event and, when the URL matched, we called <strong class="source-inline">resolve</strong> passing that response.</p>
			<p>In this case, using the <strong class="source-inline">waitForResponse</strong> function will be easier. But there are events that don't have a <strong class="source-inline">waitFor</strong> function, and you will need to use this approach to wait for them. Let's see what page events we have available.</p>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/>The close event</h2>
			<p>The <strong class="source-inline">close</strong> event is <a id="_idIndexMarker283"/>triggered when the page is closed. These days, it's not so common<a id="_idIndexMarker284"/> to have popups, mainly because they are not mobile-friendly. But we can still find some cases. For instance, when you want to add an account to your existing <em class="italic">Gmail</em> account. </p>
			<div>
				<div id="_idContainer071" class="IMG---Figure">
					<img src="image/Figure_5.09_B16113.jpg" alt="Popup in Gmail&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Popup in Gmail</p>
			<p>You will need to listen to that page's <strong class="source-inline">close</strong> event to know that the wizard process has finished.</p>
			<p>But that leaves us <a id="_idIndexMarker285"/>with another question. How do you get to that page? If we <a id="_idIndexMarker286"/>are testing the <em class="italic">Gmail</em> page and click on the <strong class="bold">Create account</strong> link, how do we get the popup?</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>The popup event</h2>
			<p>The<a id="_idIndexMarker287"/> page will trigger a <strong class="source-inline">popup</strong> event when it opens a new tab or window. We<a id="_idIndexMarker288"/> could do something like this:</p>
			<p class="source-code">const [newPage] = Promise.all([</p>
			<p class="source-code">  new Promise(resolve =&gt; page.once('popup', resolve)),</p>
			<p class="source-code">  page.click('someselector')</p>
			<p class="source-code">]);</p>
			<p>One new thing we can learn here is that <strong class="source-inline">promise.all</strong> returns an array of all the responses. As we only care about the response of the first promise, we create an array with only one element <strong class="source-inline">[newPage]</strong>. </p>
			<p>If you want to listen to new pages regardless of what triggered that new page, you can also listen to browser events.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor099"/>Target created event</h2>
			<p>The <strong class="source-inline">targetcreated</strong> event is<a id="_idIndexMarker289"/> triggered when a new target (page) is created inside the<a id="_idIndexMarker290"/> browser. We could do something like this:</p>
			<p class="source-code">const [newPage] = Promise.all([</p>
			<p class="source-code">  new Promise(resolve =&gt; browser.once('targetcreated', resolve )),</p>
			<p class="source-code">  page.click('someselector')</p>
			<p class="source-code">]);</p>
			<p>In most scenarios, this will work in the same way as the <strong class="source-inline">popup</strong> event. But it's good for you to know that you also have this tool available.</p>
			<p>Let's go back to page events.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>The console event</h2>
			<p>The <strong class="source-inline">console</strong> event<a id="_idIndexMarker291"/> will be triggered every time a new line is printed on the browser <a id="_idIndexMarker292"/>console. In the same way the <strong class="source-inline">response</strong> event gives us a <strong class="source-inline">response</strong> object with all the information, the <strong class="source-inline">console</strong> event will give us a message class with the following functions:</p>
			<ul>
				<li><strong class="source-inline">text()</strong> with the text message.</li>
				<li><strong class="source-inline">type(),</strong> which will help us identify the type of the message. The most common types are: 'log', 'debug', 'info', 'error,' and 'warning'.</li>
				<li><strong class="source-inline">location()</strong>, giving us the source of the message.</li>
				<li>As <strong class="source-inline">console.log</strong> can expect objects as arguments, we can access those element handles with <strong class="source-inline">args()</strong>. </li>
			</ul>
			<p>You can use this event to check that there are no JavaScript errors during the test.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>The dialog event</h2>
			<p>The <strong class="source-inline">dialog</strong> event<a id="_idIndexMarker293"/> is important <a id="_idIndexMarker294"/>because dialogs stop the execution of a page. There are many types of dialogs, and each of them will require us to react differently. We can know the dialog type using the <strong class="source-inline">type()</strong> function. Let's take a look at the different dialog types and how we can react to them.</p>
			<h3>The alert type</h3>
			<p><strong class="source-inline">Alert</strong>  is a <a id="_idIndexMarker295"/>dialog with only an <strong class="bold">OK</strong> option. You can resume the execution by calling <strong class="source-inline">dialog.accept()</strong>:</p>
			<div>
				<div id="_idContainer072" class="IMG---Figure">
					<img src="image/Figure_5.10_B16113.jpg" alt="Alert"/>
				</div>
			</div>
			<p class="figure-caption">Alert</p>
			<h3>Confirm type</h3>
			<p><strong class="source-inline">Confirm</strong> is a dialog <a id="_idIndexMarker296"/>with an <strong class="bold">OK</strong> and a <strong class="bold">Cancel</strong> option. You accept the dialog with <strong class="source-inline">dialog.accept()</strong> or <strong class="source-inline">dialog.dismiss()</strong> to cancel it:</p>
			<div>
				<div id="_idContainer073" class="IMG---Figure">
					<img src="image/Figure_5.11_B16113.jpg" alt="Confirm&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Confirm</p>
			<h3>The prompt type</h3>
			<p>The <strong class="source-inline">prompt</strong> dialog is not <a id="_idIndexMarker297"/>common these days. It's like the <strong class="source-inline">confirm</strong> dialog but it prompts an input that you can pass by passing a string to the <strong class="source-inline">accept</strong> function:</p>
			<div>
				<div id="_idContainer074" class="IMG---Figure">
					<img src="image/Figure_5.12_B16113.jpg" alt="Prompt"/>
				</div>
			</div>
			<p class="figure-caption">Prompt</p>
			<h3>The beforeunload type</h3>
			<p>You will<a id="_idIndexMarker298"/> see <strong class="source-inline">beforeunload</strong> these days, asking you if you want to leave the site without saving your changes. It works as a <strong class="source-inline">confirm</strong> dialog. You can interact with this dialog in the same way you would interact with the <strong class="source-inline">prompt</strong> dialog:</p>
			<div>
				<div id="_idContainer075" class="IMG---Figure">
					<img src="image/Figure_5.13_B16113.jpg" alt="Before unload dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Before unload dialog</p>
			<p>Let's wrap up this chapter with a new tool for our toolbox: <strong class="bold">the headless recorder</strong>.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>The headless recorder</h1>
			<p>The headless recorder is a<a id="_idIndexMarker299"/> Chrome extension developed by <em class="italic">Checkly</em> (<a href="https://www.checklyhq.com/">https://www.checklyhq.com/</a>). This <a id="_idIndexMarker300"/>extension will record the actions you perform on a page and generate Puppeteer code based on those actions. I think it's a great tool to get a first draft of a Puppeteer test, and from there, start working on the final code.</p>
			<p>You can download this extension by going to the Chrome Web Store (<a href="https://chrome.google.com/webstore">https://chrome.google.com/webstore</a>) and searching for <strong class="source-inline">Headless Recorder</strong>:</p>
			<div>
				<div id="_idContainer076" class="IMG---Figure">
					<img src="image/Figure_5.14_B16113.jpg" alt="Headless Recorder&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Headless Recorder</p>
			<p>Once <a id="_idIndexMarker301"/>installed, you will find a <strong class="bold">recorder icon</strong> at the top right of your browser. From there, you will have the <strong class="bold">record button</strong>, which will start to capture all the actions you perform on a page:</p>
			<div>
				<div id="_idContainer077" class="IMG---Figure">
					<img src="image/Figure_5.15_B16113.jpg" alt="Record option&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Record option</p>
			<p>Once you <a id="_idIndexMarker302"/>finish performing your test actions, you click <strong class="bold">stop</strong>, and you'll get the code almost ready to be used:</p>
			<div>
				<div id="_idContainer078" class="IMG---Figure">
					<img src="image/Figure_5.16_B16113.jpg" alt="Headless Recorder result&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Headless Recorder result</p>
			<p>I say almost ready <a id="_idIndexMarker303"/>because the recorder can't guess your real intentions. It's just a guide. As you can see there are selectors such as <strong class="source-inline">.mb-3:nth-child(1) &gt; .thumbnail &gt; .card-body &gt; .row &gt; .col-6 &gt; .btn.</strong> The recorder doesn't know what your intentions are behind clicking on a certain link. But it's a good start, and it can help you when your test requires many steps.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Summary</h1>
			<p>In this chapter, we learned the concept of flaky tests, and we saw many techniques and tools to prevent having flaky tests in our test suites.</p>
			<p>While we were learning about these wait tools, we saw many page events without even noticing them. Now you can not only wait for selectors and network calls but you can also deal with dialogs and popups.</p>
			<p>The last section was short, but as promised, we now have another tool in our toolbox, a headless recorder.</p>
			<p>In the next chapter, we will get into more advanced tools and learn how to execute JavaScript in the browser.</p>
		</div>
	</body></html>