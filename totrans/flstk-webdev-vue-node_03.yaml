- en: Introducing MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The name MongoDB comes from the phrase huMONGOus data, meaning that it can handle
    a lot of data. MongoDB is a document-oriented database architecture. It enables
    us to develop faster and scale better. In relational database designs, we store
    data by creating tables and rows, but with MongoDB, we can model our data as JSON
    documents, which is much simpler compared to those relational databases. If we
    are agile and our requirements keep changing very often, and if we need to do
    continuous deployment, then MongoDB is our choice. Being a document-based data
    model, MongoDB is very flexible as well.
  prefs: []
  type: TYPE_NORMAL
- en: The biggest advantage of using MongoDB is that the data is unstructured. We
    can customize our data in any format we like. In a **relational database management
    system** (**RDBMS**), we have to define exactly the number of fields a table can
    have, but with MongoDB, each document can have its own number of fields. We can
    add new data without even having to worry about changing the schema, which is
    why Mongo has a **schemaless design model** for the database.
  prefs: []
  type: TYPE_NORMAL
- en: If our business is growing fast, we need to scale faster, we need to access
    data in a more flexible way, and if we need to make changes to our data without
    having to worry about updating our application's database schemas, then MongoDB
    is the best choice for us. Adding new columns to tables in RDBMS also creates
    some performance issues. But, since MongoDB is schemaless, adding new fields is
    done in an instant without compromising the performance of our application.
  prefs: []
  type: TYPE_NORMAL
- en: In a relational database, the terminologies that we use are **database**, **tables**,
    and **rows**, whereas in MongoDB, we use **database**, **collections**, and **documents**,
    respectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a brief summary of what we will be covering in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing to MongoDB and the benefits of using MongoDB
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the MongoDB database, collections, and documents
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing to Mongoose, creating a connection with Mongoose, understanding
    Mongoose, and CRUD operations with Mongoose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Adding default and custom validations with Mongoose
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Why MongoDB?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'MongoDB provides a lot of advantages, some of which are:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Flexible documents**: A MongoDB collection holds several documents. Each
    document under one collection can have variable field names and can have a different
    size as well, which means we don''t have to define the schema.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**No complex relationships**: The documents in MongoDB are stored as JSON documents,
    which means we no longer have to scratch our head learning about the relationships
    between various components of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to scale**: MongoDB is easy to scale as it minimizes the database size
    by using a partitioning method called sharding. Sharding is a database partitioning
    method that allows us to segregate a large database into smaller pieces.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: MongoDB queries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We did quickly review what Mongo queries look like in [Chapter 1](d95a8844-6413-49ed-8d4a-9607cb550211.xhtml), *Introduction
    to MEVN*. Here, we will dive deep into these queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we need to do is start the MongoDB server. We can do that with
    this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Now, let's open the mongo shell by typing `mongo` in our Terminal. When we enter
    the mongo shell, to display the list of databases, we type `show dbs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you see the database in the list, type `use {database_name}` to start using
    this database. If we haven''t created our database yet, just using `use {database_name}`
    will create a database for us. It''s as simple as that. For this exercise, let''s
    create a database called `mongo_test_queries`. So for that, we need to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This should output the following in the Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Now, once we enter the database, the first thing that we need is a collection.
    We have a database but there are no collections. The best way to create a collection
    in MongoDB is by inserting a document. This not only initializes a collection
    but also adds the document to that collection. Simple as that. Now, let's move
    on to Mongo queries.
  prefs: []
  type: TYPE_NORMAL
- en: Creating documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are different queries to create a document in MongoDB, such as `insertOne()`,
    `insertMany()`, and `insert()`.
  prefs: []
  type: TYPE_NORMAL
- en: insertOne()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `insertOne()` command adds a single document to our collection. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This command takes only a single parameter, which is an object, and we can
    pass the field names and values we want for our `users` collection. When we run
    the preceding code in our Terminal inside the Mongo shell, we should get the following
    output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/91f27147-b1ee-4f8f-9121-a09b3d2a3c84.png)'
  prefs: []
  type: TYPE_IMG
- en: It returns the `_id` of the document that just got created. We have successfully
    created a collection and a document in the `users` collection.
  prefs: []
  type: TYPE_NORMAL
- en: The `insertOne()` and `insertMany()` commands only work for Mongo version 3.2
    or higher.
  prefs: []
  type: TYPE_NORMAL
- en: insertMany()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command is used for inserting multiple documents into a collection. In
    the preceding example, we saw that the `insertOne()` command takes an argument
    that is an object. The `insertMany()` command takes an array as a parameter so
    that we can pass multiple objects inside it and insert multiple documents in the
    collection. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet creates three documents in the `users` collection. When we run
    the command, the output should be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2a0b35a8-6ce9-4aea-a11d-92c82bda78cf.png)'
  prefs: []
  type: TYPE_IMG
- en: insert()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command inserts single as well as multiple documents into a collection.
    It does the job of both the `insertOne()` and the `insertMany()` commands. To
    insert a single document, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'If the command is executed successfully, we should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a719b2a-0ff8-40a6-aa1a-f68d30c60f64.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if we want to insert multiple documents, we can simply use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e9a066be-5a9a-49cb-b34e-7d57f8edb430.png)'
  prefs: []
  type: TYPE_IMG
- en: Retrieving documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Retrieving documents from collections in MongoDB is done using the `find()`
    command. There are many ways to use this command.
  prefs: []
  type: TYPE_NORMAL
- en: Finding all documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To retrieve all documents from a collection, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This outputs the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/493ba105-c15e-4001-bec1-5c33c473e5e8.png)'
  prefs: []
  type: TYPE_IMG
- en: Finding documents via filters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can add filters to the `find()` command as well. Let''s retrieve documents
    with the name  `Mike`. For that, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It should return a document with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/48f4dda2-bd2a-4452-9a6c-6900e11ff9f5.png)'
  prefs: []
  type: TYPE_IMG
- en: We can also specify multiple conditions with `AND` or `OR` queries.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find a collection with the name `Mike` and the email `mike@mongo.com`, we
    can simply use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The comma operator means an `AND` operator. We can specify as many conditions
    as we like with comma-separated values. The preceding command should output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c263d37-43b8-433c-9a47-ff92862d4fe0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, specifying conditions with `AND` or comma operators is simple. If we want
    to use the OR operator, then we should use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we are saying: retrieve those documents for users whose name is Mike,
    and the email can be `josh@mongo.com` as well. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2fae1443-b58a-48ea-af6a-95deda33f5f3.png)'
  prefs: []
  type: TYPE_IMG
- en: Updating documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like `insert()`, there are three methods of using the `update()` command
    in MongoDB: `updateOne()`, `updateMany()`, and `update()`.'
  prefs: []
  type: TYPE_NORMAL
- en: updateOne()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command updates only a single document in the collection. Here, we have
    inserted a couple of user entries with the incorrect emails. For the user with
    the name `Peter`, the email is `jack@mongo.com`. Let''s update this document using
    `updateOne()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will update Peter''s email to `peter@mongo.com`. The output is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7c5fd07-4a23-4cad-9dcf-f086003367ba.png)'
  prefs: []
  type: TYPE_IMG
- en: As the output says, the `modifiedCount` is `1` and the `matchedCount` is `1`,
    which means the document with the given condition was found and updated.
  prefs: []
  type: TYPE_NORMAL
- en: updateMany()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This command is used to update multiple documents in a collection. The command
    for updating documents with `updateOne()` and `updateMany()` is the same. To update
    the multiple records, we specify the condition and then set the desired values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between `updateOne()` and `updateMany()` is that `updateOne()`
    updates only the first document that is matched whereas `updateMany()` updates
    all the documents that are matched.
  prefs: []
  type: TYPE_NORMAL
- en: update()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Just like insert, the `update()` command does the job for `updateOne()` and
    `updateMany()`. To remove confusion, we can just use the `update()` command instead
    of `updateOne()` and `updateMany()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acd38c2b-330c-44af-bfe4-d799032d7288.png)'
  prefs: []
  type: TYPE_IMG
- en: Deleting documents
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: MongoDB provides multiple commands for deleting and removing documents from
    collections.
  prefs: []
  type: TYPE_NORMAL
- en: deleteOne()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`deleteOne()` removes only a single document from a collection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This removes the entry of a user whose name is `John`. The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4a229e2e-ac94-4654-bb52-3e0fc52b7cf8.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see in the output, the `deletedCount` is `1`, which means the record
    has been deleted.
  prefs: []
  type: TYPE_NORMAL
- en: deleteMany()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The command for `deleteMany()` is the same as `deleteOne()`. The only difference
    is that `deleteOne()` removes only a single entry with the matched filter whereas
    `deleteMany()` removes all the documents which match the given criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f45587d2-a32a-44c1-88b3-e3a6f6b71bf6.png)'
  prefs: []
  type: TYPE_IMG
- en: remove()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `remove()` command works to remove a single entry, as well as multiple
    entries, from a collection. If we want to remove only a single document that matched
    certain criteria, then we can pass the count of entries that we wish to delete.
    For example, let''s first create an entry:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'With this, now we have two entries for `Mike`. Now, if we want to remove just
    one entry using `remove()`, we can do so with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9c069d94-4b75-4853-855d-d584cbb13044.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see, we had two entries with the name `Mike`, but it only removed
    one. Similarly, if we want to remove all the documents, we can just use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: All documents will be removed.
  prefs: []
  type: TYPE_NORMAL
- en: We talked about the basic ideas on how we can query the documents in Mongo.
    To find out more details, visit [https://docs.mongodb.com/v3.2/tutorial/query-documents/](https://docs.mongodb.com/v3.2/tutorial/query-documents/).
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Mongoose is an elegant MongoDB object modeling library for Node.js. As I mentioned
    earlier, MongoDB is a schemaless database design. While this has its own advantages,
    sometimes we need to add certain validations as well, and this means defining
    the schemas for our documents. Mongoose provides an easy way to add such validations
    and to typecast the fields in a document.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, to insert data into a MongoDB document, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if we want to add another document and we want an extra field in that
    document, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This is possible in MongoDB because no schemas are defined. These types of documents
    are also needed when building an application. MongoDB will silently accept any
    kind of document. However, there are times when we need to have documents look
    similar in order to behave in certain validations or to have a specific data type.
    In such situations, Mongoose comes to the rescue. We can also leverage these features
    with raw MongoDB as well, but writing validations in MongoDB is an extremely painful
    task. That's why Mongoose was created.
  prefs: []
  type: TYPE_NORMAL
- en: 'Mongoose is a data modeling technique for Mongo written in Node.js. Every document
    inside a Mongoose collection requires a fixed amount of fields. We have to explicitly
    define a `Schema` and adhere to it. An example of a Mongoose schema is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This means that the name and description fields must be a string, whereas the
    extras can take a whole JSON object in which we can store nested values as well.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Like any other package, Mongoose can be installed in our project using NPM.
    Run the following command in our Terminal inside our `express_app` folder which
    we created in the previous chapter to install Mongoose inside that application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'If this is successfully installed, we should have a line added to our `package.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd4d9ce0-ceaf-45cf-80ca-181b578da24d.png)'
  prefs: []
  type: TYPE_IMG
- en: Connecting Mongoose to MongoDB
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once Mongoose is installed, we have to connect it to the MongoDB in order to
    start working with it. This is pretty straightforward with Mongoose; we just have
    to add a piece of code to `require` Mongoose in our `app.js` file and use the `mongoose.connect`
    method to connect it to the database. Let''s go ahead and do that. In the `app.js`
    file, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: This will import the Mongoose module into our codebase.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to connect to the MongoDB database, add the following line of code in
    our `app.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a connection with our Mongoose database. Now, let''s run the app
    with the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'and displays a message in our Terminal if it succeeded or failed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a9f674f8-65fb-4746-9de9-b5347303decc.png)'
  prefs: []
  type: TYPE_IMG
- en: That's it! We have successfully made a connection to our MongoDB database. The
    URL here is the locally hosted database URL.
  prefs: []
  type: TYPE_NORMAL
- en: Creating records in Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's start by creating a new model in our application's `express_app`. Create
    a folder called `models` in the root of the project and name it `User.js`.
  prefs: []
  type: TYPE_NORMAL
- en: We are using a capital letter for the starting letter of the file name. Also,
    we are using the single form for `models`. Contrary to this, for `controllers`,
    we use the plural form and lowercase letters, such as `users.js`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we create the file, paste the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line here just imports the Mongoose module. This Mongoose package
    provides us with several properties, one of which is to define the `Schema`. Now,
    the original `Schema` definition here is this highlighted part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'What this does is it adds a validation to our `User` data model, where it says
    there must be two fields in total. It will not accept either one or more than
    two data fields while creating a document for a Mongoose collection. Also, it
    adds a validation layer to this `Schema` as well, which says that the two fields,
    both `name`, and `email`, should be a valid string. It won''t accept an integer,
    Boolean, or anything other than a string for both of these fields. This is how
    we define the `Schema`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted part of this code represents the way to create a model. The
    first argument of the method is our model name, which maps to the corresponding
    plural version of the collection name. So, when we create a `User` model, this
    automatically maps to the `user` collections in our database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, to create a user, the first thing to do is to create a resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, finally, the part that actually creates the `user` is:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'The previous code uses a Mongoose function called `save`. The save method has
    a callback function that is used for error handling. We can do whatever we want
    when we encounter an error while saving the resource to our database there:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The `res.send` method allows us to set what we want to send to the client when
    the resource is successfully saved to the database. The first element of the object
    is `success: true`, which denotes if the execution was successful or not. The
    second element is the status code or the response code. A `200` response code
    denotes successful execution. We will discuss this in further chapters as well.The
    last element is the message that is sent to the client; the users see this in
    the frontend.'
  prefs: []
  type: TYPE_NORMAL
- en: That's how we create a resource in Mongoose.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching records from Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have successfully created a user, we have a record in the `users`
    collections in the database. There are two ways to fetch this record in our client:
    fetch all the records of users that we have or fetch a specific user.'
  prefs: []
  type: TYPE_NORMAL
- en: Fetching all records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are lots of methods that come out of the box with a Mongoose model to
    make our lives easier. Two such methods are `find()` and `findById()`. In MongoDB,
    we saw how we could retrieve a collection's records data via raw MongoDB queries.
    This is similar, the only  difference being that Mongoose has a very easy way
    to do it. I recommend you learn MongoDB first instead of Mongoose because MongoDB
    gives you an overall idea of what a database is and you will learn the fundamentals
    of the database and about its queries. Mongoose just adds a layer on top of MongoDB
    to make it look a little bit easier for faster developments.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that, let''s look into the code snippet here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The Mongoose model `User` calls a method called `find()`. The first parameter
    is our query string, which is left empty: `{}` in the preceding query. So, if
    we want to retrieve all users who share the same name, say, Peter, then we can
    replace that empty `{}` with `{ name: ''Peter''}`.'
  prefs: []
  type: TYPE_NORMAL
- en: The second parameter denotes which fields we want to retrieve from the database.
    We can leave it blank if we want to retrieve all fields or we can just specify
    it here. For this example, we are just retrieving user names and emails.
  prefs: []
  type: TYPE_NORMAL
- en: 'The third parameter has a callback function attached to it. This function takes
    two parameters, unlike the `create` method. The first parameter handles the error.
    If, somehow, the execution is not done successfully, it returns an error and we
    can customize it the way we want. The second parameter is the important one here;
    it returns the response when the execution is successfully done. In this case,
    the `users` parameter is an array of objects that are retrieved from the `users`
    collection. The output of this call would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Now we have all the records from the `users` collection.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching a specific record
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is also as simple as fetching all records from a collection. We talked
    about using `find()` in the previous section. To fetch a single record, we have
    to use `findById()` or `findOne()`, or we can also use the `where` query. The
    `where` query is the same as we talked about previously when we had to pass a
    parameter to fetch records that fell under the same category.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s move ahead on using the following query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the syntax for both `find()` and `findById()` are similar.
    Both take the same amount of parameters and behave the same. The only difference
    between these two is that the preceding `find()` method returned an array of records
    as a response, whereas `findById()` returns a single object. So, the response
    to the preceding query would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That's it – simple!
  prefs: []
  type: TYPE_NORMAL
- en: Updating records in Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's move on to updating a record in a collection. There are multiple ways
    to update the collection records as well, just as in retrieving data from the
    collections. Updating a document in Mongoose is the combination of `read` and
    `create`(save) methods. To update a document, we first need to find that document
    using the read query of Mongoose, alter that document, and then save the changes.
  prefs: []
  type: TYPE_NORMAL
- en: findById() and save()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at an example as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: So, the first thing we need to do is find the user document, which we are doing
    by `findById()`. This method returns back the user with the given ID. Now that
    we have that user, we can alter whatever we like for this user. In the preceding
    case, we are changing the name and email of that person.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now the important part. The job of updating this user''s document is done by
    the `save()` method here. We have already altered the name and email of the user
    by doing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: We are changing the object that was returned via `findById()` in the first place
    directly. Now, when we use `user.save()`, this method overwrites whatever value
    it was before for this user with this new name and email.
  prefs: []
  type: TYPE_NORMAL
- en: There are other methods we can use to update a document in Mongoose.
  prefs: []
  type: TYPE_NORMAL
- en: findOneAndUpdate()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This method can be used when we want to update a single entry. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the first parameter defines the criteria describing the record
    we want to update, which, in this case, is the user whose name is Peter. The second
    parameter is the object in which we define what attributes of `user` do we want
    to update, which is defined by `{ $set: { name: "Sara" }`. This sets the `name`
    of `Peter` to `Sara`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s make a small alteration to the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Here, notice that I have added a second parameter to the callback function called
    `user`.  What this does is that when Mongoose is done updating that document in
    the database, it returns the object. This is very useful when we want to make
    some decisions after we update the record and want to play with the newly updated
    document.
  prefs: []
  type: TYPE_NORMAL
- en: findByIdAndUpdate()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is somewhat similar to `findOneAndUpdate()`. This method takes an ID as
    a parameter, unlike `findOneAndUpdate()`, where we can add our own criteria, and
    updates that document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference here is that the first parameter takes a single integer
    value, which is the ID of the document rather than an object. This method also
    returns the object that is being updated. So we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: Deleting records in Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Just as there are many ways to create, fetch and update records in Mongoose,
    it also provides several ways to delete records from collections as well, such
    as `remove()`, `findOneAndRemove()`, and `findByIdAndRemove()`. We can use `remove()`
    to remove one or many documents. We can also find the documents we want to remove
    first and then use the `remove()` command to remove only those documents. If we
    want to find a specific document with some criteria, we can use `findOneAndRemove()`.
    We can use `findByIdAndRemove()` when we know the ID of the document we wish to
    remove.
  prefs: []
  type: TYPE_NORMAL
- en: remove()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at a sample for using this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'The first argument of the `remove()` method takes the criteria for filtering
    which user we want to remove. It takes an ID as a parameter. It finds the user
    with the given ID and removes the document from the collection. The second parameter
    is the callback function, which we talked about before. If something goes wrong
    with the above operation, it returns an error, which we can use to better handle
    the exceptions or the errors that occur in our application. In the case of success,
    we can define our own logic as to what to return. In the preceding case, we are
    returning `{ success: true }`.'
  prefs: []
  type: TYPE_NORMAL
- en: findOneAndRemove
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`findOneAndRemove()` behaves the same way as `remove()` does and takes the
    same amount of parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: We just have to define the criteria for which documents we want to delete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can also modify the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Here, I have highlighted the added piece of code. We can also pass on a second
    parameter to the callback function which returns the `user` object being deleted. Now,
    this is helpful if we want to display a certain message to the frontend and also
    add some user attributes such as `name` or `email` of the `user`. For example,
    if we want to display a message saying User with name {x} has been deleted. on
    the frontend, then we can pass `user` or other attributes of `user` here; in this
    case, it's the name, to be displayed on the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between `remove()` and `findOneAndRemove()` is that remove
    does not return the documents that were deleted but `findOneAndRemove()` does.
    Now we know when to use these two methods.
  prefs: []
  type: TYPE_NORMAL
- en: findByIdAndRemove()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This is the same as `findOneAndRemove()`, except that this always needs an
    `id` to be passed as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'Did you find any difference in the code between `findOneAndRemove()` and the
    preceding code for `findByIdAndRemove()`? If we look at the first parameter of
    this method, it only takes a simple integer value, which is the document ID. Now,
    if we look into the preceding `findOneAndRemove()` code, we will notice that we
    have passed an object in the first parameter. That''s because, for `findOneAndRemove()`,
    we can pass different arguments other than ID as well. For example, we can also
    pass `{ name: ''Anita'' }` in that parameter for `findOneAndRemove()`. But, for `findByIdAndRemove()`,
    as is obvious from the method name, we don''t need to pass an object but just
    an integer that denotes the document''s ID.'
  prefs: []
  type: TYPE_NORMAL
- en: It finds a document with the mentioned ID in the parameter and removes that
    document from the collections. Like `findOneAndRemove()`, this also returns the
    document that is being deleted.
  prefs: []
  type: TYPE_NORMAL
- en: Adding validation with Mongoose
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Validations in Mongoose are defined at the schema level. Validations can be
    set in both strings and in numbers. Mongoose provides us with built-in validation
    techniques for strings and numbers. Also, we can customize these according to
    our need as well. Since validations are defined in the schemas, they are triggered
    when we hit the `save()` method for any document. If we only want to test these
    validations, we can do that as well by executing the validation method only via
    `{doc}.validate()`.
  prefs: []
  type: TYPE_NORMAL
- en: '`validate()` is also middleware, which means it has control when we are executing
    some methods in an asynchronous way.'
  prefs: []
  type: TYPE_NORMAL
- en: Default validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's talk about some of the default validations that Mongoose provides us with.
    These are also called built-in validators.
  prefs: []
  type: TYPE_NORMAL
- en: required()
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `required()` validator checks if the field we added this validation on
    has some value or not. Previously, in the `User` model, we had this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This code also has a validation associated with the fields of the user. It requires
    the name and email of a user to be a string and not numbers, or Boolean, or anything
    else. But this code doesn't make sure the name and email fields are set for the
    user.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, if we want to add a `required()` validation, the code should be modified
    in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we have changed the value of the name key to an object instead
    of just a string. Here, we can add as many validations as we want. So, the added
    validation `required: true` checks if there is some value set on the name and
    email of the user before saving that document in the collection. It returns an
    error if the validation is not met.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also pass a message when the validation returns an error. For example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: This way, we can also customize the messages as per our requirements. Very cool,
    right?
  prefs: []
  type: TYPE_NORMAL
- en: Type validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The type validation method defines the types of fields in a document. The different
    variations of type can be `String`, `boolean`, and `number`.
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The string itself has several validators under it, such as `enum`, `match`,
    `maxlength`, and `minlength`.
  prefs: []
  type: TYPE_NORMAL
- en: '`maxlength` and `minlength` define the length of a string.'
  prefs: []
  type: TYPE_NORMAL
- en: Numbers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Numbers have two validators: `min` and `max`. The `min` and `max` values define
    the range of values for a field in a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: Custom validations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can also add custom validations in case the default built-in validations
    are not enough.  We can pass a `validate` function and write our custom code into
    that function. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have passed a `validate` method to the `Schema`. It takes a validator
    function where we can add our own code for the validation. The preceding method checks
    if the phone number field of the user is in the correct format or not. If it does
    not pass the validation, then it displays the message `{value} is not a valid
    phone number`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also add nested validations in Mongoose: for example, if the name in
    our user collection is saved as `{ name: { first_name: ''Anita'', last_name: ''Sharma''
    } }`, we will need to add validations for both `first_name` and `last_name`. To
    do that, we can use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: First, we define the `Schema` for a low-level object, which is `first_name`
    and `last_name`. Then, for the `userSchema`, we pass on the `nameSchema` for the
    name field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, we cannot add nested validations in a single `Schema` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: You can look into Mongoose validations here: [http://mongoosejs.com/docs/validation.html](http://mongoosejs.com/docs/validation.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered basic information about MongoDB and its benefits,
    how to make CRUD operations and queries in MongoDB, and the basic validations
    with Mongoose.
  prefs: []
  type: TYPE_NORMAL
- en: Going further, in the next chapter, we will talk more about the REST APIs and
    the RESTful architecture design in our application.
  prefs: []
  type: TYPE_NORMAL
