- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Bridging the Divide – Client (Frontend) versus Server (Backend) Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, I’d like to delve deeper into the idea that was introduced in [*Chapter
    1*](B18315_01.xhtml#_idTextAnchor015) – that a web developer is a software developer
    – and then talk about the various job titles that you might find yourself with
    these days (it might surprise you to learn that “web developer” might be the *least*
    likely!).
  prefs: []
  type: TYPE_NORMAL
- en: In the process, I’ll begin to introduce some of the concepts that go into building
    that technological foundation, such as getting into HTML, CSS, and JavaScript
    in more detail, what event handlers are, what the DOM is, introducing server-side
    programming ideas such as Node, and finally a look at some of the job titles you
    might encounter in this field.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the client (the frontend)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the server (the backend)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining web developer types and job titles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: GitHub is an online service – free for personal use – where you can store your
    code and, optionally, share it with the world. GitHub, as the name clues you into,
    uses the Git source code repository, or SCM, software. We’re going to get into
    that later, but for now, it’s enough to know that GitHub is where you put stuff,
    as well as access the stuff others make available. This “stuff,” which is usually
    code, gets put into repositories, or repos for short. For now, just think of a
    repo as you would a directory on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this book, head here: [https://github.com/PacktPublishing/Web-Development-Career-Master-Plan](https://github.com/PacktPublishing/Web-Development-Career-Master-Plan).
    This is the repository where you’ll find all the source code for this book. At
    this point, take a few moments to create an account for yourself there and download
    the code so that you’re ready to go from this point on. After creating your account
    and going to this book’s repository, you can download the code by clicking the
    big green **Code** button; from there, you can download a ZIP file that will contain
    all the content from the repo.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the client (the frontend)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When a developer says **frontend**, what they are generally referring to is
    the client side of a website. *Okay, that’s great*, I hear you say, but what does
    that mean?
  prefs: []
  type: TYPE_NORMAL
- en: 'In [*Chapter 1*](B18315_01.xhtml#_idTextAnchor015), I showed you a very simple
    example of a web page. That page was built with three main technologies: HTML,
    CSS, and JavaScript. These three technologies are ultimately all that a web browser
    understands. Also in that chapter, I explained that HTML stands for Hypertext
    Markup Language, but I didn’t explain what that meant. To do so, we have to break
    it down, word by word.'
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting HTML
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To explain HTML, I’m going to skip over the first word, Hypertext (we’ll come
    back to it later). For now, let me ask you this question. Imagine that I wrote
    the following on a piece of paper:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“Please return my dog Betty* *if found!”*'
  prefs: []
  type: TYPE_NORMAL
- en: Then, I gave that paper to a sign maker, and I wanted them to make that text
    red on a sign. How would I direct them to do that?
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways I might do this, but whatever form I choose, what would
    I call that instruction? Well, there’s a term that provides the answer: **markup**.
    We might write something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '*“RED -> Please return my dog Betty* *if found!”*'
  prefs: []
  type: TYPE_NORMAL
- en: That `RED->` text, we could say, “marks up” the content and provides an instruction
    – make this red – to someone who understands your markup language. If you’ve agreed
    on that language beforehand, then you can communicate what you want to happen
    in this way.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to say this is that the `RED->` text is **metadata**. Metadata is
    a common programming concept that, in its simplest terms, means data that describes
    other data. We want the underlying data – the text on the sign – to be red, so
    we need some other data to describe the color of that data.
  prefs: []
  type: TYPE_NORMAL
- en: HTML is such a standardized metadata language, and that’s where the M in Markup
    comes from. The idea is that the content to be displayed on the screen is marked
    up in various ways to tell the browser how to display it or do something with
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In HTML, marking up the content is done using **tags**, and they take a common
    form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: When you need to mark up some content, you must start by creating an *opening*
    tag. Some examples you might see are `<body>`, `<div>`, `<p>`, and `<span>`. The
    text within the `<>` characters determines the type of tag it is, which provides
    the meaning of what you’re marking up. Then, the content (`xxx`, in this example,
    to denote it might be anything) to be marked up comes next. At the end of that
    content, you add a *closing* tag, which is the same as the opening tag but with
    `/` before the name of the tag. Every opening tag must have a matching closing
    tag, forming a pair of tags (or a *block*, as it’s sometimes called); otherwise,
    you’ll run into problems, usually in the form of the page not appearing on the
    screen how you expect. Also, note that some tags can be *self-closing*, such as
    `<hr/>`, essentially combining the opening and closing tags. There aren’t too
    many of those, though.
  prefs: []
  type: TYPE_NORMAL
- en: 'Speaking of “not too many,” there is a finite set of standard HTML tags that
    exist that the browser understands. As with most things, you don’t have to try
    and memorize them all, and some you will use very infrequently. In addition, over
    time, some get *deprecated*, meaning they are no longer used, or at least shouldn’t
    be used. But web browsers like to maintain backward compatibility, meaning that
    older sites should still work in newer browsers, so deprecated tags tend to stick
    around for a while, sometimes many years. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `<b>` tag has been deprecated for a long time and should no longer be used,
    but you’ll find it still works in the most recent browsers. It makes text bold,
    and it’s deprecated because that job can be done better with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Before we go any further, let me state that tag names are not case-sensitive.
    You can write `<body>`, `<BODY>`, `<Body>`, or even `<BoDy>` if you like, and
    the browser will handle all of them just fine. That said, most developers tend
    to write them in all lowercase, and that’s the convention I’ll use throughout
    as well. It’s also worth noting that there are a lot of things in software development
    that are case-sensitive – CSS and JavaScript, for example – but HTML isn’t, at
    least not as far as tag names go. It’s not so important what convention you use,
    but it is of critical importance that you are consistent with whatever it is.
    When you get into a professional environment, that will very much be expected
    of you, so it’s a habit I strongly encourage you to get into now.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s look at the basic structure of a web page.
  prefs: []
  type: TYPE_NORMAL
- en: The anatomy of an HTML document
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When we write HTML, we create what’s called an HTML document. This document
    is a file, usually with a `.html` or `.htm` extension. It’s a plain text file
    that can be edited in any text editor, such as Notepad on Windows – no special
    tools are needed. An HTML document has a standard structure that, at a high level,
    looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The HTML document itself is created by starting it with an `<html>` tag and
    ending it with its closing partner, `</html>`. Everything between those tags represents
    the content they’re marking up, which in this case is the entire HTML document
    itself. Here, you can see a new fact about HTML: tags can be the content for other
    tags. We say that these tags are *nested*, or that they are *children* of other
    tags.'
  prefs: []
  type: TYPE_NORMAL
- en: In the code, we have a `<head>` tag and a `<body>` tag nested within the `<html>`
    tag, so they are children of the `<html>` tag (and by extension, you can reverse
    that and say that the `<html>` tag is the parent of the `<``head>` tag).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: From now on, I’m not going to list the closing tag unless there is an explicit
    reason to do so. You should assume there is a closing tag, as there is here for
    `</head>` and `</body>`, unless otherwise stated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `<head>` tag defines one of two sections of an HTML document: the head.
    This section contains content that isn’t displayed on the screen. It’s more like
    information the browser can use in various ways. For example, when we get to CSS,
    you’ll see that it is often put in the head of the document. The same can be true
    of JavaScript code. There are other tags you might see inside the head, such as
    `<title>`, which provides the title you’ll see at the top of your browser, or
    `<meta>`, which provides various pieces of metadata to the browser about the page
    (for example, the icon you normally see when you look at a website you’ve bookmarked
    can be defined here). However, none of that is required, hence I haven’t shown
    it here. Technically, the head itself isn’t required either, but it’s good practice
    to always include it, even if you put nothing in it.'
  prefs: []
  type: TYPE_NORMAL
- en: The `<body>` tag defines the main portion of the document – the part that contains
    the content that will be displayed on the screen. And – you guessed it – that
    section of the document is called the body! The simplest content you can put there
    is just plain text. You don’t need to mark it up in any special way; the browser
    will simply display it as-is.
  prefs: []
  type: TYPE_NORMAL
- en: 'But where the power starts to come in is when you start to use other HTML tags
    in the body. Let’s look at a more advanced example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: There is a lot more going on here, but let’s take it from the top, bit by bit,
    and introduce a bunch of new tags and concepts in the process. Don’t worry – it’s
    not as bad as it looks!
  prefs: []
  type: TYPE_NORMAL
- en: The head
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We start with a `<html>` tag, as before, followed by a `<head>` tag to define
    the document’s head. Inside the head, we have a `<title>` tag that defines the
    title of the document (typically seen in the header of your browser and is usually
    also the text of a bookmark you create for the site). The `<style>` tag is where
    we put CSS, which tells the browser details about how we want our content to be
    displayed – we’ll skip that for now, though.
  prefs: []
  type: TYPE_NORMAL
- en: The head of an HTML document contains metadata about the document – content
    that is not visible in a browser (aside from the title, which is typically displayed
    in the title bar of the browser window). This content can affect what’s displayed,
    though, maybe by importing JavaScript, which results in content being created,
    or that CSS I mentioned, but we’ll get to that in just a bit. You will sometimes
    find literal `<meta>` tags in the head, as you saw in the example in [*Chapter
    1*](B18315_01.xhtml#_idTextAnchor015), to define the character set the document
    uses, the viewport (essentially, this is the browser window) sizing that should
    be used, and more. But the key point is that none of this is content that’s meant
    to be explicitly displayed. That’s what the body of the document is for.
  prefs: []
  type: TYPE_NORMAL
- en: The body
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'After the closing `</head>` tag, we have our opening `<body>` tag; this is
    where we can start displaying content. This content begins with a `<h1>` tag,
    which is used to mark up text as a heading. There are several `<h>` tags, `<h1>`
    through `<h6>`. Think of these as you would when writing an outline of a book:
    `<h1>` tags are your top-level subjects, `<h2>` tags are sub-sections under an
    `<h1>` tag, and so on as the numbers increase. Visually, by default, a `<h1>`
    tag is larger than a `<h2>` tag, and the text gets smaller as the number increases.'
  prefs: []
  type: TYPE_NORMAL
- en: Below the heading is a `<hr>` tag, and this is one of those rare self-closing
    ones. This tag draws a line, or horizontal rule, below the heading.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that comes a `<p>` tag, which stands for paragraph. The text in it will
    be displayed until it’s too wide for the browser window, at which point it will
    flow down onto another line, and so on. Any content that comes after the closing
    `</p>` tag will automatically start on a new line below the paragraph. This is
    a common paradigm when building a web page: we’re largely concerned with defining
    horizontal sections like this, and `<p>` is just one way of doing that.'
  prefs: []
  type: TYPE_NORMAL
- en: The `<div>` tag that comes next is another way to create a horizontal section,
    and it is probably the most common. The difference between `<p>` and `<div>` is
    one of semantics. The term *semantics* here refers to the meaning of the tags,
    which defines the purpose and role of the content within them. The `<p>` tag is
    intended to denote “this is a paragraph, a block of text,” whereas `<div>` does
    not have any inherent meaning like that. But, in practice, they function the same
    and provide the same visual result, so in many cases, it won’t matter which you
    use.
  prefs: []
  type: TYPE_NORMAL
- en: Tag attributes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Differences aside, this `<div>` tag provides an example of something new: `id`.
    This gives a name to the tag that we can use in our code later to do things with
    that tag (or *element*, as we tend to call pairs of tags and all their content
    when we talk about them on a web page).'
  prefs: []
  type: TYPE_NORMAL
- en: Attributes are always in the form of `name=value`. So, here, `id` is the name
    of the attribute, and `nav` is the value given to it. Note that in programming
    in general, when we have a string of characters that isn’t a number, we literally
    call it a string and almost always enclose it in quotation marks.
  prefs: []
  type: TYPE_NORMAL
- en: Back to the markup
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Going back to the markup, the `<div>` tag here defines our navigation section,
    hence the `id` value. Nested inside that `<div>` is another common tag that’s
    used to produce a bulleted list of items, namely `<ul>`. This stands for `<ol>`,
    which produces a list where each item in the list is numbered automatically. Every
    item in either kind of list gets put into a `<li>`, or list item, tag.
  prefs: []
  type: TYPE_NORMAL
- en: After we close the `<li>` and `<div>` tags appropriately, we come across another
    `<div>` tag, this one defining an area we call `characterBio`. This is where we’ll
    show the biographical information of the selected character. The idea of this
    page would be that the user can click a character and see their bio. However,
    note that it’s not complete like it is here, and that’s by design. We’ll build
    on it later to add that interactivity.
  prefs: []
  type: TYPE_NORMAL
- en: Inside the `characterBio` `<div>` tag, we have a `<h2>` tag to show the character’s
    name a little bigger than regular text, but not as big as the main `<h1>` header
    at the top. And then we have another `<p>` tag where the character’s bio text
    is.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we close the `<body>` and `<html>` tags, and we have a complete web
    page!
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon opening that file in your web browser of choice, you should see what’s
    shown in *Figure 2**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1: The result of our HTML (yes, I’m a big fan of this show!)](img/B18315_02_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.1: The result of our HTML (yes, I’m a big fan of this show!)'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, I made a promise earlier that we’d come back to the Hypertext part of
    HTML, so let me fulfill that promise right now!
  prefs: []
  type: TYPE_NORMAL
- en: What about that Hypertext part?!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The term **Hypertext** in HTML refers to the ability of one HTML document to
    link to another, or to a resource it depends on. It’s these links that form the
    web. These links can be created in several ways, and they largely boil down to
    some new tags:'
  prefs: []
  type: TYPE_NORMAL
- en: '`<a>`: This tag creates an explicit link to another page. With it, you might
    write the following:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As with most tags, you have an opening and closing tag pair, with some content
    in the middle. In this case, the content is the text the user will see on the
    screen and be able to click. The `href` attribute (short for HTML reference) provides
    the URL to navigate to when clicked.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<img>`: This is how images are shown on a page (well, the simplest way at
    least):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This tag is a bit of a curiosity because there is no closing `</img>` tag, nor
    do you need to self-close it (and in fact, some browsers won’t display the image
    correctly if you do). Regardless, so long as the image file, `company_logo.png`,
    is in the same location as the HTML document, it will be shown when the page is
    rendered – that is, shown on the screen. Alternatively, you can specify a complete
    URL in the `src` attribute (short for “source”), which allows you to display images
    from other locations.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`<script>` and `<link>`: These allow you to link to JavaScript files and CSS
    files, respectively (technically, `<link>` allows you to link to other types of
    files as well, but CSS files are usually what it’s used for):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the case of the `<script>` tag, you will always have a closing `</script>`
    tag with no content between it and the opening tag. The `type` attribute specifies
    the language, though in this day and age, it’ll virtually never be anything but
    `text/javascript`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: For the `<link>` tag, `rel` defines the relationship between the HTML document
    it’s in and the file being linked to, and like the `type` attribute of the `<script>`
    tag, while it supports other values, it’ll almost always be `stylesheet`. The
    `type` attribute will also pretty much always be `text/css` these days, and you
    already know what `href` is all about.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that unlike `<script>`, a `<link>` tag will always be self-closing, as
    shown here. As with the `<img>` tag, you can specify either a file that lives
    alongside the HTML document, as shown here, or you can specify a complete URL
    to link to a file somewhere else, be it a whole other server or even a resource
    you don’t control yourself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When you link to a JavaScript or CSS file like this, we say that the file is
    being *imported*, and we call these files *external* scripts or *external* stylesheets.
    We can compare this to stylesheets defined in a `<style>` block, which is internal
    since it’s embedded directly in an HTML document. The same is true for `<script>`
    blocks for JavaScript.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: While there are other ways to link to other HTML documents and resources, these
    are by far the most common.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you’ve heard me mention CSS a few times, so let’s jump over to
    that topic and see what it’s all about!
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting CSS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I won’t lie to you: **CSS**, which stands for **Cascading Style Sheets**, can
    be… difficult. It’s not that the basic concepts underlying it are difficult –
    they are fairly simple – but there is *a lot* to it, and it can sometimes trip
    up very experienced developers. However, as with everything we’ve been discussing,
    if you take it little by little and don’t try and learn everything, it’s something
    you can handle!'
  prefs: []
  type: TYPE_NORMAL
- en: In the beginning, CSS was fairly simple to understand. If HTML roughly represents
    the structure of your house – the walls, the studs in them, the roof, the foundation,
    and so on – then CSS is the painter that comes in later and makes it pretty! For
    every element in your HTML document, you could tell the browser what styles to
    apply to it with CSS.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, let’s say you have this bit of HTML in the body of your document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s say I want to make the great Jedi master’s name red, his relatives’
    names green, and his friend’s names blue. I could do that by writing the following
    CSS inside of a `<style>` tag in the head of the document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This small bit of CSS demonstrates most of the core concepts you need to internalize,
    starting with the idea of selectors. Simply put, every bit of CSS you write will
    apply to one or more elements on the page, and which one it applies to is determined
    by a selector. Here, I’m showing the three most common – a tag selector, an ID
    selector, and a class selector:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A tag selector applies to all elements, or tags, of a given type. Here, by
    writing `h1 { color: red; }`, I’m saying that I want all `h1` tags on the page
    to be colored red.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'An ID selector, as shown in `#relatives { color: green; }`, says that the element
    with an ID of `relatives` should be colored green. Since the `id` attribute identifies
    an element with a specific name, you can only ever have one element on a page
    with a given ID (if you happen to reuse an ID, then the element that appears last
    as you read the HTML is the one that will have that ID, so as you can imagine,
    this can be the source of some insidious bugs if you get it wrong).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The class selector – for example, `.friends { color: blue; }` – says that any
    element with a `class` attribute value of friends will be colored blue. You can
    apply this to as many elements as you want.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these three lines of code defines what we call a `color` to make the
    text. The selector for a given class is the text that comes before the opening
    brace. What type of selector it is, in these three cases, is determined by what
    character we start with. If we start with a hash (`#`), that means it’s an ID
    selector. If we start with a period (`.`), that means it’s a class selector. If
    it’s simply the name of an HTML tag with no special character at the start, then
    it’s a tag selector.
  prefs: []
  type: TYPE_NORMAL
- en: But how is the style defined? We do that by setting style properties to a desired
    value, where color is one of a large set of possible attributes. There are attributes
    related to typography (`font-size`, `font-family`, and `font-weight`), some related
    to putting things in the background of a page (`background-color` and `background-image`),
    some for putting borders around things (`border-color`, `border-radius`, and `border-style`),
    properties for setting the size of elements (`width` and `height`), properties
    for changing the geometry of an element (`transform`), properties for hiding and
    showing elements (`display` and `visibility`), and properties for changing the
    position of an element from where it would normally render (`left`, `top`, `position`,
    and `z-index`). This is far from an exhaustive list. I just did a very quick count
    and, at present, it looks like there are over 200 different style properties available.
    Yikes!
  prefs: []
  type: TYPE_NORMAL
- en: 'When we talk about CSS, the *Stylesheet* part is fairly self-evident, and you
    just saw it: those three style classes and their corresponding selectors make
    up a Stylesheet. But what about the *Cascading* part? Well, that comes into play
    when you have multiple styles for a given style property that could apply to a
    given element. This can happen if you link to multiple stylesheets (because you
    can do that regardless of whether you also have your own styles in a `<style>`
    tag or not), or if multiple style classes match. For example, imagine if I changed
    the `h1` style class selector to a `p` selector. In this case, which class – and
    by extension, color – would apply? Would the text be red because of the match
    to the `<p>` tag, or would it be blue because of the class name match?'
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is determined by a cascading algorithm, where an algorithm is a
    procedure, implemented as a bit of code, that solves a specific problem or performs
    a specific task. The cascading rules this algorithm uses can get quite complex
    in practice, but in a nutshell, the following occurs:'
  prefs: []
  type: TYPE_NORMAL
- en: A list of any selectors that could apply to the element is produced.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These selectors are sorted into their order of importance, which largely means
    that those defined after others take precedence, though other factors can play
    into it as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A selector is chosen based on `<p>` tags, but then there is one that is applied
    based on the `id` value, because the `id` value is unique in the document it is
    considered more specific, so it will override the value that would be applied
    based on an element being a `<``p>` tag.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A final decision based on the order of appearance of a style definition is made,
    which is largely the same as the decision based on importance but is a bit more
    straightforward.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This covers the very basics of CSS, but as I said earlier, CSS can be difficult
    because there is a lot to it. So, surely there must be more than what I’ve said
    already, right? There is, and I’ll touch on at least some of it for you next.
  prefs: []
  type: TYPE_NORMAL
- en: Other CSS capabilities
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'CSS can do a lot more than just change colors:'
  prefs: []
  type: TYPE_NORMAL
- en: There are properties for defining the layout of a page, for example. With these,
    you can divide a page into a grid, and then define in which squares of that grid
    various elements should live.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can also use CSS to make the page “reflow” as the browser window’s size
    changes. This allows you to have a page layout that is optimized for smaller mobile
    device screens, as well as larger desktop screens, all without writing any code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: CSS isn’t generally considered code – it’s more like HTML in that it’s metadata.
    However, considering how powerful CSS is today and how complex it can get, I think
    we’re solidly in a gray area between code and not code at this point.
  prefs: []
  type: TYPE_NORMAL
- en: CSS also offers properties that can even allow you to animate elements on the
    page in various ways. You can make a page interactive with CSS alone, without
    writing any code (or at least what is *clearly* code). You can make an element
    grow when the user hovers over it, rotate when clicked, and so on.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In addition to defining your styles in a `<style>` block, usually in the `<head>`
    area of an HTML document, you can also define CSS *inline* – that is, on a given
    element itself:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `style` attribute is available on most elements, and it allows you to apply
    styles on that specific element only. Going back to the idea of cascading, this
    type of style will (nearly) always take precedence over any defined in a `<style>`
    block or linked to in an external stylesheet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Except for inline styles, which are common, the rest of these are more advanced
    topics, and since the goal here is only to give you the basic idea of what CSS
    is, I’m not going to go into them. But I wanted you to at least be aware they
    exist. I wasn’t kidding when I said that CSS can be difficult! There is a great
    deal to it, and it has become immensely powerful. But what’s described in the
    previous section are the core concepts.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we’ve looked at HTML and CSS, let’s dive into the true, *unequivocal*
    area of programming: JavaScript!'
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting JavaScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you think of HTML as the blueprint for a house, and you think of CSS as the
    decorations for the house, you can think of JavaScript as the thing that makes
    the garage door open when you press a button, or the ceiling fan and light turn
    on when you flick a switch.
  prefs: []
  type: TYPE_NORMAL
- en: HTML and CSS are what we call *declarative* languages, meaning you write what
    you want to happen, and the browser does it. For example, if you write `<hr>`,
    the browser knows you want there to be a line on the screen. If you write `color:red`
    in a stylesheet, it knows that you want the element on which the selector for
    that class applies to be red.
  prefs: []
  type: TYPE_NORMAL
- en: 'By contrast, JavaScript is what we call an *imperative* language. This means
    that you must tell the computer exactly what to do at each step of the way. You
    can’t simply declare your intent as with HTML and CSS – you have to be specific
    and detailed about what the browser, and hence the computer, must do. Most people
    will tend to say that JavaScript is actual programming, whereas HTML and CSS aren’t.
    Whether that’s true or not is a bit debatable, but the nature of JavaScript isn’t:
    you have to write instructions for the computer to follow, and it will do no more
    and no less than you tell it to.'
  prefs: []
  type: TYPE_NORMAL
- en: Demonstrating JavaScript
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By way of example, let’s add a line to the code we looked at earlier, right
    after the last `<``div>` tag:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This code shows a couple of things. First, there’s a new HTML tag: `<button>`.
    As its name suggests, it allows us to add buttons to our page, things a user can
    click to do something. The `type` attribute allows us to select one of three types
    of buttons: `button`, `reset`, or `submit`. The latter two are used in the context
    of a form, which is another HTML element that represents a collection of input
    fields, for example, to fill out your personal information when creating an account
    on a website. However, the basic `button` type is a more generic type that doesn’t
    have to be associated with a form, as is the case here.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding code also shows us a new concept: *event handlers*. Event handlers
    are bits of JavaScript that are executed in response to some event, something
    that happens on a page. That might be the user clicking a button, as is the case
    here, or maybe we want some code to execute when the page first loads, which can
    also be done with an event handler. Here, the specific event we want to handle
    is called “click,” and because event handlers execute in response to an event,
    we say that they happen “on” execution of that event, hence why `onClick` is how
    we specify this event handler.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An event handler can either be inline or external to an element. When it’s
    external, it would live inside a `<script>` block somewhere on the page (or perhaps
    in an external JavaScript file that we import). Here, though, it’s inline. The
    value of the `onClick` attribute is simply the JavaScript we want to execute when
    the click event occurs. Let’s look at that code specifically:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows a couple of key concepts in JavaScript, starting with objects. An
    object is simply a collection of data that you treat as a single unit. For example,
    think of yourself: you have a first name, a last name, an age, a phone number,
    and so on. If we stored all that information in the computer’s memory, we could,
    in our code, refer to that collection of information as `BookReader`. If we want
    to get the first name only out of that collection, we might write `BookReader.firstName`.
    The dot represents how we tell JavaScript that we want a single piece of information
    – a `BookReader`.'
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code, `document` is one such collection of information. As
    it happens, this is one that the browser creates for us to represent the HTML
    document itself, all the things that go into it, and all the information about
    it. We can do a lot with this object. For example, we can ask it questions about
    our document. We can do this by calling **methods** on it. A method is a JavaScript
    function that is attached to an object. But I hear you asking, “What’s a function?”
    Let’s talk about that now because it’s a great question!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding functions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: But what is a **function**, you ask? Well, a function is just a bit of JavaScript
    that we give a name to. We do this so that we can execute that JavaScript, perhaps
    many times, *calling* it by its name.
  prefs: []
  type: TYPE_NORMAL
- en: 'Any time you call a JavaScript function, it has the following form:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The function name is the name we assign to that JavaScript code, and arguments,
    which are optional, are any pieces of information the function needs to do its
    job. When they are present, we say they are *passed* to the function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions can be their own, separate things. An example of this is if you write
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `alert()` function exists within the browser automatically, and it’s
    just kind of floating out there on its own.
  prefs: []
  type: TYPE_NORMAL
- en: However, functions can also be *attached* to objects, which is just a fancy
    way of saying that a given property of an object is a reference to a function.
    In our code, `getElementsByTagName()` is one such function, so we say it’s a method
    of the object it’s attached to. Note that when we are referring to the name of
    a function in text like this, it’s common to include an empty set of parenthesis,
    which is the convention I’ll be using throughout this book.
  prefs: []
  type: TYPE_NORMAL
- en: This method allows us to ask the `document` object to get us a list of all the
    `<h1>` tags in the HTML document, which is why `'h1'` is passed as an argument
    to the method. Here, `'h1'` must be enclosed in quotation marks – single quotes,
    in this case (which in most cases are interchangeable) – because it’s what’s known
    as a `1234`, though, we wouldn’t need the single quotes because that wouldn’t
    be a string, it would be a number, and numbers don’t need to be quoted.
  prefs: []
  type: TYPE_NORMAL
- en: The `getElementsByTagName()` method returns a value, just like a function can
    do. What it returns can be many different things, but in this case, it’s what’s
    known as an **array**. An array is simply a list of values. Those values might
    be strings, numbers, or objects (or even functions, but that’s a more advanced
    topic). An array allows us to get values from it by an *index*, which is the position
    in the array.
  prefs: []
  type: TYPE_NORMAL
- en: In talking about arrays, though, I’ve glossed over another concept that may
    in some ways be the most important in JavaScript, and programming in general,
    and that’s **variables**. Let’s talk about that now so that you can better understand
    what an array is.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the simplest terms, variables are named things that point to somewhere in
    the computer’s memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, say we had a list of names: Frank, Traci, Andrew, and Ashley.
    We can put them in an array, just like the kind returned by `getElementsByTagName()`.
    This allows us to access each name by using its index: Frank at position 0 (because
    arrays always start counting with 0, not 1, as you might expect), Traci at 1,
    Andrew at 2, and Ashley at 3.'
  prefs: []
  type: TYPE_NORMAL
- en: 'What does the code look like for doing all that? It’s pretty simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Here, we’re creating a variable named `myArray`. And where is the memory that
    it points to that I said a variable essentially is? Well, frankly, that’s not
    our problem! The computer will take care of that for us. All we need to know is
    that when we want to access this data, we’ll use `myArray`.
  prefs: []
  type: TYPE_NORMAL
- en: The word `var` before `myArray` is called a `var` stands for variable. What
    we’re saying here is, “Hey, JavaScript, I’m declaring a variable named `myArray`
    here.” It will then find some memory for us, and make sure that `myArray` points
    to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Declaring a variable means to introduce it to the computer, but there is a
    related concept called *definition*, or *defining* a variable. The definition
    of a variable is optional; you can declare a variable without defining it (which
    is to say without giving it a starting value) and then give it a value later.
    But it’s common to see both declaration and definition done at the same time,
    as is the case here. The equals sign does that: it’s saying, “Hey, computer, the
    value of `myArray` equals this.”'
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that putting a semicolon at the end of a line of JavaScript is optional,
    but it’s a good habit to get into. That way, we can clearly see when a statement,
    which is one instruction to the computer, ends, and where the next begins (and
    there are also some very subtle but thankfully very rare situations where not
    putting it in can cause a problem, so rare though it is it’s better to avoid that
    possibility entirely through good habits).
  prefs: []
  type: TYPE_NORMAL
- en: 'The value we give is an array of data, which we denote by enclosing the values
    we want in the array in square brackets. If we were just defining a string as
    another example, then they wouldn’t be needed, and the same would be true for
    numbers or objects (objects use braces in place of the brackets, but that’s a
    little more advanced, so let’s forget that for now). For example, here’s an example
    of a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s an example of a number:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, it’s the same basic format: the `var` keyword, followed by
    a name for the variable, and then (optionally) an equals sign and the initial
    value to put into the variable.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Going back to our array, once the array is declared and defined like this,
    we can access the names by writing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This will get the value from the array at index 2, which will be `Andrew` because
    again, arrays start at 0.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have the foundation, let’s see it all in action in the event handler
    code from earlier.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the event handler better
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'With that knowledge, let’s go back to that event handler code from earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'So, what we have here is a call to the `getElementsByTagName()` method of the
    `document` object, asking it for all the `<h1>` tags on the page. This method
    returns an array, which we can then access the elements of using parenthesis.
    Since we know we’re only going to get one tag in this array because we only have
    one `<h1>` tag on the page, the index will always be 0\. The result of this is
    a reference to that tag, which we can then access the properties of. Properties
    can be read *or* written (in most cases), and in this case, we’re writing to one:
    `style`. This corresponds to the stylesheet currently applied to this tag, which
    at the start makes it red. However, we want to change the color to yellow so that
    we can set the value of the `color` attribute.'
  prefs: []
  type: TYPE_NORMAL
- en: The reason you can write `myH1Tag.style.color` is because a property of an object
    can point to other objects. This is called *nesting*, and you can nest as deeply
    as you need to. We call this nesting of objects a *hierarchy*. Here, `myH1Tag`
    is an object. In this case, the `style` attribute points to another object. Finally,
    `color` is a property of that nested object. You will sometimes see long chains
    of XXX.YYY… code in JavaScript as you drill down through a hierarchy of nested
    objects. But no matter how deeply the hierarchy goes, each XXX.YYY you see simply
    means “the YYY property of object XXX.”
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, a single line of code like that event handler can be difficult to
    understand because, in effect, several steps are being performed, and it can often
    be difficult to follow each of them, especially early on when you haven’t been
    reading JavaScript code for a long time. It may make more sense to rewrite the
    code by breaking the individual steps into individual lines, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, you can more clearly see the three discrete steps the code is performing:
    get the list of `<h1>` tags and declare a variable named `tagsArray` to point
    to it (which is defined with the array returned by the method call), then get
    the first element of that array and create a variable named `myH1Tag` to reference
    it, and finally set its `color` style attribute to yellow.'
  prefs: []
  type: TYPE_NORMAL
- en: 'I know that’s a lot of information to take in, especially if you have never
    done any kind of programming before. But here’s the good news: you’ve just been
    introduced to a good chunk of the basic concepts behind JavaScript and programming
    in general! You’ll learn a bit more as you progress through this book, but that’s
    a good start for now.'
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to talk about another topic that is closely related to
    JavaScript, as well as HTML and CSS, and that’s the DOM.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the DOM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **DOM**, which stands for **Document Object Model**, is the concrete result
    of the browser *parsing* an HTML document. This is what we call it when something
    – the browser, in this case – reads some data – the HTML file, in this case –
    and processes it in some way. It’s a collection of objects stored in the computer’s
    memory that represents that document.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider the following HTML document:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When the browser parses that file, it produces a DOM, as shown in *Figure 2**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2: A graphical representation of the DOM](img/B18315_02_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.2: A graphical representation of the DOM'
  prefs: []
  type: TYPE_NORMAL
- en: What you’re looking at is a `<html>` box was at the bottom, that is conceptually
    like the trunk of a tree. Everything that “grows” from it is a branch, and then
    any box that doesn’t have anything growing from it is like a leaf (which we call
    a *node* in tree-speak). So, you can see a branch from `<html>` that leads to
    `<head>` and `<body>` because they are the direct children of `<html>`.
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also notice that there is a box in the diagram that says `#text:` in
    it, which is a child of `<html>` too; you’ll notice several more like that throughout.
    Those represent text content in the HTML document that isn’t contained within
    a tag.
  prefs: []
  type: TYPE_NORMAL
- en: To understand that, take a look at the source HTML code. See how lines are indented?
    Well, the spaces that cause that indentation become an element in the DOM tree
    too, and that’s what those `#text:` boxes are. To the browser, those spaces are
    content that is just as valid as anything within a tag, even though it may not
    be displayed on the page. As a general rule, any whitespace in an HTML document
    won’t be rendered on the screen, at least more than a single space character (put
    another way, multiple space characters collapse into a single space character).
    There are, naturally, ways that you can make multiple spaces be displayed, but
    things such as indentation are *usually* not going to be by default.
  prefs: []
  type: TYPE_NORMAL
- en: That aside, the basic idea is that every tag, and its content, becomes elements,
    or nodes, in the DOM tree, and a more complex bit of HTML will yield a more complex
    tree structure. But it’s this tree that allows CSS and JavaScript to do their
    thing, not to mention the browser itself. When you need to get a reference to
    a DOM node to do something with it in JavaScript, the browser consults this tree
    to find it for you. When you need to specify a CSS selector to apply a style class
    to, the browser uses the tree to do its work. Later, you’ll learn that the DOM
    can be changed with JavaScript (as well as CSS) after it is initially rendered,
    and when that happens, the browser will update the tree accordingly (maybe adding
    new branches or nodes, or removing others, depending on what the change is). The
    DOM makes all that possible.
  prefs: []
  type: TYPE_NORMAL
- en: As a web developer, you don’t generally deal with the DOM directly in the sense
    that you won’t see a diagram like the previous one, at least not entirely like
    that. But it’s always there, omnipresent, allowing the browser – and by extension
    HTML, CSS, JavaScript, and ultimately *you*! – to do their thing. So, it’s important
    to understand what it is and how to conceptualize it in your mind.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve had a chance to meet HTML, CSS, JavaScript, and the DOM, let’s
    talk about what happens when a user enters an address into the address bar of
    a browser and presses *Enter* since that’s a key concept to understand. And there’s
    more to it than what first meets the eye!
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the client-server model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing that happens when you, as the user, enter an address into the
    browser’s address box and press *Enter*, is that a request is made to a **Domain
    Name Server** (**DNS**) by the browser. A DNS server is a special type of computer
    that is maintained by entities such as **Internet Service Providers** (**ISPs**)
    or major corporations. The sole job of a DNS server is to act as a phonebook,
    mapping human-friendly URLs such as google.com to IP addresses (for example, 192.158.1.232).
  prefs: []
  type: TYPE_NORMAL
- en: 'An **Internet Protocol** (**IP**) address is a unique address that every machine
    that connects to a network is given. It’s like the phone number of your cell phone:
    if someone knows it, they can connect to you. But you wouldn’t want to remember
    that 192.158.1.232 is the address – the phone number, if you will – for google.com,
    for example. So, instead, the DNS servers provide that mapping to make things
    more friendly for us humans.'
  prefs: []
  type: TYPE_NORMAL
- en: Once the DNS server responds with the IP address, the browser is then able to
    connect to the server that the IP address corresponds to and requests the HTML
    document specified in the URL. If none is specified (as in google.com), then a
    default document is returned.
  prefs: []
  type: TYPE_NORMAL
- en: The browser then reads that HTML file and parses it, creating the DOM from it.
    It then makes separate requests for each of the resources referenced by the HTML
    document, so things such as images referenced in `<img>` tags, external stylesheets
    referenced in `<link>` tags, or external JavaScript files referenced in `<script>`
    tags. In other words, it asks the server for all the things needed to make that
    web page work and display properly.
  prefs: []
  type: TYPE_NORMAL
- en: Once all those resources are retrieved, the browser renders the content to the
    screen, and you have yourself a web page to look at!
  prefs: []
  type: TYPE_NORMAL
- en: Now, especially with JavaScipt in the mix, that might not be the end of it.
    As the user takes various actions on your web page, such as clicking buttons or
    scrolling, JavaScript code can be executed in response to those actions, and that
    code might make changes to the DOM – and hence what you see on the screen – or
    it might make requests to the server. These requests might be to get some data
    that is then displayed on the page, or it may be a request for a whole new HTML
    document, which will then replace the content currently shown. In these cases,
    we call it *navigating* from one page to another.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve mentioned this server thing a few times now, and you know it’s a computer
    that responds to your requests, but there is more to it than that. So, let’s jump
    into that a little bit, shall we?
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the server (the backend)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As I mentioned earlier, the client is considered the frontend of the equation;
    the **backend** is where we get into the idea of *servers*. The word server has
    two meanings – one physical and one not.
  prefs: []
  type: TYPE_NORMAL
- en: When looking at things from a networking-centric perspective, a server is a
    physical computer, separate from the one a client is running on. They communicate
    over the network.
  prefs: []
  type: TYPE_NORMAL
- en: However, a server is also some form of software running on a physical computer,
    and it’s that software that answers a client’s requests. In other words, when
    we say something like a “web server,” it could mean the physical machine that
    a client connects to so that it can view a web page, it could mean the software
    running on a physical computer that responds to the request for the web page,
    or it could mean the combination of the two.
  prefs: []
  type: TYPE_NORMAL
- en: Because a server is, in some context at least, some kind of software, that also
    means that a client and a server could be running on the same physical machine,
    as you’ll see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: This server software comes in all different shapes, types, and sizes, including
    what programming language is used to create it. Things such as **Java**, **Python**,
    **.NET**, **Node**, and **PHP** are common languages to write server software
    in. Each has its pluses and minuses. Java, Python, and .NET are very robust languages
    that provide a ton of premade code that you can use to save you from writing it
    yourself. This is true for Node and PHP too, but Node is a platform that allows
    you to use JavaScript on the server, and PHP is its own language.
  prefs: []
  type: TYPE_NORMAL
- en: Whatever language you use, whatever platform you build on, you’ll need to provide
    code that handles a given type of request. To demonstrate this, I’d like to write
    a very simple server using Node. I think that this is the best choice to show
    you since we looked at JavaScript a little bit earlier, so it probably won’t seem
    as alien as the others might.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Node
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started, you need to install Node itself. Fortunately, this is very
    easy! Head over to [nodejs.org](http://nodejs.org) in your favorite browser, where
    you’ll see a page similar to what’s shown in *Figure 2**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3: The Node.js (or just plain Node) home page](img/B18315_02_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.3: The Node.js (or just plain Node) home page'
  prefs: []
  type: TYPE_NORMAL
- en: From here, click the big green button that says **Download Node.js (LTS)**.
    This will download an installer, which you can then run to install Node.
  prefs: []
  type: TYPE_NORMAL
- en: Note that alternatively, you can download the latest version via the link below
    that is in the sentence that begins “Want new features sooner?” The difference
    is that the button gives you the LTS – Long Term Support – version, which typically
    means it’s more stable since newer features that may not be fully ready for use
    are present. For our purposes here though, it shouldn’t make a difference, though
    it’s worth noting that I do tend to have the newest version installed on my machine.
    So, if you do happen to run into any problems with code not working as expected,
    and you installed the LTS version, try the latest version instead and see if it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the installer completes, open a command prompt and enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You should be greeted with the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The numbers may be different – that’s what it was when I wrote this – but it
    should match whatever the web page says. Assuming you get a number like this,
    though, it means that **Node** is installed and ready to go.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a project with NPM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To start creating a server, we’ll use a tool that goes hand-in-hand with Node
    called **NPM**. This stands for **Node Package Manager** and is a tool for managing
    packages, which are collections of pre-existing code that we can use in our code.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step to creating a server is to create a directory to house our project
    code, maybe call it `simple-server`, navigate to it, and enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This command tells NPM that you want to start, or *initialize*, a new project.
    You will be greeted with a series of questions. For our purposes here, simply
    press *Enter* for each one until it finally asks you if this is okay. Press *Enter*
    one more time for yes, and then look at the contents of the directory.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should find a single `package.json` file. This file contains all the metadata
    about your project that NPM, and by extension Node, needs to work with your project.
    At this point, its contents should be something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Don’t be worried too much if there are minor differences, but it should mostly
    look like this. As you can see, the metadata here was taken from the answers to
    those questions, or more specifically, the default values that NPM offered you.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the server
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this point, you have a project ready to go, but you don’t have any code
    yet. Let’s remedy that! To do so, create a file in the same directory as `package.json`
    named `index.js` and put the following code into it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Once you save that file, at the command prompt, enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You won’t see anything at this point, but so long as you didn’t see any sort
    of error, then the server is running. To test it, go to your web browser, enter
    [http://localhost](http://localhost) in the address bar, and hit *Enter*. Once
    you do, you should see a greeting stating **Hello from your first** **Node server!**.
  prefs: []
  type: TYPE_NORMAL
- en: You’ve just created a server!
  prefs: []
  type: TYPE_NORMAL
- en: To explain the code a little bit… first, we need to use a package that Node
    provides out of the box – the `http` package. The `require()` function tells JavaScript
    to make that package available to our code. It’s just a function call, which means
    it returns something to us, and in this case, it’s a reference to that package,
    which we then store in the `http` variable. Note that rather than `var`, here,
    I’m using `const` unless you *know* you’ll need to change the value stored in
    the variable later. You’ll avoid a lot of nasty bugs if you follow this advice,
    trust me! When you know that you’ll need to change the value later, you can use
    `var` and `let` as being equivalent. They aren’t, but explaining the difference
    would require getting into some other topics that are better skipped at this early
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the `http` package is imported, we can call its `createServer()` method,
    which, as its name implies, creates a server for us. Here, you can see another
    key thing about JavaScript: functions are first-class citizens, meaning they can
    be treated as values, just like strings and numbers can be. This means that we
    can pass them as arguments to other functions, and that’s exactly what’s done
    here.'
  prefs: []
  type: TYPE_NORMAL
- en: The argument to `createServer()` is a function that will be executed whenever
    a request comes into the server. This function can do whatever is needed to service
    the request. In this case, we’re just responding with a simple greeting. To do
    that, we have to call the `end()` method of the `inResponse` object, which will
    be passed to our function when a request comes in. This is the response the server
    is generating for the client, so by calling `end()`, we can simultaneously tell
    the server “This is the end of the response,” and also “Here’s the content to
    return to the client.”
  prefs: []
  type: TYPE_NORMAL
- en: The last thing we need to do is start the server, and that’s done by calling
    its `listen()` method. We have to tell it what port to listen on, which is `80`
    in this case. Here, a port is a network construct that represents a program running
    on a physical server machine. You can have multiple pieces of software running
    on a single physical server, all listening for requests. However, to know which
    one the client should talk to, each piece of software must be assigned a port
    to listen on, and the client must then specify the port to connect to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that when you enter `http://localhost` in your browser, you aren’t specifying
    the port. This works because, by default, websites always use port 80\. The browser
    is, in essence, attaching `:80` t[o the end of the UR](http://localhost:80/)L
    for you, which you should append to the end of the URL (so http://localhost:80)
    and try it just to prove it works: you should still see the greeting. I should
    also point out that **localhost** is a special name that always means “the machine
    I’m running on.”'
  prefs: []
  type: TYPE_NORMAL
- en: I hope you agree that, surprisingly, little code is needed to create a working
    – albeit very simple – server with Node. It’s one of the reasons Node is such
    a popular option for server-side development, in addition to the fact that for
    full-stack developers, it means they’re using the same language on both the client-side
    and server-side, which tends to make life a bit easier.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you’ve seen some code for both frontend and backend development, let’s
    talk a bit about what those words mean, and how they can branch into job titles
    you might encounter in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Defining web developer types and job titles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When you think of the three types of web developers that I mentioned in [*Chapter
    1*](B18315_01.xhtml#_idTextAnchor015), you’ll begin to get a good feel for the
    types of work each does. Here, I want to talk primarily about the full-stack role,
    but let’s touch on the other two a bit more here first.
  prefs: []
  type: TYPE_NORMAL
- en: Frontend developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Frontend developers focus primarily on what you see on the screen. Their concerns
    are things such as user interface design (how the screen is laid out and what
    everything looks like), user experience (how the user interacts with a website,
    ensuring that it works well for users), and frontend technologies such as HTML,
    CSS, and JavaScipt that we’ve been looking at.
  prefs: []
  type: TYPE_NORMAL
- en: They perform tasks such as interpreting wireframes and turning them into functional
    web pages. They are also concerned with performance and how search engines can
    or can’t find a website efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: Modern frontend developers will frequently use various frameworks to get their
    job done. Names such as Angular, React, and Vue, things we’ll look at in more
    detail later, come to mind. The goal of these frameworks is to enhance the three
    core pillar technologies of HTML, CSS, and JavaScript and, to some extent, make
    it so you don’t have to write them directly. The goal is to allow developers to
    produce more with less code, or in some cases code that is more robust and easier
    to understand. As I mentioned previously, we’ll get into all that later.
  prefs: []
  type: TYPE_NORMAL
- en: Backend developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Backend developers, by contrast, don’t worry too much about what’s on the screen
    in a user’s browser. Instead, their main concern is what happens on the server
    side of the equation. The bread-and-butter of backend developers are things such
    as databases and data modeling, security, providing APIs for the frontend to call
    on, and implementing the core logic of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Backend developers use a whole different set of technologies, where things such
    as Python, Java, and PGP come into play. However, one option – Node – allows them
    to write JavaScipt on the server just like on the client, so there can be some
    overlap.
  prefs: []
  type: TYPE_NORMAL
- en: Modern backend developers often use frameworks as well, though here, we often
    see names such as Django and Spring Boot.
  prefs: []
  type: TYPE_NORMAL
- en: Full-stack developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The full-stack developer, on the other hand, is skilled in both frontend and
    backend development methodologies and technologies. They must be a jack-of-all-trades,
    not specializing in either frontend or backend.
  prefs: []
  type: TYPE_NORMAL
- en: Full-stack developers are intimately concerned with integration – that is, building
    the bridge between frontend and backend – and making sure data flows correctly
    between them. They know how all the pieces fit together because, well, *they built
    all* *of them*!
  prefs: []
  type: TYPE_NORMAL
- en: Being a full-stack developer means learning a lot more, but it also means you
    carry greater value for a prospective employer. To be sure, there are some environments
    where specialists are required, be they frontend specialists or backend specialists.
    But full-stack developers tend to be a larger chunk of web developer positions.
  prefs: []
  type: TYPE_NORMAL
- en: It can be difficult to have a mental picture of an entire system that covers
    both the frontend and backend, but at the same time, it can often be easier to
    perform your duties in other ways. That’s because when you understand how all
    the pieces interact, you will see problems a bit easier than if you have a somewhat
    myopic view of things, as a specialist may.
  prefs: []
  type: TYPE_NORMAL
- en: Ultimately, there is no right answer in terms of the work world. Some people
    frankly prefer frontend and dislike backend work, and some people are the exact
    opposite. And then, some of us love the challenge of doing both. You’ll have to
    make up your mind about which is right for you as you progress.
  prefs: []
  type: TYPE_NORMAL
- en: However, regardless of which way you decide to go, let’s talk about some of
    the job titles you may encounter, how they map to these categories, and what they
    mean.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding job titles
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While you definitely could see a job posting for a “web developer,” at this
    point, I hope you’re coming to realize that *title* is a little ambiguous and
    certainly incomplete. Does it mean someone focused on frontend development? Or
    does it mean someone doing more server-side development? And, to make matters
    worse, a given title might not even mean quite the same thing at one company versus
    another!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the interest of trying to make some sense of this, let’s look at a list
    of common job titles you might find in a job posting and try to at least roughly
    define what they’re likely to mean at most places:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Programmer/computer programmer*: This is a generic title that some companies
    will use to indicate they need someone who can program in various languages –
    or perhaps in one specific language (Java programmer, as an example title). Often,
    this title will mean this is not a web development position, but that is far from
    a rule. Still, it often means someone who is working on things such as embedded
    systems or perhaps the defense industry.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Engineer/software engineer*: This is another generic title that, for the most
    part, means the same as programmer, but generally connotates a somewhat higher-level
    position. While a job listing that says programmer may tend to indicate a more
    entry-level position, something with engineer in its name probably denotes a position
    requiring previous experience. These titles also tend to mean non-web development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Senior software engineer/senior software developer*: Once you have some experience,
    higher-level development positions are, again, less likely to be for web development.
    At the senior level, you will be expected to take on bigger challenges and be
    able to work more independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Lead developer/team lead/technical lead*: Once you have suitable experience
    and demonstrated knowledge, you will often find yourself moving into a “lead”
    position. In such a role, you’ll be expected to be a guiding hand in terms of
    technical direction, often acting as a mentor to more junior team members. You’ll
    still be coding of course, but a good chunk of your time will go into writing
    documents to direct the work of others. These titles don’t say anything about
    whether they are web development-related or not; they apply pretty equally to
    either branch of the software development tree.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Principal software engineer*: Any job title with “principal” in its name tends
    to denote someone who has been around for a good, long time and is viewed as a
    guiding hand. You’ll probably be involved in multiple projects simultaneously,
    acting as a force multiplier for others and being involved in more strategic conversations
    about what should or shouldn’t be developed to aid the business.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Test engineer/QA engineer*: These are different roles from any of the ones
    mentioned previously, but they’re related. These types of jobs focus more on building
    tests, which actually for the most part still means writing code, but specifically
    code that tests other code. For example, does the `addNumbers()` function return
    5 when I pass it 2 and 3? You can write code that calls the function and confirms
    the value it returns, thereby testing that function. To be clear, *all* developers
    do this, but there is a class of people who do it all the time, and in more depth.
    Related to this are QA engineers, and they are the very necessary people who make
    life difficult for us developers! They’re the ones that try to enter ABC into
    a field that’s only supposed to take numbers and see if the system blows up. Some
    developers move into these types of jobs later, or vice versa, so there’s a clear
    relationship there.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Web developer/web designer*: Ah, yes, this one you know! Sometimes, a job
    posting will just list this as the title, which is difficult because while it
    tells you that you’ll be doing web development, it doesn’t say whether it’s frontend,
    backend, or full-stack. In my experience, I’d say it usually does mean full-stack,
    but that’s not a guarantee.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Frontend developer*: Sometimes, employers will be specific and say frontend
    development, so now you know exactly what you’ll be doing: writing a lot of HTML,
    CSS, and JavaScript!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Backend developer*: Again, a backend position tells you it’s web development,
    and tells you you’ll be working on server code, but exactly what technologies
    you’ll be using isn’t specified, which frankly means you’ll probably wind up using
    more than one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Full-stack developer*: Finally, there’s the good old full-stack title, which
    means you’ll be expected to know a bit about everything. I should emphasize that
    in most cases, you won’t be expected to be an expert at everything right from
    the start. But you *will* be expected to be able to learn as you go, which is
    equal parts exciting and scary!'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*System analyst/computer systems analyst*: Like test and QA titles, any title
    with “analyst” in it is a different thing but is related. An analyst is primarily
    focused on talking to the stakeholders and determining their needs. It’s easy
    enough for a factory owner to say “I need this assembly line to be more efficient,”
    but what does that mean, how do you achieve it, and how do you translate that
    into the blueprints for a software solution? That’s where analysts come in. They
    get into the details of the business processes involved, really understand them,
    and translate that into a software approach, whether that means web-based software
    or not. They don’t define how the software will be written in detail, generally,
    but they’ll define the overall flow of a system and how the pieces fit together.
    Developers will sometimes become analysts as time goes on, and probably sometimes
    the other way around too.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Architect/systems architect/enterprise architect/software architect/principal
    architect*: Titles with the word “architect” in them are people who are focused
    more on the structure of large-scale software systems. They’ll define what the
    parts of a system are, how they will interact, choose technologies to implement
    them, and draw up documents that define it all in a way that software developers
    can use to build what they’ve designed. Therefore, architect positions are a natural
    progression for developers after a certain period, so long as they have the necessary
    aptitude for it. If you’re thinking there is a lot of overlap between analysts
    and architects, that’s largely true. The key difference is that the analyst is
    looking at things from more of a business perspective while the architect is looking
    at it from a technical perspective. Analysts and architects work hand-in-hand.
    so come up with a blueprint for what developers will develop. Architects will
    sometimes code as well, though that tends to happen less and less as you move
    through the ranks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Technical manager/engineering manager*: The final category I’ll talk about
    is the management levels that tend to come before the executive level. Here, I’m
    talking about technical managers, sometimes called engineering managers. As the
    name implies, these are management positions, in which you’ll tend to do almost
    no actual development yourself, web or otherwise. More of your time will be spent
    on HR matters, meetings to discuss direction, and implementing that direction
    with your team. While these are management positions, you’ll still be expected
    to have your finger on the pulse of technology, which means having had a lot of
    experience to draw on. To be sure, technical managers will often still get their
    hands dirty with actual development, or development-adjacent tasks, but that’s
    no longer their primary focus day-to-day.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Again, I need to stress that none of these titles are concretely defined anywhere,
    nor are they the only titles you might encounter. Ask 100 different people what
    a technical manager is, for example, and while you probably won’t get 100 different
    answers, you’ll get more than one! Note that this is a rough guide that is based
    on my many years of experience and online research as I wrote this, so it should
    provide you with a decent idea not only of the job titles you might see but also
    what they mean, how they relate to one another, and what your career progression
    through them might look like.
  prefs: []
  type: TYPE_NORMAL
- en: I’d also like to point out that moving up through the ranks from programmer
    to manager isn’t a given! You have to be honest with yourself at each step of
    the journey and decide what’s most important to you. I had a manager some years
    back who willingly took a pay cut so that they could go back to being “just” a
    programmer because they enjoyed that aspect of their job but didn’t like the management
    side. And that’s fine! Not everyone will want to be a manager, an architect, or
    even a lead. Whatever title you have, not hating your everyday job is more important
    than any title or even the money that may come with one versus another.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s touch on one final topic, which is the roadmap we’ll be building
    up as we go through this book. We have a few more squares to uncover, Vanna White
    style!
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this chapter concluded, we can now uncover a few more squares of our web
    developer roadmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4: The roadmap, with a few more boxes filled in](img/B18315_02_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2.4: The roadmap, with a few more boxes filled in'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to **Logical Thinking**, we’ve revealed the **Frontend** and **Backend**
    boxes, along with their children, **HTML**, **CSS**, **JavaScript**, **Node**,
    and **NPM**. We’ve also revealed **Full-Stack**, which branches off both the **Frontend**
    and **Backend** boxes. We’re well on our way to web developer bingo!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered a lot of ground! We dug deeper into frontend development
    in the form of HTML, CSS, and JavaScript – the foundations of the web – providing
    some foundational knowledge about each. You also gained an understanding of how
    pages link to other pages and resources, and you got a feel for how a web browser
    loads and renders a page, including what the DOM is all about. Then, you got a
    look at the backend, saw a simple Node example, and discovered how it interacts
    with the frontend.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we talked a bit more about what a web developer is and how that
    definition ties into the frontend and backend discussions that came before. Finally,
    we talked more about what it means to be full-stack, and the benefits it can bring
    to your career.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at some more of the other things that might
    be considered “foundational” knowledge for a web developer, building on what you’ve
    seen in this chapter as we continue to build that technical foundation you’ll
    need to succeed.
  prefs: []
  type: TYPE_NORMAL
