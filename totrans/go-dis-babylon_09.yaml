- en: '9'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Calculating and Displaying Scoring Results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whether a game is implemented as a piece of software or a cut-out piece of cardboard,
    almost all games, regardless of origin or format, feature intrinsic ways to give
    players feedback on their performance throughout a game session. Whether it reflects
    the number of goals scored or the player’s ability to keep a steel ball from dropping
    between bumpers, the scoring process is where a game connects to its players at
    a most visceral level.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll be introducing two new powerful tools for your game
    development toolbox, both completely new to version 5 of Babylon.js: the `src/route-planning/route-plan-gui.js`
    and recall that there is a large amount of boilerplate, typo-prone, and ultimately
    tedious code that needs to be written just to get a bare-bones basic GUI displayed.
    Much of the code involved is of the *make this object that color, and place it
    here* variety, making it more difficult to visualize how components and elements
    will look at runtime. The GUIE allows a developer or designer to separate the
    presentation from the behavioral logic of the application – a concept very familiar
    to most developers! In addition to the GUIE, we’re going to introduce another
    incredibly powerful tool – the coroutine.'
  prefs: []
  type: TYPE_NORMAL
- en: A coroutine behaves and is constructed in a fashion that will be very familiar
    to those who have read the *Space-Truckers – The State Machine* section of [*Chapter
    4*](B17266_04_Final_AM.xhtml#_idTextAnchor070), *Creating the Application*, but
    instead of having the specific purpose of managing our application state, a coroutine
    is built from an arbitrarily defined function generator (see [*Chapter 4*](B17266_04_Final_AM.xhtml#_idTextAnchor070),
    *Creating* *the Application*, for a refresher on `function*` generators in JavaScript)
    and attached to a `BabylonJS.Observable`. Most of the time, this Observable will
    be the Scene’s `onBeforeRenderObservable`, meaning that the coroutine executes
    before every frame, but any Observable can run a coroutine. The behavior of the
    `yield` keyword in conjunction with some other elements that we’ll look at shortly
    makes coroutines a perfect tool to use when a game’s logic needs to span multiple
    rendered frames, a quality we’re going to be using to our advantage to display
    the scoring results.
  prefs: []
  type: TYPE_NORMAL
- en: As part of and in addition to our examinations of the GUIE and coroutines, we’ll
    build out a reusable dialog system that will serve as the base for our Scoring
    Dialog and Results screen before putting score tracking logic into the rest of
    the game. Though this might seem like a backward approach, having the ability
    to display scores first will help us discover what needs to be tracked and calculated
    by the rest of the application. Is there much still that could and should be done?
    Of course! There will always be more to do, but an important skill in software
    development is knowing which things *must* be done versus which things only *need*
    to be done.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the Babylon.js GUI Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a Reusable Dialog Box Component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Calculating Scores
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the Scoring Dialog Using Coroutines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical Requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There aren’t any new or additional requirements from the software or hardware
    side of things that are needed for this chapter, but there are some topics in
    the Babylon.js documentation or elsewhere that might be handy as we explore some
    of these areas:'
  prefs: []
  type: TYPE_NORMAL
- en: The Babylon.js 2D GUI system at [https://doc.babylonjs.com/divingDeeper/gui](https://doc.babylonjs.com/divingDeeper/gui)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coroutines (Babylon.js) at [https://doc.babylonjs.com/divingDeeper/events/coroutines](https://doc.babylonjs.com/divingDeeper/events/coroutines)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GUI Editor user’s guide/manual at [https://doc.babylonjs.com/toolsAndResources/tools/guiEditor](https://doc.babylonjs.com/toolsAndResources/tools/guiEditor)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Babylon.js GUI Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Boilerplate code is a term given to code that has the characteristics of being
    simple, standardized, and frequently repeated. As a software developer, it’s generally
    best not to write that type of code yourself for some very good reasons. First,
    the nature of boilerplate code is that it is repetitive, making it prone to syntax
    or other superficial logical defects (that is, typos, fat-fingers, and more).
    Second, it’s tough to maintain, since when changes need to be introduced, those
    changes are generally needed throughout the expanse of the boilerplate. Finally
    (at least for our purposes), it’s really, really, *really* boring to read and
    write code of this nature.
  prefs: []
  type: TYPE_NORMAL
- en: To solve these (and other related) problems, the Babylon.js team created the
    GUIE. As just one of a huge number of new tools and features introduced with v5.0
    of Babylon.js the GUIE fills an important niche in the Babylon.js ecosystem. Like
    its brethren, the Animation Curve Editor, the Node Material Editor, and the Playground,
    the GUIE and its associated snippet server are hosted online at [https://gui.babylonjs.com](https://gui.babylonjs.com)
    and possess similar dual capabilities to work with unique IDs and revisions for
    persistence or directly with JSON files.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two basic kinds of GUIs that Babylon.js supports: 2D and 3D. The
    2D GUI renders to a utility layer using an Advanced Dynamic Texture (see *The
    Advanced Dynamic Texture* section), whereas the 3D GUI system renders meshes on
    a utility layer. The content in this chapter and through much of this book focuses
    mainly on the 2D GUI. However, the 2D and 3D systems have very similar APIs. See
    [https://doc.babylonjs.com/divingDeeper/gui/gui3D](https://doc.babylonjs.com/divingDeeper/gui/gui3D)
    for more on the 3D GUI system.'
  prefs: []
  type: TYPE_NORMAL
- en: Before we start looking at the GUIE’s interface and capabilities, it will be
    useful if we start with either a refresher or a primer on how the Babylon.js GUI
    components operate at the level of the **Advanced Dynamic Texture** (**ADT**).
  prefs: []
  type: TYPE_NORMAL
- en: The Advanced Dynamic Texture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Throughout this book, we’ve been making use of ADTs and the 2D GUI system, but
    to this point, we haven’t tried to peek inside an ADT and see what it does. To
    do so, let’s peel off the *Advanced* part of the term and focus first on the more
    basic **Dynamic Texture** (**DT**).
  prefs: []
  type: TYPE_NORMAL
- en: A DT is a design-time integration component that exposes the HTML5 Canvas drawing
    API on one end of it; on the other, on the Babylon.js side, it exposes a `BABYLON.DynamicTexture`.
    Because it derives from a regular `BABYLON.Texture`, it is typically rendered
    by assigning the DT to an appropriate Texture slot in a Material. The Playground
    at [https://playground.babylonjs.com/#5ZCGRM#2](https://playground.babylonjs.com/%235ZCGRM%232)
    demonstrates the basics of how this works for drawing simple text, but any Canvas
    API is accessible via the DT’s `getContext` function.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See [https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API](https://developer.mozilla.org/en-US/docs/Web/API/Canvas_API)
    to learn more about the Canvas API and its different functions and capabilities,
    and [https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture](https://doc.babylonjs.com/divingDeeper/materials/using/dynamicTexture)
    to learn more about the BablyonJS DT.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing the Canvas APIs in this way allows for a huge amount of flexibility
    for developers wishing to render strings or other UI elements but at the cost
    of requiring those same developers to have to manage a large amount of what is
    essentially boilerplate code. Sound familiar? The BABYLON.GUI system is a higher
    layer of abstraction over the Canvas APIs on one end of the integration, and like
    its antecedent **Dynamic Texture**, the **Advanced Dynamic Texture** comprises
    the other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Put one way, an ADT is a **procedural texture** generated and managed by the
    BABYLON.GUI APIs. That’s it. If it feels like this is somewhat of a letdown considering
    how much build-up there’s been to this definition, then you’re in luck because
    the details are far more involved than a simple procedural texture. We can start
    by picturing how an ADT fits into the overall scene and rendering process:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.1 – The Canvas API and Babylon.js render layers that host a multitude
    of different features, such as the Inspector, Glow Layers, Gizmos, and more](img/Figure_9.01_B17266.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 9.1 – The Canvas API and Babylon.js render layers that host a multitude
    of different features, such as the Inspector, Glow Layers, Gizmos, and more
  prefs: []
  type: TYPE_NORMAL
- en: If we follow the analogy of an HTML Canvas being like a cloth canvas used for
    painting, a layer is like a distinct coat of paint on the canvas; multiple layers
    overlap and blend to create the whole piece. As with a real-world canvas, the
    order in which pixels (or swatches of paint) are laid down is important to the
    final appearance – whichever color is placed last on the canvas is generally going
    to be the dominant color for that pixel.
  prefs: []
  type: TYPE_NORMAL
- en: The ADT is rendered as one of those layers when created using `AdvancedDynamicTexture.CreateFullScreenUI`,
    with the `isForeground` property of the ADT determining whether its layer is rendered
    in front of all other layers. Crucially, this also means that the ADT can be affected
    by the same sorts of factors that affect other layers (for example, Layer Masks
    and Post-Processes; see [*Chapter 8*](B17266_08_Final_AM.xhtml#_idTextAnchor166),
    *Building the Driving Game*, the *Loading Assets Asynchronously* section for more).
    When a full-screen UI isn’t the right tool for the job, `AdvancedDynamicTexture`
    can be used identically to any texture by creating it using the `AdvancedDynamicTexture.CreateMeshTexture`
    function. This is what we did in [*Chapter 8*](B17266_08_Final_AM.xhtml#_idTextAnchor166),
    *Building the Driving Game*, in the *Making the Minimap* section, so it’s a good
    sign that we’re ready to progress up the ladder to the point where we can start
    using better tools to work with `AdvancedDynamicTexture` regardless of its type.
    In a similar vein, the GUIE will save us enormous amounts of time and effort,
    so let’s take a brief tour and get cranking!
  prefs: []
  type: TYPE_NORMAL
- en: UI Design with the GUIE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As always, the latest documentation on the Babylon.js GUIE can be found at [https://doc.babylonjs.com/toolsAndResources/tools/guiEditor](https://doc.babylonjs.com/toolsAndResources/tools/guiEditor),
    but some basic principles are still worth going over. The top-most horizontal
    menu, featuring the *hamburger* icon, has controls for managing the zoom level,
    copying and pasting controls, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'Clicking on empty space in the navigation panel displays the properties for
    the ADT. These are used to render the layout canvas in addition to buttons for
    loading and saving the GUI in various formats. The following screenshot contains,
    from right to left, the different areas of the GUI editor – the navigation tree,
    layout canvas, and property panes, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.2 – The GUIE’s three primary workspace areas, from left to right:
    navigation panel, layout canvas, and property pane. The layout shows the currently
    selected layoutGrid container element. Source: https://gui.babylonjs.com/#923BBT#37](img/Figure_9.2_B17866.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9.2 – The GUIE’s three primary workspace areas, from left to right:
    navigation panel, layout canvas, and property pane. The layout shows the currently
    selected layoutGrid container element. Source: [https://gui.babylonjs.com/#923BBT#37](https://gui.babylonjs.com/%23923BBT%2337)'
  prefs: []
  type: TYPE_NORMAL
- en: The control tree can be seen on the left-hand navigation pane, separated from
    the layout canvas by the vertical list of control icons available to insert. Probably
    one of the more important sets of these controls is going to be the various types
    of containers.
  prefs: []
  type: TYPE_NORMAL
- en: From **StackPanels** to **Grids** with a sprinkling of **ScrollViewers** and
    **Rectangles** to round things out, the container elements behave exactly as you
    may expect them to if you are accustomed to the concepts. The GUI shown in *Figure
    9.2* is a simple dialog box design, with content broken out into the three separate
    rows of the layoutGrid Grid Control. That control, in turn, is contained within
    the Rectangle dialogBorder, which is contained within the dialogRoot Container
    for the entire UI.
  prefs: []
  type: TYPE_NORMAL
- en: If you’re not familiar with containers and their behavior, a review of the BJS
    Docs section on containers might be worth a quick (and informative!) read at [https://doc.babylonjs.com/divingDeeper/gui/gui#containers](https://doc.babylonjs.com/divingDeeper/gui/gui#containers).
    Resizing and laying out visual elements can be done by dragging around handles
    in the visual layout pane or by directly setting properties to specific values
    – use the former to get an approximation and the latter to “dial in” to pixel-perfect
    precision!
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The current list of supported controls and links to their associated documentation
    sections can be found at [https://doc.babylonjs.com/toolsAndResources/tools/guiEditor#supported-controls](https://doc.babylonjs.com/toolsAndResources/tools/guiEditor#supported-controls).
  prefs: []
  type: TYPE_NORMAL
- en: 'Row indices start at zero, so the middle row is row number one and contains
    the primary content of the dialog. The following diagram illustrates how the layoutGrid’s
    three rows allocate 25%, 50%, and 25% of the available height between them, respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.3 – A simplified view of the layoutGrid and its child controls.
    The top and bottom rows each get 25% of the available height, while the middle
    row is allocated the remaining 50% of the available height at render time'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.03_B17866.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.3 – A simplified view of the layoutGrid and its child controls. The
    top and bottom rows each get 25% of the available height, while the middle row
    is allocated the remaining 50% of the available height at render time
  prefs: []
  type: TYPE_NORMAL
- en: Let’s go through the rows in turn. The first row contains the `titleText` control;
    as its name suggests, it is exactly what it seems like it is – a container for
    displaying the dialog’s title heading. The second, middle row contains the primary
    display content and therefore needs the most room for its scroll viewer (to allow
    arbitrarily long or wide child content – a useful quality to note for later…)
    and its own `userCancel` and `userAccept` buttons. These will be hooked up to
    click logic in the next section and will be spaced using relative (percentage)
    positioning to ensure the buttons stick to their respective sides.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: HTML/CSS folks are probably angrily wondering why we’re not using columns and
    span cells, or a justified alignment with a horizontal StackPanel. Those would
    indeed be wonderful approaches – if cell spanning or full justification alignment
    were available, but as they are not (at the time of writing), alternative approaches
    must be sought!
  prefs: []
  type: TYPE_NORMAL
- en: 'The final stop on our GUIE tour is less of a feature of the editor and more
    of a very strongly recommended workflow practice of naming the controls in the
    tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.4 – Control tree structure with named controls. Having clear, indicative
    names is crucial to effectively integrating the GUIE with applications. The child
    elements of the layoutGrid Grid container display their respective [row:column]
    indices in the tree'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.4_B17866.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.4 – Control tree structure with named controls. Having clear, indicative
    names is crucial to effectively integrating the GUIE with applications. The child
    elements of the layoutGrid Grid container display their respective [row:column]
    indices in the tree
  prefs: []
  type: TYPE_NORMAL
- en: If you have read a certain type of genre fantasy, then you will know that having
    the name of something gives one power over the thing being named, and our GUI
    control tree is no different! Our integration pattern for combining the GUI definition
    with JavaScript logic will hinge on using the power of a control’s name to summon
    it forth when needed, but instead of relying on magic spells and summoning circles,
    we’ll see how to use `Control.findByName` as part of the tidy integration options
    made possible by features in both the Babylon.js GUI and its core framework!
  prefs: []
  type: TYPE_NORMAL
- en: Integration with the GUIE
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s time to move past the GUIE and see how we can make use of its output in
    a simple Playground setting. The Playground at https://playground.babylonjs.com/#WIVN8Z#6
    is what we’ll be using as the starting point for this section; we’ll build it
    out and finish it up in the next section; that is, *Building a Reusable Dialog
    Box Component*. For now, let’s run the Playground and click or tap anywhere in
    the display area to summon a Dialog Box. Clicking one of the buttons will either
    dismiss or spawn a new dialog box, depending on which is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s focus on the `createScene` function. It’s very short – under 40 lines
    of code, with most of the code devoted to subscribing to various Observables of
    the `DialogBox` component and the scene’s `onPointerObservable`. Defining the
    initial dialog `opts` object and creating the `DialogBox` instance rounds out
    the scene creation logic of our Playground, leaving us free to focus our attention
    on how to convert the `const DIALOG_GUI_SNIPPET = "923BBT#32"` line into an interactive
    component, bringing us one step closer to seeing how `DialogBox` works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Right above the `DialogBox` class definition – line 60 – is where the `CONTROL_NAMES`
    constant is defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Recall when we mentioned the importance of names. This is where that discussion
    becomes important! It also becomes the only place in our code that needs to know
    anything specific about how our GUI is structured, allowing us to modify our GUI
    to a certain extent without the need to make corresponding changes to our application
    code.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK – now, we have a map of control names that we can use to access controls
    via code, but we haven’t loaded up anything for our code to access yet. We’ll
    need to create an instance of an `AdvancedDynamicTexture` – fullscreen mode is
    fine – and we also want to make sure that the text and lines are crisp and sharp
    at whatever size it ends up being rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Using `NEAREST_NEAREST` as the sampling method when scaling the texture gives
    the best results for text while the `true` flag for the last parameter enables
    adaptive scaling for a nice look whatever the scale. Now that we have something
    to host the GUI, it’s time to go ahead and load said GUI into the ADT.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we want to use `DIALOG_GUI_SNIPPET` as the source to load our GUI from,
    we’ll need to use the `parseFromSnippetAsync` method from an instance of `AdvancedDynamicTexture`.
    Since the function is asynchronous, this means we can await its completion from
    an appropriately marked `async` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once `advancedTexture` has completed loading the GUI definition from the snippet
    server (and, in the preceding case, opting out of rescaling the texture), it can
    be accessed from `advancedTexture.getControlByName()`. To avoid repetition in
    our code, we can define property accessors in a class or object to wrap the logic
    for getting or setting these control values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, there are two examples of retrieving a control, as well
    as a control’s text value. Additionally, the final property shows a similar process
    for setting the text value of the `titleText` control. These property accessors
    and others like them form a core part of the `DialogBox` class, which is the topic
    of the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The `AdvancedDynamicTexture.getControlByName`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, using this combination of tools, data, and code, it’s time to put theory
    into practice. We need an easier way to implement the concept of a dialog box
    in our application, and there are at least two places that need dialog box functionality
    – route confirmation and scoring. This problem speaks to the need to build something
    once that can be used in multiple situations.
  prefs: []
  type: TYPE_NORMAL
- en: Building a Reusable Dialog Box Component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A reusable component is capable of utilization in multiple places and contexts
    within a particular code base. Designing a reusable component is different from
    designing a single-purpose one in several ways. The most relevant one of these
    ways is that the reusable component’s functionality must be designed to be customizable
    by users without the basic code needing to be reinvented for it to be worked with.
  prefs: []
  type: TYPE_NORMAL
- en: We examined parts of `DialogBox` previously when we looked at how to wrap `advancedTexture.getControlByName`
    in a get or set accessor, so let’s build off that to make an important reminder/note.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `CONTROL_NAMES` enumeration lists all the properties implemented by the
    `DialogBox` class, but there are more properties than there are controls. Getting
    or setting a property such as `titleText` or `bodyText` operates against a text
    control’s `text` property directly.
  prefs: []
  type: TYPE_NORMAL
- en: The key parts of our component are going to be the initialization (construction)
    logic, which is important because it needs to parse the GUI data, entrance, and
    exit management, and event handling things such as button clicks. After examining
    how each of these works, we’ll put the individual pieces together to build the
    route confirmation dialog prompt.
  prefs: []
  type: TYPE_NORMAL
- en: Constructing the DialogBox Class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The constructor function for the `DialogBox` class accepts an options object
    and a Scene instance as its two parameters. These parameters are mostly for pre-populating
    the dialog box’s content, but the `displayOnLoad` parameter is a behavioral flag
    that instead controls whether or not `DialogBox` is supposed to be visible when
    it’s finished loading and initializing. When the value is `false`, then the `show()`
    method must be explicitly invoked to display the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The constructor logic ensures that the dialog box will have any required pieces
    of content populated, even if they’re not specified by the caller. Previously,
    we looked at the creation of `AdvancedDynamicTexture`, along with how to populate
    the GUI elements using `parseFromSnippetAsync`. This is a pattern that we’re using
    for the Playground to load from the snippet server. For the application, we will
    load a JSON file defining the UI using `advancedTexture.parseContent()` – a non-async
    method that also obviates the need to run the initialization logic in the callback
    from `scene.executeWhenReady`, which we used in the Playground. This is the only
    meaningful difference between our Playground’s `DialogBox` class and what will
    eventually end up in the Space-Truckers Application. This highlights the power
    of iterative code design using the PG!
  prefs: []
  type: TYPE_NORMAL
- en: 'The rest of the constructor is devoted to subscribing to and wiring the subcomponents
    of the `DialogBox` class. Our two buttons have their click event handlers wrapped
    by the class and the respective `onAcceptedObservable` and `onCancelledObservable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'To avoid leaking resources, we are capturing the Observers that have been returned
    from the subscription methods in non-public class members (denoted with the `#`
    prefix), which we clean up in the `dispose` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Any ongoing asynchronous operations must be canceled along, with any coroutines
    (see the *Creating the Scoring Dialog with Coroutines* section for a definition).
    The `createScene` function of our Playground demonstrates how this works when
    the initial confirmation `DialogBox` is disposed of in the `onAccept` handler,
    spawning a new `DialogBox` in its place.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our basic `DialogBox` defines two explicit interaction points with users: the
    accept and cancel buttons. It also defines two behaviors: show and hide. Next,
    we’ll learn how the two relate to each other and how to make the show and hide
    methods complete only after the `DialogBox` class has finished transitioning.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling Button Clicks and Changing Visibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to handling the `acceptButton` and `cancelButton` click events,
    the `onAccepted` and `onCancelled` functions both offer customizers for the `DialogBox`
    class to run custom logic before notifying external observers of the event – the
    default behavior shows this by hiding the dialog before triggering the Observable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Both `onAccepted` and `OnCancelled` return a `Promise` that resolves when the
    dialog box has finished hiding itself. If the caller cares about waiting for the
    dialog to fully show or hide itself, it can either use the standard async or Promise
    resolution patterns – that is, `await myDialog.show()` or `myDialog.hide().then(…)`.
    As for the logic to show or hide `DialogBox`, it uses the `BABYLON.setAndStartTimer`
    utility function to trigger the fade-in or fade-out of the `DialogBox` class in
    conjunction with the `Scalar.SmoothStep` function (note that some code has been
    elided in the following listing for space reasons):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, most of the action happens in the `onTick` and `onEnded`
    callbacks of the `setAndStartTimer` option. The dialog starts with an alpha of
    `1` and ends after a period of `#fadeInTransitionDurationMs` (800 ms or so) with
    an alpha of `0`. In between, values are interpolated using the `onTick` argument’s
    `completeRate`, giving a value from `0` to `1` regarding how far the timer has
    progressed to finishing.
  prefs: []
  type: TYPE_NORMAL
- en: The `onEnded` callback removes the `DialogBox` class from foreground rendering
    (see *The Advanced Dynamic Texture* section, earlier in this chapter) and sets
    the GUI’s `isVisible` to `false` before resolving the original Promise. On the
    other hand, `breakCondition` ensures that if the `DialogBox` instance is disposed
    of before completing the hide or show animation, the timer won’t attempt to call
    disposed of objects.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `show()` function is almost identical to the `hide()` function, except that
    it is more like a mirror inverse image than it is a clone. This is because it
    starts as being fully transparent and ends up being completely hidden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s review how to use the `DialogBox` class in five easy steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create an `opts` object containing, at a minimum, a `guiData` field containing
    a snippet ID:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Instantiate a new instance of `DialogBox`, passing in the previously created
    `opts` object and a reference to the Scene:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Attach observers to the dialog box’s `onAcceptedObservable` and `onCancelledObservable`
    to respond to user input (in this case, calling `createScoringDialog`):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call the `show` method to display the `DialogBox` class if the (optional) `displayOnLoad`
    flag is not set to `true`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'To dismiss or hide the dialog, click `cancelButton` or call the `hide()` function.
    To defer action until the `DialogBox` class has completely faded out, the Promise
    that’s returned from `hide` can be awaited:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With our reusable `DialogBox` completed in proof-of-concept form, let’s quickly
    look at the practice of integrating with the Space-Truckers Application by looking
    at how the route planning screen uses it to prompt the player to move to the next
    phase of gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: Prompting Users after Successful Route Planning
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Not too many changes need to be made to the `DialogBox` class from the Playground.
    However, as mentioned in the *Constructing the DialogBox Class* section, we’ll
    be changing from using a snippet loaded from a remote server to a JSON file loaded
    from the game’s assets folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'After saving the GUI JSON definition from the GUIE, the definition is added
    to the `/src/guis` folder as `gui-dialog-buttons-scroll.json`. One important change
    is needed, though, so open up the file and find any external resources (*`.png`)
    to change their URLs from absolute to relative ones pointing to the appropriate
    file in the `assets` folder. For example, the image that’s used as the `DialogBox`
    background will look like this after being modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `DialogBox` class itself is housed next door to the GUI JSON, in `guiDialog.js`,
    and as per our change from the snippet server to JSON, we must add that import
    to the top of the file before passing it into the `DialogBox` constructor as the
    `guiData` property value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Pivoting to `SpaceTruckerPlanningScreen`, we need to add an `import` for `DialogBox`
    to the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'A new `routeConfirmationDialog` attribute has been added to `SpaceTruckerPlanningScreen`,
    initialized near the end of the constructor function with logic that should be
    very familiar if you have read the entirety of this chapter thus far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Now, there is no doubt that the actual copy used in the confirmation dialog
    box could use some work, but it does the job for now – maybe you’ll be the one
    to submit a Pull Request to change it to something a bit more interesting?
  prefs: []
  type: TYPE_NORMAL
- en: On the topic of interesting, the `onAcceptedObservable` handler for the dialog
    does several interesting things. First, it notifies any interested parties that
    the player has accepted the route. Then, it updates `gameState` to reflect the
    new reality before hiding `routeConfirmationDialog` and allowing whatever logic
    is subscribed to `routeAcceptedObservable` to take things from that point. This
    is not too different from the Playground example, and not too much time is needed
    to get that up and running either! We’ll want to hold onto that feeling for now
    though because next, we’re going to be making a series of targeted changes to
    the application to gather, process, and calculate scoring data for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Calculating Scores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Much of the fun that comes from playing a game is through the different ways
    that a game can provide feedback to the player – positive or negative. This is
    a great opportunity for game designers to connect with players at an emotional
    level. Connecting positive events and outcomes to a player’s actions creates a
    feedback loop between the game and the player, and one of the oldest and truest
    connections in gaming is the concept of a point score that accumulates throughout
    gameplay.
  prefs: []
  type: TYPE_NORMAL
- en: The scoring system used in `DialogBox` that is initially empty, but which displays
    each category of scores in a line-by-line fashion before giving the final score.
  prefs: []
  type: TYPE_NORMAL
- en: Before building out the logic to capture and calculate scores, it’s useful to
    define the desired scoring data model in a sample score. This is the desired output
    of the scoring process logic, irrespective of how that logic generates the data.
    This will clue us into what sorts of changes are needed elsewhere in the application
    to support the scoring system.
  prefs: []
  type: TYPE_NORMAL
- en: Scoring System Design
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The score data that is generated and used by **Space-Truckers** can be broken
    down into three broad groups: **score factors**, **multipliers**, and **final
    scores**. Score factors are categories reflecting base attributes of both route
    planning and driving performance. The number of encounters, length of the route,
    and initial launch force are all fixed and set in the Route Planning Phase, but
    the cargo condition is dynamic up until the player reaches their destination in
    the driving phase (sample values have been provided for context):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Below `scoreFactors` are the multipliers. These values are used by the scoring
    calculations to modify one or more `scoreFactors` in various ways that we’ll get
    into in the next section, *Adding Up and Tallying Scores*. However, before we
    move on, there’s just one more thing to do. One last – you may even say final
    – section to cover. `finalScores` are the categorized and summed up values that
    come out of the combination of `scoreFactor` and multipliers. This is what will
    ultimately be displayed to the players in a “here’s the bottom line…” type of
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: Continuing to ignore any sort of details on how the scoring data is captured
    is still a useful tactic because although we may know the general shape of the
    scoring data, until we know how to calculate those scores, we won’t know precisely
    what and where data needs to be captured.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Up and Tallying Scores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The scoring logic is contained within the `src/scoring/spaceTruckerScoreManager.js`
    file. Similar to how we are compartmentalizing using the sample score shown previously,
    consumers of this component only need to call the default export `computeScores`
    and pass in a route data structure to get a `score` object in return. The `computeScores`
    function is a simple orchestration function – its only purpose is to coordinate
    the invocation of the various other functions that are calculating the individual
    scoring areas:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `createDefaultScoring` function in the second line of the preceding listing
    is a `0` or blank values. As the `score` object is passed between each of the
    various `calculateXXXScoreToRef` methods, its values are built up and used by
    successive function calls.
  prefs: []
  type: TYPE_NORMAL
- en: The `ToRef` suffix on these function names indicates that they will be mutating
    a parameter (usually the last parameter provided by convention) rather than creating
    a new instance of one. This is most seen with `Vector` and `Matrix` objects but
    consistency in naming is crucial to the long-term health of a code base! Following
    that are individual subsections that go through the details of each aspect of
    the scoring calculations.
  prefs: []
  type: TYPE_NORMAL
- en: Because we’re still in the development process, we’re not going to worry too
    much about getting these calculations balanced and tweaked to the extent we may
    want. What we need to do is establish a basic way to provide a dynamic scoring
    experience that is easy to come back to later when we’re ready to balance and
    tweak.
  prefs: []
  type: TYPE_NORMAL
- en: Encounter Scores
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We start by calculating the encounter score. Right off, we know that we want
    to get a list of encounters and that we will want to use that list to add up the
    individual modifiers for each encounter to get the final encounter modifier. If
    we assume that the route parameter contains a `pathPoints` object collection (see
    the `/src/driving/spaceTruckerDrivingScreen.calculateRouteParameters` function
    for details) and that any given entry in the `pathPoints` collection may or may
    not have an associated encounter containing a decimal `scoreModifier` value, then
    we can use a simple `map` and `reduce` operation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code calls `map` with a simple extraction function that retrieves
    the `scoreModifier` value – a number. Next, it passes the array of `scoreModifier`
    numbers to the `reduce` function. `Array.reduce` (if you aren’t already familiar
    with it) is a useful aggregation tool that takes a function as its primary parameter.
    Looping (or iterating) over the array, `arr`, the function is invoked for each
    `curr` element in turn, with the results of the `prev` operation being passed
    along with the value of the `curr` element at the `cidx` position. This is just
    a fancy way of saying that the `reduce` operation sums up the total of all the
    elements in an array of numbers! This aggregated value becomes `encounterModifier`,
    which is used in conjunction with the overall number of encounters to determine
    the total encounters score value.
  prefs: []
  type: TYPE_NORMAL
- en: Route Scores
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Route scoring calculations are performed slightly differently from encounter
    scoring. The main factor for route scoring is the length of the overall route
    (how far the cargo had to travel before arriving), but there are several equally
    important modifiers. When it comes to `transitTime` of the route, there are two
    relevant values: the planned transit time and the actual (driving phase) transit
    time. The ratio between those values, when added to a constant, gives us `transit.factor`,
    an important multiplier that’s used in two ways. First, it is applied to `distanceTraveled`;
    after it is applied to the `launchForce` value, which is used during the Route
    Planning Phase. The first is subtracted from the second to produce the final Route
    Score value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Cargo Scores
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Cargo scoring is based primarily on the condition of the cargo upon arrival,
    meaning that it reflects player performance from the Driving phase. The cargo
    starts with a condition value of 100\. When collisions with encounters or with
    sufficient velocity occur, the route path can reduce that value (see the *Capturing
    Scoring Data* section for more), which is used as the basis for the Cargo Score
    after it’s been scaled by the condition multiplier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Bonus Scoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If the player delivers their cargo in pristine condition, extra rewards are
    in order. In that case, the Delivery Bonus is applied to `finalScores`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Final Scoring
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Once all the various sub-scores have been tallied and multiplied, it’s time
    to sum them all up to get our total value. After populating with `BASE_DELIVERY_SCORE`,
    we use `Object.values` to produce an array of numbers that we (sound familiar?)
    pass to another `reduce` operation to give the `Final Total` score value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Putting these computations together helps give us an idea of what data is already
    available in the route and what needs to be collected. There’s more information
    about a game session than just the route path, after all!
  prefs: []
  type: TYPE_NORMAL
- en: Capturing Scoring Data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the sample scoring data serving as a guide, we can work backward to identify
    the places in the application where scoring data is generated before capturing
    it. This may result in the need to update or change existing data structures and
    code, but that’s OK because we will also make the needed changes to allow players
    to complete the driving phase and see their final scores displayed in their full
    glory!
  prefs: []
  type: TYPE_NORMAL
- en: Enriching the Route Data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first and possibly the biggest change is that we’ve added a new `routeData`
    property to `SpaceTruckerPlanningScreen`, which packages up all data needed by
    the scoring calculations later in the game (see the *Adding Up and Tallying Scores*
    section for more):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`routePath` of the `Cargo` object tracks encounters and other path-specific
    data, while the other values provide a baseline travel time and the length of
    the route. Encounters were already being captured as part of `cargoData` associated
    with the encounter, but the additional `scoreModifier` field is needed for every
    encounter listed in the `route-planning/gameData.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: There’s still more to do, but this completes the data collection aspect of scoring.
    Next, we need to add a trigger that will initiate the scoring process (provided
    the player has finished the route…) and show the Scoring Dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Completing the Driving Phase
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'So far, the `SpaceTruckerDrivingScreen.killTruck` function has indiscriminately
    performed the grim responsibilities implied in its name. Today, though, is different.
    Today, the Grim Reaper of trucks gets a conscience:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: When the method is called by the `onMeshIntersectExit` action trigger, it checks
    the absolute (World reference) position of the mesh against the closest Path3D
    segment of the route. See [*Chapter 8*](B17266_08_Final_AM.xhtml#_idTextAnchor166),
    *Building the Driving Game*, the *Generating the Driving Path* section for more
    on Path3D and how it relates to the route path.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Path3D exposes positions as a normalized route with positions between 0 (beginning)
    and 1 (end).
  prefs: []
  type: TYPE_NORMAL
- en: 'Should the truck happen to exit its route path (thus triggering this method)
    too far from its destination, the Grim Task of reaping continues as it did in
    the past. Let’s not dwell on the past and instead look to the alternative, happy
    future that involves calling the `completeRound` method of the `SpaceTruckerDrivingScreen`
    class. The first two things that need to happen are that we want to hide the driving
    phase GUI, which we do by setting the appropriate `layerMask` to `0`. Next, we
    transition the screen to the `DRIVING_STATE.RouteComplete` state to prevent further
    updates to the simulation that may impact scoring, which, speaking of, is what
    immediately follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Once the scoring data has been gathered and computed, `createScoringDialog`
    (from `/src/scoring/scoringDialog.js`) is invoked to do the necessary `DialogBox`
    creation and management; all that remains for `completeRound` to do is hook up
    the `onAcceptedObservable` and `onCancelledObservable` properties to the appropriate
    logic. Then, we are good to go from the standpoint of the driving screen!
  prefs: []
  type: TYPE_NORMAL
- en: 'The `createScoringDialog` function is a nice analogy to this book; it starts
    with the familiar, then mixes in something completely unexpected and/or unfamiliar
    as it progresses until, by the end, it seems like everything works by magic. Let’s
    finish this section by looking at the familiar parts of the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This is slightly different from the Playground at [https://playground.babylonjs.com/#SQG1LV#28](https://playground.babylonjs.com/%23SQG1LV%2328),
    but only because the PG doesn’t have `SpaceTruckerSoundManager` to retrieve and
    manage the sound used by the next section. There’s nothing unusual in this code
    until the very last line. What a fantastic opportunity as well to introduce one
    of the more exciting features of Babylon.js v5 – coroutines!
  prefs: []
  type: TYPE_NORMAL
- en: The logic involved in calculating the scores themselves is as simple as possible
    and no more – it requires nothing but the data passed into it directly to operate,
    but that data needs to come from somewhere. The different categories of scores
    are sourced from different components of the game; encounters contribute to their
    multiplier, transit times are calculated in both driving and route planning, and
    the cargo’s health is tracked by the truck during driving. Each of these factors
    and multipliers contributes to the overall final scores that get displayed in
    the Scoring Dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Scoring Dialog Using Coroutines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you have come from a background working with Unity, Unreal, or other game
    engines, you might be familiar with the concept of a coroutine. A coroutine in
    those contexts is defined much the same way as it is in Babylon.js: a stateful
    method that runs across multiple frames of rendering.'
  prefs: []
  type: TYPE_NORMAL
- en: Though it may imply the presence of multiple threads, typically, in most frameworks
    (for example, Unity and most certainly JavaScript!), this is not the case. The
    C# programming language uses Iterators along with the **yield** keyword to implement
    coroutines, but in JavaScript, we use a (spoiler alert!) **function* generator**.
    Bet no one saw that callback to [*Chapter 4*](B17266_04_Final_AM.xhtml#_idTextAnchor070),
    *Creating the Application* coming! Instead of using them as part of our application’s
    state machine, we’re going to define the logic that will make the score dialog’s
    scoring entries count upwards from zero, along with playing a cash-register type
    of sound. Lastly, we’ll crank things up to 11 by looking at a standalone Playground
    sample to show how it’s possible to devise a controller system composed of multiple,
    independently reusable behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing Function Generators
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a more detailed overview of JavaScript function generators, see [*Chapter
    4*](B17266_04_Final_AM.xhtml#_idTextAnchor070), *Creating the Application*, the
    *Space-Truckers – The State Machine* section. Here’s a quick example of a `function`
    generator to help remind us how they work and how to use them. Let’s say that
    our designers have devised a color palette for printing the rows of a report.
    We can define a `nextColor()` star function that will produce a new hex color
    string at every iteration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'When a function is generated by calling `nextColor()`, it will always produce
    a color from the list, in order, when requested. Where does this come into play?
    The `createScoringBlock(label)` function is responsible for creating and styling
    the actual GUI element that is displayed in the scoring `DialogBox`, calling `colorPicker.next()`
    to produce a new value each time it is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: There’s our brief review of `function*` concepts, all packed up nice and tidy.
    Now, let’s see how those fit into coroutines and Babylon.js by looking deeper
    into `scoringDialog.js`, where we’ll unwrap `scoringAnimationCo` and put it to
    work in our `DialogBox`!
  prefs: []
  type: TYPE_NORMAL
- en: Counting Player Scores with a Coroutine
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Coroutines are neat because they allow the developer to express complex behavior
    via relatively simple logic (when done right). Any time a coroutine wants to return
    control to the caller, it calls `yield` – with or without arguments (see the *Advanced
    Coroutine Usage* section). The timing and manner in which a `BABYLON.Observable`
    for that CoRo.
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: New in the Babylon.js v5 Observable API is the `Observable.runCoroutineAsync`
    and `Observable.cancelAllCoroutines` functions. See [https://doc.babylonjs.com/divingDeeper/events/coroutines](https://doc.babylonjs.com/divingDeeper/events/coroutines)
    for more!
  prefs: []
  type: TYPE_NORMAL
- en: If attached to one of the Scene’s render event Observables, the CoRo will run
    every frame, whenever the host Observable is triggered. If attached to `scene.onPointerObservable`,
    the CoRo will fire any time the pointer moves or interacts with the scene. This
    is incredibly powerful when combined with the way that JavaScript closures work
    – since an iterator function is a stateful construct, it can remember and track
    past events and conditions as they evolve over multiple frames of simulation/rendering.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes a coroutine ideal for implementing a sort-of “cash register” style
    of tallying up the player’s scores and presenting the final totals in conjunction
    with the `DialogBox` class created earlier as part of the `createScoringDialog`
    function. The coroutine logic can be deceptively simple: given a score object
    generated by the Scoring Manager (see the *Adding Up and Tallying Scores* section)
    and a scene, loop over each property of the Final Scores property and display
    its value in the `DialogBox` class by counting up to it from zero:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 9.5 – A logical flowchart of the scoringAnimationCo behavior. Circles
    represent yield statements with the optional use of Tools.DelayAsync. Rectangles
    list the actions taken'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_9.05_B17866.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 9.5 – A logical flowchart of the scoringAnimationCo behavior. Circles
    represent yield statements with the optional use of Tools.DelayAsync. Rectangles
    list the actions taken
  prefs: []
  type: TYPE_NORMAL
- en: 'The preceding diagram shows that several other pieces need to be handled: the
    height of the `bodyStack` StackPanel needs to be adjusted to account for the new
    row that was added to it, the scrollbar that contains the `bodyStack` control
    needs to be set to its new maximum value to ensure that the current line of text
    is fully visible, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Despite the seeming complexity of this logic, it comprises well under 100 lines
    of code! If we only look at the actual logic of the coroutine and exclude the
    state management code, we have even fewer lines of code to write:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The value for `MAX_COUNT` was arbitrarily determined via experimentation; it
    controls the length of the counting animation. The progress is governed by the
    `SmoothStep` function, which starts slow before speeding up greatly just before
    coming to a gentle stop at the end. Every time `Tools.DelayAsync` is passed as
    the argument to `yield`, the coroutine will pause itself for the indicated amount
    of time – or as close to it as possible – before resuming execution.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Because frame delta times don’t always add up to the exact amount of time specified,
    a coroutine can be paused for slightly longer than the indicated amount of time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When all is said and done and the final `returns` rather than `yields`, indicating
    completion and signaling to the hosting `onBeforeRenderObservable` that it’s OK
    to clean up and dispose of that coroutine function instance. From the perspective
    of the code that started things off, we have two simple lines – one to create
    the iterator function and another to start it running:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: In this scenario, we don’t want to block execution and wait until the coroutine
    completes to continue executing `createScoringDialog`, but if we were doing something
    different, such as making asynchronous HTTP calls as part of a coroutine, it would
    be prudent to await or capture the returned Promise of `runCoRoutineAsync`. Thus,
    it can be used and passed around just like any other asynchronous operation, allowing
    for more advanced scenarios and complex behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced Coroutine Usage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unless you’re a passenger on the Titanic, there’s good news: this is just the
    tip of the iceberg! Because coroutines leverage the underlying mechanics of function
    iterators, it’s possible to use the `yield*` operator to chain together multiple
    `function*` iterations into a single coroutine, as exemplified in the Playground
    at [https://playground.babylonjs.com/#5Z2QLW#1](https://playground.babylonjs.com/%235Z2QLW%231).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: See [https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/yield*)
    for more details and examples of using the `yield*` operator.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `yield*` operator is used in the context of a `function*` body, and provides
    a way to “pass through” the results of another iterator function – or, and this
    is easily missed part of the definition (emphasis added):'
  prefs: []
  type: TYPE_NORMAL
- en: “The yield* expression is used to delegate to another generator or iterable
    object.”
  prefs: []
  type: TYPE_NORMAL
- en: Although not used in our example, this would allow a developer to, for example,
    write a coroutine that produced a stream of values from an array populated by
    device sensors, among many other applications. In our example, we are using the
    `yield*` operator analogously as we may extract reusable code into a function
    by invoking another `function*`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Seemingly a small detail, this ability to execute other iterator functions
    allows us to use the powerful Compositional pattern of software design to put
    simple building blocks together to express complex behavior. We start with the
    `function* think()` coroutine. It is named appropriately because its job is to
    decide what the sphere mesh is going to do next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Think of the preceding code as the *primary controller* or, more colloquially,
    the AI for a game object. It can read the environment and make decisions on what
    to do. In our case, it waits for a second and a half before invoking the `moveToTarget`
    function (listed in the following code snippet) with the desired target position.
    This moves the sphere from wherever it is positioned in the middle of the right-hand
    side of the perimeter Plane. After another short delay, the `patrolCo` function
    is invoked.
  prefs: []
  type: TYPE_NORMAL
- en: '`function* patrolCo` is another compositional element that combines multiple
    `moveToTarget` iterations, along with logic, to change the color of the sphere
    on every movement direction change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Each set of `yield*` statements delegates execution to the `moveToTarget` function,
    which is the real workhorse of this example. This behavior does what it says on
    the tin – it moves the subject (the sphere mesh, in our case) of the behavior
    as close as it can to the given target world position. A `maxDelta` value caps
    the amount of ground the sphere can cover in any given frame (due to the coroutine
    being hosted and executed by `onBeforeRenderObservable`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The direction of movement is computed by subtracting the two relevant position
    vectors, the result of which is used to determine whether the sphere has arrived
    at its destination, as well as moving the sphere by adding a scaled vector pointing
    toward `targetPosition`. Upon arrival, the iterator function returns control to
    the calling iterator function – either `patrolCo()` or `think()`, which then proceeds
    to the next step in its iterator chain.
  prefs: []
  type: TYPE_NORMAL
- en: This simple example can easily be extended with additional behavior and logic,
    simply by adding additional `function*` definitions. Like a library or toolbox
    of behaviors, simple behaviors such as `moveToTarget` are stitched together into
    more complex behaviors such as `patrolCo`, which is, in turn, orchestrated by
    the overall `think` function iterator endlessly pondering the game’s world. An
    entire non-player actor/controller can be quickly put together in this fashion!
    Hopefully, by presenting the concepts in an isolated Playground, it’s easier to
    see how composition can make the whole greater than the sum of its parts.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve accomplished a lot in this chapter. Starting with the `DialogBox` was
    designed and saved to both the snippet server and JSON. After learning how to
    use it in conjunction with the `DialogBox` component and tested it by adding the
    Route Planning confirmation dialog.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with those initial results, we turned to the scoring system used in Space-Truckers
    and the logic needed to calculate each area of the scoring game. The data to accomplish
    this became apparent throughout, so we made the needed modifications to the **Space-Trucker
    Application** to capture scoring data. Because we already have the foundational
    dialog structure in place, it’s easy to create the **Scoring Dialog** from both
    captured and sample scoring data.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s not enough to simply display the scores in our Scoring Dialog, though,
    so we employed another new feature in v5 of Babylon.js: `BablyonJS.Observable`
    (but mostly used in `onBeforeRenderObservable`), coroutines allow complex multi-frame
    logic to be simply written and executed. Through `scoringAnimationCo`, each line
    of the Final Scores object is displayed and counted to its final value from zero.'
  prefs: []
  type: TYPE_NORMAL
- en: Moving away from the Scoring Dialog, we wrapped up this chapter by learning
    how to use coroutines with multiple `moveToTarget` and `patrolCo`.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to look at the space of Space-Truckers by diving
    into environments, **Image-Based Lighting** (**IBL**), and how to use **Physically-Based
    Rendering** (**PBR**) with Babylon.js. From workflows for converting images for
    use with IBL to adding post-processes for effect, we’ll see how easy it is to
    take a few lines of code and make something attractive and performant!
  prefs: []
  type: TYPE_NORMAL
- en: Extended Topics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It’s important not to focus too much on the particulars of the `DialogBox`
    design UI – this book isn’t a book on graphic design, much to everyone’s relief
    – so here are some ideas and resources for taking your UI adventures to the next
    level:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Babylon.js team ran a summer event in August 2022 that urged community
    members to submit the amazing UI builds they had created with the GUIE. Two “starter”
    templates were provided for people that didn’t have an existing project:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://playground.babylonjs.com/#QCH724#1](https://playground.babylonjs.com/%23QCH724%231)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://playground.babylonjs.com/#QCH724#1](https://playground.babylonjs.com/%23QCH724%231)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: These two samples are for a main menu system and an in-game menu and inventory
    system – what sorts of things can you build when you combine those as a starting
    point with what you’ve learned in this chapter?
  prefs: []
  type: TYPE_NORMAL
- en: The Space-Truckers Main Menu is very much imperatively coded as opposed to the
    GUIE JSON files, which are declarative. As we’ve seen, a declarative data-driven
    UI is much easier to build and maintain, so try applying that knowledge to the
    Main Menu by replacing some of the GUI components created in code with a `DialogBox`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Composable coroutines can provide a simple and easy way to add interesting
    behaviors to a game or application. Add a way for an arbitrary encounter instance
    in the Driving Phase to run a coroutine “behavior.” The encounter itself should
    provide the coroutine, but it will need to be provided with current game state
    information:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Three components working together can help cleanly separate and define this
    functionality:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A Behavior component that does the “thinking”
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A Think Context that provides a vehicle for state information
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A set of actions that the behavior(s) can perform (for example, “Move,” “Eat,”
    “Disperse,” “Acquire Target,” and so on)
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: An encounter coroutine may load a mesh and material, set some values, and perform
    other initialization tasks before beginning its behavioral “think” loop.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Actions can be other coroutine behaviors, such as patrolling behavior.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
