- en: Chapter 4. Test Spies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 4 章。测试间谍
- en: As we begin looking at the more complicated parts of our Backbone.js application,
    the process of isolating dependencies and testable behaviors can become an increasingly
    daunting task. To provide a little help in these areas, we will introduce Sinon.JS,
    which is a powerful test mock, stub, and spy library, in this chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们开始查看我们 Backbone.js 应用程序中更复杂的部分时，隔离依赖项和可测试行为的流程可能会变得越来越艰巨。为了在这些领域提供一些帮助，我们将介绍
    Sinon.JS，这是一个强大的测试模拟、存根和间谍库，在本章中。
- en: 'Sinon.JS allows us to artificially isolate Backbone.js components and test
    specific behaviors without interacting with the rest of the application. We will
    kick off our discussion on Sinon.JS with the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 允许我们人为地隔离 Backbone.js 组件并测试特定的行为，而无需与应用程序的其他部分交互。我们将从以下主题开始讨论 Sinon.JS：
- en: Identifying some of the test limitations typically found in Backbone.js applications
    and testing scenarios that can benefit from test fakes
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别在 Backbone.js 应用程序和测试场景中通常发现的测试限制，以及可以从中受益的测试模拟
- en: Introducing the Sinon.JS test double and assertion library
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍 Sinon.JS 测试替身和断言库
- en: Learning how to examine application behavior with test spies
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用测试间谍检查应用程序行为
- en: Integrating the Sinon-Chai plugin into Chai for better test assertions
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将 Sinon-Chai 插件集成到 Chai 中以实现更好的测试断言
- en: Testing Backbone.js application components with test spies and other Sinon.JS
    utilities
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用测试间谍和其他 Sinon.JS 工具测试 Backbone.js 应用组件
- en: Fake it 'til you make it
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 假装你做到了
- en: Ideally, we would run insulated, fast, and consistent tests on all parts of
    a Backbone.js application without any modifications. In actuality, these goals
    encounter hurdles for at least some of the real code paths in a Backbone.js application.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，我们将在 Backbone.js 应用程序的所有部分上运行隔离、快速且一致的测试，而无需任何修改。实际上，这些目标至少在 Backbone.js
    应用程序的一些实际代码路径上会遇到障碍。
- en: 'We want to test Backbone.js components in *isolation*, but many components
    have dependencies on other parts of the application. We also want the tests to
    run *quickly*, but many parts of a Backbone.js application can slow things down,
    including the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望对 Backbone.js 组件进行 *隔离* 测试，但许多组件依赖于应用程序的其他部分。我们还想让测试 *快速* 运行，但 Backbone.js
    应用程序中的许多部分可能会减慢速度，包括以下内容：
- en: Network communication, such as persisting a model state to a remote backend
    datastore or a third party API
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络通信，例如将模型状态持久化到远程后端数据存储或第三方 API
- en: Complex DOM manipulation with Backbone.js views and templates
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Backbone.js 视图和模板进行复杂的 DOM 操作
- en: Timed events and DOM animations, especially those that deliberately wait (such
    as a slow jQuery fade)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定时事件和 DOM 动画，尤其是那些故意等待的（例如缓慢的 jQuery 淡入）
- en: Finally, many events and execution paths in a Backbone.js application are non-deterministic.
    For example, parallel network requests and user inputs can be received by the
    application in any order. To deal with these issues, we sometimes have to look
    beyond the actual program code and fake out some parts of the application during
    tests. For a deeper dive into some of the common testing limitations and motivations
    for faking, see *Planning, Cheating and Faking Your Way Through JavaScript Tests*
    by *Christian Johansen* (the creator of Sinon.JS) at [http://msdn.microsoft.com/en-us/magazine/gg649850.aspx](http://msdn.microsoft.com/en-us/magazine/gg649850.aspx).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Backbone.js 应用程序中的许多事件和执行路径是非确定性的。例如，并行网络请求和用户输入可以以任何顺序被应用程序接收。为了处理这些问题，我们有时必须超越实际的程序代码，并在测试期间模拟应用程序的一些部分。有关一些常见的测试限制和模拟动机的深入了解，请参阅
    Christian Johansen（Sinon.JS 的创造者）所著的 *规划、作弊和模拟通过 JavaScript 测试*，可在 [http://msdn.microsoft.com/en-us/magazine/gg649850.aspx](http://msdn.microsoft.com/en-us/magazine/gg649850.aspx)
    查看。
- en: 'The modern techniques used to observe and/or replace program behaviors are
    collectively dubbed **test doubles**. The test doubles that we use in this book
    include:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 用于观察和/或替换程序行为的现代技术统称为 **测试替身**。本书中使用的测试替身包括：
- en: '**Spies**: A test spy wraps a method under test and records inputs and outputs
    for later use. However, it does not change any of the underlying method functionality,
    as a spy is merely an observer. Test spies are useful in situations where we want
    to check how and when a given function is called from other parts of the application.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**间谍**：测试间谍包装要测试的方法并记录输入和输出以供以后使用。然而，它不会更改任何底层方法功能，因为间谍只是一个观察者。测试间谍在需要检查给定函数如何以及何时从应用程序的其他部分被调用的情况下非常有用。'
- en: '**Stubs**: A test stub is a spy that additionally replaces the functionality
    of a method under test with a new behavior. Stubs are quite useful for test isolation.
    For example, when testing a single method that normally calls other functions,
    we can simply "stub out" the external function calls with a preprogrammed behavior.
    In this manner, tests can execute the specific code under test while faking out
    everything else.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**桩（Stubs）**: 测试桩是一个间谍，它除了替换被测试方法的函数功能外，还添加了新的行为。桩对于测试隔离非常有用。例如，当测试一个通常调用其他函数的单个方法时，我们可以简单地使用预编程的行为“桩化”外部函数调用。这样，测试就可以执行特定的测试代码，同时伪造其他所有内容。'
- en: '**Mocks**: Mocks are a combination of spies and stubs (observing function calls
    and replacing function behavior) that additionally verify expected function behavior
    during execution.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟（Mocks）**: 模拟是间谍和桩的组合（观察函数调用并替换函数行为），在执行期间还验证预期的函数行为。'
- en: Note
  id: totrans-19
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a good survey on test doubles, including approaches beyond the three we
    identified, see *Exploring The Continuum Of Test Doubles* by *Mark Seeman* ([http://msdn.microsoft.com/en-us/magazine/cc163358.aspx](http://msdn.microsoft.com/en-us/magazine/cc163358.aspx))
    and *Test Double Patterns* web page by *Gerard Meszaros* ([http://xunitpatterns.com/Test%20Double%20Patterns.html](http://xunitpatterns.com/Test%20Double%20Patterns.html)).
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 对于关于测试替身的良好概述，包括我们识别出的三种方法之外的方案，请参阅*探索测试替身连续体*（*Exploring The Continuum Of Test
    Doubles*）由*马克·西曼*（*Mark Seeman*）所著（[http://msdn.microsoft.com/en-us/magazine/cc163358.aspx](http://msdn.microsoft.com/en-us/magazine/cc163358.aspx)）以及*测试替身模式*网页（*Test
    Double Patterns*）由*杰拉尔德·梅萨罗斯*（*Gerard Meszaros*）所著（[http://xunitpatterns.com/Test%20Double%20Patterns.html](http://xunitpatterns.com/Test%20Double%20Patterns.html)）。
- en: Getting to know Sinon.JS
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 了解 Sinon.JS
- en: Sinon.JS is a popular test double library that provides spies, stubs, mocks,
    fake servers, and various helpers. We will introduce two Sinon.JS interfaces in
    this chapter—spies and the sandboxed test helper—and discuss the rest in [Chapter
    5](ch05.html "Chapter 5. Test Stubs and Mocks"), *Test Stubs and Mocks*.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 是一个流行的测试替身库，它提供了间谍、桩、模拟、假服务器和各种辅助工具。在本章中，我们将介绍两个 Sinon.JS 接口——间谍和沙盒测试辅助工具——并在第
    5 章（[http://example.org/ch05.html](http://example.org/ch05.html) "第 5 章。测试桩和模拟"）*测试桩和模拟*中讨论其余内容。
- en: Spying on functions with Sinon.JS
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Sinon.JS 监视函数
- en: Sinon.JS provides extensible test spies that can record many different aspects
    of a function execution, including calling parameters, return values, and thrown
    exceptions. The basic developer workflow is to create a spy, hook it into a function
    under test, execute the function, and then verify that the spy's recorded information
    matches with the test expectations. In this section, we will walk through the
    different ways to create spies and discuss some of the most useful parts of the
    Sinon.JS spy API.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 提供了可扩展的测试间谍，可以记录函数执行的许多不同方面，包括调用参数、返回值和抛出的异常。基本开发者工作流程是创建一个间谍，将其连接到被测试的函数，执行该函数，然后验证间谍记录的信息与测试期望相匹配。在本节中，我们将介绍创建间谍的不同方法，并讨论
    Sinon.JS 间谍 API 中一些最有用的部分。
- en: Anonymous spies
  id: totrans-25
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 匿名间谍
- en: 'Spies can be created as anonymous standalone functions, which are often used
    to test event logic in Backbone.js applications. For example, we create a Backbone.js
    event object and an anonymous Sinon.JS spy in the following code. The spy listens
    to the `foo` event, which we trigger. Then, we can inspect the spy and assert
    that the spy was called once and passed `42` as a parameter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 间谍可以作为匿名独立函数创建，这通常用于测试 Backbone.js 应用程序中的事件逻辑。例如，我们在以下代码中创建了一个 Backbone.js 事件对象和一个匿名
    Sinon.JS 间谍。间谍监听 `foo` 事件，我们触发该事件。然后，我们可以检查间谍并断言间谍被调用了一次，并且传递了 `42` 作为参数：
- en: '[PRE0]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Spy assertions
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 间谍断言
- en: 'Sinon.JS provides assertion helpers for many spy methods and properties with
    the `sinon.assert` object. In the previous example, we used Chai assertions to
    verify the spy''s recorded information. But, we could have equivalently used Sinon.JS
    assertions as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 为许多间谍方法和属性提供了 `sinon.assert` 对象的断言辅助函数。在先前的示例中，我们使用了 Chai 断言来验证间谍记录的信息。但是，我们也可以等效地使用
    Sinon.JS 断言，如下所示：
- en: '[PRE1]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `sinon.assert` helpers have an advantage over most equivalent Chai assertions
    for the reason that the failure messages are informative and specific. For example,
    a failing assertion for `sinon.assert.calledWith(spy, 42)` produces the error
    message `AssertError: expected spy to be called with arguments 42`.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '`sinon.assert` 辅助函数与大多数等效的 Chai 断言相比有一个优点，即失败信息是信息性和具体的。例如，对于 `sinon.assert.calledWith(spy,
    42)` 的失败断言会产生错误信息 `AssertError: expected spy to be called with arguments 42`。'
- en: Function spies
  id: totrans-32
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 函数间谍
- en: 'Sinon.JS spies can wrap existing functions as well. In the following example,
    we wrap the function `divide` with a spy, producing `divAndSpy`. Then, we can
    call `divAndSpy` in any manner that we could for `divide`. We can also inspect
    spy properties such as `calledWith()` in the wrapped spy:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 间谍还可以包装现有的函数。在以下示例中，我们使用间谍包装函数 `divide`，产生 `divAndSpy`。然后，我们可以以任何可以用于
    `divide` 的方式调用 `divAndSpy`。我们还可以检查包装间谍的间谍属性，如 `calledWith()`：
- en: '[PRE2]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Object method spies
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 对象方法间谍
- en: Finally, Sinon.JS spies can wrap methods in objects. This is a particularly
    powerful means of spying on one method within an overall class or Backbone.js
    component to gather information throughout the entire execution path. The wrapped
    object methods contain Sinon.JS spy properties, meaning that we do not have to
    separately track a spy variable.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Sinon.JS 间谍可以包装对象中的方法。这是在整体类或 Backbone.js 组件中监视一个方法以在整个执行路径中收集信息的特别强大的手段。包装的对象方法包含
    Sinon.JS 间谍属性，这意味着我们不需要单独跟踪间谍变量。
- en: 'Wrapped object methods remain spies until unwrapped with the `restore()` function,
    which removes the spy and reinstates the original function. As an example, let
    us consider the following object with two methods:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 包装的对象方法在用 `restore()` 函数取消包装之前仍然是间谍，该函数移除间谍并恢复原始函数。作为一个例子，让我们考虑以下具有两个方法的对象：
- en: '[PRE3]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We can spy on `multiply` to verify its call and return values, and spy on `error`
    to check that it throws an expected exception. In both cases, we call the wrapped
    object method directly (for example, `obj.multiply()`) and then access the method
    spies. Finally, we need to call `restore()` at the end of the test to unwrap the
    spies on `obj`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以监视 `multiply` 来验证其调用和返回值，并监视 `error` 来检查它是否抛出预期的异常。在这两种情况下，我们直接调用包装的对象方法（例如，`obj.multiply()`），然后访问方法间谍。最后，我们需要在测试结束时调用
    `restore()` 来取消包装 `obj` 上的间谍：
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Playing in the sandbox with Sinon.JS test helpers
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Sinon.JS 测试助手在沙盒中玩耍
- en: 'One issue with the previous example spec is that if an assertion fails before
    `restore()` is called, the object methods are still wrapped in the spies. If any
    subsequent (and otherwise passing) test tries to wrap an already wrapped method,
    Sinon.JS will throw an error such as `TypeError: Attempted to wrap <function name>
    which is already wrapped`.'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: '之前示例规范的问题之一是，如果在调用 `restore()` 之前断言失败，对象方法仍然被间谍包装。如果任何后续（并且其他方面通过）的测试尝试包装已经包装的方法，Sinon.JS
    将抛出错误，例如 `TypeError: Attempted to wrap <function name> which is already wrapped>`。'
- en: Thus, it is important to ensure that each spy eventually calls `restore()`,
    regardless of whether or not the underlying test has passed. One way of achieving
    this is with a `try`/`finally` block in the test. Another way is to create spies
    in a `before` function and call `restore()` on them in an `after` function. However,
    the easiest and the most flexible way is to perhaps use the `sinon.test` sandbox
    function.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，确保每个间谍最终都调用 `restore()` 是很重要的，无论底层测试是否通过。实现这一目标的一种方法是在测试中使用 `try`/`finally`
    块。另一种方法是创建间谍在 `before` 函数中，并在 `after` 函数中调用它们上的 `restore()`。然而，最简单且最灵活的方法可能是使用
    `sinon.test` 沙盒函数。
- en: Sinon.JS provides an execution environment dubbed as a **sandbox** that can
    be configured with spies, stubs, mocks, and other fake objects (for example, fake
    timers and AJAX requests). Conveniently, all faked properties and methods can
    be unwound with a single `restore()` call on the sandbox object.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 提供了一个称为 **沙盒** 的执行环境，可以配置间谍、存根、模拟和其他假对象（例如，假定时器和 AJAX 请求）。方便的是，所有伪造的属性和方法都可以通过在沙盒对象上调用单个
    `restore()` 调用来取消包装。
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Reviewing the Sinon.JS sandbox documentation at [http://sinonjs.org/docs/#sandbox](http://sinonjs.org/docs/#sandbox)
    is highly recommended. There are some subtle pitfalls and surprises related to
    how an application execution changes within a sandbox. For example, the default
    sandbox will fake time and the related functions such as `setTimeout`. It means
    that if your code waits for 10 milliseconds before execution, it will not run
    until the developer *manually* advances the time in the fake `clock` object.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 高度推荐查看 [Sinon.JS 沙盒文档](http://sinonjs.org/docs/#sandbox)。在沙盒中应用程序执行方式的变化涉及一些微妙的问题和惊喜。例如，默认沙盒会伪造时间和相关函数，如
    `setTimeout`。这意味着如果您的代码在执行前等待 10 毫秒，它将不会在开发者**手动**推进假 `clock` 对象的时间之前运行。
- en: 'The `sinon.test` wrapper function takes this one step further by creating a
    default sandbox, which is automatically restored after the wrapped code finishes
    its execution. Repeating our previous object method example with `sinon.test`
    yields a more elegant version of the spec, in which we don''t manually call `restore()`
    on the spies and still guarantee that the wrapped object methods are restored:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`sinon.test` 包装函数通过创建默认的沙盒，并在包装的代码执行完成后自动恢复，将这一步进一步。使用 `sinon.test` 重复我们之前的对象方法示例，可以得到一个更优雅的规范版本，其中我们不需要手动在间谍上调用
    `restore()`，同时仍然保证包装的对象方法被恢复：'
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: While the `sinon.test` helper is a handy tool for managing Sinon.JS objects,
    it is not always an appropriate choice for every spec. For example, asynchronous
    Mocha tests are tricky because `sinon.test` can potentially restore the entire
    sandbox before the `done()` parameter is later called in the test code. Additionally,
    a side effect of using `sinon.test` is that the Mocha test reporter will no longer
    show the test code when clicking on a spec description in the test driver web
    page. The reason for this makes sense—`sinon.test` wraps the actual test function,
    so `sinon.test` is all that the Mocha reporter sees. It is ultimately a matter
    of developer intuition and experience as to when to use the `sinon.test` shortcut.
    In this book we use the wrapper for a subset of our synchronous Sinon.JS-based
    specs.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `sinon.test` 辅助工具是管理 Sinon.JS 对象的有用工具，但它并不总是适合每个规范。例如，异步 Mocha 测试很棘手，因为 `sinon.test`
    可能会在测试代码中稍后调用 `done()` 参数之前恢复整个沙盒。此外，使用 `sinon.test` 的副作用是，Mocha 测试报告器在测试驱动网页中点击规范描述时将不再显示测试代码。这个原因是有道理的——`sinon.test`
    包装了实际的测试函数，因此 `sinon.test` 是 Mocha 报告器所看到的全部。何时使用 `sinon.test` 简化方法，最终取决于开发者的直觉和经验。在这本书中，我们使用包装器来处理我们基于
    Sinon.JS 的同步规范的一部分子集。
- en: Delving into the Sinon.JS spy API
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 深入了解 Sinon.JS 间谍 API
- en: Sinon.JS spies provide a fairly comprehensive set of properties and methods
    for inspecting execution information (see [http://sinonjs.org/docs/#spies](http://sinonjs.org/docs/#spies)
    for a complete list). Spies can be inspected *generally* to see if an argument
    or return value was ever encountered during execution or *specifically* to check
    information for a single function call.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.JS 间谍提供了一套相当全面的属性和方法，用于检查执行信息（有关完整列表，请参阅[http://sinonjs.org/docs/#spies](http://sinonjs.org/docs/#spies)）。间谍可以被一般地检查，以查看在执行过程中是否遇到了某个参数或返回值，或者具体地检查单个函数调用的信息。
- en: The spy API
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 间谍 API
- en: 'An introductory set of useful spy methods and properties includes:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 一套有用的间谍方法和属性包括：
- en: '`spy.callCount(num)`: This returns the number of times the spied function was
    called. This is available as an assertion with `sinon.assert.callCount(spy, num)`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spy.callCount(num)`: 此方法返回被监视函数被调用的次数。这可以作为断言使用，例如`sinon.assert.callCount(spy,
    num)`。'
- en: '`spy.called`: This is `true` if the function was called one or more times.
    Sinon.JS also provides properties to verify a few specific call counts, for example,
    `spy.calledOnce`. Assertion versions include `sinon.assert.called(spy)`, `sinon.assert.notCalled(spy)`,
    and `sinon.assert.calledOnce(spy)`.'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spy.called`: 如果函数被调用一次或多次，则此值为`true`。Sinon.JS 还提供了一些属性来验证特定的调用次数，例如`spy.calledOnce`。断言版本包括`sinon.assert.called(spy)`、`sinon.assert.notCalled(spy)`和`sinon.assert.calledOnce(spy)`。'
- en: '`spy.calledWith*`/`spy.notCalledWith*`: Sinon.JS provides methods that can
    verify if a spy was sometimes/always called with expected parameters. For example,
    `spy.calledWithExactly(arg1, arg2)` checks whether the function was called one
    or more times with `arg1` and `arg2`. By contrast, `spy.alwaysCalledWith(arg1)`
    checks whether every function call had a first argument `arg1` and any number
    of additional arguments.'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spy.calledWith*`/`spy.notCalledWith*`: Sinon.JS 提供了可以验证间谍是否有时/总是使用预期参数调用的方法。例如，`spy.calledWithExactly(arg1,
    arg2)`检查函数是否一次或多次使用`arg1`和`arg2`调用。相比之下，`spy.alwaysCalledWith(arg1)`检查每次函数调用是否都有一个第一个参数`arg1`以及任意数量的附加参数。'
- en: '`spy.returned(obj)`/`spy.alwaysReturned(obj)`: This returns `true` if `obj`
    was returned by the function one or more times/on every call.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spy.returned(obj)`/`spy.alwaysReturned(obj)`: 如果函数一次或多次/每次调用都返回了`obj`，则此方法返回`true`。'
- en: 'Sinon.js spies also record thrown exceptions, which can be inspected with the
    following methods:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon.js 间谍还会记录抛出的异常，可以使用以下方法进行检查：
- en: '`spy.threw()`: This returns `true` if the function threw an exception one or
    more times. The `spy.alwaysThrew()` alternative returns `true` if the exception
    was thrown every time. Both can take optional arguments of the type string (for
    example, `"Error"`) or an actual error object to additionally require a type match
    for the exception. Assertion versions are `sinon.assert.threw(spy)` and `sinon.assert.alwaysThrew(spy)`
    respectively.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spy.threw()`: 如果函数一次或多次抛出异常，则返回 `true`。`spy.alwaysThrew()` 选项在每次调用都抛出异常时返回
    `true`。两者都可以接受可选的字符串类型（例如，`"Error"`）或实际的错误对象，以要求异常类型匹配。断言版本分别是 `sinon.assert.threw(spy)`
    和 `sinon.assert.alwaysThrew(spy)`。'
- en: The spy call API
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: The spy call API
- en: Each time a spied function is called, Sinon.JS stores a **call object** with
    relevant information in an internal array. Call objects are useful in situations
    where a spied function is executed many times, but only one specific call needs
    to be inspected.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 每次被监视的函数被调用时，Sinon.JS 都会将包含相关信息的 **调用对象** 存储在一个内部数组中。调用对象在需要检查特定调用，但被监视的函数执行多次的情况下非常有用。
- en: 'Call objects can be accessed from a spy in various ways:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 调用对象可以通过多种方式从间谍中访问：
- en: '`spy.getCall(n)`: Retrieves the *n*th call object of the spy from a zero-indexed
    array. For example, `spy.getCall(1)` retrieves the call object from the second
    time the spied function was called.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spy.getCall(n)`: 从零索引数组中检索间谍的第 *n* 个调用对象。例如，`spy.getCall(1)` 检索间谍函数第二次被调用时的调用对象。'
- en: '`spy.firstCall`, `spy.secondCall`, `spy.thirdCall`, and `spy.lastCall`: These
    are helper properties that access commonly used call objects.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spy.firstCall`、`spy.secondCall`、`spy.thirdCall` 和 `spy.lastCall`: 这些是辅助属性，用于访问常用调用对象。'
- en: 'Call objects provide methods and properties for the particular function call
    they wrap:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 调用对象提供了封装特定函数调用的方法和属性：
- en: '`spyCall.calledOn(obj)`: This returns `true` if `obj` was the context (`this`)
    variable for the call. The `this` variable''s value is also available directly
    from the property `spyCall.thisValue`.'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spyCall.calledOn(obj)`: 如果 `obj` 是调用时的上下文（`this`）变量，则返回 `true`。`this` 变量的值也可以直接从
    `spyCall.thisValue` 属性中获取。'
- en: '`spyCall.calledWith*`/`spyCall.notCalledWith*`: These are spy call methods
    that verify if a *single* call was/was not made with specific arguments. It parallels
    the spy API methods, which instead check *all* the function calls and not just
    one. The call object also provides the specific arguments the function was called
    with, in the property `spyCall.args`.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spyCall.calledWith*`/`spyCall.notCalledWith*`: 这些是间谍调用方法，用于验证是否使用特定参数进行了 *单个*
    调用。它与间谍 API 方法平行，后者检查 *所有* 函数调用，而不仅仅是单个调用。调用对象还提供了函数被调用时的特定参数，在 `spyCall.args`
    属性中。'
- en: '`spyCall.returnValue`: This is the property containing the return value for
    the function call.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spyCall.returnValue`: 这是包含函数调用返回值的属性。'
- en: '`spyCall.threw()`: This returns `true` if the function call threw an exception.
    The exception object itself is available as `spyCall.exception`.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`spyCall.threw()`: 这会返回 `true` 如果函数调用抛出了异常。异常对象本身可以通过 `spyCall.exception` 获取。'
- en: Spicing up Chai with the Sinon.JS plugin
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Sinon.JS 插件丰富 Chai
- en: One of the primary motivations for using the Chai library is the natural language
    syntax of its chained assertions. Another strong point of Chai is that it produces
    clear error messages on assertion failures.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Chai 库的主要动机之一是其链式断言的自然语言语法。Chai 的另一个优点是它在断言失败时产生清晰的错误消息。
- en: Unfortunately, Sinon.JS spies create some assertion challenges within our test
    framework. To illustrate the issue, let's focus on the previous example that asserts
    that the `obj.multiply()` method (wrapped in a spy) was called with the parameters
    `5` and `2`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，Sinon.JS 间谍在我们的测试框架中创建了一些断言挑战。为了说明问题，让我们关注之前的例子，该例子断言 `obj.multiply()`
    方法（被间谍包装）以参数 `5` 和 `2` 被调用。
- en: 'At this point, we have encountered two ways of making assertions on Sinon.JS
    spies—with Chai assertions and with Sinon.JS built-in spy assertions. Starting
    with the first method, we can write a Chai assertion on the spy as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，我们已经遇到了两种在 Sinon.JS 间谍上进行断言的方式——使用 Chai 断言和使用 Sinon.JS 内置的间谍断言。从第一种方法开始，我们可以在间谍上编写一个
    Chai 断言，如下所示：
- en: '[PRE6]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: However, a drawback of this statement is that if the assertion fails, Chai will
    produce the unhelpful error message `expected false to be true`.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个声明的缺点是，如果断言失败，Chai 将产生无用的错误消息 `expected false to be true`。
- en: 'We can get a much better error message, `AssertError: expected multiply to
    be called with arguments 5, 2`, if we use the Sinon.JS assert version:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: '如果我们使用Sinon.JS断言版本，可以得到一个更好的错误消息，`AssertError: expected multiply to be called
    with arguments 5, 2`。'
- en: '[PRE7]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: But we then lose the naturally readable Chai dot-notation syntax.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 但这样我们就失去了Chai点符号语法的自然可读性。
- en: 'What we really want is a code that fails with an error message resembling `expected
    multiply to have been called with arguments 5, 2` and an assertion that reads
    as follows:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们真正想要的是一个在出现错误时显示类似`expected multiply to have been called with arguments 5,
    2`的错误消息，并且断言如下所示：
- en: '[PRE8]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Fortunately, we *can* get the best of both the worlds—readable Chai assertions
    with informative library-specific failure messages—by using Chai's plugin capabilities.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，我们可以通过使用Chai的插件功能，获得两个世界的最佳之处——可读的Chai断言和具有信息性的库特定错误消息。
- en: Introducing and installing Chai plugins
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引入和安装Chai插件
- en: Chai supports plugins ([http://chaijs.com/plugins](http://chaijs.com/plugins))
    that modify and extend the Chai assertion API with contextually useful changes
    and failure messages. In this section, we will introduce and install the Sinon.JS
    adapter for Chai, giving us much more concise and ultimately useful assertions
    for our test doubles.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Chai支持插件([http://chaijs.com/plugins](http://chaijs.com/plugins))，这些插件通过上下文有用的更改和错误消息来修改和扩展Chai断言API。在本节中，我们将介绍并安装Chai的Sinon.JS适配器，为我们提供更简洁且最终更有用的测试替代表述。
- en: Note
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The use of the Sinon.JS adapter is recommended but entirely optional. Although
    we will use the plugin in many examples throughout the rest of the book, all of
    our test assertions could be rewritten in equivalent statements using native Chai.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 推荐使用Sinon.JS适配器，但这完全是可选的。尽管我们将在本书的其余部分使用该插件，但我们的所有测试断言都可以使用原生的Chai重写为等效语句。
- en: 'The **Sinon-Chai** plugin ([http://chaijs.com/plugins/sinon-chai](http://chaijs.com/plugins/sinon-chai))
    can be downloaded from GitHub at [https://raw.github.com/domenic/sinon-chai/2.4.0/lib/sinon-chai.js](https://raw.github.com/domenic/sinon-chai/2.4.0/lib/sinon-chai.js).
    At present we are using version 2.4.0\. The file should be placed in the same
    directory (`test/js/lib/`) as our other test libraries and included along with
    the other libraries in the test driver web page:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '**Sinon-Chai**插件([http://chaijs.com/plugins/sinon-chai](http://chaijs.com/plugins/sinon-chai))可以从GitHub下载，地址为[https://raw.github.com/domenic/sinon-chai/2.4.0/lib/sinon-chai.js](https://raw.github.com/domenic/sinon-chai/2.4.0/lib/sinon-chai.js)。目前我们使用的是版本2.4.0。该文件应放置在我们其他测试库相同的目录(`test/js/lib/`)中，并在测试驱动网页中与其他库一起包含：'
- en: '[PRE9]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Sinon-Chai must be included *after* Chai and can be included before or after
    the Sinon.JS library. With this extra include, we are ready to start writing more
    readable and informative Chai assertions.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon-Chai必须在Chai之后包含，并且可以在Sinon.JS库之前或之后包含。有了这个额外的包含，我们就准备好开始编写更易读和更有信息的Chai断言。
- en: Tip
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Other Chai plugins that may also be useful for Backbone.js application tests
    include the adapters for Backbone.js ([http://chaijs.com/plugins/chai-backbone](http://chaijs.com/plugins/chai-backbone))
    and jQuery ([http://chaijs.com/plugins/chai-jquery](http://chaijs.com/plugins/chai-jquery)).
    The Backbone.js plugin adds assertions for Backbone.js-specific constructs such
    as `trigger` (for events) and `routes.to` (for routing). The jQuery plugin proxies
    various jQuery functions into Chai assertions, enabling statements such as `expect($text).to.have.html("<em>Edit
    your note!</em>")`.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其他可能对Backbone.js应用程序测试有用的Chai插件包括Backbone.js适配器([http://chaijs.com/plugins/chai-backbone](http://chaijs.com/plugins/chai-backbone))和jQuery([http://chaijs.com/plugins/chai-jquery](http://chaijs.com/plugins/chai-jquery))。Backbone.js插件为Backbone.js特定的结构添加了断言，例如`trigger`（用于事件）和`routes.to`（用于路由）。jQuery插件将各种jQuery函数代理到Chai断言中，使得可以编写如下语句：`expect($text).to.have.html("<em>Edit
    your note!</em>")`。
- en: The Sinon.JS plugin
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Sinon.JS插件
- en: 'The Sinon-Chai plugin extends Chai with several spy-related assertions, including
    the following:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: Sinon-Chai插件扩展了Chai，增加了几个与spy相关的断言，包括以下内容：
- en: '**Call occurrences**: `expect(spy).to.have.been.called`, `expect(spy).to.have.been.calledOnce`,
    `expect(spy).to.have.been.calledTwice`, and `expect(spy).to.have.been.calledThrice`'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用次数**：`expect(spy).to.have.been.called`、`expect(spy).to.have.been.calledOnce`、`expect(spy).to.have.been.calledTwice`和`expect(spy).to.have.been.calledThrice`'
- en: '**Call order**: `expect(spy1).to.have.been.calledAfter(spy2)` and `expect(spy1).to.have.been.calledBefore(spy2)`'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用顺序**：`expect(spy1).to.have.been.calledAfter(spy2)`和`expect(spy1).to.have.been.calledBefore(spy2)`'
- en: '**Call arguments**: `expect(spy).to.have.been.calledWithNew`, `expect(spy).to.have.been.calledOn(context)`,
    `expect(spy).to.have.been.calledWith(arg1, arg2, ...)`, `expect(spy).to.have.been.calledWithExactly(arg1,
    arg2, ...)`, and `expect(spy).to.have.been.calledWithMatch(arg1, arg2, ...)`'
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用参数**：`expect(spy).to.have.been.calledWithNew`，`expect(spy).to.have.been.calledOn(context)`，`expect(spy).to.have.been.calledWith(arg1,
    arg2, ...)`，`expect(spy).to.have.been.calledWithExactly(arg1, arg2, ...)`，以及 `expect(spy).to.have.been.calledWithMatch(arg1,
    arg2, ...)`'
- en: '**Return values**: `expect(spy).to.have.returned(returnVal)`'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**返回值**：`expect(spy).to.have.returned(returnVal)`'
- en: '**Errors**: `expect(spy).to.have.thrown()`'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误**：`expect(spy).to.have.thrown()`'
- en: 'The plugin also adds a new assertion flag:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 该插件还添加了一个新的断言标志：
- en: '`always`: It signals that the spied function must pass the assertion for *every*
    function call and not just one or more function call. For example, we can convert
    any of the following assertions that check *any* function call into ones that
    check *every* call:'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`always`：它表示间谍函数必须通过 *每个* 函数调用的断言，而不仅仅是单个或多个函数调用。例如，我们可以将以下检查 *任何* 函数调用的断言转换为检查
    *每个* 调用的断言：'
- en: '[PRE10]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, we can rewrite one of our earlier test examples with Sinon-Chai assertions
    to read as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以使用 Sinon-Chai 断言重写我们之前的一个测试示例，如下所示：
- en: '[PRE11]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Any spy assertion failures in the previous refactored test will produce informative
    messages such as `expected multiply to have been called with arguments 5, 2`.
    Thus, the Sinon-Chai plugin allows us to keep the spy assertions in Chai's chained
    dot-notation format while also producing helpful failure messages.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在之前的重构测试中，任何间谍断言失败都会产生如`expected multiply to have been called with arguments
    5, 2`之类的信息。因此，Sinon-Chai 插件允许我们在 Chai 的链式点号格式中保留间谍断言，同时生成有用的失败信息。
- en: Testing Backbone.js components with spies
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用间谍测试 Backbone.js 组件
- en: With our Sinon.JS spies and other utilities ready, we will begin spying on our
    Backbone.js application. In this section, we will introduce and test two Notes
    application views—the menu bar view and the single note view.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的 Sinon.JS 间谍和其他实用工具准备就绪后，我们将开始监视我们的 Backbone.js 应用程序。在本节中，我们将介绍并测试两个笔记应用程序视图——菜单栏视图和单个笔记视图。
- en: Tip
  id: totrans-106
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Working through the examples**'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '**通过示例进行操作**'
- en: Reiterating a point from the previous chapter, we will present the menu bar
    view and single note view implementations with the code *first* and the tests
    *second*, to help maintain a narrative structure that properly introduces the
    Notes application (and to keep things brief). This is not the preferred order
    for actual test development.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 重申前一章的观点，我们将首先展示菜单栏视图和单个笔记视图的实现代码，然后是测试代码，以帮助维持一个正确介绍笔记应用程序的叙述结构（并使内容简短）。这并不是实际测试开发的首选顺序。
- en: Accordingly, while working through this chapter, we suggest that you put this
    book down for a moment after reading the described behavior of each component.
    See if you can design and implement your own tests for the sample application
    components. After this exercise, you can continue reading and compare your tests
    with the component test suites in this chapter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在阅读每个组件描述的行为后，我们建议您暂时放下这本书，尝试为示例应用程序组件设计并实现自己的测试。完成这个练习后，您可以继续阅读，并将您的测试与本章中的组件测试套件进行比较。
- en: The Notes menu bar view
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记菜单栏视图
- en: The Notes menu bar view, `App.Views.NoteNav`, controls the **Edit**, **View**,
    and **Delete** menu bar buttons for a single note. The following screenshot illustrates
    the menu bar with an active **View** button.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 笔记菜单栏视图 `App.Views.NoteNav` 控制单个笔记的 **编辑**、**查看** 和 **删除** 菜单栏按钮。以下截图展示了带有活动
    **查看** 按钮的菜单栏。
- en: '![The Notes menu bar view](img/5248OS_04_01.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![笔记菜单栏视图](img/5248OS_04_01.jpg)'
- en: Single page menu bar view
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 单页菜单栏视图
- en: 'The `App.Views.NoteNav` view coordinates incoming/outgoing events for the view,
    edit, and delete menu actions. For example, if the **Edit** button was clicked
    on in the previous figure, the `App.Views.NoteNav` view would emit the following
    custom Backbone.js events:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.Views.NoteNav` 视图协调视图、编辑和删除菜单操作的事件。例如，如果在之前的图中点击了 **编辑** 按钮，`App.Views.NoteNav`
    视图将发出以下自定义 Backbone.js 事件：'
- en: '`nav:update:edit`: This causes the active HTML menu bar item to switch to a
    new selected action, for example, changing from **View** to **Edit**.'
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nav:update:edit`：这会导致活动 HTML 菜单栏项切换到新的选定操作，例如，从 **查看** 切换到 **编辑**。'
- en: '`nav:edit`: This is emitted to signal other Backbone.js components that the
    operative action (for example, view or edit) has changed. For example, the `App.Views.Note`
    view listens on this event and displays HTML for the appropriate corresponding
    action pane in its view area.'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nav:edit`：这个事件被触发以向其他 Backbone.js 组件发出操作动作（例如，视图或编辑）已更改的信号。例如，`App.Views.Note`
    视图监听此事件，并在其视图区域显示相应动作面板的 HTML。'
- en: 'The menu bar view is attached to the DOM list `#note-nav`, which is provided
    by the `notes/app/index.html` application page. The HTML for `#note-nav` can be
    abbreviated to the following essential parts:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单栏视图附加到 DOM 列表 `#note-nav`，这是由 `notes/app/index.html` 应用页面提供的。`#note-nav` 的
    HTML 可以简化为以下基本部分：
- en: '[PRE12]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The menu bar list is hidden by default (but shown by `App.Views.Note`). After
    instantiation, the `App.Views.NoteNav` view sets up various listeners and activates
    the proper menu bar item.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 菜单栏列表默认隐藏（但由 `App.Views.Note` 显示）。实例化后，`App.Views.NoteNav` 视图设置各种监听器并激活适当的菜单栏项。
- en: The menu bar view
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 菜单栏视图
- en: 'Now that we have reviewed the display setup and overall functionality of the
    view, we can dive into the application code at `notes/app/js/app/views/note-nav.js`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经审查了视图的显示设置和整体功能，我们可以深入研究 `notes/app/js/app/views/note-nav.js` 中的应用代码：
- en: '[PRE13]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'After specifying a default `el` element to attach the view to, the view binds
    the user menu bar clicks to the appropriate actions (for example, edit) in `events`
    and sets listeners in `initialize` to update the menu bar on occurrence of external
    events:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在指定默认 `el` 元素以附加视图之后，视图将用户菜单栏点击绑定到适当的动作（例如，编辑）在 `events` 中，并在 `initialize` 中设置监听器以在发生外部事件时更新菜单栏。
- en: '[PRE14]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'The functions `updateView` and `updateEdit` switch the `active` CSS class,
    which visually changes the highlighted tab in the menu bar:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `updateView` 和 `updateEdit` 切换 `active` CSS 类，这会在菜单栏中视觉上改变高亮的标签：
- en: '[PRE15]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The `clickView`, `clickEdit`, and `clickDelete` functions emit the view events
    corresponding to the menu bar actions:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 函数 `clickView`、`clickEdit` 和 `clickDelete` 发出与菜单栏动作对应的视图事件：
- en: '[PRE16]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Testing and spying on the menu bar view
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试和监视菜单栏视图
- en: 'The `App.Views.NoteNav` view is fairly small and essentially just proxies events
    and updates the menu bar UI. Our testing goals are similarly modest:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.Views.NoteNav` 视图相当小，本质上只是代理事件并更新菜单栏 UI。我们的测试目标同样简单：'
- en: Verify that `App.Views.NoteNav` is bound to the DOM correctly, either by defaulting
    to `#note-nav` or via a passed `el` parameter
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 验证 `App.Views.NoteNav` 是否正确绑定到 DOM，无论是默认为 `#note-nav` 还是通过传递的 `el` 参数
- en: Check that the menu bar action events are triggered and listened to correctly
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查菜单栏动作事件是否被正确触发和监听
- en: Ensure that the menu bar HTML is modified in response to appropriate actions
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保菜单栏 HTML 在适当动作下被修改
- en: With these guidelines in mind, let's step through `chapters/04/test/js/spec/views/note-nav.spec.js`,
    which is the suite for the menu bar view.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些指南的指导下，让我们逐步审查 `chapters/04/test/js/spec/views/note-nav.spec.js`，这是菜单栏视图的套件。
- en: 'The suite starts out by setting up a test fixture and a view. The `before()`
    call creates the minimum HTML that we will need to produce a menu bar list suitable
    for testing the view. The `beforeEach()` function attaches `this.$fixture` to
    the `#fixtures` container already in the DOM and creates a new `App.Views.NoteNav`
    object. The `afterEach()` call removes the view and `after()` empties out the
    `#fixtures` container completely:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 该套件首先设置一个测试固定装置和视图。`before()` 调用创建了我们为生成适合测试视图的菜单栏列表所需的最低限度的 HTML。`beforeEach()`
    函数将 `this.$fixture` 附带到 DOM 中已存在的 `#fixtures` 容器，并创建一个新的 `App.Views.NoteNav` 对象。`afterEach()`
    调用移除视图，`after()` 完全清空 `#fixtures` 容器：
- en: '[PRE17]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The first nested suite, `events`, contains one spec that verifies if a click
    on a menu bar item fires the appropriate `nav:*` and `nav:update:*` events. We
    create three Sinon.JS spies to help us with this task:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个嵌套套件 `events` 包含一个规格，验证点击菜单栏项是否触发适当的 `nav:*` 和 `nav:update:*` 事件。我们创建三个 Sinon.JS
    监视器来帮助我们完成这项任务：
- en: '`navSpy` and `updateSpy`: These objects spy on the events `nav:view` and `nav:update:view`
    and should be called when the **View** menu bar item is clicked on'
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`navSpy` 和 `updateSpy`：这些对象监视 `nav:view` 和 `nav:update:view` 事件，应该在点击 **视图**
    菜单栏项时被调用'
- en: '`otherSpy`: This spy listens on all other potential action events and is used
    to check whether the other events did *not* fire'
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`otherSpy`：这个监视器监听所有其他潜在的动作事件，并用于检查其他事件是否没有触发'
- en: 'We use the Sinon-Chai adapter extensions to make our spy assertions:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 Sinon-Chai 适配器扩展来制作我们的监视器断言：
- en: '[PRE18]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The specs in the `menu bar display` suite inspect DOM content and page interactions
    with the view. The first spec, `has no active navs by default`, checks that the
    menu bar HTML has no active selection by default—which, for a Bootstrap-based
    navigation bar, means the absence of the `active` CSS class:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`menu bar display` 套件中的规范检查 DOM 内容和页面与视图的交互。第一个规范 `has no active navs by default`
    检查菜单栏 HTML 默认没有活动选择——对于一个基于 Bootstrap 的导航栏，这意味着没有 `active` CSS 类：'
- en: '[PRE19]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, the remaining specs check whether clicking on the **Edit** menu bar tab
    or firing a direct `nav:update:edit` event causes the corresponding menu bar item
    to be activated (via insertion of the CSS class `active`):'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，剩余的规范检查点击**编辑**菜单栏标签或触发直接 `nav:update:edit` 事件是否会导致相应的菜单栏项被激活（通过插入 CSS 类
    `active`）：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: With the previous tests, we can verify that `App.Views.NoteNav` fires appropriate
    events and its HTML responds to user clicks and external events.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 通过之前的测试，我们可以验证 `App.Views.NoteNav` 触发适当的事件，并且其 HTML 对用户点击和外部事件做出响应。
- en: The Notes single note view
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 笔记单个笔记视图
- en: The `App.Views.Note` view controls everything that we have encountered so far
    with respect to a single note. Each `App.Views.Note` object instantiates a new
    `App.Views.NoteView` object and refers to an external `App.Views.NoteNav` object.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.Views.Note` 视图控制了我们迄今为止遇到的关于单个笔记的所有内容。每个 `App.Views.Note` 对象实例化一个新的 `App.Views.NoteView`
    对象，并引用外部的 `App.Views.NoteNav` 对象。'
- en: 'The main responsibilities of the class, which we will want to verify in the
    tests, include the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 类的主要职责，我们将在测试中验证，包括以下内容：
- en: Update the appropriate viewing pane mode (for example, edit or view) in response
    to menu bar action events
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应菜单栏操作事件更新适当的查看面板模式（例如，编辑或查看）
- en: Delete a single note model, and then clean up views and route back to the all
    notes list view
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除单个笔记模型，然后清理视图并路由回所有笔记列表视图
- en: Require user confirmation before deleting a note
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在删除笔记之前要求用户确认
- en: Save note model data into the backend storage in response to edit form field
    changes
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应编辑表单字段变化，将笔记模型数据保存到后端存储
- en: Update the HTML display panes in response to model data changes
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 响应模型数据变化更新 HTML 显示面板
- en: 'We will first look at the HTML template string used by the view. It is found
    in our application template file, `notes/app/js/app/templates/templates.js`:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先查看视图使用的 HTML 模板字符串。它在我们的应用程序模板文件 `notes/app/js/app/templates/templates.js`
    中找到：
- en: '[PRE21]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The template provides two `div` UI panes for action modes—`note-pane-view` for
    *viewing* a note and `note-pane-edit` for *editing* data. It also binds two template
    variables—`title` and `text`—to the editing inputs in the `note-form-edit` form.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 模板提供了两个 `div` UI 面板用于操作模式——`note-pane-view` 用于 *查看* 笔记和 `note-pane-edit` 用于
    *编辑* 数据。它还绑定两个模板变量——`title` 和 `text`——到 `note-form-edit` 表单中的编辑输入。
- en: The single note view
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 单个笔记视图
- en: 'Getting into the application code at `notes/app/js/app/views/note-nav.js`,
    we start by declaring the DOM identifier and template and then set up two events—the
    first one saves note data on occurrence of the browser''s `blur` event, and the
    second one prevents the editing form from doing a real HTTP page submission:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 进入应用程序代码 `notes/app/js/app/views/note-nav.js`，我们首先声明 DOM 标识符和模板，然后设置两个事件——第一个事件在浏览器发生
    `blur` 事件时保存笔记数据，第二个事件防止编辑表单执行真正的 HTTP 页面提交：
- en: '[PRE22]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `initialize` function does most of the heavy lifting for the view. First,
    it sets `this.nav` from the parameter options and `this.router` from either options
    or from the external `app` application object.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '`initialize` 函数为视图做了大部分繁重的工作。首先，它从参数选项设置 `this.nav`，从选项或从外部的 `app` 应用程序对象设置
    `this.router`。'
- en: Note
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reason we optionally take a router object from the `opts` parameter is that
    it makes it easier to override Backbone.js dependencies. In our tests, we will
    use `opts` to pass a Sinon.JS spy instead of a real router that records behavior
    but doesn't actually route. A different approach to this scenario (introduced
    in the next chapter) is to stub or mock `app.router` directly.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 `opts` 参数中可选地获取路由对象的原因是它使得覆盖 Backbone.js 依赖项变得更容易。在我们的测试中，我们将使用 `opts` 传递一个
    Sinon.JS 间谍而不是一个记录行为但不实际路由的真实路由器。对此场景的另一种方法（在下一章中介绍）是直接模拟或存根 `app.router`。
- en: 'Then, the view sets up event listeners on various objects by calling the helper
    function `_addListeners`. Finally, the view object renders its Underscore.js template
    to HTML with model data, sets the action state, and instantiates a child `App.Views.NoteView`
    object to handle Markdown rendering:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，视图通过调用辅助函数 `_addListeners` 在各种对象上设置事件监听器。最后，视图对象使用模型数据将 Underscore.js 模板渲染为
    HTML，设置动作状态，并实例化一个子 `App.Views.NoteView` 对象以处理 Markdown 渲染：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'As a part of initialization, the `_addListeners` helper binds object events
    as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 作为初始化的一部分，`_addListeners` 辅助函数将对象事件绑定如下：
- en: '**Model** (`this.model`): The view removes itself when the model is destroyed.
    It re-renders and saves the model to the backend when the model data changes.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模型** (`this.model`)：当模型被销毁时，视图会移除自己。当模型数据更改时，它会重新渲染并将模型保存到后端。'
- en: '**Menu bar view** (`this.nav`): The note view listens to the menu bar nav events
    and calls specific action functions such as `viewNote()` when a user clicks on
    **View**.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**菜单栏视图** (`this.nav`)：笔记视图监听菜单栏导航事件，并在用户点击 **查看** 时调用特定的动作函数，如 `viewNote()`。'
- en: '**Note view** (`this`): The note view also directly listens for action state
    (viewing or editing) events from external Backbone.js components. For instance,
    the application router uses these events to activate an existing `App.Views.Note`
    view object and set an appropriate action state.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**笔记视图** (`this`)：笔记视图还直接监听来自外部 Backbone.js 组件的动作状态（查看或编辑）事件。例如，应用程序路由器使用这些事件激活现有的
    `App.Views.Note` 视图对象并设置适当的动作状态。'
- en: 'Translating this into code produces the following function:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 将此转换为代码产生以下函数：
- en: '[PRE24]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The `render()` function displays the HTML for the single note view and hides
    any HTML content used by other views:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '`render()` 函数显示单个笔记视图的 HTML，并隐藏其他视图使用的任何 HTML 内容：'
- en: '[PRE25]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The `remove()` method first removes the contained `App.Views.NoteView` object
    and then the `App.Views.Note` object itself:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`remove()` 方法首先移除包含的 `App.Views.NoteView` 对象，然后是 `App.Views.Note` 对象本身：'
- en: '[PRE26]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `update()` method takes an action string parameter (`"view"` or `"edit"`),
    then triggers the menu bar view to update to the new state, shows the appropriate
    HTML action pane, and updates the URL hash fragment:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '`update()` 方法接受一个动作字符串参数（`"view"` 或 `"edit"`），然后触发菜单栏视图更新到新状态，显示适当的 HTML 动作面板，并更新
    URL 案件片段：'
- en: '[PRE27]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The next three methods—`viewNote()`, `editNote()`, and `deleteNote()`—handle
    the basic actions for a single note. The first two methods simply call `update()`
    with the appropriate action, while `deleteNote()` destroys the note model and
    routes back to the all notes list (that is, the application home page):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的三个方法——`viewNote()`、`editNote()` 和 `deleteNote()`——处理单个笔记的基本动作。前两个方法只是使用适当的动作调用
    `update()`，而 `deleteNote()` 则销毁笔记模型并路由回所有笔记列表（即应用程序主页）：
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Finally, `saveNote()` takes the edit form input and updates the underlying
    note model:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`saveNote()` 接收编辑表单输入并更新底层的笔记模型：
- en: '[PRE29]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Testing the single note view
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 测试单个笔记视图
- en: Our tests for `App.Views.Note` center around the various responsibilities of
    the class we discussed while introducing the view. Specifically, we want to verify
    that the note view can update UI elements for actions (for example, view and edit),
    delete notes, save model data, and correctly bind events across various other
    Backbone.js application components.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `App.Views.Note` 的测试集中在我们在介绍视图时讨论的类的各种职责。具体来说，我们想要验证笔记视图可以更新动作（例如查看和编辑）的
    UI 元素，删除笔记，保存模型数据，并在各种其他 Backbone.js 应用程序组件之间正确绑定事件。
- en: Walking through `chapters/04/test/js/spec/views/note.spec.js`, the single note
    test suite, we start by creating an initial test state. In the suite-wide `before()`
    function, we add fixture elements for regions (of which `App.Views.Note` uses
    region-note), an HTML fixture for the view itself, and then stub the note model
    prototype's `save()` method.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `chapters/04/test/js/spec/views/note.spec.js` 的单个笔记测试套件中，我们首先创建一个初始测试状态。在套件范围的
    `before()` 函数中，我们添加了区域（其中 `App.Views.Note` 使用 region-note）的固定元素，为视图本身添加了 HTML
    固定元素，然后存根笔记模型原型的 `save()` 方法。
- en: Note
  id: totrans-185
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 笔记
- en: While Sinon.JS stubs are not fully introduced in this chapter, we use one here
    to record calls to `save()` like a spy and also to prevent the method from trying
    to save to a remote backend, which would throw an error in this test context.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管Sinon.JS存根在本章中未完全介绍，但我们在这里使用它来记录对 `save()` 的调用，就像间谍一样，并防止该方法尝试将数据保存到远程后端，这在本测试上下文中会引发错误。
- en: '[PRE30]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In the `beforeEach()` setup method, we attach the view fixtures to the fixture
    container and create a spy function meant to replace our real Backbone.js router.
    Then, we create an `App.Views.Note` object and bind the fixtures and a new `App.Models.Note`
    to it. We also provide two initialization options to the `App.Views.Note` instance:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`beforeEach()`设置方法中，我们将视图固定装置附加到固定装置容器，并创建一个用来替换我们真实Backbone.js路由的间谍函数。然后，我们创建一个`App.Views.Note`对象，并将固定装置和一个新的`App.Models.Note`绑定到它。我们还向`App.Views.Note`实例提供了两个初始化选项：
- en: '`nav`: We pass a raw `Backbone.View` object as a replacement for the menu bar
    view to proxy events through, while omitting the real view logic and DOM interaction'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`nav`：我们传递一个原始的`Backbone.View`对象作为菜单栏视图的替代品，通过它代理事件，同时省略了真实的视图逻辑和DOM交互'
- en: '`router`: We pass `this.routerSpy` to record the Backbone.js routing events
    without actually changing our browser history/URL state'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`router`：我们传递`this.routerSpy`以记录Backbone.js路由事件，而实际上并不改变我们的浏览器历史/URL状态'
- en: '[PRE31]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: It is worth noting that we inject four view dependencies (`el`, `model`, `nav`,
    and `router`) into `App.Views.Note` to help isolate the instance and make it testable.
    With this configuration, the specs in our suite could be considered partial integration
    tests because we are using (and testing) real Backbone.js objects beyond the view
    under test.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们将四个视图依赖项（`el`、`model`、`nav`和`router`）注入到`App.Views.Note`中，以帮助隔离实例并使其可测试。在这种配置下，我们套件中的规范可以被认为是部分集成测试，因为我们正在使用（并测试）真实的Backbone.js对象，而不仅仅是测试下的视图。
- en: Another observation with the previous setup is that the `nav` and `router` option
    parameters are specifically chosen to avoid triggering the real behavior of the
    full application; for example, manipulating the menu bar DOM or changing the browser's
    URL. As we will learn in [Chapter 5](ch05.html "Chapter 5. Test Stubs and Mocks"),
    *Test Stubs and Mocks*, this type of behavior replacement is much more concisely
    and appropriately performed with Sinon.JS stubs or mocks.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 关于之前的设置，另一个观察结果是`nav`和`router`选项参数是特意选择的，以避免触发完整应用程序的真实行为；例如，操作菜单栏DOM或更改浏览器的URL。正如我们将在[第5章](ch05.html
    "第5章。测试存根和模拟")中学习到的，“测试存根和模拟”，这种行为替换可以通过Sinon.JS存根或模拟更简洁、更适当地完成。
- en: 'Moving on to the test teardown in `afterEach()`, we clear out the test fixtures
    and delete any view objects still around. (The specs may already have destroyed
    the test view object.) Finally, at the end of the suite in `after()`, we clear
    out the top-level fixture container and restore the `save()` method of the `App.Models.Note`
    class to its original state:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来进行测试拆解，在`afterEach()`中，我们清除测试固定装置并删除任何仍然存在的视图对象。（规范可能已经销毁了测试视图对象。）最后，在套件末尾的`after()`中，我们清除顶级固定装置容器并恢复`App.Models.Note`类的`save()`方法到其原始状态：
- en: '[PRE32]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'With our setup/teardown complete, we move on to the first nested test suite,
    `view modes and actions`, which verifies that the user DOM interaction and Backbone.js
    events can control the note view and cause it to switch between editing, viewing,
    and deleting modes:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的设置/拆解完成，接下来进入第一个嵌套测试套件，`视图模式和操作`，该套件验证用户DOM交互和Backbone.js事件可以控制笔记视图，并使其在编辑、查看和删除模式之间切换：
- en: '[PRE33]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'By default, an `App.Views.Note` view routes to the URL hash fragment `#note/:id/view`
    and displays the viewing mode HTML. We use our router spy to verify the suffix
    of the called hash fragment using the Sinon-Chai `calledWithMatch` extension.
    Then, we assert that only the viewing pane `#note-pane-view` is visible with a
    simple CSS `display` property check:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`App.Views.Note`视图路由到URL哈希片段`#note/:id/view`并显示查看模式HTML。我们使用我们的路由间谍来验证使用Sinon-Chai
    `calledWithMatch`扩展调用的哈希片段的后缀。然后，我们通过简单的CSS `display`属性检查断言只有查看面板`#note-pane-view`是可见的：
- en: '[PRE34]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The next spec triggers the `update:edit` event and then verifies that this
    changes the URL hash fragment to `#note/:id/edit` and displays the editing pane:'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个规范触发`update:edit`事件，然后验证这会将URL哈希片段更改为`#note/:id/edit`并显示编辑面板：
- en: '[PRE35]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'We test the note deletion behavior by stubbing out the `confirm()` pop up to
    always return `false` (preventing the actual note deletion) and then calling `deleteNote()`.
    We need this stub to prevent an actual browser confirmation window from popping
    up during our test run. Then, we use the spy properties of the stub to verify
    that `confirm()` was called correctly:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过模拟`confirm()`弹出窗口始终返回`false`（防止实际笔记删除）并调用`deleteNote()`来测试笔记删除行为。我们需要这个模拟来防止在测试运行期间实际弹出浏览器确认窗口。然后，我们使用存根的间谍属性来验证`confirm()`是否被正确调用：
- en: '[PRE36]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The next test suite, `model interaction`, contains a single spec that verifies
    that the deletion of a model causes the `App.Views.Note` object to remove itself
    and its contained `App.Views.NoteView` object. Accordingly, we set up spies on
    the `remove()` methods of both the views.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个测试套件`model interaction`包含一个规范，验证模型的删除会导致`App.Views.Note`对象及其包含的`App.Views.NoteView`对象移除。因此，我们在两个视图的`remove()`方法上设置了间谍。
- en: Tip
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Failure to clean up the views, models, and so on once they are no longer used
    can lead to memory leaks, which may have significant impact on the overall application
    performance. Triggering `App.Views.Note` and `App.Views.NoteView` object removals
    on the destruction of the underlying note model is one way of reclaiming used
    memory from the various components of a Backbone.js application.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦不再使用视图、模型等，未能清理它们可能导致内存泄漏，这可能会对整体应用程序性能产生重大影响。在底层笔记模型被销毁时触发`App.Views.Note`和`App.Views.NoteView`对象移除是回收Backbone.js应用程序各个组件使用内存的一种方式。
- en: At the same time, there are many other techniques to keep the memory in check.
    *Zombies! RUN!* ([http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/))
    and *Backbone.js And JavaScript Garbage Collection* ([http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/](http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/))
    are posts by *Derick Bailey* that provide a great introduction to Backbone.js
    memory management issues and solutions.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，还有许多其他技术可以用来控制内存。*僵尸！跑！*([http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/))和*Backbone.js与JavaScript垃圾回收*([http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/](http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/))是*Derick
    Bailey*发表的帖子，提供了对Backbone.js内存管理问题和解决方案的极佳介绍。
- en: '[PRE37]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The last nested test suite, `note rendering`, checks that model data is correctly
    rendered to HTML and that rendering is triggered in response to expected application
    events. The first spec, `can render a note`, verifies that `render()` shows the
    appropriate HTML region elements and hides the rest:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个嵌套测试套件`note rendering`检查模型数据是否正确渲染到HTML，以及渲染是否在预期应用程序事件响应时触发。第一个规范`可以渲染笔记`验证`render()`显示了适当的HTML区域元素并隐藏了其余部分：
- en: '[PRE38]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'The next two specs check that the `render()` method is triggered on appropriate
    changes. The spec `calls render on model events` verifies that `render()` is called
    whenever the model changes:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来的两个规范检查`render()`方法是否在适当的变化时被触发。`在模型事件上调用render`的规范验证每当模型更改时都会调用`render()`：
- en: '[PRE39]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The final spec modifies data in the single note edit form like a user would
    and then triggers the `blur` event to force model change events. The spec spies
    on the `render()` method and checks that the rendered Markdown HTML has been updated
    to reflect the new data:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 最终规范修改了单个笔记编辑表中的数据，就像用户操作一样，然后触发`blur`事件以强制模型更改事件。规范监视`render()`方法，并检查渲染的Markdown
    HTML是否已更新以反映新数据：
- en: '[PRE40]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: With all of the specs in this suite, we have increased confidence that the `App.Views.Note`
    class can emit/listen to appropriate events, clean up application objects on model
    deletion, and other behaviors that we earlier identified as the core responsibilities
    of the view.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个套件的所有规范中，我们增加了对`App.Views.Note`类能够发出/监听适当事件、在模型删除时清理应用程序对象以及其他我们之前确定的视图核心职责的信心。
- en: Hooking up and running the view tests
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接和运行视图测试
- en: 'Now that we have our test suites for `App.Views.NoteNav` and `App.Views.Note`,
    let''s wire up the test driver page `chapters/04/test/test.html`. We can re-use
    the same code as in `chapters/03/test/test.html`, with a few (highlighted in the
    ensuing code) differences, that add in the Sinon-Chai plugin, more Notes application
    libraries, and our new spec files:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`App.Views.NoteNav`和`App.Views.Note`的测试套件，让我们连接测试驱动页面`chapters/04/test/test.html`。我们可以重用`chapters/03/test/test.html`中的相同代码，其中有一些（在下述代码中突出显示）差异，添加了Sinon-Chai插件、更多的Notes应用程序库以及我们的新规范文件：
- en: '[PRE41]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: We can run the tests by opening a browser to `chapters/04/test/test.html`. (Note
    that the code samples contain the additional specs that are omitted from this
    chapter for brevity).
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过打开浏览器到`chapters/04/test/test.html`来运行测试。（注意，代码示例包含本章节为简洁而省略的附加规范）。
- en: '![Hooking up and running the view tests](img/5248OS_04_02.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![连接并运行视图测试](img/5248OS_04_02.jpg)'
- en: Test report
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 测试报告
- en: Summary
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We introduced the Sinon.JS test library in this chapter and learned how to integrate
    spies in various testing scenarios. We investigated Chai's plugin architecture
    and used the Sinon-Chai adapter to write better test spy assertions. We wrote
    specs for the menu bar and single note Backbone.js views, completing our tests
    for the single note portion of the Notes application.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在本章中介绍了 Sinon.JS 测试库，并学习了如何在各种测试场景中集成间谍。我们研究了 Chai 的插件架构，并使用 Sinon-Chai 适配器编写了更好的测试间谍断言。我们为菜单栏和单个笔记
    Backbone.js 视图编写了规范，完成了笔记应用单个笔记部分的测试。
- en: The next chapter continues our exploration of Sinon.JS by looking into stubs,
    mocks, and other useful fake testing objects. We will use these tools to fill
    out more parts of our Backbone.js application test collection and round out the
    fundamentals of writing tests with Mocha, Chai, and Sinon.JS.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将继续探索 Sinon.JS，通过研究存根、模拟和其他有用的假测试对象。我们将使用这些工具来完善我们的 Backbone.js 应用程序测试集合，并完善使用
    Mocha、Chai 和 Sinon.JS 编写测试的基础知识。
