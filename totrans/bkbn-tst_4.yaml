- en: Chapter 4. Test Spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we begin looking at the more complicated parts of our Backbone.js application,
    the process of isolating dependencies and testable behaviors can become an increasingly
    daunting task. To provide a little help in these areas, we will introduce Sinon.JS,
    which is a powerful test mock, stub, and spy library, in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Sinon.JS allows us to artificially isolate Backbone.js components and test
    specific behaviors without interacting with the rest of the application. We will
    kick off our discussion on Sinon.JS with the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Identifying some of the test limitations typically found in Backbone.js applications
    and testing scenarios that can benefit from test fakes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing the Sinon.JS test double and assertion library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning how to examine application behavior with test spies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating the Sinon-Chai plugin into Chai for better test assertions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing Backbone.js application components with test spies and other Sinon.JS
    utilities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fake it 'til you make it
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Ideally, we would run insulated, fast, and consistent tests on all parts of
    a Backbone.js application without any modifications. In actuality, these goals
    encounter hurdles for at least some of the real code paths in a Backbone.js application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We want to test Backbone.js components in *isolation*, but many components
    have dependencies on other parts of the application. We also want the tests to
    run *quickly*, but many parts of a Backbone.js application can slow things down,
    including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Network communication, such as persisting a model state to a remote backend
    datastore or a third party API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complex DOM manipulation with Backbone.js views and templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Timed events and DOM animations, especially those that deliberately wait (such
    as a slow jQuery fade)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Finally, many events and execution paths in a Backbone.js application are non-deterministic.
    For example, parallel network requests and user inputs can be received by the
    application in any order. To deal with these issues, we sometimes have to look
    beyond the actual program code and fake out some parts of the application during
    tests. For a deeper dive into some of the common testing limitations and motivations
    for faking, see *Planning, Cheating and Faking Your Way Through JavaScript Tests*
    by *Christian Johansen* (the creator of Sinon.JS) at [http://msdn.microsoft.com/en-us/magazine/gg649850.aspx](http://msdn.microsoft.com/en-us/magazine/gg649850.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'The modern techniques used to observe and/or replace program behaviors are
    collectively dubbed **test doubles**. The test doubles that we use in this book
    include:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Spies**: A test spy wraps a method under test and records inputs and outputs
    for later use. However, it does not change any of the underlying method functionality,
    as a spy is merely an observer. Test spies are useful in situations where we want
    to check how and when a given function is called from other parts of the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stubs**: A test stub is a spy that additionally replaces the functionality
    of a method under test with a new behavior. Stubs are quite useful for test isolation.
    For example, when testing a single method that normally calls other functions,
    we can simply "stub out" the external function calls with a preprogrammed behavior.
    In this manner, tests can execute the specific code under test while faking out
    everything else.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mocks**: Mocks are a combination of spies and stubs (observing function calls
    and replacing function behavior) that additionally verify expected function behavior
    during execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For a good survey on test doubles, including approaches beyond the three we
    identified, see *Exploring The Continuum Of Test Doubles* by *Mark Seeman* ([http://msdn.microsoft.com/en-us/magazine/cc163358.aspx](http://msdn.microsoft.com/en-us/magazine/cc163358.aspx))
    and *Test Double Patterns* web page by *Gerard Meszaros* ([http://xunitpatterns.com/Test%20Double%20Patterns.html](http://xunitpatterns.com/Test%20Double%20Patterns.html)).
  prefs: []
  type: TYPE_NORMAL
- en: Getting to know Sinon.JS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Sinon.JS is a popular test double library that provides spies, stubs, mocks,
    fake servers, and various helpers. We will introduce two Sinon.JS interfaces in
    this chapter—spies and the sandboxed test helper—and discuss the rest in [Chapter
    5](ch05.html "Chapter 5. Test Stubs and Mocks"), *Test Stubs and Mocks*.
  prefs: []
  type: TYPE_NORMAL
- en: Spying on functions with Sinon.JS
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sinon.JS provides extensible test spies that can record many different aspects
    of a function execution, including calling parameters, return values, and thrown
    exceptions. The basic developer workflow is to create a spy, hook it into a function
    under test, execute the function, and then verify that the spy's recorded information
    matches with the test expectations. In this section, we will walk through the
    different ways to create spies and discuss some of the most useful parts of the
    Sinon.JS spy API.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous spies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Spies can be created as anonymous standalone functions, which are often used
    to test event logic in Backbone.js applications. For example, we create a Backbone.js
    event object and an anonymous Sinon.JS spy in the following code. The spy listens
    to the `foo` event, which we trigger. Then, we can inspect the spy and assert
    that the spy was called once and passed `42` as a parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Spy assertions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sinon.JS provides assertion helpers for many spy methods and properties with
    the `sinon.assert` object. In the previous example, we used Chai assertions to
    verify the spy''s recorded information. But, we could have equivalently used Sinon.JS
    assertions as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The `sinon.assert` helpers have an advantage over most equivalent Chai assertions
    for the reason that the failure messages are informative and specific. For example,
    a failing assertion for `sinon.assert.calledWith(spy, 42)` produces the error
    message `AssertError: expected spy to be called with arguments 42`.'
  prefs: []
  type: TYPE_NORMAL
- en: Function spies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sinon.JS spies can wrap existing functions as well. In the following example,
    we wrap the function `divide` with a spy, producing `divAndSpy`. Then, we can
    call `divAndSpy` in any manner that we could for `divide`. We can also inspect
    spy properties such as `calledWith()` in the wrapped spy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Object method spies
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Finally, Sinon.JS spies can wrap methods in objects. This is a particularly
    powerful means of spying on one method within an overall class or Backbone.js
    component to gather information throughout the entire execution path. The wrapped
    object methods contain Sinon.JS spy properties, meaning that we do not have to
    separately track a spy variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrapped object methods remain spies until unwrapped with the `restore()` function,
    which removes the spy and reinstates the original function. As an example, let
    us consider the following object with two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can spy on `multiply` to verify its call and return values, and spy on `error`
    to check that it throws an expected exception. In both cases, we call the wrapped
    object method directly (for example, `obj.multiply()`) and then access the method
    spies. Finally, we need to call `restore()` at the end of the test to unwrap the
    spies on `obj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Playing in the sandbox with Sinon.JS test helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One issue with the previous example spec is that if an assertion fails before
    `restore()` is called, the object methods are still wrapped in the spies. If any
    subsequent (and otherwise passing) test tries to wrap an already wrapped method,
    Sinon.JS will throw an error such as `TypeError: Attempted to wrap <function name>
    which is already wrapped`.'
  prefs: []
  type: TYPE_NORMAL
- en: Thus, it is important to ensure that each spy eventually calls `restore()`,
    regardless of whether or not the underlying test has passed. One way of achieving
    this is with a `try`/`finally` block in the test. Another way is to create spies
    in a `before` function and call `restore()` on them in an `after` function. However,
    the easiest and the most flexible way is to perhaps use the `sinon.test` sandbox
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Sinon.JS provides an execution environment dubbed as a **sandbox** that can
    be configured with spies, stubs, mocks, and other fake objects (for example, fake
    timers and AJAX requests). Conveniently, all faked properties and methods can
    be unwound with a single `restore()` call on the sandbox object.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Reviewing the Sinon.JS sandbox documentation at [http://sinonjs.org/docs/#sandbox](http://sinonjs.org/docs/#sandbox)
    is highly recommended. There are some subtle pitfalls and surprises related to
    how an application execution changes within a sandbox. For example, the default
    sandbox will fake time and the related functions such as `setTimeout`. It means
    that if your code waits for 10 milliseconds before execution, it will not run
    until the developer *manually* advances the time in the fake `clock` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `sinon.test` wrapper function takes this one step further by creating a
    default sandbox, which is automatically restored after the wrapped code finishes
    its execution. Repeating our previous object method example with `sinon.test`
    yields a more elegant version of the spec, in which we don''t manually call `restore()`
    on the spies and still guarantee that the wrapped object methods are restored:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: While the `sinon.test` helper is a handy tool for managing Sinon.JS objects,
    it is not always an appropriate choice for every spec. For example, asynchronous
    Mocha tests are tricky because `sinon.test` can potentially restore the entire
    sandbox before the `done()` parameter is later called in the test code. Additionally,
    a side effect of using `sinon.test` is that the Mocha test reporter will no longer
    show the test code when clicking on a spec description in the test driver web
    page. The reason for this makes sense—`sinon.test` wraps the actual test function,
    so `sinon.test` is all that the Mocha reporter sees. It is ultimately a matter
    of developer intuition and experience as to when to use the `sinon.test` shortcut.
    In this book we use the wrapper for a subset of our synchronous Sinon.JS-based
    specs.
  prefs: []
  type: TYPE_NORMAL
- en: Delving into the Sinon.JS spy API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sinon.JS spies provide a fairly comprehensive set of properties and methods
    for inspecting execution information (see [http://sinonjs.org/docs/#spies](http://sinonjs.org/docs/#spies)
    for a complete list). Spies can be inspected *generally* to see if an argument
    or return value was ever encountered during execution or *specifically* to check
    information for a single function call.
  prefs: []
  type: TYPE_NORMAL
- en: The spy API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An introductory set of useful spy methods and properties includes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spy.callCount(num)`: This returns the number of times the spied function was
    called. This is available as an assertion with `sinon.assert.callCount(spy, num)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spy.called`: This is `true` if the function was called one or more times.
    Sinon.JS also provides properties to verify a few specific call counts, for example,
    `spy.calledOnce`. Assertion versions include `sinon.assert.called(spy)`, `sinon.assert.notCalled(spy)`,
    and `sinon.assert.calledOnce(spy)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spy.calledWith*`/`spy.notCalledWith*`: Sinon.JS provides methods that can
    verify if a spy was sometimes/always called with expected parameters. For example,
    `spy.calledWithExactly(arg1, arg2)` checks whether the function was called one
    or more times with `arg1` and `arg2`. By contrast, `spy.alwaysCalledWith(arg1)`
    checks whether every function call had a first argument `arg1` and any number
    of additional arguments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spy.returned(obj)`/`spy.alwaysReturned(obj)`: This returns `true` if `obj`
    was returned by the function one or more times/on every call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Sinon.js spies also record thrown exceptions, which can be inspected with the
    following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spy.threw()`: This returns `true` if the function threw an exception one or
    more times. The `spy.alwaysThrew()` alternative returns `true` if the exception
    was thrown every time. Both can take optional arguments of the type string (for
    example, `"Error"`) or an actual error object to additionally require a type match
    for the exception. Assertion versions are `sinon.assert.threw(spy)` and `sinon.assert.alwaysThrew(spy)`
    respectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The spy call API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Each time a spied function is called, Sinon.JS stores a **call object** with
    relevant information in an internal array. Call objects are useful in situations
    where a spied function is executed many times, but only one specific call needs
    to be inspected.
  prefs: []
  type: TYPE_NORMAL
- en: 'Call objects can be accessed from a spy in various ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spy.getCall(n)`: Retrieves the *n*th call object of the spy from a zero-indexed
    array. For example, `spy.getCall(1)` retrieves the call object from the second
    time the spied function was called.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spy.firstCall`, `spy.secondCall`, `spy.thirdCall`, and `spy.lastCall`: These
    are helper properties that access commonly used call objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Call objects provide methods and properties for the particular function call
    they wrap:'
  prefs: []
  type: TYPE_NORMAL
- en: '`spyCall.calledOn(obj)`: This returns `true` if `obj` was the context (`this`)
    variable for the call. The `this` variable''s value is also available directly
    from the property `spyCall.thisValue`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spyCall.calledWith*`/`spyCall.notCalledWith*`: These are spy call methods
    that verify if a *single* call was/was not made with specific arguments. It parallels
    the spy API methods, which instead check *all* the function calls and not just
    one. The call object also provides the specific arguments the function was called
    with, in the property `spyCall.args`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spyCall.returnValue`: This is the property containing the return value for
    the function call.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`spyCall.threw()`: This returns `true` if the function call threw an exception.
    The exception object itself is available as `spyCall.exception`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Spicing up Chai with the Sinon.JS plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the primary motivations for using the Chai library is the natural language
    syntax of its chained assertions. Another strong point of Chai is that it produces
    clear error messages on assertion failures.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, Sinon.JS spies create some assertion challenges within our test
    framework. To illustrate the issue, let's focus on the previous example that asserts
    that the `obj.multiply()` method (wrapped in a spy) was called with the parameters
    `5` and `2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this point, we have encountered two ways of making assertions on Sinon.JS
    spies—with Chai assertions and with Sinon.JS built-in spy assertions. Starting
    with the first method, we can write a Chai assertion on the spy as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: However, a drawback of this statement is that if the assertion fails, Chai will
    produce the unhelpful error message `expected false to be true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can get a much better error message, `AssertError: expected multiply to
    be called with arguments 5, 2`, if we use the Sinon.JS assert version:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: But we then lose the naturally readable Chai dot-notation syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'What we really want is a code that fails with an error message resembling `expected
    multiply to have been called with arguments 5, 2` and an assertion that reads
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Fortunately, we *can* get the best of both the worlds—readable Chai assertions
    with informative library-specific failure messages—by using Chai's plugin capabilities.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing and installing Chai plugins
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Chai supports plugins ([http://chaijs.com/plugins](http://chaijs.com/plugins))
    that modify and extend the Chai assertion API with contextually useful changes
    and failure messages. In this section, we will introduce and install the Sinon.JS
    adapter for Chai, giving us much more concise and ultimately useful assertions
    for our test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The use of the Sinon.JS adapter is recommended but entirely optional. Although
    we will use the plugin in many examples throughout the rest of the book, all of
    our test assertions could be rewritten in equivalent statements using native Chai.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Sinon-Chai** plugin ([http://chaijs.com/plugins/sinon-chai](http://chaijs.com/plugins/sinon-chai))
    can be downloaded from GitHub at [https://raw.github.com/domenic/sinon-chai/2.4.0/lib/sinon-chai.js](https://raw.github.com/domenic/sinon-chai/2.4.0/lib/sinon-chai.js).
    At present we are using version 2.4.0\. The file should be placed in the same
    directory (`test/js/lib/`) as our other test libraries and included along with
    the other libraries in the test driver web page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Sinon-Chai must be included *after* Chai and can be included before or after
    the Sinon.JS library. With this extra include, we are ready to start writing more
    readable and informative Chai assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Other Chai plugins that may also be useful for Backbone.js application tests
    include the adapters for Backbone.js ([http://chaijs.com/plugins/chai-backbone](http://chaijs.com/plugins/chai-backbone))
    and jQuery ([http://chaijs.com/plugins/chai-jquery](http://chaijs.com/plugins/chai-jquery)).
    The Backbone.js plugin adds assertions for Backbone.js-specific constructs such
    as `trigger` (for events) and `routes.to` (for routing). The jQuery plugin proxies
    various jQuery functions into Chai assertions, enabling statements such as `expect($text).to.have.html("<em>Edit
    your note!</em>")`.
  prefs: []
  type: TYPE_NORMAL
- en: The Sinon.JS plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The Sinon-Chai plugin extends Chai with several spy-related assertions, including
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Call occurrences**: `expect(spy).to.have.been.called`, `expect(spy).to.have.been.calledOnce`,
    `expect(spy).to.have.been.calledTwice`, and `expect(spy).to.have.been.calledThrice`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Call order**: `expect(spy1).to.have.been.calledAfter(spy2)` and `expect(spy1).to.have.been.calledBefore(spy2)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Call arguments**: `expect(spy).to.have.been.calledWithNew`, `expect(spy).to.have.been.calledOn(context)`,
    `expect(spy).to.have.been.calledWith(arg1, arg2, ...)`, `expect(spy).to.have.been.calledWithExactly(arg1,
    arg2, ...)`, and `expect(spy).to.have.been.calledWithMatch(arg1, arg2, ...)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Return values**: `expect(spy).to.have.returned(returnVal)`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Errors**: `expect(spy).to.have.thrown()`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The plugin also adds a new assertion flag:'
  prefs: []
  type: TYPE_NORMAL
- en: '`always`: It signals that the spied function must pass the assertion for *every*
    function call and not just one or more function call. For example, we can convert
    any of the following assertions that check *any* function call into ones that
    check *every* call:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we can rewrite one of our earlier test examples with Sinon-Chai assertions
    to read as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Any spy assertion failures in the previous refactored test will produce informative
    messages such as `expected multiply to have been called with arguments 5, 2`.
    Thus, the Sinon-Chai plugin allows us to keep the spy assertions in Chai's chained
    dot-notation format while also producing helpful failure messages.
  prefs: []
  type: TYPE_NORMAL
- en: Testing Backbone.js components with spies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our Sinon.JS spies and other utilities ready, we will begin spying on our
    Backbone.js application. In this section, we will introduce and test two Notes
    application views—the menu bar view and the single note view.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Working through the examples**'
  prefs: []
  type: TYPE_NORMAL
- en: Reiterating a point from the previous chapter, we will present the menu bar
    view and single note view implementations with the code *first* and the tests
    *second*, to help maintain a narrative structure that properly introduces the
    Notes application (and to keep things brief). This is not the preferred order
    for actual test development.
  prefs: []
  type: TYPE_NORMAL
- en: Accordingly, while working through this chapter, we suggest that you put this
    book down for a moment after reading the described behavior of each component.
    See if you can design and implement your own tests for the sample application
    components. After this exercise, you can continue reading and compare your tests
    with the component test suites in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: The Notes menu bar view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Notes menu bar view, `App.Views.NoteNav`, controls the **Edit**, **View**,
    and **Delete** menu bar buttons for a single note. The following screenshot illustrates
    the menu bar with an active **View** button.
  prefs: []
  type: TYPE_NORMAL
- en: '![The Notes menu bar view](img/5248OS_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Single page menu bar view
  prefs: []
  type: TYPE_NORMAL
- en: 'The `App.Views.NoteNav` view coordinates incoming/outgoing events for the view,
    edit, and delete menu actions. For example, if the **Edit** button was clicked
    on in the previous figure, the `App.Views.NoteNav` view would emit the following
    custom Backbone.js events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nav:update:edit`: This causes the active HTML menu bar item to switch to a
    new selected action, for example, changing from **View** to **Edit**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`nav:edit`: This is emitted to signal other Backbone.js components that the
    operative action (for example, view or edit) has changed. For example, the `App.Views.Note`
    view listens on this event and displays HTML for the appropriate corresponding
    action pane in its view area.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The menu bar view is attached to the DOM list `#note-nav`, which is provided
    by the `notes/app/index.html` application page. The HTML for `#note-nav` can be
    abbreviated to the following essential parts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The menu bar list is hidden by default (but shown by `App.Views.Note`). After
    instantiation, the `App.Views.NoteNav` view sets up various listeners and activates
    the proper menu bar item.
  prefs: []
  type: TYPE_NORMAL
- en: The menu bar view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now that we have reviewed the display setup and overall functionality of the
    view, we can dive into the application code at `notes/app/js/app/views/note-nav.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'After specifying a default `el` element to attach the view to, the view binds
    the user menu bar clicks to the appropriate actions (for example, edit) in `events`
    and sets listeners in `initialize` to update the menu bar on occurrence of external
    events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The functions `updateView` and `updateEdit` switch the `active` CSS class,
    which visually changes the highlighted tab in the menu bar:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The `clickView`, `clickEdit`, and `clickDelete` functions emit the view events
    corresponding to the menu bar actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Testing and spying on the menu bar view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `App.Views.NoteNav` view is fairly small and essentially just proxies events
    and updates the menu bar UI. Our testing goals are similarly modest:'
  prefs: []
  type: TYPE_NORMAL
- en: Verify that `App.Views.NoteNav` is bound to the DOM correctly, either by defaulting
    to `#note-nav` or via a passed `el` parameter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check that the menu bar action events are triggered and listened to correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that the menu bar HTML is modified in response to appropriate actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With these guidelines in mind, let's step through `chapters/04/test/js/spec/views/note-nav.spec.js`,
    which is the suite for the menu bar view.
  prefs: []
  type: TYPE_NORMAL
- en: 'The suite starts out by setting up a test fixture and a view. The `before()`
    call creates the minimum HTML that we will need to produce a menu bar list suitable
    for testing the view. The `beforeEach()` function attaches `this.$fixture` to
    the `#fixtures` container already in the DOM and creates a new `App.Views.NoteNav`
    object. The `afterEach()` call removes the view and `after()` empties out the
    `#fixtures` container completely:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The first nested suite, `events`, contains one spec that verifies if a click
    on a menu bar item fires the appropriate `nav:*` and `nav:update:*` events. We
    create three Sinon.JS spies to help us with this task:'
  prefs: []
  type: TYPE_NORMAL
- en: '`navSpy` and `updateSpy`: These objects spy on the events `nav:view` and `nav:update:view`
    and should be called when the **View** menu bar item is clicked on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`otherSpy`: This spy listens on all other potential action events and is used
    to check whether the other events did *not* fire'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We use the Sinon-Chai adapter extensions to make our spy assertions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The specs in the `menu bar display` suite inspect DOM content and page interactions
    with the view. The first spec, `has no active navs by default`, checks that the
    menu bar HTML has no active selection by default—which, for a Bootstrap-based
    navigation bar, means the absence of the `active` CSS class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, the remaining specs check whether clicking on the **Edit** menu bar tab
    or firing a direct `nav:update:edit` event causes the corresponding menu bar item
    to be activated (via insertion of the CSS class `active`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: With the previous tests, we can verify that `App.Views.NoteNav` fires appropriate
    events and its HTML responds to user clicks and external events.
  prefs: []
  type: TYPE_NORMAL
- en: The Notes single note view
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `App.Views.Note` view controls everything that we have encountered so far
    with respect to a single note. Each `App.Views.Note` object instantiates a new
    `App.Views.NoteView` object and refers to an external `App.Views.NoteNav` object.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main responsibilities of the class, which we will want to verify in the
    tests, include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Update the appropriate viewing pane mode (for example, edit or view) in response
    to menu bar action events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Delete a single note model, and then clean up views and route back to the all
    notes list view
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Require user confirmation before deleting a note
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Save note model data into the backend storage in response to edit form field
    changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update the HTML display panes in response to model data changes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We will first look at the HTML template string used by the view. It is found
    in our application template file, `notes/app/js/app/templates/templates.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The template provides two `div` UI panes for action modes—`note-pane-view` for
    *viewing* a note and `note-pane-edit` for *editing* data. It also binds two template
    variables—`title` and `text`—to the editing inputs in the `note-form-edit` form.
  prefs: []
  type: TYPE_NORMAL
- en: The single note view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Getting into the application code at `notes/app/js/app/views/note-nav.js`,
    we start by declaring the DOM identifier and template and then set up two events—the
    first one saves note data on occurrence of the browser''s `blur` event, and the
    second one prevents the editing form from doing a real HTTP page submission:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `initialize` function does most of the heavy lifting for the view. First,
    it sets `this.nav` from the parameter options and `this.router` from either options
    or from the external `app` application object.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The reason we optionally take a router object from the `opts` parameter is that
    it makes it easier to override Backbone.js dependencies. In our tests, we will
    use `opts` to pass a Sinon.JS spy instead of a real router that records behavior
    but doesn't actually route. A different approach to this scenario (introduced
    in the next chapter) is to stub or mock `app.router` directly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the view sets up event listeners on various objects by calling the helper
    function `_addListeners`. Finally, the view object renders its Underscore.js template
    to HTML with model data, sets the action state, and instantiates a child `App.Views.NoteView`
    object to handle Markdown rendering:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'As a part of initialization, the `_addListeners` helper binds object events
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model** (`this.model`): The view removes itself when the model is destroyed.
    It re-renders and saves the model to the backend when the model data changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Menu bar view** (`this.nav`): The note view listens to the menu bar nav events
    and calls specific action functions such as `viewNote()` when a user clicks on
    **View**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Note view** (`this`): The note view also directly listens for action state
    (viewing or editing) events from external Backbone.js components. For instance,
    the application router uses these events to activate an existing `App.Views.Note`
    view object and set an appropriate action state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Translating this into code produces the following function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The `render()` function displays the HTML for the single note view and hides
    any HTML content used by other views:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The `remove()` method first removes the contained `App.Views.NoteView` object
    and then the `App.Views.Note` object itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update()` method takes an action string parameter (`"view"` or `"edit"`),
    then triggers the menu bar view to update to the new state, shows the appropriate
    HTML action pane, and updates the URL hash fragment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'The next three methods—`viewNote()`, `editNote()`, and `deleteNote()`—handle
    the basic actions for a single note. The first two methods simply call `update()`
    with the appropriate action, while `deleteNote()` destroys the note model and
    routes back to the all notes list (that is, the application home page):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, `saveNote()` takes the edit form input and updates the underlying
    note model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Testing the single note view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Our tests for `App.Views.Note` center around the various responsibilities of
    the class we discussed while introducing the view. Specifically, we want to verify
    that the note view can update UI elements for actions (for example, view and edit),
    delete notes, save model data, and correctly bind events across various other
    Backbone.js application components.
  prefs: []
  type: TYPE_NORMAL
- en: Walking through `chapters/04/test/js/spec/views/note.spec.js`, the single note
    test suite, we start by creating an initial test state. In the suite-wide `before()`
    function, we add fixture elements for regions (of which `App.Views.Note` uses
    region-note), an HTML fixture for the view itself, and then stub the note model
    prototype's `save()` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While Sinon.JS stubs are not fully introduced in this chapter, we use one here
    to record calls to `save()` like a spy and also to prevent the method from trying
    to save to a remote backend, which would throw an error in this test context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `beforeEach()` setup method, we attach the view fixtures to the fixture
    container and create a spy function meant to replace our real Backbone.js router.
    Then, we create an `App.Views.Note` object and bind the fixtures and a new `App.Models.Note`
    to it. We also provide two initialization options to the `App.Views.Note` instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nav`: We pass a raw `Backbone.View` object as a replacement for the menu bar
    view to proxy events through, while omitting the real view logic and DOM interaction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`router`: We pass `this.routerSpy` to record the Backbone.js routing events
    without actually changing our browser history/URL state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It is worth noting that we inject four view dependencies (`el`, `model`, `nav`,
    and `router`) into `App.Views.Note` to help isolate the instance and make it testable.
    With this configuration, the specs in our suite could be considered partial integration
    tests because we are using (and testing) real Backbone.js objects beyond the view
    under test.
  prefs: []
  type: TYPE_NORMAL
- en: Another observation with the previous setup is that the `nav` and `router` option
    parameters are specifically chosen to avoid triggering the real behavior of the
    full application; for example, manipulating the menu bar DOM or changing the browser's
    URL. As we will learn in [Chapter 5](ch05.html "Chapter 5. Test Stubs and Mocks"),
    *Test Stubs and Mocks*, this type of behavior replacement is much more concisely
    and appropriately performed with Sinon.JS stubs or mocks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving on to the test teardown in `afterEach()`, we clear out the test fixtures
    and delete any view objects still around. (The specs may already have destroyed
    the test view object.) Finally, at the end of the suite in `after()`, we clear
    out the top-level fixture container and restore the `save()` method of the `App.Models.Note`
    class to its original state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'With our setup/teardown complete, we move on to the first nested test suite,
    `view modes and actions`, which verifies that the user DOM interaction and Backbone.js
    events can control the note view and cause it to switch between editing, viewing,
    and deleting modes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, an `App.Views.Note` view routes to the URL hash fragment `#note/:id/view`
    and displays the viewing mode HTML. We use our router spy to verify the suffix
    of the called hash fragment using the Sinon-Chai `calledWithMatch` extension.
    Then, we assert that only the viewing pane `#note-pane-view` is visible with a
    simple CSS `display` property check:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The next spec triggers the `update:edit` event and then verifies that this
    changes the URL hash fragment to `#note/:id/edit` and displays the editing pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We test the note deletion behavior by stubbing out the `confirm()` pop up to
    always return `false` (preventing the actual note deletion) and then calling `deleteNote()`.
    We need this stub to prevent an actual browser confirmation window from popping
    up during our test run. Then, we use the spy properties of the stub to verify
    that `confirm()` was called correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The next test suite, `model interaction`, contains a single spec that verifies
    that the deletion of a model causes the `App.Views.Note` object to remove itself
    and its contained `App.Views.NoteView` object. Accordingly, we set up spies on
    the `remove()` methods of both the views.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Failure to clean up the views, models, and so on once they are no longer used
    can lead to memory leaks, which may have significant impact on the overall application
    performance. Triggering `App.Views.Note` and `App.Views.NoteView` object removals
    on the destruction of the underlying note model is one way of reclaiming used
    memory from the various components of a Backbone.js application.
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, there are many other techniques to keep the memory in check.
    *Zombies! RUN!* ([http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/))
    and *Backbone.js And JavaScript Garbage Collection* ([http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/](http://lostechies.com/derickbailey/2012/03/19/backbone-js-and-javascript-garbage-collection/))
    are posts by *Derick Bailey* that provide a great introduction to Backbone.js
    memory management issues and solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The last nested test suite, `note rendering`, checks that model data is correctly
    rendered to HTML and that rendering is triggered in response to expected application
    events. The first spec, `can render a note`, verifies that `render()` shows the
    appropriate HTML region elements and hides the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The next two specs check that the `render()` method is triggered on appropriate
    changes. The spec `calls render on model events` verifies that `render()` is called
    whenever the model changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The final spec modifies data in the single note edit form like a user would
    and then triggers the `blur` event to force model change events. The spec spies
    on the `render()` method and checks that the rendered Markdown HTML has been updated
    to reflect the new data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: With all of the specs in this suite, we have increased confidence that the `App.Views.Note`
    class can emit/listen to appropriate events, clean up application objects on model
    deletion, and other behaviors that we earlier identified as the core responsibilities
    of the view.
  prefs: []
  type: TYPE_NORMAL
- en: Hooking up and running the view tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that we have our test suites for `App.Views.NoteNav` and `App.Views.Note`,
    let''s wire up the test driver page `chapters/04/test/test.html`. We can re-use
    the same code as in `chapters/03/test/test.html`, with a few (highlighted in the
    ensuing code) differences, that add in the Sinon-Chai plugin, more Notes application
    libraries, and our new spec files:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can run the tests by opening a browser to `chapters/04/test/test.html`. (Note
    that the code samples contain the additional specs that are omitted from this
    chapter for brevity).
  prefs: []
  type: TYPE_NORMAL
- en: '![Hooking up and running the view tests](img/5248OS_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Test report
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We introduced the Sinon.JS test library in this chapter and learned how to integrate
    spies in various testing scenarios. We investigated Chai's plugin architecture
    and used the Sinon-Chai adapter to write better test spy assertions. We wrote
    specs for the menu bar and single note Backbone.js views, completing our tests
    for the single note portion of the Notes application.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter continues our exploration of Sinon.JS by looking into stubs,
    mocks, and other useful fake testing objects. We will use these tools to fill
    out more parts of our Backbone.js application test collection and round out the
    fundamentals of writing tests with Mocha, Chai, and Sinon.JS.
  prefs: []
  type: TYPE_NORMAL
