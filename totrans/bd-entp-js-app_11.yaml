- en: Continuous Integration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapters, we adopted a **Test-Driven Development** (**TDD**)
    approach to developing a backend API server, which exposes a user directory platform.
    However, there are still many areas for improvement in our workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: We are running tests on our local, development environment, which may contain
    artifacts that lead to inaccurate test results
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Carrying out all these steps manually is slow and error-prone
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to eliminate these two issues by integrating with a
    **Continuous Integration** server. In essence, a CI server is a service that watches
    for changes in your repository, and then automatically runs the test suite inside
    a clean environment. This ensures the test results are more deterministic and
    repeatable. In other words, it prevents situations where something works on one
    person's machine but not another's.
  prefs: []
  type: TYPE_NORMAL
- en: 'By following this chapter, you will:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand what CI is
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrate our GitHub repository with a hosted CI platform called **Travis**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up a self-hosted **Jenkins** server
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set up our test suite to run whenever a new change is pushed to GitHub
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understand **pipelines,** especially the difference between **declarative**
    and **scripted pipelines**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Continuous Integration (CI)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: On a large-scale project, you're going to have many developers working on many
    features, releases, hotfixes, and so on, at the same time. CI is the practice
    of *integrating* work from different developers continuously. This means merging
    code from feature branches into the `dev` branch, or from a release branch into
    `master`. At every integration point, there's a chance that the integration would
    cause something to break. Therefore, we must perform tests at these integration
    points, and only carry through with the integration if all tests pass.
  prefs: []
  type: TYPE_NORMAL
- en: We already do this in our current workflow, but it is done manually. By having
    automated builds and tests that detect errors in these integration points, it
    allows members of a software development team to integrate their work frequently.
  prefs: []
  type: TYPE_NORMAL
- en: By practicing CI, we can abide by the "test early, test often" mantra, and ensure
    bugs are identified and fixed as early as possible. It also means that at any
    point, we will always have a fully functional codebase that can be deployed.
  prefs: []
  type: TYPE_NORMAL
- en: We have already laid the groundwork for following this practice by using a robust
    Git workflow and having a comprehensive test suite. The next step is to introduce
    a CI server into the mix.
  prefs: []
  type: TYPE_NORMAL
- en: Picking a CI server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are many online CI services (such as **Travis**, **CircleCI**, **Bamboo**,
    and **Shippable**) as well as self-hosted CI-capable platforms (such as **Jenkins**,
    **TeamCity**, **CruiseControl**, and **BuildBot**). For CI, they pretty much have
    the same set of capabilities, and can perform the following tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: Hook onto events and perform predefined tasks when triggered. For instance,
    when a new Git commit is pushed to the repository, the CI server would build the
    application and run the tests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Run tasks in a clean, standalone environment.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chain tasks together so that some tasks are triggered on the completion of the
    previous tasks. For instance, after the tests have finished, email the build and
    tests results to all developers.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Store history of the builds and test results.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since each CI platform is able to fulfill our requirements, our decision of
    which CI server to pick boils down to whether to use a hosted or self-hosted solution.
    As always, there''re pros and cons to each approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Costs**: Most hosted CI services are free for open source projects but require
    a paid plan for private repositories. However, hosting your own CI server also
    incurs costs of running the server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Self-Reliance**: Relying on external services for your workflow means if
    the external service is down, your workflow will be broken. However, most hosted
    CI services have very good uptime, so availability should not be a huge issue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: With a self-hosted solution, you have complete control over
    the CI server, and can extend the code and feature set with plugins or packages.
    On the other hand, if you require a feature that is not supported in a hosted
    CI server, you''d have to raise a support ticket/feature request and hope it will
    get implemented.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we are going to demonstrate both the hosted and self-hosted
    solutions, using Travis and Jenkins, respectively. The majority of the chapter,
    however, will focus on Jenkins, as it is a much more powerful and generic automation
    server than Travis.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating with Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Travis is an online CI service that installs, builds, and tests our project.
    Travis is free for open source projects and integrates well with other popular
    services such as GitHub. There's also nothing to install—all we have to do is
    include a `.travis.yml` configuration file at the root of our repository, and
    configure the repository in Travis's web application. Travis has a very shallow
    learning curve and can save us a lot of time. To get started, go to [travis-ci.org](https://travis-ci.org/) and
    sign in using your GitHub account.
  prefs: []
  type: TYPE_NORMAL
- en: Travis has two URLs [travis-ci.org](https://travis-ci.org/), which is used for
    open source projects, and [travis-ci.com](https://travis-ci.com/), which is used
    for private projects. Make sure you're using the right one.
  prefs: []
  type: TYPE_NORMAL
- en: 'It will ask you for many permissions; these permissions are required for Travis
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Read the contents of all repositories associated with your account**: This
    allows Travis to view the content of the `.travis.yml` file, as well as to be
    able to clone your repository in order to build/test it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Install webhooks and services**: This allows Travis to add hooks into your
    repositories, so that when any changes are pushed to your repository, GitHub can
    inform Travis and execute the instructions defined in the `.travis.yml` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Register with the Commit Status API**: This allows Travis to inform GitHub
    of the result of a build/test, so that GitHub can update its UI.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After you''ve reviewed these permissions, click Authorize travis-ci:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1e2d927e-fad4-4539-bde3-3bb2083570a7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After the authorization step, you''ll be brought back to the main Travis dashboard,
    where you can see every repository under your control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/efc2755d-dff6-4c83-baa3-74532477e8f8.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, we only have one project, which we should enable by clicking on the toggle
    button. This will make Travis install a GitHub service hook for that repository.
    Once installed, GitHub will send a message to Travis whenever changes are pushed
    to that repository.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Travis CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Travis will now be notified of any changes in the repository, but we haven't
    provided it with instructions to execute once a change is detected. Therefore,
    at the root of our project directory, create a configuration file named `.travis.yml`.
  prefs: []
  type: TYPE_NORMAL
- en: Note the period (`.`) before `travis`, and also that the file extension is `yml`,
    not `yaml`.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying the language
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In `.travis.yml`, we must first specify the primary language our project is
    written in. This allows Travis to install the required dependencies, and use appropriate
    default settings and configurations. For example, if we specify that our project
    is written in Node.js, Travis will, by default, configure itself to install dependencies
    by running `npm install`, and test the application by running `npm test`. It'll
    also look for a `yarn.lock` file at the root directory, and if it's present, use
    the `yarn install` and `yarn run test` commands instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, add the following line inside our `.travis.yml` file to inform Travis
    that this project uses Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: With Node.js, you can also specify which version of Node.js (or io.js) you want
    the build and tests to run on. You can specify Node versions by their major, minor,
    and patch versions, and it will get the latest version that satisfies that criteria.
    You can also use the string `"node"` to get the latest stable Node.js release,
    or `"lts/*"` for the latest LTS Node.js release.
  prefs: []
  type: TYPE_NORMAL
- en: Since this is a server-side application, we have control over the environment
    our application is run in. Therefore, if we want to, we can run our test only
    against the Node.js version specified in the `.nvmrc` file (`8.11.4`). However,
    since this process is automated, and Travis can run these tests in parallel, the
    cost of running additional tests is very low. Therefore, we should run our tests
    against future Node.js versions; doing so will prevent deprecated syntax from
    being introduced into our project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, update our `.travis.yml` to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Setting up databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our code also depends on a running instance of Elasticsearch; therefore, we
    need to specify this requirement in the `.travis.yml` file by adding a `services`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This will install and start Elasticsearch on the Travis server instance using
    the default configuration (namely, port `9200`). However, it is advisable to run
    a specific version of Elasticsearch—the same version we are running locally—to
    ensure we get results that are consistent with our development environment. Therefore,
    below the `services` block, add the following `before_install` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The Elasticsearch service may take some time to start; therefore, we should
    also tell Travis to wait a few seconds before attempting to run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Setting environment variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Lastly, our application reads variables from the environment. Since the `.env`
    and `test.env` files are not included as part of our repository, we need to manually
    provide them to Travis. We can do this by adding an `env.global` block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Our final `.travis.yml` should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: For more information about different fields in the `.travis.yml` file, check
    out [docs.travis-ci.com/user/customizing-the-build/](https://docs.travis-ci.com/user/customizing-the-build/).
  prefs: []
  type: TYPE_NORMAL
- en: Activating our project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, go to [travis-ci.org](https://travis-ci.org) to ensure your project is
    activated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cd405fdf-8dd6-46bd-91ba-79e6123f3704.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, commit `.travis.yml` to the root of the project directory, and push the
    change to GitHub. The GitHub service hook will now notify Travis of the change,
    and Travis will clone the repository, build the application, and run the tests.
    After the tests are complete (or aborted in cases of error), it will show a report
    on the Travis dashboard. The results will also be shared with GitHub so that it
    can update its UI.
  prefs: []
  type: TYPE_NORMAL
- en: Examining Travis CI results
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A Travis build will either pass or fail. If the build fails, it will be accompanied
    by a red cross:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/24ebb3ff-c1bd-4347-9f2b-528a3688de68.png)'
  prefs: []
  type: TYPE_IMG
- en: 'By default, Travis will also send an email notifying us of the result of the
    build and tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d98e8647-f081-4847-8cec-172c573eed1c.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Travis also integrates with GitHub''s Commit Status API ([developer.github.com/v3/repos/statuses/](https://developer.github.com/v3/repos/statuses/)),
    which allows third parties to attach a status to commits. Here, Travis is attaching
    the failure state to the comment, which shows up as a red cross indicator next
    to the commit time:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f8b3b2ad-3496-4c7c-887a-6c5b3db10eed.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But, most importantly, each run also saves the history of the logs, so in cases
    of error, the developers are able to pinpoint the issue and fix it quickly:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7537f940-ef7b-4c27-8de0-441761843896.png)'
  prefs: []
  type: TYPE_IMG
- en: Continuous Integration with Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now you know how to integrate with Travis CI, and know what you can expect from
    a CI server, let's try to replicate the same results using Jenkins, a self-hosted
    alternative. We have chosen Jenkins here because, at the time of writing, it is
    the most popular CI tool, with over 1 million users and 150,000 installs.
  prefs: []
  type: TYPE_NORMAL
- en: First, we will give you a brief introduction to Jenkins, and then we'll install
    and integrate it with our repository.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While Travis is purely a CI server, Jenkins is much more powerful. Generally
    speaking, Jenkins is an open source **automation server**. This means it can automate
    any processes that are tricky to do by hand, either because it is repetitive,
    time-consuming, prone to human errors, or all of the above. For example, we can
    use Jenkins for the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Building/packaging applications
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dynamically generating documentation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running pre-deployment E2E/integration/unit/UI tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment onto various testing environments (for example, development, staging)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Running post-deployment tests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deployment onto the production environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Furthermore, these processes can be chained together to form workflows, where
    the execution of one process depends on the result of the previous process. There
    are two ways of configuring these automated workflows—as **freestyle projects**,
    or as **pipelines**.
  prefs: []
  type: TYPE_NORMAL
- en: Freestyle projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Freestyle projects (a.k.a. **jobs**, or simply **projects**) were the original
    method for which all automated tasks must be defined in Jenkins. A freestyle project
    is simply a set of user-defined tasks that Jenkins should perform. For example,
    a project may involve building an application from a Git repository, while another
    project is used to run tests on this built application.
  prefs: []
  type: TYPE_NORMAL
- en: The terms **freestyle project**, **project**, and **job** are synonymous with
    each other. The term **job** is commonly used in the UI of the web interface,
    but it has been deprecated and we will use the term **project** in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can configure a freestyle project using the web interface, which allows
    you to define the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Source Code Management** (**SCM**): Specifies how Jenkins can obtain the
    starting source code for it to build/test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build triggers**: Specifies when this project should execute. For example,
    you may want to trigger a build when a new commit is pushed to the repository;
    or build the project every night at 00:00 to produce the nightly build.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build environment**.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Build**: Allows you to specify build steps. Despite its name, you can actually
    run any shell command, such as test runners, as a build step.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Post-build action**: Allows you to specify commands to execute after the
    build steps have been completed. You can, for instance, send the test results
    to the system administrator via email. Furthermore, you can use the post-build
    action to trigger another project to execute. This way, you can form a chain of
    projects that run one after another.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Freestyle projects are powerful and have been the status quo for many years.
    However, it is found lacking in several areas:'
  prefs: []
  type: TYPE_NORMAL
- en: When Hudson, Jenkins' predecessor, was written, using a UI for configuration
    was the norm. However, in the last few years, the ecosystem has moved towards **Configuration-as-Code**
    (**CaC**), where the configuration can be tracked in source control.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jenkins saves the configurations files for freestyle projects on the Jenkins
    server under `/var/lib/jenkins/jobs/`. This means if the Jenkins server is destroyed,
    all the configuration settings would be lost. Furthermore, the configuration file
    is written in XML and is hard to read.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While it is possible to chain multiple freestyle projects together using post-build
    actions, you are likely to end up with a lot of duplicate projects, each with
    different post-build action steps.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To address these issues, Jenkins 2.0 came with a feature called **P****ipeline**,
    which allow you to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Instead of linking multiple freestyle projects together via post-action build
    steps, you can, with Pipeline, specify many sequential **steps**, which can optionally
    be grouped into **stages**. In a Pipeline, the execution of a downstream step/stage
    depends on the outcome of the previous step/stage in the chain. Only when the
    previous steps are successful will the subsequent steps be run. For example, if
    the tests did not pass, then the deployment step would not run.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Allows you to specify steps using a `Jenkinsfile`: A configuration file that
    is part of your codebase. This CaC (or "pipeline as code") approach means all
    changes made to the pipeline can be tracked in Git, Pipelines can be branched
    and merged, and any broken pipelines can be reverted back to the last-known-good
    version. Furthermore, even if the Jenkins server is corrupt, the configuration
    will still survive as the `Jenkinsfile` is stored in the repository, not the Jenkins
    server; this also means that you can build the project using any Jenkins server
    that has access to the repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that you can still define your Pipeline using the Jenkins web UI, although
    using a Jenkinsfile checked into your Git repository is the recommended approach.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pipeline feature is enabled by the pipeline plugin, which is installed
    by default. To define a pipeline, you have to write in a pipeline **Domain Specific
    Language** (**DSL**) syntax and save it inside a text file named `Jenkinsfile`.
    A simple `Jenkinsfile` looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'For the remainder of this chapter, we will focus on using Jenkins to replicate
    the functions of Travis CI, specifically the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integrate with GitHub so that a message will be sent to our Jenkins server whenever
    changes are pushed to our project repository
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Whenever Jenkins receives that message, it will check out the source code and
    run the tests inside a clean and isolated environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a new Jenkins server
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the Travis-GitHub integration, when GitHub detects a change on any branches
    in the repository, it will send a message to Travis's server(s), which will clone
    the repository, build it, and run the tests. Therefore, to replicate this behavior
    with Jenkins, we must set up a Jenkins CI service to receive GitHub's messages
    and run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: We can run our Jenkins server on the same machine as our API server. However,
    if our Jenkins job somehow crashes the machine, it will cause our API server to
    go down as well. Therefore, it's much safer to deploy Jenkins CI on its own separate
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, go to your VPS provider (we'll use DigitalOcean here) and provision
    a new VPS server. The Jenkins server uses around 600 MB of memory when idle; therefore,
    choose a VPS with at least 2 GB of memory.
  prefs: []
  type: TYPE_NORMAL
- en: If you forgot how to set up and provision a new VPS, refer back to [Chapter
    10](673a49d6-f4c5-47b4-afec-af3ff031f150.xhtml), *Deploying Your Application on
    a VPS*.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since we have an SSH key pair already, we can simply select that SSH key
    to be used for this VPS, without having to manually upload our SSH key onto the
    server.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the jenkins user
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once you have a VPS running, create a user called `jenkins` with `sudo` privileges:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, to allow us to log into the server as the power-restricted user `jenkins`
    and not `root`, we must first add the public key of our development machine to
    `/home/jenkins/.ssh/authorized_keys`; the easiest way to do that is to copy the
    `/root/.ssh/` directory and change its owner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, disable password authentication and root login by editing `/etc/ssh/sshd_config`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Reload the SSH daemon for the new settings to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: On a new Terminal, try logging in using the `jenkins` user. Once that's done,
    continue the rest of the setup as `jenkins`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, let''s configure the timezone and NTP synchronization:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Installing Java
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Then, we need to install and configure Java (replace `java-8-openjdk-amd64`
    with your version of Java):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: At the time of this writing, Jenkins work best with Java 8\. Java 10 and 11
    support are still experimental (see [jenkins.io/blog/2018/06/17/running-jenkins-with-java10-11/](https://jenkins.io/blog/2018/06/17/running-jenkins-with-java10-11/)). 
    This is why we are using the `openjdk-8-jdk` package instead of `default-jdk`.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are two main versions of Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Weekly**: Released every week.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long-term Support** (**LTS**): Released every 12 weeks. The Jenkins team
    picks the most stable release from the last time an LTS was released, and designates
    that as the next LTS version.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For enterprise platforms, we want the most recent and stable version; therefore,
    we will install the latest LTS version, which is currently `2.138.1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are many ways to install Jenkins, listed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is distributed as a **Web Application ARchive** (**WAR**), or `.war`, file,
    which is simply a collection of resources that, together, constitute a web application.
    A WAR file is how web applications written in Java are distributed; any operating
    system that supports Java would be able to run the WAR file. You can download
    it from [mirrors.jenkins.io/war-stable/latest/jenkins.war](http://mirrors.jenkins.io/war-stable/latest/jenkins.war)
    and run it directly with `java -jar jenkins.war --httpPort=8765`. It'll then be
    available on port `8765`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a Docker container, which you can download from [hub.docker.com/r/jenkins/jenkins/.](https://hub.docker.com/r/jenkins/jenkins/)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As a distribution-specific package—different operating systems also maintain
    their own Jenkins package in their repository. Jenkins packages from the most
    common systems, including Ubuntu/Debian, Red Hat/Fedora/CentOS, Windows, and macOS,
    are maintained by the Jenkins team.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ideally, we would run our Jenkins server (and everything else for that matter)
    inside isolated Docker containers, however, that requires an understanding of
    containers and Docker, which will be overwhelming to learn alongside Jenkins.
    Therefore, in this chapter, we will use the Jenkins package provided by the APT
    repositories, and you can migrate to using Docker after reading [Chapter 17](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml),
    *Migrating to Docker*.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, get the public key for the Jenkins repository and add it to APT; this
    allows APT to verify the authenticity of the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add the Jenkins repository to the list of repositories that
    APT will search for. This list is stored at `/etc/apt/sources.list`, as well as
    in files within the `/etc/apt/sources.list.d/` directory. Therefore, run the following
    command, which will create a new `jenkins.list` file and store the repository
    address inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, update our local package index and install Jenkins:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The installation will do several things, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the WAR file and place it at `/usr/share/jenkins`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new user called `jenkins` which will run the service
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up Jenkins as a service/daemon that runs when the system first starts
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `/var/log/jenkins/jenkins.log` file and direct all output from Jenkins
    to this file
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can check the status of the Jenkins service by running `sudo systemctl status
    jenkins.service`.
  prefs: []
  type: TYPE_NORMAL
- en: Jenkins runs as a service in the background. It utilizes the Jetty server ([eclipse.org/jetty/](http://www.eclipse.org/jetty/))
    to provide a web interface for users to interact with. By default, this server
    will bind to port `8080`.
  prefs: []
  type: TYPE_NORMAL
- en: '`8080` is a very common port. If you''re running Jenkins on an existing server
    where port `8080` is bound by another process, you can change Jenkins'' default
    port by editing the `HTTP_PORT` entry inside Jenkins'' configuration file —`/etc/default/jenkins`.
    To put this change into effect, make sure you run `sudo systemctl restart jenkins.service`.'
  prefs: []
  type: TYPE_NORMAL
- en: Installing NGINX as a reverse proxy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, if you go to `http://<server-ip>:8080` on your browser, you''ll see the
    Jenkins setup screen. But ideally, we want to use a human-friendly hostname. So,
    just as we did with our API server, let''s install NGINX to reverse proxy requests
    from `jenkins.hobnob.social` to `http://localhost:8080`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, in the `/etc/nginx/nginx.conf` file, add a line after `include /etc/nginx/conf.d/*.conf;`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, create a configuration file for Jenkins at `/etc/nginx/sites-available/jenkins.hobnob.social` and
    paste in the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This configuration is taken from [wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx](https://wiki.jenkins.io/display/JENKINS/Running+Jenkins+behind+Nginx).
    The most pertinent parts are highlighted in preceding bold.
  prefs: []
  type: TYPE_NORMAL
- en: When a request comes in for `jenkins.hobnob.social`, it will match the `location
    /` block, which then proxies the request to the service running at the `proxy_pass`
    directive (`http://localhost:8080`). Likewise, when the internal service returns
    with a response, the `proxy_redirect` directive will rewrite the `Location` header
    of the response and replace `http://localhost:8080` with `http://jenkins.hobnob.social`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our server block is ready, add it to the `/etc/nginx/sites-enabled/` directory
    using a symbolic link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, make sure our NGINX configuration does not contain any syntax errors,
    and start it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Configuring the firewall
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To complete our NGINX setup, configure the firewall to ensure traffic can reach
    port `80`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Updating our DNS records
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, our Jenkins server should be available on port `80`, but we are still accessing
    our server via an IP address. Therefore, the next step is to configure our DNS
    records to direct traffic destined for `jenkins.hobnob.social` to our VPS.
  prefs: []
  type: TYPE_NORMAL
- en: 'On DigitalOcean, go to the Networking tab at the top and add a new `A` record
    pointing the hostname `jenkins.hobnob.social` to our VPS instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0b410a9c-3ad0-4986-b9ce-ff1810a8b961.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, our Jenkins server instance should be available at `jenkins.hobnob.social`.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Jenkins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we are ready to configure Jenkins. Navigate to `jenkins.hobnob.social` on
    your browser; there you'll see a setup wizard.
  prefs: []
  type: TYPE_NORMAL
- en: When Jenkins was installed, a password was written to a file at `/var/lib/jenkins/secrets/initialAdminPassword`,
    which only the system administrator (or users with `sudo` privileges) will have
    access to. This is to ensure that the person accessing the setup wizard is the
    system administrator and not some malicious party.
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, the first step is to copy the contents of the `/var/lib/jenkins/secrets/initialAdminPassword`
    file and paste it into the wizard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/99437f2c-3e0b-4a05-a581-42e5dce10684.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, you''ll be presented with the Customize Jenkins screen,
    where you can choose to install **plugins**. Jenkins, on its own, is just a platform
    that enables automation and has few features itself. Its functionalities are modularized
    into plugins. There are over 1,300 plugins, including integration with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Version control systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bug databases
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Pick Install suggested plugins to install the most commonly used plugins, including
    the Git and GitHub plugins we will use later. You can track the progress of the
    installation on the next screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/58b808c2-b01c-4fa7-9d6b-9d787011c4b1.png)'
  prefs: []
  type: TYPE_IMG
- en: Lastly, you'll be prompted to create an administrative user for the web interface,
    which you'll use to continue the setup process (so remember your username and
    password!).
  prefs: []
  type: TYPE_NORMAL
- en: 'Great, now we will have successfully installed Jenkins and have it running
    on a public URL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3cbb07f9-d80f-408a-853f-07e1585365f5.png)'
  prefs: []
  type: TYPE_IMG
- en: Composing a Jenkinsfile
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have set up our Jenkins instance, we are ready to define our Pipeline using
    the Pipeline DSL. Let's take a look at the Pipeline DSL syntax.
  prefs: []
  type: TYPE_NORMAL
- en: The Pipeline DSL syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There are a number of global variables, keywords, and directives that can be
    used inside any Pipeline, for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`env`: Environment variables'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`params`: Parameters set when configuring the pipeline'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`currentBuild`: Information about the current build, such as results, display
    name, and so on'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complete Global Variables list can be found at `/pipeline-syntax/globals`.
  prefs: []
  type: TYPE_NORMAL
- en: There are keywords which are available only inside steps. For example, the `sh` keyword
    allows you to specify some arbitrary shell command to run, and you can use `echo` to
    print something into the console output.
  prefs: []
  type: TYPE_NORMAL
- en: The DSL syntax can also be extended. For example, the JUnit plugin adds the `junit` step
    to the Pipeline vocabulary, which allows your step to aggregate test reports.
    In this chapter, we will use the Docker Pipeline plugin, which adds a `docker`
    keyword to run our tests inside a Docker container. More on this later.
  prefs: []
  type: TYPE_NORMAL
- en: Declarative versus scripted pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two syntaxes to define Pipelines—declarative and scripted. Originally,
    the Pipeline plugin supported only scripted pipelines, but Declarative Pipeline
    syntax 1.0 was added in February 2017 with Pipeline 2.5. Both of these syntaxes
    use the same underlying execution engine to execute instructions.
  prefs: []
  type: TYPE_NORMAL
- en: A Scripted Pipeline allows you to define your instructions using a full-featured
    programming language called **Groovy**; because of this, you are able to be very
    expressive. The downside is that the code may be less understandable, and thus
    less maintainable.
  prefs: []
  type: TYPE_NORMAL
- en: The Declarative Pipeline syntax brings structure to the Pipeline, which means
    it's easier to check the file for syntax errors, provide linting help. But with
    Declarative Pipelines, you can only define instructions that are supported by
    the syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, you should use the Declarative Pipeline syntax *wherever possible*,
    and fall back to the Scripted Pipelines only when there are instructions that
    cannot be achieved using a Declarative Pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: The declarative pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Every declarative pipeline must start with the `pipeline` directive. Within
    the `pipeline` directive are, usually, the `agent`, `stages`, and `step` directives.
  prefs: []
  type: TYPE_NORMAL
- en: The `agent` directive tells Jenkins to allocate an executor and workspace for
    this part of the Pipeline. A workspace is simply a directory in the filesystem
    where Jenkins can work with the files to run the build, and an executor is simply
    a thread that executes the task. When you use the `agent` directive, it will also
    download the source repository and save it to the workspace, so that the code
    is available for subsequent stages.
  prefs: []
  type: TYPE_NORMAL
- en: 'A typical declarative pipeline might look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The scripted pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A declarative pipeline must be defined within a `pipeline` directive that includes
    an `agent` directive; for scripted pipelines, the Pipeline must be enclosed within
    the `node` directive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `node` directive in a Scripted Pipeline is similar to the `agent` directive
    in the Declarative Pipeline, and allocates an executor and workspace for the pipeline.
    Unlike the `agent` directive, the node will not automatically download the source
    repository and save it to your workspace; instead, you have to specify that manually
    using the `checkout scm` step:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '`scm` is a special variable that represents the version of the repository that
    triggered the build.'
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To ensure that the build and test steps execute consistently, we should run
    them inside a **container**, which is an ephemeral, pre-configured, isolated environment.
  prefs: []
  type: TYPE_NORMAL
- en: A container is similar to a virtual machine, but uses fewer resources and is
    quicker to provision. Creating containers is cheap; this allows us to create containers,
    run the tests, and then discard them afterward.
  prefs: []
  type: TYPE_NORMAL
- en: We will dive more in-depth into Docker in [Chapter 17](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml), *Migrating
    to Docker*; for now, it's sufficient to understand that a Docker container provides
    an isolated and consistent environment for us to run our builds and tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Docker is the most popular container framework out there, and we will run our
    builds and tests inside Docker containers. In your repository, add the following
    Scripted Pipeline into a `Jenkinsfile` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The `docker` variable is provided by the Docker Pipeline plugin, and allows
    you to run Docker-related functions within a Pipeline. Here, we are using `docker.image()`
    to pull in an image. The image's `withRun` method will use `docker run` to run
    the image on the host.
  prefs: []
  type: TYPE_NORMAL
- en: Here, we are running the `elasticsearch-oss` image, and passing in the `discovery.type`
    flag—the same one that we've been using in previous chapters. Once the container
    is running, Jenkins will execute all the commands specified within the `withRun`
    block *on the host*, and then automatically exit once all the commands inside
    the body have finished.
  prefs: []
  type: TYPE_NORMAL
- en: Within the `withRun` block, we are specifying a `docker.image().inside()` block.
    Similar to `withRun`, commands inside the `inside` block will run once the container
    is up, but these instructions will run *inside the container*, instead of on the
    host. This is where we will run our tests.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are passing in a `--link` flag to `inside`. This uses legacy Docker
    container links to provide our `node:8.11.4` container with information about
    the `elasticsearch-oss` container, such as its address and ports. This allows
    our API application to connect to the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `--link` flag has the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, `<name or id>` is the name or ID of the container we want to link to,
    and `alias` is a string that allows us to refer to this link by name. After `withRun` has
    successfully run a container, it will provide the body with a container object,
    `c`, which has an `id` property we can use in the link.
  prefs: []
  type: TYPE_NORMAL
- en: Once a container is linked, Docker will set several environment variables to
    provide information about the linked container. For instance, we can find out
    the IP address of the linked container by referring to the value of `DB_PORT_9200_TCP_ADDR`.
  prefs: []
  type: TYPE_NORMAL
- en: You can see a full list of environment variables set by Docker at [docs.docker.com/network/links/#environment-variables](https://docs.docker.com/network/links/#environment-variables).
  prefs: []
  type: TYPE_NORMAL
- en: Save this `Jenkinsfile` and push it to the remote repository.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Since Jenkins now relies on Docker, we must install Docker on this Jenkins
    server:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This installation will do a few things, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Install the Docker Engine, which runs as a daemon in the background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Install the Docker client, which is a command-line tool (`docker`) we can run
    in our Terminal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a user on our machine called `docker`, and assign it to the `docker`
    group
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To check Docker is installed properly, you can check its status by running `sudo
    systemctl status docker`.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the docker command must be invoked with root privileges. The exception
    to this rule is if the user is `docker`, or if the user is in the `docker` group.
    We are running our Jenkins server under the user `jenkins`; therefore, to allow
    our Jenkins server to spawn new Docker containers, we must add the `jenkins` user
    to the `docker` group:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'To check that this is successful, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Lastly, restart the Jenkins service for this change to take effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Integration with GitHub
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a `Jenkinsfile` that provides instructions on how to run the tests,
    and a Jenkins server to run them; the only thing left is to set up a service hook
    with GitHub, so that it will trigger the Jenkins Pipeline whenever changes are
    pushed to the repository.
  prefs: []
  type: TYPE_NORMAL
- en: Providing access to the repository
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First and foremost, we must provide our Jenkins server with permissions to
    access our repository, as well as to set up service hooks. There are several ways
    to do this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a Personal Access (OAuth) Token on GitHub, which essentially allows your
    Jenkins server to masquerade as you. The benefits of this approach are that you
    can have one token that can be used everywhere to access all repositories under
    your control. However, although the scope of the token can be restricted, these
    permissions are applicable for all repositories under your account. Thus, this
    approach does not allow you to set granular permissions for each repository.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a new user on GitHub that represents the Jenkins server, and add that
    user as a collaborator into your repository. After creating the account, you'll
    need to create a new SSH key pair on your Jenkins host machine, and add the public
    key to GitHub (just as you would for a normal user). Then, configure your Jenkins
    server to use this SSH key to communicate with GitHub.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The benefits of this approach are that it allows you to separate your identity
    from the Jenkin servers, and you can simply add the Jenkin GitHub user to any
    other repository that you wish to grant access to the Jenkins server.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As in Step 2, create a new user on GitHub that represents the Jenkin server,
    and set up a new SSH key pair. Then, go to your repository and click on the Settings
    tab. In the sidebar, click Deploy Keys, then click Add deploy key. Now, paste
    your SSH key into the text area and save.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The benefits of this approach are that you can grant access to only a single
    repository. They are called **Deploy keys** precisely because this method is used
    a lot for automated deployments. You can set the permission for the deploy key
    to be read-only (so they only clone, build, and deploy), or both read and write
    permissions (so they can also push changes back to the repository).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To keep it simple, we are going to use the Personal Access Token method, as
    outlined in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Personal Access (OAuth) Token
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Go to [github.com/settings/tokens](https://github.com/settings/tokens) and
    click on Generate new token. Select the repo, admin:repo_hook, and admin:org_hook
    scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b6630e9c-2586-4332-bb2c-3bfa4c3e062e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, a new token is generated:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d55b352-2dc2-4aaa-9f89-22069cce546b.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we can add this token to the **Credentials** store in Jenkins, which is
    like a password manager and stores our credentials for us to reference inside
    our configuration. Click on the Credentials entry from the sidebar on the left
    of the Jenkins UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, under Stores scoped to Jenkins, click on the arrow next to the (global)
    link and then Add credentials. This will allow you to add your Personal Access
    Token to be available to the whole of Jenkins server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2dfe208a-9f81-4da1-ba9b-0b6315bb73cb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the form that appears, input the following values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f3b2b491-6639-422a-a13d-b073605f2a82.png)'
  prefs: []
  type: TYPE_IMG
- en: There are two options available for the Scope field—system or global. A system-scoped
    credential can be used by the Jenkins instance itself, but not in freestyle projects
    or pipelines. Global-scoped credentials can be used by all. The ID is an internal
    unique ID that is used to identify this credential; if left blank, an ID will
    be generated automatically.
  prefs: []
  type: TYPE_NORMAL
- en: Using the GitHub plugin
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To integrate with GitHub so that changes pushed to the repository will trigger
    a build on Jenkins, we will need to use two plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Git plugin** ([plugins.jenkins.io/git](https://plugins.jenkins.io/git)):
    Enables Jenkins to clone and pull from any Git repository that it has access to.
    Also adds Git-specific environment variables to the build environment so you can
    use it during any build steps.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**GitHub plugin** ([plugins.jenkins.io/github](https://plugins.jenkins.io/github)):
    Allows you to set up a service hook on GitHub that will send a message to our
    Jenkins instance each time a change is pushed to GitHub. The GitHub plugin also
    depends on the Git plugin.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two plugins should be installed if you followed the standard installation;
    otherwise, install them before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the GitHub plugin to automatically set up service hooks for us, we must
    provide it with the credentials we stored earlier. Go to Manage Jenkins | Configure
    Systems and under the GitHub section, add a new GitHub Server:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/82ad4aaa-335e-485e-aa5e-8c08fb15ae02.png)'
  prefs: []
  type: TYPE_IMG
- en: In the Credentials field, select the credential we stored in the previous name.
    Then, click Test connection so Jenkins can send a dummy request to GitHub to ensure
    the token is a valid one. Now, our GitHub plugin will be able to perform actions
    on our behalf.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up GitHub service hooks manually
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, go to our `Hobnob` repository on GitHub and select Settings | Integrations
    & services. You should see a list of services that hook onto events on GitHub,
    including the Travis service we added at the beginning of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19fa6e47-56af-4b77-b168-7ea84c454df2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we need to add the Jenkins (GitHub plugin) to the list of services:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7b33b7da-dcb8-4ecc-899f-390a90efd838.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On the next screen, GitHub will ask you to specify the Jenkins hook url; this
    is the URL that GitHub uses to inform our Jenkins instance of a change in the
    repository. Jenkins uses a single post-commit hook URL for all the repositories;
    by default, this has the format of `http://<ip-or-hostname>/github-webhook/`.
    So for us, we will use `http://jenkins.hobnob.social/github-webhook/`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7163bf8-54c9-4b64-a8e1-3ea4dcd34786.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will add the Service Hook to GitHub, but it''ll also indicate that it
    has never been triggered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c359edd8-701c-47bf-81b0-ad1b425dbd9b.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we need to create the pipeline on Jenkins so that when the service hook
    is triggered, we can run our pipeline as defined in the `Jenkinsfile`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new folder
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: But before we create a pipeline, we know that our application will consist of
    two parts—a backend API server and a frontend web interface. We will eventually
    use Jenkins to build both of these applications, and so it would be wise to separate
    the pipelines into two separate groups, which in the context of Jenkins, is a
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new folder, click on the New Item link found on the left-hand side
    of the interface. You''ll then be presented with the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0eb17864-b848-4298-9787-45d23d9f727a.png)'
  prefs: []
  type: TYPE_IMG
- en: Under the Name parameter, enter a name that identifies this folder and acts
    as a namespace for all projects grouped under this folder. This name will also
    be used in the URL path, as well as the directory name in the filesystem, therefore,
    you should pick a name that does not contain spaces or special characters (especially
    slashes).
  prefs: []
  type: TYPE_NORMAL
- en: You may optionally specify a Display Name and Description. Click Save and the
    folder will be created and can be accessed through the URL, [http://jenkins.hobnob.social/job/backend/](http://jenkins.hobnob.social/job/backend/).
    Next, we are going to create a new pipeline under this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Navigate to `http://jenkins.hobnob.social/job/backend/` and click on the New
    Item link again, but this time select the Pipeline option:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/21ebfb29-eac9-4615-b902-b7e1537d2aee.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the General section, check the GitHub project checkbox and paste in the
    URL to your GitHub project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/19b30e70-8b79-40d1-a0f9-b1566f6900ec.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Then, in the Build Triggers section, check the option for GitHub hook trigger
    for GITScm polling. This means this pipeline will be executed every time our webhook
    endpoint (`http://jenkins.hobnob.social/github-webhook/`) receives a message from
    GitHub related to this GitHub project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/440e7c87-f61c-4454-b69a-f03c52f9c483.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, under the Pipeline section, select Pipeline script from SCM and make
    sure Script Path is set to Jenkinsfile. This will tell Jenkins to use the Jenkins
    file from the repository. Then, click on Add repository and paste in the repository
    URL. Lastly, in Branches to build, enter the value `*/*` so that the pipeline
    will trigger based on changes on any branch:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5a8c6f08-6b59-4750-a2dd-4fd488d6a3a6.png)'
  prefs: []
  type: TYPE_IMG
- en: Save the pipeline, and move on to running our first build!
  prefs: []
  type: TYPE_NORMAL
- en: Running the first build
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, run `git commit --amend` to change the commit hash; this will be sufficient
    to constitute a change. Push this change to the remote repository. Fingers crossed,
    this should trigger the build on our Jenkins server.
  prefs: []
  type: TYPE_NORMAL
- en: First, it will download the repository and it into a workspace located at `/var/lib/jenkins/jobs`,
    then, it will run the instructions specified in our `Jenkinsfile`.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a build (freestyle project or pipeline) is triggered, it will be added
    to the list of builds in the Build History sidebar on the left. The indicator
    to the left of the build shows the status of the build. Initially, it will be
    flashing blue, indicating it is running but not yet complete. Once the pipeline
    has completed execution, the indicator will change to a non-flashing blue or red,
    representing a successful or failed build:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b0510767-7849-4803-b9ce-e34c6fce0040.png)'
  prefs: []
  type: TYPE_IMG
- en: 'You can keep track of the progress of the pipeline by going to the Console
    Output tab and reading the `stdout` produced. However, if you prefer a visual
    representation, you can look at the **Stage View**, which displays a table with
    colored blocks, where green represents a passing stage, and red represents a failed
    stage. This is provided by the pipeline stage view plugin ([plugins.jenkins.io/pipeline-stage-view](https://plugins.jenkins.io/pipeline-stage-view)),
    which is installed by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/04f1e1f2-72cf-43de-93b6-045657b25561.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have integrated our project with two CI services—Travis
    and Jenkins. With CI, we are able to trigger tests to run after certain events
    and automate the testing of our app. We have also used Docker to provide an isolated
    environment for our tests, ensuring our tests remain reliable and repeatable. In
    [Chapter 17](d336b08b-f67f-4789-8194-c65d7aa3decc.xhtml), *Migrating to Docker*,
    we will even migrate our entire deployment to using Docker.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to secure our application by implement
    authentication and authorization checks in our API.
  prefs: []
  type: TYPE_NORMAL
