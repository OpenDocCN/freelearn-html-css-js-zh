- en: Chapter 8. Scaling Up – Ensuring Performance in Complex Applications
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will look at the most common performance issues in Backbone,
    as well as how to avoid them. In particular, we''ll cover the following:'
  prefs: []
  type: TYPE_NORMAL
- en: CPU-based performance issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bandwidth-based performance issues related to content size
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bandwidth-based performance issues related to the number of requests
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Memory-based performance issues
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Backbone and performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At its core, Backbone is just a JavaScript library, and as such, it doesn't
    add any new performance challenges that weren't already in JavaScript to begin
    with. In fact, the creators of Backbone have taken great care to make the library
    perform well, and in performance comparisons with rival libraries, Backbone typically
    comes out ahead, if not on top.
  prefs: []
  type: TYPE_NORMAL
- en: However, while Backbone itself doesn't create performance issues, it does enable
    entirely new ways of creating web applications, and because such applications
    can be far more complex than traditional websites, a whole new realm of potential
    performance issues is exposed. In this chapter, we will explore these issues,
    as well as their underlying technical details, and address ways to avoid or mitigate
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Causes of performance issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Whenever a user experiences performance problems, it is because he has exceeded
    the capacity of one of his system resources, either bandwidth memory or processing
    power. Before debugging any performance issue, it's essential to understand which
    of these factors is responsible, and this can be determined in one of two ways.
    First, a profiling tool (such as the tools included with all major browsers) can
    be used to measure how much of each resource is being used, which should quickly
    make obvious which resource is being used excessively. An explanation of these
    tools falls outside the scope of this book, but I strongly encourage you to familiarize
    yourself with the tools available in your favorite browser.
  prefs: []
  type: TYPE_NORMAL
- en: For most problems, however, a profiling tool won't even be necessary, because
    their source can be determined by how they manifest. Bandwidth problems only occur
    when retrieving or sending data from your server (and in most applications, only
    retrieval operations involve enough bandwidth to be problematic). If they occur
    at load time, then they could be caused by a significant number of large static
    resources, such as images, but if they occur afterwards, they are far more likely
    to be the result of AJAX calls. In Backbone applications, this means *fetch* operations
    (or, rarely, *save* or *destroy* operations) from `Models` or `Collections`.
  prefs: []
  type: TYPE_NORMAL
- en: CPU performance issues only occur when the user's computer is forced to think
    hard about something you are making it do. For example, a series of nested `for`
    loops, or the rendering of a complex visualization such as a chart can cause such
    performance issues. This type of performance issue is usually easy to identify
    because it only occurs when the user triggers such computationally intensive code.
  prefs: []
  type: TYPE_NORMAL
- en: The final, and by far the most difficult, source of performance issues is the
    memory. Unlike the other two issues, which usually have obvious triggers such
    as the start of an AJAX operation or the rendering of a chart, memory issues can
    occur without any clear or obvious source. In fact, memory issues can begin seconds
    or even minutes before the user actually starts noticing problems, forcing you
    to trace back through all the code they hit to try and find a cause. Because memory
    issues are the most common type, and because they are the hardest to understand
    and resolve, we will be focusing most heavily on them in this chapter. However,
    before we do so, let's examine the other two sources, and some common sense approaches
    to avoiding them.
  prefs: []
  type: TYPE_NORMAL
- en: CPU-related performance issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned earlier, Backbone itself will not usually be the source of CPU-related
    performance issues, because these issues tend to be caused by specific components
    rather than the overall site architecture. However, there is one way that Backbone
    can contribute to such problems, and that is by making it easy to repeat the same
    work in multiple places. For instance, let's imagine that you are creating a dashboard
    page that will use one main `View` class to show your user various pieces of data,
    and a number of child `Views` to render each of these pieces of data. In addition,
    let's imagine that each of these pieces of data will update periodically. Normally,
    you would tie the updating of that data to an AJAX response or a user event, but
    under certain circumstances, you might instead want to use a `setInterval` statement.
    For instance, `onScroll` events are known to be problematic, so many developers
    avoid them and instead rely on `setInterval` to check for scrolling periodically.
  prefs: []
  type: TYPE_NORMAL
- en: This approach will work fine as long as there is only a single `setInterval`
    event running, but what if you instead decide to create a separate `setInterval`
    event for each child `View`? With only a few child `Views`, this still might work,
    but eventually, too many such intervals will become a drain on the user's CPU,
    causing performance problems. In the worst case scenario, while your development
    machine will be able to handle the page, your user's (less powerful) machine might
    not, causing the user to report bugs that you can't reproduce.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution in such cases is straightforward: Don''t repeat processing-intensive
    tasks unnecessarily. In the preceding example, instead of having each child `View`
    update in response to its own `setInterval` event, you could start only a single
    `setIonterval` process in the main `View` and then, have it trigger updates in
    your child `Views` (possibly by using the pub/sub pattern described in the previous
    chapter).'
  prefs: []
  type: TYPE_NORMAL
- en: Event delegation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One other way developers can easily create unnecessary strain on the user's
    browser is by creating too many event handlers. For instance, let's say you want
    to create a large table (perhaps 20 rows × 20 columns), so you create a parent
    `View` for the table and a large number of child `Views` for each cell. So far
    so good! Now let's say, you add a `click` event handler to each of these child
    `Views`. Without realizing it, you just created 400 event handlers. If you add
    another event handler, such as a `change` handler for `<input>` elements inside
    the cell, you add another 400, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given enough `Views` and enough event handlers, this can eventually create
    a performance issue, but luckily, JavaScript comes with a built-in mechanism that
    we can use to solve this problem: event bubbling. Whenever an event occurs in
    the DOM, it first triggers event handlers on the relevant DOM element and then
    bubbles up to each successive parent of that element. In other words, if a `click`
    event occurs on a `<td>` element, the browser will resolve any event handlers
    bound to that `<td>` element first, then (unless one of the event handlers returned
    false) it will call the handlers on the `<td>` element''s parent `<tr>` element
    and then that `<tr>` parent''s `<table>`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We can take advantage of this fact and change our event binding strategy to
    improve performance by binding our events to the parent `table` element's `View`
    rather than to each child `View`. This parent `View` event handler can then trigger
    the appropriate logic on the relevant child `View` by using the event's `target`
    property to determine which child `View` caused the event. While this approach
    requires slightly more work, it allows us to reduce our 400 click event handlers
    down to a single event handler, and on particularly complex pages (such as our
    hypothetical table page), the use of such event delegation can significantly reduce
    the strain on the browser.
  prefs: []
  type: TYPE_NORMAL
- en: Bandwidth-related performance issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While it''s true that the typical user''s bandwidth has grown significantly
    in the recent years, the bandwidth nevertheless remains a constant issue for web
    developers. However, many developers don''t realize that there are actually two
    main sources of bandwidth problems. The first of these is fairly obvious: forcing
    your users to download files that are too large. But, there is also a second,
    less obvious source: forcing your users to download too many files at once.'
  prefs: []
  type: TYPE_NORMAL
- en: Downloading excessively large files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s start with the obvious source first. If the files that your users need
    to download are too large, it doesn''t matter whether they are images, videos,
    or JavaScript code files: Your site is going to load slowly. However, you can
    make a big difference in the size of any file you use by enabling compression
    at the web server level. On an Apache web server, this can be done by using `mod_deflate`,
    and most other web servers have similar options. Doing so will make your server
    compress the files that it sends to your users in such a way that your users''
    browser can easily decompress them … all without the user even knowing that any
    decompression is going on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if turning on compression doesn''t help enough, then your next steps
    depend on the file type. If your issues come from images or videos, then you simply
    have to find a way to use smaller files, for instance, by lowering their resolution.
    However, if JavaScript files are your main concern, there is another option: using
    a minification program.'
  prefs: []
  type: TYPE_NORMAL
- en: Minification programs parse your code to create a new optimized version of it
    that eliminates comments, removes extra whitespace, and renames variables with
    shorter names. The only downside to using such a program is that it will make
    it harder for you to debug problems on your production servers, which shouldn't
    be an issue as long as you have a matching development environment where you don't
    minify your files. Further, if the minification truly becomes a problem, you can
    always temporarily switch your server back to the unminified files to do your
    debugging.
  prefs: []
  type: TYPE_NORMAL
- en: Together the two techniques of web server compression and minification can result
    in a major difference in file size. For example, the uncompressed jQuery library
    (version 1.11.0) is 276 KB, while the zipped version is only 82 KB and the zipped
    version of the minified jQuery code is only 33 KB. In other words, just by using
    these two techniques, it's possible to reduce jQuery's footprint by almost a factor
    of ten!
  prefs: []
  type: TYPE_NORMAL
- en: Downloading excessive number of files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unfortunately though, even if you reduce the bandwidth of your code files and
    assets, there is also another, more subtle bandwidth issue to worry about that
    has nothing to do with the number of bytes your user downloads. To understand
    this issue, you have to understand how browsers handle requests for data, both
    those that come from the DOM (such as the `<link>` and `<script>` tags) and AJAX
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a browser opens up a connection to a particular remote computer, it keeps
    track of how many other connections have already been opened to that computer''s
    domain, and if too many are already open, it pauses until one of the previous
    requests completes. The exact number of connections that can occur before this
    happens varies by browser: In Internet Explorer 7, it''s only two, but in most
    modern browsers, it''s six or eight. Because of this limit, and because each request,
    no matter how small, has a certain minimum amount of time that it will take (also
    called latency), the actual amount of bandwidth used can be irrelevant. There
    are two main approaches for solving a bandwidth issue.'
  prefs: []
  type: TYPE_NORMAL
- en: The first is, obviously, to make fewer requests. If your problem is too many
    `Models` being fetched at once, `Collections` can be very helpful in solving it;
    instead of fetching each `Model` class individually, simply create an endpoint
    on your server that can return all of the `Models` at once and then, use a `Collection`
    class to fetch them. Even though you will be downloading the same amount of data,
    this change in API will result in significantly less requests. Similarly, if your
    problem is too many images, you can combine all of the images into a single `sprites`
    file and then, use CSS to only display one image at a time.
  prefs: []
  type: TYPE_NORMAL
- en: The other option, if your application truly does require a large number of requests,
    is to use subdomains. When a browser counts how many connections it has outstanding,
    it doesn't just look at the source's domain but also at its subdomain. This means
    that you can fetch the maximum number of requests from [http://example.com/](http://example.com/)
    and then, fetch that same number of requests from `foo.example.com`, `bar.example.com`,
    and so on. This trick is often used to serve CSS and images more quickly, but
    it can just as easily be used to make a large number of simultaneous fetches (as
    long as you update your `url` methods appropriately to fetch from the correct
    subdomain).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, there is one last solution to bandwidth issues, which doesn't really
    solve these issues so much as make them more palatable to the user. If you know
    that you're going to be making a request that will take long enough for the user
    to notice, you can give the user a visual wait indicator, such as adding an animated
    spinner image or changing the cursor's CSS property to wait. If you make these
    changes just before you start a `fetch` operation, you can then use that operation's
    success and failure callbacks (or, if you use the deferred style, a single `complete`
    callback) to undo the changes. While this won't make your data download any faster,
    it will make a difference in your user's experience.
  prefs: []
  type: TYPE_NORMAL
- en: Memory-related performance issues
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Memory-related issues are the hardest to debug and solve, and unfortunately,
    they are also the most likely to be encountered when you first start using Backbone.
    Again, this is not because Backbone itself has memory issues, but because the
    possibilities that Backbone enables can allow developers to shoot themselves in
    the foot if they're not careful.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we proceed, it's important to first explain just how browsers
    manage memory. As you probably already know, the memory in JavaScript is managed
    by the browser, not the developer, using something called **garbage collector**.
    What this means is that you don't have to tell the browser I'm done using this
    variable. Instead, you can simply stop using that variable and the browser will
    figure out that it has become `garbage`, which will usually make it clean that
    variable up automatically.
  prefs: []
  type: TYPE_NORMAL
- en: 'The problem is that the garbage collector operates on a very simple interpretation
    of what is or is not garbage. In essence, any variable that is not referenced
    by another variable is considered to be garbage. For instance:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The problem is that developers often don''t realize when they leave behind
    references to a variable, and as such, they force the browser to keep using its
    memory even though the programmer considers it garbage. Let''s look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this example, it seems like we eliminated all references to `exampleView`
    when we called `exampleView.remove()` and removed it from the DOM, but in fact,
    there was still one reference left behind, hidden inside `exampleModel`. This
    reference was created when we called the `on` method of `exampleModel` and passed
    it `exampleView.render`. By doing so, we told the `Model` to wait until a change
    happens and then call `exampleView.render`, which required it to store a reference
    to `exampleView.render`. Since we didn't delete `exampleModel`, this reference
    remains and won't be garbage-collected, leaving a so-called zombie `View` in the
    browser's memory.
  prefs: []
  type: TYPE_NORMAL
- en: 'One way to solve this problem would be to remove this reference manually by
    using the `off` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: However, having to manage such references can quickly become tedious. Luckily,
    the creators of Backbone added a method to `View` (as well as the other three
    Backbone classes) that helps solve this problem, called `listenTo`. This method
    works very similarly to `on` with two important differences. First, it is called
    on the listening object (in this case, the `View`), rather than on the object
    being listened to (in this case, the `Model`), and second, it does not take a
    context argument. Instead, the context of the callback will always be set to the
    object that `listenTo` was called on.
  prefs: []
  type: TYPE_NORMAL
- en: Just as there is an `off` method for `on`, there is a `stopListening` method
    that removes listeners created by `listenTo`. However, you won't need to call
    `stopListening` yourself very often, because it's called automatically as part
    of the `remove` method of a `View`, which is what makes it so convenient.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s retry our last example using `listenTo`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This time, just as before, we have a `View` listening for changes in a `Model`.
    However, because we used `listenTo` instead of `on`, the reference created as
    a side effect will get removed whenever `stopListening` is called. Since we called
    `remove` on `exampleView` and since this method automatically calls `stopListening`
    for us, our `View` gets garbage-collected correctly without us having to do any
    extra work.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, however, `listenTo` can't solve all potential leaky references.
    For one thing, you may still want to use the `on` method from time to time. The
    primary reason for doing so is to listen for events from non-Backbone code, such
    as a jQuery UI widget. You might also be tempted to use `on` because (unlike `listenTo`)
    it takes a context argument, but thanks to Underscore's `bind` method, you don't
    need to do so; you can simply bind your desired context in your callback function
    before passing it to `listenTo`. However, even if you do avoid using `on` entirely,
    you still have to remember to call `remove` on your `View`. If you don't, you
    still need to use `off` or `stopListening` to clear the event binding references.
    Finally, event handlers aren't the only source of references.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, parent `Views` and child `Views` often reference each other, and
    unless you delete the referencing `Views` entirely, the `Views` that it references
    won't actually be garbage-collected. The good news is that there's no need to
    worry too much about such references on a small scale, and in fact, trying to
    optimize performance too heavily on every last bit of code in your application
    can wind up being counterproductive. Any given `Model` or `View` will normally
    take up only a small amount of memory on its own, so even if you do create a leaky
    reference that prevents it from being garbage-collected, the actual effect on
    your application's performance will be minimal. If the user never even notices
    the leak and then reclaims the memory when he closes his browser or hits refresh,
    then clearly there was no need for you to have spent time worrying about it.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, you mainly want to focus on managing your references when dealing with
    large numbers of objects. If you are designing a page `View` that will be used
    throughout your application, or creating a `View` for a large table with many
    separate child `Views`, then you will likely want to be extra careful with each
    reference you create and ensure that all these references get cleaned up when
    you are done with them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned how JavaScript code in general, and Backbone code
    in particular, can cause performance problems. We learned the three main causes
    of such problems (namely bandwidth, CPU, and memory), as well as techniques and
    methods that can be used to solve them. In particular, we learned how leaky event
    bindings or other references can prevent garbage collection, and how using `listenTo`
    or manually cleaning up references can enable garbage collection to work as expected.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll examine the benefits of proper code documentation,
    learn how to solve some of the Backbone-specific documentation challenges, and
    consider which of the many quality documentation tools are the best for documenting
    your projects.
  prefs: []
  type: TYPE_NORMAL
