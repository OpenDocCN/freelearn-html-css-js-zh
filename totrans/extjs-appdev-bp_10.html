<html><head></head><body><div class="chapter" title="Chapter&#xA0;10.&#xA0;Debugging and Performance"><div class="titlepage"><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Debugging and Performance</h1></div></div></div><p>In previous chapters, we discussed the role of the architect as being one with many facets. From understanding client requirements to designing the code structure based on UI wireframes right down to coding standards and naming conventions, an architect will wear many hats during the lifetime of a project.</p><p>One of these hats is that of planning with knowledge of the technology at hand. In order to make sure that the users of a software platform have a responsive experience that won't result in frustration, we need to make sure that the design that's in place will load quickly and will promptly react to user input. With Ext JS, this means having an understanding of the right component to use at the right time, working with layouts in an efficient manner, designing your view model hierarchy to avoid overnesting, and so on. There are lots of things to consider.</p><p>Once the design is complete, there may be unexpected performance issues or bugs as development progresses. In these situations, the architect may take on the role of an expert problem solver, jumping in to apply their practical knowledge of the technology. Working with third-party developer tools to step through source code and profile areas of slow performance are key aspects to driving a project through to completion.</p><p>In this chapter, we'll cover these topics in the context of Ext JS and more:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Working with browser tooling to debug and track performance</li><li class="listitem" style="list-style-type: disc">Picking through the Ext JS source code</li><li class="listitem" style="list-style-type: disc">Ext JS performance do's and don'ts</li><li class="listitem" style="list-style-type: disc">Common pitfalls of Ext JS development</li></ul></div><p>By the end of this chapter, we'll have the ability to work as project firefighters, jumping into situations that need fast, authoritative solutions before they spiral out of control.</p><div class="section" title="In-browser debugging"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec117"/>In-browser debugging</h1></div></div></div><p>We'll examine<a id="id608" class="indexterm"/> several features of the Developer Tools <a id="id609" class="indexterm"/>of the Google Chrome browser (firstly, stepping through code and debugging it). Why Google Chrome? Aside from the fact that it's my own browser of choice, its tools feel a little slicker than those in, for example, Firefox. Having said that, Firefox will allow you to do most of what we'll discuss in this chapter if you'd prefer to stick with Mozilla. At the time of writing this book, Chrome was at version 40, but most of these features have been around for at least a year.</p><p>During development, there will inevitably be situations in which we'll deal with code that doesn't work exactly as we'd expect, whether that's the code we've written, code from another member of our development team, or code in a third-party library (such as Ext JS).</p><p>When this happens, it's useful to be able to halt code execution and inspect the state of the application directly. This is exactly what the Chrome Debugger allows us to do.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note18"/>Note</h3><p>Documentation<a id="id610" class="indexterm"/> on using Chrome Developer Tools to debug JavaScript can be found at <a class="ulink" href="https://developer.chrome.com/devtools/docs/javascript-debugging">https://developer.chrome.com/devtools/docs/javascript-debugging</a>.</p></div></div><p>We'll use the Alcohology app from <a class="link" href="ch09.html" title="Chapter 9. A Shopping Application">Chapter 9</a>, <span class="emphasis"><em>A Shopping Application</em></span>, to show how a debugging session might play out.</p><div class="section" title="Stepping in"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec113"/>Stepping in</h2></div></div></div><p>Let's load up<a id="id611" class="indexterm"/> the Alcohology project in Chrome and <a id="id612" class="indexterm"/>navigate to a product, then pop up the Chrome Developer Tools by going to the <span class="strong"><strong>View</strong></span> menu, then <span class="strong"><strong>Developer</strong></span>, and <span class="strong"><strong>Developer Tools</strong></span>. Select the <span class="strong"><strong>Sources</strong></span> pane on the Developer Tools and you should end up with something like this:</p><div class="mediaobject"><img src="graphics/5308OT_10_01.jpg" alt="Stepping in"/><div class="caption"><p>The Alcohology app with Chrome Developer Tools</p></div></div><p>Let's imagine a<a id="id613" class="indexterm"/> theoretical situation in which something's not quite right when we add this product to the shopping cart. We'd <a id="id614" class="indexterm"/>like to drop into the code that handles the <code class="literal">click</code> event on the <span class="strong"><strong>Add to Cart</strong></span> button, so in the left pane of Developer Tools, we use the file explorer to navigate to <code class="literal">/app/view/product/ProductController.js</code> and scroll to the <code class="literal">onAddToCart</code> method.</p><p>By clicking on the line number for line <span class="strong"><strong>54</strong></span>, a blue indicator appears to show that we have set a "breakpoint" in the code at the beginning of the <code class="literal">onAddToCart</code> method. When code execution reaches line <span class="strong"><strong>54</strong></span>, the debugger will pause execution and give us a chance to inspect the application state:</p><div class="mediaobject"><img src="graphics/5308OT_10_02.jpg" alt="Stepping in"/><div class="caption"><p>ProductController.js with a breakpoint (indicated in blue) on line 54</p></div></div><p>The breakpoint has been set, so the next step is to trigger the execution of this code and examine <code class="literal">onAddToCart</code>.</p></div><div class="section" title="Breaking point"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec114"/>Breaking point</h2></div></div></div><p>Clicking <a id="id615" class="indexterm"/>on the <span class="strong"><strong>Add to Cart</strong></span> button will call the <code class="literal">onAddToCart</code> click handler and pause the execution on line 54. The whole line will become highlighted in blue to show the location we're paused on. This line of code grabs the current product from the view model and stores it in a <code class="literal">product</code> variable.</p><p>At this point, the highlighted line of code is yet to run and so the product variable will be undefined. Let's move on to the next line and examine the contents of product by clicking on the curving arrow in the right pane:</p><div class="mediaobject"><img src="graphics/5308OT_10_03.jpg" alt="Breaking point"/><div class="caption"><p>The "step over next function call" button highlighted in a red circle</p></div></div><p>This will skip the current line and move to the next, this time highlighting line 56 in blue.</p><p>At this point, the product variable will be set, so you can hover the mouse over it and a popup will appear showing its various properties and methods. As it's an instance of <code class="literal">Alcohology.model.Product</code>, which is <code class="literal">Ext.data.Model</code>, we'll see all of the properties and methods on the object provided by all of the classes in the inheritance chain.</p><p>Depending on the exact structure of the inheritance chain, some of these properties and methods will only be revealed by drilling down through the <code class="literal">__proto__</code> property and expanding it.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note19"/>Note</h3><p>The <code class="literal">__proto__</code> property<a id="id616" class="indexterm"/> is an internal property on a JS object that points to the prototype of this object. Ext JS replicates classical inheritance by using JavaScript's prototypal inheritance. You can read about this in more detail at MDN <a class="ulink" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain">https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Inheritance_and_the_prototype_chain</a>.</p></div></div><p>The line 56 looks like this:</p><div class="informalexample"><pre class="programlisting">this.getViewModel().get('cart').addProduct(product);</pre></div><p>Let's say<a id="id617" class="indexterm"/> we'd like to drill down into the <code class="literal">addProduct</code> method and investigate what's happening in here. The <span class="strong"><strong>Step in to next function call</strong></span> button will let us do this (it's the downward arrow next to the <span class="strong"><strong>Skip over</strong></span> button). The trouble is that it does exactly what it says, that is, steps into the next function call. Line 56 actually consists of three separate function calls:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A call to <code class="literal">getViewModel</code> that returns the view model assigned to this view controller</li><li class="listitem" style="list-style-type: disc">A call to get with the parameter 'cart' that returns the cart from the view model</li><li class="listitem" style="list-style-type: disc">Finally, the call to <code class="literal">addProduct</code> with the product variable as a parameter</li></ul></div><p>The result is that the first time we click on <span class="strong"><strong>Step In</strong></span>, we'll end up in the Ext JS framework code for <code class="literal">getViewModel</code>. We then click on the <span class="strong"><strong>Step Out</strong></span> upward arrow to return to line 56. <span class="strong"><strong>Step In</strong></span> and <span class="strong"><strong>Step Out</strong></span> again takes us in and then back out of <code class="literal">get</code>. Finally, on the third party of our little dance, <span class="strong"><strong>Step In</strong></span> will take us into the source of the <code class="literal">addProduct</code> method:</p><div class="mediaobject"><img src="graphics/5308OT_10_04.jpg" alt="Breaking point"/><div class="caption"><p>Stepping in to the addProduct code</p></div></div><p>We can <a id="id618" class="indexterm"/>now examine how the product is used in this method and verify that the code is behaving as expected and if not, why not?</p><p>The repeated stepping in/out can be painful and confusing, particularly for new developers looking to use these advanced tools. As the problem-solving architect, we need to understand these quirks for both our own sake and to assist our team in debugging sessions. There are a couple of ways around this; we'll look at these next.</p></div><div class="section" title="Black box and cut to the chase"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec115"/>Black box and cut to the chase</h2></div></div></div><p>Chrome <a id="id619" class="indexterm"/>has a feature known as "blackboxing", which tells Chrome to bypass a code file when debugging. This is exactly what we need in order to avoid the step in/out dance we saw earlier; by blackboxing the Ext JS source, Chrome will not step into this code.</p><p>It's easy to set up <a id="id620" class="indexterm"/>blackboxing. Just use the left-hand side file navigator to open the Ext JS source code, which in development builds will likely be something like this:</p><div class="informalexample"><pre class="programlisting">/ext/build/ext-all-rtl-debug.js</pre></div><p>We also opened this file earlier as we stepped through the code, so we have an alternative method of getting it open in the central pane. When we've got the file in question, it's a simple matter of right-clicking on it and choosing the <span class="strong"><strong>Blackbox Script</strong></span> option from the menu:</p><div class="mediaobject"><img src="graphics/5308OT_10_05.jpg" alt="Black box and cut to the chase"/><div class="caption"><p>The options menu for a source file with the Blackbox Script option highlighted</p></div></div><p>A banner will <a id="id621" class="indexterm"/>appear at the top of the pane to indicate that the file has been blackboxed. This is a great way to simplify debugging sessions. As the Ext JS source code is more than 100,000 lines long, it can also speed up the process a great deal.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note20"/>Note</h3><p>There are multiple<a id="id622" class="indexterm"/> methods of blackboxing a script. Refer to <a class="ulink" href="https://developer.chrome.com/devtools/docs/blackboxing">https://developer.chrome.com/devtools/docs/blackboxing</a> for more information on the Chrome Developer Tools documentation.</p></div></div><p>The second method of avoiding step in/out pain is to bypass the code in question altogether. If we know the source of the method we really want to debug, then why not just set another breakpoint there instead? In our previous example, it would have made more sense to set the breakpoint on line 9 of Cart.js, right inside the <code class="literal">addProduct</code> method. By clicking on the <span class="strong"><strong>Resume Script Execution</strong></span> icon, represented by a blue right-facing arrow, we could have jumped immediately from the breakpoint in the <code class="literal">ProductController</code> to the one in the <code class="literal">Cart</code> class.</p><p>There's an adage in software development: writing code is easier than reading code. Taking the time <a id="id623" class="indexterm"/>to work through and understand code that others have written is a key skill that all developers should acquire, but it's of particular value to architects who are often in the position of evaluating existing code and understanding how it fits into a bigger picture.</p><p>Debugging and stepping through code is a key part of this, tracing the execution of different paths to build a picture of how the application is behaving.</p></div></div></div>
<div class="section" title="Breaking and busting"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec118"/>Breaking and busting</h1></div></div></div><p>At some point<a id="id624" class="indexterm"/> in the development of a project, a developer will inevitably be faced with an obscure error, which is raised from the depths of Ext JS when the application loads. This raises an issue with the way Ext JS sets up its caching mechanism. For example, a normal (if slightly naïve) request for a JavaScript file might look like this:</p><div class="informalexample"><pre class="programlisting">GET: /assets/javascripts/jquery.min.js</pre></div><p>Out of the box, <code class="literal">Ext.Loader</code> will pull scripts like this:</p><div class="informalexample"><pre class="programlisting">GET: /ext/build/ext-all-rtl-debug.js?_dc=1420215165267</pre></div><p>It appends a timestamp query variable to the request. This is designed to ensure that we always get the latest version of the script by bypassing browser caching mechanisms.</p><p>This can be very useful; however in our situation, it means that any breakpoints set in our code will be removed when the page reloads because Chrome thinks the file is different as the timestamp's different.</p><p>How can we resolve this? It turns out to be really simple; just open <code class="literal">app.json</code> in the root of an Ext JS project and search for the comment starting "this option is used to configure the dynamic loader". The comment contains various options to be passed to the loader, such as passing <code class="literal">true</code>, which "allows requests to receive cached responses". So, we can add the following code:</p><div class="informalexample"><pre class="programlisting">"loader": {
        "cache": true
},</pre></div><p>Also, the cache-busting timestamps will be removed. Note the trailing comma. This is required to ensure the file remains as parsable JSON.</p><div class="section" title="Caught in the act"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec116"/>Caught in the act</h2></div></div></div><p>Back to the<a id="id625" class="indexterm"/> situation in which errors pop up to surprise us. There may be an error that happens on page load, on user interaction, or because of some background job. It would be great to be able to catch errors as they happens so that we can poke around with the debugger and try and establish what went wrong.</p><p>Fortunately, Chrome provides a feature that does exactly this: "break on error", as shown here:</p><div class="mediaobject"><img src="graphics/5308OT_10_06.jpg" alt="Caught in the act"/><div class="caption"><p>The "break on error" icon, highlighted by a red circle</p></div></div><p>Let's try a contrived example. Click on the "break on error" button and it turns blue, then open up the Alcohology project's <code class="literal">Application.js</code> file, and add the following code to the launch method:</p><div class="informalexample"><pre class="programlisting">Ext.create('Ext.Panel', {
    html: 'Break on error test!',
    renderTo: 'myElement'
});</pre></div><p>Save and reload the web browser. Chrome will immediately jump to the source of the error deep into the Ext JS code:</p><div class="mediaobject"><img src="graphics/5308OT_10_07.jpg" alt="Caught in the act"/><div class="caption"><p>Chrome's debugged paused on a line of code which is throwing an error</p></div></div><p>The original<a id="id626" class="indexterm"/> error thrown is <code class="literal">Uncaught TypeError: Cannot read property 'dom' of null</code>. This doesn't make much sense out of context. Now that we're in the code, we can see the surrounding variables and work out exactly what was null, in this case, the <code class="literal">el</code> variable.</p><p>We can also use the <span class="strong"><strong>Call Stack</strong></span> panel in the right-hand pane to jump up through the call stack to the code that originally initiated this code path and view all of the code calls in between. This is great in complicated scenarios to let us trace the root source of an error:</p><div class="mediaobject"><img src="graphics/5308OT_10_08.jpg" alt="Caught in the act"/></div><p>Alone, none of this will help us solve the problem. Being able to see the error, the state of the application when it was raised, and the path through the code to the original call site, all in combination with an understanding of Ext JS and a bit of intuition give us a smoking gun to resolve this issue.</p><p>The <code class="literal">el</code> variable, short for "element" is null, and looking back at our code in the launch method shows that we set our panel to <code class="literal">renderTo</code> an element called <code class="literal">myElement</code>. Using the <span class="strong"><strong>Call Stack</strong></span> pane, we can step down to the constructor and do some detective work:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Ext.create</code> will call the constructor for the panel; we can see this by clicking on <code class="literal">Ext.panel.Panel</code> in the <span class="strong"><strong>Call Stack</strong></span> pane.</li><li class="listitem" style="list-style-type: disc">This in turn calls the render method on the <code class="literal">Ext.util.Renderable</code> mixin. It passes the value of the <code class="literal">renderTo</code> config as an argument.</li><li class="listitem" style="list-style-type: disc">Within the render method, this argument is called container.</li><li class="listitem" style="list-style-type: disc">The render method calls <code class="literal">Ext.DomHelper.append</code> with a container argument, which the debugger shows to be null.</li><li class="listitem" style="list-style-type: disc">This indicates that the container variable is being manipulated elsewhere within the render method.</li><li class="listitem" style="list-style-type: disc">Tracing back, we find the culprit: <code class="literal">container = me.initContainer(container)</code>.</li><li class="listitem" style="list-style-type: disc">The <code class="literal">initComponent</code> contains the line <code class="literal">container.dom ? container : Ext.get(container)</code>.</li></ul></div><p>All of this leads us to the root source of this particular error: <code class="literal">the string myElement is passed to Ext.get</code>. As we haven't added an element with this ID to the HTML page, Ext JS cannot find it. This means that the panel doesn't have a valid container to render to and causes an error to be thrown.</p><p>The ability to <a id="id627" class="indexterm"/>undertake this kind of investigation can be the difference between a project that meets its deadlines and one that stalls due to unexpected issues. Diving deep into the code in this way is an essential skill to avoid roadblocks and keep your developers moving.</p></div></div>
<div class="section" title="Performance in Ext JS"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec119"/>Performance in Ext JS</h1></div></div></div><p>As architects, we'll<a id="id628" class="indexterm"/> start a project with a lengthy list of requirements from the client that need to be implemented for them to be satisfied. There'll be explicit things such as "login feature" and "mobile friendly", but there are requirements that are not included in this list that nonetheless are unavoidable requirements for every client.</p><p>One of these is that the application should perform well. This is a catchall term that could include:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Responsiveness of UI elements</li><li class="listitem" style="list-style-type: disc">Initial application start up time</li><li class="listitem" style="list-style-type: disc">Remote requests such as load/save</li></ul></div><p>A slow <a id="id629" class="indexterm"/>application is a key source of user frustration and the first step to diagnosing any issues of this nature is to collect information.</p><p>Let's look at the various ways in which Chrome Developer Tools can help us and address common problems using Ext JS.</p><div class="section" title="Network performance"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec117"/>Network performance</h2></div></div></div><p>As we've seen<a id="id630" class="indexterm"/> in our examples, many Ext JS applications will communicate with a backend API service in order to read and write data. If user feedback shows that remote requests are unresponsive, we need to first diagnose the calls that are causing problems. Chrome can help us here.</p><p>With the Developer Tools open, click on the <span class="strong"><strong>Network</strong></span> tab and refresh the page. We get a list of all of the resources requested as the application loads; we can filter this by clicking on one of the headers at the top of the pane. Here's the Alcohology application filtered to "XHR" or Ajax requests:</p><div class="mediaobject"><img src="graphics/5308OT_10_09.jpg" alt="Network performance"/><div class="caption"><p>Chrome Developer Tools with an Ajax request selected</p></div></div><p>In this example, one of the requests has been selected and a breakdown of timing details in shown on the right-hand side. While the Alcohology application has a very fast response time, it serves as a good illustration of how to analyze network performance.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note21"/>Note</h3><p>More details about the<a id="id631" class="indexterm"/> <span class="strong"><strong>Network</strong></span> panel can be found at <a class="ulink" href="https://developer.chrome.com/devtools/docs/network">https://developer.chrome.com/devtools/docs/network</a>.</p></div></div><p>How does this help us? If <a id="id632" class="indexterm"/>the remote server is slow, then as frontend developers, there's not much we can do about this; other than keeping our remote requests to a minimum, we're stuck with what's available. Here's one example that we can act on in order to speed things up.</p><p>Note the "stalled" entry in the timings. This is often caused due to the limit that browsers impose on the number of connections that can be active to one origin (such as a domain or subdomain) at a time. When this number is exceeded, the browser will block any new requests until a connection becomes available. This knowledge gives us several opportunities for optimization.</p><div class="section" title="Make fewer requests"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec06"/>Make fewer requests</h3></div></div></div><p>The<a id="id633" class="indexterm"/> no-brainer approach to this problem is to simply request fewer things from the server and Ext JS gives us several ways to do this. First up is a technique we used in the Alcohology app (use an icon font such as <code class="literal">FontAwesome</code> instead of image icons). This means that we'll only have to download one font file rather than multiple icon files. The <code class="literal">glyph</code> config on menu items and buttons gives us a really easy way to use this feature and negate the need to use bitmap images for icons.</p><p>Next up is nested data. This is an approach that we used in the <code class="literal">Questionnaire</code> component, but one that needs to be used carefully. By setting up model associations, we can request data for the whole hierarchy and populate our data model all at once, rather than per mode type.</p><p>For example, for the <code class="literal">Questionnaire</code> component, we could have loaded the questionnaire, the steps, and the questions in three separate requests, but by bringing it all down at once, we avoided the two remote requests. There are two caveats to this idea; firstly, the server needs to support nested data; secondly, the size of the nested data maybe much larger and therefore result in a slower response time. Multiple separate requests might result in better perceived performance, so application of this concept strongly depends on the situation, speaking of the perception of performance, and so on.</p></div><div class="section" title="Perceived performance"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec07"/>Perceived performance</h3></div></div></div><p>There <a id="id634" class="indexterm"/>are some cases in which we can't improve the load time of certain aspects of an application, for example, it could be report generation where the number crunching involved is a long-running operation.</p><p>In these cases, we need to do what we can to improve the user's perception of performance and assure them that the action they're undertaking is underway and will finish soon.</p><p>In Ext JS, one key mechanism to do this is <code class="literal">Ext.LoadMask</code>. It's used by Ext JS internally in several situations:</p><div class="mediaobject"><img src="graphics/5308OT_10_10.jpg" alt="Perceived performance"/></div><p>In the previous example from the Ext JS Kitchen Sink, a grid with a paging toolbar will automatically use <code class="literal">LoadMask</code> while waiting for the server to return the next page.</p><p>The advantage to the user is that while they have to wait, they're at least being told that they have to wait. Without <code class="literal">LoadMask</code>, they'd have hit a button and received no feedback that the server was thinking about the request.</p><p>We can<a id="id635" class="indexterm"/> leverage <code class="literal">LoadMask</code> in our own code by creating a new instance when we need it, but it's more likely that we'd use it on an existing container and leverage the fact that many Ext JS components have <code class="literal">LoadMask</code> functionality baked in.</p><p>We can use event domains, which we discussed back in <a class="link" href="ch02.html" title="Chapter 2. MVC and MVVM">Chapter 2</a>, <span class="emphasis"><em>MVC and MVVM</em></span>, as one way of hooking into remote requests and masking our components:</p><div class="informalexample"><pre class="programlisting">listen: {
    store: {
        'products': {
            'beforeload': function() {
                this.lookupReference('list').mask('Loading...');
            },
            'load': function() {
                this.lookupReference('list').mask(false);
            }
        }
    }
}</pre></div><p>In this code snippet that we added to the <code class="literal">ProductController</code> on Alcohology, we tell the <code class="literal">listen</code> config to watch out for <code class="literal">beforeload</code> and <code class="literal">load</code> events on the products store. The listener can use the "products" alias that we'd already set up on the products <code class="literal">store</code> class. When the <code class="literal">beforeload</code> event fires, we grab the product list view and call its mask method to show its <code class="literal">LoadMask</code>. When the server response returns and the <code class="literal">load</code> event fires, we call the mask method with the false argument to hide it again.</p><p>It's a simple and an unobtrusive way to wire up the loading mechanism and give the user that all-important feedback, showing that their actions have triggered an effect.</p></div><div class="section" title="Load less"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec08"/>Load less</h3></div></div></div><p>One very <a id="id636" class="indexterm"/>simple way to speed up the response of Ajax requests is to simply request less stuff! If the server supports paging, then any component powered by a store can immediately become more performant by requesting a single page of data rather than pulling it down all at once.</p><p>
<code class="literal">Ext.PagingToolbar</code> can be linked to a store and placed anywhere in an application to provide a pagination UI:</p><div class="informalexample"><pre class="programlisting">bbar: [{
        xtype: 'pagingtoolbar',
        store: { bind: '{products}' },
        displayInfo: true
}]</pre></div><p>Here, for <a id="id637" class="indexterm"/>example, is how we'd begin to add a paging toolbar to the Alcohology application's product list view. It automatically takes on touch-friendly styling from the theme we used:</p><div class="mediaobject"><img src="graphics/5308OT_10_11.jpg" alt="Load less"/><div class="caption"><p>Alcohology's product list complete with paging toolbar</p></div></div><p>A more advanced version of this technique involves using the <code class="literal">Ext.data.reader.Reader.metaData</code> property or the <code class="literal">Ext.data.proxy.Proxy.metachange</code> event. This can be used to pass data from the server to the client, which is in turn used to configure the Ext JS application; a common example is to allow the server to specify the columns that a grid contains when it first loads.</p><p>This could mean that on initial load, the server omits a field and matching grid column, such as a description, which may contain a lot of data. The user could customize the grid via the column header UI to show it when they need it.</p></div><div class="section" title="Optimistic updating"><div class="titlepage"><div><div><h3 class="title"><a id="ch10lvl3sec09"/>Optimistic updating</h3></div></div></div><p>When<a id="id638" class="indexterm"/> saving a record to the server, we'd normally see the following actions:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User clicks a button to save the record</li><li class="listitem" style="list-style-type: disc">Ext JS displays a "saving" message</li><li class="listitem" style="list-style-type: disc">Save completes and a "success" message is displayed</li></ul></div><p>In some situations though, we can trust that the server is going to save successfully and cut the actions down to the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">User clicks on a button to save the record</li><li class="listitem" style="list-style-type: disc">Save proceeds and a "saved" message is displayed</li></ul></div><p>In this case, the save action happens entirely in the background and doesn't block the user from performing other actions. You can see this kind of behavior in many e-mail applications with the server interaction happening behind the scenes and an "outbox" to store messages that fail to send on the first try.</p><p>In the event that the server does raise some kind of error, we can display a failure message and rollback the changes that the user performed. The Ext JS grid includes UI to do this; it will highlight changed values with a red marker that can be cleared when we're sure the record has been successfully committed to the server.</p><p>This is an advanced technique that requires extra UI design work, but it can immeasurably improve your user experience.</p></div></div></div>
<div class="section" title="Quick on the draw"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec120"/>Quick on the draw</h1></div></div></div><p>In addition to ensuring that the way our application interacts with the server is always done in a <a id="id639" class="indexterm"/>timely fashion, we also need to be concerned with the speed at which the user interface renders and how quickly the browser draws the UI. There are a number of common pitfalls with Ext JS in this regard:</p><div class="section" title="Overuse of panels"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec118"/>Overuse of panels</h2></div></div></div><p>Panels <a id="id640" class="indexterm"/>have several features such as a header containing tool icons, the ability to be draggable, collapsible, and have docked items. In many situations, these features just aren't required. In this situation, a container is a much better choice. It's more lightweight in memory and the markup it generates.</p></div><div class="section" title="Overnesting"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec119"/>Overnesting</h2></div></div></div><p>Overnesting <a id="id641" class="indexterm"/>of containers and panels, particularly those implementing border layouts, are a very common source of performance issues, particularly if the user needs to move between various screens containing over-nested components. Ext JS needs to perform lots of calculations to build a viewport and the layout process is particularly expensive. Every time we find ourselves adding a new component to the hierarchy, it should cause us to stop and re-evaluate.</p><p>We also need to think about how a deep hierarchy could affect cases in which we are querying our component structure. With a more complex component tree and a more complicated DOM, any operations to fetch either components or elements from the application will be slower. In many cases, this slowdown will be marginal; in some cases, it'll be a critical consideration when improving your application's performance.</p></div><div class="section" title="Deferred rendering"><div class="titlepage"><div><div><h2 class="title"><a id="ch10lvl2sec120"/>Deferred rendering</h2></div></div></div><p>When<a id="id642" class="indexterm"/> creating a container or panel with a card layout, by default the layout will immediate render all components within each card. This is usually unnecessary because the user will only see the first card to begin with. Instead, we can use the <code class="literal">deferredRender</code> configuration option on the card layout to render items only when their parent card becomes active. This reduces the initial render time, therefore, the time until the application can respond to user input.</p><p>Another similar approach involves grids. Ext JS allows you to load a large server response into a store and attempts to display it on a grid, but in situation with thousands of records, the store causes memory usage to balloon and the browser will struggle to keep things smooth with such a large number of DOM nodes making up the grid rows.</p><p>The solution is to swap out a standard store for <code class="literal">Ext.data.BufferedStore</code>. This uses an enhanced paging mechanism to preload pages of data in advance. Meanwhile, the grid will automatically use <code class="literal">Ext.grid.plugin.BufferedRenderer</code> and as the user scrolls through the grid entries, the backing <code class="literal">BufferedStore</code> will automatically load in new pages of data while removing old pages. It does this seamlessly, so the user has no idea that the rows are being loaded from the server on the fly. The <code class="literal">BufferedRenderer</code> will also dispose of DOM nodes from old nodes as they scroll past, removing the memory burden of such a large amount of data.</p><p>All of these techniques have their place. They are also useful tools to be aware of at the start of the architecture process. If a client asks whether the application can handle 10,000 records in a datagrid, we now know that a buffered store can deliver the goods. On the flipside, we need to be conscious of premature optimization; there's no point implementing a buffered store when we're only dealing with a handful of records.</p></div></div>
<div class="section" title="Analyzing performance"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec121"/>Analyzing performance</h1></div></div></div><p>Dealing<a id="id643" class="indexterm"/> with performance issues is initially a problem of intelligence gathering. There can be multiple reasons why an application feels slow, and the feedback of users often doesn't help. Describing a part of the app as "sticky" just isn't a great way to diagnose the root cause. We need to get firm facts and figures in front of us before we can hope to find a solution. While we'll look at metrics such as rendering and response times, there are many considerations that must be taken into account, such as memory usage and user perception. These topics are left as an exercise for the reader.</p><p>The Chrome Developer Tools come to the rescue again. This time, we'll look at two main features that help diagnose performance problems: profiles and the timeline.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note22"/>Note</h3><p>In general, there are two situations in which Ext JS applications feel slow: poor design decisions and over-complicated apps. Having said that, these techniques are invaluable when the problem does crop up and are applicable to any JavaScript technology.</p></div></div><p>The profiler can be found by bringing up the Developer Tools and selecting the <span class="strong"><strong>Profiles</strong></span> tab:</p><div class="mediaobject"><img src="graphics/5308OT_10_12.jpg" alt="Analyzing performance"/></div><p>While there are several types of profiles that can be issued, we'll take a look at the CPU profile. In the preceding screenshot, we'd click on <span class="strong"><strong>Start</strong></span> to immediately begin profiling. Here's a look at what happens when you click on a product in Alcohology:</p><div class="mediaobject"><img src="graphics/5308OT_10_13.jpg" alt="Analyzing performance"/></div><p>The grid <a id="id644" class="indexterm"/>is ordered with the most time-consuming function calls at the top and each line can be expanded so that we can see the functions that were called in turn. The <span class="strong"><strong>Self</strong></span> column shows the percentage of time spent in just that function's body; the <span class="strong"><strong>Total</strong></span> column shows the time spent in that function as well as all of the functions it called.</p><p>While this part of the Alcohology application is performing just fine, this simple view of the heavily-used parts of code is a key avenue to diagnose serious performance problems. However, we can do more.</p><p>We've used Chrome Developer Tools to evaluate the performance of remote requests and now we've used them to track down hotspots in our code. What about a single view that could help us track the general behavior of our application and help us visualize the types of interactions that are slowing things down? This is exactly what the <span class="strong"><strong>Timeline</strong></span> tab offers.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note23"/>Note</h3><p>This is a whistle-stop tour of <a id="id645" class="indexterm"/>
<span class="strong"><strong>Timeline</strong></span>. Refer to <a class="ulink" href="https://developer.chrome.com/devtools/docs/timeline">https://developer.chrome.com/devtools/docs/timeline</a> for more details and full documentation.</p></div></div><p>By selecting the <span class="strong"><strong>Timeline</strong></span> tab and clicking on the <span class="strong"><strong>Record</strong></span> button, Chrome immediately begins recording every event currently taking place on the page. Clicking on <span class="strong"><strong>Record</strong></span> again allows you to analyze the results:</p><div class="mediaobject"><img src="graphics/5308OT_10_14.jpg" alt="Analyzing performance"/></div><p>Timeline allows<a id="id646" class="indexterm"/> you to filter down a timeframe of events and view each in turn, from user clicks to Ajax requests to URL changes and browser repaints. From the first event, we can trace down each subsequent event, viewing stack traces, detailed timings and warnings regarding problematic behavior.</p><p>Timeline is a powerful tool and you will need time and experience to use it to the fullest. It's time well spent; it can reveal clues that would be difficult or impossible to discover any other way. These clues can help resolve problems that would otherwise take days to tackle.</p></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch10lvl1sec122"/>Summary</h1></div></div></div><p>This chapter has given us a number of angles to approach two of the most important parts of building a successful application: fixing issues and adding polish. While explicit customer requirements form the main body of our work, we should always strive to make sure that our projects are performant and as bug-free as possible.</p><p>The Chrome Developer Tools are an invaluable weapon in our arsenal. By opening a window in the otherwise dark world of debugging and performance, we can take educated steps to quickly resolve issues. Stepping through our own code and that of the Ext JS framework becomes significantly easier with the power of breakpoints and the call stack explorer.</p><p>In the next chapter, we'll take our final step to building a well-rounded and robust application. While we are constantly working to build the best architecture we can, automated testing can provide a level of reassurance that takes the solidity of our work to the next level.</p><p>Code changes and refactoring can be done with confidence when our test suite can tell us if we've broken something with our latest amendments. Integration tests can provide assurances that our final application meets customer requirements and unit tests can encourage separation of code and ensure that our business logic is sound.</p><p>In the next chapter, we'll look into a variety of ways to implement these ideas and more.</p></div></body></html>