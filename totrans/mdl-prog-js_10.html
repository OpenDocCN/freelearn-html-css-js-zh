<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Enterprise Grade Modular Design, AMD, CommonJS, and ES6 Modules</h1></div></div></div><p>In this last chapter of the book, we are going to mainly focus on re-factoring some of our application modules so we can have a more robust way of loading and managing them.</p><p>The title of this chapter mentions Enterprise Grade, but in fact we can use the principles discussed here for applications of any size and type. In the next sections, I'll introduce you to various approaches for creating and loading modules in JavaScript and talk about the environments that each approach might be better suited for. You'll also see how we can manage our module dependencies in a more structured manner.</p><p>Keep in mind that this chapter is meant to be only an introduction to such techniques, but hopefully it will make you curious enough to research them further.</p><p>I believe after seeing their benefits, you'll consider these modular design implementations in your future projects.</p><p>Some of the topics that we will cover in this chapter are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Why we need a better setup for loading our modules</li><li class="listitem" style="list-style-type: disc">AMD module format and how to use it</li><li class="listitem" style="list-style-type: disc">Tools for creating AMD modules</li><li class="listitem" style="list-style-type: disc">CommonJS module format</li><li class="listitem" style="list-style-type: disc">ECMAScript 6 modules</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec53"/>Revisiting index.html file</h1></div></div></div><p>If you recall, in <a class="link" href="ch08.html" title="Chapter 8. Application Implementation – Putting It All Together">Chapter 8</a>, <em>Application Implementation – Putting It All Together</em>, I mentioned that we<a id="id563" class="indexterm"/> were using quite a few <code class="literal">&lt;script&gt;</code> tags in<a id="id564" class="indexterm"/> our <code class="literal">index.html</code> file to load our application's<a id="id565" class="indexterm"/> modules.</p><p>To refresh your memory, here is what we had:</p><div><img src="img/B04910_10_01.jpg" alt="Revisiting index.html file"/></div><p>While this implementation worked, it was not very scalable, since for each module file we needed to add a <code class="literal">&lt;script&gt;</code> tag to our page. Also, by looking at the list of files being loaded, we could not determine how each module or component was dependent on another piece (or pieces) of the application.</p><p>We had to create another <code class="literal">&lt;script&gt;</code> tag at the bottom of the page as well, which took care of booting-up the application, as shown here:</p><div><img src="img/B04910_10_02.jpg" alt="Revisiting index.html file"/></div><p>It would be nice if we could eliminate the need for having all the <code class="literal">&lt;script&gt;</code> tags and our boot-up sequence in <code class="literal">index.html</code>. Also, it would be very useful to implement a mechanism which could indicate and mange our modules' dependencies.</p><p>Well, we are going to <a id="id566" class="indexterm"/>achieve all that very soon!</p><p>The following screenshot depicts how the new approach will clean up our <code class="literal">index.html</code> file and provide us with a more robust script-loading capability:</p><div><img src="img/B04910_10_03.jpg" alt="Revisiting index.html file"/></div><p>As you can see, the page has been shortened considerably and there is only one JavaScript file that is loaded in <code class="literal">index.html</code> now. This file is <code class="literal">require.js</code>, with its data-main attribute set to <code class="literal">js/config</code>, as shown here:</p><div><pre class="programlisting">&lt;script  src="img/require.js" data-main="js/config"&gt;&lt;/script&gt;</pre></div><p>Loading this script is all we need to do in order to load all of our modules and components, and to start up the application.</p><p>We will have a look at how<a id="id567" class="indexterm"/> this magic has taken place shortly, but before<a id="id568" class="indexterm"/> doing so, we need to talk about <strong>AMD</strong> modules.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec54"/>Introducing Asynchronous Module Definition</h1></div></div></div><p>
<strong>Asynchronous Module Definition</strong> (<strong>AMD</strong>) format for creating modules in JavaScript, is targeted for use in browsers. This format proposes a particular way for defining modules so that modules and their dependencies can be loaded into the browser asynchronously.</p><p>There are two key methods<a id="id569" class="indexterm"/> that you need to use when creating and consuming AMD modules, these are <code class="literal">define</code> and <code class="literal">require</code> methods.</p><p>The idea is that we create a module using the global <code class="literal">define</code> method and then we can import that module in other parts of the code (other modules) using the global <code class="literal">require</code> method.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec78"/>Defining modules using AMD format</h2></div></div></div><p>Here is how a <a id="id570" class="indexterm"/>module can be defined in AMD format:</p><div><pre class="programlisting">define('moduleOneId', ['dependency'], function(dependency) {

    return {
        sayHi: function(){
            console.log('Hi there!')
        }
    }
});</pre></div><p>In the preceding <a id="id571" class="indexterm"/>code, we are passing three arguments to the global <code class="literal">define</code> method, which has been provided to us by an AMD-compatible module loader.</p><p>The first argument, <code class="literal">moduleOneId</code>, is an optional parameter which assigns an ID to the module. Most of the time, we do not use this argument and other than some edge cases or when a non-AMD concatenation tool is being used to bundle our code, we leave it empty.</p><p>The second argument to <code class="literal">define</code> function is an array of dependencies, which tells the AMD module loader what modules (files) need to be loaded before executing the callback function. Of course, the third argument passed to <code class="literal">define</code> method is the callback function.</p><p>Notice that we are<a id="id572" class="indexterm"/> returning an object from this callback function. This<a id="id573" class="indexterm"/> object is the module that we are defining. In AMD format, the callback function can also return constructors and functions.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec79"/>Importing AMD modules</h2></div></div></div><p>To use the module that we<a id="id574" class="indexterm"/> have defined in the preceding code, we can import it by using the global <code class="literal">require</code> function.</p><p>Consider the following:</p><div><pre class="programlisting">require(['moduleOneId'], function(moduleOne){
    moduleOne.sayHi();
});</pre></div><p>Here, we are asking the AMD module loader to load the dependency <code class="literal">moduleOneId</code> before executing the callback function.</p><p>Note that we could also use the path to our dependency instead of using the related ID. For instance, we could write the preceding code snippet as follows:</p><div><pre class="programlisting">require(['folderPath/moduleOne.js'], function(moduleOne){
    moduleOne.sayHi();
});</pre></div><p>AMD format provides great flexibility in defining and loading our modules. It also eliminates the need for creating global variables to define the modules. AMD-compatible script loaders also often provide the capability to lazy-load our modules, if needed.</p><p>There are many web development tools (libraries) that support AMD format, but the most popular ones are <code class="literal">RequireJS</code> and <code class="literal">curl.js</code>.</p><p>In our application in this chapter, we will be using <code class="literal">RequireJS</code> to create our AMD modules and load their dependencies.</p><div><div><h3 class="title"><a id="note31"/>Note</h3><p>For an in-depth<a id="id575" class="indexterm"/> discussion on JavaScript modules and their related formats, I encourage you to visit a great post by <em>Addy Osmani</em> at <a class="ulink" href="https://addyosmani.com/writing-modular-js/">https://addyosmani.com/writing-modular-js/</a>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec80"/>Introducing RequireJS</h2></div></div></div><p>As mentioned previously, one of the most popular AMD module loaders for the browsers is <strong>RequireJS</strong>. In this section, we will learn how to create and load modules using this tool.</p><p>You can also run RequireJS on the<a id="id576" class="indexterm"/> server side using its related optimizer, <code class="literal">r.js</code>. The optimizer can package all of our AMD modules into one file and then the browser will only have to make one request to the server to load all the necessary modules. In this scenario, AMD format is used to manage dependencies among modules when they are being bundled on the server.</p><p>Alternatively, if you are using a server build setup for your client files, you may want to consider using <code class="literal">almond.js</code> for packaging your AMD modules. This is a much smaller library, but does not have<a id="id577" class="indexterm"/> the dynamic loading capabilities of RequireJS. For more information regarding <code class="literal">almond.js</code>, visit the following URL: <a class="ulink" href="https://github.com/requirejs/almond/">https://github.com/requirejs/almond/</a>.</p><p>Since we are not using a build system for our project, I will only cover using <code class="literal">RequireJS</code> for the browsers in this chapter.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec52"/>Downloading RequireJS</h3></div></div></div><p>We can download<a id="id578" class="indexterm"/> this library from the following location: <a class="ulink" href="http://requirejs.org/docs/download.html#requirejs">http://requirejs.org/docs/download.html#requirejs</a>.</p><p>You can simple copy the<a id="id579" class="indexterm"/> minimized version of the tool and save it in your selected file location.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec81"/>A test project for creating and loading AMD modules</h2></div></div></div><p>To help you become more familiar with RequireJS, I have included an additional project called <strong>requireJsLearning</strong> in the source code related to this chapter. I encourage<a id="id580" class="indexterm"/> you to download this project and follow along as we continue our talk regarding AMD and RequireJS.</p><p>In <code class="literal">requireJsLearning</code> project, I have saved the RequireJS library (<code class="literal">require.js</code>) in the <code class="literal">libs</code> folder, as shown here:</p><div><img src="img/B04910_10_04.jpg" alt="A test project for creating and loading AMD modules"/></div><p>Let's create some simple modules in this project and see how we <a id="id581" class="indexterm"/>can use RequireJS to load and manage them.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec53"/>Creating a simple AMD module</h3></div></div></div><p>We start by creating a<a id="id582" class="indexterm"/> simple AMD module in <code class="literal">person.js</code> file, under <code class="literal">modules</code> folder.</p><p>Consider the following:</p><div><pre class="programlisting">define(['modules/stuff', 'jquery'], function(stuff, jq) {
    console.log(jq + "  --&gt; Accessing jQuery from person");
    return {
        first: "Sam",
        last: "SamLastName",
        favorites: stuff.likes.join(' ')
    }
});</pre></div><p>In the preceding code, we are using the global <code class="literal">define</code> method that RequireJS has provided for us and passing two parameters to it. The first parameter is an array with two values. The first value in this array is a path to another module, which is a dependency for our <code class="literal">person</code> module.</p><p>Notice that we are using the name of the file but without the <code class="literal">.js</code> extension. This is because RequireJS assumes the extension to be <code class="literal">.js</code> by default.</p><p>The second value in our dependency array is <strong>jQuery</strong>. We are not specifying a path for jQuery here, as it is being used as a global variable.</p><div><div><h3 class="title"><a id="note32"/>Note</h3><p>
<strong>jQuery and AMD format</strong>
</p><p>As of version 1.7, jQuery supports AMD format. However, for it to be loaded properly as an <a id="id583" class="indexterm"/>AMD module, we can only place it in the same location as our <code class="literal">config.js</code> file. Since we would like to have all of our third-party libraries under <code class="literal">libs</code> folder in our project, we need to do a little bit of configuration. We will talk about this shortly.</p></div></div><p>The second parameter passed to <code class="literal">define</code> method is the callback function that gets executed after our <code class="literal">person</code> module's dependencies are loaded.</p><p>As the preceding code <a id="id584" class="indexterm"/>shows, this callback function receives two parameters, which are matched one-to-one to the dependency list defined for the <code class="literal">person</code> module.</p><p>We also return an object from this callback function which is our <code class="literal">person</code> module that can be consumed by other modules.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec54"/>Consuming our person AMD module</h3></div></div></div><p>Since <code class="literal">person</code> module is<a id="id585" class="indexterm"/> created as an AMD module, we can consume it as a dependency in other modules by only specifying its path.</p><p>Have a look at how our <code class="literal">main</code> module (in <code class="literal">main.js</code>) requires and uses <code class="literal">person</code> module, as shown in the following:</p><div><pre class="programlisting">// bootstrap file
require(['modules/person', 'jquery', 'person2'], function(person, $$, person2){
    
    console.log("Accessing Person --&gt; person first + person last; from main -&gt; " + person.first + ' ' + person.last);	
    console.log($$ + "  --&gt; jquery from main");	
    console.log("Accessing person2 --&gt; person2.first ; from main -&gt; " + person2.first)
});</pre></div><p>The preceding syntax should be a lot more familiar to you now. We are telling RequireJS (using <code class="literal">require</code> method) to load all the dependencies listed in the dependency array (the first argument to <code class="literal">require</code> method) and then pass them as arguments to the callback function.</p><p>RequireJS in turn, will make asynchronous calls to the server (one call per module) to download all of the dependencies.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec55"/>Loading dependencies of dependencies</h3></div></div></div><p>Notice that our <code class="literal">main</code> module<a id="id586" class="indexterm"/> has listed <code class="literal">person</code> module as a dependency. However, <code class="literal">person</code> module itself has also listed <code class="literal">stuff</code> module as a dependency:</p><div><pre class="programlisting">define(['modules/stuff', 'jquery'], function(stuff, jq) {
...
}</pre></div><p>Therefore, there is a dependency chain that needs to be resolved. When RequireJS looks for the dependency list of <code class="literal">main</code> module and sees <code class="literal">person</code> as a dependency, it then looks to see if <code class="literal">person</code> has any dependencies itself. If so, it will load those dependencies first. After that <code class="literal">person</code> module is loaded and passed to <code class="literal">main</code> module.</p><p>We can think of this chain as follows:</p><p>Load <code class="literal">stuff</code> module | pass it to <code class="literal">person</code> module | load <code class="literal">person</code> module | then pass <code class="literal">person</code> module to <code class="literal">main</code> module.</p><p>This is a very simplified view of how RequireJS manages dependencies and loads modules in the correct order, based on the dependency list.</p><div><div><h3 class="title"><a id="note33"/>Note</h3><p>
<strong>A small but important point</strong>
</p><p>In the preceding explanation, I mentioned the order of how modules get loaded based on the dependency list. The fact is that these modules can be physically loaded in a different order, but the important point to keep in mind is that all of the modules listed in the dependency list are loaded and the code in them is executed <em>before</em> the <code class="literal">callback</code> function is called.</p></div></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec56"/>Loading and consuming non-AMD modules</h3></div></div></div><p>We also need a way to<a id="id587" class="indexterm"/> load non-AMD modules or non-modular files in <a id="id588" class="indexterm"/>our projects, and RequireJS provides hooks to do just that.</p><p>It also has many plugins which enable us to load CSS and text files, as well as providing many other capabilities.</p><p>In our <strong>requireJsLearning</strong> project, we have three modules (files) which are not using AMD module format. These are <code class="literal">person2</code>, <code class="literal">person3</code>, and <code class="literal">person4</code>. In order for RequireJS to load such modules and make them available for usage by other modules, we need to provide some<a id="id589" class="indexterm"/> configuration settings.</p><p>If you look at <code class="literal">config.js</code> file in our project, you see the following code:</p><div><pre class="programlisting">require.config({
    deps: ['main'],
    paths: {
    //'jquery' : 'libs/jquery'// if loading from local directory
        'person2': 'modules/person2', // location to none AMD modules
        'person3': 'modules/person3',
        'person4': 'modules/person4',
        'jquery': "https://code.jquery.com/jquery-1.12.3.min" // loading from CDN
    },
    shim: {
        "person2": {
            "exports": "person2"
                // use this alias in the global scope and pass it to modules as dependency
        },
        "person3": {
            deps: ['person4'],
            // none AMD module, depending on another non AMD module
            "exports": "person3"
        }
    }
});</pre></div><p>Here, we are passing a configuration object to <code class="literal">require.config</code> method of RequireJS. The first <a id="id590" class="indexterm"/>property of this object defines <code class="literal">main</code> as a dependency (<code class="literal">deps: ['main']</code>). Remember that <code class="literal">main</code> module is the module that boots up our application, but in <code class="literal">index.html</code> file, we told RequireJS to load <code class="literal">config.js</code> using <code class="literal">data-main</code> attribute, as shown here:</p><div><pre class="programlisting">&lt;script  src="img/require.js" data-main="js/config"&gt;&lt;/script&gt;</pre></div><p>When RequireJS loads <code class="literal">config.js</code> file, the configuration object is passed to <code class="literal">require.config</code> method. Then, RequireJS figures out that it needs to load <code class="literal">main.js</code> (by looking at the <code class="literal">deps: ['main']</code> property on this object). Of course, in turn, by looking at the dependency list of <code class="literal">main</code> module, RequireJS loads all the dependencies for <code class="literal">main</code> module as well.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec57"/>Setting paths in the config object</h3></div></div></div><p>The next property<a id="id591" class="indexterm"/> set in the configuration object passed to <code class="literal">require.config</code> method is <code class="literal">paths</code> property. This property itself is an object and it's where we define the paths to our dependencies. For instance, see the following snippet:</p><div><pre class="programlisting">'person2': 'modules/person2'</pre></div><p>Here we tell RequireJS that, when it needs to load <code class="literal">person2</code>, it can find it in the <code class="literal">modules/person2.js</code> file. Remember that we do not provide the file extension for the file in this property.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec58"/>Creating shims for non-AMD modules</h3></div></div></div><p>The next property that we<a id="id592" class="indexterm"/> define in object passed to <code class="literal">require.config</code> method is <code class="literal">shim</code> property.</p><p>
<code class="literal">shim</code> property is an object too and is used to provide configuration settings for non-AMD modules.</p><p>For instance, see how we are configuring <code class="literal">person3</code> module in the following code snippet:</p><div><pre class="programlisting">"person3": {
            deps: ['person4'],
            // none AMD module, depending on another non AMD module
            "exports": "person3"
}</pre></div><p>We tell RequireJS that, when you want to load <code class="literal">person3</code> module as a dependency, first you need to load <code class="literal">person4</code> (using <code class="literal">deps</code> property), and then let the consuming modules declare this module as a dependency using the keyword <code class="literal">person3</code>.</p><p>Consider how <code class="literal">stuff</code> module declares and consumes <code class="literal">person3</code> as a dependency in the following code snippet:</p><div><pre class="programlisting">define(['person3'], function(person3) {
    console.log(person3.first +
        "  --&gt; Accessing person3.first from stuff");
    return {
        likes: ['Car', 'Bike', 'Scooter']
    };
});</pre></div><p>In this way, we can load and consume non-AMD modules asynchronously, thanks to RequireJS.</p><p>To confirm that <a id="id593" class="indexterm"/>everything is working as it should and all the dependencies are resolved properly, we can load <code class="literal">index.html</code> in the browser. We should then see the following messages in the debugger tools console (I'm using Chrome browser):</p><div><img src="img/B04910_10_05.jpg" alt="Creating shims for non-AMD modules"/></div><p>I encourage you to have a look at the code related to this project (<code class="literal">requireJsLearning</code>) and use it to see how you can create, load, and consume modules using RequireJS.</p><p>For more in-depth<a id="id594" class="indexterm"/> information regarding this great library and the many different options that it provides, please visit <a class="ulink" href="http://requirejs.org/">http://requirejs.org/</a>.</p><p>I hope this was a good introduction to AMD module format and RequireJS. Let's now use what we have learned from this section and re-factor our main application to load our modules the AMD way.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec82"/>Refactoring Images Inc. application to use AMD format</h2></div></div></div><p>To leverage the<a id="id595" class="indexterm"/> functionality that RequireJS provides for us, we are going to take two different approaches here. First, we are going to convert all of the submodules in the Core module into AMD modules. </p><p>Second, we are going to load all of our other files in the application, including our application's components, as non-AMD modules. These two approaches will provide us with a practical exercise to put our knowledge of RequireJS and AMD modules to good use.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec59"/>Modifying Core submodules into AMD modules</h3></div></div></div><p>In this section, we are <a id="id596" class="indexterm"/>going to look at <code class="literal">ImagesInc_Core.LoggingHandler</code> submodule and see how we can convert it into an AMD module. All the other submodules in the application can also be converted to AMD modules, following the same approach.</p><p>Consider how <code class="literal">ImagesInc_Core.LoggingHandler</code> submodule is implemented in our application:</p><div><pre class="programlisting">ImagesInc_Core.LoggingHandler = (function(){
...

return {
        
        logMessage: self.logMessage,
        initialize: self.initialize
    };
})();</pre></div><p>We were using an IIFE to return an object as a property on <code class="literal">ImagesInc_Core</code> global object (which is<a id="id597" class="indexterm"/> our MainCore module). This returned object is the interface to the code inside of our IIFE namespace.</p><p>To convert this submodule to an AMD module, we simply need to transfer the code which was originally inside the IIFE to <code class="literal">define</code> method provided to us by RequireJS.</p><p>Consider the following code snippet:</p><div><pre class="programlisting">define(['MainCore'], function(ImagesInc_Core){
...
    return ImagesInc_Core.LoggingHandler = {
        
        logMessage: self.logMessage,
        initialize: self.initialize
    }
}</pre></div><p>Notice that we are still returning an object from the callback function and we are also assigning it to <code class="literal">LoggingHandler</code> property of <code class="literal">ImagesInc_Core</code> object.</p><p>This approach allows us to easily convert our non-AMD submodules into AMD modules, with very little modification. This is mostly because, from the beginning, our architecture was designed to be a modular-based architecture. Now, thanks to RequireJS, we are able to load our submodule files asynchronously, without the need to add them as <code class="literal">&lt;script&gt;</code> tags to our <code class="literal">index.html</code> file.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec60"/>Loading our non-AMD modules using RequireJS</h3></div></div></div><p>We are going to load the<a id="id598" class="indexterm"/> rest of the files in our application, including <a id="id599" class="indexterm"/>MainCore, as non-AMD modules.</p><p>You may decide later on that you would like to convert these modules into AMD modules as well. I encourage you to do so, as it will be a valuable exercise. However, my goal here<a id="id600" class="indexterm"/> is to show you how AMD and non-AMD modules can work together in harmony, without much trouble at all.</p><p>As explained previously, to load non-AMD modules using RequireJS, we need to define them in <code class="literal">shim</code> property of our application's <code class="literal">config</code> file.</p><p>Remember that we load <code class="literal">config.js</code> file in our <code class="literal">index.html</code>, as shown here:</p><div><pre class="programlisting">&lt;script src="img/require.js" data-main="js/config"&gt;&lt;/script&gt;</pre></div><p>
<code class="literal">config.js</code> file in turn will cause the loading of our <code class="literal">main.js</code> file (as it has been defined as a dependency for <code class="literal">config.js</code> file), which does the bootstrapping of our application.</p><p>It is time for us to have a closer look at our application's <code class="literal">config.js</code> file.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec61"/>Setting up our application's config.js file</h3></div></div></div><p>Our application's <code class="literal">config.js</code> file consists of three main properties; <code class="literal">deps</code> property, which defines the<a id="id601" class="indexterm"/> dependencies of <code class="literal">config</code> file; <code class="literal">paths</code> property, which maps all of our dependencies to their physical file locations, and <code class="literal">shim</code> property, which is used to define the non-AMD modules in our application.</p><p>Have a look at <code class="literal">config</code> file, in the code snippet below:</p><div><pre class="programlisting">require.config({
    deps: ['main'],
    paths:{
        'MainCore' : 'Modules/Core/MainCore',
        'Logger': 'Modules/Core/Logger',
        'AjaxEngine': 'Modules/Core/AjaxEngine',
        'CookieHandler': 'Modules/Core/CookieHandler',
        'NotificationHandler': 'Modules/Core/NotificationHandler',
        'StorageHandler': 'Modules/Core/StorageHandler',
        'Utilities': 'Modules/Core/Utilities',
        'SandBox' : 'Modules/SandBox/SandBox',
        'ImagesInc_Content': 'Components/ImagesInc_Content',
        'ImagesInc_Footer': 'Components/ImagesInc_Footer',
        'ImagesInc_Header': 'Components/ImagesInc_Header',
        'AppTester': 'Modules/AppTester/AppTester',
        'CookieHandlerTester': 'Modules/AppTester/CookieHandlerTester',
        'StorageHandlerTester': 'Modules/AppTester/StorageHandlerTester',
        'Base': 'Modules/Base/Base',
        'jquery': 'Modules/Base/jquery-1.10.2.min',
        'GlobalData_Sub': 'Modules/GlobalData/GlobalData_Sub',
        'GlobalData': 'Modules/GlobalData/GlobalData'	
    },
    
    shim:{
        
        'Base':{
            exports : 'Base'
        },
        
        'jquery':{
            exports : 'jquery' 

        },
...

});</pre></div><p>I think by now you<a id="id602" class="indexterm"/> are quite familiar with the types of configuration items that we set for our application in this file. Based on this configuration, RequireJS can now load our modules and files, asynchronously and in the correct order.</p><p>This implementation allows us to have a well-organized, maintainable, and scalable solution to loading our modules, without the need to list them all in our <code class="literal">index.html</code> file.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec62"/>Booting up our application using RequireJS</h3></div></div></div><p>Our <code class="literal">main</code> module is the<a id="id603" class="indexterm"/> module responsible for<a id="id604" class="indexterm"/> booting up our application.</p><p>Have a look at the following code snippet and see how this module is implemented:</p><div><pre class="programlisting">// Application bootstrap file
var modulesToLoad = ['MainCore','Logger','AjaxEngine', 'CookieHandler', 'NotificationHandler', 'StorageHandler','Utilities','ImagesInc_Content','ImagesInc_Footer', 'ImagesInc_Header','SandBox', 'AppTester', 'CookieHandlerTester',
  'StorageHandlerTester', 'Base', 'jquery', 'GlobalData_Sub', 'GlobalData'];

require(modulesToLoad, function(ImagesInc_Core, Logger,AjaxEngine, CookieHandler, NotificationHandler, StorageHandler, Utilities, ImagesInc_Content, ImagesInc_Footer, ImagesInc_Header, SandBox, Base, jquery, GlobalData_Sub, GlobalData){
    //register StorageHandler with MainCore
    ImagesInc_Core.StorageHandler.register = (function(){
    ImagesInc_Core.registerModule(ImagesInc_Core.StorageHandler);      
    })();

    //add error handling to all methods of StorageHandler, in case localStorage not available
    if(ImagesInc_Core.Utilitizes){
    ImagesInc_Core.Utilitizes.addLocalStorageCheck(ImagesInc_Core.StorageHandler);
    }
    ImagesInc_Core.initializeAllModules();
    ImagesInc_Core.initializeAllComponents();
    ImagesInc_Core.handlePageChange(location.pathname);
});</pre></div><p>As you can see, we have<a id="id605" class="indexterm"/> listed all of our application's dependencies in an array. Then, we have used <code class="literal">require</code> method to load them all and pass them to the callback function.</p><p>Inside this <a id="id606" class="indexterm"/>callback function, we execute the code necessary to get the application started up.</p><p>If you look at the <strong>Network</strong> tab of your browser's debugger tool (I use Chrome), you will see how RequireJS has loaded the necessary modules and files for our application, as shown in the following screenshot:</p><div><img src="img/B04910_10_06.jpg" alt="Booting up our application using RequireJS"/></div><p>As you can see, modular architecture can help us greatly to manage our<a id="id607" class="indexterm"/> application pieces and their related <a id="id608" class="indexterm"/>dependencies with ease. I recommend that you spend some time exploring how to leverage the full functionality of AMD modules in your own applications.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec55"/>CommonJS</h1></div></div></div><p>As with AMD format, CommonJS (also known as CJS) is another format which defines JavaScript modules as objects that <a id="id609" class="indexterm"/>can be made available to any dependent code. CJS modules can only define objects, as opposed to AMD modules, which can define constructors and functions too.</p><p>Unlike AMD format, which takes a browser-first approach, CommonJS takes a server-first approach. It also covers a broader set of concerns which are server-related, such as io, file system, and alike.</p><p>Many developers (I'm one of them) use AMD format for browser-targeted modules and CommonJS for server-side targeted modules. However, you could use CJS format for browser modules as well.</p><p>Some <a id="id610" class="indexterm"/>of the tools that support<a id="id611" class="indexterm"/> CJS for the browsers are:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>curl.js</strong>: <a class="ulink" href="http://github.com/unscriptable/curl">http://github.com/unscriptable/curl</a></li><li class="listitem" style="list-style-type: disc"><strong>SproutCore</strong>: <a class="ulink" href="http://sproutcore.com">http://sproutcore.com</a></li></ul></div><p>Let's have a<a id="id612" class="indexterm"/> look at a simple <a id="id613" class="indexterm"/>example to see how we can implement a CJS format module.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec83"/>Implementing a CommonJS module</h2></div></div></div><p>Imagine that we <a id="id614" class="indexterm"/>have a file called <code class="literal">moduleOne.js</code>. From inside this file, we can export a CJS module like so:</p><div><pre class="programlisting">exports.someFunc = function(){
    
    return console.log("I am some function");
}</pre></div><p>Here, <code class="literal">exports</code> is a global variable and contains the object which the module is making available to other modules that wish to consume it.</p><p>On the other hand, imagine that we have another module in <code class="literal">moduleTwo.js</code> file, which resides in the same directory as <code class="literal">moduleOne.js</code>.</p><p>
<code class="literal">moduleTwo</code> can import <code class="literal">moduleOne</code> and consume it like so:</p><div><pre class="programlisting">var firstModule = require('./moduleOne');
firstModule.someFunc();

exports.someApp = function(){
    return firstModule.someFunc();
}
exports.someOtherApp = function(){
    return console.log("I am some other app");
}</pre></div><p>As you can see, in this module we use CJS <code class="literal">require</code> method to import the first module (<code class="literal">someFunc</code>), and then we can use it as <code class="literal">firstModule.someFunc()</code>.</p><p>In <code class="literal">moduleTwo.js</code>, we are also exporting another module called <code class="literal">someApp</code>, which can be consumed by other modules in the application. Note that in the preceding example, we are in fact exporting more than one module from the same file.</p><p>Notice also that there is no <code class="literal">define</code> method to wrap our modules and return an object from the callback function, as opposed to what we saw in AMD format.</p><p>CJS syntax is similar to how ECMAScript 6 defines modules, and we will have a look at that in the next section.</p><p>For more information<a id="id615" class="indexterm"/> regarding CJS modules, please refer to the following resource online: <a class="ulink" href="http://www.commonjs.org/">http://www.commonjs.org/</a>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec56"/>ECMAScript 6 modules</h1></div></div></div><p>In the new version of <a id="id616" class="indexterm"/>JavaScript, <strong>ECMAScript 6</strong> (also known as <strong>ES6</strong>), native modules have been introduced. The<a id="id617" class="indexterm"/> following points are some of the most important aspects of these modules:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Module code always automatically runs in strict mode</li><li class="listitem" style="list-style-type: disc">Variables that are<a id="id618" class="indexterm"/> created in the top level of a module are not added to the global scope</li><li class="listitem" style="list-style-type: disc">A module must export anything that should be available to the outside code</li><li class="listitem" style="list-style-type: disc">A module can import bindings (things that are exported from other modules)</li></ul></div><p>The main idea behind modules in ES6 is to give you complete control over what is accessible to the outside code from inside the module, as well as when the code inside of the module is executed.</p><p>Let's have a look at a simple example of an ES6 module.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec84"/>Defining an ES6 module</h2></div></div></div><p>We can define an ES6<a id="id619" class="indexterm"/> module either inside of a <code class="literal">.js</code> file, or inside a <code class="literal">&lt;script&gt;</code> tag in our<code class="literal">.html</code> page.</p><p>Consider the following code snippet, from an imaginary <code class="literal">simpleModule.js</code> file:</p><div><pre class="programlisting">var name = "Tom";
// export function
export function sayHello(name) {
    alert("Hello " + name);
}
function sayName(){
	alert('My name is: ' + name);
}
function sayBye(name) {
    alert("Bye " + name);
}
export sayBye;</pre></div><p>In the preceding module, we have defined three functions as well as a module variable. Note that while the variable <code class="literal">name</code> is not inside of a function, its scope is still limited to the module. This means that no external code to the module can access it.</p><p>We have also used the keyword <code class="literal">export</code> to make two of our functions available to the potential consumers of the module. As you can see, we can use <code class="literal">export</code> either on the function declaration, as in the case of <code class="literal">sayHello</code> function, or as a reference, in the case of <code class="literal">sayBye</code> function.</p><p>To create a module as an embedded module in an <code class="literal">.html</code> file, we can use the following syntax:</p><div><pre class="programlisting">&lt;script type="module"&gt;
    var modulePrivateVar = 2
    alert("The value in the module is: " + modulePrivateVar);
&lt;/script&gt;</pre></div><p>Note that we have specified <code class="literal">type</code> of the script to be <code class="literal">module</code>, which causes the browser to treat the code inside the <code class="literal">&lt;script&gt;</code> tag as an ES6 module.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec85"/>Consuming an ES6 module</h2></div></div></div><p>When the external <a id="id620" class="indexterm"/>code to an ES6 module needs to have access to what has been exposed by the module, binding needs to be used.</p><p>Consider how we can get access to the two functions that were exposed by our first module, <code class="literal">simpleModule</code>, as shown here:</p><div><pre class="programlisting">import { sayHello, sayBye } from "simpleModule.js";	
sayHello();
sayBye();
sayName(); // error, sayName was not exported</pre></div><p>As shown, we need to use the keyword <code class="literal">import</code> to create binding between the external code to the module and the functions that the module exports.</p><p>Also, notice that since <code class="literal">sayName</code> was not exported by the module, we have no access to it.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec86"/>Module loading sequence in the browsers for ES6 modules</h2></div></div></div><p>ES6 modules in the browsers are<a id="id621" class="indexterm"/> always loaded as soon as the browsers encounter the following tag:</p><div><pre class="programlisting">&lt;script type="module" src="img/simpleModule.js"&gt;</pre></div><p>However, the code in the module is not executed until the document has been completely parsed.</p><p>Modules are also executed in the order in which they appear. This means that in our preceding examples, if we had listed our modules as:</p><div><pre class="programlisting">&lt;script type="module" src="img/simpleModule.js"&gt;
&lt;script type="module"&gt;
    var modulePrivateVar = 2	
    alert("The value in the module is: " + modulePrivateVar);
&lt;/script&gt;</pre></div><p>The code in <code class="literal">simpleModule.js</code> would be executed before the code for our embedded module would.</p><p>Since a module can also have its own dependencies, which it defines using the <code class="literal">import</code> statements (bindings), each module is parsed completely before its code is executed. This is so the dependencies can be resolved correctly.</p><p>This means, if the browser encounters an import statement in an already downloaded module, it will download the dependency first before executing the code in that module. This ensures that all the modules and their dependencies are loaded before any code-execution in the modules.</p><p>There is a lot <a id="id622" class="indexterm"/>more to ES6 modules than what we have covered here, as this was meant to be a very brief introduction. I encourage you to research the subject further on your own. There are many good resources <a id="id623" class="indexterm"/>online which you can refer to and I highly recommend the following sites for more information:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://leanpub.com/understandinges6">https://leanpub.com/understandinges6</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://hacks.mozilla.org/2015/08/es6-in-depth-modules/">https://hacks.mozilla.org/2015/08/es6-in-depth-modules/</a></li><li class="listitem" style="list-style-type: disc"><a class="ulink" href="https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import">https://developer.mozilla.org/en/docs/web/javascript/reference/statements/import</a></li></ul></div><div><div><h3 class="title"><a id="note34"/>Note</h3><p>
<strong>Final note regarding our Images Inc. application</strong>
</p><p>It is always a <a id="id624" class="indexterm"/>good idea to revisit and improve the quality of the code in our applications. As such, I have made some small modifications to the code-base related to this chapter. The latest project's code is a little more polished and linted. Also, I have made improvements to the visual responsiveness of the application in the browsers by making some changes to the related CSS files.</p><p>However, there are always things that can be improved further in any project and this application is no exception.</p><p>Nonetheless, I hope the <a id="id625" class="indexterm"/>application will provide a good starting point for your future projects.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec57"/>Summary</h1></div></div></div><p>As this was the last phase in the implementation of our application, in this chapter we discussed how we can improve the dependency management and loading of our modules in the browser.</p><p>By re-factoring our application's code, we converted our Core submodules to AMD modules and then used RequireJS to load all of our JavaScript files asynchronously from the server.</p><p>We saw how we can use RequireJS, which is mainly a script-loading library, to load our AMD and non-AMD modules.</p><p>We also covered different formats for defining modules in JavaScript and talked about AMD, CommonJS, and ES6 modules. Since this book is focused on using JavaScript in the browsers, we spent more time getting to know AMD modules, as they are better suited for this purpose. </p><p>In our overview of CommonJS and ES6 modules, we noted the similarities between the two formats and saw how ES6 modules can be used in our code.</p><p>I hope you have found this book informative and a good introduction to modular programming with JavaScript.</p><p>As always, there is a lot more to learn for all of us and I wish you great success in your future endeavors.</p></div></body></html>