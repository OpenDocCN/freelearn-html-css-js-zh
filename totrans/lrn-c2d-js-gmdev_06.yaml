- en: Chapter 6. Controlling the Game with Virtual Pads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the most important things to consider when making a cross-platform game
    is the way the player will control the main character. Most of the devices your
    game will be running on won't have a keyboard or a mouse, and although more and
    more portable devices now support pads, your game must also be playable without
    pads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, I will show you three of the most popular ways to create virtual
    pads on any device. Among other things, you will learn how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Scroll big images to give an idea of an endless background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control the frame rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check collision between sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple particle system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move sprites manually or using actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the first thing to do is take a look at how successful games allow players
    to interact with them using virtual pads.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of virtual pads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The oldest, simplest, and highly discouraged way to create virtual pads is placing
    directional buttons on the screen and controlling the character according to the
    button pressed by the player.
  prefs: []
  type: TYPE_NORMAL
- en: I also used this kind of virtual pad in the first version of my *Sokoban* game
    before I made the game playable with swipes, as I showed you during the creation
    of *Cocosban* game.
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of virtual pads](img/0075SOS_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Sokoban game
  prefs: []
  type: TYPE_NORMAL
- en: In this game, you move the character by clicking or tapping exactly on an arrow
    button. It can fit in a slow-paced puzzle game, but becomes unplayable in a fast-paced
    arcade.
  prefs: []
  type: TYPE_NORMAL
- en: That's why famous platform games such as *Mikey Shorts* use ghost buttons. Ghost
    buttons act like normal buttons, but the sensible area is way bigger than the
    icon itself.
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of virtual pads](img/0075SOS_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Although the buttons aren''t bigger than the ones used in my *Sokoban* game,
    the sensible area covers the entire screen: the actual red button sensible area
    is the whole column of the screen covering the red button icon, the blue button
    sensible area is the whole column of the screen covering the blue button icon,
    and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to handle virtual pads is by using the virtual analogic pad. Although,
    the way to control *Mikey Shorts* is digital, which means one button can only
    be pressed or released; sometimes, games require more precision in movements like
    the following screenshot of the *Grand Theft Auto* series:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of virtual pads](img/0075SOS_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: On the bottom left-hand side of the screen, you can see a virtual analogic pad.
    The pad is initially activated by touching the screen, then the further you drag
    the pad from its original position, the faster the character will walk or run.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to create virtual pads that I would like to mention is the one
    used in the *VVVVVV* game, which does not show any icon. A screenshot of the *VVVVVV*
    game is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of virtual pads](img/0075SOS_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'You simply move the character left and right by continuously dragging, or dragging
    and holding your finger on the device, and I have to say it works way better than
    the old virtual pad because you can virtually use any spot on the device to move.
    Above all, there isn''t any *origin* you have to cross to change direction: no
    matter how far you move your finger from the point you start touching, once you
    move the finger in the opposite direction, the character will walk in the other
    direction.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, apart from the first example, which I said is obsolete, you will see how
    to create all these ways to control your character with virtual pads.
  prefs: []
  type: TYPE_NORMAL
- en: First things first – the game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We are making a little game just to test our virtual pads: a landscape game
    with a shopping cart surrounded by falling bombs and strawberries trying to catch
    strawberries while avoiding bombs? Does it sound crazy? It is.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the content of our `assets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First things first – the game](img/0075SOS_06_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The making of the entire game is very similar to the making of the endless space
    runner, so there's no need to talk about code you should already know.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the content of `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Just look at the resolution policy to make the game work in landscape mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the content of `loadassets.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The content of `gamescript.js`, as said, is very similar to the content of the
    endless space runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s take a look at the final result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![First things first – the game](img/0075SOS_06_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We have a cart in the bottom center of the stage, and fruit and bombs falling
    every second with a random trajectory.
  prefs: []
  type: TYPE_NORMAL
- en: 'As I already told you, there''s nothing new! You should know everything you
    need to build this game. This is `gamescript.js`: first, you need two global variables
    to handle the cart itself and the layer that will be filled with fruit and bombs:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `gameScene` is then defined as usual:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The `game` class declaration contains the core of the game itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like it''s a lot of code, but there''s nothing new: we simply add
    a background gradient, then two layers: one for fruit and bombs and one for the
    cart, and finally, we add the cart itself. To create fruit and bombs, we use the
    `schedule` method, which calls the `addItem` function every second to create a
    new `Item` class instance, while the `removeItem` function will remove fruit and
    bombs once they fly off the screen.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is really similar to the creation of the space endless runner, and the
    same goes for the creation of fruit and bombs in the `Item` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, there''s a lot of code, but most of it is pure JavaScript and has nothing
    to do with Cocos2d-JS. Let''s take a look at it anyway:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'How can you decide whether the current item will be a fruit or a bomb? By simply
    drawing a random number, then according to its value, use the bomb or fruit image.
    The `isBomb` custom attribute will tell us whether it''s a bomb (`true`) or a
    fruit (`false`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When it's time to place it on the stage, we put it in a random horizontal position
    outside the top of the screen and create a tween to move it outside the bottom
    of the screen in a different random horizontal position. Pretty similar to the
    endless runner's asteroid movement.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The `update` function ,which is called at every frame, checks for three conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: If the item is a fruit and it's very close to the cart, then we remove the item
    and output some text to the console to have a debug message, which displays the
    player hit a fruit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the item is a bomb and it's close (not as close as required by the fruit),
    but close to the cart, then we remove the item and output some text to the console
    to get a debug message, which displays the player hit a bomb. This is a difficult
    game, because being hit by a bomb is easier than collecting a fruit.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If the item (no matter which kind of item) is outside the bottom of the stage,
    we need to remove it.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That's all for the game. Now, you need to let the player control the cart in
    the three ways mentioned before.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the cart with ghost buttons
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To control the cart with ghost buttons, first, you have to place the button
    on the screen, which, as said, will only act as a fake button because the entire
    left and right area of the stage will represent the actual button.
  prefs: []
  type: TYPE_NORMAL
- en: 'You need to add some global variables to the script to handle left and right
    buttons as well as the horizontal speed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The `xSpeed` variable represents the horizontal speed of the cart, while the
    `left` and `right` variables will be assigned to left and right arrow buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `init` function needs to place the buttons, set the `touch` listener,
    and schedule the update at each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'I would like you to check whether both left and right arrow buttons are placed
    on the `topLayer` and their opacity is set to half transparent. Also, look at
    the name of the listener variable we are going to create: `touchListener`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, this is the `touchListener` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'It''s a touch event like the ones we''ve met before. Let''s take a closer look
    at the triggered events:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: When the player touches the screen that deals with ghost buttons, we only need
    to check whether the left or right portion of the screen has been touched, set
    `xSpeed` accordingly as well as turn the speed to on or off, and set it at full
    or half opacity to the respective arrow buttons.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s very important that the function returns `true` if you want Cocos2d-JS
    to be able to check when the player stops touching the screen. To acheive this,
    add the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When the player stops touching the screen, `xSpeed` is set back to zero and
    both buttons are turned off.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you only have to move the cart in the `update` function of the `game`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: There's really no need to explain anything as you are only moving the cart by
    `xSpeed` pixels; just take a look at the `setFlippedX` method to flip the cart
    horizontally when it's going right.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the game and you will see what is shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the cart with ghost buttons](img/0075SOS_06_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Touch the screen anywhere to move the cart to the left or to the right according
    to the position of the screen you are touching. That's all about ghost buttons.
    Now, let's see how to control the game using the virtual pad.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the cart with a virtual pad
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing to do in order to control a game with a virtual pad is to have
    a virtual pad. So we need to change some images in our `assets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the cart with a virtual pad](img/0075SOS_06_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The left and right buttons have been removed to be replaced by virtual pad
    images, so `loadassets.js` changes this way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Obviously, most of the game remains the same because you are only changing
    the way you control the cart. You need to change the global variables a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: While game-related variables remain the same, I added two new variables called
    `touchOrigin` and `touchEnd`, which will handle virtual pad touches. Also, the
    variables used before to handle buttons have been removed. A Boolean variable
    called `touching` will tell us whether the player is touching the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the `init` function of the `game` class needs some changes too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Basically, all lines about the left and right button have been removed, but
    the core of the script is in the `touchListener` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The first thing I would like you to see is the three events:'
  prefs: []
  type: TYPE_NORMAL
- en: '`onTouchBegan`: This event places both virtual pad sprites in the touch location
    and sets the `touching` Boolean variable to `true`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onTouchMoved`: This event updates the `touchEnd` sprite to the current touch
    position. As the name suggests, this event is triggered when the player moves
    their finger around the screen.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`onTouchEnded`: This event removes both virtual pad sprites and sets the `touching`
    Boolean variable to `false`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It''s easy to guess how I am moving the cart in the `update` function of the
    `game` class. If the `touching` variable is `true`, the cart speed is the difference
    between the `touchEnd` and `touchOrigin` functions'' *x* coordinates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Being an analogic pad, the greater the difference between the `touchEnd` and
    `touchOrigin` functions' *x* coordinates, the faster the cart movement. I divided
    the difference by `50` to keep the game playable; otherwise, the game would move
    too fast.
  prefs: []
  type: TYPE_NORMAL
- en: Test the game and play.
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the cart with a virtual pad](img/0075SOS_06_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Touch and drag the screen to move the cart at the proper speed. Also, that's
    all for the analogic virtual pad too.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the cart just with your finger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although you have been controlling the cart with your finger throughout the
    entire chapter, you have always had visual feedback of your movements. The last
    way to move the cart that I am going to show in this chapter does not provide
    any visual feedback, but it works great in games where movements are limited to
    one axis, such as the one you are making now.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you don''t need any graphic assets except the ones directly related
    to the game, so our `loadassets.js` file is smaller than ever:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, the changes are even smaller than the ones you made when you created the
    virtual pad from the ghost button: you just need to change the global variables
    a bit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `detectedX` and `savedX` variables will store the current and last saved
    finger or mouse in a horizontal position.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `touchListener` content is way simpler than before because you don''t have
    to manage images:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Apart from setting the `touching` Boolean variable to `true` or `false`, as
    seen before, you play with `detectedX` and `savedX` to store the initial and current
    touch horizontal coordinate.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `update` function of the `game` class takes care of the rest:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: When the player is touching the screen, the difference between current and last
    saved horizontal touch coordinate is made to see whether the cart has to move
    to the left or to the right. Then, the last saved horizontal touch coordinate
    is updated to the current horizontal touch coordinate, which is ready to change
    again if an `onTouchMoved` event is triggered.
  prefs: []
  type: TYPE_NORMAL
- en: Test the game and move your finger back and forth, you will see the cart change
    direction as soon as your finger changes direction.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Congratulations! This was a hard and long chapter because it explained three
    different ways to control your games. Now, it's up to you to use the way you think
    it fits better for each of your games, so why don't you write down a list of your
    favourite mobile games and think about what kind of way would you use to control
    the player?
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to the next chapter where you will meet realistic physics.
  prefs: []
  type: TYPE_NORMAL
