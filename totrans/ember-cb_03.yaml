- en: Chapter 3. Ember Templates
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. Ember 模板
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下菜谱：
- en: Defining an application template
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用程序模板
- en: Working with conditionals in templates
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板中使用条件
- en: Displaying a list of items
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 显示项目列表
- en: Binding with element attributes and classes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用元素属性和类绑定
- en: Working with HTML links inside templates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在模板内部处理 HTML 链接
- en: Handling HTML actions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理 HTML 动作
- en: Using template input helpers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板输入助手
- en: Using development helpers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用开发助手
- en: Introduction
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Ember applications use a templating engine to display HTML and dynamic content
    to the user. In Ember, this is done via the Handlebars templating library. This
    library takes Handlebars expressions and renders them to the screen using data
    binding.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 应用程序使用模板引擎向用户显示 HTML 和动态内容。在 Ember 中，这是通过 Handlebars 模板库完成的。这个库将 Handlebars
    表达式渲染到屏幕上，使用数据绑定。
- en: '**HTMLbars** is a variant of Handlebars that Ember uses as well. It has better
    performance and handles building the DOM in a more efficient manner. Keep in mind
    that for this chapter, we''ll be using HTMLbars and Handlebars interchangeably
    as they essentially do the same thing.'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: '**HTMLbars** 是 Ember 使用的 Handlebars 的一个变体。它具有更好的性能，并以更有效的方式处理构建 DOM。请注意，在本章中，我们将将
    HTMLbars 和 Handlebars 互换使用，因为它们本质上做的是同一件事。'
- en: In this chapter, we'll be going over how to use templates in our applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍如何在我们的应用程序中使用模板。
- en: Defining an application template
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用程序模板
- en: To work with templates, we need to understand the basics on how properties bind
    with controllers and components. Here are a few recipes that go over how to accomplish
    this.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要与模板一起工作，我们需要了解属性如何与控制器和组件绑定的一些基础知识。以下是一些介绍如何完成此操作的菜谱。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Before we get started, we'll need to generate a template.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，我们需要生成一个模板。
- en: 'We''ll first create a new application using Ember CLI:'
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先将使用 Ember CLI 创建一个新的应用程序：
- en: '[PRE0]'
  id: totrans-19
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This command will generate a new application that we can use for this recipe.
  id: totrans-20
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将生成一个我们可以用于此菜谱的新应用程序。
- en: 'Next, create a new route that will add a new template:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的路由，用于添加一个新的模板：
- en: '[PRE1]'
  id: totrans-22
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This command will generate the template and routes file as well as unit tests.
    The template file is called `helloworld.hbs` and will be generated in the `app/templates`
    folder. The route file is called `helloworld.js` and is located in the `app/routes`
    folder. The `route.js` file will also get modified with the new `helloworld` route.
    We'll discuss more about routes in [Chapter 4](part0039_split_000.html#1565U1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 4. Ember Router"), *Ember Router*.
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此命令将生成模板和路由文件以及单元测试。模板文件名为 `helloworld.hbs`，将在 `app/templates` 文件夹中生成。路由文件名为
    `helloworld.js`，位于 `app/routes` 文件夹中。`route.js` 文件也将被修改以包含新的 `helloworld` 路由。我们将在第
    4 章（[Chapter 4](part0039_split_000.html#1565U1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 4. Ember Router")）中更详细地讨论路由，*Ember Router*。
- en: 'After this, we''ll need to generate a `controller`:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要生成一个 `controller`：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This will generate a new file called `helloworld.js` in the `app/controller`
    folder and a unit test in `tests/unit/controllers`. We are now ready to continue.
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在 `app/controller` 文件夹中生成一个名为 `helloworld.js` 的新文件，并在 `tests/unit/controllers`
    中生成一个单元测试。我们现在可以继续了。
- en: How to do it...
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Let's take a look at adding properties to our new template file.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何向我们的新模板文件添加属性。
- en: 'Begin by editing the `helloworld.hbs` file. For this simple example, we''ll
    create a string with the first and last name properties as follows:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，编辑 `helloworld.hbs` 文件。对于这个简单的例子，我们将创建一个包含姓氏和名字属性的字符串，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Handlebar expressions are surrounded by double curly braces `{{ }}` and backed
    by a context. A context is an object from which Handlebar expressions read their
    properties. In this example, the context is the controller. The `{{outlet}}` will
    render the template of any nested routes, which will be discussed in more detail
    later.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Handlebar 表达式被双大括号 `{{ }}` 包围，并有一个上下文。上下文是一个对象，Handlebar 表达式从中读取其属性。在这个例子中，上下文是控制器。`{{outlet}}`
    将渲染任何嵌套路由的模板，这将在稍后更详细地讨论。
- en: 'The controller will need to have the `firstName` and `lastName` properties
    so that they can be displayed in the template:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器需要具有 `firstName` 和 `lastName` 属性，以便它们可以在模板中显示：
- en: '[PRE4]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The controller has the same name as the template. The template, by convention,
    will retrieve the properties from the controller of the same name. Each of them
    is bound to each other. If any changes occur to the data, the other values will
    change.
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 控制器的名称与模板相同。按照惯例，模板将从同名的控制器中检索属性。它们彼此绑定。如果数据有任何变化，其他值也会变化。
- en: Using templates with components
  id: totrans-35
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带有组件的模板
- en: Similar to controllers, we can create a component that can act as a context
    for the template. In the component, we can set up properties that can be accessed
    by the template later.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 与控制器类似，我们可以创建一个可以作为模板上下文的组件。在组件中，我们可以设置模板稍后可以访问的属性。
- en: 'To create a new component, use the `generate component` command:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要创建一个新的组件，使用`generate component`命令：
- en: '[PRE5]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: All components must have a dash in their names. This command will create the
    `hello-world.js` file in the `app/components/hello-world.js` folder, a template
    file in the `app/components/hello-world.hbs` file, and an integration test file
    at `tests/integration/components/hello-world-test.js`.
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 所有组件的名称都必须包含一个连字符。此命令将在`app/components/hello-world.js`文件夹中创建`hello-world.js`文件，在`app/components/hello-world.hbs`文件中创建一个模板文件，并在`tests/integration/components/hello-world-test.js`中创建一个集成测试文件。
- en: 'Edit the `hello-world.hbs` file and add the hello world string:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`hello-world.hbs`文件并添加hello world字符串：
- en: '[PRE6]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `firstName` and `lastName` parameters are retrieved from the component.
    The `yield` expression is used when the component is in the block form. We'll
    talk more about this in [Chapter 6](part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 6. Ember Components"), *Ember Components*.
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`firstName`和`lastName`参数是从组件中检索的。当组件以块形式存在时，使用`yield`表达式。我们将在[第6章](part0053_split_000.html#1IHDQ1-d21a6ad8148a415181fa52c0043435bb
    "第6章。Ember组件")*Ember组件*中更多地讨论这一点。'
- en: 'Add two properties to the component file, `hello-world.js`, the first one being
    `firstName` and the last one being `lastName`:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向组件文件`hello-world.js`添加两个属性，第一个是`firstName`，最后一个是`lastName`：
- en: '[PRE7]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'For the last part, all we need to do is add the component that we just created
    to one of our `application.hbs` files:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于最后一部分，我们只需要将刚刚创建的组件添加到我们的`application.hbs`文件之一：
- en: '[PRE8]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `{{hello-world}}` Handlebar expression adds the component to the `application.hbs`
    file. The `hello-world` template will then be rendered here. The `{{outlet}}`
    template will render the nested routes under the `application` route.
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{{hello-world}}` Handlebars表达式将组件添加到`application.hbs`文件中。然后`hello-world`模板将在这里渲染。`{{outlet}}`模板将渲染`application`路由下的嵌套路由。'
- en: Start the Ember server and navigate to `http://localhost:4200`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动Ember服务器并导航到`http://localhost:4200`。
- en: After the Ember server is started, open a web browser at localhost port 4200\.
    The message on the screen will show **Hello World! My name is John Smith**.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Ember服务器启动后，在本地主机4200端口打开一个网页浏览器。屏幕上的消息将显示**Hello World! My name is John Smith**。
- en: Navigate to `http://localhost:4200/helloworld` and you'll be greeted with two
    messages. The message on the screen will show **Hello World! My name is John Smith**.
    **Hello World! My name is Erik Hanchett**.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到`http://localhost:4200/helloworld`，你会看到两条消息。屏幕上的消息将显示**Hello World! My name
    is John Smith**。**Hello World! My name is Erik Hanchett**。
- en: When the `helloworld` route is loaded, the application template is displayed.
    The `{{outlet}}` template then gets rendered with the contents of the `helloworld`
    template file. This is why both messages are displayed. Remember that all routes
    are nested under the `application` route.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`helloworld`路由被加载时，应用程序模板会显示。然后`{{outlet}}`模板会使用`helloworld`模板文件的內容进行渲染。这就是为什么两个消息都会显示。记住，所有路由都嵌套在`application`路由下。
- en: How it works...
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Ember.js uses the Handlebars templating library. This library provides you with
    a way to do data binding between the component or controller, also known as a
    context, and the template. This data binding occurs in both directions. In other
    words, changes to the data in the component or controller will be reflected in
    the template. Changes in the template to the data will be reflected in the controller
    or component.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js使用Handlebars模板库。这个库为你提供了一种在组件或控制器（也称为上下文）和模板之间进行数据绑定的方式。这种数据绑定是双向的。换句话说，组件或控制器中的数据变化将在模板中反映出来。模板中数据的变化将在控制器或组件中反映出来。
- en: In the previous simple example, the `firstName` and `lastName` properties in
    the component were accessed in the template with double curly braces `{{}}`. This
    is known as a Handlebars expression. The template is just regular HTML with embedded
    Handlebar expressions. Ember compiles these templates later on during the build
    process.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的简单示例中，组件中的`firstName`和`lastName`属性在模板中通过双大括号`{{}}`进行访问。这被称为Handlebars表达式。模板只是普通的HTML，其中嵌入了Handlebar表达式。Ember在构建过程中稍后编译这些模板。
- en: Working with conditionals in templates
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板中使用条件
- en: Using conditionals is fundamental to using Ember's templating engine. In the
    following recipes, we'll take a look at conditionals and how they work with templates.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 使用条件是使用Ember模板引擎的基本方法。在下面的菜谱中，我们将查看条件以及它们如何与模板一起工作。
- en: How to do it...
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's take a look at a simple example that displays text if some property is
    true.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的示例，该示例在某个属性为真时显示文本。
- en: 'Create a new project and generate a new controller called `conditional`. Run
    this command in the root of the `application` folder to create `controller` and
    `template`:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目并生成一个名为`conditional`的新控制器。在`application`文件夹的根目录下运行此命令以创建`controller`和`template`：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This will create the conditional controller.
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建条件控制器。
- en: 'Update the `router.js` file with the new `conditional` route:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`router.js`文件中更新新的`conditional`路由：
- en: '[PRE10]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This will add a new `conditional` route. To access this route using the Ember
    server, open a web browser and navigate to `http://localhost:4200/conditional`.
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将添加一个新的`conditional`路由。要使用Ember服务器访问此路由，请打开网页浏览器并导航到`http://localhost:4200/conditional`。
- en: 'Update the `conditional` controller with the `isHomeworkDone` property:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`isHomeworkDone`属性更新`conditional`控制器：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: This will create a new `isHomeworkDone` property and default it to `true`.
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个新的`isHomeworkDone`属性并将其默认设置为`true`。
- en: 'Update the conditional template so that it will display one message if `isHomeworkDone`
    is `true` and another message if it isn''t:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新条件模板，使其在`isHomeworkDone`是`true`时显示一条消息，如果不是则显示另一条消息：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-70
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `{{if}}` statement is a helper and must be surrounded by curly braces `{{}}`
    like any other Handlebar expression. It begins with a `#` sign, which indicates
    that it's a form of a block invocation. The `{{/if}}` statement closes the statement.
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`{{if}}`语句是一个助手，必须像任何其他Handlebar表达式一样被大括号`{{}}`包围。它以一个`#`符号开始，表示它是一种块调用形式。`{{/if}}`语句关闭该语句。'
- en: The preceding example shows two statements, `{{if}}` and `{{else}}`, both in
    the block form. Only the statement that is true will be displayed.
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 之前的示例显示了两种语句，`{{if}}`和`{{else}}`，都是块形式。只有为真的语句将被显示。
- en: As we know from the controller earlier, if `isHomeworkDone` is `true`, the statement
    `Thanks for finishing the homework!` will be displayed after the template is rendered.
    On the other hand, if `isHomeworkDone` was `false`, the statement `Please finish
    the homework` will be displayed.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如我们从早期的控制器中知道的那样，如果`isHomeworkDone`是`true`，则在模板渲染后，将显示语句`Thanks for finishing
    the homework!`。另一方面，如果`isHomeworkDone`是`false`，则将显示语句`Please finish the homework`。
- en: To test this example, navigate to the `http://localhost:4200/conditional` route.
    The `{{outlet}}` in `application.hbs` will render the `conditional` template inside
    of it.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要测试此示例，请导航到`http://localhost:4200/conditional`路由。`application.hbs`中的`{{outlet}}`将渲染其内部的`conditional`模板。
- en: Using inline invocation with templates
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用模板与内联调用
- en: Inline invocation can be used to display data with `if` statements, all within
    one line of code.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 内联调用可用于使用`if`语句在一行代码中显示数据。
- en: 'We''ll take the previous example and recreate it using inline invocation. Edit
    the `condtional.hbs` file in the `app/templates` folder with the new `if` statement
    using inline invocation:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用内联调用重新创建前面的示例。使用内联调用在`app/templates`文件夹中的`condtional.hbs`文件中编辑`router.js`文件，使用新的`if`语句：
- en: '[PRE13]'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: When using inline invocation, you don't need to use the pound sign `#` or end
    the `if` block with `{{/if}}`. Everything can be written in one expression.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当使用内联调用时，您不需要使用井号`#`或使用`{{/if}}`结束`if`块。一切都可以在一个表达式中写出来。
- en: The first argument of the helper after `isHomeworkDone`, `Thanks for finishing`
    `the homework!`, will be shown only if `isHomeworkDone` is `true`. The second
    argument, `Please finish the homework`, will be displayed if `isHomeworkDone`
    is `false`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`isHomeworkDone`之后，助手的第一个参数`Thanks for finishing` `the homework!`只有在`isHomeworkDone`是`true`时才会显示。第二个参数`Please
    finish the homework`将在`isHomeworkDone`是`false`时显示。
- en: Working on nested invocation with templates
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在模板中使用嵌套调用
- en: Nested invocations are inline, which means that they return a single value.
    They can also accept multiple nested `if` statements in the inline helper.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 嵌套调用是内联的，这意味着它们返回单个值。它们也可以在内联助手中接受多个嵌套的`if`语句。
- en: 'In the `conditional` controller, add a couple of properties called `isHomeworkDone`
    and `isChoresDone`:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`conditional`控制器中，添加两个名为`isHomeworkDone`和`isChoresDone`的属性：
- en: '[PRE14]'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Both of these are defaulted to `true`.
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这两个都默认为`true`。
- en: 'Let''s use nested invocation to display a message only if both `isHomeworkDone`
    and `isChoresDone` are `true`. Edit the `condtional.hbs` file with the new nested
    `if` statement:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们使用嵌套调用只显示一个消息，如果`isHomeworkDone`和`isChoresDone`都是`true`。用新的嵌套`if`语句编辑`condtional.hbs`文件：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `Thanks for finishing the homework` string will display only if both `isChoresDone`
    and `isHomeworkDone` are `true`. Otherwise, nothing is displayed. As the controller
    has both values set to `true`, the message will display **Thanks for finishing
    the homework!** after the template is rendered.
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`谢谢完成作业`字符串只有在`isChoresDone`和`isHomeworkDone`都是`true`时才会显示。否则，不会显示任何内容。由于控制器将这两个值都设置为`true`，在模板渲染后，将显示**谢谢完成作业！**。'
- en: The opposite of if is unless
  id: totrans-89
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 与`if`相反的是`unless`
- en: Another useful helper is `unless`. It works exactly the opposite of the `if`
    helper. It can work with all three invocation styles—inline, block, and nested.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个有用的助手是`unless`。它正好与`if`助手相反。它可以与所有三种调用方式一起工作——内联、块和嵌套。
- en: 'We''ll create the `unless` block that will display a string if it''s not true
    in our `conditional.hbs` file:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在`conditional.hbs`文件中创建一个`unless`块，如果它在我们不是真的，将显示一个字符串：
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In this block, the `unless` helper will display `Please finish the homework`
    only if `isHomeworkDone` is `false`. On the other hand, the message `Thanks for
    finishing the homework!` will be displayed if `isHomeworkDone` is `true`. This
    is essentially the opposite of the `if` helper.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个块中，如果`isHomeworkDone`是`false`，`unless`助手将显示`请完成作业`。另一方面，如果`isHomeworkDone`是`true`，将显示消息`谢谢完成作业！`。这本质上与`if`助手相反。
- en: In this example, assuming that `isHomeworkDone` is `true`, the `Thanks for finishing
    the homework!` string will be displayed in the template after it's rendered.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，假设`isHomeworkDone`是`true`，在模板渲染后，将显示字符串`谢谢完成作业！`。
- en: How it works...
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `if` and `unless` conditionals are built-in helpers that are made available
    to us from the Handlebars templating engine. They are surrounded by curly braces
    `{{}}`, which tell Handlebars to interpret them. The `{{if}}` statement checks
    whether the property is `true`. JavaScript values such as `undefined`, `null`,
    `''` , `[]`, and numeric `0` will return as `false`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`if`和`unless`条件是内置助手，它们由Handlebars模板引擎提供给我们。它们被大括号`{{}}`包围，这告诉Handlebars解释它们。`{{if}}`语句检查属性是否为`true`。JavaScript值如`undefined`、`null`、`''''`、`[]`和数字`0`将返回为`false`。'
- en: There are three different ways in which these conditional helpers can be invoked—block,
    nested, or inline. All three will work with `if` and `unless` helpers.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这些条件助手可以通过三种不同的方式被调用——块、嵌套或内联。所有三种都会与`if`和`unless`助手一起工作。
- en: Displaying a list of items
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 显示物品列表
- en: Often, you'll have a list of items that you'll need to iterate over. We can
    iterate through these items with the `each` helper. This recipe will go over how
    to do this.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会有一个需要迭代的物品列表。我们可以使用`each`助手遍历这些项目。这个配方将介绍如何做到这一点。
- en: How to do it...
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Let's say that we have a list of students and want to display them in our template.
    We'll use the `each` helper to accomplish this.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们有一个学生列表，并想在模板中显示它们。我们将使用`each`助手来完成这项工作。
- en: 'In a new project, generate `student` `controller` and `template`:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新项目中，生成`student``controller`和`template`：
- en: '[PRE17]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This will create the necessary files needed for our example.
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建我们示例所需的必要文件。
- en: 'Update the `router.js` file with the new `student` route:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的`student`路由更新`router.js`文件：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This will add a new `conditional` route. To access this route using the Ember
    server, open a web browser and navigate to `http://localhost:4200/student`.
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将添加一个新的`conditional`路由。要使用Ember服务器访问此路由，请打开网络浏览器并导航到`http://localhost:4200/student`。
- en: 'Update our student controller with an array of `students` as a property:'
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将学生控制器更新为具有`students`数组属性：
- en: '[PRE19]'
  id: totrans-109
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This array has three student objects.
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个数组有三个学生对象。
- en: 'In our `student.hbs` template, we''ll iterate through the `students` array
    using the `each` helper:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`student.hbs`模板中，我们将使用`each`助手遍历`students`数组：
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The first argument to the `each` helper is the array to be iterated over. In
    this case, this is the `students` array that was declared in the `student` controller.
    The `|student|` block `param` is what we'll use to iterate over the array.
  id: totrans-113
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`each`辅助函数的第一个参数是要迭代的数组。在这种情况下，这是在`student`控制器中声明的`students`数组。`|student|`块`param`是我们将用于遍历数组的内容。'
- en: The `each` helper must be in the block form. In this example, each value of
    the student will be displayed with an HTML break afterward.
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`each`辅助函数必须以块形式存在。在这个例子中，学生的每个值都会显示，并在其后使用HTML换行符。'
- en: 'The output will look like this after being rendered:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染后的输出将如下所示：
- en: '[PRE21]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: If, by chance, the array was empty, you can use `{{else}}`.
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果数组意外为空，可以使用`{{else}}`。
- en: 'Add a new array to the template. This array can be empty or may not even exist:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向模板添加一个新的数组。这个数组可以是空的，甚至可能不存在：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The `else` block will be rendered only if the array is empty or doesn't exist.
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 只有当数组为空或不存在时，才会渲染`else`块。
- en: Finding the index of the array
  id: totrans-121
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查找数组的索引
- en: If needed, you can also access `index` of the array in the second block `param`.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要，你还可以在第二个块`param`中访问数组的`index`。
- en: 'Create a new array and add the `index` block `param`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的数组并添加`index`块`param`：
- en: '[PRE23]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: After each iteration, `name` and `index` is displayed with an HTML break element.
    The index can be accessed using the double curly braces `{{index}}`.
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在每次迭代后，使用HTML换行元素显示`name`和`index`。索引可以通过双大括号`{{index}}`访问。
- en: 'Assuming that we are using the same student array from earlier in this chapter,
    the rendered output will look as follows:'
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设我们正在使用本章前面提到的相同的学生数组，渲染的输出将如下所示：
- en: '[PRE24]'
  id: totrans-127
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Keep in mind that `index` starts at `0` and not `1`.
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，`index`从`0`开始，而不是`1`。
- en: How it works...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `each` helper uses block params to iterate through arrays. The `each` helper
    takes an array argument and the block `param` is used to iterate each individual
    item on the list. If the array doesn't exist or is empty, you can use `else` to
    display a message instead.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`each`辅助函数使用块参数来遍历数组。`each`辅助函数接受一个数组参数，而`block param`用于遍历列表中的每个单独的项目。如果数组不存在或为空，可以使用`else`来显示一条消息。'
- en: In the recipes in this chapter, the `students` array was declared in `controller`.
    It had several student objects that could be accessed by the template. The template
    used this array and iterated over it with the `each` helper.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的食谱中，`students`数组在`controller`中声明。它有几个学生对象，可以通过模板访问。模板使用了这个数组，并使用`each`辅助函数遍历它。
- en: Binding with element attributes and classes
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用元素属性和类绑定
- en: A very useful feature of HTMLBars is binding elements to attributes in your
    HTML.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: HTMLBars的一个非常有用的功能是将元素绑定到你的HTML属性中。
- en: How to do it...
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: A very simple example would be binding an element to an `img src` tag.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 一个非常简单的例子是将元素绑定到`img src`标签。
- en: 'In a new project, generate `index template` and `index controller`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新项目中，生成`index template`和`index controller`：
- en: '[PRE25]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This will generate the files needed for this example.
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成此示例所需的文件。
- en: 'Create a new `index controller` file with `url`, `sideClass`, and `secondClass`
    as its properties:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`index controller`文件，其属性为`url`、`sideClass`和`secondClass`：
- en: '[PRE26]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We get the `index` route and controller without having to create a specific
    route for them. It works like the application route, which all other routes inherit
    from.
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以获取`index`路由和控制器，而无需为它们创建特定的路由。它的工作方式与应用程序路由相同，所有其他路由都继承自该路由。
- en: 'Create a new template and add an `img` tag. The `url` element will be displayed:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的模板并添加一个`img`标签。将显示`url`元素：
- en: '[PRE27]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This will be rendered as if the `url` property is in the `src` attribute for
    the `img` tag.
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将像`url`属性在`img`标签的`src`属性中一样被渲染。
- en: 'The template will be rendered with the `url` property as follows:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 模板将使用`url`属性如下渲染：
- en: '[PRE28]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We can essentially add this to any tag we like.
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们基本上可以将这个添加到我们喜欢的任何标签中。
- en: 'Let''s create a `div` tag in our template with a couple of properties added
    for the class:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在模板中创建一个`div`标签，并添加一些用于类的属性：
- en: '[PRE29]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Both `sideClass` and `secondClass` will be added to the class attribute. As
    these properties are bound, they act like any other property in Ember. They can
    be dynamically changed and the template will render accordingly.
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`sideClass`和`secondClass`都将添加到类属性中。由于这些属性被绑定，它们就像Ember中的任何其他属性一样。它们可以动态更改，并且模板将相应地渲染。'
- en: Tip
  id: totrans-151
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Content security policy**'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**内容安全策略**'
- en: When running examples in this book, you might occasionally see messages in the
    console warning you about content security violations. They'll usually appear
    in big red text in your console. The Ember team put this in place to help remind
    developers about potential security issues that your application might have. For
    the purpose of this book, these warnings can be ignored. On the other hand, you
    can fix these warnings by editing the `config/environment.js` file and the `contentSecurityPolicy`
    section. You can find examples on how content security works at [http://content-security-policy.com/](http://content-security-policy.com/).
  id: totrans-153
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在运行本书中的示例时，你可能会偶尔在控制台中看到关于内容安全违规的消息。它们通常会以大红色文本出现在你的控制台中。Ember 团队这样做是为了帮助提醒开发者你的应用程序可能存在的潜在安全问题。对于本书的目的，这些警告可以忽略。另一方面，你可以通过编辑
    `config/environment.js` 文件和 `contentSecurityPolicy` 部分来修复这些警告。你可以在 [http://content-security-policy.com/](http://content-security-policy.com/)
    找到关于内容安全如何工作的示例。
- en: How it works...
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Binding elements in attributes is done by the HTMLBars templating library, which
    is based on the Handlebars library. It looks at every attribute with a property
    and renders it on the screen. These attributes are bound to properties that can
    be accessed in the controller or component.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 通过 HTMLBars 模板库在属性中绑定元素，该库基于 Handlebars 库。它查看每个具有属性的属性，并在屏幕上渲染它。这些属性绑定到可以在控制器或组件中访问的属性。
- en: We can bind any property to any attribute. The only exception being view helpers.
    We'll discuss this more in a later part of the chapter.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将任何属性绑定到任何属性上。唯一的例外是视图辅助函数。我们将在本章的稍后部分讨论这个问题。
- en: Working with HTML links inside templates
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在模板内处理 HTML 链接
- en: One of the most useful helpers that Ember.js provides is the link-to helper.
    We'll discuss how to use this helpful feature in this recipe.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: Ember.js 提供的最有用的辅助函数之一是 `link-to` 辅助函数。我们将讨论如何在本次食谱中使用这个有用的功能。
- en: How to do it...
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到...
- en: The link-to helper is used to navigate an Ember application. The first argument
    is always the name of the route. The second is the dynamic segment. We'll discuss
    dynamic segments a little later.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`link-to` 辅助函数用于导航 Ember 应用程序。第一个参数始终是路由的名称。第二个是动态段。我们将在稍后讨论动态段。'
- en: One of the simplest ways to use the link-to helper is to use it inline.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `link-to` 辅助函数的最简单方法之一是将其内联使用。
- en: 'Create a new student application and route. Run this command in the root of
    the `project` directory:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的学生应用程序和路由。在 `project` 目录的根目录下运行此命令：
- en: '[PRE30]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Ember CLI will generate a new route called students. This will update the `router.js`
    file as well as add the template and route files.
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember CLI 将生成一个名为 `students` 的新路由。这将更新 `router.js` 文件以及添加模板和路由文件。
- en: 'Open the `students.hbs` file in the `app/templates` folder and add this string
    to it:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/templates` 文件夹中打开 `students.hbs` 文件，并向其中添加此字符串：
- en: '[PRE31]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This message will be displayed after navigating to the `students` route.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在导航到 `students` 路由后，将显示此消息。
- en: 'Open the `application.hbs` file. Let''s add a `link-to` helper:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `application.hbs` 文件。让我们添加一个 `link-to` 辅助函数：
- en: '[PRE32]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The `link-to` helper's first argument is `students`. This is the `students`
    route that we created earlier. This will render an HTML hyperlink with the name
    of `Students` linked to the `students` route. The `{{outlet}}` tells the Handlebars
    templating library where to render the output of the route.
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`link-to` 辅助函数的第一个参数是 `students`。这是我们之前创建的 `students` 路由。这将渲染一个名为 `Students`
    的 HTML 超链接，链接到 `students` 路由。`{{outlet}}` 告诉 Handlebars 模板库在哪里渲染路由的输出。'
- en: 'The output of `link-to` will show an HTML link. When this is clicked, the link
    will display the `students` route message that we created earlier in the `students.hbs`
    file. This is rendered by `{{outlet}}`:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`link-to` 的输出将显示一个 HTML 链接。当点击此链接时，它将显示我们在 `students.hbs` 文件中创建的 `students`
    路由消息。这是由 `{{outlet}}` 渲染的：'
- en: '[PRE33]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '`Students` is a hyperlink to the route, `/students`.'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Students` 是指向路由 `/students` 的超链接。'
- en: Ember.js is smart enough to remember the history of a link after it's clicked.
    Therefore, if by chance a user clicks back on the web browser, it will return
    to the previous route.
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember.js 足够智能，可以记住点击链接后的历史记录。因此，如果用户不小心在网页浏览器上点击后退，它将返回到上一个路由。
- en: 'You can override this behavior, if needed, by adding the `replace=true` option
    to the `link-to` helper:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果需要，你可以通过向 `link-to` 辅助函数添加 `replace=true` 选项来覆盖此行为：
- en: '[PRE34]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Tip
  id: totrans-177
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Adding data attributes to view helpers**'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**向视图辅助函数添加数据属性**'
- en: Unfortunately, data view helpers such as `link-to` and `input` don't allow custom
    data attributes. In other words, if you're using `link-to`, you can't add `data-toggle='dropdown'`
    to the end of the `link-to` helper. Normal attributes such as class will work,
    however.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 很不幸，像 `link-to` 和 `input` 这样的数据视图助手不允许自定义数据属性。换句话说，如果你正在使用 `link-to`，你不能在 `link-to`
    助手末尾添加 `data-toggle='dropdown'`。然而，正常的属性如 `class` 将会工作。
- en: 'One way to add custom attributes is to reopen `Ember.LinkComponent` for `link-to`
    or `Ember.TextField` for the `input` helper. Reopening a class was discussed in
    [Chapter 2](part0023_split_000.html#LTSU1-d21a6ad8148a415181fa52c0043435bb "Chapter 2. The
    Ember.Object Model"), *The Ember.Object Model*, so check there first. After reopening
    the class, you can add an `attributeBindings` property array. Each element in
    the array is a data attribute that you want available to your `link-to` or `input`
    helper. For example, to add `data-toggle` as an attribute to your `link-to` helper,
    it would look like `attributeBindings: [''data-toggle'']`. We''ll discuss more
    about `input` helpers in the next section.'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '添加自定义属性的一种方法是为 `link-to` 或 `input` 助手重新打开 `Ember.LinkComponent` 或 `Ember.TextField`。在
    [第 2 章](part0023_split_000.html#LTSU1-d21a6ad8148a415181fa52c0043435bb "第 2 章。Ember.Object
    Model") 中讨论了重新打开类，*The Ember.Object Model*，所以首先查看那里。重新打开类后，你可以添加一个 `attributeBindings`
    属性数组。数组中的每个元素都是你希望对 `link-to` 或 `input` 助手可用的数据属性。例如，要将 `data-toggle` 作为属性添加到你的
    `link-to` 助手，它将看起来像 `attributeBindings: [''data-toggle'']`。我们将在下一节中讨论更多关于 `input`
    助手的内容。'
- en: Alternatively, you can create a component that extends from `LinkComponent`
    instead of the normal simple component. You can then add attributes to it. Make
    sure to name it something other than `link-to`.
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 或者，你可以创建一个从 `LinkComponent` 扩展而来的组件，而不是普通的简单组件。然后你可以向它添加属性。确保不要将其命名为 `link-to`。
- en: Using link-to helpers with dynamic segments
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用带有动态段落的 `link-to` 助手
- en: Link-to helpers can be used to link dynamic segments. The dynamic segment is
    added to the second argument in the `link-to` helper. In this recipe, we'll create
    a `students` route with a dynamic segment.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用 `link-to` 助手来链接动态段。动态段被添加到 `link-to` 助手的第二个参数中。在这个菜谱中，我们将创建一个带有动态段的 `students`
    路由。
- en: 'Run this command from the project root to create `resource` for `students`:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目根目录运行此命令以创建 `students` 的 `resource`：
- en: '[PRE35]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This will create the model, route, and templates needed for our new `students`
    route.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建我们新的 `students` 路由所需的所有模型、路由和模板。
- en: 'Next, we''ll need to update the `router.js` file and add a simple dynamic segment:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要更新 `router.js` 文件并添加一个简单的动态段：
- en: '[PRE36]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The most important thing to realize here is the path. This is called a dynamic
    segment and is represented by :`student_id`. By convention, the `students` route
    will retrieve information from the student model. If the user navigates to `/students/5`,
    the route will retrieve the student model with the ID of 5\. Look for more information
    on dynamic segments and routes in the [Chapter 4](part0039_split_000.html#1565U1-d21a6ad8148a415181fa52c0043435bb
    "Chapter 4. Ember Router"), *Ember Router*.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这里需要意识到最重要的是路径。这被称为动态段，由 :`student_id` 表示。按照惯例，`students` 路由将从学生模型中检索信息。如果用户导航到
    `/students/5`，路由将检索具有 ID 为 5 的学生模型。更多关于动态段和路由的信息，请参阅 [第 4 章](part0039_split_000.html#1565U1-d21a6ad8148a415181fa52c0043435bb
    "第 4 章。Ember Router")，*Ember Router*。
- en: 'Create a new `application.js` file in the `app/routes` folder. For the sake
    of simplicity, we''ll have the application route return an array of student objects
    that we can then retrieve in our template:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/routes` 文件夹中创建一个新的 `application.js` 文件。为了简单起见，我们将让应用程序路由返回一个学生对象的数组，我们可以在模板中检索它：
- en: '[PRE37]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `application` route is on top and is inherited by all other routes. For
    this example, we returned a list of objects with a number of properties. This
    model will be able to be accessed in our students template.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`application` 路由位于顶部，并且所有其他路由都会继承它。在这个例子中，我们返回了一个具有多个属性的对象列表。这个模型将能够在我们的学生模板中访问。'
- en: 'Update the students template in the `app/templates` folder:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `app/templates` 文件夹中的学生模板：
- en: '[PRE38]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: This template will display `name`, `age`, and `location` of the model passed
    to it. Make sure to prefix all the values with `model`.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个模板将显示传递给它的模型中的 `name`、`age` 和 `location`。确保所有值都以前缀 `model` 开头。
- en: 'We''ll then update the `application.hbs` file with a `{{each}}` helper and
    `link-to`:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将更新 `application.hbs` 文件，使用 `{{each}}` 助手和 `link-to`：
- en: '[PRE39]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In this example, we have an `each` helper that iterates through the model.
    The `link-to` helper has two arguments. The first is the route, which is `students`.
    The second is the dynamic segment, `student`. Ember will replace each segment
    with the value of the corresponding object ID''s property. If, for some reason,
    no model exists, you can explicitly set the value instead:'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个 `each` 助手，它遍历模型。`link-to` 助手有两个参数。第一个是路由，即 `students`。第二个是动态段，`student`。Ember会将每个段替换为对应对象ID属性值。如果由于某种原因没有模型存在，您可以显式设置该值：
- en: '[PRE40]'
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This will link the student's route with a dynamic segment with an ID of `1`.
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将链接学生的路由与具有ID为 `1` 的动态段。
- en: Tip
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Multiple segments**'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**多个段**'
- en: There might be times where you have nested routes with multiple segments. For
    example, a blog might have blog posts and each blog post might have comments.
    In this case, you can specify multiple segments in the `link-to` helper. All you
    need to do is separate them with a space. For instance, a blog with multiple comments
    might look like `{{#link-to 'blog.comment' 1 comment}}Comment{{/link-to}}`. The
    `1` is the first dynamic segment and the comment is the second dynamic segment.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 可能会有嵌套多个段的路由。例如，一个博客可能有博客文章，每篇博客文章可能有评论。在这种情况下，您可以在 `link-to` 助手中指定多个段。您只需用空格将它们分开。例如，一个有多个评论的博客可能看起来像
    `{{#link-to 'blog.comment' 1 comment}}Comment{{/link-to}}`。`1` 是第一个动态段，comment
    是第二个动态段。
- en: 'After being rendered, three links will be displayed as follows:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 渲染后，将显示三个链接，如下所示：
- en: '[PRE41]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Clicking on any link will navigate to the student's route with that ID. The
    template will then display the student's information on the screen as follows:![Using
    link-to helpers with dynamic segments](img/00005.jpeg)
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击任何链接将导航到具有该ID的学生路线。模板随后将在屏幕上显示学生的信息如下：![使用动态段落的链接助手](img/00005.jpeg)
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `link-to` helper is used by the templating engine to route a customer throughout
    an application. It's only used for internal links, not external.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`link-to` 助手由模板引擎用于在整个应用程序中路由客户。它仅用于内部链接，不用于外部链接。'
- en: The `link-to` helper takes two or more arguments. The first is the name of the
    route. The second is used for dynamic segments.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '`link-to` 助手接受两个或更多参数。第一个是路由的名称。第二个用于动态段。'
- en: Handling HTML actions
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理HTML动作
- en: Often, in an application, we'll need to allow interaction with controls that
    affect the application state. To accomplish this, we'll use actions.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在应用程序中，我们需要允许与影响应用程序状态的控件进行交互。为了实现这一点，我们将使用动作。
- en: How to do it...
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: The `{{action}}` helper is used on HTML elements to send actions back to the
    template's corresponding controller or component when the user clicks on an element.
    Let's take a look at an example of this.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: '`{{action}}` 助手用于HTML元素，当用户点击元素时，将动作发送回模板对应的控制器或组件。让我们看看这个例子。'
- en: 'Create a new project, navigate to the root of the `application` directory,
    and type this command to generate a new component:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目，导航到 `application` 目录的根目录，并输入以下命令以生成一个新的组件：
- en: '[PRE42]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Keep in mind that all components must have a dash in their names. This will
    generate the component template, JavaScript files, and test files.
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请记住，所有组件的名称都必须包含一个连字符。这将生成组件模板、JavaScript 文件和测试文件。
- en: 'Edit the `action-component.js` file in the `components` folder. We''ll add
    the action, `toggleTex`t:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 `components` 文件夹中的 `action-component.js` 文件。我们将添加动作 `toggleText`：
- en: '[PRE43]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this example, we have a `showText` property that's defaulted to `true`. When
    the action, `toggleText`, is triggered, it toggles the `showText` property. The
    `toggleProperty` method sets the opposite value of its current property.
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个例子中，我们有一个默认为 `true` 的 `showText` 属性。当触发动作 `toggleText` 时，它会切换 `showText`
    属性。`toggleProperty` 方法设置其当前属性的相反值。
- en: 'The `toggleText` action is now ready to be added to the template. The next
    step is to add the action to the component template using the `{{action}}` helper:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`toggleText` 动作现在可以添加到模板中。下一步是将动作添加到组件模板中，使用 `{{action}}` 助手：'
- en: '[PRE44]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `if` helper will display text only if the `showText` property is `true`.
    The button at the bottom has an action called `toggleText` attached to it. Whenever
    this button is pressed, the `toggleText` action will be invoked by the corresponding
    `action-component` component. To keep things clear, the button text will show
    `Hide Text` if the text is shown and `Show Text` if it's hidden.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`if`辅助工具仅在`showText`属性为`true`时显示文本。底部的按钮有一个名为`toggleText`的动作附加到它上。每次按下此按钮时，相应的`action-component`组件将调用`toggleText`动作。为了保持清晰，按钮文本将显示为`Hide
    Text`（如果文本显示）和`Show Text`（如果文本隐藏）。'
- en: The `action` helper can be added to any HTML element. As soon as the element
    is clicked, the action will be triggered.
  id: totrans-223
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`action`辅助工具可以添加到任何HTML元素上。一旦元素被点击，动作就会被触发。'
- en: 'It''s good to know that you can attach an action to any HTML element but not
    all will respond. Some browsers may ignore the click event. In this case, you
    can use this `css` trick as a workaround:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 好知道你可以将动作附加到任何HTML元素上，但并非所有元素都会响应。某些浏览器可能会忽略点击事件。在这种情况下，你可以使用这个`css`技巧作为解决方案：
- en: '[PRE45]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Tip
  id: totrans-226
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Specifying the type of event**'
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**指定事件类型**'
- en: By default, all actions listen for click events. When a click occurs, that action
    is triggered in the context, component, or controller. You can specify an alternative
    to the click event with the `on` option. For example, a button with a double-click
    action would look like `<button {{action 'toggleText' on='doubleClick'}}Show Text</button>`.
    All event names must be camel-cased and lowercase when assigned to `on`.
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，所有动作都会监听点击事件。当点击发生时，该动作将在上下文、组件或控制器中触发。你可以使用`on`选项指定替代点击事件。例如，一个具有双击动作的按钮将看起来像`<button
    {{action 'toggleText' on='doubleClick'}}Show Text</button>`。所有事件名称在分配给`on`时必须为驼峰式和小写。
- en: 'We now need to add the component to the `application` template file so that
    it can be displayed:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要将组件添加到`application`模板文件中，以便它可以显示：
- en: '[PRE46]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This will add our action component to our `application` template.
  id: totrans-231
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将把我们的动作组件添加到我们的`application`模板中。
- en: After loading the application with the Ember server, it will look as follows:![How
    to do it...](img/00006.jpeg)
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在使用Ember服务器加载应用程序后，它将看起来如下所示：![如何操作...](img/00006.jpeg)
- en: Pressing the **Hide Text** button will hide the text. Pressing it again will
    show the text.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按下`Hide Text`按钮将隐藏文本。再次按下它将显示文本。
- en: Tip
  id: totrans-234
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Allowing modifier keys**'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**允许修改键**'
- en: By default, the `action` helper will ignore click events when modifier keys
    such as *Alt* or *Ctrl* are pressed at the same time. If needed, you can specify
    an `allowedKeys` option. For example, a button with an allowed key *Alt* would
    look like `<button {{action 'toggleText' allowedKeys='alt'}}Show Text</button>`.
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，`action`辅助工具会在同时按下修改键（如*Alt*或*Ctrl*）时忽略点击事件。如果需要，你可以指定一个`allowedKeys`选项。例如，一个允许键*Alt*的按钮将看起来像`<button
    {{action 'toggleText' allowedKeys='alt'}}Show Text</button>`。
- en: Adding a parameter to an action event
  id: totrans-237
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向动作事件添加参数
- en: You can have arguments in an action handler that will be passed back to the
    context. Anything after the action name of the `action` helper will be passed
    as an argument to the component or controller.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在动作处理程序中添加参数，这些参数将被传递回上下文。`action`辅助工具的动作名称之后的所有内容都将作为参数传递给组件或控制器。
- en: 'To begin, we''ll create a new component. After the project is created, run
    this command in the root of the `project` folder:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将创建一个新的组件。在项目创建后，在`project`文件夹的根目录下运行此命令：
- en: '[PRE47]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This will generate the necessary component files for our new `param-component`.
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成我们新的`param-component`所需的组件文件。
- en: 'Edit the `param-component.js` file and add a new action called `pressed`:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`param-component.js`文件并添加一个名为`pressed`的新动作：
- en: '[PRE48]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: In this simple example, the `pressed` action has only one parameter. When the
    action is triggered, an `alert` box is displayed with the passed in parameter
    text.
  id: totrans-244
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个简单的示例中，`pressed`动作只有一个参数。当动作被触发时，将显示一个带有传入参数文本的`alert`框。
- en: 'The next step is to edit the template and add the action:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是编辑模板并添加动作：
- en: '[PRE49]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: In this template, we have an `input` helper. The `input` helper will be discussed
    in more detail in the *Using template input helpers* recipe. The button press
    triggers the `pressed` action and passes the `hello` text from the input helper
    to the action.
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个模板中，我们有一个`input`辅助工具。`input`辅助工具将在*使用模板输入辅助工具*菜谱中更详细地讨论。按钮点击会触发`pressed`动作，并将输入辅助工具中的`hello`文本传递给动作。
- en: Note
  id: totrans-248
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Allowing default browser action**'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**允许默认浏览器动作**'
- en: The action helper, by default, prevents the default browser action of the DOM
    event. In other words, when a user clicks on a link or button that might otherwise
    reload the page, Ember prevents this. If needed, you can turn this behavior off
    using `preventDefault=false`. For example, we can add an action event to a link
    and have it redirected to a page as well as trigger an event `<a href="thispage.htm"
    {{action 'pressed' preventDefault=false}}>Press Me</a>`.
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，动作辅助工具会阻止DOM事件的默认浏览器行为。换句话说，当用户点击可能否则会重新加载页面的链接或按钮时，Ember会阻止这种行为。如果需要，您可以使用`preventDefault=false`来关闭此行为。例如，我们可以向链接添加一个动作事件，并将其重定向到页面，同时触发一个事件`<a
    href="thispage.htm" {{action 'pressed' preventDefault=false}}>按我</a>`。
- en: 'The next step is to add `param-component` to the application:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是将`param-component`添加到应用程序中：
- en: '[PRE50]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: In this code, we added `param-component` to the `application` template.
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此代码中，我们向`application`模板添加了`param-component`。
- en: After starting the server, a textbox will be displayed. Pressing the **Press
    Me** button will display the text in an alert box. It should look as follows:![Adding
    a parameter to an action event](img/00007.jpeg)
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动服务器后，将显示一个文本框。按下**按我**按钮将在弹出的警告框中显示文本。它应该如下所示：![向动作事件添加参数](img/00007.jpeg)
- en: 'In some cases, we may not be using an `input` helper. Let''s say that we want
    to have an action event trigger `onblur`. We can specify a `value` option in our
    `action` helper:'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在某些情况下，我们可能不会使用`input`辅助工具。假设我们想要一个动作事件触发`onblur`。我们可以在`action`辅助工具中指定一个`value`选项：
- en: '[PRE51]'
  id: totrans-256
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The input `text` field has `value` equal to the `hello` property. The `onblur`
    event is raised whenever the element loses focus. By default, the action handler
    receives the first parameter of the event listener. In this case, it would be
    `Event {}`. We must specify the `value` option to specify the target value using
    `target.value`.
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 输入`text`字段具有等于`hello`属性的`value`。每当元素失去焦点时，都会引发`onblur`事件。默认情况下，动作处理程序接收事件监听器的第一个参数。在这种情况下，它将是`Event
    {}`。我们必须指定`value`选项来指定目标值，使用`target.value`。
- en: Unfortunately, due to the way Ember binds values, we cannot simply just send
    the `hello` property as a parameter to the action. This is why we must use the
    `value` option.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Ember绑定值的方式，我们无法简单地只发送`hello`属性作为参数到动作。这就是为什么我们必须使用`value`选项。
- en: You can test this by entering text in the textbox and clicking outside the box
    so that it loses focus. It should show the correct text in the alert popup.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在文本框中输入文本并点击框外使其失去焦点来测试这一点，以便在弹出的警告框中显示正确的文本。
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `action` helper attaches to HTML elements in order to allow user interaction.
    It sends named events to the template's corresponding context, component, or controller.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`action`辅助工具附着到HTML元素上，以便允许用户交互。它向模板的相应上下文、组件或控制器发送命名事件。'
- en: The `action` helper by default sends the first parameter of the event listener.
    You can send any parameter that you want after the `action` event. If needed,
    you can specify the `value` option and use `value.target`, which will send the
    target of the event.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`action`辅助工具会发送事件监听器的第一个参数。您可以在`action`事件之后发送任何您想要的参数。如果需要，您可以指定`value`选项并使用`value.target`，这将发送事件的目标。
- en: Using template input helpers
  id: totrans-263
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用模板输入辅助工具
- en: To create common form controls, `input` helpers can be used. This recipe will
    go over how to use them in our Ember applications.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建常见的表单控件，可以使用`input`辅助工具。本食谱将介绍如何在我们的Ember应用程序中使用它们。
- en: How to do it...
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: The most common `input` helper is `{{input}}`. It wraps around the `Ember.TextField`
    view and is almost identical to the traditional `<input>` HTML element.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的`input`辅助工具是`{{input}}`。它围绕`Ember.TextField`视图，几乎与传统的`<input>`HTML元素相同。
- en: 'Create a new project. In the `app/templates` folder, open the `application.hbs`
    file and add an `input` helper:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的项目。在`app/templates`文件夹中，打开`application.hbs`文件并添加一个`input`辅助工具：
- en: '[PRE52]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: This `input` helper is very simple; all it does is set the value of the textbox
    to `hello world`. It is surrounded by double curly braces and supports the normal
    input attributes.
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个`input`辅助工具非常简单；它所做的只是将文本框的值设置为`hello world`。它被双大括号包围，并支持正常的输入属性。
- en: 'When rendered, it will look as follows:'
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当渲染时，它将如下所示：
- en: '[PRE53]'
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If needed, we can assign properties to the `input` helper.
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果需要，我们可以将属性分配给`input`辅助工具。
- en: 'Create a new `application` controller. Run this command in the root `application`
    folder:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的`application`控制器。在根`application`文件夹中运行此命令：
- en: '[PRE54]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This will generate a new controller that the application can access.
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将生成一个应用程序可以访问的新控制器。
- en: 'Open the controller and add a new property. We''ll call this `helloText`:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开控制器并添加一个新属性。我们将称之为 `helloText`：
- en: '[PRE55]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Edit the `application.hbs` file again and set `value` to the property:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次编辑 `application.hbs` 文件并将 `value` 设置为属性：
- en: '[PRE56]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The `helloText` property is now bound to the input value. Attributes that have
    quoted values will be set directly to the element. If left unquoted, these values
    will be bound to the property on the template's current rendering context. In
    this case, this is the controller.
  id: totrans-280
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`helloText` 属性现在绑定到输入值。具有引号值的属性将直接设置到元素。如果未加引号，则这些值将绑定到模板当前渲染上下文上的属性。在这种情况下，这是控制器。'
- en: 'Let''s add a simple action to the `input` helper. This can be done using the
    dasherized event name as an attribute to the `input` helper:'
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在 `input` 辅助器中添加一个简单的动作。这可以通过将破折号化的事件名称作为属性添加到 `input` 辅助器来完成：
- en: '[PRE57]'
  id: totrans-282
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Whenever a key is pressed, the action pressed will be triggered in the component
    or controller.
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当按下键时，组件或控制器中的 `pressed` 动作将被触发。
- en: 'As we haven''t created a key press, we''ll add it to our controller:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们没有创建按键事件，我们将将其添加到我们的控制器中：
- en: '[PRE58]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Whenever a key is pressed in the textbox, a message will be logged to the console.
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 每当在文本框中按下键时，都会将一条消息记录到控制台。
- en: How to use checkbox helpers
  id: totrans-287
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用复选框辅助器
- en: In the previous example, we created a simple input textbox. We can also create
    a checkbox in the same way. This uses the `Ember.Checkbox` view.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个示例中，我们创建了一个简单的输入文本框。我们也可以以相同的方式创建复选框。这使用了 `Ember.Checkbox` 视图。
- en: 'In a new project, open the `application.hbs` file in the `app/templates` folder.
    Let''s add a new checkbox:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新项目中，打开 `app/templates` 文件夹中的 `application.hbs` 文件。让我们添加一个新的复选框：
- en: '[PRE59]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is very similar to the input textbox.
  id: totrans-291
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这与输入文本框非常相似。
- en: 'Generate an `application` controller. This will be used to store our `isChecked`
    property:'
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 生成 `application` 控制器。这将用于存储我们的 `isChecked` 属性：
- en: '[PRE60]'
  id: totrans-293
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Update the controller with the new `isChecked` property. Set it to `true`:'
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的 `isChecked` 属性更新控制器。将其设置为 `true`：
- en: '[PRE61]'
  id: totrans-295
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: This controller has only a Boolean property, `isChecked`.
  id: totrans-296
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此控制器只有一个布尔属性，`isChecked`。
- en: 'The `isChecked` property is bound to the checkbox. After it''s rendered, it
    should look as follows:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`isChecked` 属性绑定到复选框。渲染后，它应该看起来如下：'
- en: '[PRE62]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: How to use text areas
  id: totrans-299
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 如何使用文本区域
- en: To create a `textarea` element, we can use the `textarea` helper. This wraps
    the `Ember.TextArea` view.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建 `textarea` 元素，我们可以使用 `textarea` 辅助器。这会包装 `Ember.TextArea` 视图。
- en: 'Create a new project and edit the `application.hbs` file in the `app/templates`
    folder. Add a `textarea` helper:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的项目并编辑 `app/templates` 文件夹中的 `application.hbs` 文件。添加一个 `textarea` 辅助器：
- en: '[PRE63]'
  id: totrans-302
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'The text area box will be displayed with `20` columns and `10` rows. It will
    look like this after being rendered:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 文本区域框将显示为 `20` 列和 `10` 行。渲染后看起来如下：
- en: '[PRE64]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Adding actions and attributes work in the same way as the `input` and `checkbox`
    helpers.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 添加动作和属性的方式与 `input` 和 `checkbox` 辅助器相同。
- en: How it works...
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The input, textarea, and checkbox are all helpers that make it easier to work
    with common form controls. They wrap around `Ember.TextField`, `Ember.Checkbox`,
    and `Ember.TextArea`.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 输入、文本区域和复选框都是辅助器，使处理常见的表单控件变得更加容易。它们围绕 `Ember.TextField`、`Ember.Checkbox` 和
    `Ember.TextArea` 包装。
- en: With these helpers, we can easily bind elements and actions to them.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些辅助器，我们可以轻松地将元素和动作绑定到它们。
- en: Using development helpers
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用开发辅助器
- en: Debugging your template is a task that you'll often use. Here are the steps
    to do this.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 调试模板是一项你经常会使用的任务。以下是执行此操作的步骤。
- en: How to do it...
  id: totrans-311
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: The most basic way of debugging Ember templates is to use `{{log}}` and `{{debugger}}`.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 调试 Ember 模板最基本的方法是使用 `{{log}}` 和 `{{debugger}}`。
- en: 'Create a new Ember application. Create a new component called `log-example`.
    Run this command in the root `application` folder:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Ember 应用程序。创建一个名为 `log-example` 的新组件。在根 `application` 文件夹中运行以下命令：
- en: '[PRE65]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This will create a new component template and JavaScript files.
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将创建一个新的组件模板和 JavaScript 文件。
- en: 'Open the `log-example.js` file in the `app/components` folder and a new property
    called `helloText`:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/components` 文件夹中打开 `log-example.js` 文件并添加一个名为 `helloText` 的新属性：
- en: '[PRE66]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: This is a simple component with just one property.
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个只有一个属性的简单组件。
- en: 'Open the `log-example.hbs` file in the `app/templates/components` directory.
    Add `log` to it:'
  id: totrans-319
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `app/templates/components` 目录中打开 `log-example.hbs` 文件并添加 `log`：
- en: '[PRE67]'
  id: totrans-320
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: This will display a string in the browser's console window.
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将在浏览器的控制台窗口中显示一个字符串。
- en: 'Now we can add this new component to our `application.hbs` file:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以将这个新组件添加到我们的 `application.hbs` 文件中：
- en: '[PRE68]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: After being rendered, the text **Hello text is Hello World** will be displayed
    in the console.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 文本 **Hello text is Hello World** 在渲染后将在控制台显示。
- en: 'In this same example, let''s add `{{debugger}}`. Edit the `log-example.hbs`
    file and add it at the bottom:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个相同的例子中，让我们添加 `{{debugger}}`。编辑 `log-example.hbs` 文件，并将其添加到底部：
- en: '[PRE69]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The debugger is the equivalent of JavaScript's debugger keyword. It will halt
    the execution of code and allow the inspection of the current rendering context.
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 调试器等同于 JavaScript 的 `debugger` 关键字。它将停止代码的执行，并允许检查当前的渲染上下文。
- en: 'If we start the server and load the web page, the browser will halt on the
    debug statement while loading. At this point, we can open the browser''s console
    window and use the `get` function to find the current value of `helloText`:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果我们启动服务器并加载网页，浏览器将在加载过程中暂停在调试语句处。此时，我们可以打开浏览器的控制台窗口，并使用 `get` 函数来查找 `helloText`
    的当前值：
- en: '[PRE70]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: The `get` command can retrieve any value from the context. In other words, it
    can retrieve any value from the component or controller. This works the same if
    the debug statement was in a `{{each}}` loop.
  id: totrans-330
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`get` 命令可以检索上下文中的任何值。换句话说，它可以检索组件或控制器中的任何值。如果调试语句在 `{{each}}` 循环中，这也同样适用。'
- en: 'You can get the context of the view as well in the console debugger:'
  id: totrans-331
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以在控制台调试器中获取视图的上下文：
- en: '[PRE71]'
  id: totrans-332
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Tip
  id: totrans-333
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Ember Inspector**'
  id: totrans-334
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**Ember 检查器**'
- en: The Ember Inspector is a plugin for Chrome and Firefox web browsers. It makes
    it easy to debug and understand your Ember application. When you are using the
    plugin, you can see all sorts of information on your application, including routes,
    models, templates, controllers, and components. You can download it from the Firefox
    or Chrome plugin store for free.
  id: totrans-335
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: Ember 检查器是 Chrome 和 Firefox 网络浏览器的插件。它使得调试和了解你的 Ember 应用变得容易。当你使用此插件时，你可以看到关于你的应用的各种信息，包括路由、模型、模板、控制器和组件。你可以从
    Firefox 或 Chrome 插件商店免费下载它。
- en: How it works...
  id: totrans-336
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The Handlebars library has made it easy to debug your templates. They are helpers
    that interact with the web browser to log information to the console or stop the
    execution of it.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: Handlebars 库使得调试模板变得容易。它们是与网络浏览器交互的辅助工具，用于将信息记录到控制台或停止其执行。
- en: The Ember's `{{debugger}}` equivalent in JavaScript is the debugger. Both work
    very much in the same way.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: Ember 的 `{{debugger}}` 在 JavaScript 中的等效是 `debugger`。它们的工作方式非常相似。
