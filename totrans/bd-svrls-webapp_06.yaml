- en: Developing the Backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Developing the backend without servers is the main drive of the serverless concept
    and what makes it so interesting. In this model, a paradigm shift is to break
    the project into small pieces of logic that can be deployed separately instead
    of one single bloated application. How to architecture this separation is covered
    in this chapter. Also, we will continue the development of our serverless online
    store building the backend using the REST principles.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: An overview of serverless architectures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Organizing the project's code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to create RESTful services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After this chapter, you'll have built the backend of our serverless online store.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the project architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will cover four different architectural approaches for
    serverless projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Nanoservices**: This is where **each functionality** has its **own Lambda**
    function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices**: This is where **each Lambda** handles **all HTTP verbs**
    of a single resource'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Monolith**: This is where **one single Lambda** function handles **all functionalities**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Graph**: This uses the **GraphQL** standard, which is an alternative to REST
    APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As we will see, each architectural approach has its pros and cons and there
    is no *silver bullet*. You need to weigh the benefits and choose what you think
    is the best for your specific use case. Let's see more about them.
  prefs: []
  type: TYPE_NORMAL
- en: Monolith versus Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first thing that we need to think about when choosing a serverless architecture
    is if the application will execute with just one Lambda function (**Monolith**
    or **Graph**) or if it will have multiple Lambdas (**Microservices** or **Nanoservices**).
    The number of Lambda functions represents how many deployment units it has.
  prefs: []
  type: TYPE_NORMAL
- en: A monolith is a self-contained application where all functionalities are developed
    in a single solution and a modification in one piece of the code requires a new
    deployment of the whole solution.
  prefs: []
  type: TYPE_NORMAL
- en: The microservices architecture is the opposite. You have multiple units that
    can be deployed separately, where each one is responsible for a distinct part
    of the whole solution. To follow the microservices architecture, you need to add
    modularity to the application. You break a large application into a set of small
    services that can communicate with each other through HTTP requests.
  prefs: []
  type: TYPE_NORMAL
- en: Microservices uses the concept of bounded context. For example, in an online
    store, we have a context for **sales**, which represents all business rules related
    to selling products, and another context for **support**, which involves the features
    related with customer service. We can separate those concerns considering that
    they have different business rules and are able to evolve independently. Modifications
    in a support rule must not impact a sales feature, so you can deploy one service
    without deploying the other, which makes it easier for different teams to work
    in different contexts at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In general, microservices offer the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: Better separation of concerns and modularity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Independent and frequent deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Easier parallel development using separated teams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As with everything else, it is accompanied with some drawbacks, which are as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: More DevOps effort (which is mitigated by the Serverless Framework)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A distributed system adds complexity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration tests between multiple services are harder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nanoservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A nanoservice is the smallest part that you can extract from a monolithic application.
    You can split a monolith into multiple microservices, but those microservices
    can also be split into multiple nanoservices.
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can have a **users** microservice that is responsible for handling
    all operations related with users such as create, retrieve, update, delete, password
    recovery, and others. *Retrieving* a user is a single functionality that can be
    very simple, implemented with less than 10 lines of code. If you create a Lambda
    function just for this piece of logic, you are creating a nanoservice.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram shows that each exposed functionality has its own Lambda
    function and an HTTP endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbbf9f4c-58b2-4876-8d33-3589541e5bcb.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To build an application like this, we need to configure the `serverless.yml`
    file giving each function its own endpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Due to simplicity, this example has ignored the `OPTIONS` verb that would be
    required in this solution because the browser, in cross-origin requests, preflights
    an `OPTIONS` request to check the CORS headers before executing `POST`, `PUT`,
    `PATCH`, and `DELETE`. We'll cover more about this later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this architecture, we can list the pros and cons as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: Separation of concerns allows you to modify one feature without affecting other
    parts of your system. Autonomous teams will also benefit from a minimized number
    of conflicts.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging problems is much easier when a function has a single responsibility.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: Performance can be slower. Since some functions will be rarely triggered, cold
    start delays will be more frequent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a big project, you can end up with hundreds of functions! A huge number of
    logical parts may cause more harm than benefit.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The microservices pattern adds modularization of functionalities related to
    the bounded context of an application. In this architecture, each Lambda function
    handles all HTTP verbs of a single resource. It generally results in having five
    endpoints (**GET**, **POST**, **PUT**, **DELETE**, **OPTIONS**) per function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/979fae5f-25dd-479d-8655-30052162db06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding system can be defined by the `serverless.yml` file as two bounded
    contexts, where all HTTP verbs of a given context reference the same Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'This architecture has the following pros and cons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: Results in a reduced number of Lambda functions to manage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With less cold starts, performance can be slightly better than nanoservices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging is a little bit more complicated, since each function has more options
    and possible outcomes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Requires implementing a routing mechanism to handle each request correctly
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This routing mechanism can be implemented with a simple `switch…case` statement
    using the Lambda event to find the HTTP method and the REST resource:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Monolith
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The monolith pattern uses just one Lambda function to handle all functionalities
    of our application. In this case, we have all of the application''s endpoints
    triggering the same Lambda function:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ac0aba89-cf96-4c75-8112-823ef5d39353.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The preceding example can be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: A monolith architecture is not necessarily bad. For small applications that
    need to minimize cold delays, it can be indeed the best option. Let's now look
    at the pros and cons.
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: When all endpoints use the same Lambda function, the code will be constantly
    cached and cold starts will hardly happen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast deployments as there is just one resource
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: Requires building a complex routing system to handle each request, for big applications,
    it can be transformed in a *big ball of mud*
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the code base grows too much with too many dependencies, the performance
    of a single execution will be reduced
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging problems will be much more difficult
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's much harder to provision memory and set timeouts since each code path has
    a distinct execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Graph
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Graph pattern is based on the GraphQL standard that was proposed by Facebook.
    It is an emerging technology with the objective to provide an alternative to RESTful
    APIs. Since it is growing in popularity among serverless projects, it deserves
    a section in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this pattern, we have just one Lambda function with a single endpoint. This
    endpoint is a query that will trigger the GraphQL to fetch the corresponding data
    in any form that the client needs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6ee76037-ced9-489e-a48d-b9e81f1866ed.png)'
  prefs: []
  type: TYPE_IMG
- en: Having just one endpoint is not a restriction. You can have multiple endpoints,
    but the objective of this pattern is to reduce the number of interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `serverless.yml` file is very simplified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will see a simple example of how to build a GraphQL API inside a Lambda
    function. Let''s take a look at the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Install the GraphQL module (`npm install graphql --save`) and require it inside
    the `handler.js` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next step is to describe how your data is organized. In the following example,
    we have a `ShoppingCart` entity which contains a list of `Products` that the user
    wants to buy. The object key is the property name and the value is its data type.
    The schema is a string input that will be compiled by the `buildSchema` function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `decimal` data type is not a built-in data type, but you can count money
    in pennies instead of dollars with the `integer` type. GraphQL offers the `float`
    data type, but it is not reliable for handling currencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, take a look in this JSON object that follows the defined schema:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: In this example, the entire dataset will be provided as an input to the `graphql`
    function through the `data` variable. However, in a real-world application, it
    would not be feasible to load the entire database to memory. What is done in this
    case is to define a resolver function in the schema definition that tells the
    GraphQL engine how to fetch the required data, which means how to query the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'After defining how your data is structured and where it is, you can use `graphql`
    to query the data. This query will be defined by the client and will be available
    in the `event` input of the Lambda function. For example, consider this query
    sent by the client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this query, the client wants to know the list of selected products, but there
    is some information that the client is not interested in. For example, the client
    doesn't want to know the `code` of the products or whether there is a `promotionCode`
    associated with this cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use it in a Lambda function, call the `graphql` function passing the `schema`,
    `query`, and `data` arguments:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'A request to this function would return the following JSON object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'What makes GraphQL powerful is its simple syntax, that allows the client to
    request exactly what it needs and receive that data in the format that it expects.
    In this model, a single request can bring data from multiple resources. It can
    be an interesting alternative to RESTful APIs, but it also has its limitations.
    Ignoring the pros and cons related to REST, the following list compares the Graph
    pattern as a solution for a serverless architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Pros**:'
  prefs: []
  type: TYPE_NORMAL
- en: The Graph query can be a better replacement for the routing mechanism of the
    monolithic approach
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When all endpoints use the same Lambda function, the code will be constantly
    cached and cold starts will hardly happen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fast deployments as there is just one function and one endpoint
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cons**:'
  prefs: []
  type: TYPE_NORMAL
- en: The Lambda size may hurt the performance if the code base grows too much with
    too many dependencies
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's much harder to provision memory and set timeouts since each query has a
    distinct execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: GraphQL has many other features and requires extensive material, which is not
    the focus of this book. For a start, you can learn more at [http://graphql.org/learn](http://graphql.org/learn).
  prefs: []
  type: TYPE_NORMAL
- en: Naming differences
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Serverless Framework's team shares a similar view of the serverless architectures,
    which you can check out at [https://serverless.com/blog/serverless-architecture-code-patterns](https://serverless.com/blog/serverless-architecture-code-patterns).
  prefs: []
  type: TYPE_NORMAL
- en: However, what I call “nanoservices”, they call “microservices”. In my opinion,
    microservice is not a good term to describe the architecture style where every
    single feature is considered as one microservice. The concept of microservices
    was created to designate monolithic applications that were broken down into a
    few distinct pieces to better handle the management and evolution of features.
    When you have too many pieces, the principles do not apply so easily. Fortunately,
    the Serverless Framework makes it easier to handle dozens of services, but for
    a traditional application, when a microservice is too fine-grained, the overhead
    of maintenance and communication overweighs its benefits and, for the purpose
    of differentiation, it is called here a nanoservice.
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that they have named the pattern that I call “microservices” as “services”.
    You can name these patterns as you prefer, but understand that those terms can
    be confusing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram illustrates the difference between **Monolith**, **Microservices**,
    and **Nanoservices** architectures in my point of view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ce9ba8e3-a048-4e04-aba2-4171ecd97410.png)'
  prefs: []
  type: TYPE_IMG
- en: Developing the backend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After this overview of architectures, we can start building the backend. In
    this sample, which is only an experiment, I've opted for the monolith architecture
    because it reduces the cold start delays and our backend logic is very small.
    In your solution, you need to think about the use cases and weigh the benefits
    and drawbacks of each option.
  prefs: []
  type: TYPE_NORMAL
- en: Defining the functionalities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we developed the frontend and hardcoded some data
    to display static pages. Now, we are going to create the backend to expose the
    necessary information that will be used by the frontend. Take a look at the following
    frontend views and what functionalities they will need from the backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Home page**: This page requires a list of all available products to display'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Product details**: This page requires the detailed information about a product,
    including the list of user comments'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Shopping Cart**: This page needs to display the selected products and allow
    the user to save or checkout the cart'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Signup page**: The logic of this page will be implemented in [Chapter 8](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml),
    *Securing the Serverless Application*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Login page**: The logic of this page will also be implemented in [Chapter
    8](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml), *Securing the Serverless Application*'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Page not found**: There is no need to request the backend when the URL is
    invalid'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Error page**: This page won''t make any additional request to the backend
    when an error occurs'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Besides those pages, we have a Navbar component that will be displayed for all
    pages and it has a notification icon. We are going to implement this feature in
    [Chapter 9](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml), *Handling Serverless
    Notifications*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In a nutshell, we need to implement now the following functionalities:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve all available products to sell
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the details of a specific product
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Retrieve the list of selected products of the user's Shopping Cart
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the list of selected products
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Checkout a Shopping Cart
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To make it simpler, second and third features will be provided in the result
    of the first feature, which means that when the user requests the list of all
    available products, the response object will bring all information about each
    product, as well as the information on whether the user has added the product
    to the Shopping Cart.
  prefs: []
  type: TYPE_NORMAL
- en: Organizing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Choosing how to organize the files of a project is a personal choice. You just
    need to place the files using meaningful names that will make it easier to find
    them later. In this project, I''ve used the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/28bda533-e59c-4168-b0a6-dc249ef3672c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here''s a brief description about each folder shown in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '`functions`: These are the Lambda functions that will be directly deployed
    to AWS. We have just one function because our application is a monolith. This
    function will handle all things related to products. We don''t need a Lambda function
    to handle user creation/authentication because we are going to use Cognito for
    this task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`lib`: This is the common application logic that can be used by different Lambda
    functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`node_modules`: These are Node dependencies that were installed in this project
    folder and are referenced by the `package.json` file. They will be zipped to be
    used by the Lambda functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`repositories`: This folder holds the infrastructure code to connect with the
    database and define the queries. It will be implemented in [Chapter 7](436e582c-0a4c-4257-b8eb-aa2c1dbd98c4.xhtml),
    *Using a Serverless Database*. In the screenshot, you can see that we are going
    to implement queries for SimpleDB and DynamoDB. The FakeDB will be used in this
    chapter to provide hardcoded data for testing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`test`: This folder holds the unit and integration test files. It will be implemented
    in Chapter 10, *Testing, Deploying, and Monitoring*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Referencing Lambda functions in other folders
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you create a new service with the Serverless Framework, it will create
    a `serverless.yml` file to reference a sample function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: What you should note here is that `handler.hello` means that the Serverless
    Framework will try to find a `handler.js` file in the *same directory* as your
    `serverless.yml` file and look for an exported `hello` function. When you have
    a big project, you may prefer to separate your handler functions in subfolders.
    The syntax is pretty straightforward, `foldername/file.function`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In this project, I''ve used the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Using multiple services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another thing that you should note is that the Serverless Framework will create
    a ZIP folder only with the contents that are in the same level of the `serverless.yml`
    file or lower. It is not possible to include dependencies of upper levels. The
    implication is that if your project uses two different services, each one of them
    with a distinct `serverless.yml` file, you can't share dependencies directly between
    them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates an example of a project with this issue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bfd77654-e53b-40e5-9bce-1cdf0157220c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `greetings.js` file is a simple Node.js module with just one line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Both the `handler.js` files from `service1` and `service2` were implemented
    to return a message using the `greetings` module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The only difference between them is how the `greetings` module is loaded. In
    the first service, as it is in the same level, we load using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the second service, we need to reference the `service1` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: If you test the `service2` function locally (`serverless invoke local --function
    hello`), it will run without problems, but it will fail if deployed to AWS because
    the ZIP file will not be published with the dependency.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are two solutions for this problem:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid using several services. Aggregate them into a single service and place
    the merged `serverless.yml` file in the project root.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use local npm packages to manage common dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Although I prefer the first option, the second option is also valid. To create
    a local npm package, browse to the folder that contains the common dependencies
    and run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This command will create a zipped package with the exact same format that would
    be created for a public `npm` module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in the folder that contains your serverless service, install the package
    locally using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You need to repeat this process every time that the common dependency is modified.
    If it is constantly updated, you would need to include this stage into your build
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the endpoints
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we already know, we need to create the API Gateway endpoints to expose to
    the world our serverless functions. This is done in the `serverless.yml` file,
    and the following example shows how to create the endpoints for the serverless
    store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Setting an `OPTIONS` endpoint is mandatory in cases where you want to support
    the `POST`, `PUT`, `PATCH`, or `DELETE` verbs in a cross-origin request. The reason
    is a security measure used by browsers, that is, before making an HTTP request
    that can modify the resource, it preflights a request with `OPTIONS` to check
    whether CORS is enabled and whether the HTTP verb is allowed.
  prefs: []
  type: TYPE_NORMAL
- en: RESTful APIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you are not already familiar with RESTful APIs, you should know at least
    the following common HTTP verbs and how they are used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GET`: This is used to request data to the server'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST`: This is used to create or modify resources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST/resource`: Without an ID, a new element will be created'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST/resource/id`: If you know the ID and pass it in the request, the element
    will be updated, however, it is typically used only to create and not to update
    resources'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`POST/resource/new-id`: If there is no resource for a given ID, this request
    must return an error'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT`: This is used to create or modify the following resources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT/resource`: This should return an error because the ID is expected'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT/resource/id`: This replaces the entire object with the data provided'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PUT/resource/new-id`: If there is no resource for a given ID, it will be created'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PATCH`: This is used to do partial updates, instead of replacing the entire
    resource with the given data, it won''t update or remove properties that do not
    match with the input'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DELETE`: This is used to delete resources and an ID must be provided'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OPTIONS`: This returns the allowed HTTP verbs and informs if CORS is enabled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Routing the HTTP verbs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As already exemplified, for our routing strategy, we can use a `switch…case`
    statement using `httpMethod` and `resource` to identify the path. I suggest adding
    a `try…catch` statement to warn the client about unexpected errors instead of
    letting Lambda swallow the messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following example shows how to implement the routes for the `products`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Remember that you need to run `serverless deploy` to create the Lambda function
    and endpoints, but after that, the command `serverless deploy function --function
    products` can be used for a faster deployment.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will explain how the `utils` module was created to handle the
    responses.
  prefs: []
  type: TYPE_NORMAL
- en: Handling HTTP responses
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Usually, we need to handle at least four response types:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Success**: Return HTTP `200 OK` when the request is processed successfully.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Error**: Return HTTP `500 Internal Server Error` when an error happens in
    the backend.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Not found**: Return HTTP `404 Not Found` when the client requests a resource
    that doesn''t exist.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Options**: Return HTTP `200 OK` along with the allowed methods for this resource.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are many other HTTP status codes, like `400 Bad Request` when the client
    sends a request without the necessary parameters, but covering an extensive list
    of status codes is out of the scope of this book and most of them are not used
    in the majority of applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows how to implement those handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Regarding the `OPTIONS` verb, we need to answer the requests with the status
    code `200 OK` and set the allowed methods and headers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the Lambda functions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we are going to see how to implement the backend features.
    After implementing and deploying the Lambda functions, we can modify the frontend
    code to make Ajax requests to the backend.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving all products
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This feature has the following three responsibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Retrieve all products from the products table
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve all user comments/ratings and join them with the product list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Retrieve the user Shopping Cart and merge with the product list to identify
    what products were already selected
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those queries will be created and executed by `repository` and its implementation
    will be defined in the next [Chapter 7](cb2f92df-5bc3-4c8e-8872-fbee58e5b0be.xhtml),
    *Managing a Serverless Database*.
  prefs: []
  type: TYPE_NORMAL
- en: 'By now, let''s use the FakeDB to return hardcoded values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'In this case, the FakeDB will just return a list of products:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Saving the Shopping Cart
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This request receives as the input a list of selected products and the `UserID`.
    In our sample application, the `UserID` will uniquely identify the shopping cart,
    which means that each user has just one cart.
  prefs: []
  type: TYPE_NORMAL
- en: If the user is logged in, the frontend knows the `UserID`. However, we can't
    receive an `ID` directly from the client and take actions trusting that this information
    is valid. We know that a malicious user can modify the JavaScript code to send
    an `ID` of another user.
  prefs: []
  type: TYPE_NORMAL
- en: For a reliable operation, we must analyze the authentication tokens that are
    passed through the headers of all requests from logged users and check if the
    `ID` is correct. This step will be implemented in [Chapter 8](5778526b-7b49-48bd-8fc8-f5285baa64c1.xhtml),
    *Securing the Serverless Application*.
  prefs: []
  type: TYPE_NORMAL
- en: Checking out
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Handling payments is a complex feature that won't be covered in this book. So,
    when the user tries to checkout the Shopping Cart, a message will be displayed
    to show that this is just a demo application.
  prefs: []
  type: TYPE_NORMAL
- en: However, we can use this feature to learn how serverless notifications work.
    When the user starts a payment process, the backend receives the credit card information
    and makes a request to process the payment. As this step can take a long time,
    instead of using the client to make repetitive requests (polling), we can use
    WebSockets to notify the user when the response is available. Serverless notifications
    will be covered using IoT in [Chapter 9](ab2add3a-931b-478c-9fbf-039ba2a637a1.xhtml),
    *Handling Serverless Notifications*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you have learned the serverless architectures such as nanoservices,
    microservices, monolith, and Graph. For our serverless store, the monolith architecture
    was selected and used to build the backend. We also covered how to structure the
    project's code and build RESTful APIs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about the SimpleDB serverless database.
    Due to the fact that SimpleDB may not be good enough for most applications, we
    are also going to learn about DynamoDB, which is not a serverless database, but
    requires minimal management.
  prefs: []
  type: TYPE_NORMAL
