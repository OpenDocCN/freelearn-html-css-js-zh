<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Deployment</h1>
                </header>
            
            <article>
                
<p>Now that we know how to create Aurelia applications, we should be able to deploy them in our own servers or if you want to take advantage of other big companies resources, why don't use cloud providers to deploy our apps?</p>
<p>In this chapter, you will learn how to deploy your applications on your own self-managed servers using Docker and NGINX. Also, you will learn how to deploy applications on Heroku and one of the best cloud providers on the planet—<strong>Amazon Web Services</strong> (<strong>AWS</strong>).</p>
<p>We will use Docker to deploy locally, because this will make our deployment portable so that you can deploy your application in your own data center or in the cloud.</p>
<p>Having said that, in this chapter, we will cover the following topics:</p>
<ul>
<li>Configuring our web for production</li>
<li>Deploying on your own server</li>
<li>Deploying on Heroku</li>
<li>Deploying on AWS S3 buckets</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring our web for production</h1>
                </header>
            
            <article>
                
<p>Before we deploy our application to production, we should prepare and configure it. Let's create an example Aurelia application and deploy it. Open a new Terminal window and run the following command to start a new <kbd>deployme</kbd> project:</p>
<pre><strong>$ au new deployme</strong><br/><strong>  ...</strong><br/><strong>  ...</strong><br/><strong>  Happy Coding!</strong><br/><br/><strong>$ ls deployme/aurelia_project/environments<br/>  dev.js  stage.js  prod.js</strong></pre>
<p>Let's navigate to the <kbd>aurelia_project/environments</kbd> folder. In this folder, you will find the following files that map to a specific development environment:</p>
<ul>
<li><kbd>dev.js</kbd>: Contains the configurations for the development phase.</li>
<li><kbd>stage.js</kbd>: Contains the configuration for the staging phase. This phase is also known as <strong>Quality Assurance</strong> (<strong>QA</strong>).</li>
<li><kbd>prod.js</kbd>: Contains the configuration for the production phase. In this phase, our application is being used by our final users.</li>
</ul>
<p>Let's open the <kbd>dev.js</kbd> file and check the content of the configuration for the development phase:</p>
<pre>export default {<br/>  debug: true,<br/>  testing: true<br/>};</pre>
<p>A configuration file is a simple JSON file. As you can see in the <kbd>dev.js</kbd><em> </em>file, the <kbd>debug</kbd> and <kbd>testing</kbd> attributes are true. It means that while we are developing our application, we will be able to debug and test the application. Let's add a new attribute to see how this works. In the <kbd>dev.js</kbd><em> </em>file, apply the following changes:</p>
<pre>export default {<br/>  debug: true,<br/>  testing: true,<br/>  <strong>appTitle: 'DeployMe [dev]'</strong><br/>};</pre>
<p>Now, let's go ahead and open the <kbd>prod.js</kbd><em> </em>file and see how the application should be configured for production:</p>
<pre>export default {<br/>  debug: false,<br/>  testing: false<br/>};</pre>
<p>In production, we don't need to debug anything, and we don't test our application, so we have to disable debugging and testing and set the value as <kbd>false</kbd>. Let's create the <kbd>appTitle</kbd> attribute, but this time with the correct value for production:</p>
<pre>export default {<br/>  debug: false,<br/>  testing: false,<br/>  <strong>appTitle: 'DeployMe'</strong><br/>};</pre>
<p>Now let's apply the following changes to the <kbd>app.js</kbd> file to read the <kbd>appTitle</kbd> from the environment <kbd>environment.js</kbd> configuration file:</p>
<pre>import <strong>environmentConfig</strong> from './environment'<br/><br/>export class App {<br/>  constructor() {<br/>    <strong>this.appTitle = environmentConfig.appTitle;</strong><br/>  }<br/>}</pre>
<p>Now, let's apply the following changes to the <kbd>app.html</kbd><em> </em>file:</p>
<pre>&lt;template&gt;<br/>  &lt;h1&gt;<strong>${appTitle}</strong>&lt;/h1&gt;<br/>  &lt;p&gt;<br/>    Hello :)!<br/>  &lt;/p&gt;<br/>&lt;/template&gt;</pre>
<p>Once the changes are applied, let's run the application, but this time let's specify the environment in order to see how the application's title changes depending on the environment. Go ahead and run the following command for the development environment:</p>
<pre><strong>$ au run --watch --env dev</strong><br/>  ...<br/> <strong> Application Available At: http://localhost:9000</strong><br/><br/></pre>
<p>Navigate to the <kbd>http://localhost:9000</kbd> in your browser and you should see something similar to the following image:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/452ca39b-d1aa-4d84-a1ec-7b4cb00f7f02.png" style="width:25.17em;height:14.25em;"/></div>
<p>Cool! Now let's run the application, but this time let's change the <kbd>(--env)</kbd> environment flag from <kbd>dev</kbd> to <kbd>prod</kbd> in order to create the production version:</p>
<pre><strong>$ au run --env prod</strong><br/> <strong> ...</strong><br/><strong>  Application Available At: http://localhost:9000</strong></pre>
<p><span>Navigate to the <kbd>http://localhost:9000</kbd> in your browser and you should see something similar to the following image:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/625510b6-dd17-42ae-9337-b7bf344229df.png" style="width:26.67em;height:16.75em;"/></div>
<p>Cool! We are almost done with the production version. Before we deploy our application, we will need to create a minified version of our code. To do so, execute the following command:</p>
<pre><strong>$ au build --env prod</strong></pre>
<p>The preceding command will generate the build scripts into the <kbd>scripts</kbd> folder, which will contain the JavaScript files ready for production. These files are minified in order to improve the load performance in the client browser. We will take the <kbd>dist</kbd> folder and <kbd>index.html</kbd> for the deployment process. Basically, an Aurelia application deployment has the following files architecture:</p>
<pre>./<br/>   - index.html<br/>   - dist/<br/>     - app-bundle.js<br/>     - vendor-bundles.js</pre>
<div class="packt_infobox">Details of the JavaScript files are provided in further details in the Aurelia CLI section of <a href="b9497d63-ff4d-449d-a84c-62e2d66a314b.xhtml" target="_blank">Chapter 1</a>, <em>Introducing Aurelia</em>.</div>
<p>Cool! Let's learn how to deploy our application. Keep reading!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying on your own server</h1>
                </header>
            
            <article>
                
<p>Upto now, we have the production files ready to be deployed. The typical deployment scenario is when you want to deploy your web application on your local server, local computer, or internal corporate server. This is a common practice for big companies that want to manage and have full control on their servers. So, let's learn how to do that using Docker and NGINX as our best allies.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our NGINX configuration file</h1>
                </header>
            
            <article>
                
<p>The only role that NGINX will play in our deployment is to serve as a web server, so we will write a simple configuration file for our server. Go ahead and create the <kbd>default.conf</kbd> file in the project root folder:</p>
<pre>server {<br/>    <strong>listen 80</strong>;<br/>    server_name localhost;<br/><br/>   <strong> location / {</strong><br/><strong>        root /usr/share/nginx/html;</strong><br/><strong>        index index.html index.htm;</strong><br/><strong>    }</strong><br/><br/>    error_page 500 502 503 504 /50x.html;<br/>}</pre>
<p>Let's understand what this configuration file does. First, we tell NGINX to <kbd>listen</kbd> on port <kbd>80</kbd>. It means that when we want to access our application, we should call to this port. Secondly, we define the path where NGINX will find our application files. We will have to copy the <kbd>scripts</kbd> folder and <kbd>index.html</kbd> file into this folder.</p>
<p>Cool! We have the NGINX configuration file for our application web server. Let's continue with the <kbd>Dockerfile</kbd> file setup.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating our Dockerfile</h1>
                </header>
            
            <article>
                
<p>Our <kbd>Dockerfile</kbd> contains the receipt to build a Docker image with all the configuration we need to start our NGINX web server and also will contain the web application that has to be copied inside the container. Go ahead and create the <kbd>Dockerfile</kbd><em> </em>file in the project root folder:</p>
<pre>FROM nginx:alpine<br/><br/>COPY default.conf /etc/nginx/conf.d/default.conf<br/><br/>COPY index.html /usr/share/nginx/html/index.html<br/>COPY dist /usr/share/nginx/html/scripts</pre>
<p>Yeah, that's all! This is a simple Docker file that uses <kbd>nginx:alphine</kbd> as its base image. We <kbd>COPY</kbd> the <kbd>default.conf</kbd><em> </em>file, which contains the NGINX configuration file, and, finally, we <kbd>COPY</kbd> our web application files.</p>
<p>That's it! let's build our Docker image and run our very first container.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Running our application on Docker</h1>
                </header>
            
            <article>
                
<p>Before we can run our application, we will need to create a Docker image using our <kbd>Dockerfile</kbd>. Open a new Terminal and navigate to the project root folder. Once you are there, run the following command to build our Docker image:</p>
<pre><strong>$ cd /some/path/deployme</strong><br/><strong>$ docker build -t mydeploymeapp .<br/><br/>Sending build context to Docker daemon 130.9MB</strong><br/><strong>Step 1/4 : FROM nginx:alpine</strong><br/><strong>Digest: sha256:17c4704e19a11cd47545fa3c17e6903fc88672021f7f907f212d6663baf6ab57</strong><br/><strong>Status: Downloaded newer image for nginx:alpine</strong><br/><strong> ---&gt; 91ce6206f9d8</strong><br/><strong>Step 2/4 : COPY default.conf /etc/nginx/conf.d/default.conf</strong><br/><strong> ---&gt; 0e744f0e2556</strong><br/><strong>Step 3/4 : COPY index.html /usr/share/nginx/html/index.html</strong><br/><strong> ---&gt; 092ad92d0d5c</strong><br/><strong>Step 4/4 : COPY scripts /usr/share/nginx/html/scripts</strong><br/><strong> ---&gt; 6d097542eec5</strong><br/><strong>Successfully built 6d097542eec5</strong><br/><strong>Successfully tagged mywebapp:latest<br/></strong></pre>
<p>We use the <kbd>docker build</kbd> command to build a new image. The <kbd>-t</kbd> option allows us to give our image a name, in this case, our image is called <kbd>mydeploymeapp</kbd>. Pay attention to the period (<kbd>.</kbd>) in the last command argument; the <kbd>docker build</kbd> command uses a <kbd>Dockerfile</kbd> to build the new image. We specify the path of this <kbd>Dockerfile</kbd> in the last option of the command; as this file is in the root folder where we are running <kbd>docker build</kbd>, we should use the <em>period</em> symbol to specify the current folder, which in this case contains the <kbd>Dockerfile</kbd>.</p>
<p>Once the build process is finished, we will have the <kbd>Successfully built</kbd> message.</p>
<p>Now we are ready to start our application. Go ahead and run the following command to start a new <kbd>mydeploymeapp</kbd> Docker container:</p>
<pre><strong>$ docker run -p 8000:80 mywebapp</strong></pre>
<p>We used the <kbd>docker run</kbd> command to start a new container and pass the <kbd>-p</kbd> option to map our host <kbd>8000</kbd> port to the NGINX <kbd>80</kbd> port, which is listening inside the container. The last argument is the Docker image that we want to create, in this case, our application's image.</p>
<p>Cool! Our application is up and running. Let's navigate to <kbd>http://localhost:8000</kbd> and you should see the following page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/73cb37c5-20d4-4925-8c3e-97db70d11309.png" style="width:25.42em;height:12.92em;"/></div>
<p>That's it! We have successfully deployed our Aurelia application on our local server using Docker and NGINX. You can install Docker on your remote server and follow the same steps we did in this section to install any Aurelia application.</p>
<p>Let's learn in the following sections how to deploy apps to the cloud. Keep reading!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying on Heroku</h1>
                </header>
            
            <article>
                
<p>It's time to take advantage of the cloud and start looking for new approaches. In this section, we will see how to deploy our Aurelia example application to Heroku. We will follow the next steps in order before we start the deployment process:</p>
<ol>
<li>Create a Heroku account</li>
<li>Prepare our application</li>
<li>Deploy</li>
</ol>
<p class="mce-root">Let's start with the very first step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating a Heroku account</h1>
                </header>
            
            <article>
                
<p>Navigate to <a href="https://heroku.com">https://heroku.com</a> and click on the <span class="packt_screen">SIGN UP FOR FREE</span> button. Then, fill the form with your account information. Once you are ready, we will need to install the Heroku CLI. This CLI will provide us with an easy-to-use command-line tool that we will use to deploy our applications and perform other administration operations on our applications.</p>
<p>To download the Heroku CLI, navigate to <a href="https://devcenter.heroku.com/articles/heroku-cli">https://devcenter.heroku.com/articles/heroku-cli</a>. Select your operating system and follow the installation instructions. Once the installation finished, go ahead and open a new Terminal window and execute the following command to log in to your Heroku workspace:</p>
<pre><strong>$ heroku login</strong><br/><br/><strong>  Enter your Heroku credentials:</strong><br/><strong>  Email: erikson.murrugarra@gmail.com</strong><br/><strong>  Password: ***************</strong><br/><strong>  Logged in as erikson.murrugarra@gmail.com</strong></pre>
<p>The preceding command will ask you for your <kbd>email</kbd> and <kbd>password</kbd> that you used in the signup process. Provide your credentials and if everything is correct, you will receive the <kbd>Logged in as ...</kbd> message.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Preparing the application</h1>
                </header>
            
            <article>
                
<p>Heroku, just like other cloud providers, does not offer any way to deploy static HTML files, so we will need to deploy our application using another strategy. We will create a simple PHP file that will serve as the entry point that will have one line of code to import our <kbd>index.html</kbd> file:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8cef1900-ce47-43c8-a146-7b339b9812d2.png" style="width:13.42em;height:14.75em;"/></div>
<p>Now, in the <kbd>dist</kbd> folder, go ahead and create the <kbd>index.php</kbd><em> </em>file with the following content:</p>
<pre>&lt;? <br/>  include_once("index.html");</pre>
<p>We use the <kbd>invoke_once</kbd> function to import the <kbd>index.html</kbd> page as the main page.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploy</h1>
                </header>
            
            <article>
                
<p>Once we have our application static files and our <kbd>index.php</kbd><em> </em>entry point file, let's create a new Heroku application. Navigate to the <kbd>dist</kbd> folder and <kbd>init</kbd> a new Git repository running the following commands:</p>
<pre><strong>$ cd dist</strong><br/><strong>$ git init</strong><br/><strong>$ git add .</strong><br/><strong>$ git commit -m "My Application commit"</strong></pre>
<div class="packt_infobox">We use git add following by a period (.) to add all the files to the staging area. It means all the changes will be candidates to commit.</div>
<p>Once we have our local git repository, let's create a new Heroku application named <kbd>mydeploymeapp</kbd>. Execute the following command:</p>
<pre><strong>$ heroku apps:create deploymeapp</strong><br/><br/><strong>  Creating <img src="assets/ec09ec8a-6a1d-4cf7-b546-6fd7e06d8c15.png" style="width:0.92em;height:0.92em;"/> deploymeapp... done</strong><br/><strong>  https://deploymeapp.herokuapp.com/ | https://git.heroku.com/deploymeapp.git</strong></pre>
<p>We use the Heroku CLI tool and call the <kbd>apps:create</kbd> option to create a new application. You have to change the application's name, because they should be globally different from other app's names. Once created, Heroku will respond with the application's URL.</p>
<p>Now that we have our application created, let's push the code to the Git repository created by Heroku to host our application's code and see the results. Execute the following command:</p>
<pre><strong>$ git push heroku master</strong><br/><br/><strong>Counting objects: 3, done.</strong><br/><strong>...</strong><br/><strong>remote:</strong><br/><strong>remote: -----&gt; PHP app detected</strong><br/><strong>remote:</strong><br/><strong>...</strong><br/><strong>done.</strong><br/><strong>To https://git.heroku.com/mydeploymeapp.git</strong><br/><strong>   15cb66e..72d4d2a master -&gt; master</strong></pre>
<p>As you can see, Heroku will recognize automatically that we are deploying a PHP application, and it will deploy our application. Let's go ahead and navigate to your application's URL; mine is <a href="https://mydeploymeapp.herokuapp.com">https://mydeploymeapp.herokuapp.com</a>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9a55aa39-6ce6-4618-ab1b-30121dcc2d3e.png" style="width:35.83em;height:14.17em;"/></div>
<p>Awesome! Now that we know how to deploy our application on the <em>cloud</em> using Heroku, let's explore how can we do this with another very popular cloud provider. We will learn how to deploy our website using <strong>Amazon Simple Storage Service</strong> (<strong>Amazon S3</strong>). Keep reading!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deploying on AWS S3 Buckets</h1>
                </header>
            
            <article>
                
<p>AWS is one of the biggest cloud providers across the globe. We will learn how to deploy our Aurelia application using AWS S3. Yes, I am not crazy! We will deploy our application without installing any server or <strong>Elastic Cloud Compute</strong> (<strong>EC2</strong>) virtual machine instance.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Uploading files</h1>
                </header>
            
            <article>
                
<p>Before we start the process, you will need to have an account on AWS. Navigate to the following URL to create your free account—<a href="https://aws.amazon.com">https://aws.amazon.com</a>.</p>
<p>Once you are done with the registration process and are logged in to the AWS console, go ahead and navigate to the S3 service dashboard, as shown:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f5aeb44e-a554-4839-9e35-ebbe5451f5e2.png"/></div>
<p>Once the S3 dashboard is loaded, you will see the list of all the your AWS buckets that you created before. If not, you will see an empty list. Click on the <span class="packt_screen">Create Bucket</span> button to create a new bucket and name your bucket with your application's name and click on the <span class="packt_screen">Next</span> button to accept the defaults:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8df2045a-a195-40aa-ba36-71b0f69b8a4d.png"/></div>
<p>Once created, you should see the new S3 bucket in the list:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/5c642963-24e9-4667-9aff-92b0bedd4721.png"/></div>
<p>Now get into your bucket, and let's upload the <kbd>index.html</kbd> file to the bucket by clicking on the <span class="packt_screen">Add files</span> button and selecting the file. Don't forget to grant public read permission when you are submitting the files:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/133f129c-b53d-4609-92f1-00dce5375fe4.png"/></div>
<p>Once we have selected our web application files that we want to deploy in S3, we should make these files public so that S3 will be able to serve the file publicly, otherwise our users won't be able to access our web application files. To do so, select the <span class="packt_screen">Grant public read access to this object(s)</span> option in the <span class="packt_screen">Manage public permissions</span> drop-down list, as illustrated:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/2b7a8aa5-ef42-430e-a926-1dca8549d218.png"/></div>
<p>Cool! To upload the contents into the <kbd>script</kbd> folder, you will need to create a folder for scripts in the bucket. To do this, just click on the <span class="packt_screen">Create Folder</span> button. Once you have the folder created, go ahead and upload the <kbd>app-bundle.js</kbd> and <kbd>vendor-bundle.js</kbd> files into the S3 scripts folder (don't forget to grant public permission).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Configuring our S3 Bucket for the web</h1>
                </header>
            
            <article>
                
<p>Let's configure our bucket to act as a website bucket. Before we do that, let's access our <kbd>index.html</kbd> file from our web browser. To do this, select the <kbd>index.html</kbd> page and let's copy the URL besides <span class="packt_screen">Link</span> that appears in the object settings panel:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3ef10624-98b9-445f-ac6a-cae49d375cd6.png"/></div>
<p>Navigate to the link provided, and you should see your web application up and running:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1c59a10d-6947-4953-b307-9ab32db4d535.png" style="width:64.25em;height:41.92em;"/></div>
<p>There is one last step we should do. First, note that the URL is not friendly, and we are accessing our web using the <kbd>index.html</kbd> file. This is not the right way to deploy a web application on Amazon S3. Let's configure our bucket to explicitly make it a web bucket.</p>
<p>Let's navigate to the <span class="packt_screen">Properties</span> tab in our bucket and select the static web hosting option. Select the <span class="packt_screen">use this bucket to host a website</span> option, type <kbd>index.html</kbd> as the index page, and click on <span class="packt_screen">Save:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/42e78396-2b9e-4723-a559-c50b7a020f5c.png"/></div>
<p class="mce-root">Cool! Now we are ready. Copy the new URL provided by AWS and navigate to it to see the web application up and running:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ed276f28-c1ec-4478-8ed8-22b3bda4c13f.png"/></div>
<p>Awesome! You are ready to deploy your applications on AWS using S3 buckets without the need to provide any virtual server. Congratulations!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this final chapter of the book, you learned how to deploy web applications on self-managed or on-premise servers and also how to take advantage of the cloud.</p>
<p>You learned how to use Docker to deploy applications. Using Docker will help you in all the phases of development, so we strongly encourage you to buy a Docker book and start learning about it right now!</p>
<p>We also covered how to deploy applications on top of Heroku. Heroku is a <strong>Platform as a Service</strong> (<strong>PaaS</strong>) that will manage and monitor your applications for you. So you don't have to worry about infrastructure; you just need to worry about creating awesome applications.</p>
<p>Finally, you came across how to deploy applications using AWS S3 buckets to deploy applications without any virtual server configuration.</p>
<p>Aurelia is becoming very popular and is being adopted by important organizations; this is the right time to become an expert and be ready for the revolutionary future in which Aurelia will play a very important role. On the other hand, you only have a little bit  of knowledge about Docker and cloud computing. We encourage you to explore more about these technologies, which are extremely important in the IT world. </p>
<p>Having said that, we wish you the best in your next adventure.</p>


            </article>

            
        </section>
    </body></html>