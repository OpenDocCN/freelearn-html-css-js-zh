- en: '5'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Framework Considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapters, we primarily focused on learning from other framework
    projects to prepare for building our full stack JavaScript framework, which will
    include the ability to create backend infrastructure and frontend interfaces and
    will have capabilities to test both sides of these features. Even though our goal
    is a full stack framework for application development, you will be able to use
    what you learned from this experience and apply it to similar JavaScript projects.
    Existing projects’ architectural patterns and design decisions will help us orient
    our project and set it up for success. In this chapter, we will study three factors
    to consider when we plan out our framework that are useful for aspiring software
    architects and those considering being the responsible individuals behind larger
    technical project decisions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Items to cover for the purposes of our framework considerations are set out
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Determining project goals**: Focusing on what you are building and who will
    be the main consumer and patron of the framework’s APIs'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Identifying framework problem spaces**: Aligning with the problem space of
    the new framework you are developing'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Technical design decisions**: Factors such as the technological stack, architecture,
    and development approach that shape your framework’s uniqueness from other projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter and generally in this book, we are considering an educational
    approach to framework building, which means that future chapters will cover the
    development of specific kinds of JavaScript frameworks, focusing on web application
    systems. However, you can utilize the gathered knowledge to build a framework
    that satisfies your particular needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image will help us focus on the consideration categories and
    highlights particular subsections that are useful to know as part of the planning
    and development cycles:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1: Framework development pillars](img/Figure_5.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5.1: Framework development pillars'
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The technical requirements are similar to the preceeding chapters. Use the `chapter5`
    directory from the book's repository to run `npm install` and then `npm start`
    to quickly get started with the code and samples that are mentioned in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Determining project goals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While contemplating building a new framework, you must identify your project’s
    objectives and stakeholders. These two factors are the main drivers behind your
    time and investment into building something new. Embarking on a new framework
    project requires understanding potential motivators and a clear insight into the
    goals, emphasizing the developer you support and their needs. These reasons can
    range from internal work use cases to open source hobby projects. Your scenario
    may very well differ but based on *Figure 5**.1*, we can explore the first pillar—*project
    goals*—as part of this section.
  prefs: []
  type: TYPE_NORMAL
- en: Context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Comprehending the context of a project is fundamental to guiding its development
    and ensuring it meets the needs of its intended users. The context involves assessing
    factors such as the project’s purpose, target audience, and the environments in
    which it will be used. Two contexts for framework projects are along the following
    themes:'
  prefs: []
  type: TYPE_NORMAL
- en: Work-related company-backed initiatives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Public open source projects, often with an educational or hobby nature
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each of these scenarios comes with its distinctive set of necessities and considerations.
  prefs: []
  type: TYPE_NORMAL
- en: Frameworks developed for particular business needs could have business objectives
    ranging from small start-up environments to large enterprises. Professional use
    cases, contextualized in building a framework for business needs, can drastically
    vary. For instance, similar to the initial development of the React library, a
    project can support a single platform such as Facebook. However, business needs
    can also include developing a framework for repeating use cases, such as deploying
    multiple services with the same core architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Hobby/open source projects can grow from **proofs of concept** (**PoCs**) or
    learning materials to widely used tools across the software industry. These are
    usually not monetarily impactful, but they can serve as a growth tool for your
    career and practical knowledge. Focus on expanding your skill set in particular
    software development and JavaScript knowledge areas.
  prefs: []
  type: TYPE_NORMAL
- en: It is a good idea to determine and align the project’s goals for your new framework
    before writing any code. If your project focuses on internal company use cases,
    such as supporting internal company products, then the goals are more tailored
    toward enhancing efficiency, improving collaboration, and streamlining the development
    process. Ultimately, all the planning and building support the main core goal—enabling
    the organization to ship higher-quality and more reliable projects faster.
  prefs: []
  type: TYPE_NORMAL
- en: Once your framework progresses, the context can potentially alter into something
    new. For example, if the framework was initially started as an internal project,
    further down the road, you could open source it and leverage the input from other
    developers who are not directly associated with it. It can also work the other
    way—a framework started as a hobby project could be picked up for internal professional
    use with new investment supported by commercial clients. Both of these scenarios
    are quite common in the software development industry.
  prefs: []
  type: TYPE_NORMAL
- en: Stakeholders
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The target audience and stakeholders of your project are your framework’s customers.
    They are the ones that expect an easy-to-use system with adequate programming
    interfaces. Catering to their needs and expectations is vital for the success
    of your framework. These users are looking for a system that is easy to use and
    provides efficient programming interfaces, allowing them to develop applications
    and services with ease and agility.
  prefs: []
  type: TYPE_NORMAL
- en: To create a framework that appeals to your target audience, your investment
    into stakeholder support is essential to ensure that the developer experience
    is intuitive and user-friendly. Stakeholder support involves designing clear,
    well-organized resources and providing example code and use cases that solve everyday
    problems. Often, you will need to offer support to your stakeholders directly
    or through other means. You will encourage adaptation by making it easier for
    developers to understand and navigate your framework.
  prefs: []
  type: TYPE_NORMAL
- en: The robust programming interfaces that cater to the diverse needs of your audience
    also play an important role. By offering practical, adaptable, and efficient tools,
    you will empower your users to tackle their projects confidently and foster a
    sense of trust and loyalty toward your framework.
  prefs: []
  type: TYPE_NORMAL
- en: As a framework developer, remember that your audience’s needs and expectations
    should be at the forefront of your design process, so your aim should be to deliver
    a user-centric experience that stands out in the competitive landscape and becomes
    an invaluable asset to developers and stakeholders.
  prefs: []
  type: TYPE_NORMAL
- en: In the context of this book, the framework has the reader as the stakeholder,
    focusing on educational materials. If you are following along and creating your
    own framework, consider yourself the stakeholder. This makes things much easier;
    you have the freedom to alter and change the pathway of your framework.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we look at several other considerations that could be beneficial
    to reflect upon before you start coding.
  prefs: []
  type: TYPE_NORMAL
- en: Other considerations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Additional project considerations in framework development are very similar
    to those of a small or large team developing software projects. Helpful questions
    to consider as part of determining if your project needs to exist and should be
    built are along the following themes:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The general purpose of the framework**: This is derived from the core objectives;
    you should have a clear understanding of the primary reasons to deliver your project,
    identifying specific software-related problems and aiming to solve them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Survey of existing tools**: Before building something new from scratch, evaluating
    projects already in the ecosystem is a good idea. This consideration will help
    you make a decision to internally use some of the tools or extend them to fit
    your needs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance costs**: Depending on the size of resources to address your framework’s
    problem space, you need to understand time and money investments into the project.
    Projecting this will help you allocate resources appropriately and ensure the
    project’s long-term sustainability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Innovative and distinctive features**: Identify unique selling points and
    advantages that your framework will offer compared to existing solutions in the
    ecosystem. This could include advanced functionality, enhanced performance, or
    unexplored approaches to solving typical problems.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resourcing**: Assess your development team’s skills, expertise, and availability,
    and identify any gaps that may need to be addressed. This could involve hiring
    new team members or seeking external support to ensure the successful development
    of the framework. In some cases, you could be the only resource powering the development
    of this project. This comes with the advantages of efficient design making but
    puts you in the driving seat for the whole project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Roadmap**: Develop a comprehensive roadmap outlining project milestones and
    feature support. By spending time on this, you can provide a clear vision for
    the development process and help keep the project on track while communicating
    the framework’s direction to its stakeholders.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Timeline**: Determine how much time you invest in the framework. This involves
    setting realistic deadlines for each project stage and considering potential risks
    and obstacles that may impact the timeline. By establishing a well-defined timeline,
    you can ensure that the project progresses efficiently and focuses on delivering
    value to its intended audience.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All the considerations mentioned in this section can contribute to your development
    process. Spending a little time figuring out the answer to all these considerations
    could greatly benefit your project. A lot of these considerations will depend
    on the problem space of your framework. To help handle this, we will cover potential
    problem spaces in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Identifying framework problem spaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Frameworks are designed to support the development of one or many projects,
    focusing on solving a particular problem space. We define a problem space as a
    set of challenges or a range of problems that the framework is prepared to address;
    this is the second pillar from *Figure 5**.1*. A problem space can be a specific
    software application area in which the framework is intended to be used.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw from examples of frameworks in previous chapters of this book, JavaScript
    has a broad reach in client and server environments. It enables us to build frameworks
    to fit our needs and technological requirements. For your brand new project, you
    could potentially be tackling a particular framework category. By focusing on
    the technical aspects of a unique project, combined with innovative features,
    you can make your project different from what is already available out there in
    the wild.
  prefs: []
  type: TYPE_NORMAL
- en: Popular problem spaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Here are some potential development paths you could take in the JavaScript
    framework problem space:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Frontend frameworks**: Focused on building frontend applications’ frameworks,
    you can find ways to utilize the latest browser technologies to develop unique
    rendering techniques and improve on state management. Given that this is a popular
    category of frameworks with many existing solutions, a more straightforward approach
    is to write your own abstractions on top of these existing solutions—for example,
    internally using a project such as Vue.js while developing your own self-developed
    framework interfaces. This way, you can approach your problem space, focusing
    on its challenges and solving them instead of reinventing the basics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Browser-focused solutions**: Similar to the previous point, you could take
    the approach of building browser-focused solutions, different from frameworks
    focused on web application development, and concentrate on utilizing new technologies
    available to web browsers. For instance, you could leverage WebAssembly ([webassembly.org](https://webassembly.org))
    or WebGPU ([w3.org/TR/webgpu](https://w3.org/TR/webgpu)) to develop unique frameworks
    in the client-side environment.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Backend applications**: If you are building a new JavaScript framework for
    backend development, it is important to focus on reliability, scalability, and
    security features. You could start by looking over the examples from this book
    or elsewhere on the internet, then build a framework that addresses common backend
    challenges, such as working with certain types of databases, enabling different
    types of authentication, and rapid API development techniques.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Testing**: If you are building a new testing framework for JavaScript applications,
    you could focus on providing a simple and intuitive interface for writing and
    running tests. You could also enable built-in support for popular testing frameworks
    and libraries and integrations with continuous integration tools. You could also
    provide advanced testing features such as visual regression testing, unique parallelization
    and grouping techniques, and pattern-matching-powered test automation. In [*Chapter
    6*](B19014_06.xhtml#_idTextAnchor089) of this book, we will start developing a
    simple testing framework, while focusing on the learning process; it is a good
    contender for a simpler type of framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Native applications**: By building a new framework for native applications,
    you could focus on providing components and APIs that make creating responsive
    and high-performance applications easy. Often, these systems offer built-in support
    for mobile and desktop features, such as camera access, push notifications, and
    integration with native operating system features. This type of framework is challenging
    to develop due to the number of environments you have to support. Though, as we
    have seen examples in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015) and [*Chapter
    2*](B19014_02.xhtml#_idTextAnchor030), with React Native and Electron, these kinds
    of projects are not impossible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Embedded solutions**: This type of framework would focus on providing a simple
    and easy-to-use interface for programming and interacting with hardware devices.
    To create one of these, you must develop APIs for standard sensors and devices.
    These include working with external chipsets, motors, GPS, and Bluetooth accessories.
    The main focus behind this framework would be to create a unique approach to reduce
    memory and processor usage, as you are targeting embedded instruments. This is
    a more complex challenge with JavaScript, even though there have been many projects
    in the past that allowed the runtime to interact with embedded devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We explored several examples of more popular JavaScript frameworks in the previous
    chapters. However, JavaScript’s versatility extends beyond those we’ve already
    discussed. The language can enable you to build new framework projects that cater
    to other niches. JavaScript has become ubiquitous in modern web development, allowing
    developers to build robust and feature-rich applications.
  prefs: []
  type: TYPE_NORMAL
- en: Other framework pathways
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are many other types of projects that JavaScript allows us to build;
    they all have their own considerations. In no particular order, let’s take a look
    at more framework development pathways:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Game development**: As JavaScript is the only target runtime available to
    the web browser, it ends up being the only solution for building games. Your JavaScript
    game development framework can provide tools and utilities that make it easy to
    build 2D or 3D games for web and mobile platforms. These utilities could include
    built-in support for physics engines, animation, and audio. In such a scenario,
    the framework could concentrate on providing advanced features, such as multiplayer
    support or virtual reality integration, as those features become more popular.
    Some popular JavaScript game development frameworks include Phaser, Pixi.js, PlayCanvas,
    and Babylon.js. Even though game development frameworks have specific requirements
    related to rendering and performance, you can still use knowledge from this book
    to structure this type of framework.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Computation**: A new framework for computation and data science could potentially
    perform scientific computing and data analysis tasks. You could focus on providing
    a set of APIs for performing mathematical operations and working with data. This
    framework could have built-in support for popular data visualization libraries
    and statistical analysis tools. The potential for JavaScript computation frameworks
    is in the frontend presentation and backend computation layers. A single framework
    can combine both of those possibilities.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visualization**: Similar to the computation theme, there is room for better
    JavaScript data visualization frameworks. In visualization projects, you could
    focus on providing a set of tools and components for creating interactive and
    dynamic visualizations. You could also integrate with visualization libraries
    such as D3.js and explore advanced features such as real-time data streaming.
    As this niche is developing, you can find new ways to render and interact with
    information from many data sources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Artificial intelligence**: If you decide to develop a JavaScript framework
    for AI and **machine learning** (**ML**), you should prioritize providing a comprehensive
    set of APIs for building and training neural networks. Consider basing your framework
    on widely used ML APIs and libraries, such as TensorFlow.js ([tensorflow.org/js](https://tensorflow.org/js)).
    The features of such a framework could include interoperability with various types
    of ML formats and configurations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User interface (UI)**: A framework built around constructing UIs could be
    helpful for a different feature set from regular frontend applications. It could
    include capabilities for customizable components and responsive UIs. Innovative
    features could consist of styling and theming components utilizing modern CSS
    features. The framework could integrate with external libraries such as Tailwind
    CSS, Material UI, Bootstrap, and so on. Building a UI framework can be advantageous
    if you work in marketing or design-related environments.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on your framework goal, these are some potential framework pathways.
    In previous chapters of the book, we have covered the ins and outs of some classes
    of these frameworks in detail. This is not an exhaustive list of possible solutions
    within a JavaScript environment, but it showcases the many possibilities. The
    most popular and competitive category of frameworks is related to building frontend
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have a clearer vision of the problem space, in the next section,
    we can proceed to considerations with regard to the technical architectures of
    framework projects.
  prefs: []
  type: TYPE_NORMAL
- en: Technical architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections of this chapter, we identified our stakeholders—those
    who will directly benefit from our framework project. We also identified potential
    problem spaces. Those two factors give us a solid idea of what we want to build.
    In this section, we explore the third pillar from *Figure 5**.1*—*technical architecture*—to
    give us a focused look at the technical specificities of our planned project.
  prefs: []
  type: TYPE_NORMAL
- en: Abstraction levels and flexibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The importance of practical abstraction levels and allowing flexibility in code
    APIs of a JavaScript framework is an important design decision. As you develop
    your frameworks, these two principles are necessary to ensure the framework’s
    usability, maintainability, and adaptability.
  prefs: []
  type: TYPE_NORMAL
- en: As explored in [*Chapter 2*](B19014_02.xhtml#_idTextAnchor030), sensible abstraction
    levels are essential for providing developers with clean, easy-to-understand interfaces.
    The encapsulated complexities of the underlying implementation improve productivity
    and minimize the risk of errors as developers work with a higher-level, more intuitive
    API that shields them from unnecessary complexity.
  prefs: []
  type: TYPE_NORMAL
- en: The sensible abstraction levels promote modularity and reusability of code,
    as the framework’s features can be more easily connected and adapted to varying
    circumstances. Providing a level of modularity enables developers to build upon
    existing modules, fostering a developer-driven ecosystem of extensions that further
    enhance the framework’s capabilities. By striking the right balance between abstraction
    and flexibility, a JavaScript framework can cater to various projects, from small-scale
    to complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: Allowing flexibility in code APIs is another critical aspect of a successful
    JavaScript framework. A flexible API accommodates different coding styles, paradigms,
    and use cases, enabling developers to tailor their approach to suit their unique
    requirements. This adaptability is essential in the fast-paced world of web development,
    where new tools, libraries, and patterns are constantly emerging. By offering
    a versatile API, a JavaScript framework can remain relevant and valuable in the
    face of these evolving trends.
  prefs: []
  type: TYPE_NORMAL
- en: One potential pitfall of abstraction is the creation of highly opinionated abstractions
    that impose strict constraints on how developers can use the framework. While
    abstractions can streamline specific use cases, they may hinder the framework’s
    overall flexibility and limit its applicability to a broader range of projects.
    If you would like to build a less opinionated framework, consider providing your
    stakeholders with expandable options, such as using different templating engines
    or various ways of managing state within built applications.
  prefs: []
  type: TYPE_NORMAL
- en: Striking the right balance between abstraction and flexibility, and avoiding
    overly opinionated abstractions, will help you craft a versatile and enduring
    JavaScript framework.
  prefs: []
  type: TYPE_NORMAL
- en: Environment compatibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: JavaScript runs in diverse environments, including browsers, servers, mobile
    devices, and other unique hardware, each with unique characteristics, making compatibility
    a pressing factor in any framework’s success. Determining the runtime environment
    compatibility of your framework is about figuring out which runtimes to support
    and maintain. Generally, in JavaScript frameworks, it is about the time and technological
    investment choice of frontend and backend features. This includes browser-specific
    APIs and compatibility with different backend systems. Besides frontend and backend
    systems, JavaScript is supported in many other environments.
  prefs: []
  type: TYPE_NORMAL
- en: Framework developers face a significant challenge in ensuring compatibility
    with multiple JavaScript environments and the specific quirks of those environments.
    At a high level, this includes different types of browser engines and compatibility
    with different module systems. This task requires careful consideration and design
    decisions to ensure the framework works seamlessly across all targeted runtimes.
  prefs: []
  type: TYPE_NORMAL
- en: The first design decision is about configuring compatibility for the appropriate
    JavaScript environment. Developers must consider the target environment for the
    framework and ensure that it is compatible with the chosen setting. For instance,
    if the framework is designed for web applications, the developers must ensure
    it works seamlessly across multiple browser versions and APIs. Incompatibilities
    may arise due to variations in browser capabilities, leading to problems such
    as inconsistent rendering or unresponsive applications.
  prefs: []
  type: TYPE_NORMAL
- en: Another significant consideration when developing a new JavaScript framework
    is handling environment differences. Writing extra code-compatibility layers is
    valuable for minor and significant runtime differences. Handling runtime differences
    includes investing time in backward compatibility for both older browsers and
    older versions of server-side runtimes. In general, supporting multiple frontend
    JavaScript environments takes different versions of the same browser environment.
    For example, many browsers, such as Firefox, have various versions, and each version
    may have unique capabilities or features. Developers must ensure the framework
    is designed to handle these variations and provides optimal performance and functionality
    regardless of the browser version.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, you must handle cross-runtime compatibility to enable server-side
    rendering or Node.js testing of frontend components. JavaScript server environments
    may require specific deliberations when building frameworks. They may have different
    APIs than browsers, and some features, such as the DOM, may not be available.
    Thus, developers must ensure that the framework is designed to handle such variations
    and provides optimal performance in server environments. Framework developers
    include JavaScript polyfills and similar code snippets, providing a fallback mechanism
    for new and missing features in other environments. These are essential when building
    a new framework that should work across multiple domains.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring compatibility with multiple JavaScript environments requires additional
    thorough testing during framework development and maintenance. Testing is essential
    in identifying and resolving compatibility issues early in the development cycle.
    For instance, we can use the automated testing tooling we saw in the previous
    chapter to test the framework on various browser versions and mobile devices to
    identify compatibility issues. Including these tests helps to ensure that the
    framework delivers optimal performance and functionality across all targeted environments.
    However, testing through all possible runtime use cases and quirks can be challenging,
    and running a test on all configurations your framework will be used in is impossible.
    Fortunately, compatibility issues significantly reduced as JavaScript runtimes
    matured. If you are developing a framework outside the browser, something similar
    to Electron or React Native, you have further challenges. You must ensure the
    framework is compatible with the multiple operating systems that you are designing
    your project for. For example, the operating system runtimes may have different
    capabilities, affecting the framework’s feature set.
  prefs: []
  type: TYPE_NORMAL
- en: Overall, you are able to define the supported JavaScript environments and take
    control of the types of runtimes you support in your framework, knowing that compatibility
    with multiple JavaScript environments requires continuous maintenance and updates
    to your project. This maintenance includes compatibility with new browser versions
    or server environments that tweak their capabilities or add new features.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing libraries
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It makes sense to commit to specific JavaScript libraries before developing
    a new framework. The use of existing JavaScript libraries will save you time—time
    you can use to focus on the framework’s features and technical architecture. It
    is a common pattern for frameworks to rely on libraries to build out the internals.
    These libraries often indirectly enable the framework feature set behind the scenes,
    including features such as data management, routing, interacting with the DOM,
    and abstracting away JavaScript runtime complexity. As the framework covers a
    more extensive feature set and shapes the development experience, the internal
    libraries focus on delivering a precise solution to a particular problem.
  prefs: []
  type: TYPE_NORMAL
- en: Choosing the right set of libraries can significantly impact the development
    process and the shape of your framework. The libraries you utilize in your framework
    will likely make you an expert user of them. However, balancing the benefits of
    using libraries with potential downsides, such as compatibility problems, API
    restrictions, and ongoing maintenance, is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we explore other JavaScript frameworks, we can identify libraries they rely
    on for specific functionality. Depending on the architecture, your framework can
    build the library right into the framework or use it to extend aspects of your
    framework. If we look at Angular, we will find that it utilizes `BookService`
    service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses the `Observable` class to return the `getWeather` function
    first. From within your Angular classes, you can rely upon RxJS to provide many
    data-operating operators. In addition, the RxJS library provides error-handling
    operators, as seen in the `retry` call in the preceding code. A detailed explanation
    of the library’s operators can be found at [rxjs.dev/guide/operators](https://rxjs.dev/guide/operators).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the RxJS example
  prefs: []
  type: TYPE_NORMAL
- en: The `chapter5` directory in the book repository includes an example of using
    Angular with the RxJS library. You can try this out on your own computer by running
    the interactive script from the chapter directory or executing `npm install`,
    and then `npm run dev` from the `angular-rxjs` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The example application will utilize the `BookService` service presented previously
    to fetch data. The API data comes with additional properties that you can use
    to extend the existing application. Refer to the `README.md` files for additional
    information.
  prefs: []
  type: TYPE_NORMAL
- en: In another example of library usage, Vue.js initially used **Vuex** as a library
    for centralized state management. However, as the framework developed, the approach
    to managing the state changed. Vue has switched over to recommending and utilizing
    **Pinia** ([pinia.vuejs.org](https://pinia.vuejs.org)) for state management. With
    an intuitive approach based on the Flux architecture, the library closely related
    to Vue, it allows developers to use multiple stores to manage states, enables
    extensibility, and is much more closely aligned with the framework’s features.
    Another example that we have seen in [*Chapter 1*](B19014_01.xhtml#_idTextAnchor015)
    is Next.js, which uses the React library for rendering and other features. Next.js
    focuses on using primitives provided by React to abstract away complexities when
    using the library directly.
  prefs: []
  type: TYPE_NORMAL
- en: As you introduce libraries into your framework, be smart about choosing them.
    Often, it is more effortless to abstract away direct access to the libraries for
    the users of your framework. Otherwise, you must support particular library APIs
    in your framework, locking you into a specific coding pattern. Historically, Ember.js
    had to spin up an effort to decouple the framework from its usage of the jQuery
    library. This type of migration meant providing an update path for projects trying
    to keep up with the latest versions of the framework.
  prefs: []
  type: TYPE_NORMAL
- en: As your framework develops, you will find great benefits in the ecosystem of
    JavaScript libraries. The challenge will be keeping up with the developing nature
    of these projects as the target runtime evolves.
  prefs: []
  type: TYPE_NORMAL
- en: Compiler tooling
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In *Chapters 3* and *4*, we examined instances of framework development patterns.
    These patterns included the use of compilers and other build tools for the purposes
    of framework development and structure. There’s no question that the tools utilized
    in these patterns make the development, refactoring, and maintenance workflow
    much more manageable. Therefore, unless there is a specific reason for your framework
    to avoid the benefits of these tools, it is firmly advisable to lean into the
    ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Build tooling and compilers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: While writing the code of your framework project, you want to have a good feedback
    loop from the code changes you make. This feedback loop can come from running
    the project’s tests or having a sample application that utilizes your framework
    as you work on new features or bug fixes. This kind of iteration workflow can
    be configured with built-in JavaScript behaviors, or you could rely on a number
    of existing build tools and compilers. For the development process, the choice
    of compiler tooling can significantly impact and affect the efficiency of the
    development of your framework. Looking back at framework showcases, we have seen
    examples of using tools such as Rollup.js, `webpack`, and `esbuild` for web framework
    development and packaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'The choice of these tools will depend on the precise requirements of your framework.
    While meticulously choosing to use these tools, you need to make sure to evaluate
    their benefits and drawbacks. In addition, the tools you choose should be suitable
    for both the development workflow and a good framework publishing workflow. You
    could decide to separate those two workflows, but then you could end up with too
    many tools that you need to maintain. For example, we can take some of these tools
    and consider the following factors:'
  prefs: []
  type: TYPE_NORMAL
- en: The overall JavaScript runtime and feature support, such as features that include
    extensive JavaScript module format support and advanced features such as tree-shaking
    and intelligent code bundling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For frontend systems, evaluate browser and web API support
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The complexity and flexibility of configuration when targeting different workflows
    and environments, potentially choosing zero-configuration tools versus comprehensive
    configuration
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build-time speed for both development and production builds of the framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Maturity of the tool compared to other similar solutions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Developer feature set, such as **Hot Module Replacement** (**HMR**), development
    server, and instant live reload
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with external tools, such as test frameworks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Some of these factors can differ depending on your framework’s problem space—for
    example, frontend versus backend domains.
  prefs: []
  type: TYPE_NORMAL
- en: Trying out esbuild
  prefs: []
  type: TYPE_NORMAL
- en: The `chapter5/esbuild` directory in the book's repository includes a sample
    project that uses `esbuild` to bundle frontend files. You can refer to the `build.js`
    file for the `esbuild` compiler configuration. When you run this project locally
    on your machine, the tool will take the assets from the `src` directory and output
    the resulting files into the `dist` directory; these are later loaded into the
    `index.html` file in the root of the project. The build steps are executed using
    the `npm run dev` command from the project directory.
  prefs: []
  type: TYPE_NORMAL
- en: With enough time investment, you can develop your own compiler or bundler. We
    have seen prior examples of custom framework compiler development with projects
    such as Svelte. Creating your own tooling is a larger undertaking, but this is
    something that could set your framework apart and has immense potential.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript extensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: TypeScript and similar tools that extend the JavaScript functionality get a
    special mention in the design decision section. These JavaScript language extensions
    have been at the core of framework development in recent years. Even if the popularity
    of using TypeScript in the framework development workflow might decrease over
    time, it will likely be replaced by other similar tooling that encompasses benefits
    not available directly with JavaScript. With TypeScript in particular, framework
    developers get a productivity boost from extra features such as static typing,
    interfaces, decorators, namespaces, and much more. All these are highly beneficial
    for framework development.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you are unsure about introducing an additional TypeScript workflow
    into your framework or have a specific JavaScript environment that conflicts with
    TypeScript’s tooling. In that case, you could consider a design decision to opt
    in for the JSDoc annotation version of TypeScript types. A range of supported
    types for JavaScript files with TypeScript annotations can be found at [typescriptlang.org/docs/handbook/jsdoc-supported-types.html](https://typescriptlang.org/docs/handbook/jsdoc-supported-types.html).
    If you don’t mind the additional transpiling step and entirely opt into TypeScript’s
    ecosystem, then it can help you with many development hurdles, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Reducing the number of code issues identified at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Enabling faster refactoring of your code**: The ability to do this is much
    more critical in frameworks, as frameworks have much more dynamic code bases than
    routine web application projects'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved class-based programming concepts**: You can use additional building
    blocks such as interfaces, inheritance features, and more to have a well-designed
    code base'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Having a much more descriptive and documented code base**: This proactively
    benefits you and other teammates working on the project with you'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**It allows you to utilize new syntax features faster**: TypeScript constantly
    adds new valuable features and is not bound by slow browser adoption of new syntax
    features'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these benefits are highly useful, and ultimately it is a good design decision
    to use TypeScript or TypeScript-like solutions to enhance the quality of your
    coding experience.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter’s core ideas looked at several critical factors and considerations
    that we need to research and keep in mind as we start our new project. First is
    identifying the framework’s stakeholders and goals, these being the objectives
    and the audience that will benefit from having these objectives fulfilled. Then,
    we examined potential problem spaces, focusing on understanding the project types
    we can consider. Finally, we explored examples of specific JavaScript architectural
    design decisions that could shape our project.
  prefs: []
  type: TYPE_NORMAL
- en: Considering all this information will help you create a better framework project.
    Meanwhile, we will also use these framework considerations together throughout
    this book. We will start applying all these considerations in the next chapter,
    as we start building a new framework from scratch.
  prefs: []
  type: TYPE_NORMAL
