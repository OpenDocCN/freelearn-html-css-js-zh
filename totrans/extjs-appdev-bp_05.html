<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Practical &#x2013; a CMS Application"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Practical – a CMS Application</h1></div></div></div><p>In previous chapters, we explored the more theoretical side of application architecture as well as the cast of tools we'll use to support us. We've reviewed design patterns, methods of structuring our application. Now, it's time to understand how these can fit together to create a well-structured application.</p><p>In this chapter, we'll create a basic user interface for a <span class="strong"><strong>content management system</strong></span> (<span class="strong"><strong>CMS</strong></span>). While<a id="id161" class="indexterm"/> many businesses will work with an off-the-shelf CMS (such as Joomla! or Drupal), the vastly varying requirements from business-to-business means that a bespoke content management system is a fairly common project.</p><p>It's also a deceptively-complicated proposition. With such a range of business-specific requirements, the basic CMS can quickly become a complex application with modules and interface elements that are tailored for the problem at hand. This makes it even more important that the basics are taken care of, for example, code structure and naming conventions.</p><p>In reflection of this, we'll only be creating a basic starter-level CMS. We'll be:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Designing a data structure and the corresponding Ext JS model and store implementation</li><li class="listitem" style="list-style-type: disc">Building a full class structure and mapping the interactions between them</li><li class="listitem" style="list-style-type: disc">Sketching out pseudocode for some more complex interactions</li><li class="listitem" style="list-style-type: disc">Fleshing out our design into a full implementation</li></ul></div><p>This is also the general pattern that the next few chapters will take. In this particular chapter, our application will contain:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A hierarchical treeview of website structure</li><li class="listitem" style="list-style-type: disc">The search feature</li><li class="listitem" style="list-style-type: disc">A form panel showing page detail</li><li class="listitem" style="list-style-type: disc">A create, update, read, and delete functionality</li></ul></div><p>By the end of the chapter, we'll have put our knowledge to test in a basic real-world application using Ext JS 5's MVVM architecture to structure our code in a way that's clean and understandable.</p><div class="section" title="A content-managed system"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec37"/>A content-managed system</h1></div></div></div><p>We're going<a id="id162" class="indexterm"/> to be producing a bare-bone, but usable implementation of a CMS, which uses some of the Ext JS architectural concepts we've already touched on, such as view models and view controllers, event listeners, and data binding. Here's a look at the desired final product:</p><div class="mediaobject"><img src="graphics/5308OT_05_01.jpg" alt="A content-managed system"/><div class="caption"><p>Architecture CMS: our first example application</p></div></div><p>Long before we get to this point, we need to go through the requirements for the application, design its various application layers, and come up with a design. Only then can we start talking about the code level. Let's get started with checking out our client's request.</p></div></div>
<div class="section" title="The requirements"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec38"/>The requirements</h1></div></div></div><p>We receive<a id="id163" class="indexterm"/> two documents as our project brief from the client: a wireframe and a set of criteria to meet. A wireframe is the layout of our application in broad strokes, as shown here:</p><div class="mediaobject"><img src="graphics/5308OT_05_02.jpg" alt="The requirements"/><div class="caption"><p>Wireframe graphic for "Architecture CMS"</p></div></div><p>Immediately, we know that this is a very simple single-page application with a tree view, editor panel, and a search bar. The criterion fleshes out as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">REST backend API provided</li><li class="listitem" style="list-style-type: disc">The treeview to show all pages</li><li class="listitem" style="list-style-type: disc">Search that will highlight the matching page in the treeview</li><li class="listitem" style="list-style-type: disc">The required HTML editor</li><li class="listitem" style="list-style-type: disc">URLs that must be customizable</li><li class="listitem" style="list-style-type: disc">Pages that can be published or unpublished</li><li class="listitem" style="list-style-type: disc">User must be able to create, view, update, and delete pages</li></ul></div><p>Let's <a id="id164" class="indexterm"/>assess these criteria in terms of Ext JS. Firstly, we know that REST support is available in Ext JS via <code class="literal">Ext.data.proxy.Rest</code>, which we can use through our models and stores. However, note that the second point requires a tree view representing the hierarchical structure. While Ext JS provides a <code class="literal">TreePanel</code> component and there's a dedicated <code class="literal">TreeStore</code> to handle hierarchical data, there may be a possibility that loading this kind of nested data via a REST API could have some complications.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip07"/>Tip</h3><p>At this point, we could consult with our team and even write some prototype code to investigate this REST issue before getting fully underway with development. It's important to resolve any uncertainty before moving forward.</p></div></div><p>With this cleared up, we now look at the requirement for search. We know that <code class="literal">Ext.data.NodeInterface</code>, the class that powers nodes in a <code class="literal">TreePanel</code>, has a <code class="literal">findChildBy</code> method that allows you to traverse a tree from the root and perform an arbitrary action when we find what we need.</p><p>The customer specified that an HTML editor is required, which is fine as Ext JS ships with a well-featured WYSIWYG HTML editor in <code class="literal">Ext.form.field.HtmlEditor</code>. For the URL customization, we don't have to do anything special other than be aware that the client has asked for this field to be included when editing; likewise the same with the published/unpublished flag.</p><p>Finally, we know the operations that the customer would like to perform on pages, which dictates how our application will interact with the existing backend. Given the REST API available to us, supporting the required <span class="strong"><strong>create, read, update, and delete</strong></span> (<span class="strong"><strong>CRUD</strong></span>) actions <a id="id165" class="indexterm"/>should be trivial with an implementation of <code class="literal">Ext.data.Model</code>.</p><div class="section" title="Accepting the challenge"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Accepting the challenge</h2></div></div></div><p>As we've<a id="id166" class="indexterm"/> reviewed the client's criteria against the tools available to us, we can confidently accept the challenge laid down for us. Without performing due diligence on customer requirements, we could begin a project without being 100 percent certain of whether we could complete it, potentially risking the success of the project <a id="id167" class="indexterm"/>and costing valuable time and money.</p></div></div>
<div class="section" title="Starting at the bottom"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec39"/>Starting at the bottom</h1></div></div></div><p>The client stated that we have a REST API available to us. In fact, they have other Ext JS applications<a id="id168" class="indexterm"/> to be built on top of this API and so we're lucky. The data is returned as JSON that can be easily consumed by <code class="literal">Ext.data</code>. The customer provided documentation on how the API operates:</p><div class="informalexample"><pre class="programlisting">API Endpoint: http://localhost:3000

GET /pages
Accepts: n/a
Returns: [{ id: 1, text: 'label', children: [] }, { id: 2, text: '', children: [] }]

PUT /page
Accepts: {"published":true,"stub":"our-work","body":"Our Work.","id":"5e30c0a3-729a-4719-a17f-7e2286576bda"}
Returns: {"success":true}

POST /page
Accepts: {"label":"New Page","text":"New Page","leaf":true,"id":"Unsaved-1","parentId":"5e30c0a3-729a-4719-a17f-7e2286576bda","published":true,"stub":"new-page","body":"A New Page."}
Returns: [{"clientId":"Unsaved-1","id":"2ae28c61-cc6e-4a98-83ee-f527f4b19f1e","text":"New Page","body":"A New Page.","published":true,"stub":"new-page","leaf":true}]

DELETE /page
Accepts: {"id":2}
Returns: {"success":true}</pre></div><p>At this point, your developers will be dancing a little jig because not only do you have documentation, but also the API is very straightforward supports only a few operations.</p><p>Our part of the data implementation becomes easy now. We know that we want to implement a treeview. The data coming back from <code class="literal">/pages</code> is already formatted correctly for this with an array of children and both ID and text properties. We only need one model to represent a page, so it'll look something like this in pseudo-UML:</p><div class="informalexample"><pre class="programlisting">ArchitectureCms.model.Page: extends Ext.data.TreeModel
- id
- stub
- published
- body
- [] children</pre></div><p>Then, we'll have a super simple store to collect these models together:</p><div class="informalexample"><pre class="programlisting">ArchitectureCms.store.Pages: extends Ext.data.TreeStore</pre></div><p>There's no <a id="id169" class="indexterm"/>custom logic hanging off the store so that's literally our full definition, although we know that our implementation will be configured to use our <code class="literal">ArchitectureCms.model.Page</code>.</p><p>The data layer is the one through which everything will be built on. Although our design for this layer is super simple for this application, it's worth writing it in case we see any glaring issues. We can now look at how these data classes will interact with the user interface and glue classes in the rest of our application.</p></div>
<div class="section" title="Work your way up"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec40"/>Work your way up</h1></div></div></div><p>Controllers are the glue that binds your application together; it's often useful to look at our wireframe <a id="id170" class="indexterm"/>again and break down the aspects that represent view classes and will need a controller to orchestrate their actions. The basic wireframe can be seen in the following screenshot:</p><div class="mediaobject"><img src="graphics/5308OT_05_04.jpg" alt="Work your way up"/><div class="caption"><p>The wireframe broken down: yellow, green, and blue are all identified as separate views</p></div></div><p>In this application, as we have a very straightforward layout and set of interactions between <a id="id171" class="indexterm"/>components, we can get away with a very simple architecture.</p><p>While it's important to create a strong starting structure in the early days of an application, you should always strive to build something that is clearly designed and doesn't contain classes that have been added just in case they are needed.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip08"/>Tip</h3><p>
<span class="strong"><strong>You Aren't Going To Need it</strong></span> (<span class="strong"><strong>YAGNI</strong></span>) is a popular term with some software developers <a id="id172" class="indexterm"/>who believe that less is more—don't write code based on some far-future assumption about what you might need. Instead, iterate on your architecture with every addition and take as much care with these additions as you would at the start of a project.</p></div></div><p>In the Ext JS MVVM architecture, a top-level controller is used to mediate interactions<a id="id173" class="indexterm"/> between other controllers. Here, we've elected to create just one controller (a view controller called <code class="literal">Main</code>) that will coordinate all of the actions of the views within its namespace.</p><p>Let's take a look at how these new classes will look when working together and in association with our data layer:</p><div class="mediaobject"><img src="graphics/5308OT_05_05.jpg" alt="Work your way up"/></div><p>The preceding diagram clearly shows how data flows through our application (from the data layer that interfaces with the client's API to controllers and then down to views via view models). We can now flesh out each of these classes by naming them and specifying their methods and properties:</p><div class="informalexample"><pre class="programlisting">ArchitectCms.view.main.MainController: extends Ext.app.ViewController
- onAddClick
- onDeleteClick
- onSaveClick
- onPageSelect
ArchitectCms.view.main.PageModel: extends Ext.app.ViewModel
- pages
- currentPage
- isUnsavedPage
- searchTerm
ArchitectCms.view.main.Main: extends Ext.panel.Panel
ArchitectCms.view.main.Detail: extends Ext.form.Panel
ArchitectCms.view.main.Tree: extends Ext.tree.Panel
- searchFor</pre></div><p>Let's break<a id="id174" class="indexterm"/> this down a bit and talk about the reasons we've designed the application in this way.</p><div class="section" title="The devil is in the detail"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec58"/>The devil is in the detail</h2></div></div></div><p>It's immediately clear that the controller is where most of the interesting stuff is happening, but it's important to remember to keep your controllers slim. If you find yourself with lots of methods in there, it's a good sign you need another controller—look for the <a id="id175" class="indexterm"/>logical place one might split off.</p><p>In our case, a future iteration of the application might have separate view controllers for the tree and for the detail panel with an overarching controller to enable communication between the two. For now though, we just don't need this. All we have in our <code class="literal">MainController</code> class is four methods that will handle actions from our views.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip09"/>Tip</h3><p>Controllers are there to support everything else. Focus on your data first, then your views, and use the controllers to connect them. As such, work out which events your views are going to fire and your controller will pretty much write itself—all it'll be doing is handling these events and passing off the hard work somewhere else.</p></div></div><p>This is a great opportunity to put implementation details to one side for a moment and think about how these classes would look if they were designed to make our life easy.</p><p>For example, the view model called <code class="literal">PageModel</code> has a method called <code class="literal">isUnsavedPage</code>, which allows you to ensure that the user doesn't navigate away before they save a new page, ensuring they won't lose any data.</p><p>Designing like this up front enables us to think about all of the great features that make for a good user experience without having to get worked up about the code that will make it happen. Of course, every situation is different. We need to make sure that we don't let our imagination run away with itself and start dreaming up features that aren't required!</p><p>There's a <a id="id176" class="indexterm"/>short discussion to be had with regard to the <code class="literal">searchFor</code> method on the <code class="literal">Tree</code> class. In controllers, we pull together a few parts of our application and hand off the real work to them, not to the controller itself. That's exactly what we're doing here. Think of this method in the same way you would use the <code class="literal">expandPath</code> method on the <code class="literal">Ext.tree.Panel</code> base—a method that acts on the tree interface without breaking out and interacting with anything else. Its logical place is as an augmentation to the tree UI.</p></div></div>
<div class="section" title="Where the wild things are"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec41"/>Where the wild things are</h1></div></div></div><p>We have our design, so let's step a little closer and examine the parts of the application where a little more detail may be required. For example, we have a controller method called <code class="literal">onAddClick</code> that will be handling the process of adding a new record, but what will this <a id="id177" class="indexterm"/>actually entail and are there any pain points hidden within? Here's what needs to happen when this handler is done with its job:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Ask the user for a name for the new page</li><li class="listitem" style="list-style-type: disc">Create a new blank record with default values and the page name</li><li class="listitem" style="list-style-type: disc">Add the page as a child node of the current page</li><li class="listitem" style="list-style-type: disc">Load the record in the detail panel</li><li class="listitem" style="list-style-type: disc">Show the new record in the tree</li></ul></div><p>That's a lot for a single controller action. Let's look at how we might code it to see whether we're trying to do too much. We'll write some pseudocode (fake code) to drill down into some detail:</p><div class="informalexample"><pre class="programlisting">newPageName = promptUser 'Please enter a page name'

newPageModel = new Page {
    text = newPagename
}

pageTree.addAndSelect newPageModel</pre></div><p>There's no JavaScript here, no Ext JS classes in use. We're just writing the code we wish we could write if there weren't any language or framework constraints. Given that, this code looks good—it's clear what's happening and we're not doing too much.</p><p>One thing to <a id="id178" class="indexterm"/>notice is that <code class="literal">Ext.panel.Tree</code> doesn't have a native <code class="literal">addAndSelect</code> method. We'll need to write this, but if it makes our controller code cleaner and shorter, then that's a good thing.</p><div class="section" title="Spiky and hairy"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec59"/>Spiky and hairy</h2></div></div></div><p>There's a truism in software development that code is harder to read than it's to write. Comprehending someone else's code without having the reasoning behind it can be difficult. Having said that, there's a difference between code that's a little hairy, a little scary—something that doesn't shout out its intent via comments, variable naming or method <a id="id179" class="indexterm"/>naming, and code that shows consideration for future maintainers.</p><p>In writing pseudocode, we're trying to ensure that the concepts behind our code are well fleshed out beforehand and that any difficulties are taken care of before we really start work on our application.</p><p>In complex cases, pseudocode won't go far enough. We'll have to write some real code in the form of a spike. In <span class="emphasis"><em>Kent Beck's Guide to Better Smalltalk: A Sorted Collection</em></span>, <span class="emphasis"><em>SIGS</em></span>, he talks a bit about this:</p><div class="blockquote"><blockquote class="blockquote"><p><span class="emphasis"><em>"Sometimes I call this a "spike", because we are driving a spike through the entire design. […] Because people variously associate "spike" with volleyball, railroads, or dogs, I have begun using "architectural prototype" to describe this implementation."</em></span></p></blockquote></div><p>When creating a spike, we're pushing through any assumptions we have and testing our design decision on a tiny prototype (the smallest code snippet or application we can build to prove our idea).</p><p>This firms up our design by eliminating further unknowns. We can be sure that a UI component will support the feature we require because we've actually tested it in a practical example. If it's an architectural code spike, we can see whether the various elements of our design hang together in a way that "feels right", if it works within the framework being used, and the design patterns that have been chosen.</p><p>We can perform a spike on the <code class="literal">addAndSelect</code> method described previously, but we know that <code class="literal">Ext.tree.Panel</code> already has an <code class="literal">add</code> method and that the underlying <code class="literal">selectionModel</code> will allow us to mark a node as selected. Therefore, now that we have alleviated our concerns with pseudocode, there's no need to continue on to real code until we implement<a id="id180" class="indexterm"/> the real deal. As developers working under constraints of time and money, we need to be pragmatic, as long as we are certain that due diligence has been performed.</p></div></div>
<div class="section" title="The real deal"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec42"/>The real deal</h1></div></div></div><p>We've designed the data layer and the UI layer, the glue that dictates how the two interact, and <a id="id181" class="indexterm"/>tackled the remaining bits of the<a id="id182" class="indexterm"/> client requirements that look like they may cause trouble. We're in good shape to start putting our fingers on the keyboard in our favorite text editor and show how the design can be implemented in Ext JS.</p><div class="section" title="A short interlude on data binding"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec60"/>A short interlude on data binding</h2></div></div></div><p>With the introduction of view models in Ext JS, the concept of data binding has also been brought to <a id="id183" class="indexterm"/>prominence. In short, data binding binds one value to another value. When<a id="id184" class="indexterm"/> the first changes, the second updates automatically. Two-way data binding means that when either value changes, the other updates accordingly.</p><p>On the whole, Ext JS has implemented this idea via view models. A UI component may have its title bound to a value and when this value is updated by another part of the application, the title automatically changes. This removes the need for the developer to wire up change events and ensures that data will be consistent across an application.</p><p>We're going to use data binding heavily in this example application and across all our practical chapters. In many cases, a little bit of binding configuration can remove a lot of boilerplate event wiring, so we're going to take advantage of it where we can.</p></div></div>
<div class="section" title="Creating a structure"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec43"/>Creating a structure</h1></div></div></div><p>Using our<a id="id185" class="indexterm"/> knowledge from previous chapters, we'll create an application skeleton using Sencha Cmd and use it as a basis for our work. We're familiar with this by now:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>sencha generate app -ext ArchitectureCms ./architecture-cms</strong></span>
</pre></div><p>With a simple command, we're up and running with a template. Let's fire up a web server and look for changes in our code:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>cd architecture-cms</strong></span>
<span class="strong"><strong>sencha app watch</strong></span>
</pre></div><p>We can <a id="id186" class="indexterm"/>now launch a web browser and navigate to <code class="literal">http://localhost:1841</code> to see the template in action. We don't want any of the example code that's been generated. So, we can remove it with the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>rm app/view/main/*</strong></span>
</pre></div><p>Now, we've got a clean directory structure on which we can build our content management system.</p></div>
<div class="section" title="Data-driven design"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec44"/>Data-driven design</h1></div></div></div><p>In the same <a id="id187" class="indexterm"/>way that we designed our application by<a id="id188" class="indexterm"/> looking at the data layer first, we'll write the Ext JS model and store code first. Here's the model, which we'll build bit-by-bit to explain the thought process behind the code:</p><div class="informalexample"><pre class="programlisting">Ext.define('ArchitectureCms.model.Page', {
   extend: 'Ext.data.TreeModel',
fields: [
        { name: 'body' },
        { name: 'stub' },
        { name: 'text' },
        { name: 'published' }
    ]
});</pre></div><p>Let's look back at our design for this class. We're defining the same fields we laid out there with the exception of the children field, which is a special case as we're using <code class="literal">Ext.data.TreeModel</code>.</p><p>Of course, this isn't enough to drive a real-world Ext JS model. This is where the design now differs from the implementation. Let's connect the model to the client's API:</p><div class="informalexample"><pre class="programlisting">Ext.define('ArchitectureCms.model.Page', {
    extend: 'Ext.data.TreeModel',
 
    fields: [
        { name: 'body' },
        { name: 'stub' },
        { name: 'text' },
        { name: 'published' }
    ]
});</pre></div><p>Woah! The<a id="id189" class="indexterm"/> design is mostly language agnostic, but <a id="id190" class="indexterm"/>the implementation now shows off configuration options that are very Ext JS-specific. There are two ways of configuring a model. One way to configure is via its proxy and another is via its schema. The proxy configuration works just fine, but in larger applications, the schema can be shared between models and provides a central place to configure the base API URL and the path to fetch for a particular model.</p><p>Because of this, we're going to start off using schema even though we're only dealing with a single model in this application. Let's look at the various configuration options:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">namespace</code>: This<a id="id191" class="indexterm"/> is the segment of the model's class name that represents the namespace. This means that Ext JS can remove the namespace part of the full class name and be left with nothing but the model, which it can then use to automatically build URLs. In this case, we set the namespace as <code class="literal">ArchitectureCms.model</code>, which allows Ext JS to work out that the model name is just <code class="literal">Page</code>. We'll use this later.</li><li class="listitem" style="list-style-type: disc"><code class="literal">urlPrefix</code>: This<a id="id192" class="indexterm"/> is generally the hostname or the API endpoint to use in combination with the path to the specific resource being consumed.</li><li class="listitem" style="list-style-type: disc"><code class="literal">proxy.type</code>: This is<a id="id193" class="indexterm"/> the type of proxy, which when dealing with the server will likely be <code class="literal">ajax</code> or <code class="literal">rest</code>. We know that our customer has a REST API, so it's set to <code class="literal">rest</code>.</li><li class="listitem" style="list-style-type: disc"><code class="literal">proxy.url</code>: This<a id="id194" class="indexterm"/> uses all the preceding options to build a URL. The segments in curly brackets will be replaced in order to build a full URL to the resource being consumed. <code class="literal">{prefix}</code> is the <code class="literal">urlPrefix</code> from above, <code class="literal">{entityName:uncapitalize}</code> is the model's name parsed from the class name without the namespace in lower case.</li></ul></div><p>Phew! At this point, we've done a pretty deep dive into Ext JS configuration options. This chapter, and indeed this book, is supposed to be about architecture. So from now on, there will be some cases where we'll skip over this kind of detail on the assumption that you've worked with Ext JS before and understand these configuration options.</p><p>We're trying to design this application; we're not trying to teach JavaScript or Ext JS. Although, we'll look at aspects of the Ext JS framework that contribute to a successful application, we're not going to regurgitate the Sencha documentation. With this in mind, let's add a little bit more to our model and talk about how it helps us meet the customer requirements:</p><div class="informalexample"><pre class="programlisting">Ext.define('ArchitectureCms.model.Page', {
    extend: 'Ext.data.TreeModel',
    clientIdProperty: 'clientId',
    identifier: {
        type: 'sequential',
        prefix: 'Unsaved-'
    },
    schema: {
        namespace: 'ArchitectureCms.model',
        urlPrefix: 'http://localhost:3000',
        proxy: {
            type: 'rest',
            url: '{prefix}/{entityName:uncapitalize}'
        }
    },
    fields: [
        { name: 'body' },
        { name: 'stub' },
        { name: 'text' },
        { name: 'published' }
    ]
});</pre></div><p>This is<a id="id195" class="indexterm"/> the final iteration of the <code class="literal">Page</code> class, now with <a id="id196" class="indexterm"/>an identifier configured. We know that we need to differentiate between a saved and an unsaved model, and we know that the server will return <code class="literal">clientId</code> if it's supplied, so here we explicitly state that it's going to have the <code class="literal">Unsaved-</code> string in the ID until the server supplies an auto-incremented identifier to replaced it on save.</p><div class="section" title="A model store"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec61"/>A model store</h2></div></div></div><p>The<a id="id197" class="indexterm"/> store for this application is pretty simple:</p><div class="informalexample"><pre class="programlisting">Ext.define('ArchitectureCms.store.Pages', {
    extend: 'Ext.data.TreeStore',
    model: 'ArchitectureCms.model.Page',
    alias: 'store.pages',
    root: {} // set empty root as using bind doesn't do this
});</pre></div><p>Everything<a id="id198" class="indexterm"/> here is self-explanatory, although there is a caveat. With the current version of Ext JS (5.0.1), we need to set an empty root node that allows you to use data binding to bind this store to a UI component. If we don't, an error will be thrown, so this is a simple workaround.</p></div></div>
<div class="section" title="A room with a view"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec45"/>A room with a view</h1></div></div></div><p>We mentioned that it was a good idea to design your application (starting with the data layer and then moving to the views) so that it's easier to understand the interactions that your<a id="id199" class="indexterm"/> controllers will have to deal with. When moving <a id="id200" class="indexterm"/>from the design to the code, the same applies, so we will write the user interface for this application and then later wire it up to the data via controllers.</p><p>First up, we need a viewport. We only have one page in the CMS, so the viewport is the container for all of the individual subviews (such as the tree and the detail panel). This application is fairly focused, so we're going to put all our views and associated classes under the <code class="literal">ArchitectureCms.view.main.* namespace</code>. Here's the code for our <code class="literal">ArchictureCms.view.main.Main</code> viewport:</p><div class="informalexample"><pre class="programlisting">// app/view/main/Main.js
Ext.define('ArchitectureCms.view.main.Main', {

    extend: 'Ext.panel.Panel',
 requires: [
        'ArchitectureCms.view.main.Detail',
        'ArchitectureCms.view.main.Tree'
    ],
    
    session: true,

    controller: 'main',
    viewModel: 'page',
    
    title: 'Architect CMS',
    bind: { title: 'Architect CMS - Currently Editing "{currentPage.text}"' },

    layout: 'border',

    items: [
        { xtype: 'page-detail', region: 'center', reference: 'detail' },
        { xtype: 'page-tree', region: 'west', width: 300, reference: 'tree', split: true }
    ]
});</pre></div><p>This is mostly straightforward (we extend <code class="literal">Ext.Panel</code> rather than <code class="literal">Ext.Container</code> to give us support for a title bar). Next up, we require the view classes we're going to use in the viewport.</p><p>The <code class="literal">session</code> option is set to <code class="literal">true</code>. We'll discuss this in more detail shortly.</p><p>The<a id="id201" class="indexterm"/> view controller and view model are specified by <a id="id202" class="indexterm"/>their aliases; we'll create these classes later. Sencha Cmd knows that these are "auto-dependencies", so we will automatically require them without having to include them in the <code class="literal">requires</code> array.</p><p>We create a default title, namely, <code class="literal">Architect CMS</code>, but in the next line, we have our first use of the <code class="literal">bind</code> option. Let's break down what's happening here. We've already specified a view model for this class and always have to bind to a value in a view model. Not only this, the <code class="literal">bind</code> option is only triggered when the view model value changes, which is why we need to specify a default value via the title configuration. For the bind configuration, we specify the values we want to bind against (in this case title) and then provide a binding expression. Here, it's just a string. The segment in curly brackets determines the value on the view model to bind to. Later, we'll look at <code class="literal">currentPage.text</code> and see how this gets set, but it will suffice for now to realize that when this value changes; it gets incorporated into the value for title. We'll see something like this:</p><div class="mediaobject"><img src="graphics/5308OT_05_06.jpg" alt="A room with a view"/></div><p>Note that this will happen without having to wire up any event handlers. It's a little sprinkle of magic that reduces the boilerplate code we have to write.</p><p>Next up, we specify a border layout and then fill the items array with the tree and detail panel, referencing them by their <code class="literal">xtype</code>. Thanks to our configuration of the <code class="literal">requires</code> option, Ext JS is already aware of these classes, so we can use the aliases as shorthand.</p><p>Other than the binding configuration and a bit of auto-requiring magic, there's nothing special<a id="id203" class="indexterm"/> happening here. The key, in terms of application<a id="id204" class="indexterm"/> design, is the introduction of the binding concept in association with view models and view controllers. Hopefully, we've shown how these ideas can be introduced with barely any additional code.</p><div class="section" title="The tree panel and searching"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec62"/>The tree panel and searching</h2></div></div></div><p>Now that we've got our viewport container, we can introduce the views themselves. First, we'll look <a id="id205" class="indexterm"/>at the code for the tree that shows<a id="id206" class="indexterm"/> the page hierarchy:</p><div class="informalexample"><pre class="programlisting">// app/view/main/Tree.js
Ext.define('ArchitectureCms.view.main.Tree', {
    extend: 'Ext.tree.Panel',
    xtype: 'page-tree',
    rootVisible: false,
     tbar: [
        { xtype: 'textfield', emptyText: 'Search...', width: '100%', bind: { value: '{searchTerm}'}}
    ],

    bind: { store: '{pages}', searchFor: '{searchTerm}' },

    config: {
        searchFor: null
    },

    applySearchFor: Ext.emptyFn
});</pre></div><p>More binding expressions! One important thing to realize is that a view model declared on a high-level component, in this case our <code class="literal">ArchitectureCms.view.main.Main</code> viewport, will cascade down and become available to child components. This means that our binding expressions in the tree will refer to the <code class="literal">Page</code> view model we assigned to the main viewport. What customer requirement are we trying to fulfill by using binding in the tree?</p><p>We want to be able to search for a page and have it highlighted in the tree. To do so, when we type in <code class="literal">textfield</code>, the value has to be passed to the tree. A traditional way of doing this <a id="id207" class="indexterm"/>would be to listen for a change event <a id="id208" class="indexterm"/>or <code class="literal">keypress</code> on <code class="literal">textfield</code>, then trigger a <code class="literal">search</code> method on the tree. Rather than doing this manually, we can use data binding via a view model to achieve the same effect:</p><div class="mediaobject"><img src="graphics/5308OT_05_03.jpg" alt="The tree panel and searching"/><div class="caption"><p>Data flows between UI components through the view model</p></div></div><p>The <code class="literal">searchTerm</code> value on the view model can flow back and forth between the <code class="literal">searchFor</code> config on the tree and the value on <code class="literal">textfield</code>. However, in this case, it's only one direction (from <code class="literal">textfield</code> down to the tree).</p><p>In addition, we tell the tree to bind to the pages value on the view model; we know we're going to need a list of pages from somewhere.</p><p>The missing piece in this puzzle is the part that actually does the searching on the tree. Thanks to the Ext JS configuration system, any <code class="literal">config</code> option that is specified also creates an <code class="literal">applyConfigName</code> method on the class instance and this is called every time the <code class="literal">config</code> option changes. This means that by creating <code class="literal">applySearchFor</code> on the tree, every time <code class="literal">searchFor</code> updates via its binding, we can run a piece of code to do something with the new value.</p><p>Note that we put a function placeholder in the last code snippet (the <code class="literal">Ext.emptyFn</code> part). Here's the actual code we're going to use here:</p><div class="informalexample"><pre class="programlisting">applySearchFor: function(text) {
    var root = this.getRootNode();
    var match = root.findChildBy(function(child) {
        var txt = child.get('text');

        if(txt.match(new RegExp(text, 'i'))) {
            this.expandNode(child, true, function() {
                var node = this.getView().getNode(child);
                Ext.get(node).highlight();
            }, this);
        }
    }, this, true);
}</pre></div><p>In brief, use <a id="id209" class="indexterm"/>a regular expression to do a <a id="id210" class="indexterm"/>case-insensitive match on the search term against the text of each tree node. If a match is found, expand the tree to this point and call its <code class="literal">highlight</code> method to produce a visual cue.</p></div><div class="section" title="Pages in detail"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Pages in detail</h2></div></div></div><p>The tree is used to browse the hierarchy of trees in the CMS, so we now need a way to look at the<a id="id211" class="indexterm"/> detail of each page. The detail pane is a panel containing a number of form fields:</p><div class="informalexample"><pre class="programlisting">Ext.define('ArchitectureCms.view.main.Detail', {
    extend: 'Ext.form.Panel',
    xtype: 'page-detail',
    defaultType: 'textfield',
    bodyPadding: 10,
    hidden: true,
    bind: {
        hidden: '{!currentPage}'
    },
    items: [
        { xtype: 'container', cls: 'ct-alert', html: 'This record is unsaved!', bind: { hidden: '{!isUnsavedPage}' } },
        { fieldLabel: 'Id', bind: '{currentPage.id}', xtype: 'displayfield'},
        { fieldLabel: 'Published', bind: '{currentPage.published}', xtype: 'checkboxfield' },
        { fieldLabel: 'Label', bind: '{currentPage.text}' },
        { fieldLabel: 'URL Stub', bind: '{currentPage.stub}' },
        { fieldLabel: 'Body', bind: { value: '{currentPage.body}' }, xtype: 'htmleditor' }
    ],
    bbar: [
        { text: 'Save', itemId: 'save' },
        { text: 'Add Child Page', itemId: 'addChild' },
        { text: 'Delete', itemId: 'delete' }
    ]
});</pre></div><p>Each of the form fields has a binding expression, which ties the field value to a value on the <code class="literal">currentPage</code> object of the view model. When the user changes the field, the view model will automatically get updated. Note that we don't have to specifically state the property to <a id="id212" class="indexterm"/>bind to because form fields have their <code class="literal">defaultBindProperty</code> set to <code class="literal">value</code>.</p><p>The whole form panel has its hidden value bound to <code class="literal">currentPage</code>, so if this value is not set, the panel will be hidden. This allows you to hide the form when no page is selected. We've also got a warning message as the first item in the panel, which will be hidden when the view model's <code class="literal">isUnsavedPage</code> value changes to <code class="literal">false</code>.</p><p>We've only written a little bit of code outside the UI configuration, yet with the addition of the view model, we'll already have a populated tree panel with search tied to a detail panel. Next, we'll look at the view model code itself.</p></div><div class="section" title="The magical page view model"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec64"/>The magical page view model</h2></div></div></div><p>This <a id="id213" class="indexterm"/>view model uses a simple formula to provide a calculated value to the view:</p><div class="informalexample"><pre class="programlisting">// app/view/main/PageModel.js
Ext.define('ArchitectureCms.view.main.PageModel', {
    extend: 'Ext.app.ViewModel',
    alias: 'viewmodel.page',

    requires: ['Architecture.store.Pages'],

    stores: {
        pages: {
            type: 'pages',
            session: true
        }
    },

    formulas: {
        isUnsavedPage: function(get) {
            return get('page.id').toString().indexOf('Unsaved-') &gt; -1;
        }
    }
});</pre></div><p>Considering the functionality that this class enables, that's very little code. The store definition is fairly self-explanatory, just using the <code class="literal">ArchitectureCms.store.Pages</code> alias to specify that the view model has a page value powered by this store.</p><p>The formulas <a id="id214" class="indexterm"/>definition is a little more interesting. It's a way of declaring that a value will be returned based on other values in the view model. In this case, as we specified on our model that newly created records would use a prefix of <code class="literal">Unsaved-</code>, we can look for this to determine whether the record's been saved to the server or not. So, <code class="literal">isUnsavedPage</code> returns <code class="literal">true</code> or <code class="literal">false</code> depending on whether the record's ID contains this prefix or not.</p><p>The only missing thing here is the <code class="literal">currentPage</code> value. We can set arbitrary values on the view model. So, this gets set elsewhere in the controller. Before we talk about this, let's jump back to discuss a new concept in Ext JS 5: <code class="literal">Ext.data.Session</code>.</p></div><div class="section" title="This data is now in session"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec65"/>This data is now in session</h2></div></div></div><p>An <code class="literal">Ext.data.Session</code> is a way of centralizing data in an application, ensuring that stores are working with the same set of data without having redundant reloading. It also allows much <a id="id215" class="indexterm"/>easier batched updates and deletions.</p><p>In our application, we set <code class="literal">session</code>, set to <code class="literal">true</code> on our top-level viewport, which tells Ext JS to automatically create a session and make it available to any other code that requests it. This is the simplest way of constructing a session, although there's a lot more customization that we can do if need be.</p><p>The reason we use a session in this application is to allow us to link the data that the tree and the detail panel uses. This helps with data binding too; we can use exactly the same model instance in the tree and the detail panel, which means that updates made in the detail panel will flow through the view model and into the correct page instance in the tree. In a moment, when we look at our view controller, we'll use the session a little more and get a glimpse of how it can help manage your data.</p></div><div class="section" title="The glue controlling all"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec66"/>The glue controlling all</h2></div></div></div><p>In previous chapters, we've looked at how the controller can use event domains to hook into anything interesting happening elsewhere in the application. Here, we use the same approach, which we discussed previously, and get the controller to hook up a bunch of event handlers<a id="id216" class="indexterm"/> to deal with user actions<a id="id217" class="indexterm"/> in the user interface:</p><div class="informalexample"><pre class="programlisting">// app/view/main/MainController.js
Ext.define('ArchitectureCms.view.main.MainController', {
    extend: 'Ext.app.ViewController',
    alias: 'controller.main',

    requires: ['ArchitectureCms.model.Page'],

    init: function() {
        this.listen({
            component: {
                'treepanel': {
                   'select': 'onPageSelect'
                },
                'page-detail #save': {
                    click: 'onSaveClick'
                },
                'page-detail #addChild': {
                    click: 'onAddClick'
                },
                'page-detail #delete': {
                    click: 'onDeleteClick'
                }
            }
        });
    },


 onPageSelect: function(tree, model) {
        this.getViewModel().setLinks({
            currentPage: {
                type: 'Page',
                id: model.getId()
            }
        });
    },


    onAddClick: function() {
        var me = this;

        Ext.Msg.prompt('Add Page', 'Page Label', function (action, value) {
            if (action === 'ok') {
                var session = me.getSession(),
                    selectedPage = viewModel.get('currentPage'),
                    tree = me.lookupReference('tree');

                var newPage = session.createRecord('Page', {
                    label: value,
                    text: value,
                    leaf: true
                });

                selectedPage.insertChild(0, newPage);
                tree.setSelection(newPage);
                tree.expandNode(selectedPage);
            }
        });
    },


    onDeleteClick: function() {
        var me = this;
        
        Ext.Msg.confirm('Warning', 'Are you sure you'd like to delete this record?', function(btn) {
            if(btn === 'yes') {
                me.getViewModel().get('currentPage').erase();
                me.getViewModel().set('currentPage', null);
                Ext.toast('Page deleted');
            }
        }, this)
        
    },

    onSaveClick: function() {
        this.getViewModel().get('currentPage').save();
        Ext.toast('Page saved');
    }
});</pre></div><p>This <a id="id218" class="indexterm"/>view controller handles the following<a id="id219" class="indexterm"/> four events:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The <code class="literal">select</code> event on the tree handled by the <code class="literal">onPageSelect</code> method</li><li class="listitem" style="list-style-type: disc">The <code class="literal">click</code> event on the detail panel's save button handled by <code class="literal">onSaveClick</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">click</code> event on the detail panel's add child button handled by <code class="literal">onAddChildClick</code></li><li class="listitem" style="list-style-type: disc">The <code class="literal">click</code> event on the detail panel's delete button handled by <code class="literal">onDeleteClick</code></li></ul></div><p>Some of this will be self-explanatory, some relates to data binding, and some relates to the session. Let's break down the important parts.</p><div class="section" title="Selecting a page"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec02"/>Selecting a page</h3></div></div></div><p>When the tree fires a <code class="literal">select</code> event, the view controller's <code class="literal">onPageSelect</code> method gets passed the <a id="id220" class="indexterm"/>model for the selected tree node. We mentioned earlier that we can set arbitrary values on the view model, specifically the <code class="literal">currentPage</code> value, and so this is what we do here, but with a twist.</p><p>Rather than just setting the data, we give Ext JS a hint that we want to set a model instance by using the links configuration. By supplying the name of the model class and its ID, Ext JS will use the matching instance if it's already available in the current <code class="literal">Ext.data.Session</code> or it'll automatically load it from the server. It's a handy shortcut for reducing the number of requests to the backend API and another example of how to use a session.</p></div><div class="section" title="Adding a page"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec03"/>Adding a page</h3></div></div></div><p>The view controller listens for events on a button with an item ID of <code class="literal">#addChild</code>. When it fires, we <a id="id221" class="indexterm"/>ask the user for the name of the new page, and the next step is to actually create a page record. Rather than using <code class="literal">Ext.create</code>, we call <code class="literal">createRecord</code> on the current <code class="literal">Ext.data.Session</code>, which allows you to continue to make Ext JS aware of the records we're managing. It also allows you to maintain a global understanding of the saved and unsaved records. This would be even more useful in an application where we need to do batch updates of records.</p><p>After creating<a id="id222" class="indexterm"/> a model instance, we follow the pseudocode we wrote earlier in the chapter, but tie it to actual Ext JS methods and add the page to the tree data structure before selecting it in the tree UI itself.</p></div><div class="section" title="Deleting a page"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec04"/>Deleting a page</h3></div></div></div><p>This is fairly straightforward (handle the <code class="literal">click</code> event from the <code class="literal">#delete</code> button and then grab the <code class="literal">currentPage</code> from the view model). We also remove the leftover page from the view model<a id="id223" class="indexterm"/> so that the detail panel automatically clears itself, rather than leaving a dead record available to edit. We display a notification to the user with <code class="literal">Ext.toast</code>.</p></div><div class="section" title="Saving a page"><div class="titlepage"><div><div><h3 class="title"><a id="ch05lvl3sec05"/>Saving a page</h3></div></div></div><p>This is even <a id="id224" class="indexterm"/>simpler (handling a click on the #save button, grabbing the <code class="literal">currentPage</code> from the view model, and then calling its <code class="literal">save</code> method). There's nothing special happening here. The only thing to note is that if this is a new record, the server will respond with a new ID and replace the one that Ext JS automatically allocated. Thanks to the binding to <code class="literal">isUnsavedPage</code> on the view model, this will cause the "unsaved" message to disappear from the detail panel.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec46"/>Summary</h1></div></div></div><p>With our first practical application, we've taken the theoretical ideas discussed in previous chapters and shown how they apply to the creation of a useful code base. From analysis to what the customer really needs to see, whether we can fulfill their request to sketching out designs, and undertaking short code spikes down to applying the MVVM pattern via view models and their supporting infrastructure, we've built an application brain-first rather than code-first.</p><p>In the next chapter, we'll create a more complicated real-world application, but this time, we won't have to discuss the basics of data binding in so much detail. We'll apply our growing knowledge to build a more complex app, a log analyzer, which could be used by a system administrator to monitor their infrastructure. This will require more thought about how to design the various moving parts that will make up our second application.</p></div></body></html>