- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Reactive View Library Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive view library patterns give us tools to build applications in a scalable
    and maintainable manner when we could benefit from breaking out of the component
    primitive. Using the React view library, we’ll cover different techniques for
    going beyond component-based composition to inject functionality into our components
    – the render prop, a higher-order component, hooks, and provider patterns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll cover the following main topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: An introduction to reactive view library patterns and where we can benefit the
    most by using them
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Examples and implementation approaches for the render prop pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing and using the higher-order component pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using hooks to build React function components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Multiple ways to implement the provider pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to discern when and how to use Reactive
    view library patterns to build React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along in this chapter, you’ll need the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Node.js** **20+**: [https://nodejs.org/en](https://nodejs.org/en)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Npm 8+**: Comes with most Node.js installations'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://parceljs.org/](https://parceljs.org/) is used in some examples and
    has similar platform support to Node.js'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**React**: React DOM and Formik are installed via npm; an understanding of
    [https://react.dev/](https://react.dev/) basics in a web context is required'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can find the code files for this chapter on GitHub at [https://github.com/PacktPublishing/Javascript-Design-Patterns](https://github.com/PacktPublishing/Javascript-Design-Patterns)
  prefs: []
  type: TYPE_NORMAL
- en: What are reactive view library patterns?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Reactive view libraries are extensively used for JavaScript and web frontend
    development. A few very popular options are **React**, **Angular**, and **Vue**.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive view libraries provide a way to write applications in a more scalable
    fashion by allowing the user interface (usually the browser) to react to changes
    in the data. Application development is, therefore, simplified, since the view
    library or framework takes care of all the direct manipulation necessary to maintain
    synchronization between the underlying data and the browser.
  prefs: []
  type: TYPE_NORMAL
- en: One of the key common denominators between these libraries and frameworks is
    the concept of a **component**, which contains business logic and/or rendering
    logic. The component is a key building block of an application. It can be reused
    or not, but it usually encapsulates a set of responsibilities and enforces interfaces
    around it.
  prefs: []
  type: TYPE_NORMAL
- en: A trait of components is that a developer should be able to use them as building
    blocks, and without component internals changing significantly, an application’s
    behavior can be changed significantly.
  prefs: []
  type: TYPE_NORMAL
- en: Reactive view library patterns, therefore, help us build components in a reusable
    fashion, but they also cover techniques to work around situations where the component
    abstraction has shortcomings.
  prefs: []
  type: TYPE_NORMAL
- en: In the following sections, we’ll cover the render props, higher-order component,
    hooks, and the provider pattern in React. We’ll be focusing on React, but the
    patterns have equivalents in Vue.
  prefs: []
  type: TYPE_NORMAL
- en: The render prop pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The render prop pattern is apparent when a component allows its consumer to
    define how a part of that component is rendered, via a function prop. These can
    be children as a function or another prop, which is a function that takes some
    parameters and returns JSX.
  prefs: []
  type: TYPE_NORMAL
- en: Render props allow for a level of inversion of control. Although a component
    could completely encapsulate rendering and business logic, it instead yields control
    of some parts of the rendering logic to its consumer.
  prefs: []
  type: TYPE_NORMAL
- en: Such inversion of control is useful to share logic without sharing the visuals
    or actually rendering the UI. Therefore, this pattern is widespread among libraries.
    A prime example is **Formik**, which gives consumers flexibility on how to render
    a form while providing an abstraction over the form’s state management logic.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s start with a scenario where we build a `CoupledSelect` component, which
    is a wrapper for the `select` native element. We’ll build this component in a
    way that the data and the rendering are closely coupled, providing a simple example
    of when render props can be useful.
  prefs: []
  type: TYPE_NORMAL
- en: A consumer’s expectation from `CoupledSelect` is that it would behave mostly
    like the `select` native element, with some caveats.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `CoupledSelect` component takes the following props:'
  prefs: []
  type: TYPE_NORMAL
- en: '**selectedOption**: This sets the selected option; it is akin to the selected
    prop on the **option** native element'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**options**: This is an array of strings that are rendered as **option** elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**onChange**: This is an optional callback for the component rendering **CoupledSelect**
    to react to option selections'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can implement it as follows. `CoupledSelect` will wrap around `onChange`,
    since it’s optional:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s move on to the rendering logic. We’ll return a select element with `onChange={onChangeHandler}`
    and `value={selectedOption}` so that select will be in sync with `selectedOption`
    and propagate changes back:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we’ll render the `props.options` using .map, which will return an
    <`option`> element, with the value and key properties set to option and whose
    content will be the `option` value also:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using our `CoupledSelect` might look something as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'We define an array of options. Here, we structure them as a list of objects
    with a `value` key that’s a string:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use `CoupledSelect` by ensuring that `props.options` is an array
    of strings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can save `selectedOption` by using the `useState` hook. We will name
    this particular piece of state `selectedOption` and its update function `setSelectedOption`.
    This will allow us to make `CoupledSelect` interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, we will set an initial value for `selectedOption` to show that this
    functionality of the `CoupledSelect` component works:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Starting with the initial `selectedOption` functionality, we can see that the
    item at index 3 of the options array, `{ value: ''grape'' }`, is the initially
    selected option, as shown in *Figure 4**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: The CoupledSelect initial state, with grape selected](img/B19109_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The CoupledSelect initial state, with grape selected'
  prefs: []
  type: TYPE_NORMAL
- en: When opening `select`, the `select` is in the correct state.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: The CoupledSelect select open state, hovering on the orange option](img/B19109_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: The CoupledSelect select open state, hovering on the orange option'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, when we select a different option, `onChange` handler also works as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: In the CoupledSelect post-selection state, orange is now selected](img/B19109_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: In the CoupledSelect post-selection state, orange is now selected'
  prefs: []
  type: TYPE_NORMAL
- en: The `CoupledSelect` component has limited flexibility due to the `options.map()`
    call in the render function. Since we’re using the option variable as the option
    element’s value, it must be a string or number. The value is also equal to the
    rendered text content of the option element, but there are often situations where
    we want to display something different from the value that we’re storing. It’s
    a presentation versus persistence concern here. For example, we can’t change the
    values rendered without changing what’s being stored in `onChange`.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to add a `Fruit`: prefix to `select`, a naive approach is to implement
    it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Unfortunately, this doesn’t work as expected, as the initial selection doesn’t
    work anymore:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: The CoupledSelect initial state, where the initial selection
    does not work correctly](img/B19109_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: The CoupledSelect initial state, where the initial selection does
    not work correctly'
  prefs: []
  type: TYPE_NORMAL
- en: When opening the `select,` things seem to work OK; we can see the **Fruit:**
    prefix for all the options, as shown in *Figure 4**.5*.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: The CoupledSelect open state, with the Fruit: prefix](img/B19109_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: The CoupledSelect open state, with the Fruit: prefix'
  prefs: []
  type: TYPE_NORMAL
- en: 'On selection of a new option, we can see that what’s being stored in the `selectedOption`
    is **Fruit: pear** instead of **pear**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: The CoupledSelect post-selection state – note that the selected
    option Fruit: pear includes the prefix Fruit:](img/B19109_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: The CoupledSelect post-selection state – note that the selected
    option Fruit: pear includes the prefix Fruit:'
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, the `CoupledSelect` component can’t be used flexibly, due to the
    coupling of the render logic and the data logic.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll now see how render props could have alleviated this issue by decoupling
    data and rendering logic.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation/example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In our `CoupledSelect` example, we saw how the stored data and what is displayed
    to the user are tightly coupled. We’ll now see how to break that coupling using
    render props.
  prefs: []
  type: TYPE_NORMAL
- en: Decoupling presentation from data logic by using render props
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An alternative way to have written the `CoupledSelect` component with render
    props is as follows. The key additional prop we’re passing is `renderOption`,
    a render prop. Most of the remaining components are similar but are included for
    completeness:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Usage of the `SelectRenderProps` component is very similar to that of `CoupledSelect`.
    The only additional prop we need to provide an implementation for is the `renderOption`
    prop, which we implement with a function that returns an `option` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: So far, the implementation is very similar to `CoupledSelect`, apart from the
    fact that the parent of `SelectRenderProps` now decides how to render an option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given the same requirement to prefix the options with `Fruit:`, we can now
    implement it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Note that counter to what we did with `CoupledSelect`, we’re not even touching
    the options prop. Our only change is to the `renderOption` prop. We’ll now test
    this example and show that decoupling the rendering logic (with a render prop)
    from the data logic works much better for extensibility.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SelectRenderProps` initial state renders correctly, with `select` and
    **grape** in the parent component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: The SelectRenderProps initial state – the options and initial
    selection are displayed correctly](img/B19109_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: The SelectRenderProps initial state – the options and initial selection
    are displayed correctly'
  prefs: []
  type: TYPE_NORMAL
- en: When we open `select`, we can see that the **Fruit:** prefix is rendered.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: The SelectRenderProps open state – the options include the Fruit:
    prefix](img/B19109_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: The SelectRenderProps open state – the options include the Fruit:
    prefix'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, upon selection of an option, the state is updated correctly, the parent
    stores `select` has **Fruit:** **banana** selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.9: The SelectRenderProps post-selection state – the selected option
    does not include the Fruit: prefix](img/B19109_04_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.9: The SelectRenderProps post-selection state – the selected option
    does not include the Fruit: prefix'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen how render props can allow the rendering logic and data logic
    to be edited separately when making a rendering change.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve implemented a basic example of the render prop pattern, we’ll
    see how libraries leverage it to provide flexibility to consumers.
  prefs: []
  type: TYPE_NORMAL
- en: Additional render prop patterns when providing components with flexible presentation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The React form management library Formik uses a render prop to provide form
    state back to consumers. The render prop is the children prop of the Formik component.
    In other words, what’s between the opening `<Formik>` tag and the closing `</Formik>`
    tag is a function, which provides props such as values, `isSubmitting`, and `handleChange`.
  prefs: []
  type: TYPE_NORMAL
- en: See the following example, which is a single-input form that takes a name, validates
    that it’s at least two characters long, and allows the form to be submitted.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin, we’ll render the form and input that will store the `fields` value
    in `Formik`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we can add submission handling and an inline validation error display:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In the initial state, we see the form with a single input and a submit button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: The Formik single field and Submit button in its initial state,
    which includes the Name (Required) label](img/B19109_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: The Formik single field and Submit button in its initial state,
    which includes the Name (Required) label'
  prefs: []
  type: TYPE_NORMAL
- en: When we click (or otherwise focus) on the name input and then un-focus (the
    *blur* web event), the validation triggers, letting us know that the field is
    required.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: Name input blur validation - Error: Required validation error](img/B19109_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: Name input blur validation - Error: Required validation error'
  prefs: []
  type: TYPE_NORMAL
- en: If we input only one character and blur, we get a validation error, **Name**
    **too short**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: H in the name input triggers the validation error Name too short](img/B19109_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: H in the name input triggers the validation error Name too short'
  prefs: []
  type: TYPE_NORMAL
- en: When a name that meets the validation criteria is met, the validation errors
    are cleared.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: A valid Formik field clears the validation errors](img/B19109_04_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: A valid Formik field clears the validation errors'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, when we click **Submit**, we get a browser alert with **{ “name”:
    “****Hugo” }**.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.14: An alert on submission with { “name”: “Hugo” }](img/B19109_04_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.14: An alert on submission with { “name”: “Hugo” }'
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a look at some limitations of the render prop pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One key limitation of the render prop pattern is that it provides units of reuse
    and integration that are functions and not components. It’s possible for a lot
    of the logic to end up in the render prop function itself that could have been
    better served by creating a new component.
  prefs: []
  type: TYPE_NORMAL
- en: Render props can make code harder to test when using a shallow renderer such
    as Enzyme’s `shallow`, which won’t render the full component tree. Components
    making heavy use of render props should probably use a full “mount” rendering
    approach so that all the children of the component (including the render props)
    are rendered.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced you to the render prop pattern and described
    its use cases, examples, and limitations.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn about another reactive view library pattern
    – higher-order components.
  prefs: []
  type: TYPE_NORMAL
- en: The higher-order component pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A higher-order component is a function that takes a component and returns a
    component. The definition of higher-order components is similar to higher-order
    functions, which JavaScript supports. Higher-order functions are functions that
    receive a function as a parameter or return a function.
  prefs: []
  type: TYPE_NORMAL
- en: The higher-order component pattern allows us to pass additional props to a component.
  prefs: []
  type: TYPE_NORMAL
- en: Implementation/example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following is a simple render prop, `withLocation`, which injects `window.location.href`
    and `window.location.origin` into a component as props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The pattern that’s used when using higher-order components is to export default
    the higher-order component called with the local component – in this case, `withLocation(Location)`.
    The `Location` component is a simple component that takes location as provided
    by `withLocation` and renders it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In the consumer of `Location`, what we import as `Location` is the default
    export – that is, `withLocation(Location)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The `Location` component renders `location.href` and `location.origin`, based
    on what’s provided by `withLocation`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19109_04_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.15: The Location component rendering the href and origin, based on
    what’s provided by withlocation'
  prefs: []
  type: TYPE_NORMAL
- en: We’ve now seen a simple example of a key benefit of higher-order components,
    which is that the component doing the rendering doesn’t need to be directly aware
    of where to receive information; it can read props instead.
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `withLocation` example already showed a simple reason why we could use higher-order
    components – to maintain separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: In our Location component example, it’s completely possible for Location to
    access `window.location` directly. What that would mean, however, is that the
    Location component is aware of global objects, which could be undesirable. For
    example, it might make unit-testing of `Location` more difficult, since it’s accessing
    something beyond its props.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As with all abstractions, higher-order components are a layer of indirection.
    This means that tracing where a prop comes from can be more difficult than when
    props are passed explicitly from the parent component.
  prefs: []
  type: TYPE_NORMAL
- en: Tracing the props becomes even more difficult when the higher-order component
    comes from a third-party library (and thus is harder to inspect).
  prefs: []
  type: TYPE_NORMAL
- en: Higher-order components can have a cost in terms of rendering in the browser,
    since we wrap our component in another component if we stack too many higher-order
    components on top of each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following `ConnectedComponent` uses three higher-level components:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: As a consumer of `ConnectedComponent`, we’ll likely render four components –
    the ones provided by `withRouter`, `withHttpClient`, `withAnotherDependency`,
    and `ComponentWithDependencies`. If we had another way to inject the router, HTTP
    client and another dependency, we could reduce the number of components to one,
    only needing `ComponentWithDependencies`.
  prefs: []
  type: TYPE_NORMAL
- en: This drawback leads us to the next topic in this chapter – hooks. Hooks provide
    us a way to access data and logic in similar scenarios as higher-order components,
    without additional components being rendered. Hooks are a great replacement for
    logic-heavy higher-order components.
  prefs: []
  type: TYPE_NORMAL
- en: The hooks pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ve now covered what might be considered *legacy* patterns in React – render
    props and higher-order components.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll note that the React documentation page about higher-order components
    has the following disclaimer: “Higher-order components are not commonly used in
    modern React code.”'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading
  prefs: []
  type: TYPE_NORMAL
- en: 'The React documentation for **useState** and **useEffect** hooks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**useState**: [https://react.dev/reference/react/useState](https://react.dev/reference/react/useState)'
  prefs: []
  type: TYPE_NORMAL
- en: '**useEffect**: [https://react.dev/reference/react/useEffect](https://react.dev/reference/react/useEffect)'
  prefs: []
  type: TYPE_NORMAL
- en: So, what we know so far is that hooks allow us to do what we did with render
    props and that higher-order components are not recommended any more. This is because
    hooks provide a way to access all the React primitives, including state and the
    component life cycle.
  prefs: []
  type: TYPE_NORMAL
- en: React provides built-in hooks. The two we’ll focus on are `useState` and `useEffect`.
    One key feature of hooks is that we can write custom hooks that build on top of
    React built-in hooks and other custom hooks, which means we have a new way to
    share logic in React.
  prefs: []
  type: TYPE_NORMAL
- en: An implementation/example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll implement simple data fetching using the class React components, and then
    hooks. This will showcase how state and life cycle events are handled in both
    cases.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start with the class components. The regular way to implement data fetching
    is by using life cycle hooks; the initial one tends to be `componentDidMount`.
  prefs: []
  type: TYPE_NORMAL
- en: Our `BasketItemsClassical` component takes `httpClient` and `basketId`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The component’s constructor initializes a `state.basketSession` variable to
    an empty object, `{}`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Next, we’ll add a `setBasketSession` method, which will call `this.setState`
    to set `basketSession` as the passed parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also add `componentDidMount`, which calls `httpClient.get()` with the
    fakestoreapi.com URL to load carts, using the `basketId` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'What this now means is that we should be able to render out the contents of
    `this.state.basketSession` in the component’s `render()` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `BasketItemsClassical` can be used as follows by passing `httpClient` and
    `basketId` as props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '`BasketClassical` can then be used in our `App`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the browser, this displays as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.16: The Basket class component loading JSON data](img/B19109_04_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.16: The Basket class component loading JSON data'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s the same example with hooks; instead of using `componentDidMount`, we
    can use the `useEffect` hook, and instead of `this.state` in the constructor and
    `this.setState`, we use the `useState` hook. In order to use hooks, we use a React
    function component (React class components don’t support hooks):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Our `BasketItemsHooks` can be used in the same way as `BasketItemsClassical`,
    by passing `httpClient` and `basketId` as props:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We’ll also need to modify `App` to render `BasketHooks` in addition to `BasketClassical`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Both `BasketHooks` (*Figure 4**.17*) and `BasketClassical` (*Figure 4**.16*)
    yield the same JSON output after the HTTP requests are completed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.17: The Hooks basket loading JSON data](img/B19109_04_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.17: The Hooks basket loading JSON data'
  prefs: []
  type: TYPE_NORMAL
- en: 'The hooks approach is slightly more compact; each part of the functionality
    does feel a bit more self-contained. For example, the initial state is handled
    in the same place that defines what the state update function will be in the hooks
    version. In the class example, the `initialisation` state is in the constructor,
    and the state update function is a method. In the `BasketClassical` example, there
    was the option to simplify the component by removing the state update method and
    using a direct `this.setState({ bookingSession: session })` call.'
  prefs: []
  type: TYPE_NORMAL
- en: Use cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A simple way to think about hooks and class or function components is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Hooks for shared logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Components for logic that is related to rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The higher-order component and render prop patterns, which are used to separate
    presentation and business logic, are unlikely to be needed any more and can be
    replaced by custom hooks.
  prefs: []
  type: TYPE_NORMAL
- en: React hooks and function components are the recommended way to develop modern
    React applications.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Hooks can’t be used in React class components, as detailed in the React documentation:
    [https://react.dev/reference/react/Component#defining-a-class-component](https://react.dev/reference/react/Component#defining-a-class-component).
    Note that function components are the recommended way to build React components.'
  prefs: []
  type: TYPE_NORMAL
- en: In code bases with heavy usage of class components, higher-order components
    should remain in use instead of migrating components to functions in order to
    use hooks.
  prefs: []
  type: TYPE_NORMAL
- en: The last piece of the puzzle with React components is how to bypass the prop
    drilling problem and pass data without changing each component in a React component
    tree. The pattern we use for this is the provider pattern, which we’ll cover in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: The provider pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The provider pattern in React is where one component in the tree makes data
    accessible to all its descendants. This is usually accomplished using the React
    **Context** primitive.
  prefs: []
  type: TYPE_NORMAL
- en: Use case – the prop drilling problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The key use case for the provider pattern is to avoid the **prop** **drilling**
    problem.
  prefs: []
  type: TYPE_NORMAL
- en: A large majority of the time, a component’s main input is the prop it receives
    from its parent component. A state management pattern to share state between components
    in React is to *lift state up*. Lifting state up means to store relevant state
    in a common ancestor of the components that require the shared state.
  prefs: []
  type: TYPE_NORMAL
- en: As stated in the React.js docs ([https://react.dev/learn/sharing-state-between-components](https://react.dev/learn/sharing-state-between-components))
  prefs: []
  type: TYPE_NORMAL
- en: When you want to coordinate two components, move their state to their common
    parent. Then pass the information down through props from their common parent
  prefs: []
  type: TYPE_NORMAL
- en: This can lead to **prop drilling** when the common parent has multiple components
    between it and the components requiring the props. This means all the intermediate
    components will receive the props, but they will only use them to forward them
    on to the next layer of components.
  prefs: []
  type: TYPE_NORMAL
- en: As stated in the React.js docs (https://react.dev/learn/passing-data-deeply-with-context#the-problem-with-passing-props)
  prefs: []
  type: TYPE_NORMAL
- en: Passing props is a great way to explicitly pipe data through your UI tree to
    the components that use it. But passing props can become verbose and inconvenient
    when you need to pass some prop deeply through the tree, or if many components
    need the same prop. The nearest common ancestor could be far removed from the
    components that need data, and lifting state up that high can lead to a situation
    called “prop drilling
  prefs: []
  type: TYPE_NORMAL
- en: The provider pattern is a solution to the prop drilling problem, since every
    descendent of the provider component will have access to the data it provides.
  prefs: []
  type: TYPE_NORMAL
- en: An implementation/example
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s look back to the examples from *The hooks pattern* section, where we had
    the App rendering `BasketClassical` and `BasketHooks`, which render `BasketItemsClassical`
    and `BasketItemsHooks`, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.18: A React app tree with BasketClassical, BasketHooks, and their
    descendants](img/B19109_04_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.18: A React app tree with BasketClassical, BasketHooks, and their
    descendants'
  prefs: []
  type: TYPE_NORMAL
- en: This illustrates the prop drilling problem, since `BasketClassical` and `BasketHooks`
    don’t use `basketId` or `httpClient` beyond passing it to `BasketItemsClassical`
    and `BasketItemsHooks`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are multiple ways to consume a context in React, but it all begins by
    creating a context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '`HttpClientContext` is a context that’s initialized with the null value. `HttpClientProvider`
    is a component that takes a `httpClient` value, setting it as the value that `HttpClientContext.Provider`
    will pass to its descendants in the component tree.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to use `HttpClientContext`, we can use `HttpClientContext.Consumer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '`HttpClientContext.Consumer` has a children render-prop (function) that takes
    the value of the context (in this case, `httpClient`) and returns some JSX to
    render:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'This yields the following output in the browser:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.19: The JSON contents of basketId=5 from fakestoreapi.com](img/B19109_04_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.19: The JSON contents of basketId=5 from fakestoreapi.com'
  prefs: []
  type: TYPE_NORMAL
- en: 'The approach using `HttpClientContext.Consumer` directly is a bit unwieldy.
    Instead, we could wrap it in a higher-order component, `withHttpClient`, which
    consumes `HttpClientConsumer`. The benefit here is that we only have one place
    that uses `HttpClientConsumer`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'With a slight difference from our example of a higher-order component, we’ll
    export const `Connected``     BasketItemsClassical` with the value `withHttpClient(BasketItemsClassical)`. The
    *connected* nomenclature is a call back to the large React Redux code bases where
    the components are often split among *presentation* and *container* components.
    The Redux higher-order component is called `connect`, and all the containers are
    connected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We can then use `ConnectedBasketItemsClassical` as follows. Note that we don’t
    pass an `httpClient` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: The higher-order component version using `withHttpClient` outputs the same value
    as the direct `HttpClientConsumer` implementation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.20: The JSON contents of basketId=5 from fakestoreapi.com](img/B19109_04_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.20: The JSON contents of basketId=5 from fakestoreapi.com'
  prefs: []
  type: TYPE_NORMAL
- en: The final approach to using context and the provider pattern is to leverage
    the React `useContext` hook. Similar to how `HttpClientContext.Consumer` allows
    us to access the context provider’s value, the hook fulfills that same role. So,
    the output of `useContext(context)` is the current value, based on where the hook
    renders in the component tree.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s customary to wrap the `useContext` hook in a more descriptive name (as
    we did for `HttpClientContext.Consumer`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, using `httpClient` from the `HttpClientContext` requires component-level
    changes. So, we’ll write the following implementation of `BasketItemsHooksUseContext`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '`BasketItemsHooksUseContext` can be used as follows. Note that we’re not passing
    `BasketItemsHooksUseContext`, a `httpClient` prop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: This implementation is yet again equivalent to the previous implementations
    we did with `HttpClientConsumer` and `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.21: The JSON contents of basketId=5 from fakestoreapi.com](img/B19109_04_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.21: The JSON contents of basketId=5 from fakestoreapi.com'
  prefs: []
  type: TYPE_NORMAL
- en: We saw how to use the provider pattern to solve the prop drilling problem in
    React apps. Let’s now look at some limitations of this pattern in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Limitations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The provider pattern is a layer of indirection. It might not always be obvious
    where a context’s value is coming from, or it might sometimes be necessary to
    change the provider/context shape to make some changes at the component level.
    For example, when using context with hooks, the hook shows a direct link between
    consuming component and the context, but it doesn’t necessarily show the provider
    or how the value inside the context is defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'It’s also sometimes possible to solve the prop drilling problem by making liberal
    use of children and composing the components in a single large JSX return, such
    as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: In `MyComponent`, we pass the props directly to `OtherComponent` and `FinalComponent`
    from `MyComponent`. If we had `ContainerComponent` encapsulating `OtherComponent`
    and `FinalComponent`, the props would be drilled via `ContainerComponent` (it
    doesn’t use the props but receives them, in order to pass them to its descendants).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we looked at how reactive view library patterns enable us to
    build React applications more effectively when the component paradigm starts to
    break down.
  prefs: []
  type: TYPE_NORMAL
- en: The render prop pattern allows us to decouple data logic and rendering logic
    by yielding rendering control back to the consumer of a component.
  prefs: []
  type: TYPE_NORMAL
- en: The higher-order component pattern allows components to implement logic (data
    or rendering) against their props, without having to concern themselves with where
    the information comes from.
  prefs: []
  type: TYPE_NORMAL
- en: The hooks pattern means that React primitives that were only available in class
    components are now available as self-contained logic chunks to function components.
    Hooks can be composed separately of components, which makes hooks a powerful primitive
    and can partly replace the render prop and higher-order component patterns.
  prefs: []
  type: TYPE_NORMAL
- en: The provider pattern allows React components to pass data not only to their
    children but also to any descendent component.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’re familiar with reactive view library patterns, in the next chapter,
    we will look at rendering and page hydration strategies to improve web applications’
    performance.
  prefs: []
  type: TYPE_NORMAL
