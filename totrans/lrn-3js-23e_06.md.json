["```js\n<script src=\"img/ConvexGeometry.js\"></script>\n```", "```js\nfunction generatePoints() {\n  // add 10 random spheres\n  var points = [];\n  for (var i = 0; i < 20; i++) {\n    var randomX = -15 + Math.round(Math.random() * 30);\n    var randomY = -15 + Math.round(Math.random() * 30);\n    var randomZ = -15 + Math.round(Math.random() * 30);\n    points.push(new THREE.Vector3(randomX, randomY, randomZ));\n  }\n\n  var group = new THREE.Object3D();\n  var material = new THREE.MeshBasicMaterial({color: 0xff0000, transparent: false});\n  points.forEach(function (point) {\n    var geom = new THREE.SphereGeometry(0.2);\n    var mesh = new THREE.Mesh(geom, material);\n    mesh.position.clone(point);\n    group.add(mesh);\n  });\n\n  // add the points as a group to the scene\n  scene.add(group);\n}\n```", "```js\n// use the same points to create a convexgeometry\nvar convexGeometry = new THREE.ConvexGeometry(points);\nconvexMesh = createMesh(convexGeometry);\nscene.add(convexMesh);\n```", "```js\nfunction generatePoints(segments, phiStart, phiLength) {\n  // add 10 random spheres\n  var points = [];\n  var height = 5;\n  var count = 30;\n  for (var i = 0; i < count; i++) {\n    points.push(new THREE.Vector3((Math.sin(i * 0.2) + Math.cos(i * 0.3)) * height + 12, 0, ( i - count ) + count / 2));\n  }\n\n  ...\n\n  // use the same points to create a LatheGeometry\n  var latheGeometry = new THREE.LatheGeometry (points, segments, phiStart, phiLength);\n  latheMesh = createMesh(latheGeometry);\n  scene.add(latheMesh);\n}\n```", "```js\nvar options = {\n  amount: 10,\n  bevelThickness: 2,\n  bevelSize: 1,\n  bevelSegments: 3,\n  bevelEnabled: true,\n  curveSegments: 12,\n  steps: 1\n};\n\nshape = createMesh(new THREE.ExtrudeGeometry(drawShape(), options));\n```", "```js\nvar points = [];\nfor (var i = 0 ; i < controls.numberOfPoints ; i++) {\n  var randomX = -20 + Math.round(Math.random() * 50);\n  var randomY = -15 + Math.round(Math.random() * 40);\n  var randomZ = -20 + Math.round(Math.random() * 40);\n\n  points.push(new THREE.Vector3(randomX, randomY, randomZ));\n}\n\nvar tubeGeometry = new THREE.TubeGeometry(new THREE.SplineCurve3(points), segments, radius, radiusSegments, closed);\n\nvar tubeMesh = createMesh(tubeGeometry);\nscene.add(tubeMesh);\n```", "```js\n<svg version=\"1.0\"   x=\"0px\" y=\"0px\" width=\"1152px\" height=\"1152px\" xml:space=\"preserve\">\n  <g>\n  <path  id=\"batman-path\" style=\"fill:rgb(0,0,0);\" d=\"M 261.135 114.535 C 254.906 116.662 247.491 118.825 244.659 119.344 C 229.433 122.131 177.907 142.565 151.973 156.101 C 111.417 177.269 78.9808 203.399 49.2992 238.815 C 41.0479 248.66 26.5057 277.248 21.0148 294.418 C 14.873 313.624 15.3588 357.341 21.9304 376.806 C 29.244 398.469 39.6107 416.935 52.0865 430.524 C 58.2431 437.23 63.3085 443.321 63.3431 444.06 ... 261.135 114.535 \"/>\n  </g>\n</svg>\n```", "```js\nfunction drawShape() {\n  var svgString = document.querySelector(\"#batman-path\").getAttribute(\"d\");\n  var shape = transformSVGPathExposed(svgString);\n  return shape;\n}\n\nvar options = {\n  amount: 10,\n  bevelThickness: 2,\n  bevelSize: 1,\n  bevelSegments: 3,\n  bevelEnabled: true,\n  curveSegments: 12,\n  steps: 1\n};\n\nshape = createMesh(new THREE.ExtrudeGeometry(drawShape(), options));\n```", "```js\nfunction plane(u, v) {\t\n  var x = u * width;\n  var y = 0;\n  var z = v * depth;\n  return new THREE.Vector3(x, y, z);\n}\n```", "```js\nradialWave = function (u, v) {\n  var r = 50;\n\n  var x = Math.sin(u) * r;\n  var z = Math.sin(v / 2) * 2 * r;\n  var y = (Math.sin(u * 4 * Math.PI) + Math.cos(v * 2 * Math.PI)) * 2.8;\n\n  return new THREE.Vector3(x, y, z);\n}\n\nvar mesh = createMesh(new THREE.ParametricGeometry(radialWave, 120, 120, false));\n```", "```js\nu:0/5, v:0/4\nu:1/5, v:0/4\nu:2/5, v:0/4\nu:3/5, v:0/4\nu:4/5, v:0/4\nu:5/5, v:0/4\nu:0/5, v:1/4\nu:1/5, v:1/4\n...\nu:5/5, v:3/4\nu:5/5, v:4/4\n```", "```js\nvar options = {\n  size: 90,\n  height: 90,\n  weight: 'normal',\n  font: 'helvetiker',\n  style: 'normal',\n  bevelThickness: 2,\n  bevelSize: 4,\n  bevelSegments: 3,\n  bevelEnabled: true,\n  curveSegments: 12,\n  steps: 1\n};\n\n// the createMesh is the same function we saw earlier\ntext1 = createMesh(new THREE.TextGeometry(\"Learning\", options));\ntext1.position.z = -100;\ntext1.position.y = 100;\nscene.add(text1);\n\ntext2 = createMesh(new THREE.TextGeometry(\"Three.js\", options));\nscene.add(text2);\n};\n```", "```js\n<script type=\"text/javascript\" src=\"img/bitstream_vera_sans_mono_roman.typeface.js\">\n</script>\n```", "```js\nconsole.log(THREE.FontUtils.faces);\n```", "```js\n\"familyName\":\"Bitstream Vera Sans Mono\"\n```", "```js\n<script type=\"text/javascript\" src=\"img/coffee-script.js\"></script>\n<script type=\"text/coffeescript\" src=\"img/ThreeBSP.coffee\"></script>\n```", "```js\n<script type=\"text/coffeescript\">\n  onReady();\n</script>\n```", "```js\nfunction onReady() {\n  // Three.js code\n}\n```", "```js\ncoffee --compile ThreeBSP.coffee\n```", "```js\n<script type=\"text/javascript\" src=\"img/ThreeBSP.js\"></script>\n```", "```js\nfunction redrawResult() {\n  scene.remove(result);\n  var sphere1BSP = new ThreeBSP(sphere1);\n  var sphere2BSP = new ThreeBSP(sphere2);\n  var cube2BSP = new ThreeBSP(cube);\n\n  var resultBSP;\n\n  // first do the sphere\n  switch (controls.actionSphere) {\n    case \"subtract\":\n      resultBSP = sphere1BSP.subtract(sphere2BSP);\n    break;\n    case \"intersect\":\n      resultBSP = sphere1BSP.intersect(sphere2BSP);\n    break;\n    case \"union\":\n      resultBSP = sphere1BSP.union(sphere2BSP);\n    break;\n    case \"none\": // noop;\n  }\n\n  // next do the cube\n  if (!resultBSP) resultBSP = sphere1BSP;\n  switch (controls.actionCube) {\n    case \"subtract\":\n      resultBSP = resultBSP.subtract(cube2BSP);\n    break;\n    case \"intersect\":\n      resultBSP = resultBSP.intersect(cube2BSP);\n    break;\n    case \"union\":\n      resultBSP = resultBSP.union(cube2BSP);\n    break;\n    case \"none\": // noop;\n  }\n\n  if (controls.actionCube === \"none\" && controls.actionSphere === \"none\") {\n  // do nothing\n  } else {\n    result = resultBSP.toMesh();\n    result.geometry.computeFaceNormals();\n    result.geometry.computeVertexNormals();\n    scene.add(result);\n  }\n}\n```"]