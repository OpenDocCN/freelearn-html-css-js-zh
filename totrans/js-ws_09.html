<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer221">
			</div>
		</div>
		<div class="Content" id="_idContainer222">
			<h1 id="_idParaDest-343"><a id="_idTextAnchor381"/>9. Working with Node.js</h1>
		</div>
		<div class="Content" id="_idContainer244">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to describe the basics of and use <strong class="source-inline">Node.js</strong> to build basic web applications; differentiate between synchronous and asynchronous processing; use <strong class="source-inline">Node Package Manager (npm)</strong> to add, remove, and update the packages with your command-line interface; use built-in and third-party node modules; run MySQL and MongoDB databases; and build real-time web applications using <strong class="source-inline">WebSocket</strong>, and more.</p>
			<h1 id="_idParaDest-344"><a id="_idTextAnchor382"/>Introduction</h1>
			<p>So far, you have covered the fundamentals and core basics of JavaScript. This includes understanding the core syntax of building interactive web-based programs using JavaScript code. A strong understanding of the foundation of this programming language will enable us to take a look at Node.js, which is beyond the browser. It forms the basis for the popularity of JavaScript. </p>
			<p>In this chapter, you will be introduced to Node.js. Before Node.js, JavaScript was used primarily for client-side scripting as part of the browser. In 2009, Ryan Dahl developed Node.js, a cross-platform, open-source JavaScript runtime environment that executes JavaScript outside the browser. It allows developers to use command-line tools and carry out server-side scripting. Basically, it unites the entire process of web application development through a single programming language as opposed to the developer having to learn different languages and build different projects for the server-side and the client-side.</p>
			<p>Node.js is not just considered a programming language but an environment in which you can execute JavaScript. It is a popular programming language with a huge repository on GitHub that is sustained by contributions from thousands of developers all around the world. In this chapter, you will start with the installation of Node.js on all platforms, and then you will go through how it works in the background and how it processes requests asynchronously. Furthermore, you will study the different types of modules and how to use them. You will also do a lot of important exercises to get some practical exposure to Node.js. There are a lot of things to learn, so let's begin.</p>
			<h1 id="_idParaDest-345"><a id="_idTextAnchor383"/>The Node.js Environment</h1>
			<p>Node.js has an event-driven architecture that is capable of processing requests asynchronously. Node.js has a single-threaded architecture. Traditional servers had multi-threaded architectures and they spawned a new thread as soon as a new request landed, but Node.js handles everything on a single thread. You may wonder how a single-threaded Node.js handles millions of requests. Well, the answer is the event loop. JavaScript works on a single thread and handles async operations thanks to its event-loop architecture. Any request that is taking a long time is sent to the background and the next request is addressed and processed. Before proceeding, let's understand the difference between synchronous and asynchronous processing.</p>
			<h2 id="_idParaDest-346"><a id="_idTextAnchor384"/>Sync versus Async </h2>
			<p>If the execution of a program takes place in a linear sequence, it is synchronous processing. For example, in the following code block, an entire line will be read and executed before the process moves to the next line:</p>
			<p class="source-code"><a id="_idTextAnchor385"/>var fs = require('fs');</p>
			<p class="source-code">var contents = fs.readFileSync('fake.js', 'utf8');</p>
			<p class="source-code">console.log(contents);</p>
			<p>This process works best with only one request. In the case of multiple requests, you have to wait for the previous request to finish. This can be as exciting as watching grass grow. To overcome this, you can handle the request asynchronously. This way, you will push any process that is taking too long from the execution stack to the background so that other code can be executed. Once the background work is done, the program will be pushed back again to the execution stack and processed further:</p>
			<p class="source-code">var fs = require('fs');</p>
			<p class="source-code">fs.readFile('DATA', 'utf8', function(err, contents) {   </p>
			<p class="source-code">    console.log(contents);</p>
			<p class="source-code">});</p>
			<p class="source-code">console.log('after calling readFile');</p>
			<h2 id="_idParaDest-347"><a id="_idTextAnchor386"/>Background of Request Processing</h2>
			<p>Node.js uses a library named <strong class="source-inline">llibuv</strong>. It handles asynchronous I/O very well. Instead of spawning multiple threads for each request, it manages a thread pool very efficiently with the help of the OS kernel. As soon as a new request lands on a Node.js server, it delegates most of the work to other system workers. As soon as the background workers finish their job, they emit events to Node.js callbacks registered on that event. This process is visualized in the following figure: </p>
			<div>
				<div class="IMG---Figure" id="_idContainer223">
					<img alt="Figure 9.1: Node.js event loop architecture&#13;&#10;" src="image/C14377_09_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.1: Node.js event loop architecture</p>
			<p>Node.js is much faster than multithreaded systems, even with a single thread. Therefore, Node.js uses event loop architecture with thread pool management, which makes it powerful and faster than its competitors.</p>
			<h2 id="_idParaDest-348"><a id="_idTextAnchor387"/>What Are Callbacks?</h2>
			<p>Callbacks are a very important concept when it comes to asynchronous programming. A callback is a function that can be executed as soon as its primary function finishes. Callbacks are heavily used in Node.js.</p>
			<p>A typical example of where a callback would be useful is reading text from a file. While a file is read, you do not want the server to wait for it to finish first. Reading a file can be handled by a background worker and as soon as it finishes, it will execute an event, which will be processed by the event loop. This event will then execute the callback.</p>
			<h2 id="_idParaDest-349"><a id="_idTextAnchor388"/>The Node.js Shell</h2>
			<p>Node.js comes with a virtual terminal shell. It provides a quick way to use Node.js. You can execute expressions in the shell. You can also execute loops and define functions in the shell. To enter the shell, open your terminal and type node.</p>
			<p class="callout-heading">Note</p>
			<p class="callout"><strong class="source-inline">REPL</strong> is also a built-in module. You can also import it to your module.</p>
			<h2 id="_idParaDest-350"><a id="_idTextAnchor389"/>Exercise 9.01: Your First Program</h2>
			<p>Now that you know about the Node.js environment and its workings, you are ready to write your first script and execute it with Node.js. Let's write our first very simple Node.js script in which we will just perform the sum of two numbers and will show the output on the screen:</p>
			<ol>
				<li>Create a file named <strong class="source-inline">first.js</strong>. Open the terminal in the same directory and add the following lines:<p class="source-code">// 1. define the function</p><p class="source-code">let add = (a, b) =&gt; {  </p><p class="source-code">    return a + b;</p><p class="source-code">}</p><p class="source-code">// 2. Call the defined function</p><p class="source-code">console.log("Sum of 12 and 34 is", add(12, 34));</p></li>
				<li>Run the function to get the output:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer224">
					<img alt="Figure 9.2: Output of your first program&#13;&#10;" src="image/C14377_09_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.2: Output of your first program</p>
			<p>Here, you have written a simple function to add the two numbers, which you will pass when you call the function. Then, you will execute this script with Node.js and the output will be printed in the console.</p>
			<h2 id="_idParaDest-351"><a id="_idTextAnchor390"/>How to Import/Require a Module in a Node.js Application</h2>
			<p>Importing/requiring other modules in your program is very easy in Node.js. You can use <strong class="source-inline">require</strong> to import other modules into your Node.js application. Let's say we need one of the built-in modules of Node.js in our script. We would use the following syntax:</p>
			<p class="source-code">const path = require('path');</p>
			<p>This will look for the package within Node.js modules along with any globally or locally installed packages in the project. If it is found, it will import it; otherwise, it will throw an exception. When writing modularized code, you can create your own custom packages and import them using <strong class="source-inline">require</strong> with a relative path, like so:</p>
			<p class="source-code">const myModule = require('./modules/myModule');</p>
			<h2 id="_idParaDest-352"><a id="_idTextAnchor391"/>Node Package Manager (npm) </h2>
			<p>One of the good things about working with Node.js is that you can write highly modularized code. There are millions of packages available on the internet that can be used in your projects. But as the number of packages used in your projects grows, so too does the difficulty of handling them. Node.js comes with its own package manager, which is called npm. </p>
			<p>npm has thousands of packages, and all are easily available through its web portal and through your command-line interface. It is used to manage the packages your application needs. You can add, remove, and update packages with your command-line interface. </p>
			<p class="callout-heading">Note </p>
			<p class="callout"><strong class="source-inline">npm</strong> is preconfigured at the time of node installation on all major platforms. In the case of Linux, if you are facing issues while accessing <strong class="source-inline">npm</strong> after successfully installing Node.js, then you have to add the path of <strong class="source-inline">npm</strong> to the <strong class="source-inline">$PATH</strong> variables. Check the Linux installation part in the <em class="italic">Preface</em> of the book for more details. In the case of Windows and Mac, it's most likely that you will not face any issues.</p>
			<h3 id="_idParaDest-353"><a id="_idTextAnchor392"/>Flags</h3>
			<p>Some of the useful command-line flags are:</p>
			<p><strong class="source-inline">-g</strong> = Install the package globally, that is, in the system.</p>
			<p><strong class="source-inline">-S</strong> = Save the package as a project dependency. Similar to <strong class="source-inline">–save</strong>.</p>
			<p><strong class="source-inline">-D</strong> = Save the package as a <strong class="source-inline">dev</strong> dependency. Similar to <strong class="source-inline">--save-dev</strong>.</p>
			<p><strong class="source-inline">-v</strong> = Check the currently installed version.</p>
			<h3 id="_idParaDest-354"><a id="_idTextAnchor393"/>Commands</h3>
			<p>Some of the very useful commands of <strong class="source-inline">npm</strong> are given here:</p>
			<ul>
				<li><strong class="bold">Install</strong>:<p>In order to install a package, you can use the install or <strong class="source-inline">i</strong> parameters of <strong class="source-inline">npm</strong>. For instance, say you wanted to add <strong class="source-inline">express.js</strong> to your program – you would do that as follows:</p><p class="source-code">$ npm install express //i is the shortcut to install. (npm i express)</p></li>
				<li><strong class="bold">Update</strong>:<p>To update a package, you can use the update parameter of <strong class="source-inline">npm</strong>. For instance, you would use this if you wanted to update <strong class="source-inline">express.js</strong> in your program:</p><p class="source-code">$ npm update express</p></li>
				<li><strong class="bold">Remove</strong>:<p>To remove a package, you can use the remove or <strong class="source-inline">rm</strong> parameters of <strong class="source-inline">npm</strong>. For instance, say you wanted to remove the previously installed package (<strong class="source-inline">express.js</strong>) from your program – you could do so this way:</p><p class="source-code">$ npm remove express // rm is the shortcut to remove. (npm rm express)</p></li>
				<li><strong class="bold">Publish</strong>: <p>You can publish your own packages to the <strong class="source-inline">npm</strong> registry. Use the <strong class="source-inline">publish</strong> parameter to push the package to the <strong class="source-inline">npm</strong> registry:</p><p class="source-code">$ npm publish</p></li>
				<li><strong class="bold">Search</strong>: <p>You can even search the registry using the <strong class="source-inline">search</strong> parameter:</p><p class="source-code">$ npm search express</p></li>
			</ul>
			<h2 id="_idParaDest-355"><a id="_idTextAnchor394"/>package.json</h2>
			<p><strong class="source-inline">package.json</strong> is a file that always stays in the root of the project. It is a manifest file that almost all <strong class="source-inline">Node.js</strong> projects have. This is the file that <strong class="source-inline">npm</strong> uses to manage dependencies. Before starting development in <strong class="source-inline">Node.js</strong>, everybody should understand what <strong class="source-inline">package.json</strong> is and what it does. It basically serves two main purposes:</p>
			<ul>
				<li>Managing the dependencies of your project</li>
				<li>Providing scripts that help to generate builds, run tests, and other stuff related to your project</li>
			</ul>
			<p>You can define start scripts in this file, which will help you to inject environment variables into your project. You can even use this file to configure the production and development environments.</p>
			<p>To create this file in the project root, execute the following in your terminal:</p>
			<p class="source-code">$ npminit</p>
			<p>You will be prompted to answer a question. You can simply press <em class="italic">Enter</em> to skip it and a file named <strong class="source-inline">package.json</strong> will be created in your current directory:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer225">
					<img alt="Figure 9.3: Sample output of package.json&#13;&#10;" src="image/C14377_09_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.3: Sample output of package.json</p>
			<h2 id="_idParaDest-356"><a id="_idTextAnchor395"/>Publishing a Package</h2>
			<p>The <strong class="source-inline">npm</strong> registry is completely open to new packages. You can build and upload your own package to the <strong class="source-inline">npm</strong> registry, and to do that, you just need a directory with a <strong class="source-inline">package.json</strong> file in it. You can just write your module and update the <strong class="source-inline">package.json</strong> parameters. Then, you use the following command to push it to the registry:</p>
			<p class="source-code">$ npm publish</p>
			<p>You can now search for your package at <a href="https://www.npmjs.com">https://www.npmjs.com</a> and anyone can install your package as a dependency in their project.</p>
			<p>In this section, you were introduced to Node.js and its workings, and you wrote and executed your first Node.js program. You learned how to handle Node.js packages efficiently. You understood the purpose and importance of <strong class="source-inline">package.json</strong>. This was just the introduction. Now that we've introduced you to Node.js, let's dive deeper into managing Node.js packages and using them in your projects.</p>
			<h1 id="_idParaDest-357"><a id="_idTextAnchor396"/>Node Modules</h1>
			<p>To start with, we can say that Node.js modules can vividly comprehend the dependencies of an application. Suppose that you have created an easy-to-use payment application, say, for a restaurant. You have developed a payment app. Now, you get the idea to implement a QR scanner inside your app to make bill payments even easier. Well, you have two choices. Either create the entire feature yourself by spending time developing, or you can install the same functionality in your application using <strong class="source-inline">npm</strong>'s vast inventory of modules. </p>
			<p>All you need to do is follow these steps:</p>
			<ol>
				<li value="1">You need to search for the module name, say, <strong class="bold">QR scanner</strong>, to use in your Node or Angular application on Google.</li>
				<li>The very first link you need is <a href="https://www.npmjs.com/">https://www.npmjs.com/</a>. In this inventory, you can see many efficient Node.js modules. You can find a vast variety of modules there to use for anything from beautifying your terminal to rectifying your code. When you have got the module you need, you will have to install and merge it with your application. </li>
				<li>Now that you have the module, you just need to implement it in your application. Finally, the last step is to install the module in your application by entering the following command in your terminal:<p class="source-code">$ npm install &lt;module_name&gt; --save</p></li>
				<li>This will add your module as a dependency in your <strong class="source-inline">package.json</strong> file. You just need to import or require it as per the tech syntax. Just copy and paste the functions as per the installed module's guidelines. Now is the time to run your application:<p class="source-code">$ npm start</p></li>
			</ol>
			<p>You now have some wonderful new features in your application, added in a matter of minutes.</p>
			<p>To summarize this, a Node.js module is a properly bundled magical box consisting of one or more JavaScript files destined to fulfill a specific operation in your application, in the most efficient and sustainable way, that are maintained by its developers consistently.</p>
			<p>You can even make your own Node.js modules and publish them. That makes you an open source contributor. Before moving onto that, let's jump into an interesting discussion about built-in node modules.</p>
			<h2 id="_idParaDest-358"><a id="_idTextAnchor397"/>Node.js Modules</h2>
			<p>There are numerous modules included with Node.js that do not require installation. One such basic module is the URL module. </p>
			<p><strong class="bold">URL</strong></p>
			<p>URL is a module provided by Node.js that is used to split complicated URL strings into a more readable format. It can be used as follows:</p>
			<p class="source-code">const url = require('url');</p>
			<p>There are some utilities provided by this module that you can use to resolve and parse a URL. If you look at any URL closely, you will find that it contains some particular components written in a complex format:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer226">
					<img alt="Figure 9.4: Breakdown of URL into different terms&#13;&#10;" src="image/C14377_09_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.4: Breakdown of URL into different terms</p>
			<p>You can use the URL module to solve any difficulty that you're having. The module treats the URL as an object and each component inside the URL is treated as a property of the object, meaning you can access each and every part of the URL without difficulty.</p>
			<p>Some of the useful properties of URL are shown in this table:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer227">
					<img alt="Figure 9.5: URL Properties&#13;&#10;" src="image/C14377_09_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption"><a id="_idTextAnchor398"/>Figure 9.5: URL Properties</p>
			<h2 id="_idParaDest-359"><a id="_idTextAnchor399"/>Exercise 9.02: Updating URL Information Using the URL Module </h2>
			<p>To try and understand the different properties of a URL, let's do an exercise where we will try to update the information of a URL, such as the pathname and host. This will help us understand how to manipulate the properties of the URL object to alter URLs when we need to:</p>
			<ol>
				<li value="1">Create an empty file and save it with the <strong class="source-inline">.js</strong> extension. For this exercise, let's create <strong class="source-inline">url.js</strong>.</li>
				<li>The first thing to do is to import the URL module:<p class="source-code">const url = require('url');</p></li>
				<li>Now, let's use the <strong class="source-inline">parse</strong> function of the URL module and try to process a URL:<p class="source-code">const url = url.parse('https://www.google.com/maps#horizontal');</p></li>
				<li>After calling the <strong class="source-inline">parse</strong> function, in return, you will get a processable object. This object will contain all the metadata of that URL. We can then use this object to manipulate the URL. Let's change the host, pathname, and hash of the URL:<p class="source-code">url.host ='maps.google.com'; // https://maps.google.com/maps#horizontal</p><p class="source-code">url.pathname = '/q'; // https://maps.google.com/q</p><p class="source-code">url.hash = 'vertical'; // https://maps.google.com/q#vertical</p></li>
				<li>Now let's use the <strong class="source-inline">format</strong> function of the processable URL object to format it into a string and print it using the <strong class="source-inline">console.log</strong> function:<p class="source-code">console.log(URL.format(url));</p></li>
				<li>Finally, just execute the script using Node.js. It will print the new URL, which you have updated using the properties of the URL object:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer228">
					<img alt="Figure 9.6: Output of the URL program&#13;&#10;" src="image/C14377_09_06.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.6: Output of the URL program</p>
			<p>In this exercise, we learned how to manipulate the properties of a URL. We modified the different components of a URL by using different functions provided by the URL module.</p>
			<h2 id="_idParaDest-360"><a id="_idTextAnchor400"/>Filesystem</h2>
			<p>There is a Node.js section that you can use to work with the filesystem. You can perform various operations on files and directories using this module, such as create, update, read, and delete operations. The <strong class="source-inline">try...catch</strong> statement is a block of statements that are used to handle the exceptions that occur using synchronous operations. These exceptions may also be allowed to bubble up.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Before proceeding further, know that you will perform all of these operations on an <strong class="source-inline">intro.txt</strong> file, which contains the introduction of Node.js. So, make sure that you have the <strong class="source-inline">intro.txt</strong> file with some content in the root of the project where you will write these scripts. You can run and test scripts by simply typing <strong class="source-inline">node NameofYourFile.js</strong> in your terminal window, making sure that you have the appropriate rights.</p>
			<p>The various ways in which you can use this module are as follows:</p>
			<ul>
				<li><strong class="source-inline">read</strong> is used to read files in the filesystem using the <strong class="source-inline">fs.open()</strong> method:<p class="source-code">var fs = require('fs');</p><p class="source-code">fs.readFile('sample.txt', 'utf-8', (err, data) =&gt; {</p><p class="source-code">        if (err) { console.log(err) }</p><p class="source-code">        console.log('Data read from file: ', data);</p><p class="source-code">});</p><p>This will print all the data of the file to the console.</p></li>
				<li><strong class="source-inline">append</strong> adds specific content to files using <strong class="source-inline">fs.appendFile()</strong>:<p class="source-code">var fs = require('fs');</p><p class="source-code">var data = "\nLearn Node.js with the help of a well built <strong class="source-inline">Node.js</strong> tutorial.";</p><p class="source-code">fs.appendFile('sample.txt', data, 'utf8',</p><p class="source-code">// using the callback function</p><p class="source-code">function (err) {</p><p class="source-code">if (err) throw err;</p><p class="source-code">// if there is no error</p><p class="source-code">    console.log("New data was appended to file successfully.")</p><p class="source-code">});</p><p>It will append the line that you passed as the second parameter to the <strong class="source-inline">appendFile</strong> function to the file of the file.</p></li>
				<li>Renaming the files in the filesystem is done using the <strong class="source-inline">fs.rename()</strong> method:<p class="source-code">var fs = require('fs');</p><p class="source-code">fs.rename('sample.txt', 'introduction.txt', (err) =&gt; {</p><p class="source-code">        if (err) { console.log(err) }</p><p class="source-code">        console.log('Done');</p><p class="source-code">})</p><p>This code will rename the <strong class="source-inline">intro.txt</strong> file to <strong class="source-inline">introduction.txt</strong> file.</p></li>
				<li>Files can be deleted using the <strong class="source-inline">fs.unlink()</strong> method:<p class="source-code">var fs = require('fs');</p><p class="source-code">fs.unlink('introduction.txt', (err) =&gt; {</p><p class="source-code">        if (err) { console.log(err) }</p><p class="source-code">        console.log('Done');</p><p class="source-code">})</p></li>
			</ul>
			<p>You use <strong class="source-inline">unlink</strong> to remove any file from the filesystem. Just pass the relative path or filename that you want to remove, and it will unlink that file/path from the filesystem.</p>
			<h2 id="_idParaDest-361"><a id="_idTextAnchor401"/>Operating System </h2>
			<p>This section provides a number of operating system-related utility methods. It can be imported using:</p>
			<p class="source-code">const os = require('os');</p>
			<p>Some of the important functions of this module are:</p>
			<ul>
				<li><strong class="source-inline">os.arch()</strong><p>This method will return the operating system's CPU architecture for which the Node.js binary was compiled, that is, <strong class="source-inline">arm</strong>, <strong class="source-inline">arm64</strong>, <strong class="source-inline">x32</strong>, <strong class="source-inline">x64</strong>, and so on. This module is very helpful if you are designing any architecture-dependent module.</p></li>
				<li><strong class="source-inline">os.cpus()</strong><p>This method will return an array of objects that contains all the information about each CPU core.</p></li>
				<li><strong class="source-inline">os.hostname()</strong><p>This method will return the hostname of the operating system.</p></li>
				<li><strong class="source-inline">os.platform()</strong><p>This method will return the operating system platform for which Node.js is compiled. This will be set during the compile time of Node.js. Some of the famous platforms are Darwin, freebsd, linux, openbsd, and win32.</p></li>
				<li><strong class="source-inline">os.networkInterfaces()</strong><p>This method will give us all the information regarding network interfaces that have been assigned a network address. It will return an object, and each key will identify a network interface.</p></li>
			</ul>
			<h2 id="_idParaDest-362"><a id="_idTextAnchor402"/>Exercise 9.03: Fetching Details about the Operating System</h2>
			<p>Let's explore this module with a simple exercise. In this exercise, you will use Node.js' <strong class="source-inline">OS</strong> module to get details about the operating system:</p>
			<ol>
				<li value="1">You have to import the os module using <strong class="source-inline">require</strong> in your Node.js script:<p class="source-code">const os = require('os');</p></li>
				<li>Then, you can access this <strong class="source-inline">os</strong> object to call its properties and get the information necessary:<p class="source-code">console.log(os.arch()); //x32, x64</p><p class="source-code">console.log(os.platform()); //win32, Win64, Darwin, Linux</p></li>
				<li>You can then change the flow of your code execution based on the architecture on which the script is running.<p>The output will be visible as follows:</p><div class="IMG---Figure" id="_idContainer229"><img alt="Figure 9.7: Some useful methods of the built-in os module in REPL mode of node&#13;&#10;" src="image/C14377_09_07.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.7: Some useful methods of the built-in os module in REPL mode of node</p>
			<p>In this exercise, we learned some useful methods to change the flow of code execution based on the architecture of the script and fetch details about the operating system.</p>
			<h2 id="_idParaDest-363"><a id="_idTextAnchor403"/>Path Module</h2>
			<p>The <strong class="source-inline">path</strong> module provides utilities for working with file and directory paths. It can be imported as follows:</p>
			<p class="source-code">const path = require('path');</p>
			<p>Some of the important functions of this module are:</p>
			<p><strong class="source-inline">path.dirname(pathString)</strong></p>
			<p>This method will return the directory name of a path. It is similar to Unix's <strong class="source-inline">dirname</strong> command.</p>
			<p><strong class="source-inline">path.extname(pathString)</strong></p>
			<p>This method will return the extension of the path. It will move from the last occurrence of the . (period) character of the entered path to the end of the path.</p>
			<p><strong class="source-inline">path.format(pathObject)</strong></p>
			<p>This method will return a path string from an object with specific keys. This is the opposite of <strong class="source-inline">path.parse()</strong>.</p>
			<p><strong class="source-inline">path.join([...pathStrings, pathString... ])</strong></p>
			<p>This method joins all the given path segments together using a platform-specific separator as a delimiter, then normalizes the resulting path. It's very useful when you are switching directories programmatically.</p>
			<h2 id="_idParaDest-364"><a id="_idTextAnchor404"/>Exercise 9.04: How to Extract and Join Directories</h2>
			<p>Let's explore the <strong class="source-inline">path</strong> module in detail by working on an exercise. In this exercise, you will extract the directory from absolute and relative paths, join directories, and extract file extensions from a path:</p>
			<ol>
				<li value="1">Create an empty file and save it with a <strong class="source-inline">.js</strong> extension. For this exercise, let's name it <strong class="source-inline">path.js</strong>.</li>
				<li>Now, let's take some sample directories and filenames for you to use to observe how the <strong class="source-inline">path</strong> module manipulates paths. Note that these paths are related to Windows:<p class="source-code">let dir = 'C:/Packt';</p><p class="source-code">let otherDir = '/assets/images/';</p><p class="source-code">let file = path.js';</p></li>
				<li>First, let's get the directory from a path. Let's say that you have one path of a file (<strong class="source-inline">/Users/YourUserName/Documents/node/modules/myFile.js</strong>) and you want to extract the directory where this file exists:<p class="source-code">// On Windows: "C:/Packt"</p><p class="source-code">path.dirname(dir+file);</p></li>
				<li>Now, let's extract the file extension from the path string. For that, you have to use the '<strong class="source-inline">extname'</strong> function of the <strong class="source-inline">path</strong> module:<p class="source-code">path.extname(file); // ".js"</p></li>
				<li>Finally, let's try to join multiple directories and files to create a path. You can use the <strong class="source-inline">join</strong> method of the <strong class="source-inline">path</strong> module for this:<p class="source-code">path.join(dir, otherDir + file)</p></li>
				<li>Now that you have the finished code snippet, run <strong class="source-inline">node path.js</strong> in your terminal:<p class="source-code">const path = require('path');</p><p class="source-code">let dir = "C:/Packt";</p><p class="source-code">let otherDir = "/assets/images/";</p><p class="source-code">let file = "path.js";</p><p class="source-code">console.log(path.dirname(dir + file));</p><p class="source-code">console.log(path.extname(file));</p><p class="source-code">console.log(path.join(dir, otherDir + file));</p><p>The screenshot of this preceding code will be displayed as follows:</p><div class="IMG---Figure" id="_idContainer230"><img alt="Figure 9.8: Output of the path program&#13;&#10;" src="image/C14377_09_08.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 9.8: Output of the path program</p>
			<p>We can see the path to the directory in the preceding figure. We also learned to extract file extensions from a path.</p>
			<h1 id="_idParaDest-365"><a id="_idTextAnchor405"/>HTTP</h1>
			<p><strong class="source-inline">http</strong> is the most important module of Node.js. It helps you to spin up a server that will listen to one specific port. It will let you transfer information over <strong class="bold">Hypertext Transfer Protocol</strong> (<strong class="bold">HTTP</strong>).</p>
			<p>The <strong class="source-inline">createServer</strong> function takes one function as a parameter, which will be called when you make any request to the server. That function has two parameters: <strong class="source-inline">req</strong> and <strong class="source-inline">res</strong>. The first, the request parameter, is a stream that holds all the details of the request. For instance, if you are using a <strong class="source-inline">POST</strong> request to submit a form, then this object will hold all the values in it. The response parameter is also a stream, and you can use it to update the response header, status, and more: </p>
			<p class="source-code">res.writeHead(200, {'Content-Type': 'application/json'});</p>
			<p>Here, you are updating one key in the header and writing the status code as <strong class="source-inline">200</strong>, which is "OK." The difference between a parameter and a query is highlighted in the following figure:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer231">
					<img alt="Figure 9.9: Difference between a parameter and a query&#13;&#10;" src="image/C14377_09_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.9: Difference between a parameter and a query</p>
			<p>You can also get the parameter and the query from the same <strong class="source-inline">req</strong> object, which will help you to process the request.</p>
			<h2 id="_idParaDest-366"><a id="_idTextAnchor406"/>Exercise 9.05: Using a Node.js Server</h2>
			<p>Let's start our first Node.js server. This will be a very basic server that will just greet all requests with a "Hello World!" response. We will learn how to start up a server on a particular port and how to write responses to requests. Let's jump straight into coding:</p>
			<ol>
				<li value="1">Create a file named <strong class="source-inline">http_server.js</strong> and copy the following content into the file, then save it:<p class="source-code">var http = require('http');</p><p class="source-code">var port = 3000;</p><p class="source-code">// Start the server instance</p><p class="source-code">let server = http.createServer( function (req, res) {</p><p class="source-code">        res.write( 'Hello World!' ); // Response content</p><p class="source-code">        res.end(); // End response</p><p class="source-code">});</p><p class="source-code">server.listen( port ); // the server object listens on port 3000</p><p>It should display as follows:</p><div class="IMG---Figure" id="_idContainer232"><img alt="Figure 9.10: Node.js server&#13;&#10;" src="image/C14377_09_10.jpg"/></div><p class="figure-caption">Figure 9.10: Node.js server</p></li>
				<li>Run the <strong class="source-inline">http_server.js</strong> file using the following command in your terminal:<p class="source-code">$ npm i express</p></li>
				<li>Then open the browser and go to <strong class="source-inline">http://localhost:3000</strong>:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer233">
					<img alt="Figure 9.11: Output from the Node.js server in Chrome&#13;&#10;" src="image/C14377_09_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.11: Output from the Node.js server in Chrome</p>
			<p>We can see the <strong class="source-inline">Hello World</strong> response in the browser by starting the server. We learned how to use a Node.js server and how to write responses to requests.</p>
			<h2 id="_idParaDest-367"><a id="_idTextAnchor407"/>Third-Party Modules</h2>
			<p>Node has a huge library of packages where a lot of developers have written and published useful modules for you to use. You can simply download these modules using <strong class="source-inline">npm</strong> and use them in your projects. There are thousands of packages available in the <strong class="source-inline">npm</strong> repository. Let's look at some of the useful third-party packages available for Node.js.</p>
			<h2 id="_idParaDest-368"><a id="_idTextAnchor408"/>Express.js</h2>
			<p><strong class="source-inline">Express</strong> is one of the most popular frameworks of node.js. It is one of the reasons why Node.js is so popular. It is a minimal, open-source, and flexible web application framework that provides a robust set of features for web and mobile applications. </p>
			<p>You can install it using:</p>
			<p class="source-code">$ npm i express</p>
			<p>Starting up a web server is extremely simple in <strong class="source-inline">Express</strong>:</p>
			<p class="source-code">const express = require('express')</p>
			<p class="source-code">const app = express()</p>
			<p class="source-code">app.get('/', (req, res) =&gt; res.send('Hello World!'))</p>
			<p class="source-code">app.listen(3000, () =&gt; console.log('Example app listening on port 3000)));}!'))</p>
			<p>The server is up and running in just four lines of code.</p>
			<p>Routing in Express</p>
			<p><strong class="source-inline">Express</strong> has taken care of routing very well. You can write modularized routes in Express. The following code can be used to set up <strong class="bold">basic routing</strong>:</p>
			<p class="source-code">const express = require('express')</p>
			<p class="source-code">const app = express()</p>
			<p class="source-code">// GET</p>
			<p class="source-code">app.get('/', function (req, res) {</p>
			<p class="source-code">  res.send('Hello World!')</p>
			<p class="source-code">})</p>
			<p class="source-code">// POST</p>
			<p class="source-code">app.post('/', function (req, res) {</p>
			<p class="source-code">  res.send('Got a POST request')</p>
			<p class="source-code">})</p>
			<p class="source-code">// PUT</p>
			<p class="source-code">app.put('/user', function (req, res) {</p>
			<p class="source-code">  res.send('Got a PUT request at /user')</p>
			<p class="source-code">})</p>
			<p class="source-code">// DELETE</p>
			<p class="source-code">app.delete('/user', function (req, res) {</p>
			<p class="source-code">  res.send('Got a DELETE request at /user')</p>
			<p class="source-code">})</p>
			<h2 id="_idParaDest-369"><a id="_idTextAnchor409"/>The bodyParser Module</h2>
			<p>JSON is a very common data sharing format that is used by over 90% of the web applications on the internet. Managing JSON is very easy in JavaScript, but when it comes to sharing JSON online, it becomes a little more difficult. For this purpose, we use the <strong class="source-inline">bodyParser</strong> module. Data is shared as buffer on the internet. This module works as a middleware between the request received and your application. It converts the buffer to plain JSON and binds it to the request:</p>
			<p class="source-code">var express = require('express')</p>
			<p class="source-code">var bodyParser = require('body-parser')</p>
			<p class="source-code"> </p>
			<p class="source-code">var app = express()</p>
			<p class="source-code"> </p>
			<p class="source-code">// parse application/x-www-form-urlencoded</p>
			<p class="source-code">app.use(bodyParser.urlencoded({ extended: false }))</p>
			<p class="source-code"> </p>
			<p class="source-code">// parse application/json</p>
			<p class="source-code">app.use(bodyParser.json())</p>
			<p class="source-code"> </p>
			<p class="source-code">app.use(function (req, res) {</p>
			<p class="source-code">  res.setHeader('Content-Type', 'text/plain')</p>
			<p class="source-code">  res.write('you posted:\n')</p>
			<p class="source-code">  res.end(JSON.stringify(req.body, null, 2))</p>
			<p class="source-code">})</p>
			<h2 id="_idParaDest-370"><a id="_idTextAnchor410"/>Morgan Logger</h2>
			<p><strong class="source-inline">morgan</strong> is a logging module. Every time a request hits on the server, your application logs the request to reveal the real status of your server. A server can handle multiple types of requests. So, the application must log all the requests to check the health of the server. There are a lot of benefits to using loggers on a server. Some of them are listed here:</p>
			<ul>
				<li>You can track how many requests the server is processing in a day, week, month, and so on.</li>
				<li>You can see how much time each request is taking to process.</li>
				<li>You can see the types of requests that are getting hit, such as <strong class="source-inline">GET</strong>, <strong class="source-inline">POST</strong>, and <strong class="source-inline">PUT</strong>.</li>
				<li>You can see what endpoints are being used frequently.</li>
				<li>The module will maintain all the error logs.</li>
			</ul>
			<p><strong class="source-inline">morgan</strong> is very easy to use and is a configured middleware <strong class="source-inline">npm</strong> module for node applications. You can install it by entering the following command in your terminal:</p>
			<p class="source-code">$ npm install morgan --save</p>
			<p>Then use it in your application as follows:</p>
			<p class="source-code">var morgan = require('morgan')</p>
			<p>Finally, you just need to add this one line to create a middleware between <strong class="source-inline">morgan</strong> and your Node.js application:</p>
			<p class="source-code">app.use(morgan(':method :status :url - :response-time ms'));</p>
			<p>This will print the following log:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer234">
					<img alt="Figure 9.12: Output from the Node.js server in the terminal&#13;&#10;" src="image/C14377_09_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.12: Output from the Node.js server in the terminal</p>
			<p>In this section, we learned how to use built-in and third-party node packages in your project. You learned how to use routing and how to log requests on the server. It does not end here, though; you can write your own custom modules as well. The only thing you need to do is export one of the entry functions. An example is shown in the following figure:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer235">
					<img alt="Figure 9.13: Example of export and require using Node.js&#13;&#10;" src="image/C14377_09_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.13: Example of export and require using Node.js</p>
			<p>Think of a module export as a variable. A module export is a variable in which you will put some value and you can get the same data wherever your application requires this file. You can export functions, JSON, strings, or any type of data from any JavaScript file to any other JavaScript file in your application. </p>
			<h1 id="_idParaDest-371"><a id="_idTextAnchor411"/>Working with Databases </h1>
			<p>When it comes to the server-side, databases are very important. All the data that your applications need to store for future reference have to be stored somewhere. In this topic, you will learn how to use two of the most popular databases: MySQL and MongoDB.</p>
			<h2 id="_idParaDest-372"><a id="_idTextAnchor412"/>Setting up Databases</h2>
			<p>In this section, we will work with two of the major database types present today. Before proceeding further, let's go through different ways in which we can connect with databases. There are two ways to connect with databases:</p>
			<ul>
				<li>Locally: When a database server is running on your machine.</li>
				<li>Remotely: When a database server is running on some other machine and you are accessing it through the internet.</li>
			</ul>
			<p>You can have your database server running somewhere in the cloud and you can access it using a URL along with credentials. But for this section, let's set up both databases locally on the machine and let's connect to them using Node.js.</p>
			<p>The installation of both databases is pretty straightforward. You can download the latest bundles from their official websites and install them as you install other applications. For installation guidelines, you can follow their official documentation, which is very easy to understand. They have also covered installation on all different types of platforms, such as Windows and Linux. </p>
			<p>MySQL : <a href="https://packt.live/32ypsRH">https://packt.live/32ypsRH</a> MongoDB: <a href="https://packt.live/2PY7SDV">https://packt.live/2PY7SDV</a></p>
			<h2 id="_idParaDest-373"><a id="_idTextAnchor413"/>Connecting with Databases</h2>
			<p>After installing, you have to start both the database servers and configure a user. This is the user whose credentials you will use to get access to the database. For learning purposes, give this user administrator privileges so that you will have all the permissions to perform various types of actions.</p>
			<p>In order to connect with databases, we require some information about the server machine:</p>
			<p><strong class="bold">Host</strong>: The host will be the domain name or the IP address of the server where the database is running. </p>
			<p><strong class="bold">Port</strong>: This will be the port number on which the database server is listening. By default, MySQL database runs on port 3306 and MongoDB runs on port 27017. </p>
			<p><strong class="bold">User</strong>: Here, we have to specify the username of any active user of the database. We always create an administrator user just after finishing the installation. It is not recommended to use an administrator account with applications in production, but for learning purposes, we can use it. In a production environment, we must create a database user that has limited and necessary access only.</p>
			<p><strong class="bold">Password</strong>: The password of the user will go here.</p>
			<p><strong class="bold">Database</strong>: Here, we have to mention the name of the database with which we want to initialize the connection.</p>
			<p>We have to specify this configuration to the database driver that we will use when making connection with database. For example, when making a connection with MySQL, we have to specify this configuration:</p>
			<p class="source-code">var connection = MySQL.createConnection({</p>
			<p class="source-code">        host: 'localhost', // 127.0.0.1</p>
			<p class="source-code">        user: 'me',</p>
			<p class="source-code">        password: 'secret',</p>
			<p class="source-code">        database: 'my_db'</p>
			<p class="source-code">});</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If the port is not mentioned, it will pick the default value of the port number.</p>
			<p>We will learn more about how to make a connection and how to use this connection to fetch and save data for both MySQL and MongoDB in the next sections.</p>
			<h2 id="_idParaDest-374"><a id="_idTextAnchor414"/>MySQL</h2>
			<p>My<a id="_idTextAnchor415"/>SQL is a relational SQL database management system. It is one of the oldest, most successful, and most popular open-source databases in the world. It is widely used for developing various web-based software applications.</p>
			<p>The MySQL library is one of the most widely used <strong class="source-inline">npm</strong> libraries. Millions of developers use this library worldwide. The best way to learn about configuring the database is with practice. Let's go through a very useful exercise that will help you to learn about database setup in any Node.js project.</p>
			<h2 id="_idParaDest-375"><a id="_idTextAnchor416"/>Exercise 9.06: Install, Connect, and Process Responses with a MySQL Server</h2>
			<p>Let's do an exercise in which we will install a MySQL driver and connect it to a MySQL server. We will also take a look at how to fire MySQL queries to the database and how to process the responses:</p>
			<ol>
				<li value="1">In order to use this module with node, you can install it into your project as a dependency:<p class="source-code">$ npm install mysql</p></li>
				<li>After installing it, you can require it in the project using:<p class="source-code">var MySQL = require('mysql');</p></li>
				<li>After importing it into the project, you have to make a connection with the database. For that, you can use the <strong class="source-inline">createConnection</strong> method.</li>
				<li>If everything went fine, the connection will be ready. You can fire the MySQL query using:<p class="source-code">var connection = MySQL.createConnection({</p><p class="source-code">        host: 'localhost',</p><p class="source-code">        user: 'me',</p><p class="source-code">        password: 'secret',</p><p class="source-code">        database: 'my_db'</p><p class="source-code">});</p><p class="source-code">connection.connect(function (err) {</p><p class="source-code">        if (err) {</p><p class="source-code">                console.error('error connecting: ' + err.stack);</p><p class="source-code">                return;</p><p class="source-code">        }</p><p class="source-code">        console.log('connected as id ' + connection.threadId);</p><p class="source-code">}</p><p class="source-code">);</p><p class="source-code">Code runs connection and logs thread ID to console. From here on, the reader should be able to run queries like,connection.query('SELECT * FROM table, function(err, result, fields)  </p><p class="source-code">{ </p><p class="source-code">  if (err) throw err;</p><p class="source-code">  console.log(result); </p><p class="source-code">});</p><p class="callout-heading">Note</p><p class="callout">Before closing the connection, note that port 3307 is the author's local port. The standard MySQL port is 3306.</p><div class="IMG---Figure" id="_idContainer236"><img alt="Figure 9.14: Passing credentials in MySQL Server&#13;&#10;" src="image/C14377_09_14.jpg"/></div><p class="figure-caption">Figure 9.14: Passing credentials in MySQL Server</p></li>
				<li>Make sure that you pass the credentials of the user you created earlier while going through the previous section (<em class="italic">Setting Up Databases</em>):<p class="source-code">connection.query('SELECT 1 + 1 AS solution', function (error, results, fields) {</p><p class="source-code">        if (error) throw error;</p><p class="source-code">        console.log('The solution is: ', results[0].solution);</p><p class="source-code">      });  </p></li>
				<li>When done querying the database, you can close the connection using:<p class="source-code">connection.end();</p></li>
				<li>To check the connection, use the following query to the database:<p class="source-code">if(connection.state === 'disconnected'){</p><p class="source-code">     return respond(null, { status: 'fail', message: 'server down'});</p><p class="source-code">   } else ("continue with app code")</p></li>
			</ol>
			<p>In this exercise, we connected to a MySQL server and fired MySQL queries to the database to process the responses.</p>
			<h2 id="_idParaDest-376"><a id="_idTextAnchor417"/>MongoDB</h2>
			<p>MongoDB is a leading open-source NoSQL database. It is a document-oriented database program written in C++. It uses a JSON-like structure to store data, which is why it is most popular for use with node apps. It is also a part of the MEAN stack, which is one of the most popular tech stacks in the world today. The MEAN stack is a combination of the four major technologies of MongoDB, Express.js, AngularJS, and Node.js. In MongoDB, tables are referred to as collections, and data rows are referred to as documents. Documents are formatted in JSON format and are, by default, schema independent.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Make sure to run the local MongoDB server first, and then get the URI to the connection. A URI contains the protocol, authentication, port, and database name a single string. You will learn about the format of the URI soon.</p>
			<h2 id="_idParaDest-377"><a id="_idTextAnchor418"/>Exercise 9.07: Installing and Configuring a Connection in MongoDB</h2>
			<p>Let's write some code in Node.js to help us connect our application with MongoDB. After this exercise, you will be able to install MongoDB and configure a connection with MongoDB using Node.js:</p>
			<ol>
				<li value="1">In order to install the driver, use the following command in your terminal:<p class="source-code">$ npm install mongodb --save</p></li>
				<li>Then, in your application, make it a requirement:<p class="source-code">const MongoClient = require('mongodb').MongoClient;</p></li>
				<li>Then you have to prepare a connection URL. It must be in the following form:<p class="source-code">mongodb://[username:password@]host1[:port1][,...hostN[:portN]]][/[database][?options]]</p></li>
				<li>You can use this URI to connect with MongoDB:<p class="source-code">const url = 'mongodb://localhost:27017';</p><p class="source-code">MongoClient.connect(url, function(err, client) {</p><p class="source-code">  assert.equal(null, err);</p><p class="source-code">  console.log("Connected successfully to server");</p><p class="source-code"> </p><p class="source-code">  const db = client.db(dbName);</p><p class="source-code"> </p><p class="source-code">  client.close();</p><p class="source-code">});</p><p>The output will be displayed as follows:</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer237">
					<img alt="Figure 9.15: Successful connection with MongoDB&#13;&#10;" src="image/C14377_09_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.15: Successful connection with MongoDB</p>
			<p>Make sure you pass the credentials of the user you created earlier while going through the <em class="italic">Setting Up Databases</em> section.</p>
			<p>In this exercise, you learned about one of the main database that we have in the industry today. So far, you have learned about what MySQL and MongoDB are and how to use them with node apps.</p>
			<h1 id="_idParaDest-378"><a id="_idTextAnchor419"/>Making Real-Time Web Apps </h1>
			<p>Our world is very dynamic, and we are living in an era where live communication is crucial. Whether talking to another person in real life or following cricket scores, real-time communication, and data are very important. The best thing about Node.js is its support for streams and WebSocket. Node.js is the perfect tool for creating a real-time web application.</p>
			<h2 id="_idParaDest-379"><a id="_idTextAnchor420"/>WebSocket</h2>
			<p>WebSocket provides a continuous full-duplex communication channel. This means that both the server and the client communicate and exchange data at the same time over a single TCP connection. With WebSocket, clients do not have to refresh a page to see changes. The server will push the date back to the client. WebSocket helps facilitate the dynamic flow of connections, resulting in communication at both ends being achieved at considerable speeds. It means that you can now receive and send data on one connection only. </p>
			<p>A server can configure the client in real-time because of the lack of lag in communication, and the client can continuously share its data with the server, which will allow it to analyze and optimize the project:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer238">
					<img alt="Figure 9.16: Duplex tunnel between client and server with WebSocket connection&#13;&#10;" src="image/C14377_09_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.16: Duplex tunnel between client and server with WebSocket connection</p>
			<p>The WebSocket connection is made through a process known as the WebSocket handshake. This process starts with the client initiating a regular HTTP request to the server. Any additional information will be included in the header of this request, which informs the server that the client wishes to establish a WebSocket connection. If the server has WebSocket configured, it will accept the request. When the handshake is complete, the initial HTTP connection is replaced by a WebSocket connection. This connection uses the same underlying TCP/IP connection that HTTP uses. Now, either the frontend or backend can start sending data.</p>
			<h2 id="_idParaDest-380"><a id="_idTextAnchor421"/>Socket.IO</h2>
			<p>Socket.IO is a library that enables real-time, bidirectional, and event-based communication between the browser and the server. It is built to make the use of WebSocket easier. It only requires two things:</p>
			<ul>
				<li>A Node.js server</li>
				<li>A JavaScript library for the browser</li>
			</ul>
			<p>It supports auto-connect, which means if one client disconnects for any reason, it will continuously try to reconnect with the server. </p>
			<p>Let's look at how to install it in your project. Use the following command in your terminal:</p>
			<p class="source-code">$ npm install socket.io --save  </p>
			<p>Next, configure it with your app server:</p>
			<p class="source-code">const express = require('express')</p>
			<p class="source-code">const app = express();</p>
			<p class="source-code">server.listen(3000);</p>
			<p class="source-code">const io = require('socket.io')(server)</p>
			<p><strong class="source-inline">socket.io</strong> is now configured with the app server. You can bind events and listeners using the <strong class="source-inline">io</strong> variable. Now, whenever a new client connects with the server, it executes a connection event where you can get all the information regarding the sockets:</p>
			<p class="source-code">io.on('connection', client =&gt; {</p>
			<p class="source-code">        client.on('event', data =&gt; { /* … */ });</p>
			<p class="source-code">        client.on('disconnect', () =&gt; { /* … */ });</p>
			<p class="source-code">      });      </p>
			<p>That's it. It is really that simple to configure socket.io with your app server.</p>
			<h2 id="_idParaDest-381"><a id="_idTextAnchor422"/>Exercise 9.08: Building a Chat Application</h2>
			<p>Let's make a real-time chat application using node and socket.io. In this exercise, we will create an app that will allow us to start multiple sessions for different users and develop a real-time chat experience between users. This will be a very basic and simple chat application where you will be able to create a group where:</p>
			<ul>
				<li>You can chat in real-time.</li>
				<li>More than one person can join the group.</li>
				<li>Each member will be assigned fake names by default.</li>
				<li>You can change your name.</li>
				<li>You can see who is typing at any time.</li>
			</ul>
			<p>Before proceeding further, let's go through the file structure of our project:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer239">
					<img alt="Figure 9.17: File structure of this exercise&#13;&#10;" src="image/C14377_09_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.17<a id="_idTextAnchor423"/>: File structure of this exercise</p>
			<p>There are two main files:</p>
			<ul>
				<li><strong class="source-inline">App.js</strong>: This file contains all the server-side configuration. In this file, we will configure <strong class="source-inline">socket.io</strong>, write all events and listeners, and perform the routing of the requests.</li>
				<li><strong class="source-inline">Chat.js</strong>: This file contains all the code required for the client-side.</li>
			</ul>
			<ol>
				<li value="1">Start the server and configure it to use <strong class="source-inline">socket.io</strong> in <strong class="source-inline">app.js</strong> by adding the following code:<p class="source-code">const express = require('express')</p><p class="source-code">const app = express()</p><p class="source-code">// Listen on port 3000</p><p class="source-code">server = app.listen(3000)</p><p class="source-code">// Configuring Socket</p><p class="source-code">const io = require('socket.io')(server)</p></li>
				<li>Now, WebSocket is configured with the server. Let's create some events and listeners that will help us communicate with the client (frontend) and listen on every connection:<p class="source-code">io.on('connection', (socket) =&gt; {</p><p class="source-code">        //listen on change_username</p><p class="source-code">        socket.on('change_username', (data) =&gt; {</p><p class="source-code">            socket.username = data.username</p><p class="source-code">        })</p><p class="source-code">    </p><p class="source-code">        //listen on typing</p><p class="source-code">        socket.on('typing', (data) =&gt; {</p><p class="source-code">        socket.broadcast.emit('typing',{username : socket.username</p><p class="source-code">})</p><p class="source-code">})</p><p class="source-code">})</p><p>The application is listening for two events, <strong class="source-inline">typing</strong> and <strong class="source-inline">change_username</strong>. They will be executed whenever a socket emits these events. </p></li>
				<li>Now, you are done with your server-side code. Let's work on the frontend (client). First, import the socket.io library to the client-side. After a successful configuration of the server, you can open <strong class="source-inline">http://localhost:3000/socket.io/socket.io.js</strong> in your browser, which will download a script file. This is the file that you have to import on the client-side. </li>
				<li>Add the following <strong class="source-inline">script</strong> tag inside <strong class="source-inline">index.html</strong>:<p class="source-code">&lt;script src='/socket.io/socket.io.js'&gt;&lt;/script&gt;</p></li>
				<li>The complete file will look like this:<p class="source-code-heading">index.html</p><p class="source-code">2 &lt;html&gt;</p><p class="source-code">3 &lt;head&gt;</p><p class="source-code">4     &lt;meta http-equiv="Content-Type" const="text/html;charset=UTF-8" /&gt;</p><p class="source-code">5     &lt;link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/boot       strap.min.css"</p><p class="source-code">6         integrity="sha384-ggOyR0iXCbMQv3Xipma34MD+dH/1fQ784/j6cY/iJTQUOhcWr7x9JvoRxT2MZw1T"           crossorigin="anonymous"&gt;</p><p class="source-code">7     &lt;link rel="stylesheet" type="text/css" href="style.css"&gt;</p><p class="source-code">8     &lt;script src="/socket.io/socket.io.js"&gt;&lt;/script&gt;</p><p class="source-code">9     &lt;title&gt;Packt - Chat App Exercise&lt;/title&gt;</p><p class="source-code">10 &lt;/head&gt;</p><p class="source-code">11 </p><p class="source-code">12 &lt;body&gt;</p><p class="source-code">13     &lt;header&gt;</p><p class="source-code">14         &lt;h1&gt;Avengers Chatroom&lt;/h1&gt;</p><p class="source-code">15     &lt;/header&gt;</p><p class="source-code-link">The full code is available at: <a href="https://packt.live/2NIGAjn">https://packt.live/2NIGAjn</a></p></li>
				<li>Let's configure the client-side by connecting the client-side to the server. Create a file named <strong class="source-inline">chat.js</strong> and make sure that both <strong class="source-inline">index.html</strong> and <strong class="source-inline">chat.js</strong> are in the same directory or folder. If you want to move the files to different locations, then you have to reflect this in the <strong class="source-inline">import</strong> link in your <strong class="source-inline">index.html</strong> as well.</li>
				<li>You have to declare the link to the server where the request will be forwarded to in <strong class="source-inline">chat.js</strong>:<p class="source-code">var socket = io.connect('http://localhost:3000');</p></li>
				<li>We are using <strong class="source-inline">localhost</strong> because the server is running on our local machine. It listens for events that are executed by the server. In this case, we need to listen for <strong class="source-inline">keyboard typing</strong>.  Enter the following code snippet below the declared connection in the <strong class="source-inline">chat.js</strong> file:<p class="source-code">socket.on('typing', (data) =&gt; {</p><p class="source-code">feedback.html("&lt;p&gt;&lt;i&gt;&lt;b&gt;" + data.username + "&lt;/b&gt; is typing a message..." + "&lt;/i&gt;&lt;/p&gt;")</p><p class="source-code">})</p><p class="source-code">        </p><p class="source-code">//Listen on typing</p><p class="source-code">socket.on('stop_typing', (data) =&gt; {</p><p class="source-code">feedback.html("")</p><p class="source-code">})</p></li>
				<li>Execute the server file with the following command in your terminal to start the server and listen to all requests:<p class="source-code">§ npm start</p></li>
				<li>Now, open two instances of Chrome and visit <strong class="source-inline">http://localhost:3000</strong>. These two instances of Chrome will create two sessions, which will mimic two different users. Just start typing and sending messages to have a good conversation in real-time:<p class="callout-heading">Note</p><p class="callout">The code will be available in the GitHub repository for this book at <a href="https://packt.live/36KWlh0">https://packt.live/36KWlh0</a>.</p></li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer240">
					<img alt="Figure 9.18: Two Chrome sessions conducting a real-time chat&#13;&#10;" src="image/C14377_09_18.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.18: Two Chrome sessions conducting a real-time chat</p>
			<p>As you can see in this figure, there are two sessions of Chrome running. These two sessions represent two users. Both can chat in real-time. They can even see whether the other person is typing or not.</p>
			<p>In this section, you were introduced to building real-time web applications in node using socket.io and you built a cool chat app.</p>
			<h2 id="_idParaDest-382">Activity 9.01<a id="_idTextAnchor424"/>: Create a Web Application to Upload, Store, and Save Image Details</h2>
			<p>A major part of web development is uploading media and referring to it in the future. In this activity, you'll create a web application that will allow you to upload images to a server and store them in a directory. To make it even more challenging, you'll need to save the image details in a database for further use and analytics.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This activity requires a MySQL database server to be running on the system. Please make sure that a MySQL server is installed and running on your machine before executing this script.</p>
			<p>When the request reaches the server, it will first rename the file and then upload the image to the directory, before sending the path of the images as a response back to the client:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer241">
					<img alt="Figure 9.19: Output of the node server&#13;&#10;" src="image/C14377_09_19.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.19: Output of the node server</p>
			<p>You should get the following log from the server-side:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer242">
					<img alt="Figure 9.20: File is uploaded in the image's directory on the server&#13;&#10;" src="image/C14377_09_20.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.20: File is uploaded in the image's directory on the server</p>
			<p>Once the file is uploaded to the directory successfully, you should see the following MySQL output:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer243">
					<img alt="Figure 9.21: MySQL output&#13;&#10;" src="image/C14377_09_21.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.21: MySQL output</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Details about the image file are also successfully stored in the database.</p>
			<p>Here are the steps that will help you complete the activity:</p>
			<ol>
				<li value="1">Define the directory structure.</li>
				<li>Import all of the dependencies.</li>
				<li>Configure the Node.js <strong class="source-inline">morgan</strong> module to log each of the request details in the console.</li>
				<li>Configure your application to use the MySQL database.</li>
				<li>Establish the database connection to configure <strong class="source-inline">Multer</strong>.</li>
				<li>Add routing to the application.</li>
				<li>Start the server.</li>
				<li>Send a request to upload the image to the server.<p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found on page 738.</p></li>
			</ol>
			<h1 id="_idParaDest-383"><a id="_idTextAnchor425"/>Summary</h1>
			<p>So far, you have covered nearly all the basics of web development with Node.js. </p>
			<p>You started with an introduction to Node.js, wrote your first program, and ran it. You learned about Node's package manager and the Node.js environments. You were guided through some of the useful built-in and third-party Node.js modules and discovered how you can import these modules in your application and use common modules such as <strong class="source-inline">body parse</strong> and <strong class="source-inline">auth</strong>. You created connections with databases using Node.js and learned how to make queries in the databases. </p>
			<p>Finally, you learned how to make a real-time web application and learned how to build a chat application. There are a lot of concepts still to cover because node is huge, however, you have the required knowledge to explore node further with ease. In the next chapter, you will learn how to use requests to communicate with other services. You will look into different types of requests and how to process and display data. You will also take a look at <strong class="bold">RESTful APIs</strong>. </p>
			<p>Let's move on to the next chapter.</p>
		</div>
	</body></html>