<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Highcharts APIs</h1></div></div></div><p>Highcharts offers a small set of APIs designed for plotting charts with dynamic interactions. In order to understand how the APIs work, we must first familiarize ourselves with the chart's internal objects and how they are organized inside a chart. In this chapter, we will learn about the chart class model and how to call the APIs by referencing the objects. Then we build a simple stock price application with PHP, jQuery, and jQuery UI to demonstrate the use of Highcharts APIs. After that, we turn our attention to four different ways of updating a series. We experiment with all the series update methods with the purpose of building an application to illustrate variations in visual effects, and the difference in CPU performance between them. Finally, we investigate performance when updating a series with popular web browsers, in terms of different sizes of datasets. In this chapter, we will cover the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Understanding the Highcharts class model</li><li class="listitem" style="list-style-type: disc">Getting data in Ajax and displaying new series with <code class="literal">Chart.addSeries</code></li><li class="listitem" style="list-style-type: disc">Displaying multiple series with simultaneous Ajax calls</li><li class="listitem" style="list-style-type: disc">Using <code class="literal">Chart.getSVG</code> to format SVG data into an image file</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">Chart.renderer</code> methods</li><li class="listitem" style="list-style-type: disc">Exploring different methods to update series and their performance</li><li class="listitem" style="list-style-type: disc">Experimenting with Highcharts performance with large datasets</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec66"/>Understanding the Highcharts class model</h1></div></div></div><p>The relationship between <a id="id634" class="indexterm"/>Highcharts classes is very simple and obvious. A chart is composed of five different classes—<code class="literal">Chart</code>, <code class="literal">Axis</code>, <code class="literal">Series</code>, <code class="literal">Point</code>, and <code class="literal">Renderer</code>. Some of these classes contain an array of lower-level components and an object property to back-reference to a higher level-owner component. For example, the <code class="literal">Point</code> class has the <code class="literal">series</code> property pointing back to the owner <code class="literal">Series</code> class. Each class also has a set of methods for managing and displaying its own layer. In this chapter, we will focus on the set of APIs for dynamically modifying charts. The following class diagram describes the association between these classes:</p><div><img src="img/7451OS_10_01.jpg" alt="Understanding the Highcharts class model"/></div><p>The <code class="literal">Chart</code> class is<a id="id635" class="indexterm"/> the top level class representing the whole chart object. It contains method calls to operate the chart as a whole—for example, exporting the chart into SVG or other image formats and setting the dimension of the chart. The <code class="literal">Chart</code> class has multiple arrays of <code class="literal">Axis</code> and <code class="literal">Series</code> objects; that is, a chart can have one or more <em>x</em> axes, <em>y</em> axes, and series. The <code class="literal">Renderer</code> class is a utility class that has a one-to-one relationship per chart and provides a common interface for drawing in SVG and VML-based browsers.</p><p>The <code class="literal">Series</code> class has an array of <code class="literal">Point</code> objects. The class has back-reference properties towards the <code class="literal">Chart</code> and <code class="literal">Axis</code> objects (see the dotted lines in the previous diagram) and provides functions for managing its list of <code class="literal">Point</code> objects. The <code class="literal">yAxis</code> and <code class="literal">xAxis</code> properties in the <code class="literal">Series</code> class are necessary, as a chart can have multiple axes.</p><p>The <code class="literal">Point</code> class is just a simple object containing x and y values and a back-reference to its series object (see the dotted line). The APIs are for managing the data points in the chart.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec70"/>Highcharts constructor – Highcharts.Chart</h2></div></div></div><p>Needless to say, the most important method in the APIs is<a id="id636" class="indexterm"/> the <code class="literal">Highcharts.Chart</code> method, with <a id="id637" class="indexterm"/>which we have seen plenty of action so far. However, there is more to this constructor call. <code class="literal">Highcarts.Chart</code> creates and returns a chart object but it also has a second optional parameter known as <code class="literal">callback</code>:</p><div><pre class="programlisting">Chart(Object options, [ Function callback ])</pre></div><p>The callback<a id="id638" class="indexterm"/> function is called when a chart is created and rendered. Inside the function, we can either call the component methods or access the properties inside the chart object. The newly created chart object is passed via the only callback function parameter. We can also use the '<code class="literal">this</code>' keyword inside the callback function, which also refers to the chart <a id="id639" class="indexterm"/>object. Instead of using the <code class="literal">Highcharts.Chart</code> callback parameter, we can achieve the same result by declaring our code inside the <code class="literal">chart.events.load</code> handler, which will be explored in the next chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec71"/>Navigating through Highcharts components</h2></div></div></div><p>In order to use the Highcharts API, we<a id="id640" class="indexterm"/> must navigate to the right object inside the class hierarchy. There are several ways to traverse within the chart object: through the chart hierarchy model, retrieving the component directly with the <code class="literal">Chart.get</code> method, or a mixture of both.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec14"/>Using the object hierarchy</h3></div></div></div><p>Suppose <a id="id641" class="indexterm"/>that the chart <a id="id642" class="indexterm"/>object is created, as follows:</p><div><pre class="programlisting">&lt;script type="text/javascript"&gt;
  $(document).ready(function() {
    var chart = new Highcharts.Chart({
      chart: {
          renderTo: "container"
      },
      yAxis: [{
        min: 10,
        max: 30
      }, {
        min: 40,
        max: 60
      }],
      series: [{
        data: [ 10, 20 ]
      }, {
        data: [ 50, 70 ],
        yAxis: 1
      }],
      subtitle: {
          text: "Experiment Highcharts APIs"
      }
           
    });
  }, function() {
   ...
  });
&lt;/script&gt;</pre></div><p>We can then access the first position of the series' object with the index 0 from the chart. Inside the callback handler, we use the <code class="literal">this</code> keyword to refer to the chart object as follows:</p><div><pre class="programlisting">var series = this.series[0];</pre></div><p>Suppose there are two <em>y</em> axes in the configuration. To retrieve the second <em>y</em> axis, we can do as follows:</p><div><pre class="programlisting">var yAxis = this.yAxis[1];</pre></div><p>To retrieve the third data point object<a id="id643" class="indexterm"/> from the second series of the chart, type the following:</p><div><pre class="programlisting">var point = this.series[1].data[2];</pre></div><p>Supposing multiple<a id="id644" class="indexterm"/> charts are created on the page, a chart object can be accessed via the Highcharts namespace:</p><div><pre class="programlisting">var chart = Highcharts.charts[0];</pre></div><p>We can also retrieve the chart's container element through the container option:</p><div><pre class="programlisting">var container = chart.container;</pre></div><p>To examine the options structure of a created chart, use the options property:</p><div><pre class="programlisting">// Get the chart subtitle
var subtitle = chart.options.subtitle.text;</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec15"/>Using the Chart.get method</h3></div></div></div><p>Instead of cascading down the<a id="id645" class="indexterm"/> object hierarchy, we can directly retrieve the<a id="id646" class="indexterm"/> component using the <code class="literal">Chart.get</code> method (the <code class="literal">get</code> method is only available at the chart level, not in each component class). Assigning components with IDs will allow you to access them directly using the <code class="literal">get</code> method instead of traversing nodes in the object's hierarchical structure. The configuration uses the option key <code class="literal">id</code>, so this value must be unique.</p><p>Suppose we have created a chart with the following configuration code:</p><div><pre class="programlisting">xAxis: {
  id: 'xAxis',
  categories: [ ... ]
},
series: [{
  name: 'UK',
  id: 'uk',
  data: [ 4351, 4190, 
      { y: 4028, id: 'thirdPoint' }, 
      ... ]
}]</pre></div><p>We can retrieve the components as follows:</p><div><pre class="programlisting">var series = this.get('uk');
var point = this.get('thirdPoint');
var xAxis = this.get('xAxis');</pre></div><p>If the <code class="literal">id</code> option is not <a id="id647" class="indexterm"/>previously configured, we can<a id="id648" class="indexterm"/> use the JavaScript <code class="literal">filter</code> method to search for the item based on the property:</p><div><pre class="programlisting">this.series.filter(function(elt) {return elt.name == 'uk';})[0];</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec16"/>Using both the object hierarchy and the Chart.get method</h3></div></div></div><p>It is cumbersome <a id="id649" class="indexterm"/>to define the <code class="literal">id</code> option for every<a id="id650" class="indexterm"/> component inside the chart. Alternatively, we can navigate <a id="id651" class="indexterm"/>through the components using both approaches, as follows:</p><div><pre class="programlisting">var point = this.get('uk').data[2];</pre></div></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec67"/>Using the Highcharts APIs</h1></div></div></div><p>In this section, we will<a id="id652" class="indexterm"/> build an example using jQuery, jQuery UI, and Highcharts to explore each component's APIs. All the example code from here on will be using the object hierarchy to access chart components, that is, <code class="literal">chart.series[0].data[0]</code>. The user interface used here has a very minimal look and is far from perfect, as the main purpose of this exercise is to examine the Highcharts APIs.</p><p>First, let's see the usage of this user interface; then we will dissect the code to understand how the operations are performed. The following is the final UI screenshot that will be created in this section:</p><div><img src="img/7451OS_10_02.jpg" alt="Using the Highcharts APIs"/></div><p>This is a simple web frontend for plotting the stock data chart for the past 30 days. The top part is a group of buttons for setting the stock symbols, getting the stock price, and retrieving the chart image by downloading it or via e-mail. The <strong>Add to the list</strong> button is for adding a stock symbol straight to the list without getting the stock prices and plotting the data. The <strong>Plot All</strong> button is for launching multiple stock price queries from the symbol list simultaneously, and to plot the data when all the results arrive. Alternatively, <strong>Add &amp; Plot</strong> is a quick option for plotting a single stock symbol.</p><p>The bottom half contains a <a id="id653" class="indexterm"/>chart that we have already created. The chart is displayed with empty data and axes with titles (setting the <code class="literal">showAxes</code> option to <code class="literal">true</code>). The whole idea is to reuse the existing chart rather than recreating a new chart object every time new results arrive. Therefore, there is no flickering effect when the chart is destroyed and created and it appears as a smooth update animation. This also provides better performance without running extra code to regenerate the chart object.</p><p>This example is<a id="id654" class="indexterm"/> also available online at <a class="ulink" href="http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_1.html">http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_1.html</a>.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec72"/>Chart configurations</h2></div></div></div><p>The following<a id="id655" class="indexterm"/> is the chart<a id="id656" class="indexterm"/> configuration used for the example. Once a stock query is made, the server-side script will request the stock prices for the last 30 days and format the results into days in units of milliseconds. Hence, the <em>x</em> axis is configured as a <code class="literal">datetime</code> type with intervals on a daily basis:</p><div><pre class="programlisting">    var chart = new Highcharts.Chart({
      chart: {
        renderTo: 'container',
        showAxes: true,
        borderWidth: 1
      },
      title: { text: 'Last 30 days stock price' },
      credits: { text: 'Learning Highcharts' },
      xAxis: {
        type: 'datetime',
        tickInterval: 24 * 3600 * 1000,
        dateTimeLabelFormats: { day: '%Y-%m-%d' },
        title: {
          text: 'Date',
          align: 'high'
        },
        labels: {
          rotation: -45,
          align : 'center',
          step: 2,
          y: 40,
          x: -20
        }
      },
      yAxis: {
        title: { text: 'Price ($)' }
      },
      plotOptions: {
        line: { allowPointSelect: true }
      }
     });</pre></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec73"/>Getting data in Ajax and displaying a new series with Chart.addSeries</h2></div></div></div><p>Let's examine the action <a id="id657" class="indexterm"/>behind the <strong>Add &amp; Plot</strong> button, <a id="id658" class="indexterm"/>defined as the following HTML syntax:</p><div><pre class="programlisting">Stock Symbol: &lt;input type=text id='symbol' /&gt; 
&lt;input type='button' value='Add to the list' id='addStockList' /&gt; &lt;input type='button' value='Add &amp;amp; Plot' id='plotStock'&gt;
....
Added symbols list:
&lt;ol id='stocklist'&gt;
&lt;/ol&gt;</pre></div><p>The jQuery code<a id="id659" class="indexterm"/> for the button <a id="id660" class="indexterm"/>action is<a id="id661" class="indexterm"/> listed, as <a id="id662" class="indexterm"/>follows:</p><div><pre class="programlisting">   $('#plotStock').button().click( 
     function(evt) {

      // Get the input stock symbol, empty the 
      // list andinsert the new symbol into the list
      $('#stocklist').empty();
      var symbol = $('#symbol').val();
           $('#stocklist').append($("&lt;li/&gt;").append(symbol)); 

      // Kick off the loading screen
      chart.showLoading("Getting stock data ....");

      // Launch the stock query
      $.getJSON('./stockQuery.php?symbol=' + 
                   symbol.toLowerCase(),
           function(stockData) {
             // parse JSON response here
             .....
           }
      );
     }
   );</pre></div><p>The previous code defines the event handler for the <strong>Add &amp; Plot</strong> button's click event. First, it empties all the entries in the stock symbol list box that have IDs as <code class="literal">stocklist</code>. Then, it retrieves the stock symbol value from the input field <code class="literal">symbol</code> and appends the symbol to the list. The next step is to initiate a loading message screen on the chart by calling the <code class="literal">chart.showLoading</code> method. The following screenshot shows the loading message screen:</p><div><img src="img/7451OS_10_13.jpg" alt="Getting data in Ajax and displaying a new series with Chart.addSeries"/></div><p>The next call is to <a id="id663" class="indexterm"/>launch a jQuery Ajax call, <code class="literal">$.getJSON</code>, to query <a id="id664" class="indexterm"/>the stock<a id="id665" class="indexterm"/> price. The <code class="literal">stockQuery.php</code> server script (of course, any other <a id="id666" class="indexterm"/>server-side language can be used) does two tasks: it resolves the<a id="id667" class="indexterm"/> symbol into the <a id="id668" class="indexterm"/>full name of the organization, launches the symbol query from another website (<a class="ulink" href="http://ichart.finance.yahoo.com/table.csv?s=BATS.L">http://ichart.finance.yahoo.com/table.csv?s=BATS.L</a>) for the <a id="id669" class="indexterm"/>past stock price data, then packs the data into rows and encodes them into JSON format. The following is the code in the <code class="literal">stockQuery.php</code> file:</p><div><pre class="programlisting">&lt;?php
  $ch = curl_init();
  curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);

  // Get the stock symbol name
  curl_setopt($ch, CURLOPT_URL, "http://download.finance.yahoo.com/d/quotes.csv?s={$_GET['symbol']}&amp;f=n");
  $result = curl_exec($ch);
  $name = trim(trim($result), '"');

  // Get from now to 30 days ago
  $now = time();
  $toDate = localtime($now, true);
  $toDate['tm_year'] += 1900;
  $fromDate = localtime($now - (86400 * 30), true);
  $fromDate['tm_year'] += 1900;
  $dateParams = "a={$fromDate['tm_mon']}&amp;b={$fromDate['tm_mday']}&amp;c={$fromDate['tm_year']}" ."&amp;d={$toDate['tm_mday']}&amp;e={$toDate['tm_mday']}&amp;f={$toDate['tm_year']}";

  curl_setopt($ch, CURLOPT_URL, "http://ichart.finance.yahoo.com/table.csv?s={$_GET['symbol']}&amp;{$dateParams}&amp;g=d");
  $result = curl_exec($ch);
  curl_close($ch);

  // Remove the header row
  $lines = explode("\n", $result);
  array_shift($lines);

  $stockResult['rows'] = array();
  // Parse the result into dates and close value
  foreach((array) $lines as $ln) {
    if (!strlen(trim($ln))) {
      continue;
    }
    list($date, $o, $h, $l, $c, $v, $ac) = 
      explode(",", $ln, 7);
    list($year, $month, $day) = explode('-', $date, 3);
    $tm = mktime(12, 0, 0, $month, $day, $year);
    $stockResult['rows'][] = 
      array('date' =&gt; $tm * 1000, 
         'price' =&gt; floatval($c));
  }

  $stockResult['name'] = $name;
  echo json_encode($stockResult);
?&gt;</pre></div><p>The <a id="id670" class="indexterm"/>following<a id="id671" class="indexterm"/> is the <a id="id672" class="indexterm"/>result returned from the server side<a id="id673" class="indexterm"/> in the <a id="id674" class="indexterm"/>JSON <a id="id675" class="indexterm"/>format:</p><div><pre class="programlisting">{"rows":[ {"date":1348138800000,"price":698.7},
     {"date":1348225200000,"price":700.09},
     ... ],
 "name": "Apple Inc."
}</pre></div><p>Once the JSON result arrives, the data is passed to the definition of the handler of <code class="literal">getJSON</code> and parsed into an array of rows. The following are the details of the handler code:</p><div><pre class="programlisting">$.getJSON('./stockQuery.php?symbol=' + 
     symbol.toLowerCase(),
     function(stockData) {

         // Remove all the chart existing series
         while (chart.series.length) {
             chart.series[0].remove();
         }

         // Construct series data and add the series
         var seriesData = [];
         $.each(stockData.rows, 
             function(idx, data) {
                 seriesData.push([ data.date, data.price ]);
             }
         );

         var seriesOpts = {
             name: stockData.name + ' - (' + symbol +')',
             data: seriesData,

             // This is to stop Highcharts rotating
             // the color and data point symbol for
             // the series
             color: chart.options.colors[0],
             marker: {
                 symbol: chart.options.symbols[0]
             }
         };

         chart.hideLoading();
         chart.addSeries(seriesOpts);
     }
);</pre></div><p>First of all, we <a id="id676" class="indexterm"/>remove all the existing series displayed in the<a id="id677" class="indexterm"/> chart by <a id="id678" class="indexterm"/>calling <code class="literal">Series.remove</code>. We then construct a series <a id="id679" class="indexterm"/>option with a data array of date (in UTC time) and price. We then <a id="id680" class="indexterm"/>remove the loading screen <a id="id681" class="indexterm"/>with <code class="literal">Chart.hideLoading</code> and display a new series with the <code class="literal">Chart.addSeries</code> methods. The only minor issue is that the default color and point marker for the series change when the series is reinserted; the internal indices in <code class="literal">chart.options.colors</code> and <code class="literal">chart.options.symbols</code> are incremented when a series is removed and added back to the chart. We can explicitly set the series color and point symbol to resolve this issue.</p><p>Alternatively, we can call <code class="literal">Series.setData</code> to achieve the same result but, once the name (subject) of a series is assigned and the series is created, it is not allowed to change. Therefore, we stick to <code class="literal">Chart.addSeries</code> and <code class="literal">Series.remove</code> in this example.</p><p>The <a id="id682" class="indexterm"/>following is a <a id="id683" class="indexterm"/>screenshot <a id="id684" class="indexterm"/>of a<a id="id685" class="indexterm"/> single <a id="id686" class="indexterm"/>stock <a id="id687" class="indexterm"/>query:</p><div><img src="img/7451OS_10_03.jpg" alt="Getting data in Ajax and displaying a new series with Chart.addSeries"/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec74"/>Displaying multiple series with simultaneous Ajax calls</h2></div></div></div><p>The next part is to explore <a id="id688" class="indexterm"/>how to<a id="id689" class="indexterm"/> launch multiple Ajax <a id="id690" class="indexterm"/>queries simultaneously and plot series together when all the results have been returned. The implementation is pretty much the same as plotting a single stock query, except that we build up the series array option as we gather the results and plot<a id="id691" class="indexterm"/> them only <a id="id692" class="indexterm"/>when <a id="id693" class="indexterm"/>the last result arrives:</p><div><pre class="programlisting">// Query all the stocks simultaneously and 
// plot multipleseries in one go
$('#plotAll').button().click( 

  function(evt) {

    // Kick off the loading screen
    chart.showLoading("Getting multiple stock data ....");

    // Get the list of stock symbols and launch 
    // the query foreach symbol 
    var total = $('#stocklist').children().length;

    // start Ajax request for each of the items separately
      $.each($('#stocklist').children(), 
      function(idx, item) {
       var symbol = $(item).text();
       $.getJSON('./stockQuery.php?symbol=' +
         symbol.toLowerCase(),
              function(stockData) {

          // data arrives, buildup the series array
          $.each(stockData.rows, 
            function(idx, data) {
             $.histStock.push([ data.date,
                      data.price ]);
            }
          );

          seriesOpts.push({
           name: stockData.name + ' - (' +       
              symbol +')',
           data: $.histStock,
           // This is to stop Highcharts 
           // rotating the colorfor the series
           color: chart.options.colors[idx],
           marker: {
             symbol: chart.options.symbols[idx]
           }
          });

          // Plot the series if this result 
          // is the last one
          if (seriesOpts.length == total) {

            // Remove all the chart existing series
            while (chart.series.length) {
              chart.series[0].remove()
            }
             
            chart.hideLoading();
            $.each(seriesOpts, 
              function(idx, hcOption) {
               chart.addSeries(hcOption, 
                       false);
              }
            );

            chart.redraw();
                } // else – do nothing, 
          // not all results came yet 
         } // function(stockData) 
        ); // getJSON
     }); // $.each($('#stocklist')
    }); // on('click'</pre></div><p>The second Boolean <a id="id694" class="indexterm"/>parameter <a id="id695" class="indexterm"/>of <code class="literal">Chart.addSeries</code>, <code class="literal">redraw</code>, is passed as <code class="literal">false</code>. Instead, we finalize all the updates in one single<a id="id696" class="indexterm"/> call, <code class="literal">Chart.redraw</code>, to save CPU time. The following is the screenshot for the multiple stock queries:</p><div><img src="img/7451OS_10_04.jpg" alt="Displaying multiple series with simultaneous Ajax calls"/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec75"/>Extracting SVG data with Chart.getSVG</h2></div></div></div><p>In this section, we will learn <a id="id697" class="indexterm"/>how to extract <a id="id698" class="indexterm"/>chart output and deliver it via e-mail <a id="id699" class="indexterm"/>or file download. Although we can rely on the exporting module and call the <code class="literal">exportChart</code> method to export the chart into the desired image format, it would be beneficial to see the whole process from formatting the original SVG content to creating an image file. After that, it is just a matter of calling different utilities to deliver the image file on the server side.</p><p>To extract the data underneath SVG from the displaying chart, the <code class="literal">getSVG</code> method is called, available when the exporting module is loaded. This method is similar to <code class="literal">exportChart</code>: it accepts the <code class="literal">chartOptions</code> parameter, which is used for applying configurations to the export chart output.</p><p>Here is the client-side jQuery code for handling both the <strong>Download</strong> and <strong>Email</strong> buttons.</p><p>Here, we use the <code class="literal">protocol</code> variable to specify the action for the chart and both buttons call the defined common function, <code class="literal">deliverChart</code>:</p><div><pre class="programlisting"> // Export chart into SVG and deliver it to the server
 function deliverChart(chart, protocol, target) {

   // First extracts the SVG markup content from the
   // displayed chart
   var svg = chart.getSVG();

   // Send the whole SVG to the server and url
   $.post('./deliverChart.php', {
       svg: svg,
       protocol: protocol,
       target: target
     },
     function(result) {
       var message = null;
       var title = null;

       switch (protocol) {

         // Create a dialog box to show the 
         // sent status
         case 'mailto':
           message = result.success ? 
            'The mail has been sent successfully' : 
            result.message;
           title = 'Email Chart';
           break;
             
         // Uses hidden frame to download the 
         // image file created on the server side
         case 'file':        
           // Only popup a message if error occurs
           if (result.success) {
             $('#hidden_iframe').attr("src",
                      "dlChart.php");
           } else {
             message = result.message;
             title = 'Download Chart';
           }
           break;
       }
                 
       if (message) {
         var msgDialog = $('#dialog');
         msgDialog.dialog({ autoOpen: false, 
           modal: true, title: title});
         msgDialog.text(message);
         msgDialog.dialog('open');
       }
   }, 'json');
 }</pre></div><p>The <code class="literal">deliverChart</code> method <a id="id700" class="indexterm"/>first <a id="id701" class="indexterm"/>calls the Highcharts API <code class="literal">getSVG</code> to <a id="id702" class="indexterm"/>extract the SVG content, then launches a <code class="literal">POST</code> call with both SVG data and action parameters. When <code class="literal">$.post</code> returns with a task status value, it shows a message dialog. As for the download chart, we create a hidden <code class="literal">&lt;iframe&gt;</code> to download the chart image file upon the successful return of the task status value.</p><p>The following is a simple server-side script for converting the SVG content and delivering the exported file:</p><div><pre class="programlisting">&lt;?php
$svg = $_POST['svg'];
$protocol = $_POST['protocol'];
$target = $_POST['target'];

function returnError($output) {
  $result['success'] = false;
  $result['error'] = implode("&lt;BR/&gt;", $output);
  echo json_encode($result);
  exit(1);
}

// Format the svg into an image file
file_put_contents("/tmp/chart.svg", $svg);
$cmd = "convert /tmp/chart.svg /tmp/chart.png";
exec($cmd, $output, $rc);
if ($rc) {
  returnError($output);
}

// Deliver the chart image file according to the url
if ($protocol == 'mailto') {

  $cmd = "EMAIL='{$target}' mutt -s 'Here is the chart' -a /tmp/chart.png -- {$protocol}:{$target} &lt;&lt;.
Hope you like the chart
.";

  exec($cmd, $output, $rc);
  if ($rc) {
   returnError($output);
  }
  $result['success'] = true;

} else if ($protocol == 'file') {
  $result['success'] = true;
}

echo json_encode($result);
?&gt;</pre></div><div><div><h3 class="title"><a id="note15"/>Note</h3><p>The web server is running on a Linux platform (Ubuntu 12.04). As for the e-mail action, we use two command-line utilities to help us. The first is a fast image conversion tool, <strong>convert</strong>, that <a id="id703" class="indexterm"/>is part of the <strong>ImageMagick</strong> package<a id="id704" class="indexterm"/> (<strong>s</strong>ee the package website for more details at <a class="ulink" href="http://www.imagemagick.org/script/index.php">http://www.imagemagick.org/script/index.php</a>). Inside the script, we save the SVG data from the <code class="literal">POST</code> parameter into a file and then run the convert tool to format it into a PNG image. The convert tool supports many other image formats and comes with a myriad of advanced features. Alternatively, we can use Batik to do a straightforward conversion by issuing the following command:</p><div><pre class="programlisting">
<strong>java -jar batik-rasterizer.jar /tmp/chart.svg</strong>
</pre></div></div></div><p>The given <a id="id705" class="indexterm"/>command also converts an <a id="id706" class="indexterm"/>SVG file and outputs <code class="literal">/tmp/chart.png</code> <a id="id707" class="indexterm"/>automatically. For the sake of implementing the e-mail feature quickly, we will launch an e-mail tool, <strong>mutt</strong><a id="id708" class="indexterm"/> (see the package website for more details at <a class="ulink" href="http://www.mutt.org">http://www.mutt.org</a>), instead of using the PHP mail extension. Once the PNG image file is created, we use mutt to send it as an attachment and use a heredoc to specify the message body.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p>A <strong>heredoc</strong><a id="id709" class="indexterm"/> is a quick way of inputting strings in a Unix command line with new lines and white spaces. See <a class="ulink" href="http://en.wikipedia.org/wiki/Here_document">http://en.wikipedia.org/wiki/Here_document</a>.</p></div></div><p>The following is the screenshot of the e-mail that is sent:</p><div><img src="img/7451OS_10_05.jpg" alt="Extracting SVG data with Chart.getSVG"/></div><p>The following <a id="id710" class="indexterm"/>is the screenshot of the<a id="id711" class="indexterm"/> attachment e-mail that arrived in my <a id="id712" class="indexterm"/>e-mail account:</p><div><img src="img/7451OS_10_06.jpg" alt="Extracting SVG data with Chart.getSVG"/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec76"/>Selecting data points and adding plot lines</h2></div></div></div><p>The next part is to <a id="id713" class="indexterm"/>implement <a id="id714" class="indexterm"/>the <strong>Show</strong><a id="id715" class="indexterm"/>
<strong> Range</strong> checkbox and the <strong>Show Point Value</strong> button. The <strong>Show Range</strong> option displays plot lines along the highest and lowest points<a id="id716" class="indexterm"/> in the chart, whereas <strong>Show Point Value</strong> displays a box with the value at the bottom left-hand side if a point is selected. The following screenshot demonstrates how both are enabled in the chart:</p><div><img src="img/7451OS_10_07.jpg" alt="Selecting data points and adding plot lines"/></div><div><div><h3 class="title"><a id="note16"/>Note</h3><p>Although it is more natural for the <strong>Show Point Value</strong> checkbox to show the selected point display, this will become a callback implementation to every point select event. Instead, we use a button here, so that we can directly call the <code class="literal">Chart.getSelectedPoints</code> method.</p></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec17"/>Using Axis.getExtremes and Axis.addPlotLine</h3></div></div></div><p>The <code class="literal">Axis.getExtremes</code> method <a id="id717" class="indexterm"/>not only returns the axis current minimum and maximum range in display, but also the highest and the lowest values for the data points. Here, we use the method to combine with the <code class="literal">Axis.addPlotLine</code> function<a id="id718" class="indexterm"/> to add a pair of plot lines along the <em>y</em> axis. The <code class="literal">addPointLine</code> routine expects a plot line configuration.</p><p>In this example, we specify a data label as well as an <code class="literal">id</code> name, so that we can remove lines at both high and low ends when the <strong>Show Range</strong> option is unchecked or plot lines need to be redisplayed <a id="id719" class="indexterm"/>with a new value. The following is the code for the<a id="id720" class="indexterm"/> <strong>Show Range</strong> action:</p><div><pre class="programlisting">  // Show the highest and lowest range in the plotlines. 
  var showRange = function(chart, checked) {
    if (!chart.series || !chart.series.length) {
        return;  
    }

    // Checked or not checked, we still need to remove
    // any existing plot lines first
    chart.yAxis[0].removePlotLine('highest');
    chart.yAxis[0].removePlotLine('lowest');

    if (!checked) {
      return;
    }

    // Checked - get the highest &amp; lowest points
    var extremes = chart.yAxis[0].getExtremes();

    // Create plot lines for the highest &amp; lowest points 
    chart.yAxis[0].addPlotLine({
      width: 2,
      label: {
        text: extremes.dataMax,
        enabled: true,
        y: -7
      },
      value: extremes.dataMax,
      id: 'highest',
      zIndex: 2,
      dashStyle: 'dashed',
      color: '#33D685'
    });

    chart.yAxis[0].addPlotLine({
      width: 2,
      label: {
        text: extremes.dataMin,
        enabled: true,
        y: 13
      },
      value: extremes.dataMin,
      zIndex: 2,
      id: 'lowest',
      dashStyle: 'dashed',
      color: '#FF7373'
    });
  };</pre></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec18"/>Using the Chart.getSelectedPoints and Chart.renderer methods</h3></div></div></div><p>The <strong>Show Point Value</strong> button makes <a id="id721" class="indexterm"/>use of the <code class="literal">Chart.getSelectedPoints</code> method to retrieve the data point that is currently selected. Note that this method requires the series option <code class="literal">allowPointSelect</code> to be enabled in the first place. Once a data point is selected and the <strong>Show Point Value</strong> button is clicked, we use functions provided by the <code class="literal">Chart.renderer</code> method to draw a tooltip-like box showing the selected value. We can use the <code class="literal">Renderer.path</code> or <code class="literal">Renderer.rect</code> methods to draw the rounded box, then <code class="literal">Renderer.text</code> for the data value.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p>Highcharts also supports multiple data point selection, which can be done by clicking on the left mouse button while holding down the <em>Ctrl</em> key.</p></div></div><p>Additionally, we use <a id="id722" class="indexterm"/>the <code class="literal">Renderer.g</code> routine to group the SVG box and value string together and add the resulting group element into the chart. The reason for that is so that we can re-display the box with a new value by removing the old group object as a whole instead of each individual element:</p><div><pre class="programlisting"> $('#showPoint').button().click(function(evt) {
   // Remove the point info box if exists 
   chart.infoBox &amp;&amp; (chart.infoBox =
            chart.infoBox.destroy());

   // Display the point value box if a data point 
   // is selected
   var selectedPoint = chart.getSelectedPoints();
   var r = chart.renderer;
   if (selectedPoint.length) {
     chart.infoBox = r.g();
     r.rect(20, 255, 150, 30, 3).attr({
       stroke: chart.options.colors[0],
       'stroke-width': 2,
       fill: 'white'
     }).add(chart.infoBox);

     // Convert selected point UTC value to date string
     var tm = new Date(selectedPoint[0].x);
     tm = tm.getFullYear() + '-' + 
       (tm.getMonth() + 1) + '-' + tm.getDate();
     r.text(tm + ': ' + selectedPoint[0].y, 
       28, 275).add(chart.infoBox);
     chart.infoBox.add();
   }
 });</pre></div><p>Highcharts' <code class="literal">Renderer</code> class also comes with other methods to draw simple SVG shapes on the chart, such as <code class="literal">arc</code>, <code class="literal">circle</code>, <code class="literal">image</code>, <code class="literal">rect</code>, <code class="literal">text</code>, <code class="literal">g</code>, and <code class="literal">path</code>. For more advanced shapes, we can use<a id="id723" class="indexterm"/> the <code class="literal">path</code> method, which accepts the SVG path<a id="id724" class="indexterm"/> syntax and has limited support on VML paths. Moreover, the <code class="literal">Renderer</code> class can be used independently from a chart—that is, we can call methods of the <code class="literal">Renderer</code> class without creating a chart beforehand and add SVG contents to an HTML element:</p><div><pre class="programlisting">var renderer = new Highcharts.Renderer($('#container')[0], 200, 100);</pre></div><p>This creates a <code class="literal">Renderer</code> object that allows us to create SVG elements inside the <code class="literal">container</code> element, with an area 200 pixels wide and 100 pixels high.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec77"/>Exploring series update</h2></div></div></div><p>The series update is<a id="id725" class="indexterm"/> one of the most frequent tasks performed in<a id="id726" class="indexterm"/> charts. In this section, we investigate it in high definition. In Highcharts, there are several approaches to updating a series. Generally, we can update a series from a series or data point level. Then, the update method itself can either be actually changing the value, or reinserting it. We will discuss each approach and create a comprehensive example to experiment with all the techniques.</p><p>In order to compare each approach, we will continue to use stock market data but we will change the user interface this time to enable replaying the historical stock price. The following is the screenshot of the example in action:</p><div><img src="img/7451OS_10_08.jpg" alt="Exploring series update"/></div><p>As we can see, there<a id="id727" class="indexterm"/> are multiple selection boxes to choose <a id="id728" class="indexterm"/>from: how many years of historical stock price to replay, how many data points to update in each iteration, and how long the wait is in between each update. Most importantly, we can choose which series update method should be used; it is interesting to observe the behavioral difference between them, especially during the whole replay. This demo is also available on my website at <a class="ulink" href="http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_2.html">http://www.joekuan.org/Learning_Highcharts/Chapter_10/Example_2.html</a>. I strongly recommend readers give it a<a id="id729" class="indexterm"/> go. Before we look into each update approach, let's find out how to construct this continuous series update process.</p><div><div><div><div><h3 class="title"><a id="ch10lvl3sec19"/>Continuous series update</h3></div></div></div><p>Once we enter a stock <a id="id730" class="indexterm"/>symbol and select the <a id="id731" class="indexterm"/>number of years of stock prices to replay, we can click on the <strong>Load Data</strong> button to retrieve the price data. Once the data arrives, a confirmation dialog pops up with a <strong>Start</strong> button to kick-start the process. The following is the action code for <a id="id732" class="indexterm"/>the <strong>Start</strong><a id="id733" class="indexterm"/> button:</p><div><pre class="programlisting"> // Create a named space to store the current user
 // input field values and the timeout id
 $.histStock = {};
 
 $('#Start').button().click(function() {

   chart.showLoading("Loading stock price ... "); 

   // Remove old timeout if exists
   $.histStock.timeoutID &amp;&amp; 
     clearTimeout($.histStock.timeoutID);

   var symbol = 
     encodeURIComponent($('#symbol').val().toLowerCase());
   var years = encodeURIComponent($('#years').val());

   // Remember current user settings and initialise values
   // for the run
   $.histStock = {
     // First loop start at the beginning
     offset: 0,
     // Number of data pts to display in each iteration
     numPoints: 30,
     // How long to wait in each iteration
     wait: parseInt($('#updateMs').val(), 10),
     // Which Highcharts method to update the series
     method: $('#update').val(),
     // How many data points to update in each iteration
     update: parseInt($('#updatePoints').val(), 10)
   };

   // Clean up old data points from the last run
   chart.series.length &amp;&amp; chart.series[0].setData([]);

   // Start Ajax query to get the stock history
   $.getJSON('./histStock.php?symbol=' + symbol + 
        '&amp;years=' + years,
     function(stockData) {
       // Got the whole period of historical stock data
       $.histStock.name = stockData.name;
       $.histStock.data = stockData.rows;

       chart.hideLoading();
       // Start the chart refresh
       refreshSeries();
     }
   );
 })</pre></div><p>We first create a variable, <code class="literal">histStock</code>, under the jQuery namespace, that is accessed by various parts within the demo. The <code class="literal">histStock</code> variable holds the current user's inputs and the reference to the refresh task. Any changes from the user interface update <code class="literal">$.histStock</code>, so the series update responds accordingly.</p><p>Basically, when<a id="id734" class="indexterm"/> the <strong>Start</strong> button is clicked, we initialize the <code class="literal">$.histStock</code> variable<a id="id735" class="indexterm"/> and start an Ajax query with the stock symbol and number-of-years parameters. Then, when the stock price data returns from the query, we store the result into the variable. We then call <code class="literal">refreshSeries</code>, which calls itself by the setting via a timer routine. The following code is the simplified version of the method:</p><div><pre class="programlisting">var refreshSeries = function() {
  var i = 0, j;

  // Update the series data according to each approach
  switch ($.histStock.method) {
    case 'setData':
       .... 
    break;
    case 'renewSeries':
       .... 
    break;
    case 'update':
       .... 
    break;
    case 'addPoint':
       .... 
    break;
  }

  // Shift the offset for the next update
  $.histStock.offset += $.histStock.update; 

  // Update the jQuery UI progress bar
  ....

  // Finished 
  if (i == $.histStock.data.length) {
    return;
  }

  // Setup for the next loop
  $.histStock.timeoutID = 
       setTimeout(refreshSeries, $.histStock.wait);
};</pre></div><p>Inside <code class="literal">refreshSeries</code>, it inspects the settings inside the <code class="literal">$.histStock</code> variable and updates the series<a id="id736" class="indexterm"/> depending on the user's choice. Once the update is <a id="id737" class="indexterm"/>done, we increment the <code class="literal">offset</code> value, which is at the start position for copying the stock result data into the chart. If the counter variable <code class="literal">i</code> hits the end of the stock data, then it simply exits the method. Otherwise, it will call the JavaScript timer function to set up the next loop. The next goal is to review how each update method is performed.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec78"/>Testing the performance of various Highcharts methods</h2></div></div></div><p>There are four <a id="id738" class="indexterm"/>techniques for updating<a id="id739" class="indexterm"/> the series data: <code class="literal">Series.setData</code>, <code class="literal">Series.remove</code>/<code class="literal">Chart.addSeries</code>, <code class="literal">Point.update</code>, and <code class="literal">Series.addPoint</code>. We measure the performance for all four techniques in terms of CPU and memory usage with the Resource Monitor tool. Each method is timed when replaying the stock prices for the past year along with 0.5 seconds of waiting time between each update. We repeated the same run twice and recorded the average. The experiment is repeated on a selection of browsers: Firefox, Chrome, Internet Explorer 8 and 11, and Safari. Although IE 8 does not support SVG and only supports VML, it is important to use it in the experiment because Highcharts' implementation is compatible with IE 8. One thing that we instantly notice is the same chart on IE8 is not as appealing as in SVG.</p><div><div><h3 class="title"><a id="note17"/>Note</h3><p>The whole experiment is running on a PC with Windows 7 Ultimate installed, and the hardware is 4GB RAM Core 2 Duo 3.06 GHz with an Intel G41 Graphics chipset.</p><p>The browser versions are Firefox 31.0, Chrome 36.0.1985, IE11 11.0.9600, Safari 5.1.7, and IE8 8.0.6001. Safari may not be a true performance indicator as it is rather old for a PC platform.</p><p>It is no longer possible to install/run IE8 on Windows 7, as Microsoft has discontinued support. Although we can set the user agent on IE11 to IE8 and conduct the experiment, it doesn't offer a true reflection of IE8 performance. Therefore, we set up another system running Windows XP with IE8 on identical hardware.</p></div></div><p>In the following sections, each series update approach is explained and a performance comparison is presented between the browsers. Readers must not use the result as a guide to the browser's general performance, which is derived from running a myriad of tests in a number of areas. What we are experimenting with here is simply how Highcharts <a id="id740" class="indexterm"/>performs on each <a id="id741" class="indexterm"/>browser in terms of SVG animations.</p><div><div><h3 class="title"><a id="note18"/>Note</h3><p>Note that the results are different compared to what was presented in the previous edition. This is mainly due to using a more up-to-date version of Highcharts: we use 4.0.3 in this experiment, whereas 2.2.24 is documented in the previous edition.</p></div></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec20"/>Applying a new set of data with Series.setData</h3></div></div></div><p>We can apply a new set of data to an<a id="id742" class="indexterm"/> existing series using the <code class="literal">Series.setData</code> method:</p><div><pre class="programlisting">setData (Array&lt;Mixed&gt; data, [Boolean redraw])</pre></div><p>The data can be an array of one dimensional data, an array of x and y value pairs, or an array of data point objects. Note that this method is the simplest form of all the approaches, and doesn't provide any animation effects at all. Here is how we use the <code class="literal">setData</code> function in our example:</p><div><pre class="programlisting">  case 'setData':
    var data = [];
 
    // Building up the data array in the series option
    for (i = $.histStock.offset, j = 0; 
       i &lt; $.histStock.data.length &amp;&amp; 
       j &lt; $.histStock.numPoints; i++, j++) {
      data.push([ 
        $.histStock.data[i].date,
        $.histStock.data[i].price ]);
    }

    if (!chart.series.length) {

      // Insert the very first series
      chart.addSeries({
        name: $.histStock.name,
        data: data    
      });
    } else {

      // Just update the series with 
      // the new data array
      chart.series[0].setData(data, true);
    }
    break;</pre></div><p>There are two sets of animations appearing in the chart: <em>x</em>-axis labels moving from the center of the chart and the data points in the series. Although the series scrolls smoothly, the movement of the <em>x</em>-axis labels appears too quickly and becomes choppy. The following graph shows the performance comparison when using the <code class="literal">setData</code> method across the browsers:</p><div><img src="img/7451OS_10_14.jpg" alt="Applying a new set of data with Series.setData"/></div><p>There are minor <a id="id743" class="indexterm"/>differences in terms of CPU usage, except for IE8 that runs on VML instead of SVG. IE8 consumed much higher CPU usage and took much longer to finish. The animation lagged throughout the experiment. Among the browsers, Safari is marginally the best. Out of all the browsers, Firefox has the highest memory footprint, whereas IE 11 had the smallest. Perhaps a slight surprise is that Safari has a better performance than Firefox and is also very close to Chrome.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec21"/>Using Series.remove and Chart.addSeries to reinsert series with new data</h3></div></div></div><p>Alternatively, we can<a id="id744" class="indexterm"/> remove the whole series <a id="id745" class="indexterm"/>with the <code class="literal">Series.remove</code> method, then rebuild the series options with the data and reinsert a new series using <code class="literal">Chart.addSeries</code>. The downside of this approach is that the internal index for the default colors and point symbols is incremented, as we found in the earlier example. We can compensate for that by specifying the color and the marker options. Here is the code for the <code class="literal">addSeries</code> method:</p><div><pre class="programlisting">  case 'renewSeries':
    var data = [];
    for (i = $.histStock.offset, j = 0; 
       i &lt; $.histStock.data.length &amp;&amp; 
       j &lt; $.histStock.numPoints; i++, j++) {
      data.push([ $.histStock.data[i].date, 
            $.histStock.data[i].price ]);
    }
    // Remove all the existing series
    if (chart.series.length) {
      chart.series[0].remove();
    }

    // Re-insert a new series with new data
    chart.addSeries({
      name: $.histStock.name,
      data: data,
      color: chart.options.colors[0],
      marker: {
        symbol: chart.options.symbols[0]
      }
    });
    break;</pre></div><p>In this experiment, we use the refresh rate for every half-second, which is shorter than the time span of the default animation. Therefore the series update appears erratic without much animation, as in <code class="literal">setData</code>. However, if we change the refresh rate to 3 seconds or more, then we can see the series being redrawn from the left-hand to the right-hand side in each update. Unlike other methods, the x-axis labels are updated without any animations:</p><div><img src="img/7451OS_10_23.jpg" alt="Using Series.remove and Chart.addSeries to reinsert series with new data"/></div><p>The following graph shows<a id="id746" class="indexterm"/> the performance <a id="id747" class="indexterm"/>comparison when using the <code class="literal">addSeries</code> method across the browsers:</p><div><img src="img/7451OS_10_15.jpg" alt="Using Series.remove and Chart.addSeries to reinsert series with new data"/></div><p>Since this approach seems to have the least animation, the CPU usage levels are relatively low across all the browsers, as is the memory usage. As expected, IE8 consumes the most resources. Next is IE11, which is roughly on a par with Chrome. The most unusual result is that Firefox requires significantly less CPU usage than both Chrome and Safari when <a id="id748" class="indexterm"/>there is little animation. We<a id="id749" class="indexterm"/> will investigate this further in a later section.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec22"/>Updating data points with Point.update</h3></div></div></div><p>We can update <a id="id750" class="indexterm"/>individual data points with the <code class="literal">Point.update</code> method. The <a id="id751" class="indexterm"/>update method has a similar prototype to <code class="literal">setData</code>, which accepts a single value, an array of x and y values, or a data point object. Each update call can be redrawn into the chart with or without animation:</p><div><pre class="programlisting">update ([Mixed options], [Boolean redraw], [Mixed animation])</pre></div><p>Here is how we use the <code class="literal">Point.update</code> method: we traverse through each point object and call its member function. In order to save CPU time, we set the <code class="literal">redraw</code> parameter to <code class="literal">false</code> and call <code class="literal">Chart.redraw</code> after the last data point is updated:</p><div><pre class="programlisting">  case 'update':
    // Note: Series can be already existed 
    // at start if we click 'Stop' and 'Start'
    // again
    if (!chart.series.length || 
        !chart.series[0].points.length) {
      // Build up the first series
      var data = [];
      for (i = $.histStock.offset, j = 0; 
         i &lt; $.histStock.data.length &amp;&amp; 
         j &lt; $.histStock.numPoints; i++, j++) {
        data.push([ 
          $.histStock.data[i].date, 
          $.histStock.data[i].price ]); 
      }

      if (!chart.series.length) {
        chart.addSeries({
          name: $.histStock.name,
          data: data    
        });
      } else {
        chart.series[0].setData(data);
      }

    } else {
      // Updating each point
      for (i = $.histStock.offset, j = 0; 
         i &lt; $.histStock.data.length &amp;&amp; 
         j &lt; $.histStock.numPoints; i++, j++) {
        chart.series[0].points[j].update([
          $.histStock.data[i].date,                         
          $.histStock.data[i].price ],
        false);
      }
      chart.redraw();
    }
    break;</pre></div><p><code class="literal">Point.update</code> animates<a id="id752" class="indexterm"/> each data point vertically. It gives a <a id="id753" class="indexterm"/>wavy effect overall as the graph is progressively updated. In the same way as the <code class="literal">setData</code> method, the labels approach the x-axis line diagonally. The following graph shows the performance comparison of the <code class="literal">Point.update</code> method across the browsers:</p><div><img src="img/7451OS_10_16.jpg" alt="Updating data points with Point.update"/></div><p>As the animations are pretty much the same as the <code class="literal">setData</code> approach, the performance shown in the preceding chart is very close to the results of the <code class="literal">setData </code>performance experiment.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec23"/>Removing and adding data points with Point.remove and Series.addPoint</h3></div></div></div><p>Instead of updating each<a id="id754" class="indexterm"/> individual data point, we can <a id="id755" class="indexterm"/>use <code class="literal">Point.remove</code> to remove data <a id="id756" class="indexterm"/>points within the <code class="literal">series.data</code> array and <a id="id757" class="indexterm"/>use <code class="literal">Series.addPoint</code> to add new data points back into the series:</p><div><pre class="programlisting">remove ([Boolean redraw], [Mixed animation])
addPoint (Object options, [Boolean redraw], [Boolean shift], 
          [Mixed animation])</pre></div><p>As for the time series data, we can use <code class="literal">addPoint</code> along with the <code class="literal">shift</code> parameter set to <code class="literal">true</code>, which will automatically shift the series point array:</p><div><pre class="programlisting">  case 'addPoint':
    // Note: Series can be already existed at
    // start if we click 'Stop' and 'Start' again
    if (!chart.series.length || 
        !chart.series[0].points.length) {

      // Build up the first series
      var data = [];
      for (i = $.histStock.offset, j = 0; 
          i &lt; $.histStock.data.length &amp;&amp; 
        j &lt; $.histStock.numPoints; i++, j++) {
        data.push([ 
          $.histStock.data[i].date,
          $.histStock.data[i].price ]); 
      }

      if (!chart.series.length) {
        chart.addSeries({
          name: $.histStock.name,
          data: data    
        });
      } else {
        chart.series[0].setData(data);
      }

      // This is different, we don't redraw 
      // any old points
      $.histStock.offset = i;

    } else {

      // Only updating the new data point
      for (i = $.histStock.offset, j = 0; 
        i &lt; $.histStock.data.length &amp;&amp; 
        j &lt; $.histStock.update; i++, j++) {
        chart.series[0].addPoint([
          $.histStock.data[i].date, 
          $.histStock.data[i].price ],
          false, true );
      }
      chart.redraw();
    }
    break;</pre></div><p>The following graph<a id="id758" class="indexterm"/> shows the performance <a id="id759" class="indexterm"/>comparison of the <code class="literal">addPoint</code> method<a id="id760" class="indexterm"/> across <a id="id761" class="indexterm"/>the browsers:</p><div><img src="img/7451OS_10_17.jpg" alt="Removing and adding data points with Point.remove and Series.addPoint"/></div><p>There is hardly any difference between the <code class="literal">addPoint</code> method, <code class="literal">setData,</code> and <code class="literal">update</code> in terms of both CPU and memory usage.</p></div><div><div><div><div><h3 class="title"><a id="ch10lvl3sec24"/>Exploring SVG animation performance on browsers</h3></div></div></div><p>So far, we have seen that the<a id="id762" class="indexterm"/> level of CPU usage increased <a id="id763" class="indexterm"/>with animations. However, the question left unanswered is why Safari had lower CPU consumption than Chrome and Firefox. A number of browser benchmark suites have been run on the test machine to confirm the general consensus that the Firefox and Chrome browsers have overall better performance than Safari.</p><div><div><h3 class="title"><a id="note19"/>Note</h3><p>All browsers were benchmarked with SunSpider<a id="id764" class="indexterm"/> <a class="ulink" href="http://www.webkit.org/perf/sunspider/sunspider.html">http://www.webkit.org/perf/sunspider/sunspider.html</a>, Google's V8 Benchmark suite<a id="id765" class="indexterm"/> <a class="ulink" href="http://octane-benchmark.googlecode.com/svn/latest/index.html">http://octane-benchmark.googlecode.com/svn/latest/index.html</a>, and Peacekeeper<a id="id766" class="indexterm"/> <a class="ulink" href="http://peacekeeper.futuremark.com/">http://peacekeeper.futuremark.com/</a>.</p></div></div><p>Nonetheless, there is <a id="id767" class="indexterm"/>one particular area where Safari has<a id="id768" class="indexterm"/> better performance than the other browsers: SVG animations; this is reflected in our previous experiments. Here, we use a benchmark test, written by Cameron Adams, that is especially designed to measure SVG animations with bouncing particles in frames per second. The test (HTML5 versus Flash: Animation Benchmarking <a class="ulink" href="http://www.themaninblue.com/writing/perspective/2010/03/22/">http://www.themaninblue.com/writing/perspective/2010/03/22/</a>) was originally written to compare various HTML5 animation technologies against Flash. Here, we run the SVG test with the Chrome and Safari browsers. The following is a Safari screenshot running with a 500-particle test:</p><div><img src="img/7451OS_10_18.jpg" alt="Exploring SVG animation performance on browsers"/></div><p>As for Chrome, the test is running at around 165 FPS. We repeat the assessment with various numbers of particles on both browsers. The following graph summarizes the performance difference with regard to SVG animations:</p><div><img src="img/7451OS_10_20.jpg" alt="Exploring SVG animation performance on browsers"/></div><p>As we can see, Safari <a id="id769" class="indexterm"/>manages a higher frame <a id="id770" class="indexterm"/>rate with particles fewer than 3,000. After that, the Safari performance starts to degrade in parallel with Chrome. Firefox has a consistently lower frame rate and the frame rate drops considerably compared to the others.</p><p>This leads to another inevitable question: why is there such a difference, given that both browsers run with the same code base of webkit? It is difficult to pinpoint where the discrepancy lies. However, one of the few differences between both products is the JavaScript engines, which may affect that area, or possibly it is caused by the minor difference in the webkit version. In addition, other specific SVG performance tests in <a class="ulink" href="http://jsperf.com">http://jsperf.com</a> have <a id="id771" class="indexterm"/>also been run, in which Safari again had a higher score than Chrome.</p><p>In the next section, we will see how Highcharts' performance corresponds to the data size.</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec79"/>Comparing Highcharts' performance on large datasets</h2></div></div></div><p>Our final test is to observe <a id="id772" class="indexterm"/>how Highcharts performs with <a id="id773" class="indexterm"/>large data sets. In this experiment, we are going to plot scatter series across various data sizes and observe the time taken to display the data. We chose to use the scatter series because, when there is a very large data set with tens of thousands of samples, the user is likely to plot only data points on the chart. Here is the simplified code illustrating how we do it:</p><div><pre class="programlisting">var data = [];
// Adjust for each experiment
var num = 0;
if (location.match(/num=/)) {
   var numParam = location.match(/num=([^&amp;]+)/)[1];
   num = parseInt(numParam, 10);
}
for (var i = 0; i &lt; num; i ++) {
    data.push([ Math.random() * 1000000000, Math.random() * 50000 ]);
}

var start = new Date().getTime();
var chart = new Highcharts.Chart({
    chart: {
         renderTo: 'container',
         showAxes: true,
         animation: false,
         ....
    },
    series: [{
         type: 'scatter',
         data: data
    }],
    tooltips: {
         enabled: false
    },
    plotOptions: {
         series: {
             turboThreshold: 1,
             animation: false,
             enableMouseTracking: false
         }
    }
    }, function() {
         var stop = new Date().getTime();
         // Update the time taken label
         $('#time').append(((stop - start) / 1000) + " sec");
    });</pre></div><p>The page is loaded with URL parameters to specify the dataset size. We start timing before the chart object is created and stop at the callback handler in the constructor, <code class="literal">Chart</code>, method. We repeat the experiment with the same dataset size on each browser used in the previous benchmarking experiments. Once the page is loaded on a browser, the dataset is randomly generated. Then, timing begins just before the chart object is constructed and stops at the callback method in Highcharts. The chart function is executed when the chart is finally displayed onto the screen. The following screenshot shows the time taken to <a id="id774" class="indexterm"/>display 3,000 data points on the<a id="id775" class="indexterm"/> Safari browser:</p><div><img src="img/7451OS_10_21.jpg" alt="Comparing Highcharts' performance on large datasets"/></div><p>The following graph illustrates Highcharts' performance on different browsers with various dataset sizes. The lower the line, the less time it takes to display the number of data points, which indicates better performance:</p><div><img src="img/7451OS_10_22.jpg" alt="Comparing Highcharts' performance on large datasets"/></div><p>None of the browsers take particularly long to display large datasets. This shows the impressive scalable performance of Highcharts. Even IE 11, which is consistently slower in all tests, only takes 5.3 seconds to render 50,000 data points. As for smaller datasets, there is hardly any difference in timing. Both Firefox and Safari have very similar results, although Firefox is marginally better. This is due to the fact that there is no animation in scatter series and Firefox generally performs better without SVG animation. This also supports our findings in the least animated <code class="literal">addSeries</code> experiment, where Firefox required less CPU usage. As for Chrome, its performance is roughly equidistant between Safari/Firefox and IE 11.</p><p>From all these<a id="id776" class="indexterm"/> experiments, we can <a id="id777" class="indexterm"/>conclude that Safari performs  the best with Highcharts (on a Windows PC), particularly when there are a lot of SVG animations in the chart. If a chart is static, then Firefox gives the best performance. IE 11 has the best memory utilization among the browsers but runs slower. Chrome achieves a consistent mid-range performance. We must stress that SVG is only one of the many areas of performance testing and Chrome has outperformed other browsers in the benchmark score.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec68"/>Summary</h1></div></div></div><p>In this chapter, we studied the Highcharts APIs, from the class model to applying them in applications. Then we performed a comprehensive study of the different techniques for updating a chart series in Highcharts, and carried out an experiment to analyze the difference in their performance. Finally, the chapter finished by analyzing the speed of different web browsers when rendering data points with regard to different sizes of large datasets.</p><p>In the next chapter, we will look into Highcharts events handling, which is closely related to Highcharts APIs.</p></div></body></html>