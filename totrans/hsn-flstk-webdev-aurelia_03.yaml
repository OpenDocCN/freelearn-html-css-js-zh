- en: Testing and Debugging
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Testing is one of the most important phases of the development process. Whatever
    type of project you are working on, testing is key if you want to deliver applications
    with high quality and make your users happy.
  prefs: []
  type: TYPE_NORMAL
- en: Just imagine what would happen if your favorite taxi application makes your
    driver take you to the wrong place or the price of your trip is higher than it's
    supposed to be? This embarrassing bug will undoubtedly produce a series of catastrophic
    events that will damage the reputation of the application and, worse still, the
    company reputation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Learning how to test our Aurelia applications and how to correctly apply the
    **Test**-**Driven Development** (**TDD**) approach will improve the quality of
    your applications, avoid embarrassing bugs, make your users happier, and make
    you a better developer. So, in this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Benefits of testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TDD
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aurelia testing framework
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Practicing testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging our code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Benefits of testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Making *testing* part of our development process comes with a lot of benefits
    in every layer of our project. Before we start writing code to test our application,
    let''s review the benefits that good testing brings to:'
  prefs: []
  type: TYPE_NORMAL
- en: The development team
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The organization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The users
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For the development team
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you work in a team with multiple members, you might have experienced that
    bad moment when a member pushes some changes and the application does not work
    as expected. Not only that, if the team does not have a mechanism to avoid changes
    that can break, someone else's code might cause conflict and decrease the quality
    of our applications.
  prefs: []
  type: TYPE_NORMAL
- en: Applying testing enables a mechanism that helps us avoid potential bugs in the
    code. It is recommended that you write test scripts for all the components into
    the application. The code coverage percentage is an indicator of how much testing
    the development team has written for the application. It is recommended to have
    a 100 percent coverage; with this, you ensure that every time someone else changes
    the code, you are not breaking someone else's code.
  prefs: []
  type: TYPE_NORMAL
- en: For the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are working in an *agile* team, you might be familiar with sprints of
    two weeks or maybe one month. When you work in agile teams, it is important to
    automate as much as you can, and automating the testing phase will help your team
    deliver deliverables quickly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Automating testing without the need for human intervention requires your team
    to write tests in all the phases of the application, such as these:'
  prefs: []
  type: TYPE_NORMAL
- en: Unit test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: UI test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: End-to-end test
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For Aurelia applications, you will learn how to write unit-test scripts and
    end-to-end tests. Writing tests and automating them will increase the development
    speed of our team.
  prefs: []
  type: TYPE_NORMAL
- en: For the organization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to protect the reputation of the organization in which you are
    working. Testing projects in our organization as much as possible will improve
    its reputation and make it more reliable.
  prefs: []
  type: TYPE_NORMAL
- en: There are many cases where big companies have lost a large amount of money because
    of failures in software. All these mistakes could have been avoided if the applications
    had been tested before they were published to the users. For that reason, understanding
    the importance of good testing is key in every aspect of the organization.
  prefs: []
  type: TYPE_NORMAL
- en: For the users
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Nothing is worse than delivering an application to your users that does not
    satisfy their needs, and even worse is an application infested with bugs and is
    of a generally poor quality. Think carefully about what you deliver to your users.
    The more you code, the more satisfied your users will be.
  prefs: []
  type: TYPE_NORMAL
- en: Test-Driven Development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This is a development approach that changes the way developers test the code
    of their applications. Previously, developers implemented all the business logic
    of their applications and once everything was coded, they wrote the tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Writing test scripts is not an easy task; just imagine the time it takes to
    code all the business logic of your application, and the fact that you have to
    write tests for all the possible scenarios requires a lot of knowledge about the
    system itself and the level of complexity only increases if you are the sole developer
    who maintains the code. However, thankfully, there is a better way to test things
    out. TDD is composed of three simple phases:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8288c148-ff21-4e0c-8387-d6c9ddaca46f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Always remember these three colors: red, green, and blue; they represent the
    TDD cycle. Being in the red phase means that you have written what your piece
    of code is supposed to do, but the functionality is not implemented yet and the
    test will fail. Being in the blue phase, it means that you have implemented the
    code and the test now passes without any problem, but the code might be refactored.
    Lastly, being in the green phase means that both the code and tests were implemented
    and passed successfully, and the code is well formatted and easy for any developer
    to read.'
  prefs: []
  type: TYPE_NORMAL
- en: Let's cover each step in further detail to get a close look at TDD phases by
    coding a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: Making our code fail
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is important to know that we won't use any testing framework at this point.
    The main goal in this section is to understand how TDD works; we have a complete
    tour of testing technology in the following sections in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will use TDD to create an additional function called `sum`, which will return
    the sum of two numbers that are passed as parameters. First, using an editor of
    your choice, create a new file called `testing.js` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the `assert` module to use its `equal` function. The `equal`
    function expects three parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: The current value or expression to be analyzed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The expected value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The message that should be thrown in case the current and expected value are
    not equal
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the assertion *fails*, the program will be *finished* and you will see the
    reason why the assertion fails in your Terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we import our `assert` module, we proceed to create our `add` function.
    However, this function does not perform any operation; this is because our intention
    is to first write the test and make it fail, and after that we will implement
    the logic itself in the next point. In the same `testing.js` file, append to the
    following code with the testing case right below the `add` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Now we have our test case, which will compare the current value—`add(5, 5)`—housed
    into the result variable against the expected value—`10`, and if they are not
    equal, the `Should be 10` error message will be displayed and as the program is
    complete, the next expression—`console.log`—won't be executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time to execute our test. Using your Terminal, get into your folder where
    you have created the `testing.js` file and execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went wrong, you should see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Cool! Now it's time to implement the code and pass our test.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, let''s implement the code in the `add` function. We will declare a `result`
    variable into the function to house the addition between the two parameters passed
    to it. Open the `testing.js` file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we have implemented the logic for our `add` function, the next time
    we run the test, we expect that the `assertion.equal` function won''t fail and
    the `Test passed!!` message will be displayed. Let''s try it out. Execute the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the test passed and now the `Test passed!!` message is displayed.
    By using this strategy to write the test first and then implement it, we can be
    100 percent sure that our application is doing what it's supposed to do.
  prefs: []
  type: TYPE_NORMAL
- en: Let's follow the last step to finish our TDD flow.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At this point, everything is okay; we have our test and implementation written,
    the code is doing what we expect, and it seems that there's nothing left to do.
    But, as a good developer, we should look for ways to make our code more readable
    and reduce the lines of code. Also, the refactoring phase is used to change some
    weird variable names and, if possible, add comments to our code if needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your `testing.js` file and apply the following changes to make it more
    readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The first change is in the `add` function. As this is a simple addition operation,
    declaring a `result` variable is not necessary, so we return the addition result
    in the `return` function to make it more readable.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we are passing the results of the call to `add(5, 5)` into the `assert.equal`
    function, so it is easier to know what you are trying to test.
  prefs: []
  type: TYPE_NORMAL
- en: As you might see, TDD is easy to implement but a little bit hard to adopt; we
    (the authors :D) encourage you to adopt and use it at work. This will make your
    life easier and will help you become a better programmer who knows how to deliver
    quality software.
  prefs: []
  type: TYPE_NORMAL
- en: Now it's time to see what Aurelia has to offer. Keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Aurelia testing frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Aurelia is powered by other open source testing technologies which together
    help us set up a very productive development environment. Understanding the fundamentals
    of these technologies will give us a clear idea of how things work and will give
    you the knowledge to tackle any problem that may appear in the future.
  prefs: []
  type: TYPE_NORMAL
- en: Before we write our first Aurelia tests, let's learn about JasmineJS and KarmaJS,
    the most awesome frameworks that the JavaScript ecosystem could provide us for
    testing, and let's use the example implemented in the TDD section to understand
    how to write testing scripts using the Jasmine syntax and assertions helper functions.
  prefs: []
  type: TYPE_NORMAL
- en: Learning JasmineJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As is detailed in its website, Jasmine is a behavior-driven development framework
    for testing JavaScript code: it does not depend on any other JavaScript frameworks,
    it does not require a DOM, and it has a clean, obvious syntax so that you can
    easily write tests. Jasmine is an easy-to-learn framework, and it comes with its
    own assertion functions, so we don''t need to install any additional assertion
    library, such as Chai. Let''s start installing it and exploring the building blocks—suites
    and test cases.'
  prefs: []
  type: TYPE_NORMAL
- en: Installation and configuration
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the NPM tool to install Jasmine. Open your favorite Terminal and
    execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding instruction will install Jasmine as an executable program that
    you can invoke in any folder in your Terminal. We achieve this using the `--global`
    flag in the `npm install` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once Jasmine is installed, we need to create our project example skeleton to
    practice with Jasmine. For this, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new folder called `practice-jasmine`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a new Jasmine project by executing the `jasmine init` command
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Write our test script
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'So, having the steps clear, open your Terminal and execute the following commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `jasmine init` command is executed, it will create the following folder
    structure for our project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can get the preceding tree list by installing the `tree` program and executing
    it into your `practice-jasmine` folder with the `tree` command.
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the root of the project''s folder, there is a `spec` folder,
    where we will save all our test scripts. Right in the `spec` folder, there is
    a `support` folder where a `jasmine.json` file has been created for us. This file
    contains all the configuration that Jasmine will use to find our test scripts
    and then execute them. Using the editor of your choice, open the `jasmine.json`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The important properties to consider in this file are `spec_dir`, which points
    to the folder that hosts our test scripts, and `spec_files`, which declares a
    regular expression that tells Jasmine that the files containing `spec.js` or `Spec.js`
    at the end of their names have to be considered as test scripts and have to be
    processed.
  prefs: []
  type: TYPE_NORMAL
- en: 'To validate that everything is configured correctly, execute the following
    command in the root `practice-jasmine` directory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You should see the message `No specs found` displayed which means that as we
    didn't write any test yet, Jasmine was not able to process any test case. Also,
    you can see how much time Jasmine takes to execute your tests.
  prefs: []
  type: TYPE_NORMAL
- en: Test suites
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Following the best practices, you have to separate your tests that are similar
    to be grouped in suites. For example, in our application, we will write code to
    manage football matches and information about teams. Both matches and teams are
    different domains and for that reason, we should group the tests related to the
    matches in a suite and repeat the same for teams.
  prefs: []
  type: TYPE_NORMAL
- en: 'Following the example where we created an `add` function, we might be implementing
    this function for a Calculator application, so let''s use this as an example to
    understand Jasmine. In the `specs` folder, create the `calculator.spec.js` file
    and write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We have created our test suite; for that, we are using the `describe` function
    and we pass the name of our suite as the first parameter, in this case `Calculator`,
    and as the second parameter, we pass a function that will contain the code for
    our test cases.
  prefs: []
  type: TYPE_NORMAL
- en: Test cases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To write the test for our applications, we need test cases that should basically
    consider all the possible scenarios that your app can afford. For our Calculator
    example, we will create test cases for the four main arithmetic operations—addition,
    multiplication, subtraction, and division. Test cases are created using the `it`
    function, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we continue on our trip, we should have something to test. So let''s
    create a `Calculator` object to test out. In the same `calculator.spec.js` file,
    add the following code at the very beginning, before the suite declaration, as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Now that we have something to test, let's learn about how we can write assertions
    in our test file.
  prefs: []
  type: TYPE_NORMAL
- en: Expects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We test the functionality of our code by writing expects that are no more than
    simple assumptions that we have for our code if everything was implemented correctly.
    In the file we are working on, apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: We have created the expectations that we have for our code. For example, for
    the additional test case, we expect that the result of `add(1, 2)` returns `3`.
    We specify the match operation using helper functions, such as the `toEqual` function,
    that as its name says, won't raise any exception in case the result of calling
    the add function is the same as the expected value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our test script fully implemented, let''s execute it and see
    what we get in the console. Run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the output displayed is that `4 specs` were found and executed without
    failures. It is time to see what will happen if we force a test case to fail.
    Replace the expect statement in the addition test case for the following expects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the changes are applied, run the following command to make our test fail:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Let's analyze the output. The first thing to note is the following `F...` string,
    this means that the first test has failed and the other 3 (dots) are correct.
    You can also read the `Expected 3 to equal 30` message giving the reason why our
    test fails, and finally the test resume that shows that `4 specs` where found
    but just `1 failure` occurred.
  prefs: []
  type: TYPE_NORMAL
- en: The output for this test displays the failing test at the beginning of the `F...`
    string. This might be at the beginning or in another order. That is because the
    random property in the `jasmine.json` file is configured to be true, which means
    random executions. If you want to execute your tests sequentially, change the
    random property to false.
  prefs: []
  type: TYPE_NORMAL
- en: You have seen how easy it is to use the Jasmine framework to test our code.
    Of course, you have to learn more about it; we would really like to teach you
    everything about Jasmine, but that is beyond the scope of this book. We recommend
    you visit the official site at [https://jasmine.github.io/](https://jasmine.github.io/).
  prefs: []
  type: TYPE_NORMAL
- en: Learning KarmaJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored Jasmine, which basically is a testing framework powered with
    a cool syntax and functions that help us write the test scripts for our application;
    in order to execute our test, we had to execute them manually and wait until this
    finished to see how many tests passed and how many failed.
  prefs: []
  type: TYPE_NORMAL
- en: Karma is a test runner. A test runner is a tool that is configured to look for
    the test scripts of our application, execute the tests automatically, and export
    the result of our testing. As we are creating web components with Aurelia, we
    will need to test our application in different browsers with different characteristics,
    and as web browsers are different in many ways, we need a way to test our web
    application in all possible browsers to ensure that our users won't face any problem
    with our app.
  prefs: []
  type: TYPE_NORMAL
- en: 'Karma is able to use any testing framework to implement tests. As we have learned
    Jasmine, we will be using it to write our test scripts, and we will be using Karma
    to pick up the test files, execute them, and export the results. The following
    illustrates the flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3bcb21ff-e054-48b5-baa5-d1ff436bb484.png)'
  prefs: []
  type: TYPE_IMG
- en: We will see the power of KarmaJS later in this chapter; just keep in mind that
    Aurelia uses Karma as its test runner for all the projects that you create using
    the Aurelia CLI, as discussed in Chapter 1, *Introducing Aurelia.*
  prefs: []
  type: TYPE_NORMAL
- en: Installing karma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will use the NPM to install Karma and other dependencies. Let''s start creating
    a practice folder called `practice-karma` and initializing our project. Run the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'We use `npm init` to create a new module; this will prompt you a bunch of questions
    and will create a `package.json` file similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Up to now, you should have the following folder structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Now it''s time to install Karma and the dependencies that we require to use
    Karma and Jasmine. In the `practice-karma` folder, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will install the dependencies required to use Karma and
    Jasmine, and also will add the dependencies to our `package.json` file into the
    `devDependencies` attribute. Open your `package.json` file, and you should see
    something similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: As we have to use the `--save-dev` flag, the dependencies are listed in the
    `devDependencies` attribute; if you use `--save` instead, it will list the dependencies
    in the `dependencies` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Karma
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that Karma is installed, we need to configure the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Jasmine as testing tool
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Folders with the app code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web browser launcher
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reporters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Setting up all the preceding parameters might result in a very time-consuming
    task, so we will use the Karma executable to configure everything automatically.
    In the `practice-karma` folder, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This will prompt you a bunch of questions; just press enter to accept all the
    default configuration, and once everything is done, a `karma.conf.js` file will
    be created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to specify a pattern for the files to be utilized in the testing process.
    To do this, apply the following changes to the `files: []` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have specified that every file that ends with `.spec.js` in its name
    will be processed by karma. Let''s create the `specs` folder and inside, create
    the `calculator.spec.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'You should have a project structure similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Now it's time to test things out by creating a testing example.
  prefs: []
  type: TYPE_NORMAL
- en: Testing example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For the Calculator app example, let''s create the *src* folder in the root
    project''s folder and create the `calculator.js` file inside:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, we are not saving our `calculator.js` file inside the `specs/`
    folder, so we need to configure karma to load the files present in the `src/`
    folder. Apply the following changes in the `karma.conf.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Now, Karma will load all the files from the `specs` and `src` folder when testing
    is running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s implement the code of our `calculator.js` file. Using your editor of
    choice, open the `src/calculator.js` file and apply the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: If you want to make a variable accessible globally, simply create it as a property
    of the window object. In this case, we made the `Calculator` object **global**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s write our test case. Open the `specs/calculator.spec.js` file and
    apply the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code should be familiar to you if you note that we are using the
    Jasmine testing framework to write our tests. Now that we have everything set
    up and our code implemented, let's continue by launching the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Launching the test runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our test code and a Calculator object, it''s time to launch
    Karma to execute our test. Open the command line and in the `practice-karma` root
    folder, execute the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will output a bunch of logs, while it opens a new window
    in your Chrome web browser and executes your test into the web page recently started.
    This page is opened in Chrome because it is configured in the `karma.conf.js`.
    Consider this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Note in the last lines that our test was executed with a successful result.
    The web page launched looks similar to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5f11a98a-d0c2-4882-b77e-181eae459390.png)'
  prefs: []
  type: TYPE_IMG
- en: 'As you might have noted, running the previous command might be too long to
    remember; to make our life easy, let''s configure our `package.json` file to configure
    the `test` script to execute this command for us. Open the `package.json` files
    and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'Once configured, execute the following command to run the tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: That's it. Using Karma and Jasmine will give us all the enablers we need to
    write robust tests for our applications. Both technologies are not limited to
    web development. You can use them in any Javascript project such as a backend
    written in Node.js. So now, it's time to see an example with a real Aurelia component.
    Keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Testing an Aurelia component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In order to see a real testing example, we will create a simple application.
    This app will merely greet a user and display the topic currently learning. These
    two pieces of data, the username and topic, will be persisted as bindable entities
    and we will call this component `info-box`. We will develop an application similar
    to the following mock-up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d76e6c9-ce5f-4a8e-9f7e-d51e7e75141f.png)'
  prefs: []
  type: TYPE_IMG
- en: Coding the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We will use the Aurelia CLI to generate our Aurelia application. Aurelia configures
    the project to work with the Karma test runner and the Jasmine testing framework
    and uses Chrome as the default web browser.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our application, open your Terminal and in the working directory
    you prefer, run the following command and accept the defaults:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will create a new directory called `aurelia-testapp`;
    let''s get into this folder and launch the application by running the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding command will output a bunch of logs while the development server
    is starting and Aurelia is getting started. Head over to `http://localhost:9000`;
    and you should see something similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c624d46-6a5f-40c0-a41c-6547476a532a.png)'
  prefs: []
  type: TYPE_IMG
- en: Creating our component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To create our `info-box` component, we will use the Aurelia CLI. Stop the running
    application and execute the following command. This will ask you for the destination
    folder; press *Enter* to use `src` as default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'This command will create two files that together define the `info-box` component;
    these files are as listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '`info-box.js`: Contains the component''s view model'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`info-box.html`: Contains the HTML view template'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's implement our `info-box` component.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the info-box view model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `info-box.js` file and apply the following changes to declare the
    `username` and `topic` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Implementing the info-box view HTML template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Open the `info-box.js` file and apply the following changes to bind our attributes
    to the HTML template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Rendering the info-box component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To load and render our component, we need to import the component into the
    app component. Open the `app.html` file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we import the `info-box` component and then use it using the `<info-box>` tag
    syntax. With changes done, launch the application again by running the `au run
    --watch` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8a10e764-5b92-4b56-a943-30f0ab9dc317.png)'
  prefs: []
  type: TYPE_IMG
- en: Writing the test
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before we start writing our test, let''s clean up the `test` folder by removing
    the `app.spec.js` file in the `unit` folder. Once completed, you should have something
    similar to folder tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: 'In the `unit` folder, create the `info-box.spec.js` file and add the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: First, we import two objects from the Aurelia framework that we will use to
    initialize our `info-box` component. Then, we declare our `Info-Box` test suite
    and we declare one test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that we are using a special syntax; instead of using `function() {}`,
    we are using `() => {}` ECMAScript syntax. To unit test our component, we will
    need to perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap the component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the component
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bootstrapping the component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will need to create the component so that Jasmine will use it to apply the
    test. Apply the following changes in the `info-box.spec.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Before we bootstrap the component, it has to be created. We use the `StageComponent`
    object to instantiate an Aurelia component; we specify the component by passing
    its name as a param of the `withResources` function. Lastly, we specify a view
    using the `<info-box>` element in the `inView` function.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have the component skeleton defined, we call its `create` function and
    pass the `bootstrap` object. The `bootstrap` object contains the default configuration
    specified in the `main.js` file, as discussed in Chapter 1*, Introducing Aurelia.*
  prefs: []
  type: TYPE_NORMAL
- en: Testing the component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have our component created, we need to test it. To do this, we
    rely on the done callback passed to the test function to notify Jasmine that the
    test is done. If we don''t specify the done parameter, our test won''t be executed
    because we execute our assertions in a promise and if we don''t call it, we will
    get a timeout error since Jasmine won''t be able to know when our test completed.
    Let''s apply the following changes to the `info-box.spec.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: You should be aware that if you are using Webpack, you might need to import
    `PLATFORM` from the `aurelia-pal` module in order to load the `info-box` resource
    as follows—`.withResourceS(PLATFORM.moduleName('info-box'))`. For additional Webpack
    considerations, visit the official site at [https://aurelia.io/docs/build-systems/webpack](https://aurelia.io/docs/build-systems/webpack).
  prefs: []
  type: TYPE_NORMAL
- en: In the `then` function, we pass our callback that will use the `component.element.querySelector`
    function to access the HTML elements into the `info-box` component, and we use
    the `innerHTML` property of the elements to access the element's values.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we compare the values of the elements by the expected values and when
    all the `expect` statements are executed, we call the `done()` function to tell
    Jasmine we have finished this test case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Lastly, a `catch` callback is passed to print any error detected in the test
    process. Once everything is complete, run the following command in your Terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'If everything went right, the Chrome web browser should be opened and you should
    see the following output in your Terminal window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: That's it! Now you know how to test Aurelia components. A little challenge for
    you is to apply everything learned in a TDD cycle. Have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Debugging our code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Debugging tools are extremely important for a developer. It does not matter
    which programming language or framework you are using, or if you are working on
    either frontend or backend project. Debugging will always be present in your development
    process.
  prefs: []
  type: TYPE_NORMAL
- en: Nowadays, the web browser does more than just server pages, caching content,
    saving favorites, and so on. They are complete web development tools that provide
    awesome tools to debug our code and application performance.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how we can debug our code using our favorite web browser. We will
    use Chrome Developer Tools as an example.
  prefs: []
  type: TYPE_NORMAL
- en: Refactoring our application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: First, we need to start our application and open it in a web browser. Let's
    use our `aurelia-testapp`*:*
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'With the application up and running, head over to `http://localhost:9000` to
    see the application. We will add a button and when the button is pressed, we will
    debug some dummy code. Open the `info-box.html` file and apply the following change:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Open the `info-box.js` file and apply the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to your browser application, click on the Debug Me! button, and you
    should see the following on the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d5b52c1a-fb65-40fc-bc2b-35efb26d58cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Debugging with Chrome Developer Tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We need to open the Chrome Developer Tools. To do this, go to the View | Developer
    | Developer tools option in the menu or press *F12*. You should see something
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/67c2e18e-3cbd-47ca-b209-95e9c395d23e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With this window open, let''s apply a little change to our `info-box` file
    to tell the browser that we want to stop and debug our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Go back to your application and click on the Debug Me! button. The `debugger;`
    instruction will stop the browser execution and enter into the browser debugging
    mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/59055109-a3b2-41c2-8af5-51fe53f119e6.png)'
  prefs: []
  type: TYPE_IMG
- en: You can use the Developer Tools options to navigate your code, analyze variables
    values, add breakpoints, and so on. I personally prefer to debug my code in this
    way. You can try debugging code using the Node.js command line or another type
    of debugging. Debugging tools will vary depending on the web browser you are working
    on.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are in good shape and we know how to style and test Aurelia applications,
    it's time to learn how to create awesome Aurelia components. Keep reading!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we explored the benefits that good testing brings to our company,
    team, products, and users. Good testing will always make our products better and
    our users happy.
  prefs: []
  type: TYPE_NORMAL
- en: 'We learned how to apply TDD to our software development process and the importance
    and impact it has on the quality of our apps. You should always remember that
    TDD is composed of three colored phases: the red phase, which makes your test
    fail; the blue phase, which makes your test pass; and lastly, the green phase,
    which refactors and cleans your code.'
  prefs: []
  type: TYPE_NORMAL
- en: We also learned about the testing technologies that Aurelia uses for development
    and learned how to use them independently. Jasmine is the testing framework and
    Karma is used as the test runner.
  prefs: []
  type: TYPE_NORMAL
- en: We practiced with a real testing example of an Aurelia component and we explored
    some debugging options.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we are in good shape and know how to style and test Aurelia applications,
    it's time to become real experts in creating Aurelia components. So, keep reading!
  prefs: []
  type: TYPE_NORMAL
