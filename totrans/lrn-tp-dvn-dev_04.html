<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Grouping Values Together in Types</h1>
                </header>
            
            <article>
                
<p class="mce-root">In <span>the previous chapter, we saw a way to group types and values together so that they can be accessed under a single namespace, and we saw how these namespaces (modules) themselves have types. Modules are not, however, convenient for passing around values during runtime. We need a lightweight way to build more structured types out of simpler types, to model real-world problems.</span><br/></p>
<p>In this chapter, we will cover these structured types, specifically:</p>
<ul>
<li>Record types</li>
<li>Tuple types</li>
<li>Object types</li>
<li>JavaScript object types</li>
</ul>
<p>Collectively, these types are referred to as <strong>product types</strong> because the number of possible values a product type can contain is the <em>product</em> of the number of possible values each of its component types can contain. This is an interesting result in type theory, and it gives us a hint to the fact that types obey certain algebraic laws. I will provide further reading materials on this later on in the book, after we have developed our type knowledge more.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Record types</h1>
                </header>
            
            <article>
                
<p>We've used record types in several places in the book so far, mostly to build a <kbd>person</kbd> type with an ID and a name. Let's examine this simple record type a bit more closely and pick apart what exactly happens when it is created:</p>
<pre><span class="underline">type</span> <strong>person</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>};</pre>
<p>As a whole, this type definition creates a new <em>nominal</em> type called <kbd>person</kbd> with two named fields: <kbd>id</kbd> and <kbd>name</kbd>, with specific <kbd>int</kbd> and <kbd>string</kbd> types. A nominal type is one that is distinguished by the typechecker from other types solely by name.</p>
<div class="packt_infobox">This is as opposed to structural types, which are considered by the typechecker to be equal to their constituent types. For example, we saw in the previous chapter that modules are structurally typed. We'll see some more examples in this chapter and the next one.</div>
<p>At any rate, nominal types cannot be used interchangeably, even if they have the exact same definition. For example:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch03/Ch03_Greet.re 10:20-22<br/>  <br/>   8 │ type person = {id: int, name: string};<br/>   9 │ let bob = {id: 1, name: "Bob"};<br/>  <strong>10</strong> │ let result = greet(<strong>bob</strong>);<br/>  <br/>  This has type:<br/>    <strong>person</strong><br/>  But somewhere wanted:<br/>    LearningTyddReason.Ch02_Demo.person (defined as<br/>      LearningTyddReason.Ch02_Demo.person)</pre>
<p>In the preceding error message, notice that we defined a new record type <kbd>person</kbd> in <kbd>Ch03_Greet</kbd>, created a value of this type, and tried to call the <kbd>greet</kbd> function with it. But the <kbd>greet</kbd> function only accepts <kbd>Ch02_Demo.person</kbd> values and errors on our <kbd>person</kbd> value that have the same structure but a different name (the module path is considered to be part of the name for this purpose):</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/019817df-50ca-4b34-9ca3-2dd33233086d.png" style="width:29.83em;height:2.67em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Type mismatch between nominal types with the same definition</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Record literals</h1>
                </header>
            
            <article>
                
<p>We can create record values using the record-literal syntax:</p>
<pre>/* src/Ch04/Ch04_RecordLiterals.re */<br/><span class="underline">type</span> <strong>person</strong> = {<em>id</em>: <strong>int</strong>, <em>name</em>: <strong>string</strong>};<br/><br/><span class="underline">let</span> <em>bob</em> = {<em>name</em>: "Bob", <em>id</em>: 1}; /* (1) */<br/><br/><span class="underline">let</span> <em>jim</em> = { /* (2) */<br/>  <span class="underline">let</span> <em>id</em> = 2;<br/>  <span class="underline">let</span> <em>name</em> = "Jim";<br/>  {<em>id</em>, <em>name</em>} /* (3) */<br/>};<br/><br/><span class="underline">let</span> <em>tomId</em> = 3;<br/><span class="underline">let</span> <em>tom</em> = {<em>id</em>: <em>tomId</em>, <em>name</em>: "Tom"}; /* (4) */</pre>
<p>These are the typical variations of record literals:</p>
<ol>
<li>Standard record-literal syntax for a record type with the <kbd>field1</kbd> to <kbd>fieldN</kbd> fields is: <kbd>{field1: expression1, ..., fieldN: expressionN}</kbd>. Note one of the most significant things about records: <em>field order doesn't matter.</em> Here we defined a record literal with field names in the opposite order to the record-type definition.</li>
<li>We can start an enclosed scope with brackets so that the names declared inside (<kbd>id</kbd>, <kbd>name</kbd>) will not be visible from outside, and the last expression (<kbd>{id, name}</kbd>) in the enclosed scope will be the result value of the scope. Note that the scope delimiter brackets are separate from the record delimiter brackets.</li>
<li>We can use the <em>record field punning</em> syntax to write record literals when there is a name in the scope that's identical to the field name. Modern JavaScript has gained this punning feature as well.</li>
<li>We can fall back on the standard record-literal syntax with any expression if we don't have names in the scope identical to the field names.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing fields and dealing with errors</h1>
                </header>
            
            <article>
                
<p>Record field access syntax looks much like in other languages: <kbd>recordValue.fieldName</kbd>.</p>
<p>To correctly infer the types of record literals though, Reason depends on matching up the field names to record types that it knows about. A common error that you will see is when Reason can't find a suitable record type; for example, if we delete the <kbd>person</kbd> type from <kbd>Ch04_RecordLiterals</kbd>:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch04/Ch04_RecordLiterals.re 2:12-13<br/>  <br/>  1 │ /* src/Ch04/Ch04_RecordLiterals.re */<br/>  <strong>2</strong> │ let bob = {<strong>name</strong>: "Bob", id: 1}; /* (1) */<br/>  3 │ <br/>  4 │ let jim = { /* (2) */<br/>  <br/>  The record field name can't be found.<br/>  <br/>  If it's defined in another module or file, bring it into scope by:<br/>  - Annotating it with said module name: let baby = {MyModule.age: 3}<br/>  - Or specifying its type: let baby: MyModule.person = {age: 3}</pre>
<p>This often happens when the record type is defined in another module. We mentioned before that Reason doesn't automatically search through other modules to find record types, because different modules could contain record types with the same field names; it would be unclear which one you meant. Instead, Reason opts to have you be explicit about the module, for example:</p>
<pre><span class="underline">let</span> <em>bob</em> = {<em>Ch02_Demo.id</em>: 1, <em>name</em>: "Bob"};</pre>
<p>Now Reason can tell that:</p>
<ul>
<li>The <kbd>id</kbd> field you're referring to is in <kbd>Ch02_Demo</kbd></li>
<li>The record literal has only the <kbd>id</kbd> and <kbd>name</kbd> fields</li>
<li>Therefore, the only type this record can possibly be is <kbd>Ch02_Demo.person</kbd> (it can't be <kbd>Ch02_Demo.company</kbd> because that record type has an <kbd>employees</kbd> field as well)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Changing record values</h1>
                </header>
            
            <article>
                
<p>Records are by default immutable: once you create one, you can't change it. This is in addition to all Reason values being non-reassignable by default (meaning that something such as <kbd>let x = 1; x = 2;</kbd> is a compile error). This rigidity is for good reason: if you know that values can't change, it becomes really easy to think about each part of your program in isolation and then be confident that the parts will behave consistently when put back together. This is one of the core principles of <em>functional programming,</em> which Reason's statically typed techniques are built on.</p>
<p>But completely unchangeable values are not very useful. You'll usually need to change values at runtime to model the behaviors you're interested in. So Reason provides two ways to change record values: immutable updates and mutable fields.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Immutable updates</h1>
                </header>
            
            <article>
                
<p>This is what we will be using most of the time. With <em>immutable updates,</em> we literally create new record values using old ones. Reason provides a special syntax for this, which comes in very handy when the record type has two or more fields. But no matter how many fields, we can always build record values by just using the normal record-literal syntax. The following are some examples:</p>
<pre>/* src/Ch04/Ch04_RecordUpdates.re */<br/><span class="underline">let</span> <em>bob</em> = <em>Ch04_RecordLiterals.bob</em>;<br/><span class="underline">let</span> <em>bobLongForm1</em> = {...<em>bob</em>, <em>name</em>: "Robert"}; /* (1) */<br/><span class="underline">let</span> <em>bobLongForm2</em> = {<em>Ch04_RecordLiterals.id</em>: <em>bob.id</em>, <em>name</em>: "Robert"}; /* (2) */</pre>
<p>Here, we update Bob's name to its long form. Note a couple of things:</p>
<ol>
<li>When we use the immutable update syntax (also known in Reason as the <em>record spread</em> syntax), Reason creates a new record value that's identical to the old one (<kbd>bob</kbd>), except for the fields that we override. Also, even though the record type is defined in another module, we don't need to use a module prefix for any fields, because the immutable update forces Reason to look up what the fields are and thus it knows about the <kbd>name</kbd> field when we update it.</li>
<li>When we use the normal record-literal syntax, we need to define all the record fields. If we forget one, we'll get a rather interesting type of error:</li>
</ol>
<pre style="padding-left: 60px"><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch04/Ch04_RecordUpdates.re 4:20-51<br/>  <br/>  2 │ let bob = Ch04_RecordLiterals.bob;<br/>  3 │ let bobLongForm1 = {...bob, name: "Robert"};<br/>  <strong>4</strong> │ let bobLongForm2 = <strong>{Ch04_RecordLiterals.id: bob.id}</strong>;<br/>  <br/>  Some record fields are undefined: name</pre>
<p>Since Reason doesn't allow null or undefined values, it's a type error to leave out a record field:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9dc9e2f4-8feb-40ae-a355-791c87f6cba8.png" style="width:41.67em;height:7.42em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Missing record field type error</div>
<p>With immutable updates, we can reuse the same name and not have to worry about coming up with new names for various transformed values, thanks to shadowing:</p>
<pre><span class="underline">let</span> <em>bob</em> = <em>Ch04_RecordLiterals.bob</em>;<br/><span class="underline">let</span> <em>bob</em> = {...<em>bob</em>, <em>name</em>: "Robert"};<br/><span class="underline">let</span> <em>bob</em> = {...<em>bob</em>, <em>id</em>: <em>bob.id</em> + 1}</pre>
<p>We'll often use shadowing to perform a series of updates on some value, to convey the intention that we're building or transforming the same value toward a final use.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mutable record fields</h1>
                </header>
            
            <article>
                
<p>These are used less often because they introduce an element of unsafety into a program, and force the developer to be much more defensive in their code. You have a binding of a certain value at one point, and at another point it can be a different value, and all other parts of the codebase that were behaving in a certain way based on the original value will be in for a big surprise if they happen to check again and find the new value.</p>
<p>Nevertheless, they can be very useful if you need some extra performance from some records, and you keep the mutations contained within the scope of a single function. Here's an example:</p>
<pre>/* src/Ch04/Ch04_MutableFields.re */<br/><span class="underline">type</span> <strong>summaryStats</strong> = {<br/>  <span class="underline">mutable</span> <em>sum</em>: <strong>float</strong>, /* (1) */<br/>  <em>count</em>: <strong>int</strong>,<br/>  <span class="underline">mutable</span> <em>mean</em>: <strong>float</strong><br/>};<br/><br/><span class="underline">let</span> <em>summarise</em>(<em>array</em>) = {<br/>  <span class="underline">let</span> <em>result</em> = {<em>sum</em>: 0., <em>count</em>: <em>Array.length</em>(<em>array</em>), <em>mean</em>: 0.}; /* (2) */<br/><br/>  <span class="underline">for</span> (<em>i</em> <span class="underline">in</span> 0 <span class="underline">to</span> <em>result.count</em> - 1) { /* (3) */<br/>    <em>result.sum</em> = <em>result.sum</em> +. <em>Array.unsafe_get</em>(<em>array</em>, <em>i</em>); /* (4), (5) */<br/>  };<br/><br/>  <em>result.mean</em> = <em>result.sum</em> /. <em>float_of_int</em>(<em>result.count</em>); /* (6), (7) */<br/>  <em>result</em><br/>};</pre>
<p>There are quite a few things going on here:</p>
<ol>
<li>We make a record field mutable using the <kbd>mutable</kbd> keyword before the field name. In this case, we make only two out of the three fields mutable, because the count never needs to change for a given array.</li>
<li>We create a new record of the type with the usual literal syntax; we can use <kbd>0.</kbd> as a shorthand for <kbd>0.0</kbd> for float literals, and the <kbd>Array.length</kbd> function returns the length of a Reason array.</li>
<li>We use a <kbd>for</kbd> loop to iterate over the input array whose statistics we want. Reason fully supports imperative programming syntax, such as <kbd>for</kbd> and <kbd>while</kbd> loops; if you're looking to program in any given style, you'll likely be able to do it in Reason.</li>
<li>We sum up the array iteratively, by mutating the <kbd>sum</kbd> field. Mutating a (mutable) record field uses the simple <kbd>recordVal.field = value</kbd> syntax.</li>
<li>We get the element at the given array index using <kbd>Array.unsafe_get</kbd>, which forgoes a bounds check before getting the element. In this example, we don't need a bounds check because we've already made sure we won't go past the end of the array when we started the loop. But if we'd made a mistake, say <kbd>for (i in 0 to result.count) { ... }</kbd>, we'd get a runtime error. So it's good to be very careful with unsafe functions. There's a safe, bounds-checked syntax for array element access: <kbd>array[i]</kbd>.</li>
<li>After we finish iterating through the entire array, we mutate the <kbd>mean</kbd> field to the final mean value.</li>
<li>We can't divide the float <kbd>sum</kbd> by the int <kbd>count</kbd>, so we need to convert the int <kbd>count</kbd> to a float. Note that we don't go the other way round, that is, convert the float <kbd>sum</kbd> to an int, because that would be a lossy conversion!</li>
</ol>
<p>Note how overall we are keeping the mutation inside the bounds of a single function. Although, this mutation safety is somewhat undermined by just returning the <kbd>summaryStats</kbd> value with two mutable fields to the caller. In future mutation examples, we'll show safer usage patterns.</p>
<div class="packt_tip">We're using slightly different operators for float arithmetic: in Reason, integer and float arithmetic are completely separate and they don't mix. The float arithmetic operators are the same as the integer arithmetic ones, except with a "<kbd>.</kbd>" appended to them. The Reason philosophy is very much one of <em>explicit is better than implicit</em>.</div>
<p>To reiterate, for most purposes, immutable records work very well indeed. Mutable record fields come in handy in a limited set of situations, and when we do use them, we need to take extra precautions against accidental mutations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Record patterns</h1>
                </header>
            
            <article>
                
<p>In <a href="ff0971a6-9cf3-4680-8010-47acb7663764.xhtml">Chapter 2</a>, <em>Program with Types and Values</em>, we saw that the general syntax for value bindings is:</p>
<pre><span class="underline">let</span> <em>PATTERN</em> = <em>VALUE</em>;</pre>
<p>This syntax applies to records too, because record literals also act as patterns. In the case of record patterns, we call it <em>destructuring pattern matching,</em> because we bind names by matching against the structure of the record value and pulling out its fields. Here are some examples:</p>
<pre>/* src/Ch04/Ch04_RecordPatterns.re */<br/><span class="underline">open</span> <em>Ch04_RecordLiterals</em>; /* (1) */<br/><br/><span class="underline">let</span> {<em>id</em>: <em>bobId</em>, <em>name</em>: <em>bobName</em>} = <em>bob</em>; /* (2) */<br/><span class="underline">let</span> {<em>id</em>, <em>name</em>: <em>jimName</em>} = <em>jim</em>; /* (3) */<br/><span class="underline">let</span> {<em>id</em>: <em>tomId</em>, <em>name</em>: _} = <em>tom</em>; /* (4) */<br/><span class="underline">let</span> {<em>name</em>, _} = <em>tom</em>; /* (5) */<br/><span class="underline">let</span> {<em>name</em>: <em>tomName</em>} = <em>tom</em>; /* (6) */</pre>
<p>These are the possible variations of record patterns:</p>
<ol>
<li>We globally open the record literals module, to get convenient access to the types and values defined there, without having to qualify every time. I didn't show this in the previous chapter because I deliberately wanted to de-emphasize global openings since they are usually more risky. In controlled cases such as this one though, they are OK.</li>
<li>Record patterns look just like record literals, except what would be the field values are also names (<kbd>bobId</kbd>, <kbd>bobName</kbd>) and these names get bound to the actual values in the record.</li>
<li>We can use a shortcut if we want to bind a name that's the same as the field name: just omit the colon and field value on the right. We can even mix the two styles.</li>
</ol>
<ol start="4">
<li>We can bind only some fields of a record to values, and explicitly not bind the other fields by binding them to the underscore symbol, which means ignore.</li>
<li>We can bind some fields to names and unreservedly ignore the rest using the underscore symbol.</li>
<li>We can bind some fields and ignore the rest by completely omitting them. Reason will infer the type of the pattern using the field names it sees but may get confused if there are multiple record types defined with the same fields.</li>
</ol>
<p>As you can see, the record-pattern syntax is very sophisticated and detailed, built up over time as Reason's base language, OCaml, has been in active industrial use. It will take a little time to get used to all the patterns; start simple and use the more succinct ones as needed.</p>
<p>One last thing to mention about record patterns: they are also irrefutable patterns, just like simple value bindings, such as <kbd>let x = 1;</kbd>. Irrefutability simply means that once a pattern is compiled, there is no way it can fail to match against the value on the right-hand side at runtime. By this metric, record patterns pass because binding them is just a matter of binding their fields to names, and simple name bindings are also irrefutable. But we will see examples of refutable patterns in the next chapter, so keep an eye out for them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Tuple types</h1>
                </header>
            
            <article>
                
<p><em>Tuples</em> are lightweight, structural types. To be precise, they are types made up of other types, joined together within parentheses in a particular order, separated by commas, and without field names. The tuple value syntax is very simple–open parenthesis, comma-separated list of values, close parenthesis. In fact, the value syntax closely mimics the type of the tuples themselves.</p>
<div class="packt_tip"><em>Tuple</em> pronunciation varies depending on who you ask, but I usually pronounce it to rhyme with <em>couple</em>.</div>
<p>Why would we use tuples when we have record types with field names? Sometimes, we don't want to spin up a new type, with a definition, just to hold some values together. Tuples are a low-ceremony way to do that. But the danger of using them over larger portions of a codebase is that they're not self-describing like record types are. Here's an example:</p>
<pre>/* src/Ch04/Ch04_Tuples.re */<br/><br/>/* ID, name */<br/><span class="underline">let</span> <em>bob</em> = (1, "Bob");<br/><br/>/* Name, ID */<br/><span class="underline">let</span> <em>jim</em> = ("Jim", 2);<br/><br/>/*let bobEqualsJim = bob == jim;*/</pre>
<div class="packt_tip">I used just two values to make up the tuples here, but Reason supports tuples of any size.</div>
<p>Notice the last line, which is commented out. If we uncomment that line, we'll get the following error:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch04/Ch04_Tuples.re 4:27-29<br/>  <br/>  2 │ let bob = (1, "Bob");<br/>  3 │ let jim = ("Jim", 2);<br/>  <strong>4</strong> │ let bobEqualsJim = bob == <strong>jim</strong>;<br/>  <br/>  This has type:<br/>    <strong>(string, int)</strong><br/>  But somewhere wanted:<br/>    (int, string)<br/>  <br/>  The incompatible parts:<br/>    <strong>string</strong><br/>    vs<br/>    int</pre>
<div class="packt_infobox">I removed the descriptive comments to fit all the code in the error message.</div>
<p>The type error tells us the types of the two tuples, and we see that they differ purely by the ordering of their component types:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cfc7e712-67ea-4c56-a9b5-cdc85a9fc0aa.png" style="width:26.25em;height:8.33em;"/></div>
<div class="packt_figref CDPAlignCenter CDPAlign">Tuple type mismatch error</div>
<p>In the preceding error, we also see that Reason doesn't bother to check the entire type once it finds even one error in the structure of the tuple types. Nine times out of ten, as soon as we investigate this error message, we'll immediately see the problem<span>–</span>the values are swapped and so are the types<span>–</span>and fix it in one go. The other time, we'll hit another type error after we fix the first one, and fix that. I like to think of type-driven development as really <em>type-error-driven development</em> because hitting type errors is a really good scenario as it means one more potential bug that the production code will never see.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessing tuple values</h1>
                </header>
            
            <article>
                
<p>We can access values inside tuples in two main ways: destructuring pattern matching and accessor functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Destructuring pattern matching</h1>
                </header>
            
            <article>
                
<p>We can bind names to values in tuples using destructuring, similar to records:</p>
<pre><span class="underline">let</span> (<em>bobId</em>, <em>bobName</em>) = <em>bob</em>;<br/><span class="underline">let</span> (<em>jimName</em>, <em>_</em>) = <em>jim</em>;</pre>
<p>The general pattern is <kbd>(field1, field2, ..., field<em>N</em>)</kbd> for <em>N</em>-tuples. As always, the special <kbd>_</kbd> pattern allows us to disregard fields we don't care about. Unlike with records, though, we can't omit them altogether<span>–</span>we must list out all the fields separated by commas. Because tuples are typed according to their structure, omitting a tuple field changes the type we'd be matching against and would be a type error:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch04/Ch04_Tuples.re 12:18-20<br/>  <br/>  10 │ <br/>  11 │ let tom = (3, "Tom", 45); /* ID, name, age */<br/>  <strong>12</strong> │ let (tomId, _) = <strong>tom</strong>;<br/>  <br/>  This has type:<br/>    <strong>(int, string, int)</strong><br/>  But somewhere wanted:<br/>    ('a, 'b)</pre>
<div class="CDPAlignCenter CDPAlign"><img src="assets/abd1f51a-aa22-445d-b837-adf6e61e3b4a.png" style="width:28.17em;height:12.58em;"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref">Tuple destructure type error</div>
<p>We're seeing two interesting types here: <kbd>'a</kbd> and <kbd>'b</kbd> (usually pronounced <em>alpha</em> and <em>beta</em>). We'll delve into what they mean in a future chapter, but right now we can think of them as Reason's way of saying <em>I haven't figured out these types yet</em>. In any case, notice that they don't trigger the actual type error–since Reason doesn't know what they are, it can't assume that they're type mismatches. What really causes the error is the missing third element of the tuple. Effectively, we're trying to match a 3-tuple against a 2-tuple, and this triggers the type error.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Accessor functions</h1>
                </header>
            
            <article>
                
<p>Reason provides two convenience functions, <kbd>fst</kbd> and <kbd>snd</kbd>, to get the first and second positional values from tuples. Here's an example:</p>
<pre><span class="underline">let</span> <em>bobId</em> = <em>fst</em>(<em>bob</em>);<br/><span class="underline">let</span> <em>jimId</em> = <em>snd</em>(<em>jim</em>);</pre>
<p>These functions often come in handy when we're trying to manage lots of tuples and need to tell other functions how to manipulate them. We'll see an example of this kind of controlled behavior in the upcoming chapter on functions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object types</h1>
                </header>
            
            <article>
                
<p><em>Objects</em> are part of OCaml's full-fledged support for <strong>object-oriented programming</strong> (<strong>OOP</strong>). They combine some of the best properties of records and tuples: they are structural so we can create them in an adhoc way (without having to define their types), and we can provide field names (in OOP terminology, methods) that act as descriptive names. Here's an example:</p>
<pre>/* src/Ch04/Ch04_Objects.re */<br/><span class="underline">let</span> <em>bob</em> = {<span class="underline">as</span> _; <span class="underline">pub</span> <em>id</em> = 1; <span class="underline">pub</span> <em>name</em> = "Bob"}; /* (1), (2) */<br/><br/><span class="underline">let</span> <em>greet</em>(<em>person</em>) =<br/>  "Hello, " ++<br/>  <em>person#name</em> ++<br/>  " with ID " ++<br/>  <em>string_of_int</em>(<em>person#id</em>); /* (3) */<br/><br/><span class="underline">let</span> <em>jim</em> = {<br/>  <span class="underline">pub</span> <em>id</em> = 2;<br/>  <span class="underline">pub</span> <em>name</em> = "Jim";<br/>  <span class="underline">pub</span> <em>sayHi</em> = "Hi, my name is " ++ <em>this#name</em> /* (4) */<br/>};<br/><br/><em>Js.log</em>(<em>greet</em>(<em>jim</em>)); /* (5) */<br/>/*Js.log(greet({as _; pub name = "Tom"}));*/</pre>
<p>These show some basic usage of Reason objects:</p>
<ol>
<li>Objects are delimited by brackets and can refer to themselves within the brackets using the <kbd>this</kbd> keyword. However, if we don't use <kbd>this</kbd>, Reason will warn us about an unused value. So we can optionally ignore it using <kbd>as _</kbd> at the start of the object to suppress this warning.</li>
<li>We can create objects in an adhoc way by specifying their public methods (that is, fields) using the <kbd>pub</kbd> keyword. Reason will infer the type of the object from its public methods.</li>
<li>We can access object fields (that is, call their public methods) using the <kbd>#</kbd> notation. Also, in this case, we need to convert the int ID to a string to concatenate it to other strings.</li>
<li>We can call methods on the current object by using <kbd>this</kbd>.</li>
<li>If we load the output JavaScript module, <kbd>src/Ch04/Ch04_Objects.bs.js</kbd>, in NodeJS, Jim's greeting will be printed.</li>
</ol>
<p>If you look at the JavaScript output, you'll see that it's fairly complex. Reason objects are indeed fairly heavyweight values because they can contain a lot of functionality wrapped up inside them. Often, we don't need this level of power because we have other ways of modeling data and behavior. We'll cover more abstraction techniques in further chapters that lessen the need for Reason objects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Inheritance and subtyping</h1>
                </header>
            
            <article>
                
<p>You may be wondering whether Reason objects support inheritance. In fact, they do fully support inheritance with runtime dispatch. We won't delve into inheritance because OOP style is not the focus of this book; you can find ample resources for OOP in the Reason and OCaml documentation (they have equivalent functionality, just with different syntax).</p>
<p>The one thing we need to emphasize is that Reason objects are <em>extensible</em> in a specific way, using a typing technique called <strong>row polymorphism</strong>. This is an advanced topic, and we'll cover different kinds of <em>polymorphism</em> (giving different types of common behaviors) in a future chapter. However, the basic idea is that a <kbd>u</kbd> object that supports a <em>superset</em> of all the methods of a <kbd>t</kbd> object is considered to have a <kbd>U</kbd> type that is a <em>subtype</em> of the <kbd>T</kbd> type of the <kbd>t</kbd> object. So, the <kbd>u</kbd> object can be safely <strong>upcast</strong> to the <kbd>T</kbd> type (that is, we can safely say that <kbd>u</kbd> has the <kbd>T</kbd> type) because that would not be a lossy conversion. In other words, objects support <em>inheritance</em> simply in terms of their method implementations.</p>
<p>Let's look at a concrete example: the <kbd>greet</kbd> function in the preceding example code. We call it with the <kbd>jim</kbd> object. The function calls two methods on its input object: <kbd>id</kbd> and <kbd>name</kbd>. Reason actually infers the input object type as <kbd>{.. id: int, name: string}</kbd>. We call this an open object type. The <em>openness</em> is marked by the two dots right after the opening bracket. It means we can call <kbd>greet</kbd> with subtypes of this type.</p>
<p>In fact, we do just that, on the line marked <kbd>(5)</kbd>: we call <kbd>greet</kbd> with <kbd>jim</kbd>, which is an object with the <kbd>id</kbd>, <kbd>name</kbd>, and <kbd>sayHi</kbd> methods. In other words, it's a subtype of the type that <kbd>greet</kbd> is expecting, and <kbd>greet</kbd> accepts it because its input parameter type allows subtypes. If you change the call to use <kbd>bob</kbd>, it will succeed as well because <kbd>bob</kbd> also conforms to the type that has <kbd>id</kbd> and <kbd>name</kbd> methods of the expected types.</p>
<p>However, if you uncomment the last line, you'll get the following type error:</p>
<pre><strong>(Output from bsb -w)</strong><br/>  We've found a bug for you!<br/>  /Users/yawar/src/learning-tydd-reason/src/Ch04/Ch04_Objects.re 17:14-37<br/>  <br/>  15 │ <br/>  16 │ Js.log(greet(jim)); /* (5) */<br/>  <strong>17</strong> │ Js.log(greet(<strong>{as _; pub name = "Tom"}</strong>));<br/>  <br/>  This has type:<br/>    <strong>{. name : string }</strong><br/>  But somewhere wanted:<br/>    {.. id : int, name : string }<br/>  The first object type has no method id</pre>
<p>This error indicates that we're passing in an input that doesn't meet the minimum requirements for the <kbd>greet</kbd> function. Indeed, intuitively we can see that the input only has a <kbd>name</kbd> method, whereas the <kbd>greet</kbd> function requires both the <kbd>id</kbd> and <kbd>name</kbd> methods.</p>
<p>If you think about it, Reason objects behave very much like JavaScript, Python, or Ruby objects, in the sense that we can treat them as bags of values and methods. The only difference is Reason checks the methods for us at compile time instead of runtime!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JavaScript object types</h1>
                </header>
            
            <article>
                
<p>The first thing to explain about JavaScript objects in Reason is that they're not actually JavaScript objects, they are Reason syntactic constructs that will compile down to JavaScript objects. We use the latter term as a shortcut to refer to the former.</p>
<p>With the realization that Reason objects behave a lot like JavaScript objects, we can understand how Reason's support for JavaScript objects works. This support is baked in, but only if we're targeting JavaScript using BuckleScript. In this project, we are, so here's an example:</p>
<pre>/* src/Ch04/Ch04_JsObjects.re */<br/><span class="underline">let</span> <em>bob</em> = {"id": 1, "name": "Bob"}; /* (1) */<br/><br/><span class="underline">let</span> <em>greet</em>(<em>person</em>) =<br/>  "Hello, " ++<br/>  <em>person##name</em> ++<br/>  " with ID " ++<br/>  <em>string_of_int</em>(<em>person##id</em>); /* (2) */<br/><br/><span class="underline">let</span> <em>jim</em> = {"id": 2, "name": "Jim", "age": 29}; /* (3) */<br/><br/><em>Js.log</em>(<em>greet</em>(<em>jim</em>));</pre>
<p>This example shows some typical JavaScript object usage:</p>
<ol>
<li>Notice how similar the JavaScript object literal is to actual JavaScript. It's explicitly designed this way<span>–</span>enclosed in brackets, field names in double-quotes, values following the colon.</li>
<li>The JavaScript object field access looks almost exactly like the Reason object method calls, only substituting <kbd>#</kbd> with <kbd>##</kbd>.</li>
<li>It's possible to give JavaScript objects actual methods that refer to the <kbd>this</kbd> JavaScript value, but it's a very advanced topic, so we're using an <kbd>age</kbd> field here instead.</li>
</ol>
<p>Notice at the end that, just like with the Reason objects example, we're passing in an object (<kbd>jim</kbd>) that exposes a superset of the fields required by the <kbd>greet</kbd> function. This is why we use this special syntax in Reason to model JavaScript objects: they act like Reason objects in the sense of supporting subtyping with row polymorphism. With this subtyping, we can model many JavaScript idioms with an ease that we just couldn't do with the simpler record types. The preceding use of the <kbd>greet</kbd> function is just one example of that, and, indeed in the JavaScript world, it's common to see objects passed around between functions that use only some subset of their properties.</p>
<p>If you look at the JavaScript output, notice that it is comparatively very simple–it really is just simple JavaScript object manipulation. Thanks to BuckleScript's ability to model JavaScript objects using basic OCaml objects, and Reason's nice object syntax, we get the best of both worlds.</p>
<p>We won't, as a rule, focus on JavaScript object types in this book, but in real-world Reason usage it's very good to understand how they work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we thoroughly explored some of the most important types Reason has to offer: product types, such as records, tuples, objects, and JavaScript objects. By understanding what they are and how and when to use them, we can now model a large portion of our data-processing needs.</p>
<p>In the next chapter, we'll cover sum types, which are the flip side of the coin from product types, allowing us to model alternatives directly in our data.</p>


            </article>

            
        </section>
    </body></html>