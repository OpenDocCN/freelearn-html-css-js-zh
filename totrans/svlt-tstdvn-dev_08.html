<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-101"><a id="_idTextAnchor100"/>8</h1>
<h1 id="_idParaDest-102"><a id="_idTextAnchor101"/>Creating Matchers to Simplify Tests</h1>
<p>This chapter introduces another method for simplifying tests: building custom matchers. Most of the time, it makes sense to stick to the built-in matchers. For instance, the powerful combination of the <code>toEqual</code> matcher with the <code>expect.objectContaining</code> and <code>expect.arrayContaining</code> functions make it easy to build expressive expectations.</p>
<p>But sometimes it makes sense to build a matcher that can scoop up a number of different checks into one single check. This not only shortens tests but can make them more readable, too.</p>
<p>In <a href="B19611_05.xhtml#_idTextAnchor070"><em class="italic">Chapter 5</em></a>, <em class="italic">Validating Form Data</em>, each of the form validation rules was tested by a <code>describe</code> context with four tests, like this:</p>
<pre class="source-code">
describe('when the date of birth is in the wrong format')
  it('does not save the birthday', ...)
  it('returns a 422', ...)
  it('returns a useful message', ...)
  it('returns the other data back including the incorrect
      value', ...)
});</pre>
<p>Since all the validation rules have the same format, it seems like a good candidate for abstracting some shared code. The matcher we’ll create will scoop three of these tests into a custom matcher – the <code>toBeUnprocessableEntity</code> matcher – that can be used to replace them all with a single test:</p>
<pre class="source-code">
it('returns a complete error response', async () =&gt; {
  const result = await performFormAction(
    createBirthday('Hercules', 'unknown')
  );
  expect(result).toBeUnprocessableEntity({
    error:
      'Please provide a date of birth in the YYYY-MM-DD
       format.',
    name: 'Hercules',
    dob: 'unknown'
  });
});</pre>
<p>There’s one final important point: the custom matcher requires its own set of unit tests. That’s so you can be sure that the matcher does the right thing: it passes when it’s meant to pass, and it fails when it’s meant to fail. Just like how you want to be sure that your application code does the right thing.</p>
<p class="callout-heading">Testing test code</p>
<p class="callout">The general rule I have is this: if your code contains any kind of control structure or branching logic, such as <code>if</code> statements or loop constructs, then it needs tests.</p>
<p>This chapter covers the following:</p>
<ul>
<li>Test-driving the pass or failure of an expectation</li>
<li>Providing extra information in failure messages</li>
<li>Implementing the negated matcher</li>
<li>Updating existing tests to use the matcher</li>
</ul>
<p>By the end of the chapter, you’ll understand how to build a matcher and how to write tests for it.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor102"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter08/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter08/Start</a>.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor103"/>Test-driving the pass or failure of an expectation</h1>
<p>In this <a id="_idIndexMarker254"/>section, you’ll build the basic functionality of the <code>toBeUnprocessableEntity</code> matcher, ensuring <a id="_idIndexMarker255"/>that it will correctly pass or fail your test. But first, we’ll look at the structure of a matcher and then the approach to unit testing matchers.</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor104"/>Understanding matcher structure</h2>
<p>Let’s look at the<a id="_idIndexMarker256"/> basic structure of a matcher and how we can test it:</p>
<pre class="source-code">
export function toTestSomething(received, expected) {
  const pass = ...
  const message = () =&gt; "..."
  return {
   pass,
   message
  };
}</pre>
<p>The <code>received</code> parameter value is the object passed to the <code>expect</code> call. The <code>expected</code> value is the value passed to the matcher. So, in the example from the introduction, the result is the received object, and the object containing the <code>error</code>, <code>name</code>, and <code>dob</code> properties is the expected object.</p>
<p>The <code>return</code> value has two important properties: <code>pass</code> and <code>message</code>. The <code>pass</code> boolean should be <code>true</code> if your matcher passes the check, and <code>false</code> otherwise. However, for a negated matcher, the opposite happens: a <code>true</code> value for <code>pass</code> means that the expectation fails.</p>
<p>The <code>message</code> property <a id="_idIndexMarker257"/>is a function that returns a string. This string is what the test runner displays in the event that your test fails. The contents of the string should be enough for the developer to pinpoint what error occurs. The property itself is defined as a function so that it can be lazily evaluated: there’s no point running this code if the test passes.</p>
<p>Unlike other code samples in this book, the matcher function will be defined using the standard <code>function</code> keyword. This means it gains access to the <code>this</code> bound variable.</p>
<p>Vitest primes <code>this</code> with a number of useful utility functions that the matcher can use. We’ll use a couple of them in this chapter: <code>this.equals</code> and <code>this.utils.diff</code>. Another useful property is <code>this.isNot</code>, which is <code>true</code> if your matcher was invoked in its negated form.</p>
<h2 id="_idParaDest-106"><a id="_idTextAnchor105"/>Testing a matcher</h2>
<p>There are a <a id="_idIndexMarker258"/>couple of ways to test a matcher. One way is to test the function return values, as you would with any other function. The difficulty with this approach is that you’ll need to set up the <code>this</code> variable, and that’s not straightforward.</p>
<p>Another approach, and the approach we’ll use this in this chapter, is to use the <code>toThrowError</code> matcher to wrap the matcher under test, like this:</p>
<pre class="source-code">
expect(() =&gt;
  expect(response).toBeUnprocessableEntity()
).toThrowError(
  'Expected 422 status code but got 500'
);</pre>
<p>The <code>toThrowError</code> matcher takes a function as the parameter to expect; this is then executed within a <code>try</code> block. The caught <code>Error</code> object then has its <code>message</code> value checked against the expected value.</p>
<p>For this approach to work, we’ll need to ensure <code>toBeUnprocessableEntity</code> is registered with the<a id="_idIndexMarker259"/> Vitest test runner. We can do that with the <code>beforeAll</code> function that runs once at the very beginning test suite.</p>
<p>With all that knowledge, we’re ready to begin writing the matcher.</p>
<h2 id="_idParaDest-107"><a id="_idTextAnchor106"/>Writing the toBeUnprocessableEntity matcher</h2>
<p>Let’s get started<a id="_idIndexMarker260"/> with the test suite:</p>
<ol>
<li>Create a new file named <code>src/matchers/toBeUnprocessableEntity.test.js</code>, and start with the <a id="_idIndexMarker261"/>following imports. They include all the Vitest imports, which we’ll use in the next step. We’ll also import the <code>fail</code> SvelteKit function, which we’ll use in our tests:<pre class="source-code">
import {
  describe,
  it,
  expect,
  beforeAll
} from 'vitest';
import { fail } from '@sveltejs/kit';
import {
  toBeUnprocessableEntity
} from './toBeUnprocessableEntity.js';</pre></li>
<li>Next, create a new <code>describe</code> block with a <code>beforeAll</code> block at the start. This ensures that the new matcher is registered before our tests run. This only needs to be done once:<pre class="source-code">
describe('toBeUnprocessableEntity', () =&gt; {
  beforeAll(() =&gt; {
    expect.extend({ toBeUnprocessableEntity });
  });
});</pre></li>
<li>Our first <a id="_idIndexMarker262"/>test will cause the expectation <a id="_idIndexMarker263"/>to fail. Add the following test code, which creates a failure reason with a <code>500</code> error code rather than a <code>422</code>, and then use the <code>toThrowError</code> matcher to check that the expectation fails:<pre class="source-code">
it('throws if the status is not 422', () =&gt; {
  const response = fail(500);
  expect(() =&gt;
    expect(response).toBeUnprocessableEntity()
  ).toThrowError();
});</pre></li>
<li>To make that test pass, all we need to do is build a matcher that returns a <code>pass</code> value of <code>false</code>. Create a new file named <code>src/matchers/toBeUnprocessableEntity.js</code> with the following content. As mentioned previously, this uses the <code>function</code> keyword syntax so that we gain access to Vitest’s matcher utility functions that are attached to the <code>this</code> variable:<pre class="source-code">
export function toBeUnprocessableEntity(
  received, expected
) {
  return { pass: false };
}</pre></li>
<li>With the first test passing, add the second. This one checks the opposite – that the matcher does not throw if the response has a <code>422</code> error code:<pre class="source-code">
it('does not throw if the status is 422', () =&gt; {
  const response = fail(422);
  expect(() =&gt;
    expect(response).toBeUnprocessableEntity()
  ).not.toThrowError();
});</pre></li>
<li>To make <a id="_idIndexMarker264"/>that pass, wrap the original <a id="_idIndexMarker265"/>code in a conditional so that it becomes a guard clause, and if that condition isn’t met, then return a <code>pass</code> value of <code>true</code>, as shown:<pre class="source-code">
export function toBeUnprocessableEntity(
  received, expected
) {
  <strong class="bold">if (received.status !== 422) {</strong>
    return { pass: false };
  <strong class="bold">}</strong>
  <strong class="bold">return { pass: true };</strong>
}</pre></li>
<li>If a failure occurs, we want the test runner to display a helpful message about why the expectation failed. To do that, you can pass a string value to the <code>toThrowError</code> matcher that defines the error message. This is what the Vitest test runner will display on the screen. Add the following test:<pre class="source-code">
it('returns a message that includes the actual error code', () =&gt; {
  const response = fail(500);
  expect(() =&gt;
    expect(response).toBeUnprocessableEntity()
  ).toThrowError(
    'Expected 422 status code but got 500'
  );
});</pre></li>
<li>Making <a id="_idIndexMarker266"/>that pass involves sending<a id="_idIndexMarker267"/> back the <code>message</code> property. The value of this property is a function that is only invoked if the test fails. It’s a form of lazy evaluation, allowing the test runner to avoid doing unnecessary work. Update the guard clause to include the <code>message</code> property, as shown:<pre class="source-code">
if (received.status !== 422) {
  return {
    pass: false,
    <strong class="bold">message: () =&gt;</strong>
      <strong class="bold">`Expected 422 status code but got</strong>
<strong class="bold">        ${received.status}`</strong>
  };
}</pre></li>
<li>Next, we also need to check the <code>response</code> body. In our application code, any <code>422</code> result returns an <code>error</code> property along with the original form values. We want the matcher to fail the test if the actual response doesn’t match the expected value:<pre class="source-code">
it('throws error if the provided object does not match', () =&gt; {
  const response = fail(422, { a: 'b' });
  expect(() =&gt;
    expect(response).toBeUnprocessableEntity({
      c: 'd'
    })
  ).toThrowError();
});</pre></li>
<li>To make<a id="_idIndexMarker268"/> that pass, all we need is to add<a id="_idIndexMarker269"/> a very simple second guard clause. If an argument is passed to the matcher, then we fail the test. This implementation isn’t even close to a correct implementation, but it’s enough to make the test pass. We’ll need to triangulate with more tests. But for now, you can start with this code:<pre class="source-code">
export function toBeUnprocessableEntity(
  received,
  expected
) {
  if (received.status !== 422) {
    ...
  }
  <strong class="bold">if (expected) {</strong>
    <strong class="bold">return {</strong>
      <strong class="bold">pass: false</strong>
    <strong class="bold">};</strong>
  <strong class="bold">}</strong>
  ...
}</pre></li>
<li>The next test is very similar, but this time, the two response bodies <em class="italic">do</em> match. This case<a id="_idIndexMarker270"/> shouldn’t cause a failure error:<pre class="source-code">
it('does not throw error if the provided object does match', () =&gt; {
  const response = fail(422, { a: 'b' });
  expect(() =&gt;
    expect(response).toBeUnprocessableEntity({
      a: 'b'
    })
  ).not.toThrowError();
});</pre></li>
<li>Update<a id="_idIndexMarker271"/> the second guard clause to use the <code>this.equals</code> function to perform a deep equality check on the <code>received.data</code> value and the <code>expected</code> parameter. This is enough to make the test pass:<pre class="source-code">
export function toBeUnprocessableEntity(
  received,
  expected
) {
  if (received.status !== 422) {
    ...
  }
  if (<strong class="bold">!this.equals(received.data, expected)</strong>) {
    return {
      pass: false
    };
  }
  ...
};</pre></li>
<li>The final<a id="_idIndexMarker272"/> test is a check that partial <a id="_idIndexMarker273"/>objects match:<pre class="source-code">
it('does not throw error if the provide object is a partial match', () =&gt; {
  const response = fail(422, { a: 'b', c: 'd' });
  expect(() =&gt;
    expect(response).toBeUnprocessableEntity({
      a: 'b'
    })
  ).not.toThrowError();
});</pre></li>
<li>To make that pass, we will use the <code>expect.objectContaining</code> constraint function, which can be passed into the call to <code>this.equals</code>. Start by importing the <code>expect</code> object at the top of the test file:<pre class="source-code">
import { expect } from 'vitest';</pre></li>
<li>Then, update the guard class to wrap the <code>expected</code> value in a call to <code>expect.objectContaining</code>, as shown:<pre class="source-code">
if (
  !this.equals(
    received.data,
    <strong class="bold">expect.objectContaining(expected)</strong>
  )
) {
  ...
}</pre></li>
<li>Finally, if<a id="_idIndexMarker274"/> you run tests now, you’ll find the <a id="_idIndexMarker275"/>very first test fails because the value of <code>expected</code> is <code>undefined</code>, and <code>expect.objectContaining</code> doesn’t like that. To fix the issue, set a default value for the <code>expected</code> argument, like this:<pre class="source-code">
export function toBeUnprocessableEntity(
  received,
  expected<strong class="bold"> = {}</strong>
) {
  ...
}</pre></li>
</ol>
<p>You’ve now seen how to test-drive a matcher function. The next section focuses on improving the error messages that are displayed when a failure occurs.</p>
<h1 id="_idParaDest-108"><a id="_idTextAnchor107"/>Providing extra information in failure messages</h1>
<p>This <a id="_idIndexMarker276"/>section improves the detailed information that is presented to the developer when a test fails. The purpose of this extra information is to help pinpoint the issue with the application code so that the developer isn’t left scratching their head about what went wrong.</p>
<p>Let’s begin:</p>
<ol>
<li>Add the next test, which checks that a basic message is shown when the response bodies do not match:<pre class="source-code">
it('returns a message if the provided object does not match', () =&gt; {
  const response = fail(422, { a: 'b' });
  expect(() =&gt;
    expect(response).toBeUnprocessableEntity({
      c: 'd'
    })
  ).toThrowError(/Response body was not equal/);
});</pre></li>
<li>To make<a id="_idIndexMarker277"/> that pass, add the <code>message</code> property to the second guard clause <code>return</code> value. We’ll expand on this in the next test:<pre class="source-code">
if (!this.equals(...)) {
  return {
    pass: false<strong class="bold">,</strong>
    <strong class="bold">message: () =&gt; 'Response body was not equal'</strong>
  };
}</pre></li>
<li>Vitest includes a built-in object <code>diff</code> helper that will print out a colorful diff. Colors are added into the text string using ANSI color codes, which the Terminal will decipher and use to switch on and off colors. The presence of these codes means that checking the text content within the <code>toThrowError</code> matcher is not straightforward. The following test shows a pragmatic way of checking the same thing in a simpler way, by checking that both the <code>c</code> and <code>a</code> properties appear somewhere in the output:<pre class="source-code">
it('includes a diff if the provided object does not match', () =&gt; {
  const response = fail(422, { a: 'b' });
  expect(() =&gt;
    expect(response).toBeUnprocessableEntity({
      c: 'd'
    })
  ).toThrowError('c:');
  expect(() =&gt;
    expect(response).toBeUnprocessableEntity({
      c: 'd'
    })
  ).toThrowError('a:');
});</pre></li>
<li>To make<a id="_idIndexMarker278"/> that pass, we’ll append the diff onto the end of <code>message</code> that we’re already printing. First, import the <code>EOL</code> constant from Node.js’s <code>os</code> module, which gives us the current platform’s line-ending:<pre class="source-code">
import { EOL } from 'os';</pre></li>
<li>In the matcher code, update the second guard clause’s <code>message</code> property to use the <code>this.utils.diff</code> function to print the diff of the <code>expected</code> and <code>received.data</code> objects:<pre class="source-code">
return {
  pass: false,
  message: () =&gt;
    `Response body was not equal:` + EOL +
    this.utils.diff(expected, received.data)
};</pre></li>
</ol>
<p>That completes <a id="_idIndexMarker279"/>the display of detailed error information. We’ll finish off our matcher in the next section by ensuring it works nicely when used in a negated sense.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor108"/>Implementing the negated matcher</h1>
<p>Negating a matcher<a id="_idIndexMarker280"/> is a tricky business, mainly because negated <a id="_idIndexMarker281"/>matchers can have confusing meanings. For example, what does the following expectation mean?</p>
<pre class="source-code">
expect(result).not.toBeUnprocessableEntity({
  error: 'An unknown ID was provided.'
});</pre>
<p>Presumably, it should fail if the response is <code>422</code> and the response body matches the object provided. But should it also fail if the response is, say, a <code>500</code> or <code>200</code> response? If that was what was expected, wouldn’t it be enough to write this?</p>
<pre class="source-code">
expect(result).not.toBeUnprocessableEntity();</pre>
<p>I find that when writing matchers for domain-specific ideas, negated matchers are best avoided, or at least restricted in their use. However, to show how it’s done, let’s carry on with the matcher.</p>
<p>When we negate the matcher, the Vitest test runner will fail the test if the matcher returns a <code>pass</code> value of <code>true</code>. We have exactly one scenario where this occurs, as all our guard clauses return a <code>pass</code> value of <code>false</code>. So, all these remaining tests simply check the <code>message</code> property in this case.</p>
<p>Let’s start by creating a nested <code>describe</code> block:</p>
<ol>
<li>Add a nested <code>describe</code> block named simply <code>not</code>, and add the first test:<pre class="source-code">
describe('not', () =&gt; {
  it('returns a message if the status is 422 with the
  same body', () =&gt; {
    const response = fail(422, { a: 'b' });
    expect(() =&gt;
      expect(response).not.toBeUnprocessableEntity({
        a: 'b'
      })
    ).toThrowError(
      /Expected non-422 status code but got 422/
    );
  });
});</pre></li>
<li>To make that <a id="_idIndexMarker282"/>pass, head to the bottom of the matcher and add the basic <code>message</code> property value to the last <code>return</code> value in the function, as shown:<pre class="source-code">
return {
  pass: true<strong class="bold">,</strong>
  <strong class="bold">message: () =&gt; 'Expected non-422 status code but got 422'</strong>
};</pre></li>
<li>We can improve upon that by ensuring that the actual <code>response</code> body is returned in the message. Add the next test:<pre class="source-code">
it('includes with the received response body in the message', () =&gt; {
  const response = fail(422, { a: 'b' });
  expect(() =&gt;
    expect(response).not.toBeUnprocessableEntity({
      a: 'b'
    })
  ).toThrowError(/"a": "b"/);
});</pre></li>
<li>To make<a id="_idIndexMarker283"/> that pass, you can make use of the <code>this.utils.stringify</code> utility function, which does all the hard work for you:<pre class="source-code">
return {
  pass: true,
  <strong class="bold">message: () =&gt;</strong>
    <strong class="bold">`Expected non-422 status code but got 422 with</strong>
<strong class="bold">      </strong><strong class="bold">body:` + EOL +</strong>
    <strong class="bold">this.utils.stringify(received.data)</strong>
};</pre></li>
<li>Finally, we need to be careful about the case when no expected object is passed in. When this happens, the actual body isn’t relevant for the developer since, by omitting it from the expectation, they have expressed that they aren’t interested in it:<pre class="source-code">
it('returns a negated message for a non-422 status with no body', () =&gt; {
  const response = fail(422);
  expect(() =&gt;
    expect(response).not.toBeUnprocessableEntity()
  ).toThrowError(
    'Expected non-422 status code but got 422'
  );
});</pre></li>
<li>To make <a id="_idIndexMarker284"/>that pass, add a third guard clause, as shown:<pre class="source-code">
if (!received.data) {
  return {
    pass: true,
    message: () =&gt;
      'Expected non-422 status code but got 422'
  };
}</pre></li>
</ol>
<p>You’ve now test-driven a complete matcher, with useful error messages and support for the negated form. Next, it’s time to make use of it in our existing test suites.</p>
<h1 id="_idParaDest-110"><a id="_idTextAnchor109"/>Updating existing tests to use the matcher</h1>
<p>In this final section, we’ll <a id="_idIndexMarker285"/>use the matcher we’ve<a id="_idIndexMarker286"/> just built to simplify the form validation error test suite.</p>
<p>Let’s get started:</p>
<ol>
<li>First, register the matcher for our test runs by adding an <code>import</code> statement and call to <code>expect.extend</code> in the <code>src/vitest/registerMatchers.js</code> file:<pre class="source-code">
...
import {
  toBeUnprocessableEntity
} from './src/matchers/toBeUnprocessableEntity.js';
...
expect.extend({ toBeUnprocessableEntity });</pre></li>
<li>Then, in <code>src/routes/birthdays/page.server.test.js</code>, find the nested <code>describe</code> block with the description <code>when the name is not provided</code>. It contains<a id="_idIndexMarker287"/> four tests. Leave the<a id="_idIndexMarker288"/> first one in place, and replace the last three tests with the following test:<pre class="source-code">
describe('when the name is not provided', () =&gt; {
  ...
  it('does not save the birthday', ...);
  <strong class="bold">it('returns a complete error response', () =&gt; {</strong>
  <strong class="bold">  expect(result).toBeUnprocessableEntity({</strong>
  <strong class="bold">    error: 'Please provide a name.',</strong>
  <strong class="bold">    </strong><strong class="bold">dob: '2009-02-02'</strong>
  <strong class="bold">  });</strong>
  });
});</pre></li>
<li>Then, do the same for the nested <code>describe</code> block with the description <code>when the date of birth is in the wrong format</code>, replacing the last three tests with <a id="_idIndexMarker289"/>the test shown:<pre class="source-code">
describe('when the date of birth is in the wrong format', () =&gt; {
  ...
  it('does not save the birthday', ...);
  <strong class="bold">it('returns a complete error response', () =&gt; {</strong>
  <strong class="bold">  expect(result).toBeUnprocessableEntity({</strong>
  <strong class="bold">    error:</strong>
  <strong class="bold">      </strong><strong class="bold">'Please provide a date of birth in the YYYY-</strong>
<strong class="bold">          MM-DD format.',</strong>
  <strong class="bold">    name: 'Hercules',</strong>
  <strong class="bold">    dob: 'unknown'</strong>
    });
  });
});</pre></li>
<li>Do<a id="_idIndexMarker290"/> exactly the same thing with the <code>when the id is </code><code>unknown</code> context:<pre class="source-code">
describe('when the id is unknown', () =&gt; {
  ...
  it('does not save the birthday', ...);
  <strong class="bold">it('returns a complete error message', () =&gt; {</strong>
  <strong class="bold">  expect(result).toBeUnprocessableEntity({</strong>
  <strong class="bold">    </strong><strong class="bold">error: 'An unknown ID was provided.'</strong>
  <strong class="bold">  });</strong>
  <strong class="bold">});</strong>
});</pre></li>
<li>Next, there <a id="_idIndexMarker291"/>are a couple of tests <a id="_idIndexMarker292"/>specifically for ensuring <code>id</code> is returned. Update the expectations for them both, as shown:<pre class="source-code">
it('returns the id when an empty name is provided', async () =&gt; {
  ...
  <strong class="bold">expect(result).toBeUnprocessableEntity({</strong>
    <strong class="bold">id: storedId()</strong>
  <strong class="bold">});</strong>
});
...
it('returns the id when an empty date of birth is provided', async () =&gt; {
  ...
  <strong class="bold">expect(result).toBeUnprocessableEntity({</strong>
    <strong class="bold">id: storedId()</strong>
  <strong class="bold">});</strong>
});</pre></li>
</ol>
<p>And that completes the changes. Make sure to run all tests and check that everything is passing. Take a step back <a id="_idIndexMarker293"/>and look at how much <a id="_idIndexMarker294"/>clearer and simpler your tests have become.</p>
<h1 id="_idParaDest-111"><a id="_idTextAnchor110"/>Summary</h1>
<p>This chapter has shown you how to build a custom matcher to simplify your test expectations. It also discussed the importance of test-driving matcher code.</p>
<p>Your unit test files act as a specification of your software. It’s imperative that these files are clear and concise so that the specifications are clear. Sometimes, writing custom matchers can help you achieve that clarity.</p>
<p>Why do we test-drive matcher implementations? Because almost all matchers have branching logic – sometimes they’ll pass and sometimes they’ll fail – and you want to be sure that the right branches are used at the right times.</p>
<p>In the next chapter, we’ll switch back to refactoring our application code, with the intention of improving its testability.</p>
</div>
</div></body></html>