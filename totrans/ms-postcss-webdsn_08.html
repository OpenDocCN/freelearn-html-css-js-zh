<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Creating PostCSS Plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Creating PostCSS Plugins</h1></div></div></div><p>Plugins, plugins…we can't escape them; by now, you will have seen that they are an essential part of developing within PostCSS. Its modular nature is built entirely around plugins, and is how we can streamline our processing through selective use of these plugins.</p><p>In this chapter, we'll cover the anatomy of a PostCSS plugin and take a look at some pre-built examples, before embarking on the construction of a simple plugin that we can then test and submit for inclusion in the PostCSS system.</p><p>We will cover a number of topics throughout this chapter, which will include the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Discovering how plugins can be used to extend PostCSS</li><li class="listitem" style="list-style-type: disc">Examining the architecture of a standard plugin</li><li class="listitem" style="list-style-type: disc">Creating a PostCSS plugin using the plugin boilerplate</li><li class="listitem" style="list-style-type: disc">Building some example plugins</li><li class="listitem" style="list-style-type: disc">Testing and submitting your plugin for inclusion in the PostCSS plugin library</li><li class="listitem" style="list-style-type: disc">Exploring some examples of existing plugins available for PostCSS</li></ul></div><p>Let's make a start…!</p><div class="section" title="Extending PostCSS with plugins"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec66"/>Extending PostCSS with plugins</h1></div></div></div><p>A question, how many<a id="id398" class="indexterm"/> times have you worked with plugins that by themselves don't actually achieve anything?</p><p>I'll bet the answer <a id="id399" class="indexterm"/>won't be a high figure—and no, I'm not including those plugins that claim to perform an operation, yet don't seem to work for some reason! The power of PostCSS lies not in the core system, but the plugins that we use to manipulate our CSS style sheets.</p><p>At the time of writing, there are more than 200 plugins available for use within PostCSS—these range from extending PostCSS (such as <code class="literal">postcss-nested</code> or <code class="literal">postcss-mixins</code>), to manipulating colors (such as <code class="literal">postcss-color-hcl</code> or <code class="literal">postcss-rgba-hex</code>), to plugins that cater for future CSS syntax (such as adding <code class="literal">@extend</code> support).</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note40"/>Note</h3><p>The full list is <a id="id400" class="indexterm"/>available at <a class="ulink" href="https://github.com/postcss/postcss/blob/master/docs/plugins.md">https://github.com/postcss/postcss/blob/master/docs/plugins.md</a>, or via the searchable catalogue hosted at <a class="ulink" href="http://www.postcss.parts">http://www.postcss.parts</a>.</p></div></div><p>To date, we've used a fair number of plugins throughout our examples—we've configured them for use, but<a id="id401" class="indexterm"/> there is still an element of <span class="emphasis"><em>black box</em></span> about them, where we don't always know how the insides work. It's time to change that. As a<a id="id402" class="indexterm"/> first step, let's briefly meet the toolset that helps make plugins possible, the PostCSS API.</p><p>Any plugin created for PostCSS will have been constructed using the API. The key to this API will be the <code class="literal">Node</code> and <code class="literal">Container</code> methods, which can be used to manipulate content once the <code class="literal">postcss</code> object has been initialized in the plugin. We will explore these in more detail throughout this chapter, but before doing so, it makes sense to explore the architecture of a PostCSS plugin first, so let's have a look and see what makes one tick.</p></div></div>
<div class="section" title="Dissecting the architecture of a standard plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec67"/>Dissecting the architecture of a standard plugin</h1></div></div></div><p>Creating a<a id="id403" class="indexterm"/> PostCSS plugin is a straightforward process—the beauty of PostCSS is that we as developers are free to design and construct <a id="id404" class="indexterm"/>any plugin we desire; it does mean that not every plugin will be of the same quality as others!</p><p>This aside, the <a id="id405" class="indexterm"/>recommended way to construct any <a id="id406" class="indexterm"/>PostCSS plugin is to use the boilerplate code, which is <a id="id407" class="indexterm"/>available from <a class="ulink" href="https://github.com/postcss/postcss-plugin-boilerplate">https://github.com/postcss/postcss-plugin-boilerplate</a>; we can see an example of it in this screenshot:</p><div class="mediaobject"><img src="graphics/BO5194_08_01.jpg" alt="Dissecting the architecture of a standard plugin"/></div><p>If we explore<a id="id408" class="indexterm"/> the source code for any PostCSS plugin hosted in GitHub, there will be a host of different files present; not all of them will be the same for each different plugin!</p><p>Nonetheless, if we delve<a id="id409" class="indexterm"/> in deeper, there are some files we would expect to see as part of the architecture of any plugin; they are as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">index.js</code>: This contains the main functionality for each plugin</li><li class="listitem" style="list-style-type: disc"><code class="literal">package.json</code>: This is<a id="id410" class="indexterm"/> used to configure and manage locally installed NPM packages</li><li class="listitem" style="list-style-type: disc"><code class="literal">test.js</code>: This <a id="id411" class="indexterm"/>contains the tests required to ensure the plugin works as expected</li></ul></div><p>Let's explore these in more detail, beginning with <code class="literal">index.js</code>.</p><div class="section" title="Exploring index.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec73"/>Exploring index.js</h2></div></div></div><p>The crux of any plugin centers <a id="id412" class="indexterm"/>around <code class="literal">index.js</code>—we start with a reference to PostCSS (as a dependency for our plugin); this is followed by the exports function, which exposes functionality to anyone using the plugin:</p><div class="informalexample"><pre class="programlisting">var postcss = require('postcss');
 
module.exports = postcss.plugin('myplugin', function(options) {

  return function (css) {
    options = options || {};
         
    // Processing code will be added here
  }
});</pre></div></div><div class="section" title="Discovering package.json"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec74"/>Discovering package.json</h2></div></div></div><p>Next up, we have<a id="id413" class="indexterm"/> <code class="literal">package.json</code>—this is used to configure and manage locally installed Node packages; given that PostCSS is based on Node.js, we will see something akin to this for any plugin installed as part of the PostCSS ecosystem:</p><div class="informalexample"><pre class="programlisting">{
  "name": "PLUGIN_NAME",
  "version": "0.0.0",
  "description": "PostCSS plugin PLUGIN_DESC",
  "keywords": [
    "postcss",
    "css",
    "postcss-plugin"KEYWORDS
  ],</pre></div><p>The first section contains some basic details about the plugin name, description, and version. If we look through the <code class="literal">package.json</code> file, it's not difficult to spot a number of keywords in capitals—at first glance, one might be mistaken for thinking that it renders as invalid JSON.</p><p>There is a reason for this—one of the steps for using this boilerplate plugin is to run a script that will replace these keywords with information; the script will transform this into valid JSON. This is something we will cover in more detail later, in the <span class="emphasis"><em>Creating a transition plugin</em></span> section. For now, assume that this file will be converted to valid JSON during the build process.</p><p>Moving on, we then store the name of the author, the plugin's license, and where we can get the source or file bugs relating to the plugin:</p><div class="informalexample"><pre class="programlisting">  "author": "AUTHOR_NAME &lt;AUTHOR_EMAIL&gt;",
  "license": "MIT",
  "repository": "GITHUB_NAME/PLUGIN_NAME",
  "bugs": {
    "url": "https://github.com/GITHUB_NAME/PLUGIN_NAME/issues"
},
"homepage": "https://github.com/GITHUB_NAME/PLUGIN_NAME",</pre></div><p>This section is the most critical—the dependencies section stores details of any dependencies, when used in production; the <code class="literal">devDependencies</code> section takes care of dependencies when working in a development environment:</p><div class="informalexample"><pre class="programlisting">  "dependencies": {
    "postcss": "^5.0.10"
  },
  "devDependencies": {
    "ava": "^0.7.0",
    "eslint": "^1.10.2"
  },
  "scripts": {
    "test": "ava &amp;&amp; eslint *.js"
  }
}</pre></div><p>A key guideline<a id="id414" class="indexterm"/> given by the PostCSS team is that every plugin should be tested—this should always be a given, to help ensure we are creating something that is solid and not likely to cause issues for our users. A part of the boilerplate code contains a suitable test script for this purpose, so let's take a quick look at it now.</p></div><div class="section" title="Exploring test.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec75"/>Exploring test.js</h2></div></div></div><p>The third element<a id="id415" class="indexterm"/> that is key to any plugin is the test—this should be stored in <code class="literal">test.js</code>, and will look similar to this:</p><div class="informalexample"><pre class="programlisting">import postcss from 'postcss';
import test from 'ava';

import plugin from './';

function run(t, input, output, opts = { }) {
  return postcss([ plugin(opts) ]).process(input)
    .then( result =&gt; {
      t.same(result.css, output);
      t.same(result.warnings().length, 0);
    });
}

/* Write tests here
test('does something', t =&gt; {
  return run(t, 'a{ }', 'a{ }', { });
});
*/</pre></div><p>We will cover this part in more detail later in this chapter, in the <span class="emphasis"><em>Testing and submitting a plugin</em></span> section—for now, let's get stuck in to creating a PostCSS-based plugin. We'll start with a quick look at the API, before diving into creating a plugin that applies a specific font stack based on a chosen font, and adds updated declarations if one of those fonts needs to be imported into our site.</p><p>With the<a id="id416" class="indexterm"/> framework in place, we can then build up our plugin using the PostCSS API; this contains a number of classes, modules, and methods that we can use. The key function in the API is of course <code class="literal">postcss</code>—this is the main entry point for PostCSS and is required for all plugins:</p><div class="informalexample"><pre class="programlisting">var postcss = require('postcss');</pre></div><p>Let's take a quick look through what else is available in the API, beginning with the Vendor module.</p></div><div class="section" title="The Vendor module"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec76"/>The Vendor module</h2></div></div></div><p>This module <a id="id417" class="indexterm"/>contains helpers for working with vendor prefixes—we can initiate it using this object:</p><div class="informalexample"><pre class="programlisting">var vendor = postcss.vendor;</pre></div><p>The module contains<a id="id418" class="indexterm"/> two methods, as shown in the table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Module</p>
</th><th style="text-align: left" valign="bottom">
<p>Format</p>
</th><th style="text-align: left" valign="bottom">
<p>Value returned</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">vendor.prefix</code>
</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>The vendor prefix extracted from an input string:</p>
<p>
</p><div class="informalexample"><pre class="programlisting">// prefix extracted = '-webkit-'
var vp = postcss.vendor;
vp.prefix('-webkit-clip-path')</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">vendor.unprefixed</code>
</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>The<a id="id419" class="indexterm"/> input string stripped of its vendor prefix:</p>
<p>
</p><div class="informalexample"><pre class="programlisting">// value extracted = 'tab-size'
var vp = postcss.vendor;
vp.unprefixed('-moz-tab-size')</pre></div><p>
</p>
</td></tr></tbody></table></div></div><div class="section" title="The List module"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec77"/>The List module</h2></div></div></div><p>This module contains helpers to safely split lists of CSS values, whilst preserving parentheses and<a id="id420" class="indexterm"/> quotes. We can initiate it using this object:</p><div class="informalexample"><pre class="programlisting">var list = postcss.list;</pre></div><p>The module contains two methods, as shown in the table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Module</p>
</th><th style="text-align: left" valign="bottom">
<p>Format </p>
</th><th style="text-align: left" valign="bottom">
<p>Designed to split</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">list.space</code>
</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>Space-separated values (such as those for background, border-radius, and <a id="id421" class="indexterm"/>other shorthand properties):</p>
<p>
</p><div class="informalexample"><pre class="programlisting">// expected result:
// ['1px', 'calc(10% + 1px)']
var ls = postcss.list;
ls.space('1px calc(10% + 1px)')</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">list.comma</code>
</p>
</td><td style="text-align: left" valign="top">
<p>String</p>
</td><td style="text-align: left" valign="top">
<p>Comma-separated values (such as those for transition-* and background<a id="id422" class="indexterm"/> properties):</p>
<p>
</p><div class="informalexample"><pre class="programlisting">// Expected result:
// ['black', 'linear-gradient(white, black)']
var ls = postcss.list;
ls.comma('black, linear-gradient(white, black)')</pre></div><p>
</p>
</td></tr></tbody></table></div></div><div class="section" title="Classes available in the API"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec78"/>Classes available in the API</h2></div></div></div><p>Once the PostCSS object has been defined as a dependency in our plugin, we can begin to manipulate its <a id="id423" class="indexterm"/>contents—for this purpose, there are a number of classes available to assist, as shown in this table:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Name of class</p>
</th><th style="text-align: left" valign="bottom">
<p>Role within plugin</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Processor</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Creates a Processor instance, initializes any plugins, then uses this instance on <a id="id424" class="indexterm"/>CSS files as specified in the configuration.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">LazyResult</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Acts as a <a id="id425" class="indexterm"/>promise proxy for the result of PostCSS transformations.</p>
<p>Promises are <a id="id426" class="indexterm"/>a key part of working with Node.js—if you are not familiar with this concept, take a look at <a class="ulink" href="https://www.promisejs.org/">https://www.promisejs.org/</a> for a detailed explanation.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Result</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Provides the<a id="id427" class="indexterm"/> result of any PostCSS transformations.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Warning</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows a <a id="id428" class="indexterm"/>user to manage a warning within the plugin.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">CssSyntaxError</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Allows a <a id="id429" class="indexterm"/>user to retrieve any errors for broken CSS, generated by the CSS parser.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Input</code>
</p>
</td><td style="text-align: left" valign="top">
<p>Represents<a id="id430" class="indexterm"/> the source CSS being manipulated by PostCSS plugins.</p>
</td></tr></tbody></table></div></div><div class="section" title="Nodes available in the API"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec79"/>Nodes available in the API</h2></div></div></div><p>Of course, we <a id="id431" class="indexterm"/>cannot manipulate content from within a PostCSS plugin without having access to each CSS node—the API contains a group of useful nodes to help with parsing and manipulating content:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Node</p>
</th><th style="text-align: left" valign="bottom">
<p>Represents</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Root</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A CSS file <a id="id432" class="indexterm"/>and its parsed nodes:</p>
<p>
</p><div class="informalexample"><pre class="programlisting">var root = postcss.parse('a{color: darkred}');
root.type         //=&gt; 'root'
root.nodes.length //=&gt; 1</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">AtRule</code>
</p>
</td><td style="text-align: left" valign="top">
<p>An <code class="literal">@</code>-based<a id="id433" class="indexterm"/> rule in CSS, such as <code class="literal">@media print {…}</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Rule</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A CSS<a id="id434" class="indexterm"/> rule, containing a selector and declaration block:</p>
<p>
</p><div class="informalexample"><pre class="programlisting">var root = postcss.parse('h1{}');
var rule = root.first;
rule.type       //=&gt; 'rule'
rule.toString() //=&gt; 'h1{}'</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Declaration</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A CSS<a id="id435" class="indexterm"/> declaration:</p>
<p>
</p><div class="informalexample"><pre class="programlisting">var root = postcss.parse('a{color: darkred}');
var decl = root.first.first;
decl.type       //=&gt; 'decl'
decl.toString() //=&gt; 'color: darkred'</pre></div><p>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">Comment</code>
</p>
</td><td style="text-align: left" valign="top">
<p>A comment <a id="id436" class="indexterm"/>between declarations or statements (in both rules and <code class="literal">@</code>-rules):</p>
<p>
</p><div class="informalexample"><pre class="programlisting">var root = postcss.parse('a { color: /* inner */ darkred; /* outer */ }');
var decl    = root.first.first;
var comment = root.first.last;

comment.type //=&gt; 'comment'
decl.between //=&gt; ': /* inner */'</pre></div><p>
</p>
</td></tr></tbody></table></div></div><div class="section" title="Methods available in the API"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec80"/>Methods available in the API</h2></div></div></div><p>A key role of a plugin is to <a id="id437" class="indexterm"/>navigate through each node to help determine if it should perform some action; the API contains a number of methods to assist with parsing nodes:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Method group</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Nodes</p>
</td><td style="text-align: left" valign="top">
<p>These <a id="id438" class="indexterm"/>methods are for working with each CSS node—this includes methods such as the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">node.type</code>: returns a string representing the node type</li><li class="listitem" style="list-style-type: disc"><code class="literal">node.parent</code>: returns the parent node as a string</li><li class="listitem" style="list-style-type: disc"><code class="literal">node.next()</code> or <code class="literal">node.prev()</code>: returns the next or previous child of a node's parent.</li></ul></div>
<p>More details<a id="id439" class="indexterm"/> are available at <a class="ulink" href="https://github.com/postcss/postcss/blob/master/docs/api.md#nodes-common-methods">https://github.com/postcss/postcss/blob/master/docs/api.md#nodes-common-methods</a>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Containers</p>
</td><td style="text-align: left" valign="top">
<p>These<a id="id440" class="indexterm"/> methods contain methods for working with children in a container node—this includes<a id="id441" class="indexterm"/> methods such as the following:</p>
<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">container.nodes</code>: returns an array containing the container's children.</li><li class="listitem" style="list-style-type: disc"><code class="literal">container.first</code>: return the container's first child node.</li><li class="listitem" style="list-style-type: disc"><code class="literal">container.last</code>: return the container's last child node.</li></ul></div>
<p>More <a id="id442" class="indexterm"/>details are available at <a class="ulink" href="https://github.com/postcss/postcss/blob/master/docs/api.md#containers-common-methods">https://github.com/postcss/postcss/blob/master/docs/api.md#containers-common-methods</a>
</p>
</td></tr></tbody></table></div><p>The main site contains details and examples of all of the methods and classes available within the API—it is worth taking time to familiarize yourself with the options available.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip17"/>Tip</h3><p>Details for each<a id="id443" class="indexterm"/> method or class are available on the PostCSS API page at <a class="ulink" href="https://github.com/postcss/postcss/blob/master/docs/api.md">https://github.com/postcss/postcss/blob/master/docs/api.md</a>
</p></div></div><p>Okay, enough with theory: on we go! Let's change tack and put some of what we've just learnt to good use by constructing a couple of plugins for PostCSS. These will use a real mix of the API commands that we've briefly looked at earlier in this chapter; our first demo centers around a shorthand plugin for creating transition statements within CSS rules in a style sheet, so let's get stuck in and see how it works.</p></div></div>
<div class="section" title="Creating an transition plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec68"/>Creating an transition plugin</h1></div></div></div><p>The idea for this <a id="id444" class="indexterm"/>plugin is not new; it's loosely based on the <code class="literal">postcss-transform-shortcut</code> plugin by Jonathan Neal, available from <a class="ulink" href="https://github.com/jonathantneal/postcss-transform-shortcut">https://github.com/jonathantneal/postcss-transform-shortcut</a>. The concept is not necessarily<a id="id445" class="indexterm"/> a shorter means to create transition statements, but it makes it easier by allowing authors to specify values independently. These are then automatically inserted into the correct order within the transition declaration.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note41"/>Note</h3><p>The source <a id="id446" class="indexterm"/>code for this plugin is also available on GitHub, at <a class="ulink" href="https://github.com/alexlibby/postcss-transition-shortcut">https://github.com/alexlibby/postcss-transition-shortcut</a>; the NPM package<a id="id447" class="indexterm"/> is also available at <a class="ulink" href="https://www.npmjs.com/package/postcss-transition-shortcut">https://www.npmjs.com/package/postcss-transition-shortcut</a>.</p></div></div><p>Let's dive in and take a look at how it is put together, in more detail:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by<a id="id448" class="indexterm"/> installing Git—this is required for installing the plugin boilerplate. To do this, browse to <a class="ulink" href="https://git-scm.com/book/en/v2/Getting-Started-Installing-Git">https://git-scm.com/book/en/v2/Getting-Started-Installing-Git</a>, and follow the instructions for your platform.</li><li class="listitem">Open a <a id="id449" class="indexterm"/>Node.js command prompt, then change the working folder to our project directory.</li><li class="listitem">In the prompt, enter this command then press <span class="emphasis"><em>Enter</em></span>:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>git clone https://github.com/postcss/postcss-plugin-boilerplate.git</strong></span>
</pre></div></li><li class="listitem">Git will clone the <code class="literal">postcss-plugin-boilerplate</code> repository to our project area, as shown in this screenshot:<div class="mediaobject"><img src="graphics/BO5194_08_02.jpg" alt="Creating an transition plugin"/></div></li><li class="listitem">The plugin boilerplate includes a script to automatically generate the skeleton for our plugin—go ahead and run this command in the prompt:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>node ./postcss-plugin-boilerplate/start</strong></span>
</pre></div></li><li class="listitem">It will show a series of prompts for various bits of information. Go ahead and fill in appropriate responses, similar to that shown in this screenshot. Note that it is not obligatory to have a GitHub account, as the information is simply added to the <code class="literal">package.json</code> file; if you spend any time developing plugins in the future, then it is recommended that you go ahead and create one:<div class="mediaobject"><img src="graphics/BO5194_08_03.jpg" alt="Creating an transition plugin"/></div></li><li class="listitem">Once the<a id="id450" class="indexterm"/> plugin folder has been created, we can remove the <code class="literal">postcss-plugin-boilerplate</code> folder from the project root folder, as this is no longer needed.</li><li class="listitem">If all is well, we should see something akin to this screenshot, when browsing the contents of our plugin folder:<div class="mediaobject"><img src="graphics/BO5194_08_04.jpg" alt="Creating an transition plugin"/></div></li><li class="listitem">At this point, we<a id="id451" class="indexterm"/> can now add the code for our plugin into <code class="literal">index.js</code>—to do this, open up a copy of the file from within the <code class="literal">postcss-transition-shortcut</code> plugin from within our project area, and alter the code as shown:<div class="informalexample"><pre class="programlisting">var postcss = require('postcss');

module.exports = postcss.plugin('postcss-transition-shortcut', function (opts) {
  opts = opts || {};

  var defaults = {
    property: 'all',
    duration: '1s',
    timing: 'ease-in-out',
    delay: '1s'
  };

  return function (css, result) {
    css.walkRules(function (rule) {
      var transitionRule;
      var transitionValues = [];
      var index = -1, node;
      var attributes = /^ (property|duration|timing|delay)$/;

      while (node = rule.nodes[++index]) {
         if (attributes.test(node.prop)) {
          transitionRule = transitionRule || node.cloneBefore({ prop: 'transition' });
          var transValues = postcss.list.space(node.value);
          transitionValues.push(transValues.join(','));
          node.remove();
          --index;
        }
      }
      transitionRule.value =
        transitionValues.join(' '); 
      });
  };
});</pre></div></li></ol></div><p>At this stage we<a id="id452" class="indexterm"/> will have a working plugin—the proof, though (to quote an old English saying), is in the pudding: does the plugin work as we expect? Well, there's no better way to find out than by trying it out, so let's set up a quick demo to confirm it works as expected. Before we do so, though, there is one important point I need to make, which concerns the generation of PostCSS plugins.</p><div class="section" title="Creating a test for our plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec81"/>Creating a test for our plugin</h2></div></div></div><p>The sharp-eyed<a id="id453" class="indexterm"/> amongst you will notice though that if we don't specify one of the four values for our transition plugin, then the code at present won't use the default; hopefully an update will come in a future version of the plugin.</p><p>This aside, the process for testing our <a id="id454" class="indexterm"/>plugin uses the AVA test runner, available from <a class="ulink" href="https://github.com/sindresorhus/ava">https://github.com/sindresorhus/ava</a>. The framework for the test is already created within the plugin boilerplate, which leaves us to add the test code to test.js file. Let's take a peek at what's required:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by<a id="id455" class="indexterm"/> installing the AVA test runner—for this, fire up a Node.js command prompt, and change the working folder to the root of our plugin folder.</li><li class="listitem">In the prompt, enter these commands, pressing <span class="emphasis"><em>Enter</em></span> after each—the first installs AVA, with the second adding it to our <code class="literal">package.json</code> file:<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install --global ava</strong></span>
<span class="strong"><strong>ava --init</strong></span>
</pre></div></li><li class="listitem">Open a new file in your text editor of choice—go ahead and add the following highlighted lines to <code class="literal">test.js</code>, within the plugin folder we created in the previous exercise:<div class="informalexample"><pre class="programlisting">      t.same(result.warnings().length, 0);
    }); 
} 


<span class="strong"><strong>test('transitionShtct', t =&gt; { </strong></span>
<span class="strong"><strong>  return run( t, 'div { property: all; duration: 1s; timing: ease-in-out; delay: 1s; }', 'div { transition: all 1s ease-in-out 1s; }', { }); </strong></span>
<span class="strong"><strong>});</strong></span>
</pre></div></li><li class="listitem">Next, fire up a Node.js command prompt, then change the working directory to our plugin project folder.</li><li class="listitem">At the prompt, enter <code class="literal">npm test</code> and press <span class="emphasis"><em>Enter</em></span>.</li><li class="listitem">AVA will perform the test, which is then linted using ESLint. If all is well, we should see the results shown in this screenshot—assuming nothing was amiss with the test:<div class="mediaobject"><img src="graphics/BO5194_08_05.jpg" alt="Creating a test for our plugin"/></div></li></ol></div><p>All good so far, right—at this point, we're OK to create a simple demo to prove plugin works…or are we? Well, the test shows a pass, so the code should be OK. But further down there are a ton of errors displayed, similar to this screenshot—what gives?</p><div class="mediaobject"><img src="graphics/BO5194_08_06.jpg" alt="Creating a test for our plugin"/></div><p>The test has <a id="id456" class="indexterm"/>passed, yet the tests would seem to indicate otherwise; a look further down reveals yet more errors:</p><div class="mediaobject"><img src="graphics/BO5194_08_07.jpg" alt="Creating a test for our plugin"/></div><p>This raises some important points about testing, so let's cover these before continuing with our demo.</p></div><div class="section" title="Correcting the errors"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec82"/>Correcting the errors</h2></div></div></div><p>The main error, or <code class="literal">Exported linebreaks to be 'LF'…</code>, is a simple one to fix—it's being caused by <a id="id457" class="indexterm"/>Sublime Text being set to use Windows as the default line endings setting. Assuming we're using Sublime Text, let's go ahead and deal with that error:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Open up Sublime Text, then open <code class="literal">index.js</code> from our plugin folder.</li><li class="listitem">Click on View | Line Endings.</li><li class="listitem">Change the selected option to <span class="strong"><strong>Unix</strong></span>, and save the file.</li><li class="listitem">Repeat steps 1 to 3 for <code class="literal">test.js</code>—once done, close both files.</li></ol></div><p>If we re-run the test, we should see a significant drop in listed errors—there will be some left for us to fix in <code class="literal">index.js</code> and <code class="literal">test.js</code>, similar to this screenshot:</p><div class="mediaobject"><img src="graphics/BO5194_08_08.jpg" alt="Correcting the errors"/></div><p>Most of the <a id="id458" class="indexterm"/>errors are self-explanatory—the two that are less obvious are <code class="literal">Expected indentation of X spaces…</code> and <code class="literal">Line X exceeds the maximum line length…</code>. We can fix the first by replacing all instances of tabs with four individual spaces per tab. The second error is simple to fix—simply split the line of code into two lines.</p><p>We need to work through all of the remaining errors, as far as possible—these won't entirely be the same for your version of the plugin, but some will be similar.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip18"/>Tip</h3><p>If you come <a id="id459" class="indexterm"/>across any errors where you want to understand the reason behind the error, take a look at <a class="ulink" href="https://jslinterrors.com/">https://jslinterrors.com/</a>—it's a great source for defining what an error means!</p></div></div><p>Assuming we've cleared most of the errors, we should be left with just one:</p><div class="mediaobject"><img src="graphics/BO5194_08_09.jpg" alt="Correcting the errors"/></div><p>Is this an error we should fix, and therefore can clear from the report? The simple answer is that it <a id="id460" class="indexterm"/>depends—it highlights an important point about using linting for code, so let's take a moment to cover this in more detail.</p></div><div class="section" title="Clearing the final error"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec83"/>Clearing the final error</h2></div></div></div><p>The last error <a id="id461" class="indexterm"/>shown in the report presents some challenges—the code is valid, yet ESLint flags the error. The reason for this is that it has found an assignment expression within a while statement initializer; it is treated as a possible mistake in the code and <span class="emphasis"><em>may</em></span> have unintended effects on the code.</p><p>In some respects, it can be treated as a warning, and not necessarily as an error. Prior to July 2013 we could have configured our test to ignore this, but changes made to ESLint since that date mean that this error cannot be cleared without reworking the code.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note42"/>Note</h3><p>If you<a id="id462" class="indexterm"/> would like to understand more about the causes of this error, then please refer to <a class="ulink" href="http://jslinterrors.com/unexpected-assignment-expression/">http://jslinterrors.com/unexpected-assignment-expression/</a>.</p></div></div><p>In our instance, the code is valid and will not cause any errors—it leaves us with several options as to what we can do going forward:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We can simply ignore the error and carry on—it's not great that the test fails, but in this case it won't cause any harm to our code</li><li class="listitem" style="list-style-type: disc">We can switch off the test for it, so that while this condition is not tested, the test will at least show a 100% pass</li><li class="listitem" style="list-style-type: disc">We can look to alter the code to design out the error/warning—this is the ideal solution, but it may be a longer term route, depending on the nature of the changes we need to make</li></ul></div><p>For now, we're going to switch off the test for this error—we can do this by editing the <code class="literal">.eslintrc</code> file from within our plugin, and set the value in square brackets to <code class="literal">0</code>:</p><div class="mediaobject"><img src="graphics/BO5194_08_10.jpg" alt="Clearing the final error"/></div><p>This will work in the short term, but with a view to revisiting the code to design out the ambiguity at some point in the future.</p></div><div class="section" title="Performing a test using the plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec84"/>Performing a test using the plugin</h2></div></div></div><p>With our plugin in<a id="id463" class="indexterm"/> place, let's test it out—for this, we need a couple of files from the code download that accompanies this book; the files are available in the <code class="literal">T43 – building a transition shortcut plugin</code> folder:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Go ahead and extract copies of <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code>, then save them to the root of our project area.</li><li class="listitem">In a new file, add the following CSS styles, saving it as <code class="literal">style.css</code> in the <code class="literal">src</code> folder in our project area:<div class="informalexample"><pre class="programlisting">div {
  property: all;
  duration: 1s;
  timing: ease-in-out;
  delay: 1s;
}</pre></div></li><li class="listitem">Fire up a Node.js command prompt, then change the working directory to our project area.</li><li class="listitem">At the prompt, enter <code class="literal">gulp</code> then press <span class="emphasis"><em>Enter</em></span>—PostCSS will go away and compile the source style sheet. If all is well, we should see the compiled results of our style sheet in the <code class="literal">dest</code> folder of our project area:<div class="mediaobject"><img src="graphics/BO5194_08_11.jpg" alt="Performing a test using the plugin"/></div></li></ol></div><p>At this stage, we've run the test for our plugin—we go one step further, and add our plugin to a test runner service such <a id="id464" class="indexterm"/>as Travis CI (at <a class="ulink" href="https://travis-ci.org">https://travis-ci.org</a>). Although this is a mandatory part of the process for creating any PostCSS plugin, there is a fairly steep learning curve, and anyone working on Windows may run into difficulties! If you are a Windows user, you will have to make <code class="literal">test.js</code> executable via the command line—this requires prior knowledge of using Git, which is beyond the scope of this book.</p><p>For now, we'll skip past the Travis CI part of the process—the plugin is sufficiently straightforward that the local testing with <code class="literal">test.js</code> will suffice. Let's change tack—our plugin contains a number of useful concepts in PostCSS, so let's explore how it is put together in more detail.</p></div><div class="section" title="Dissecting our plugin in detail"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec85"/>Dissecting our plugin in detail</h2></div></div></div><p>The inspiration for this plugin is twofold—at the time of writing, PostCSS doesn't have a great number of <a id="id465" class="indexterm"/>animation-based plugins, and it borrows the same concept used in the <code class="literal">postcss-transform-shortcut plugin</code>.</p><p>We start with the ubiquitous call to initialize PostCSS as a dependency for our plugin:</p><div class="informalexample"><pre class="programlisting">var postcss = require('postcss');</pre></div><p>Next up, we initialize <code class="literal">postcss.plugin</code>, to expose functionality within our plugin to the ecosystem:</p><div class="informalexample"><pre class="programlisting">module.exports = postcss.plugin('postcss-transition-shortcut', function (options) {</pre></div><p>At present, our plugin doesn't contain any options, so it will be set as blank; if we had had some options set, then these will be stored in the options array:</p><div class="informalexample"><pre class="programlisting">options = options || {};</pre></div><p>A key part of our plugin is to set some default options—we need to have some default values set, if we don't specify one or more values:</p><div class="informalexample"><pre class="programlisting">var defaults = {
  property: 'all',
  duration: '1s',
  timing: 'ease-in-out',
  delay: '1s'
};</pre></div><p>Up next comes the crux of our plugin—it returns the result of this function:</p><div class="informalexample"><pre class="programlisting">  return function (css) {
     css.walkRules(function (rule) {
       var transitionRule;
       var transitionValues = [];
       var index = -1, node;
       var attributes = /^(property|duration|timing|delay)$/;</pre></div><p>We walk through each rule using <code class="literal">css.walkRules</code>—it sets up a number of variables and an array; we also set a search string that will be used to find any instance of our transition properties.</p><p>If we find a suitable instance of our property, we then clone it, adding the property name <code class="literal">transition</code> before it. We then work through each of up to four properties that may be set, joining them together into the final transition declaration:</p><div class="informalexample"><pre class="programlisting">       while (node = rule.nodes[++index]) {
        if (attributes.test(node.prop)) {
          transitionRule = transitionRule || node.cloneBefore({ prop: 'transition' });
           var transValues = postcss.list.space(node.value);
           transitionValues.push(transValues.join(','));
           node.remove();
           --index;
         }
       }
       transitionRule.value = transitionValues.join(' ');
    });
  };
});</pre></div><p>Let's move on. Our first example was a straightforward plugin; although it does need some further<a id="id466" class="indexterm"/> development (as indicated in <span class="emphasis"><em>Testing our plugin</em></span>), it still serves a useful purpose. In our next example, we'll take a different approach: we will use an existing plugin as a basis for our new version. This plugin, unlike the first one, will not see the light of day in GitHub, though—we'll explore the reasons for this, and more, as part of our next exercise.</p></div></div>
<div class="section" title="Building a custom font plugin"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec69"/>Building a custom font plugin</h1></div></div></div><p>For our next <a id="id467" class="indexterm"/>demo, we're not going to build something original, but start with adapting an existing plugin that is already available for PostCSS. The plugin we <a id="id468" class="indexterm"/>will use is <code class="literal">postcss-fontpath</code> by Seane King (available from <a class="ulink" href="https://github.com/seaneking/postcss-fontpath">https://github.com/seaneking/postcss-fontpath</a>); we're going to incorporate an autocomplete facility<a id="id469" class="indexterm"/> that automatically adds the relevant font stack, based on the name provided, and using the lists available at <a class="ulink" href="http://www.cssfontstack.com/">http://www.cssfontstack.com/</a>.</p><p>"Why do this", I hear you ask? To prove a point—it isn't always necessary to re-invent the wheel; sometimes it is preferable to simply adapt something that exists, which doesn't quite fit our requirements. In this instance, the code we're adding will make it more useful; it will need some further development to allow for error-checking, but nonetheless still serves a purpose.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note43"/>Note</h3><p>A point of note—recommended practice is to use the plugin boilerplate we covered in the previous section. For this next exercise, we will build it manually—this is to show you something of the process, even though it is not one we would release into the wild.</p></div></div><p>Okay, that aside, let's get stuck in and start developing our plugin:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We'll start by creating a folder within the root of our project area—go ahead and name this folder <code class="literal">postcss-custom-fonts</code>.</li><li class="listitem">Next, we need to set up the folder as a Node module, so fire up a Node.js command prompt and change the working folder to our plugin folder.<p>At the prompt, enter <code class="literal">npm init</code> to start the process of creating a <code class="literal">package.json</code> file—use the details shown in this screenshot, at the appropriate prompt:</p><div class="mediaobject"><img src="graphics/BO5194_08_12.jpg" alt="Building a custom font plugin"/></div></li><li class="listitem">With the <a id="id470" class="indexterm"/>prompt still open, go ahead and enter these commands, then press <span class="emphasis"><em>Enter</em></span>—the first one is needed to install PostCSS as a dependency for our plugin, with the second installing <code class="literal">underscore.js</code>, as a second dependency (it's used for the extend method):<div class="informalexample"><pre class="programlisting"><span class="strong"><strong>npm install postcss --save</strong></span>
<span class="strong"><strong>npm install underscore --save</strong></span>
</pre></div><p>Keep the session open—we will need it towards the end of this exercise.</p></li><li class="listitem">From the code download that accompanies this book, we need to extract a copy of <code class="literal">index.js</code>—copy this to the plugin folder.</li><li class="listitem">If all is well, we should see something akin to this screenshot when browsing the contents of our plugin folder:<div class="mediaobject"><img src="graphics/BO5194_08_13.jpg" alt="Building a custom font plugin"/></div></li><li class="listitem">With our plugin in place, let's test it out. For this, we need a couple of files from the code download that accompanies this book. Go ahead and extract copies of <code class="literal">gulpfile.js</code> and <code class="literal">package.json</code> from the <code class="literal">T42 – Building a custom font</code> plugin folder (and <span class="emphasis"><em>not</em></span> the plugin one!), then save them to the root of our project area.</li><li class="listitem">In a new<a id="id471" class="indexterm"/> file, add the following CSS styles, saving it as <code class="literal">style.css</code> in the <code class="literal">src</code> folder in our project area:<div class="informalexample"><pre class="programlisting">@font-face {
  font-family: 'robotoregular';
  font-path: '/fonts/Roboto-Regular-webfont';
  font-weight: normal;
  font-style: normal;
}

h1 { font-family: robotoregular,  fontstack("Extra Stack"); }</pre></div></li><li class="listitem">Revert back to the Node.js command prompt session we had open at the start of this exercise. Make sure the working folder is set to our project area before continuing.</li><li class="listitem">At the prompt, enter <code class="literal">gulp</code> then press <span class="emphasis"><em>Enter</em></span>—PostCSS will go away and compile the source style sheet. If all is well, we should see the compiled results of our style sheet in the <code class="literal">dest</code> folder of our project area:</li></ol></div><div class="mediaobject"><img src="graphics/BO5194_08_14.jpg" alt="Building a custom font plugin"/></div><p>At this stage, we now have a working plugin—even though this is not an original creation, it still <a id="id472" class="indexterm"/>highlights a number of key concepts around construction of PostCSS plugins. Let's take a moment to explore the functionality of our plugin in more detail.</p><div class="section" title="Dissecting the functionality of our plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec86"/>Dissecting the functionality of our plugin</h2></div></div></div><p>At first glance, the <a id="id473" class="indexterm"/>code for our plugin may look complex, but in reality it is relatively straightforward to follow—let's go through it in sections, beginning with defining instances of the <code class="literal">postcss</code> object and a <code class="literal">fontstacks_config</code> object we will use in the plugin:</p><div class="informalexample"><pre class="programlisting">var postcss = require('postcss');
var _ = require('underscore');

// Font stacks from http://www.cssfontstack.com/
var fontstacks_config = {
  'Arial': 'Arial, "Helvetica Neue", Helvetica, sans-serif',
  'Times New Roman': 'TimesNewRoman, "Times New Roman", Times,
  Baskerville, Georgia, serif'
}</pre></div><p>Next up, we add a simple helper function—this is used to convert font names into title case; the names<a id="id474" class="indexterm"/> listed in <code class="literal">fontstacks_config</code> are case sensitive, and will fail if they don't match:</p><div class="informalexample"><pre class="programlisting">// Credit for this function: http://stackoverflow.com/a/196991
function toTitleCase(str) {
  return str.replace(/\w\S*/g, function(txt){
    return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase();
  });
}</pre></div><p>This is the start of the plugin—the first two lines are the obligatory initialization to make the plugin available for use, followed by defining an options object. We then use <code class="literal">_.extend</code> to extend the predefined values in our chosen font stack with those added to the configuration object when running the plugin:</p><div class="informalexample"><pre class="programlisting">module.exports = postcss.plugin('customfonts', function (options) {
  return function (css) {

    options = options || {};
    fontstacks_config = _.extend(fontstacks_config, options.fontstacks);</pre></div><p>We then walk through each rule and node, working out if they first contain a font declaration, then if they contain a font name that matches one in the predefined font stacks. If there is a match, then the font name is converted to the appropriate font stack and inserted with any additional fonts specified, but which don't match our font stacks:</p><div class="informalexample"><pre class="programlisting">    css.walkRules(function (rule) {
      rule.walkDecls(function (decl, i) {
        var value = decl.value;
        if (value.indexOf( 'fontstack(' ) !== -1) {
          var fontstack_requested = value.match(/\(([^)]+)\)/)[1].replace(/["']/g, "");
          fontstack_requested = toTitleCase(fontstack_requested);

          var fontstack = fontstacks_config[fontstack_requested];
          var first_font =  value.substr(0, value.indexOf('fontstack('));

          var new_value = first_font + fontstack;
          decl.value = first_font + fontstack;
        }
      });
    });</pre></div><p>In the second half <a id="id475" class="indexterm"/>of the plugin, we perform a simpler task—we work our way through each rule and declaration, looking for any instances of <code class="literal">@font-face</code> in the code. We then define a <code class="literal">fontpath</code> variable that removes any quotes from the supplied values, and a <code class="literal">format</code> array to manage the different font formats available for use:</p><div class="informalexample"><pre class="programlisting">    css.walkAtRules('font-face', function(rule) {
      rule.walkDecls('font-path', function(decl) {
        var fontPath = decl.value.replace(/'/g, ''),
        src = '',
        formats = [
          { type: 'woff', ext: '.woff' },
          { type: 'truetype', ext: '.ttf' },
          { type: 'svg', ext: '.svg' }
        ];</pre></div><p>We then build up the relevant statement for each font type, before assembling the custom font declaration and inserting it back into the appropriate point in our style sheet:</p><div class="informalexample"><pre class="programlisting">        formats.forEach(function(format, index, array) {
          if (index === array.length - 1){
            src += 'url("' + fontPath + format.ext + '")
        format(\'' + format.type + '\')';
          } else {
            src += 'url("' + fontPath + format.ext + '")
        format(\'' + format.type + '\'),\n ';
          }
        });

        decl.cloneBefore({ prop: 'src', value: src });
        decl.remove();
      });
    });
  }
});</pre></div><p>Our plugin has exposed some key concepts in PostCSS plugin design—the main ones are the use of <code class="literal">.WalkDecls</code> and <code class="literal">.WalkRu</code>
<code class="literal">les</code> (or <code class="literal">.WalkAtRules</code>). I would strongly recommend familiarizing <a id="id476" class="indexterm"/>yourself with the API documentation at <a class="ulink" href="https://github.com/postcss/postcss/blob/master/docs/api.md">https://github.com/postcss/postcss/blob/master/docs/api.md</a>, which outlines all of the commands available within the API, and gives a brief description of their purpose.</p><p>Despite creating<a id="id477" class="indexterm"/> what should be a useful plugin, it isn't one that I would recommend releasing into the wild. At this point you may think I have completely lost the plot, but as I always say, "there's method in the madness"—there are good reasons for not publishing this plugin, so let's take a moment to explore why it might not be a sensible move to release this plugin in its current format.</p></div><div class="section" title="Exploring the dangers of publishing this plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec87"/>Exploring the dangers of publishing this plugin</h2></div></div></div><p>Over the<a id="id478" class="indexterm"/> last few pages, we've created what should be a useful plugin to manipulate custom fonts—it automatically builds up the right font stack based on pre-defined settings, and will fill in the appropriate <code class="literal">@font-face</code> code for us. At this point we should have a plugin that can be released into the wild, for anyone to use…surely?</p><p>Well yes, and no—even though this plugin serves a purpose, it is not one that I would recommend making available…at least not yet! There are a few reasons why, which also help to illustrate the benefits of using the boilerplate code we covered earlier in this chapter:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The plugin doesn't have a <code class="literal">test.js</code> file or configuration associated with it—one of the requirements for releasing plugins is that each be tested, using a <code class="literal">test.js</code> file. Ideally we might use a service such as Travis CI to help with this, but this really only works if you use a Unix-based environment for development.</li><li class="listitem" style="list-style-type: disc">The plugin itself performs two different roles, which is not recommended—best practice for PostCSS plugins is to try where possible to limit the role to one task only. The benefits of this can be seen when using a task runner—we can pick and choose which plugins to use, without introducing too much extra unwanted functionality.</li><li class="listitem" style="list-style-type: disc">The architecture of our code is not optimal—this is primarily due to the use of <code class="literal">css.WalkRules</code> (line 16), and <code class="literal">css.WalkAtRules</code> (line 28). These two commands parse each node within the container, and call the callback function for each rule node and at-rule node. The difference here is that <code class="literal">css.WalkRules</code> works on every rule; <code class="literal">css.WalkAtRules</code> will only work on <code class="literal">@-</code>rules (such as <code class="literal">@font-face</code>). They are not interchangeable, which makes it very inefficient at compilation.</li><li class="listitem" style="list-style-type: disc">If we don't use the plugin boilerplate, then most of the files required for publishing code will not be present—these either have to be created by hand, or created as part of submitting to GitHub. If we use the boilerplate, then this will be done for us automatically, along with configuring the <code class="literal">package.json</code> file for us—all we need to do is add a suitable task runner such as Gulp or Grunt.</li></ul></div><p>One might ask<a id="id479" class="indexterm"/> why we would even consider this route, if it is likely to throw up issues during development—the simple answer is that it helps us understand something of how plugins should be built. If we're building a plugin for personal use only, then there is no need for some of the files or processes that we have to use when releasing plugins for general use.</p></div></div>
<div class="section" title="Simplifying the development process"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec70"/>Simplifying the development process</h1></div></div></div><p>Leaving aside<a id="id480" class="indexterm"/> the intended audience for our plugins, throughout our development process we've used a mix of different techniques, but with one thing in common—our plugins have very few dependencies! This is not to be sniffed at, as clearly any dependencies that change may have a resulting knock-on effect for our plugin.</p><p>This aside, there will be times when the lack of any dependencies may require more development effort than is sensible (or practical)—it is at this point where we may need to consider using additional plugins to handle some of the processing. A perfect example of this is to parse a font: statement so that we can work on the constituent elements; there are a few others that are worthy of note:</p><div class="informaltable"><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Type of parser or helper</p>
</th><th style="text-align: left" valign="bottom">
<p>URL of plugin source</p>
</th><th style="text-align: left" valign="bottom">
<p>Purpose of plugin</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>Selector</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/postcss/postcss-selector-parser">https://github.com/postcss/postcss-selector-parser</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Manages<a id="id481" class="indexterm"/> selector strings.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Value</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/TrySound/postcss-value-parser">https://github.com/TrySound/postcss-value-parser</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Transforms CSS values and <code class="literal">@-</code>rule parameters<a id="id482" class="indexterm"/> into a tree of nodes for easy traversal.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Property</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/jedmao/postcss-resolve-prop">https://github.com/jedmao/postcss-resolve-prop</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Resolves<a id="id483" class="indexterm"/> a rule's property value—this is particularly useful if multiple values are specified for the same property.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Font</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/jedmao/parse-css-font">https://github.com/jedmao/parse-css-font</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Parses <a id="id484" class="indexterm"/>a <code class="literal">font</code> property, and returns values for each element, such as <code class="literal">font-size</code>, <code class="literal">family</code>, <code class="literal">style</code>, or <code class="literal">lineHeigh</code>
<code class="literal">t</code>.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Dimension</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/jedmao/parse-css-dimension">https://github.com/jedmao/parse-css-dimension</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Parses<a id="id485" class="indexterm"/> a CSS dimension such as <code class="literal">number</code>, <code class="literal">length</code>, or <code class="literal">percentage</code>, to return a JavaScript object.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Sides</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/jedmao/parse-css-sides">https://github.com/jedmao/parse-css-sides</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Parses <a id="id486" class="indexterm"/>an element's side attributes (such as <code class="literal">margin</code>, <code class="literal">padding</code>, or <code class="literal">border</code> properties), and returns values for all four sides as strings.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Font helpers</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/jedmao/postcss-font-helpers">https://github.com/jedmao/postcss-font-helpers</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Used to<a id="id487" class="indexterm"/> manipulate font statements in CSS—it either returns individual elements or a combined font object, as required.</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>Margin helpers</p>
</td><td style="text-align: left" valign="top">
<p>
<a class="ulink" href="https://github.com/jedmao/postcss-margin-helpers">https://github.com/jedmao/postcss-margin-helpers</a>
</p>
</td><td style="text-align: left" valign="top">
<p>Used to <a id="id488" class="indexterm"/>manipulate margin values for any specified element.</p>
</td></tr></tbody></table></div><p>So, should we use them? It's not obligatory by any means, but they may help remove some of the<a id="id489" class="indexterm"/> effort required to create our plugin. If any are used, then it pays to keep a close note of any changes being made to the plugins, so that we can correct any issues that occur promptly; after all, no-one likes a plugin that isn't maintained properly by the developer!</p><p>Let's move on, a key part of plugin construction is consistency; the power of PostCSS allows any plugin to be created, so keeping a sense of uniformity is essential. To help with this, the developer of PostCSS has released a set of guidelines: let's dive in and take a look at these in more detail.</p></div>
<div class="section" title="Guidelines for plugin building"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec71"/>Guidelines for plugin building</h1></div></div></div><p>One of the <a id="id490" class="indexterm"/>key benefits of the PostCSS ecosystem is its flexibility—it allows any developer to create any plugin, or adapt existing ones, as long as the license allows for further development!</p><p>To help retain a sense of consistency, the developer has issued a series of mandatory guidelines, which should be followed where practical:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The name of your plugin should clearly indicate the purpose of that plugin—for example, if you built one to mimic the CSS4 <code class="literal">:hover</code> pseudo-class, then <code class="literal">postcss-hover</code> would be a good example.</li><li class="listitem" style="list-style-type: disc">It is better to create a plugin that does one thing well, and not one that tries to perform multiple tasks at the same time.</li><li class="listitem" style="list-style-type: disc">Always use the <code class="literal">postcss.plugin</code> method when creating plugins—you are then hooking into a common plugin API.</li><li class="listitem" style="list-style-type: disc">Where<a id="id491" class="indexterm"/> possible, try to use asynchronous methods—you should also set a <code class="literal">node.source</code> for each node, so that PostCSS can generate an accurate source map.</li><li class="listitem" style="list-style-type: disc">Do not use the console when displaying errors—some PostCSS runners do not allow console output. Use <code class="literal">result.warn</code> instead to manage errors.</li><li class="listitem" style="list-style-type: disc">Any plugin created and published must be tested, with documented examples (where possible) and a change log in English.</li><li class="listitem" style="list-style-type: disc">If you are writing a plugin for Node, then the postcss-plugin keyword must feature in the <code class="literal">package.json</code> file—this is used for feedback about the PostCSS ecosystem.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip19"/>Tip</h3><p>More details on<a id="id492" class="indexterm"/> these guidelines are available at <a class="ulink" href="https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md">https://github.com/postcss/postcss/blob/master/docs/guidelines/plugin.md</a>.</p></div></div></li></ul></div><p>In addition, it is likely that we will use a task runner of some description, such as Broccoli, Grunt, or Brunch, or as in our case, Gulp. To help retain that consistency, the developer has issued a series of guidelines that should be followed where appropriate:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">If your plugin uses a <code class="literal">config</code> file, then it must always be written in JavaScript, and set to support functions in parameters.</li><li class="listitem" style="list-style-type: disc">When using runners, always set the to and from options, even if your runner doesn't handle writing to disk—this is to ensure that PostCSS generates accurate source maps and displays better syntax errors.</li><li class="listitem" style="list-style-type: disc">PostCSS runners must only use the publicly available asynchronous API—runners should not rely on undocumented methods or properties that may be removed in a future release.</li><li class="listitem" style="list-style-type: disc">Don't simply display the full JavaScript stack when handling <code class="literal">CssSyntaxError</code> messages—not every developer is familiar with JavaScript! Instead, make sure any errors are handled gracefully.</li><li class="listitem" style="list-style-type: disc">Any warnings that appear from <code class="literal">result.warnings()</code> should be displayed by PostCSS runners; this can be facilitated by using the <code class="literal">postcss-logs-warnings</code> or <code class="literal">postcss-messages</code> plugins if needed.</li><li class="listitem" style="list-style-type: disc">If your plugin uses the source map option, then by default this will be generated as an inline map by PostCSS. Runners must provide an option to save the map to a separate file, if required.<div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip20"/>Tip</h3><p>More details<a id="id493" class="indexterm"/> on these guidelines are available at <a class="ulink" href="https://github.com/postcss/postcss/blob/master/docs/guidelines/runner.md">https://github.com/postcss/postcss/blob/master/docs/guidelines/runner.md</a>.</p></div></div></li></ul></div><p>The guidelines provided for plugins are mandatory, but in some cases can be seen as a start point—for example, a change log should always be maintained, but it is up to the developer as<a id="id494" class="indexterm"/> to whether this is a <code class="literal">HISTORY.md</code>, <code class="literal">CHANGELOG.md</code>, or a GitHub Releases document. The trick here is careful planning, and to keep it simple—focus on the basics first, before moving onto more complex projects. We can then get accustomed to what must be provided as a minimum for each plugin, before extending it to cover task runner use.</p><p>Okay, let's change tack at this point: one of the guidelines we've covered states that every plugin should be tested as part of normal practice; now is a perfect opportunity to explore what this means in more detail.</p></div>
<div class="section" title="Making the plugin available for use"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec72"/>Making the plugin available for use</h1></div></div></div><p>A key part of creating any plugin is testing—once tested, we can then decide if we want to release it for general use on GitHub and Node's package manager directory. It's not obligatory, but if we have created something that could be useful to others, then it is only fair that we make it available!</p><p>There are a few steps<a id="id495" class="indexterm"/> involved in the process—they can be split into three groups: testing the plugin, adding the final details (in GitHub), and submitting it for inclusion on the PostCSS plugin directory. We'll be using the <code class="literal">postcss-transition-shortcut</code> plugin that we've just created, as a basis for releasing it for general use.</p><p>We've already covered the requirements for testing our plugin, so let's explore the remaining steps needed to make our plugin available for general use by developers. The first step is to publish our plugin to a suitable repository on GitHub. This process falls outside of the scope of this book, but in a nutshell, the process for making the plugin available is as follows:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add examples of code to the <code class="literal">README.md</code> file—this should show an example of a source file, and what we would expect to see when that file has been processed.</li><li class="listitem" style="list-style-type: disc">In the <code class="literal">CHANGELOG.md</code> file, add the initial version number for the plugin.</li><li class="listitem" style="list-style-type: disc">All of the changes <a id="id496" class="indexterm"/>need to be committed to GitHub—my preferred choice is GitHub Desktop, available for Windows or Mac from <a class="ulink" href="https://desktop.github.com/">https://desktop.github.com/</a>. For Linux users, there are<a id="id497" class="indexterm"/> several options available at <a class="ulink" href="https://git-scm.com/download/gui/linux">https://git-scm.com/download/gui/linux</a>.</li><li class="listitem" style="list-style-type: disc">At this point, we now need to publish our plugin to Node's package directory, NPM. The process<a id="id498" class="indexterm"/> involves adding a new<a id="id499" class="indexterm"/> user to NPM, then publishing all files to NPM; the details are outlined in full at <a class="ulink" href="https://docs.npmjs.com/getting-started/publishing-npm-packages">https://docs.npmjs.com/getting-started/publishing-npm-packages</a>.</li></ul></div><p>Once the plugin has been prepared, tested and published, all that remains is to fork PostCSS, add your plugin to the <code class="literal">Plugins</code> section in <code class="literal">README.md</code>, and send a <code class="literal">pull</code> request. We can then monitor the site's Twitter feed for updates about our plugin.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="tip21"/>Tip</h3><p>If you are interested, then you may like to refer to <span class="emphasis"><em>GitHub Essentials</em></span> by <span class="emphasis"><em>Achilleas Pipinellis</em></span>, available at <a class="ulink" href="https://www.packtpub.com/">https://www.packtpub.com/</a>.</p></div></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec73"/>Summary</h1></div></div></div><p>Unlike other processors, plugins play a central role in PostCSS—we can pick and choose what functionality we want to use; if it doesn't exist, then we are free to create our own version. Throughout the course of this chapter, we've covered some key concepts around the use of plugins, so let's take a moment to review what we have learnt.</p><p>We kicked off with a quick introduction to the use of plugins, which was swiftly followed by exploring the architecture of a standard plugin that included a look at some of the key files that make up a standard plugin. We then moved on to take a look at some of the classes, modules, and methods available as part of the API.</p><p>Next up, we began working through the construction of an example plugin, before constructing a suitable test process and correcting the errors generated from linting the code as part of the test. We then rounded off our plugin with a look in more detail, to understand some of the key concepts behind how it works.</p><p>Moving on, we then covered the construction of a second plugin, but this time explored the manual process, and examined why this is not a recommended practice. We took a look at some of the issues that can arise from this practice, and why using the plugin boilerplate makes development easier.</p><p>We then rounded out the chapter by exploring some of the helper plugins we can use to simplify development, along with the recommended guidelines for development, and the process for making the plugin available for other developers to use in the future.</p><p>Okay, onwards we go: so far, we've used a variety of plugins throughout the book. There are three particular groups of plugins that are particularly useful—they are for fallback support, implementing shortcuts to creating CSS, and plugin packs. We'll cover all three (and more) in the next chapter.</p></div></body></html>