- en: Chapter 1. Knockout Essentials
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第1章. Knockout基础知识
- en: 'Though it is expected that you have experience with both JavaScript and **KnockoutJS**,
    we will still be covering the basics to establish a common foundation. This book
    wouldn''t be complete if we didn''t cover at least the basics. After that, we
    will look at building a simple application to create and manage contact information.
    This application will be used throughout the book to explore new techniques in
    Knockout and see how they fit into the larger process of application development.
    In this chapter, you will learn how to:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然预期您对JavaScript和**KnockoutJS**都有经验，但我们仍将介绍基础知识以建立共同的基础。如果不介绍至少基础知识，这本书就不完整。之后，我们将查看构建一个简单的应用来创建和管理联系信息。这个应用将在整本书中用来探索Knockout的新技术，并了解它们如何融入应用开发的大过程。在本章中，您将学习如何：
- en: Define viewmodels
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义视图模型
- en: Write standard bindings
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写标准绑定
- en: Use extenders
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用扩展器
- en: Use templates
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用模板
- en: Put all these pieces together into a functional application
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有这些部分组合成一个功能应用
- en: This covers most of the standard functionalities in Knockout. In the next chapter,
    we will look at creating our own bindings to extend Knockout.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 这涵盖了Knockout的大部分标准功能。在下一章中，我们将探讨创建自己的绑定来扩展Knockout。
- en: Even if you have used Knockout before and don't think you need a refresher,
    I encourage you to at least read the section that covers the `Contacts List` application
    example. It's something we will be using throughout the book as we explore more
    advanced concepts.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 即使您之前使用过Knockout并且认为不需要复习，我也鼓励您至少阅读涵盖`联系人列表`应用示例的部分。在我们探索更高级概念的过程中，我们将使用这个示例。
- en: Before we get started, let's get our development environment set up.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始之前，让我们设置我们的开发环境。
- en: The environment setup
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 环境设置
- en: We will be using a simple **Node.js** server to host our application because
    it will run on any operating system. If you haven't done so, install Node.js by
    following the instructions at [http://nodejs.org/download](http://nodejs.org/download).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用一个简单的**Node.js**服务器来托管我们的应用，因为它可以在任何操作系统上运行。如果您还没有安装，请按照[http://nodejs.org/download](http://nodejs.org/download)上的说明安装Node.js。
- en: We will be using **Git** to manage the code for each chapter. If you haven't
    done so, install Git by following the instructions at [http://git-scm.com/book/en/Getting-Started-Installing-Git](http://git-scm.com/book/en/Getting-Started-Installing-Git).
    The code for this book can be downloaded from [http://www.packtpub.com](http://www.packtpub.com).
    All the code needed to start each chapter can be found in a branch named `cp[chapter#]-[sample]`.
    For example, the first sample we will look at is going to be in the `cp1-computeds`
    branch.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用**Git**来管理每章的代码。如果您还没有安装，请按照[http://git-scm.com/book/en/Getting-Started-Installing-Git](http://git-scm.com/book/en/Getting-Started-Installing-Git)上的说明安装Git。本书的代码可以从[http://www.packtpub.com](http://www.packtpub.com)下载。每个章节开始所需的全部代码都可以在名为`cp[章节编号]-[示例]`的分支中找到。例如，我们将查看的第一个示例将位于`cp1-computeds`分支中。
- en: 'To begin, clone the repository from [https://github.com/tyrsius/MasteringKnockout](https://github.com/tyrsius/MasteringKnockout).
    You can either use the provided download links or run the following command:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，从[https://github.com/tyrsius/MasteringKnockout](https://github.com/tyrsius/MasteringKnockout)克隆仓库。您可以使用提供的下载链接或运行以下命令：
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Then, check out the first sample using:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用以下命令检出第一个示例：
- en: '[PRE1]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'All the examples follow the same pattern. At the root is a `server.js` file
    that contains a boilerplate Node.js server. Inside the client directory is all
    the code for the application. To run the application, run this from the command
    line:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 所有示例都遵循相同的模式。在根目录下是一个包含样板Node.js服务器的`server.js`文件。在客户端目录中包含应用的所有代码。要运行应用，请在命令行中运行以下命令：
- en: '[PRE2]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Keep the command-line window open else the server will stop running. Then,
    open your web browser and navigate to `http://localhost:3000`. If you''ve set
    up your environment correctly, you should be looking at the empty `Contacts List`
    application, as shown in the following screenshot:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 保持命令行窗口开启，否则服务器将停止运行。然后，打开您的网络浏览器并导航到`http://localhost:3000`。如果您正确设置了环境，您应该会看到如以下截图所示的空`联系人列表`应用：
- en: '![The environment setup](img/00002.jpeg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![环境设置](img/00002.jpeg)'
- en: The `cp1` branch contains a skeleton with some blank pages. Until we get to
    the **Contacts** application, most of the samples will not have the **Contacts**
    or **Settings** pages; they will just present the code on the home page.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp1` 分支包含一些空白页的骨架。直到我们到达 **联系人** 应用程序，大部分示例将不会有 **联系人** 或 **设置** 页面；它们将在主页上展示代码。'
- en: Looking at the samples
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 查看示例
- en: 'Samples of running code are provided throughout the book. They are in branches
    in the Git repository. You can look at them by checking out the branch, using
    the following command:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 书中提供了运行代码的示例。它们位于 Git 仓库的分支中。你可以通过检出分支查看它们，使用以下命令：
- en: '[PRE3]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Since the repository is a functional app, most of the code is not relevant to
    the samples. The `client` directory contains the `index.html` and `shell.html`
    pages, as well as the `app`, `content`, and `lib` directories. The `app` directory
    is where our JavaScript is located. The `content` directory contains the included
    CSS and `lib` contains third-party code (Knockout, jQuery, and Twitter Bootstrap).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 由于仓库是一个功能应用，大部分代码与示例无关。`client` 目录包含 `index.html` 和 `shell.html` 页面，以及 `app`、`content`
    和 `lib` 目录。`app` 目录是我们 JavaScript 的位置。`content` 目录包含包含的 CSS，而 `lib` 包含第三方代码（Knockout、jQuery
    和 Twitter Bootstrap）。
- en: The included Node server has a very simple view composition that places the
    contents of a page in the `{{ body }}` section of the shell. If you have worked
    with any server-side MVC frameworks, such as Ruby on Rails or ASP.NET MVC, you
    will be familiar with this. The mechanism is not related to Knockout, but it will
    help us keep our code separated as we add files. The shell is in the `shell.html`
    file. You can take a look at it, but it's not directly related to the samples.
    The HTML for samples is in the `client/index.html` file. The JavaScript for samples
    is in the `client/app/sample.js` file.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 包含的 Node 服务器具有一个非常简单的视图组合，将页面的内容放置在壳的 `{{ body }}` 部分中。如果你使用过任何服务器端 MVC 框架，例如
    Ruby on Rails 或 ASP.NET MVC，你会对这一点很熟悉。这种机制与 Knockout 无关，但它将帮助我们保持代码分离，当我们添加文件时。壳位于
    `shell.html` 文件中。你可以查看它，但它与示例没有直接关系。示例的 HTML 代码在 `client/index.html` 文件中。示例的 JavaScript
    代码在 `client/app/sample.js` 文件中。
- en: JavaScript's compatibility
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 的兼容性
- en: Throughout this book, we will be using code that relies on ECMAScript 5 features,
    which are supported on all modern browsers. I encourage you to run these examples
    using a compatible browser. If you cannot, or if you are interested in running
    them in an older environment, you can use a **polyfill** for them. A polyfill
    is a JavaScript library that adds standard features to old environments to allow
    them to run modern code. For the ECMAScript 5 functions, I recommend **Sugar.js**.
    For the CSS3 media query support, I recommend **Respond.js**.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将使用依赖于 ECMAScript 5 特性的代码，这些特性在所有现代浏览器上都得到支持。我鼓励你使用兼容的浏览器运行这些示例。如果你不能，或者如果你有兴趣在旧环境中运行它们，你可以使用
    **polyfill**。polyfill 是一个 JavaScript 库，它向旧环境添加标准功能，以便它们能够运行现代代码。对于 ECMAScript
    5 函数，我推荐 **Sugar.js**。对于 CSS3 媒体查询支持，我推荐 **Respond.js**。
- en: An overview of Knockout
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Knockout 概述
- en: Knockout is a library designed for **Model-View-ViewModel** (**MVVM**) development.
    This pattern, a descendant of Martin Fowler's Presentation model, encourages the
    separation of **User Interface** (**UI**) from the business logic of the domain
    model. To facilitate this separation, Knockout provides the three necessary components
    for implementing this pattern, namely, a declarative syntax for the view (the
    data-bind HTML attribute), a mechanism to notify changes from the viewmodel (the
    observable object), and a data binder to mediate between the two (Knockout's binding
    handler).
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 是一个为 **模型-视图-视图模型**（**MVVM**）开发设计的库。这种模式是 Martin Fowler 的展示模型的子模式，它鼓励将
    **用户界面**（**UI**）与领域模型的企业逻辑分离。为了促进这种分离，Knockout 提供了实现此模式所需的三个必要组件，即视图的声明性语法（数据绑定
    HTML 属性）、从视图模型通知更改的机制（可观察对象）以及介于两者之间的数据绑定器（Knockout 的绑定处理程序）。
- en: We will be covering the data-bind and observable object syntax here; the binding
    handler syntax and its use will be covered in the next chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在这里介绍数据绑定和可观察对象语法；绑定处理程序语法及其用法将在下一章介绍。
- en: Using the MVVM pattern means your viewmodel operates on data with JavaScript,
    and your HTML view is described using the declarative data-binding syntax. Your
    JavaScript code should not be directly accessing or modifying the view—data-binding
    should handle that by translating your observable objects into HTML using binding
    handlers.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 MVVM 模式意味着你的视图模型使用 JavaScript 操作数据，并且你的 HTML 视图使用声明式数据绑定语法来描述。你的 JavaScript
    代码不应直接访问或修改视图——数据绑定应该通过将你的可观测对象转换为 HTML 并使用绑定处理程序来处理这一点。
- en: The best way to think about the separation between view and viewmodel is to
    consider whether two different views could use your viewmodel. While this is often
    not done, it is still helpful to keep it in mind because it forces you to maintain
    the separation between them. MVVM allows you to redesign the view without affecting
    the viewmodel.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 要考虑视图和视图模型之间的分离，最好的方式是考虑是否两个不同的视图可以使用你的视图模型。虽然这通常不会这样做，但将其牢记在心仍然很有帮助，因为它迫使你保持它们之间的分离。MVVM
    允许你在不影响视图模型的情况下重新设计视图。
- en: Observables
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 可观测对象
- en: Knockout follows a publish/subscribe pattern to keep data in sync between different
    parts of the application, such as the UI and the viewmodel. The publisher in Knockout
    is the observable object. If you've used MVVM before in **Windows Presentation
    Foundation** (**WPF**) development, then observable objects can be thought of
    as Knockout's `INotifyPropertyChanged` implementation.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 通过发布/订阅模式在应用程序的不同部分之间保持数据同步，例如 UI 和视图模型。Knockout 中的发布者是可观测对象。如果您之前在
    **Windows Presentation Foundation** (**WPF**) 开发中使用过 MVVM，那么可观测对象可以被视为 Knockout
    的 `INotifyPropertyChanged` 实现。
- en: 'To construct an observable, the `observable` function is called on the global
    `ko` object:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建一个可观测对象，需要在全局 `ko` 对象上调用 `observable` 函数：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `observable` function returns a new observable. If `ko.observable` is called
    with a value, it returns an observable with that value.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`observable` 函数返回一个新的可观测对象。如果使用值调用 `ko.observable`，则返回具有该值的可观测对象。'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reason why Knockout observables are JavaScript functions instead of normal
    properties is to allow support for older browsers such as Internet Explorer 6,
    which did not support getters and setters on properties. Without that ability,
    setting properties would have no mechanism to notify subscribers about changes.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout 可观测对象之所以是 JavaScript 函数而不是普通属性，是为了支持旧版浏览器，如不支持属性上的获取器和设置器的 Internet
    Explorer 6。如果没有这种能力，设置属性将没有机制来通知订阅者关于更改的信息。
- en: Observables are JavaScript functions that record subscribers reading their value,
    then call these subscribers when the value has been changed. This is done using
    Knockout's dependency tracking mechanism.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测对象是 JavaScript 函数，它们记录读取其值的订阅者，然后在值更改时调用这些订阅者。这是通过 Knockout 的依赖跟踪机制完成的。
- en: 'Observables are read by calling them without any parameters. To write to an
    observable, call it with the value as the first and only parameter (further parameters
    are ignored):'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 通过不带任何参数调用它们来读取可观测对象。要写入可观测对象，请使用值作为第一个也是唯一的参数调用它（其他参数将被忽略）：
- en: '[PRE5]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Tip
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: '**Downloading the sample code**'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '**下载示例代码**'
- en: You can download the sample code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从您在 [http://www.packtpub.com](http://www.packtpub.com) 的账户下载您购买的所有 Packt
    书籍的示例代码文件。如果您在其他地方购买了这本书，您可以访问 [http://www.packtpub.com/support](http://www.packtpub.com/support)
    并注册以直接将文件通过电子邮件发送给您。
- en: 'Observables can contain any legal JavaScript value: primitives, arrays, objects,
    functions, and even other observables (though this wouldn''t be that useful).
    It doesn''t matter what the value is; observables merely provide a mechanism to
    report when that value has been changed.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 可观测对象可以包含任何合法的 JavaScript 值：原始值、数组、对象、函数，甚至其他可观测对象（尽管这可能不是很有用）。值是什么并不重要；可观测对象仅仅提供了一个机制来报告该值何时被更改。
- en: Observable arrays
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观测数组
- en: 'Though standard observables can contain arrays, they aren''t well suited to
    track changes in them. This is because the observable is looking for changes in
    the value of the array, a reference to the array itself, which is not affected
    by adding or removing elements. As this is what most people expect change notification
    to look like on an array, Knockout provides the `observableArray`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管标准可观察对象可以包含数组，但它们并不适合跟踪数组中的变化。这是因为可观察对象正在寻找数组值的更改，而不是数组本身的引用，添加或删除元素不会影响引用。由于这是大多数人期望在数组上看起来像更改通知的样子，Knockout提供了`observableArray`：
- en: '[PRE6]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Like observables, arrays can be constructed with an initial value. Normally,
    you access an observable by calling it or setting its value by passing it a parameter.
    With observable arrays it''s a little different. As the value of the array is
    its reference, setting that value would change the entire array. Instead, you
    usually want to operate on the array by adding or removing elements. Consider
    the following action:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 与可观察对象一样，数组可以用初始值构造。通常，您通过调用它或通过传递参数设置其值来访问可观察对象。对于可观察数组，情况略有不同。由于数组的值是其引用，设置该值将改变整个数组。相反，您通常想要通过添加或删除元素来操作数组。考虑以下操作：
- en: '[PRE7]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By calling `this.users()`, the underlying array is retrieved before a new user
    is pushed to it. In this case, Knockout is not aware that the array was changed,
    as the change was made to the array itself and not the observable. To allow Knockout
    to properly track changes, these changes need to be made to the observable, not
    the underlying value.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调用`this.users()`，在将新用户推送到它之前检索了底层数组。在这种情况下，Knockout没有意识到数组已更改，因为更改是对数组本身而不是可观察对象进行的。为了允许Knockout正确跟踪更改，这些更改需要应用于可观察对象，而不是底层值。
- en: 'To do this, Knockout provides the standard array methods on the observable,
    namely, `push`, `pop`, `shift`, `unshift`, `sort`, `reverse`, and `splice`. The
    call should look like this:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，Knockout在可观察对象上提供了标准的数组方法，即`push`、`pop`、`shift`、`unshift`、`sort`、`reverse`和`splice`。调用应该如下所示：
- en: '[PRE8]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Notice that instead of retrieving the array from the observable, we are calling
    `push` directly on the observable. This will ensure that subscribers are notified
    of the change with an updated array.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们不是从可观察对象中检索数组，而是直接在可观察对象上调用`push`。这将确保订阅者通过更新后的数组收到更改通知。
- en: Computed observables
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算可观察对象
- en: 'Observables are properties that are set manually, either through your code
    or by bindings from the UI. Computed observables are properties that automatically
    update their value by responding to changes in their dependencies, as shown in
    the following code:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察对象是手动设置的属性，无论是通过您的代码还是通过UI的绑定。计算可观察对象是那些通过对其依赖项的变化自动更新其值的属性，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this example, `subtotal` and `tax` are the dependencies of the `total` computed
    observable. For the first time, the computed observable calculates records of
    any other observables that were accessed and creates a subscription for them.
    The result is that whenever `subtotal` or `tax` are changed, the `total` is recalculated
    and notified to its subscribers. It helps to think of computed observables as
    declarative values; you define their value as a formula and they will keep themselves
    up to date.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`subtotal`和`tax`是`total`计算可观察对象的依赖项。对于第一次，计算可观察对象计算了访问过的任何其他可观察对象的记录并为它们创建了一个订阅。结果是，每当`subtotal`或`tax`发生变化时，`total`就会重新计算并通知其订阅者。将计算可观察对象视为声明性值可能会有所帮助；您将它们的值定义为公式，它们将保持自身更新。
- en: The `parseFloat` calls are to ensure that they are treated as numbers instead
    of strings, which would cause concatenation instead of arithmetic. As Knockout
    binds data against HTML attributes, which are always strings, updates from data
    binding produce strings. When we discuss extenders, you will see another way to
    manage this issue.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '`parseFloat`调用是为了确保它们被视为数字而不是字符串，这会导致连接而不是算术运算。由于Knockout将数据绑定到HTML属性，这些属性始终是字符串，因此数据绑定的更新会产生字符串。当我们讨论扩展器时，您将看到另一种管理此问题的方法。'
- en: 'You can see a sample of this on the `cp1-computeds` branch:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`cp1-computeds`分支上看到这个示例的样本：
- en: '![Computed observables](img/00003.jpeg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![计算可观察对象](img/00003.jpeg)'
- en: Try changing some of the numbers and watch the `total` computed value update
    automatically. You can see that the viewmodel code contains just this sample by
    looking in the `client/app/sample.js` file.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试更改一些数字并观察`总`计算值自动更新。您可以通过查看`client/app/sample.js`文件来看到viewmodel代码中只包含这个示例。
- en: Writable computed observables
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可写计算可观察对象
- en: 'The preceding `total` example is a read-only computed. While they are less
    common, it is also possible to make a computed observable writable. To do so,
    pass an object with a `read` and `write` function to `ko.computed`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的`total`示例是一个只读计算。虽然它们不太常见，但也可以使计算可观察量可写。要做到这一点，将一个包含`read`和`write`函数的对象传递给`ko.computed`：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: When something attempts to write to the `total` computed now, it will cause
    the `subtotal` observable to be updated by the `write` function. This is a very
    powerful technique, but it is not always necessary. In some cases being unable
    to write directly to `total` might be a good thing, such as when `total` might
    involve conditionally applying tax to a list of items. You should use writeable
    computeds only when it makes sense to do so.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 当有东西尝试向当前的`total`计算写入时，它将通过`write`函数更新`subtotal`可观察量。这是一个非常强大的技术，但并不总是必要的。在某些情况下，无法直接写入`total`可能是一件好事，例如当`total`可能涉及对项目列表条件性地应用税费时。你应该只在有道理这样做的时候使用可写计算。
- en: You can see an example of this in the `cp1-writecomputed` branch. The `total`
    computed is now bound to an `input` element such as the `subtotal` and `tax` properties,
    and changes to the value will reflect back into the `subtotal` observable.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cp1-writecomputed`分支中看到这个示例。现在的`total`计算绑定到了一个`input`元素，例如`subtotal`和`tax`属性，值的更改将反映回`subtotal`可观察量。
- en: Pure computed observables
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 纯计算可观察量
- en: Nonpure computed observables re-evaluate themselves whenever any of their dependencies
    change, even if there are no subscribers to receive the updated value. This re-evaluation
    can be useful if the computed also has intentional side effects, but it wastes
    memory and the processor's cycles if it has no side effects. Pure computed observables,
    on the other hand, do not re-evaluate when there are no subscribers.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 非纯计算可观察量在它们的任何依赖项发生变化时都会重新评估自己，即使没有订阅者接收更新的值。如果计算也有故意的副作用，这种重新评估可能是有用的，但如果没有任何副作用，它将浪费内存和处理器的周期。另一方面，纯计算可观察量在没有订阅者时不会重新评估。
- en: 'Pure computed observables have two states: **listening** and **sleeping**.
    When a pure computed has subscribers, it will be listening and behaving exactly
    like a normal computed. When a pure computed has no subscribers, it will enter
    its sleeping state and dispose off all of its dependency subscriptions. When it
    wakes up, the pure computed will re-evaluate itself to ensure its value is correct.'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 纯计算可观察量有两种状态：**监听**和**睡眠**。当一个纯计算有订阅者时，它将处于监听状态，并表现得就像一个正常的计算一样。当一个纯计算没有订阅者时，它将进入睡眠状态并取消所有依赖订阅。当它醒来时，纯计算将重新评估自身以确保其值正确。
- en: Pure computed observables are useful when a value may go unused for an extended
    period of time, as they do not re-evaluate. However, since a pure computed always
    re-evaluates when accessed from a sleeping state, it can sometimes perform worse
    than a normal computed observable. Since normal computeds only re-evaluate when
    their dependencies change, a computed observable that is frequently woken from
    a sleeping state could potentially evaluate its dependencies more often.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个值可能长时间未被使用时，纯计算可观察量非常有用，因为它们不会重新评估。然而，由于纯计算在从睡眠状态访问时总是会重新评估，它有时可能表现得不如正常计算可观察量。由于正常计算只有在它们的依赖项发生变化时才会重新评估，因此频繁从睡眠状态唤醒的计算可观察量可能会更频繁地评估其依赖项。
- en: 'There are two ways to create a pure computed: by using `ko.pureComputed` or
    by passing `{ pure: true }` as the third parameter to `ko.computed`:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '创建纯计算有两种方式：使用`ko.pureComputed`或通过将`{ pure: true }`作为`ko.computed`的第三个参数传递：'
- en: '[PRE11]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Note
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Pure computed observables were introduced in Knockout 3.2, which was not released
    at the time this book was written. None of the code samples take advantage of
    pure computed observables, even though many of the samples would have benefited
    from them.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 纯计算可观察量是在Knockout 3.2中引入的，而这本书是在那时尚未发布。没有任何代码示例利用纯计算可观察量，尽管许多示例本可以从它们中受益。
- en: Manual subscriptions
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 手动订阅
- en: Sometimes you need to do more than update a dependent value when an observable
    changes, such as make a web request for additional data based on the new value
    of your observable. Observables provide a `subscribe` function that lets you register
    a function to be called when the observable is updated.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，当可观察量发生变化时，你需要做的不仅仅是更新依赖值，例如根据你可观察量的新值发起一个网络请求以获取更多数据。可观察量提供了一个`subscribe`函数，允许你注册一个函数，当可观察量更新时将被调用。
- en: Subscriptions use the same internal mechanism in Knockout that binding handlers
    and computed observables use to receive changes.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 订阅在 Knockout 中使用与绑定处理程序和计算属性使用的相同内部机制来接收更改。
- en: 'This is an example of setting up a subscription on an observable:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在可观察对象上设置订阅的一个示例：
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This subscription will be called any time when the `locationId` is updated,
    whether it happens from a UI binding or from somewhere else in JavaScript.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `locationId` 被更新时，无论是由 UI 绑定还是 JavaScript 中的其他地方触发，此订阅都会被调用。
- en: 'The `subscribe` function also allows you to provide a target for the subscription
    and the name of the event you want to subscribe to. The target is the value of
    `this` for the subscription handler you provide. The event defaults to change,
    which receives the value after it has been updated, but can also be `beforeChange`,
    which is called with the old value before a change happens:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`subscribe` 函数还允许你为订阅提供一个目标以及你想要订阅的事件名称。目标是为你提供的订阅处理程序设置的 `this` 的值。事件默认为更改，它接收更新后的值，但也可以是
    `beforeChange`，它在更改发生之前调用，并带有旧值：'
- en: '[PRE13]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Finally, you can stop a subscription from continuing to fire by capturing it
    and calling dispose. This can be useful if you want to stop the handler or to
    make subscriptions that only fire a single time:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以通过捕获订阅并调用 dispose 来停止订阅继续触发。如果你想要停止处理程序或创建只触发一次的订阅，这可能会很有用：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Once a subscription has been disposed, it cannot be restarted. If you need it,
    you will have to recreate the subscription.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦订阅被销毁，它就不能重新启动。如果你需要它，你必须重新创建订阅。
- en: The `cp1-subscribe` branch has a subscription example that logs any changes
    to the `subtotal` observable on the JavaScript console, as well as a button that
    stops the subscription. Try changing the subtotal or total value and watch out
    for the console messages. Changing the total causes an update of the subtotal,
    which is why it still fires the subscription. Remember, changes from any source
    will cause an observable to report changes to all of its subscribers. This is
    the same reason updating the `total` computed causes the `subtotal` observable's
    `input` element to update; the `input` element is a subscriber to the viewmodel's
    property.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp1-subscribe` 分支有一个订阅示例，它在 JavaScript 控制台中记录 `subtotal` 可观察对象的任何更改，以及一个停止订阅的按钮。尝试更改小计或总价值，并注意控制台消息。更改总价值会导致小计更新，这就是为什么它仍然触发订阅。记住，来自任何来源的更改都会导致可观察对象向所有订阅者报告更改。这就是为什么更新
    `total` 计算属性会导致视图模型属性的 `input` 元素更新；`input` 元素是视图模型属性的订阅者。'
- en: Defining viewmodels
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义视图模型
- en: Viewmodels are the objects whose properties your view binds with; they form
    the binding context. It is the representation of your data and operations for
    your view (we will cover them in detail in the *Control flow bindings* section
    later in this chapter). Like regular objects in JavaScript, there are many ways
    to actually create them, but Knockout introduces some specific challenges.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 视图模型是视图与之绑定的属性的对象；它们形成绑定上下文。它是你视图中的数据和操作的表示（我们将在本章后面的 *控制流绑定* 部分详细讨论它们）。像 JavaScript
    中的常规对象一样，实际上有很多方法可以创建它们，但 Knockout 引入了一些特定的挑战。
- en: The this and self keywords
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: this 和 self 关键字
- en: 'In JavaScript, `this` has a special meaning; it refers to the object calling
    the function. Functions called from an object get that object set to `this`. However,
    for functions that are anonymously called by code, that is merely the *inside*
    of an object, the behavior is different. Consider the following viewmodel:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在 JavaScript 中，`this` 有一个特殊的意义；它指的是调用函数的对象。从对象中调用的函数将那个对象设置为 `this`。然而，对于由代码匿名调用的函数，这仅仅是对象的
    *内部*，其行为是不同的。考虑以下视图模型：
- en: '[PRE15]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The function inside the computed observable is not a property of the `Invoice`
    object. As it runs in a different context, its value for this will be the window
    object, not the `Invoice` object. It will not be able to find the `subtotal` property.
    There are two ways to handle this.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 计算属性中的函数不是 `Invoice` 对象的属性。因为它在另一个上下文中运行，所以它的 `this` 值将是窗口对象，而不是 `Invoice` 对象。它将无法找到
    `subtotal` 属性。有两种处理方法。
- en: 'The first is by using the second parameter of the `ko.computed` function to
    bind the function to `this`:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 第一种是通过使用 `ko.computed` 函数的第二个参数将函数绑定到 `this`：
- en: '[PRE16]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This gives the computed observable a reference to the `Invoice` that originally
    defined it, which allows the computed observable to call the supplied function
    in the correct context.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这给计算可观察值提供了一个对最初定义它的 `Invoice` 的引用，这允许计算可观察值在正确的上下文中调用提供的函数。
- en: 'The second way to ensure the computed observable can reference the `subtotal`,
    is to capture the value of `this` in a closure. You can then use the closure to
    safely refer to the properties of the parent viewmodel. There are several conventional
    names for such a closure: `that`, `_this`, or `self`.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 确保计算可观察值可以引用 `subtotal` 的第二种方式是捕获 `this` 的值在一个闭包中。然后你可以使用这个闭包安全地引用父视图模型的属性。这样的闭包有几个传统名称：`that`、`_this`
    或 `self`。
- en: 'I prefer to use `self` as it is visually distinct from `this` while still carrying
    a similar meaning, but it''s up to you:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 我更喜欢使用 `self`，因为它在视觉上与 `this` 区分开来，同时仍然具有相似的含义，但最终决定权在你：
- en: '[PRE17]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: I find the second method easier to remember. If you always use `self` to refer
    to the model, it will always work. If you have another anonymous function inside
    the computed, you will have to remember to bind that function as well; `self`
    continues to work as a closure no matter how many levels deep you nest. The `self`
    variable works as a closure inside any function defined in your viewmodel, including
    subscriptions. It's also easier to spot when `self` isn't being used, which is
    very helpful while debugging your code.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 我发现第二种方法更容易记住。如果你总是使用 `self` 来引用模型，它总是会起作用。如果你在计算属性内部有另一个匿名函数，你必须记得绑定该函数；无论你嵌套多深，`self`
    作为一个闭包都会继续工作。`self` 变量作为闭包在视图模型中定义的任何函数内部工作，包括订阅。当 `self` 没有被使用时，这也很容易被发现，这在调试代码时非常有帮助。
- en: Problems with prototypes
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型问题
- en: 'If you are working with viewmodels that will be inherited by other viewmodels,
    you might think that putting all the base observable properties on the prototype
    is the way to go. In vanilla JavaScript, if you are inheriting an object, try
    to change the value of a property stored on the prototype; the property would
    be added to the inheriting object leaving the prototype intact. When using observables
    in Knockout though, this isn''t the case. The observables are functions, and their
    values are set by calling them with a single parameter, not by assigning new values
    to them. Because prototypical inheritance would result in multiple objects referring
    to a single observable; observables cannot be safely placed on viewmodel prototypes.
    Nonobservable functions can still be safely included in prototypes. For example,
    consider the following objects:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在处理将被其他视图模型继承的视图模型，你可能会认为将所有基本可观察属性放在原型上是正确的做法。在纯 JavaScript 中，如果你正在继承一个对象，尝试改变存储在原型上的属性的值；该属性将被添加到继承对象中，而原型保持不变。然而，在使用
    Knockout 中的可观察值时，情况并非如此。可观察值是函数，它们的值是通过调用它们并传递单个参数来设置的，而不是通过为新值赋值。因为原型继承会导致多个对象引用同一个可观察值；可观察值不能安全地放在视图模型的原型上。非可观察函数仍然可以安全地包含在原型中。例如，考虑以下对象：
- en: '[PRE18]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The last line will cause the name of both objects to be updated, as it is referring
    to the same function. This example can be seen in the `cp1-prototype` branch,
    which includes two input elements bound to the name of each viewmodel. As they
    are really the same observable, changing one will affect the other.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一行将导致两个对象的名字都被更新，因为它引用的是同一个函数。这个例子可以在 `cp1-prototype` 分支中看到，该分支包括两个绑定到每个视图模型名称的输入元素。由于它们实际上是同一个可观察值，改变一个将影响另一个。
- en: Serializing viewmodels
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 序列化视图模型
- en: 'When you are ready to send your viewmodels to the server, or really do anything
    that requires you to work with their values instead of observables, Knockout provides
    two very handy utility methods:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 当你准备好将你的视图模型发送到服务器，或者真正需要处理它们的值而不是可观察值时，Knockout 提供了两个非常实用的实用方法：
- en: '`ko.toJS`: This function takes an object and does a deep copy, unwrapping all
    observables, into a new JavaScript object whose properties are normal (nonobservable)
    JavaScript values. This function is perfect to get copies of viewmodels.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.toJS`：这个函数接受一个对象，并对其进行深拷贝，展开所有可观察值，到一个新的 JavaScript 对象中，其属性是正常的（非可观察）JavaScript
    值。这个函数非常适合获取视图模型的副本。'
- en: '`ko.toJSON`: This function uses the output from `ko.toJS` with `JSON.stringify`
    to produce a JSON string of the supplied object. This function accepts the same
    parameters as `JSON.stringify`.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ko.toJSON`：这个函数使用 `ko.toJS` 的输出与 `JSON.stringify` 结合，生成一个包含提供对象的 JSON 字符串。这个函数接受与
    `JSON.stringify` 相同的参数。'
- en: The data-bind syntax
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据绑定语法
- en: 'Knockout takes advantage of the HTML5 `data-*` attribute specification to define
    its `data-bind` attribute. Though all HTML attributes are necessarily strings,
    Knockout parses them as name:value pairs. The name refers to the binding handler
    to be used and the value refers to the value the binding will use:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: Knockout利用HTML5 `data-*`属性规范来定义其`data-bind`属性。尽管所有HTML属性都是字符串，但Knockout将它们解析为name:value对。名称指的是要使用的绑定处理程序，而值指的是绑定将使用的值：
- en: '[PRE19]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `data-bind` attribute can also contain multiple bindings separated by commas.
    This allows multiple properties to be bound on an element:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`data-bind`属性也可以包含由逗号分隔的多个绑定。这允许在元素上绑定多个属性：'
- en: '[PRE20]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding example, the enable binding uses `canEdit` as a value. The
    binding will set the `disabled` attribute on the button element when `canEdit`
    is `false`, and remove the `disabled` attribute when `canEdit` is `true`. If `canEdit`
    is an observable, the enable binding will update whenever `canEdit` is updated.
    If `canEdit` is a literal value, such as `true`, it will only use the value to
    set the initial state.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，`enable`绑定使用`canEdit`作为值。当`canEdit`为`false`时，绑定将在按钮元素上设置`disabled`属性，当`canEdit`为`true`时，将移除`disabled`属性。如果`canEdit`是一个可观察的值，`enable`绑定将在`canEdit`更新时更新。如果`canEdit`是一个字面量值，例如`true`，它将只使用该值来设置初始状态。
- en: Enable is a **one-way binding**; it will update the element with changes from
    the value but it will not update the value with changes from the element. This
    is because when enable is being used to control the element, Knockout assumes
    that nothing will be programmatically updating the element. Updates should happen
    in the viewmodel, and binding handlers should be responsible for ensuring the
    view is kept in sync.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`Enable`是一个**单向绑定**；它将更新元素值，但不会用元素值更新值。这是因为当使用`enable`来控制元素时，Knockout假设不会有任何程序更新元素。更新应在视图模型中发生，绑定处理程序应负责确保视图保持同步。'
- en: 'When users update the UI of data-bound input elements, those changes need to
    be synced to the viewmodel. This is done with **two-way bindings**, such as the
    `value` binding:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户更新数据绑定输入元素的UI时，这些更改需要同步到视图模型。这是通过**双向绑定**完成的，例如`value`绑定：
- en: '[PRE21]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: This binding will set the initial value of the `input` element to the current
    value of the `firstName` property, and after that, it will ensure that any changes
    to either the element's value or the property cause the other to update. If the
    user types something into the input, the `firstName` property will receive the
    value. If the `firstName` property is updated programmatically, the input's value
    will be updated.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此绑定将`input`元素的初始值设置为`firstName`属性的当前值，之后，它将确保元素值或属性的任何更改都会导致对方更新。如果用户在输入框中输入某些内容，`firstName`属性将接收该值。如果`firstName`属性被程序更新，输入框的值也将被更新。
- en: These are both examples of binding against a simple property on the viewmodel.
    This is the most common case, but Knockout supports more complex scenarios as
    well.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是绑定到视图模型简单属性的示例。这是最常见的情况，但Knockout也支持更复杂的场景。
- en: Note
  id: totrans-122
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete list of the standard Knockout binding handlers, see the Knockout
    documentation ([http://knockoutjs.com/documentation/introduction.html](http://knockoutjs.com/documentation/introduction.html)).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 对于标准Knockout绑定处理程序的完整列表，请参阅Knockout文档([http://knockoutjs.com/documentation/introduction.html](http://knockoutjs.com/documentation/introduction.html))。
- en: Binding with nested properties
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 嵌套属性的绑定
- en: 'In the previous example, Knockout parsed the binding value for the name of
    a property and looked for that property on the current viewmodel. You can also
    provide deep property references. Consider the following object:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的示例中，Knockout解析了属性的绑定值并查找当前视图模型上的该属性。您也可以提供深层属性引用。考虑以下对象：
- en: '[PRE22]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'We can bind directly against the `firstName` property of the viewmodel''s user
    by using standard dot notation:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过使用标准的点表示法直接绑定到视图模型用户的`firstName`属性：
- en: '[PRE23]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Binding against functions
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 函数绑定
- en: If you are using the `click` or `event` bindings to bind some UI event, the
    binding expects the property to be a function. Functions will receive the current
    model (the binding context) as their first parameter, and the JavaScript event
    as the second parameter (though you shouldn't need to do this very often).
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您使用`click`或`event`绑定来绑定一些UI事件，绑定期望属性是一个函数。函数将接收当前模型（绑定上下文）作为其第一个参数，并将JavaScript事件作为第二个参数（尽管您不需要这样做非常频繁）。
- en: 'In this example, the parent viewmodel receives the contact to be removed from
    the `click` binding because the `foreach` loop creates a nested binding context
    for each contact. The parent reference in the binding moves the context up to
    the parent viewmodel to get access to the remove function:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，父视图模型通过 `click` 绑定接收要删除的联系人，因为 `foreach` 循环为每个联系人创建了一个嵌套绑定上下文。绑定中的父引用将上下文移动到父视图模型以获取对删除函数的访问：
- en: '[PRE24]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Binding with expressions
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用表达式进行绑定
- en: 'In addition to property references, Knockout also supports the use of JavaScript
    expressions as binding values. For bindings that expect true or false values,
    such as enable, we can use Boolean expressions to set them:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 除了属性引用外，Knockout 还支持将 JavaScript 表达式用作绑定值。对于期望 true 或 false 值的绑定，例如 enable，我们可以使用布尔表达式来设置它们：
- en: '[PRE25]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'We can also use ternary expressions to control the result of the expression.
    This is useful in cases where Booleans are not expected, such as text bindings:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用三元表达式来控制表达式的结果。这在布尔值不期望的情况下很有用，例如文本绑定：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now the `span` will have `Yes` as content.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 现在 `span` 将以 `Yes` 作为内容。
- en: Both forms of expressions will use dependency tracking to rerun if they read
    from an observable the first time they are run. If `age` was an observable value,
    we could update it and the element's binding would re-evaluate the expression,
    changing the text or enabled state if the result changed.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种表达式形式都将使用依赖跟踪来重新运行，如果它们在第一次运行时从可观察值中读取。如果 `age` 是一个可观察值，我们可以更新它，并且元素的绑定将重新评估表达式，如果结果改变，将更改文本或启用状态。
- en: Binding with function expressions
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用函数表达式进行绑定
- en: 'The last method to set binding values is by using functions. You can call a
    function by referencing it in the binding:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 设置绑定值的最后一种方法是使用函数。您可以通过在绑定中引用它来调用函数：
- en: '[PRE27]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'You can also write an anonymous function as a string directly in the binding.
    When creating a function for the `click` binding, the parameters are the binding
    context (viewmodel) and the JavaScript `click` event. If you bind against a viewmodel
    function using its property name, it would receive the same parameters:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以直接在绑定中将匿名函数作为字符串写入。当为 `click` 绑定创建函数时，参数是绑定上下文（视图模型）和 JavaScript `click`
    事件。如果您使用属性名绑定到视图模型函数，它将接收相同的参数：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Though this is possible, I wouldn't encourage it. It places logic directly in
    the view instead of in the viewmodel where it belongs. You should only use this
    last method in very special cases. It's much better to place the method on the
    viewmodel and just use a property reference.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这是可能的，但我不会鼓励这样做。它将逻辑直接放在视图中，而不是属于视图模型的视图模型中。您只应在非常特殊的情况下使用这种方法。将方法放在视图模型上并仅使用属性引用要好得多。
- en: Using parentheses in bindings
  id: totrans-146
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在绑定中使用括号
- en: 'It can be confusing trying to figure out when to use parentheses in bindings
    to use an observable as a value. Knockout tries to be helpful by not requiring
    the parentheses in simple binding expressions like this one:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试弄清楚在绑定中使用括号以使用可观察值作为值时可能会令人困惑。Knockout 通过在简单绑定表达式中不要求括号来尝试提供帮助，如下所示：
- en: '[PRE29]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In this example, the `firstName` property could be either an observable or
    a literal value, and it would work just fine. However, there are two cases when
    the parentheses are needed in bindings: when binding against a nested property
    and when binding with an expression. Consider the following viewmodel:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`firstName` 属性可以是可观察的或字面值，并且它将正常工作。然而，在绑定中有两种情况下需要括号：当绑定到嵌套属性和当绑定到表达式时。考虑以下视图模型：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The user object here is an observable property, as are each of its properties.
    If we wanted to write the same binding now, it would need to include parentheses
    on the `user` function but still not on the `firstName` property:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这里用户对象是一个可观察属性，以及它的每个属性也是如此。如果我们现在想写相同的绑定，它需要在 `user` 函数上包含括号，但不在 `firstName`
    属性上：
- en: '[PRE31]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In cases where we are binding directly against a property, the parentheses of
    that property are never needed. This is because Knockout is smart enough to understand
    how to access the value of the observable that it is given in bindings.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们直接绑定到属性的情况下，该属性的括号永远不需要。这是因为 Knockout 足够智能，能够理解如何在绑定中访问它给出的可观察值的值。
- en: 'However, if we are binding against an expression, they are always needed:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们绑定到一个表达式，它们总是需要的：
- en: '[PRE32]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Neither of these bindings will cause errors, but the first one will not work
    as expected. This is because the first expression will try to evaluate on the
    `age` observable itself (which is a function, not a number) instead of the observable's
    value. The second one correctly compares the value of the observable to `18`,
    producing the expected result.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个绑定都不会导致错误，但第一个绑定不会按预期工作。这是因为第一个表达式将尝试在 `age` 可观察对象本身（它是一个函数，而不是一个数字）上评估，而不是在可观察对象的值上。第二个表达式正确地比较了可观察对象的值与
    `18`，产生了预期的结果。
- en: Debugging with ko.toJSON
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 ko.toJSON 进行调试
- en: 'Because `ko.toJSON` accepts the spaces argument for `JSON.stringify`, you can
    use it in a text binding to get a live copy of your viewmodel with nice, readable
    formatting:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因为 `ko.toJSON` 接受 `JSON.stringify` 的 `spaces` 参数，所以你可以在文本绑定中使用它来获取一个格式良好、易于阅读的
    viewmodel 的实时副本：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The `cp1-databind` branch has an interactive example of each of these bindings.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp1-databind` 分支有一个每个这些绑定的交互式示例。'
- en: Control flow bindings
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制流绑定
- en: So far, we have looked at one-way and two-way bindings that set or sync data
    with an attribute on an HTML element. There is a different kind of binding that
    Knockout uses for modifying the DOM by adding or removing nodes. These are the
    control flow bindings, and they include `foreach`, `if`, `with`, and `template`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经查看了一向绑定和双向绑定，它们通过 HTML 元素的属性设置或同步数据。Knockout 使用一种不同的绑定来通过添加或删除节点来修改
    DOM。这些是控制流绑定，包括 `foreach`、`if`、`with` 和 `template`。
- en: All of the control flow bindings work by actually removing their content from
    the DOM and creating an in-memory template from it. This template is used to add
    and remove the content as necessary.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的控制流绑定实际上是通过从 DOM 中移除其内容并创建一个内存中的模板来工作的。这个模板用于根据需要添加和移除内容。
- en: 'Control flow bindings (except `if`) also introduce a binding context hierarchy.
    Your root binding context is the viewmodel passed to `ko.applyBindings`. The `data-bind`
    attributes have access to properties in the current context. Control flow bindings
    (other than `if`) create a child-binding context, meaning that `data-bind` attributes
    inside the control flow binding''s template have access to the properties of their
    context and not the root context. Bindings inside a child context have access
    to special properties to allow them to navigate the context hierarchy. The most
    commonly used are:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 控制流绑定（除了 `if`）还引入了一个绑定上下文层次结构。你的根绑定上下文是传递给 `ko.applyBindings` 的 viewmodel。`data-bind`
    属性可以访问当前上下文中的属性。控制流绑定（除了 `if`）创建一个子绑定上下文，这意味着控制流绑定模板内的 `data-bind` 属性可以访问它们上下文中的属性，而不是根上下文。子上下文内的绑定可以访问特殊属性，以便它们可以导航上下文层次结构。最常用的有：
- en: '`$parent`: This accesses the binding context of the immediate parent. In this
    example, `group` and `$parent.group` refer to the same property because `$parent`
    accesses the context outside of the person:'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$parent`：这访问了直接父级的绑定上下文。在这个例子中，`group` 和 `$parent.group` 指的是同一个属性，因为 `$parent`
    访问的是人之外的上下文：'
- en: '[PRE34]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '`$parents[n]`: This is an array of parent contexts. The `$parents[0]` array
    is same as `$parent`.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$parents[n]`：这是一个父级上下文的数组。`$parents[0]` 数组与 `$parent` 相同。'
- en: '`$root`: This is the root viewmodel, the highest context in the hierarchy.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$root`：这是根 viewmodel，在层次结构中处于最高层。'
- en: '`$data`: This is the current viewmodel, useful inside `foreach` loops.'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`$data`：这是当前 viewmodel，在 `foreach` 循环内很有用。'
- en: Note
  id: totrans-170
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For a complete list of context properties, see the Knockout documentation for
    them at [http://knockoutjs.com/documentation/binding-context.html](http://knockoutjs.com/documentation/binding-context.html).
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对于上下文属性的完整列表，请参阅 Knockout 文档中的它们，链接为 [http://knockoutjs.com/documentation/binding-context.html](http://knockoutjs.com/documentation/binding-context.html)。
- en: The if binding
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if 绑定
- en: 'The `if` binding takes a value or expression to evaluate and only renders the
    contained template when the value or expression is truthy (in the JavaScript sense).
    If the expression is falsy, the template is removed from the DOM. When the expression
    becomes true, the template is recreated and any contained `data-bind` attributes
    are reapplied. The `if` binding does not create a new binding context:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: '`if` 绑定接受一个要评估的值或表达式，并且只有在值或表达式为真（在 JavaScript 的意义上）时才渲染包含的模板。如果表达式是假的，模板将从
    DOM 中移除。当表达式变为真时，模板将被重新创建，并且任何包含的 `data-bind` 属性都将重新应用。`if` 绑定不会创建一个新的绑定上下文：'
- en: '[PRE35]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: This `div` would be empty when `isAdmin` is `false` or `null`. If the value
    of `isAdmin` is updated, the binding will re-evaluate and add or remove the template
    as necessary.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `isAdmin` 为 `false` 或 `null` 时，这个 `div` 将为空。如果 `isAdmin` 的值被更新，绑定将重新评估并根据需要添加或删除模板。
- en: 'There is also an `ifnot` binding that just inverts the expression. It''s useful
    if you want to still use a property reference without needing to add a bang and
    parentheses. The following two lines are equivalent:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个 `ifnot` 绑定，它只是反转了表达式。如果你想在不需要添加感叹号和括号的情况下仍然使用属性引用，这会很有用。以下两行是等价的：
- en: '[PRE36]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The parentheses are needed in the first example because it is an expression,
    not a property name. They are not needed in the second example because it is a
    simple property reference.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个例子中需要括号，因为它是一个表达式，而不是属性名。在第二个例子中不需要括号，因为它是一个简单的属性引用。
- en: The with binding
  id: totrans-179
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: With 绑定
- en: 'The `with` binding creates a new binding context using the supplied value,
    which causes bindings inside the bound element to be scoped to the new context.
    These two snippets are functionally similar:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`with` 绑定使用提供的值创建一个新的绑定上下文，这导致绑定在绑定元素内的作用域被限制到新的上下文中。这两个代码片段在功能上是相似的：'
- en: '[PRE37]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: While saving a few keystrokes and keeping your bindings easier to read is nice,
    the real benefit of the `with` binding is that it is an implicit `if` binding.
    If the value is `null` or `undefined`, the content of the HTML element will be
    removed from the DOM. In the cases where this is possible, it saves you from the
    need to make null checks for each descendant binding.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然节省一些键盘输入并使你的绑定更容易阅读是件好事，但 `with` 绑定的真正好处是它是一个隐式的 `if` 绑定。如果值是 `null` 或 `undefined`，HTML
    元素的内容将从 DOM 中移除。在可能的情况下，这可以节省你为每个后代绑定进行空值检查的需要。
- en: The foreach binding
  id: totrans-183
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: The foreach binding
- en: The `foreach` binding creates an implicit template using the contents of the
    HTML element and repeats that template for every element in the array.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach` 绑定创建一个隐式模板，使用 HTML 元素的内容，并为数组中的每个元素重复该模板。'
- en: 'This viewmodel contains a list of people we need to render:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 viewmodel 包含了一个我们需要渲染的人的列表：
- en: '[PRE38]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'With this binding, we create an implicit template for the `li` element:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个绑定，我们为 `li` 元素创建一个隐式模板：
- en: '[PRE39]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'This binding produces the following HTML:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 这个绑定会生成以下 HTML：
- en: '[PRE40]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The thing to note here is that the `li` element is binding against `name`, which
    is the property of a person. Inside the `foreach` binding, the binding context
    is the child element. If you need to refer to the child itself, you can either
    use `$data` or supply an alias to the `foreach` binding.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，`li` 元素绑定的是 `name`，这是人的属性。在 `foreach` 绑定内部，绑定上下文是子元素。如果你需要引用子元素本身，你可以使用
    `$data` 或为 `foreach` 绑定提供一个别名。
- en: 'The `$data` option is useful when the array only contains primitives that you
    want to bind against:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 当数组只包含你想要绑定的原始数据时，`$data` 选项很有用：
- en: '[PRE41]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `alias` option can clean up your code, but it is particularly useful when
    you have a nested context and want to refer to the parent. Refer to the following
    code:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: '`alias` 选项可以清理你的代码，但它特别有用，当你有一个嵌套上下文并且想要引用父级时。参考以下代码：'
- en: '[PRE42]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This can be achieved with `$parent`, of course, but it is more legible when
    using an `alias`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过 `$parent` 实现，当然，但使用 `alias` 时更易于阅读。
- en: Template binding
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 模板绑定
- en: 'The template binding is a special control flow binding. It has a parameter
    for each of the other control flow bindings. It might be more accurate to say
    that the other control flow bindings are all **aliases** for the template binding:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 模板绑定是一个特殊的控制流绑定。它为每个其他控制流绑定都有一个参数。可能更准确地说，其他控制流绑定都是模板绑定的 **别名**：
- en: '[PRE43]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Both of these are functionally equivalent. The template binding `as` has a parameter
    for `if` and `data` (which together make a `with` binding).
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个在功能上是等价的。模板绑定 `as` 有一个参数用于 `if` 和 `data`（它们一起构成了 `with` 绑定）。
- en: 'However, unlike the other control flow bindings, it can also generate its template
    from a named source using the `name` parameter. By default, the only source Knockout
    looks for is a `<script>` tag with an `id` parameter matching the `name` parameter:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，与其他控制流绑定不同，它还可以使用 `name` 参数从命名源生成模板。默认情况下，Knockout 只查找具有与 `name` 参数匹配的 `id`
    参数的 `<script>` 标签：
- en: '[PRE44]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: To stop the `script` block from being executed as JavaScript, you need a dummy
    script type, such as `text/html` or `text/ko`. Knockout will not apply bindings
    to script elements, but it will use them as a source for templates.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 要停止 `script` 块作为 JavaScript 执行，你需要一个虚拟的脚本类型，例如 `text/html` 或 `text/ko`。Knockout
    不会将绑定应用于脚本元素，但它将它们用作模板的源。
- en: Though it is much more common to use the inline templates seen in `foreach`
    or `with`, named templates have three very important uses.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在 `foreach` 或 `with` 中看到的内联模板使用得更为常见，但命名模板有三个非常重要的用途。
- en: Reusable templates
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可重用模板
- en: 'As templates can reference an external source for the HTML, it is possible
    to have multiple template bindings pointing to a single source:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板可以引用外部源来生成 HTML，因此可以有多个模板绑定指向单个源：
- en: '[PRE45]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: The branch `cp1-reuse` has an example of this technique.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp1-reuse` 分支有一个这个技巧的例子。'
- en: Recursive templates
  id: totrans-209
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 递归模板
- en: 'Because templates participate in data-binding themselves, it is possible for
    a template to bind against itself. If a template references itself, the result
    is recursive:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 由于模板本身参与数据绑定，因此模板可以绑定到自身。如果一个模板引用了自己，结果就是递归：
- en: '[PRE46]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The template reference in the preceding template is using the shorthand binding,
    which just takes the name of the template directly. When using this shorthand,
    the current binding context is used for the template's `data` parameter, which
    is perfect inside a `foreach` loop like this one. This is a common technique when
    using recursive templates, as trees of information are the most common place to
    find visual recursion.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个模板中使用的模板引用是使用缩写绑定，它直接使用模板的名称。当使用这种缩写时，当前绑定上下文用于模板的 `data` 参数，这在像这样的 `foreach`
    循环中是完美的。当使用递归模板时，这是一种常见的技巧，因为信息树是最常见的地方，可以找到视觉递归。
- en: An example of this recursive template is in the `cp1-recurse` branch.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 这个递归模板的例子在 `cp1-recurse` 分支中。
- en: Dynamic templates
  id: totrans-214
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态模板
- en: 'The name of the template in the previous example is a string, but it could
    be a property reference too. Binding the template name to an observable allows
    you to control which template is rendered. This could be useful to swap a viewmodel''s
    template between a display and edit mode. Consider this template binding:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 上一个例子中模板的名称是一个字符串，但它也可以是一个属性引用。将模板名称绑定到一个可观察的变量允许你控制要渲染哪个模板。这可能在交换视图模型的模板在显示和编辑模式之间非常有用。考虑这个模板绑定：
- en: '[PRE47]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'This template binding backed by a viewmodel property such as this one:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模板绑定由一个像这样的视图模型属性支持：
- en: '[PRE48]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: If we update the `editing` property from `true` to `false`, the template will
    re-render from `viewTemplate` to `editTemplate`. This allows us to programmatically
    switch between them.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们将 `editing` 属性从 `true` 更改为 `false`，模板将重新渲染从 `viewTemplate` 到 `editTemplate`。这允许我们通过编程方式在它们之间切换。
- en: An example of a dynamic edit/view template is in the `cp1-dynamic` branch.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一个动态编辑/查看模板的例子在 `cp1-dynamic` 分支中。
- en: In an advanced scenario, you could use a technique such as this for creating
    a generic container on a page to display entirely different views. Switching the
    template name and the data at the same time would mimic navigation, creating a
    **Single Page Application** (**SPA**). We will take a look at a similar technique
    when we get to [Chapter 4](part0037_split_000.html#page "Chapter 4. Application
    Development with Components and Modules"), *Application Development with Components
    and Modules*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 在一个高级场景中，你可以使用这种技术来在页面上创建一个通用的容器来显示完全不同的视图。同时切换模板名称和数据将模拟导航，创建一个**单页应用程序**（**SPA**）。当我们到达第
    4 章 [Chapter 4](part0037_split_000.html#page "Chapter 4. Application Development
    with Components and Modules")，*使用组件和模块进行应用程序开发*时，我们将查看一个类似的技术。
- en: Containerless control flow
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 无容器控制流
- en: So far, we have looked at using the control flow bindings (`if`, `with`, `foreach`,
    and `template`) and the standard `data-bind` attribute on an HTML element. It
    is also possible to use control flow bindings without an element by using special
    comment tags that are parsed by Knockout. This is called containerless control
    flow.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经探讨了使用控制流绑定（`if`、`with`、`foreach` 和 `template`）以及 HTML 元素上的标准 `data-bind`
    属性。还可能使用没有元素的控制流绑定，通过使用 Knockout 解析的特殊注释标签。这被称为无容器控制流。
- en: 'Adding a `<!— ko -->` comment starts a virtual element that ends with a `<!--
    /ko -->` comment. This virtual element causes a control flow binding to treat
    all contained elements as children. The following block of code demonstrates how
    sibling elements can be grouped by a virtual comment container:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 添加一个`<!— ko -->`注释开始一个以`<!-- /ko -->`注释结束的虚拟元素。这个虚拟元素会导致控制流绑定将所有包含的元素视为子元素。以下代码块演示了如何通过虚拟注释容器对兄弟元素进行分组：
- en: '[PRE49]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'List elements only allow specific elements as children. The preceding containerless
    syntax applies the `if` binding to the last two elements in the list, which causes
    them to add or remove from the DOM based in the `isAdmin` property:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 列表元素只允许特定的元素作为子元素。前面的无容器语法将`if`绑定应用于列表中的最后两个元素，这会导致它们根据`isAdmin`属性添加或从DOM中删除：
- en: '[PRE50]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The preceding containerless syntax allows us to have a `foreach` binding to
    create a list of items while maintaining a header item at the top of the list.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的无容器语法允许我们有一个`foreach`绑定来创建一个项目列表，同时保持列表顶部的标题项。
- en: All of the control flow bindings can be used in this way. The preceding two
    examples can be seen in the `cp1-containerless` branch.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的控制流绑定都可以这样使用。前面的两个例子可以在`cp1-containerless`分支中看到。
- en: Extenders
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 扩展器
- en: 'The last "basic" feature to cover is extenders (don''t worry, there is still
    plenty of advanced stuff to cover). Extenders offer a way to modify individual
    observables. Two common uses of extenders are as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要介绍的是扩展器（别担心，还有很多高级内容要介绍）。扩展器提供了一种修改单个可观察对象的方法。扩展器的两种常见用途如下：
- en: Adding properties or functions to the observable
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向可观察对象添加属性或函数
- en: Adding a wrapper around the observable to modify writes or reads
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可观察对象周围添加包装器以修改写入或读取
- en: Simple extenders
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 简单扩展器
- en: 'Adding an extender is as simple as adding a new function to the `ko.extenders`
    object with the name you want to use. This function receives the observable being
    extended (called the target) as the first argument, and any configuration passed
    to the extender is received as the second argument, as shown in the following
    code:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 添加扩展器就像向`ko.extenders`对象添加一个新函数一样简单，使用你想要使用的名称。这个函数接收被扩展的可观察对象（称为目标）作为第一个参数，并且任何传递给扩展器的配置作为第二个参数接收，如下面的代码所示：
- en: '[PRE51]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This extender will create a new `previousValues` property on the observable.
    This new property is as an observable array and old values are pushed to it as
    the original observable is changed (the current value is already in the observable
    of course).
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展器将在可观察对象上创建一个新的`previousValues`属性。这个新属性是一个可观察数组，当原始可观察对象发生变化时（当然当前值已经在可观察对象中），旧值会被推送到它里面。
- en: 'The reason the extender has to return the target is because the result of the
    extender is the new observable. The need for this is apparent when looking at
    how the extender is called:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展器必须返回目标的原因是扩展器的结果是新的可观察对象。这种需求在查看扩展器是如何被调用的时候很明显：
- en: '[PRE52]'
  id: totrans-239
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: The `true` value sent to `recordChanges` is received by the extender as the
    `options` parameter. This value can be any JavaScript value, including objects
    and functions.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 发送到`recordChanges`的`true`值作为`options`参数被扩展器接收。这个值可以是任何JavaScript值，包括对象和函数。
- en: 'You can also add multiple extenders to an observable in the same call. The
    object sent to the `extend` method will call an observable for every property
    it contains:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在同一个调用中将多个扩展器添加到可观察对象中。发送到`extend`方法的对象将为它包含的每个属性调用一个可观察对象：
- en: '[PRE53]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: As the `extend` method is called on the observable, usually during its initial
    creation, the result of the `extend` call is what is actually stored. If the target
    is not returned, the `amount` variable would not be the intended observable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 当在可观察对象上调用`extend`方法时，通常是在其初始创建期间，`extend`调用的结果才是实际存储的内容。如果目标没有返回，`amount`变量就不会是预期的可观察对象。
- en: To access the extended value, you would use `amount.previousValues()` from JavaScript,
    or `amount.previousValues` if accessing it from a binding. Note the lack of parentheses
    after amount; because `previousValues` is a property of the observable, not a
    property of the observable's value, it is accessed directly. This might not be
    immediately obvious, but it should make sense as long as you remember that the
    observable and the value the observable contains are two different JavaScript
    objects.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问扩展的值，您可以使用 JavaScript 中的 `amount.previousValues()`，或者如果从绑定中访问则为 `amount.previousValues`。注意
    `amount` 后面没有括号；因为 `previousValues` 是可观察者的一个属性，而不是可观察者值的属性，它可以直接访问。这可能一开始不太明显，但只要您记住可观察者和可观察者包含的值是两个不同的
    JavaScript 对象，这应该是有意义的。
- en: An example of this extender is in the `cp1-extend` branch.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展器的一个例子在 `cp1-extend` 分支中。
- en: Extenders with options
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 带有选项的扩展器
- en: The previous example does not pass any options to the `recordChanges` extender,
    it just uses `true` because the property requires a value to be a valid JavaScript.
    If you want a configuration for your extender, you can pass it as this value,
    and a complex configuration can be achieved by using another object as the value.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的示例没有向 `recordChanges` 扩展器传递任何选项，它只是使用 `true`，因为该属性需要一个有效的 JavaScript 值。如果您想为扩展器提供一个配置，您可以将其作为此值传递，并通过使用另一个对象作为值来实现复杂的配置。
- en: 'If we wanted to supply a list of values that are not to be recorded, we could
    modify the extender to use the options as an array:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想要提供一个不希望记录的值的列表，我们可以修改扩展器以使用选项作为数组：
- en: '[PRE54]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'Then we could call the extender with an array:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以使用数组调用扩展器：
- en: '[PRE55]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Now our `history` observable won't record values for `0` or `null`.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的 `history` 可观察者不会为 `0` 或 `null` 记录值。
- en: Extenders that replace the target
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换目标的扩展器
- en: Another common use for extenders is to wrap the observable with a computed observable
    that modifies reads or writes, in which case, it would return the new observable
    instead of the original target.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展器的另一个常见用途是将可观察者包装在一个计算可观察者中，该计算可观察者修改读取或写入，在这种情况下，它会返回新的可观察者而不是原始目标。
- en: 'Let''s take our `recordChanges` extender a step further and actually block
    writes that are in our `ignore` array (never mind that an extender named `recordChanges`
    should never do something like this in the real world!):'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们把 `recordChanges` 扩展器再进一步，并实际上阻止 `ignore` 数组中的写入（不要在意名为 `recordChanges` 的扩展器在现实世界中永远不应该做这样的事情！）：
- en: '[PRE56]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: That's a lot of changes, so let's unpack them.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 这有很多更改，所以让我们来分解它们。
- en: First, to make `ignore` easier to reference, I've set a new variable that will
    either be the `options.ignore` property or an empty array. Defaulting to an empty
    array lets us skip the null check later, which makes the code a little easier
    to read. Second, I created a writable computed observable. The `read` function
    just routes to the target observable, but the `write` function will only write
    to the target if the `ignore` option doesn't contain the new value. Otherwise,
    it will notify the target subscribers of the old value. This is necessary because
    if a UI binding on the observable initiated the change, it needs the illegal change
    to be reverted. The UI element would already have updated and the easiest way
    to change it back is through the standard binding notification mechanism that
    is already listening for changes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为了使 `ignore` 更容易引用，我设置了一个新变量，该变量将是 `options.ignore` 属性或一个空数组。默认为空数组让我们可以跳过后面的
    null 检查，这使得代码更容易阅读。其次，我创建了一个可写的计算可观察者。`read` 函数只是将路由到目标可观察者，但 `write` 函数只有在 `ignore`
    选项不包含新值时才会写入目标。否则，它将通知目标订阅者旧值。这是必要的，因为如果 UI 绑定在可观察者上触发了更改，则需要撤销非法更改。UI 元素已经更新，最容易将其更改回原来的方式是通过标准绑定通知机制，该机制已经监听更改。
- en: 'The last change is the `notify: always` extender that''s on the `result`. This
    is one of Knockout''s default extenders. Normally, an observable will only report
    changes to subscribers when the value has been modified. To get the observable
    to reject changes, it needs to be able to notify subscribers of its current unchanged
    value. The notify extender forces the observable to always report changes, even
    when they are the same.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '最后的更改是位于 `result` 上的 `notify: always` 扩展器。这是 Knockout 的默认扩展器之一。通常，一个可观察者只有在值被修改时才会向订阅者报告更改。为了使可观察者能够拒绝更改，它需要能够通知订阅者其当前未更改的值。通知扩展器强制可观察者始终报告更改，即使它们是相同的。'
- en: Finally, the extender returns the new computed observable instead of the target,
    so that anyone trying to write a value does so against the computed.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，扩展器返回新的计算可观察值而不是目标，这样任何尝试写入值的人都会针对计算进行操作。
- en: The `cp1-extendreplace` branch has an example of this binding. Notice that trying
    to enter values into the input box that are included in the ignored options (`0`
    or an empty string) are immediately reverted.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '`cp1-extendreplace`分支有一个这种绑定的例子。注意，尝试输入包含在忽略选项中（`0`或空字符串）的值会立即被撤销。'
- en: The Contacts List application
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 联系人列表应用程序
- en: It's time to start putting these concepts together into a usable application.
    Isolated samples can only take you so far. We are going to cover the application
    in the `cp1-contacts` branch in detail. The application's functionality is all
    on the **Contacts** page, which you can get to from the navigation bar in your
    browser. Before we start digging into the code, I encourage you to play around
    with the application a bit (it does persist data). It will help in understanding
    the relationships in the code.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 是时候将这些概念组合成一个可用的应用程序了。孤立的样本只能带你走这么远。我们将详细介绍`cp1-contacts`分支中的应用程序。应用程序的功能全部在**联系人**页面上，您可以通过浏览器中的导航栏访问它。在我们开始深入代码之前，我鼓励您先玩一下这个应用程序（它确实会持久化数据）。这将有助于理解代码中的关系。
- en: Overview
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 概述
- en: 'The application has three main JavaScript objects:'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 该应用程序有三个主要的JavaScript对象：
- en: The contact model
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人模型
- en: The **Contacts** page viewmodel
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**联系人**页面视图模型'
- en: The mock data service
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模拟数据服务
- en: The application only uses the HTML in the `index.html` file, but the two sections
    are mostly independent.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序仅使用`index.html`文件中的HTML，但这两个部分基本上是独立的。
- en: The entry form (create and edit)
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入表单（创建和编辑）
- en: The contacts list
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 联系人列表
- en: 'The JavaScript code in the example follows the **Immediately-Invoked Function
    Expression** (**IIFE**) pattern (sometimes pronounced "iffy") to isolate code
    from the global scope, and a namespace called `app` to share code between files:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 示例中的JavaScript代码遵循**立即调用的函数表达式**（**IIFE**）模式（有时发音为“iffy”），以隔离代码与全局作用域，并使用一个名为`app`的命名空间在文件之间共享代码：
- en: '[PRE57]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'This is definitely not the only way to organize JavaScript code, and you may
    have a pattern you prefer. If you want to understand this pattern better, here
    are a few online resources:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是组织JavaScript代码的唯一方式，你可能有一个你更喜欢的模式。如果你想更好地理解这个模式，这里有一些在线资源：
- en: '[http://benalman.com/news/2010/11/immediately-invoked-function-expression/](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://benalman.com/news/2010/11/immediately-invoked-function-expression/](http://benalman.com/news/2010/11/immediately-invoked-function-expression/)'
- en: '[http://addyosmani.com/blog/essential-js-namespacing/](http://addyosmani.com/blog/essential-js-namespacing/)'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://addyosmani.com/blog/essential-js-namespacing/](http://addyosmani.com/blog/essential-js-namespacing/)'
- en: The contact model
  id: totrans-277
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联系人模型
- en: The `client/app/contacts.js` file defines our basic contact object. Let's go
    over it piece by piece.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: '`client/app/contacts.js`文件定义了我们的基本联系人对象。让我们逐个分析它。'
- en: 'It starts with a standard declaration of observable properties with some default
    values. There are a lot of reasons to organize code in a variety of ways, but
    for the smaller models, I prefer to keep all of their persistable properties together
    at the top:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 它从一个标准的可观察属性声明开始，并带有一些默认值。有许多理由以不同的方式组织代码，但对于较小的模型，我更喜欢将它们的所有可持久属性一起放在顶部：
- en: '[PRE58]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Next is the `displayName` property, some simple logic to generate a nice "title"
    for UI display. The JavaScript or operator (`||`) is used here to ensure we don''t
    try to read the `length` property on a `null` or `undefined` value by returning
    a default value in case all the names are empty. This essentially makes it a null-coalescing
    operator when used during an assignment:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`displayName`属性，一些简单的逻辑来生成一个漂亮的“标题”用于UI显示。这里使用了JavaScript的或运算符（`||`），以确保我们不会尝试在`null`或`undefined`值上读取`length`属性，在这种情况下，会返回一个默认值。这实际上使得它在赋值时成为一个空合并运算符：
- en: '[PRE59]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Next is a utility method to update the model that accepts an object and merges
    in its properties. I generally put a similar method onto all of my models so that
    I have a standard way of updating them. Once again, we are using `||` as a safety
    net, in case the method is called without a parameter (in the real world, you
    would want a stronger check, one that ensured `update` was an object and not a
    primitive value or an array):'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是一个更新模型的实用方法，它接受一个对象并将其属性合并进来。我通常在我的所有模型上放一个类似的方法，这样我就可以有一个标准的方式来更新它们。再一次，我们使用
    `||` 作为安全网，以防方法在没有参数的情况下被调用（在现实世界中，你希望有一个更强的检查，确保 `update` 是一个对象而不是原始值或数组）：
- en: '[PRE60]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Also note that after defining the `update` function, the model calls it with
    the constructor argument. This lets the constructor provide the ability to create
    a new model from existing data and partial data as well. This is very useful when
    deserializing data, for example, JSON from an Ajax request.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 还要注意，在定义 `update` 函数之后，模型会使用构造函数参数来调用它。这使得构造函数能够从现有数据以及部分数据中创建新的模型。这在反序列化数据时非常有用，例如，从
    Ajax 请求中获取 JSON。
- en: Lastly, we have the `toJSON` method. The standard `JSON.stringify` method in
    JavaScript will look for this method to allow an object to control how it is serialized.
    As Knockout's `ko.toJSON` calls `JSON.stringify` underneath after it unwraps all
    the observables so that the serialization gets values and not functions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们有 `toJSON` 方法。JavaScript 中的标准 `JSON.stringify` 方法会查找这个方法，以便对象可以控制其序列化方式。Knockout
    的 `ko.toJSON` 在展开所有可观察对象之后会调用 `JSON.stringify`，这样序列化就会得到值而不是函数。
- en: 'As the serialized form of our model is the one we will try to persist, usually
    by sending it to the server with Ajax, we don''t want to include things such as
    our computed display name. Our `toJSON` method override takes care of this by
    just deleting the property:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们模型的序列化形式是我们将尝试持久化的形式，通常是通过使用 Ajax 将其发送到服务器，我们不希望包含诸如我们的计算显示名称之类的东西。我们的 `toJSON`
    方法覆盖通过仅删除属性来处理这个问题：
- en: '[PRE61]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The copy with `ko.toJS` is important. We don't want to delete `displayName`
    from the actual model; we only want it removed from the serialized model. If we
    made the variable with `copy = self`, we would just have a reference to the same
    object. The `ko.toJS` method is a simple way to get a plain JavaScript copy that
    we can safely delete properties from without affecting the original object.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `ko.toJS` 进行复制很重要。我们不希望从实际模型中删除 `displayName`；我们只想从序列化模型中移除它。如果我们用 `copy
    = self` 创建变量，我们只会得到对同一个对象的引用。`ko.toJS` 方法是一种简单的方式，可以获取一个纯 JavaScript 复制，我们可以安全地从中删除属性而不影响原始对象。
- en: The Contacts page viewmodel
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 联系人页面视图模型
- en: The `client/app/contactspage.js` file defines the viewmodel for the **Contacts**
    page. Unlike our contacts model, the page does a lot more than expose some observable
    properties, and it isn't designed to be constructed from existing data either.
    Instead of taking an object to control its starting values, which doesn't make
    much sense for a page, the constructor's argument is designed for dependency injection;
    its constructor arguments take in its external dependencies.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`client/app/contactspage.js` 文件定义了 **Contacts** 页面的视图模型。与我们的联系人模型不同，该页面做的不仅仅是暴露一些可观察属性，它也不是为了从现有数据中构建而设计的。它不是通过接受一个对象来控制其起始值，这对于一个页面来说没有太多意义，其构造函数的参数是为了依赖注入设计的；它的构造函数参数接受其外部依赖项。'
- en: 'In this example, `dataService` is a dependency used by the page viewmodel:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`dataService` 是页面视图模型使用的依赖项：
- en: '[PRE62]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Very briefly, if you aren''t familiar with dependency injection, it lets us
    define our page against an API (sometimes called a contract or interface) of methods
    to get and save data. This is especially useful for us, as in this sample application,
    we aren''t using real Ajax but mocking it with an object that just writes to the
    DOM''s local storage:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 简单来说，如果你不熟悉依赖注入，它允许我们定义我们的页面针对一个 API（有时称为合同或接口）的方法来获取和保存数据。这对我们来说特别有用，因为在本示例应用程序中，我们没有使用真实的
    Ajax，而是用一个只向 DOM 的本地存储写入的对象来模拟它：
- en: '[PRE63]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For more information on the DOM local storage, see the page on the Mozilla Developer
    Network at [https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于 DOM 本地存储的信息，请参阅 Mozilla 开发者网络上的页面：[https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage](https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage)。
- en: However, when we write the real Ajax service later, our `ContactsPageViewmodel`
    doesn't need to change at all. We will just construct it with a different `dataService`
    parameter. As long as they expose the same methods (the same API) it will just
    work.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们稍后编写实际的 Ajax 服务时，我们的 `ContactsPageViewmodel` 实际上不需要任何更改。我们只需用不同的 `dataService`
    参数来构建它。只要它们公开相同的方法（相同的 API），它就会正常工作。
- en: 'The first section inside the constructor is for the contacts list. We expose
    an observable array and get the contacts from our data service:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数内的第一个部分是用于联系列表的。我们公开一个可观察数组，并从我们的数据服务获取联系：
- en: '[PRE64]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: We are passing callback to the `getContacts` call because our data service provides
    an asynchronous API. When the data service has finished getting our contacts,
    it will call the callback with them. All our callback needs to do is put them
    into the `contacts` array.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将回调传递给 `getContacts` 调用，因为我们的数据服务提供了一个异步 API。当数据服务完成获取我们的联系后，它将使用它们调用回调。我们的回调需要做的只是将它们放入
    `contacts` 数组。
- en: 'The next block of code is to control the **CRUD** (**Create, Read, Update,
    Delete**) operations for individual contacts. First, we expose an observable object
    that we will use for all edits:'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 下一段代码是用来控制单个联系 **CRUD**（**创建、读取、更新、删除**）操作的。首先，我们公开一个我们将用于所有编辑的可观察对象：
- en: '[PRE65]'
  id: totrans-303
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Our UI is going to bind an edit form against the `entryContact` property. The
    entry contact property is pulling a double duty here; it contains the contact
    that is being created or edited, and it indicates that editing is occurring. If
    the entry contact is null, then we aren't editing; if it has an object, then we
    are editing. The UI will use `with` and `if` bindings to control which content
    to show based on this logic.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 UI 将将编辑表单绑定到 `entryContact` 属性。在这里，条目联系属性承担双重职责；它包含正在创建或编辑的联系，并指示正在发生编辑。如果条目联系为空，则表示我们不在编辑；如果它有一个对象，则表示我们正在编辑。UI
    将使用 `with` 和 `if` 绑定来根据此逻辑控制显示哪些内容。
- en: The `newEntry` and `cancelEntry` functions provide the UI with a means to switch
    between these two states.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`newEntry` 和 `cancelEntry` 函数为 UI 提供了在两种状态之间切换的手段。'
- en: 'For editing existing contacts, we just expose another function that takes a
    contact and sets the entry contact to it:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 对于编辑现有联系，我们只需公开另一个函数，该函数接受一个联系并将其设置为条目联系：
- en: '[PRE66]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The last thing we need for real editing is the ability to persist our changes.
    As in the real world, we have three scenarios, namely creating new objects, saving
    existing objects, and deleting existing objects.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 对于真正的编辑，我们需要的最后一件事是能够持久化我们的更改。正如现实世界一样，我们有三种情况，即创建新对象、保存现有对象和删除现有对象。
- en: 'Creating and updating are both going to be done using the `entryContact` property,
    and we want to be able to bind the same form for both, which means we need to
    target a single function:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 创建和更新都将使用 `entryContact` 属性来完成，我们希望能够为两者绑定相同的表单，这意味着我们需要针对单个函数：
- en: '[PRE67]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'Internally, our `saveEntry` method checks for a non-default `id` value to determine
    whether or not it''s making a new object or updating an existing one. Both are
    calls to the data service using the entry contact with a callback to clear the
    `entryContact` property out (as we are done with editing). In the creation case,
    we also want to add the newly created contact to our local list of contacts before
    emptying the entry contact:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，我们的 `saveEntry` 方法会检查非默认的 `id` 值，以确定是创建新对象还是更新现有对象。这两种情况都是调用数据服务，使用条目联系并带有回调来清除
    `entryContact` 属性（因为我们已经完成了编辑）。在创建的情况下，我们希望在清空条目联系之前，将新创建的联系添加到我们本地的联系列表中：
- en: '[PRE68]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You might think that the contact is going to be null out by the second line,
    but that is not the case. The `entryContact` property is an observable and its
    value is a contact. The first line reads this value and pushes it into the `contacts`
    array. The second line sets the value of the `entryContact` property to `null`;
    it does not affect the contact that was just pushed. It's the same as if we had
    set a variable to null after adding it to an array. The variable was a reference
    to the object, and making the variable null removes the reference, not the object
    itself.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为联系会在第二行被置为空，但这并不是事实。`entryContact` 属性是一个可观察对象，其值是一个联系。第一行读取这个值并将其推入 `contacts`
    数组。第二行将 `entryContact` 属性的值设置为 `null`；它不会影响刚刚推入的联系。这就像我们在将对象添加到数组后将其变量设置为空一样。变量是对对象的引用，将变量设置为空会移除引用，而不是对象本身。
- en: 'The delete function is simple by comparison:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 与之相比，删除函数很简单：
- en: '[PRE69]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: It's going to take an existing contact, like `editContact` did, and call the
    data service. As we are deleting the contact, the only thing we need is the `id`
    property. The callback will remove the contact from the list of contacts when
    the service is done, using the `remove` function provided on all observable arrays
    by Knockout.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 它将使用现有的联系人，比如`editContact`所做的那样，并调用数据服务。当我们删除联系人时，我们只需要`id`属性。回调将在服务完成后使用Knockout提供的`remove`函数从联系人列表中删除联系人。
- en: 'The last piece of functionality on the page is the search mechanism. It starts
    with an observable to track the search and a function to clear it out:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 页面上最后的功能是搜索机制。它从一个可观察的变量开始跟踪搜索，并有一个清除搜索的功能：
- en: '[PRE70]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'The `query` property is going to be used to filter out any contacts that don''t
    have a matching or partially-matching property. If we wanted to be as flexible
    as possible, we could search against every property. However, since our list of
    contacts is only going to show our computed `displayName` and phone number, it
    would look odd to return results matching on properties we didn''t show. This
    is the computed observable from the code sample that filters the contacts list:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '`query`属性将被用来过滤掉任何没有匹配或部分匹配属性的联系人。如果我们想要尽可能灵活，我们可以对每个属性进行搜索。然而，由于我们的联系人列表只显示计算出的`displayName`和电话号码，返回匹配我们未显示的属性的搜索结果看起来会很奇怪。这是代码示例中从联系人列表中进行过滤的计算可观察变量：'
- en: '[PRE71]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Note
  id: totrans-321
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you want to filter all of the contact's properties, they are listed in the
    repository code as comments. They can easily be re-enabled by uncommenting each
    line.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想过滤联系人的所有属性，它们在代码库中以注释的形式列出。它们可以通过取消注释每一行轻松重新启用。
- en: First, we check to see whether the query is empty, because if it is, we aren't
    going to filter anything so we don't want to waste cycles iterating the contacts
    anyway.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们检查查询是否为空，因为如果为空，我们不会过滤任何东西，所以我们不想浪费周期去迭代联系人。
- en: Before starting, we call the `toLowerCase()` function on the query to avoid
    any case sensitivity issues. Then, we iterate on the contacts. Knockout provides
    several utilities methods for arrays (among other things) on the `ko.utils` object.
    The `arrayFilter` function takes an array and an iterator function, which is called
    on each element of the array. If the function returns `true`, `arrayFilter` will
    include that element in its return value; otherwise it will filter the element
    out. All our iterator needs to do is compare the properties we want to keep the
    filter on (remembering to put them in lowercase first).
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始之前，我们调用`toLowerCase()`函数对查询进行转换，以避免任何大小写敏感的问题。然后，我们在联系人上迭代。Knockout在`ko.utils`对象上提供了几个数组相关的实用方法（以及其他功能）。`arrayFilter`函数接受一个数组和迭代函数，该函数会在数组的每个元素上被调用。如果函数返回`true`，`arrayFilter`将包括该元素在其返回值中；否则，它将过滤掉该元素。我们迭代器需要做的只是比较我们想要保留的过滤属性（记得首先将它们转换为小写）。
- en: Now if the UI binds against `displayContacts`, the search functionality will
    filter the UI.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在如果UI绑定到`displayContacts`，搜索功能将过滤UI。
- en: 'However, we might experience poor performance with a large list of contacts
    if we are looping through them all every time the query is updated, especially
    if the query updates every time a key is pressed. To address this, we can use
    the standard Knockout `rateLimit` extender on our filtered computed to stop it
    from updating too frequently:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们每次查询更新时都要遍历所有联系人，特别是如果查询在每次按键时更新，我们可能会遇到大量联系人列表的较差性能。为了解决这个问题，我们可以在我们的过滤计算上使用标准的Knockout
    `rateLimit` 扩展器来阻止它过于频繁地更新：
- en: '[PRE72]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'This extender has two modes: `notifyAtFixedRate` and `notifyWhenChangesStop`.
    These two options will throttle or debounce the computed.'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 这个扩展器有两个模式：`notifyAtFixedRate`和`notifyWhenChangesStop`。这两个选项将节流或去抖动计算。
- en: Note
  id: totrans-329
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you aren't familiar with the throttling and debouncing functions, there is
    an excellent explanation with visuals at [http://drupalmotion.com/article/debounce-and-throttle-visual-explanation](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation).
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不太熟悉节流和去抖动函数，[http://drupalmotion.com/article/debounce-and-throttle-visual-explanation](http://drupalmotion.com/article/debounce-and-throttle-visual-explanation)上有很好的解释和视觉演示。
- en: This lets us control how often the computed re-evaluates itself. The preceding
    example will only re-evaluate the computed once all dependencies have stopped
    changing for 100 ms. This will let the UI update when the query typing settles
    down while still appearing to filter as the user types.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 这让我们可以控制计算重新评估自身的频率。前面的例子只有在所有依赖项停止变化100毫秒后，计算才会重新评估一次。这将允许在查询输入稳定下来时更新UI，同时仍然看起来像用户输入时那样进行过滤。
- en: A philosophical note on a model versus a viewmodel
  id: totrans-332
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于模型与视图模型的一个哲学思考
- en: The line between model and viewmodel in client-server application can get blurry,
    and even after reading Knockout's documentation ([http://knockoutjs.com/documentation/observables.html](http://knockoutjs.com/documentation/observables.html))
    it can be unclear whether or not our contact object is really a model or viewmodel.
    Most would probably argue that it is a viewmodel as it has observables. I like
    to think of these smaller objects, which are barely more than their persisted
    data, as models and to think of viewmodels as the objects containing operations
    and view representations, such as our **Contacts** page viewmodel `removeContact`
    operation or the `entryContact` property.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端-服务器应用程序中，模型和视图模型之间的界限可能会变得模糊，即使阅读了Knockout的文档([http://knockoutjs.com/documentation/observables.html](http://knockoutjs.com/documentation/observables.html))，也可能不清楚我们的联系人对象是否真的是模型或视图模型。大多数人可能会争辩说它是一个视图模型，因为它有可观察属性。我喜欢将这些较小的对象视为模型，并将视图模型视为包含操作和视图表示的对象，例如我们的**联系人**页面视图模型中的`removeContact`操作或`entryContact`属性。
- en: Mock data service
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模拟数据服务
- en: Normally, you would use an Ajax call, probably with jQuery, to retrieve data
    and submit data to and from the server. Because this is a book on Knockout and
    not Node.js, I wanted to keep the server as thin as possible. From the "Mastering
    Knockout" perspective, whether we call a JavaScript object making Ajax requests
    or store it in the DOM is immaterial. As long as we are working with something
    that looks and functions like an asynchronous service, we can explore how Knockout
    viewmodels might interact with it. That being said, there is some functionality
    in the data service that would be used in an Ajax data service object, and it
    is interesting from a Knockout application development perspective.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，你会使用Ajax调用，可能配合jQuery，来检索数据并将数据从服务器提交和检索。因为这是一本关于Knockout的书，而不是Node.js，我想尽量保持服务器尽可能瘦。从“精通Knockout”的角度来看，我们调用一个制作Ajax请求的JavaScript对象或将其存储在DOM中并不重要。只要我们正在处理看起来和功能像异步服务的东西，我们就可以探索Knockout视图模型如何与之交互。话虽如此，数据服务中确实有一些功能会在Ajax数据服务对象中使用，并且从Knockout应用程序开发的角度来看是很有趣的。
- en: 'You might have noticed in the previous section that when the **Contacts** page
    view model communicated with the data service, it wasn''t dealing with JSON but
    real JavaScript objects. In fact, not even plain JavaScript objects but our contact
    model. This is because part of the data service''s responsibility, whether it''s
    a mock or a real Ajax service, is to abstract away the knowledge of the service
    mechanisms. In our case, this means translating between JSON and our Knockout
    models:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在前一节中注意到，当**联系人**页面视图模型与数据服务通信时，它并没有处理JSON，而是处理真实的JavaScript对象。实际上，甚至不是普通的JavaScript对象，而是我们的联系人模型。这是因为数据服务的一部分责任，无论是模拟还是真实的Ajax服务，都是抽象化服务机制的知识。在我们的情况下，这意味着在JSON和我们的Knockout模型之间进行转换：
- en: '[PRE73]'
  id: totrans-337
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: This is the `createContact` method from our mock data service if it was rewritten
    to use real Ajax (this code is in the `mockDataService.js` file as a comment).
    The data service is part of our application, so it knows that it's working with
    observable properties and that it needs to translate them into plain JavaScript
    for jQuery to properly serialize it, so it unwraps the contact that it's given
    with `ko.toJS`. Then, in the `done` handler, it takes the `id` that it gets back
    from the server's response and updates the contact's observable `id` property
    with it. Finally, it calls the callback to signify that it's done.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将我们的模拟数据服务中的`createContact`方法重写为使用真实的Ajax（此代码在`mockDataService.js`文件中作为注释），那么它看起来是这样的。数据服务是我们应用程序的一部分，因此它知道它正在处理可观察属性，并且需要将它们转换为纯JavaScript以便jQuery能够正确序列化，因此它使用`ko.toJS`解包它提供的联系人。然后，在`done`处理程序中，它从服务器的响应中获取`id`，并使用它更新联系人的可观察`id`属性。最后，它调用回调来表示已完成。
- en: You might wonder why it doesn't pass `contact` as an argument to the callback.
    It certainly could, but it isn't necessary. The original caller already had the
    contact, and the only thing that the caller is going to need is the new `id` value.
    We've already updated the `id`, and as it's observable, any subscriber will pick
    that new value up. If we needed some special handling before setting the `id`
    value, that would be a different case and we could raise the callback with `id`
    as an argument.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能会想知道为什么它没有将`contact`作为参数传递给回调。当然可以，但这是不必要的。原始调用者已经有了联系人，调用者唯一需要的是新的`id`值。我们已经更新了`id`，由于它是可观察的，任何订阅者都会获取那个新值。如果我们需要在设置`id`值之前进行一些特殊处理，那将是另一种情况，并且我们可以通过将`id`作为参数传递来引发回调。
- en: The view
  id: totrans-340
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图
- en: Hopefully, you have already played with the application a bit. If you haven't,
    now is the time. I'll wait.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 希望您已经稍微玩过这个应用程序。如果您还没有，现在就是时候了。我会等待。
- en: You would have noticed that when adding or editing contacts, the contacts list
    is removed. What you might not have noticed is that the URL doesn't change; the
    browser isn't actually navigating when we switch between these two views. Though
    they are in the same HTML file, these two different views are mostly independent
    and they are controlled through a `with` and an `ifnot` binding.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 当您添加或编辑联系人时，您可能会注意到联系人列表被移除。您可能没有注意到的是，URL并没有改变；当我们在这两个视图之间切换时，浏览器实际上并没有进行导航。尽管它们在同一个HTML文件中，但这两个不同的视图基本上是独立的，并且它们通过`with`和`ifnot`绑定来控制。
- en: The edit form
  id: totrans-343
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编辑表单
- en: 'This is what is shown when adding or editing contacts:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在添加或编辑联系人时显示的内容：
- en: '[PRE74]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Because the `with` binding is also implicitly an `if` binding, the entire form
    is hidden when the `entryContact` property is null or undefined.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`with`绑定也是隐式的`if`绑定，因此当`entryContact`属性为null或undefined时，整个表单会被隐藏。
- en: The rest of the form is pretty straightforward. A `submit` binding is used so
    that clicking the save button or hitting the enter key on any field calls the
    submit handler, a header showing the display name, value bindings for each field,
    a save button with `type="submit`" (so that it uses the submit handler), and a
    cancel button that binds to `$parent.cancelEntry`. Remember, the `$parent` scope
    is necessary because the `with` binding creates a binding context on the `entry`
    contact and `cancelEntry` is a function on `ContactPageViewmodel`.
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 表单的其余部分相当直接。使用`submit`绑定，以便点击保存按钮或按任何字段的回车键都会调用提交处理程序，显示显示名称的标题，每个字段的值绑定，一个带有`type="submit"`的保存按钮（以便它使用提交处理程序），以及一个绑定到`$parent.cancelEntry`的取消按钮。记住，`$parent`作用域是必要的，因为`with`绑定在`entry`联系人上创建了一个绑定上下文，而`cancelEntry`是`ContactPageViewmodel`上的一个函数。
- en: Contacts list
  id: totrans-348
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 联系人列表
- en: 'The list starts with an `ifnot` binding on the `entryContact` property, ensuring
    that it only shows in the case that the previous form is hidden. We only want
    one or the other to be seen at a time:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 列表从`entryContact`属性的`ifnot`绑定开始，确保只有在上一个表单隐藏的情况下才会显示。我们只想一次看到其中一个：
- en: '[PRE75]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: The search input has a `value` binding as well as the `valueUpdate` option.
    The value update option controls when the `value` binding reports changes. By
    default, changes are reported on blur, but the `afterkeydown` setting causes changes
    to be reported immediately after the input gets a new letter. This would cause
    the search to update in real time, but remember that the display contacts have
    a `rateLimit` extender that debounces the updates to 100 ms.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 搜索输入具有`value`绑定以及`valueUpdate`选项。值更新选项控制`value`绑定何时报告更改。默认情况下，更改在失去焦点时报告，但`afterkeydown`设置会导致在输入获得新字母后立即报告更改。这将导致搜索实时更新，但请记住，显示的联系人有一个`rateLimit`扩展器，它将更新延迟到100毫秒。
- en: Next to the search box is a button to add a new contact. Then, of course, the
    list of contacts is bound with a `foreach` binding on the `displayContacts` property.
    If it was bound against `contacts` directly, the list would not show the filtering.
    Depending on your application, you might even want to keep the unfiltered contacts
    list private and only expose the filtered lists. The best option really does depend
    on what else you're doing, and in most cases, it's okay to use your personal preference.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在搜索框旁边有一个按钮用于添加新的联系人。然后，当然，联系人列表通过在`displayContacts`属性上的`foreach`绑定来绑定。如果它直接绑定到`contacts`，则列表将不会显示过滤功能。根据您的应用程序，您甚至可能希望保留未过滤的联系人列表为私有，并且仅公开过滤后的列表。最佳选项实际上取决于您正在做什么，在大多数情况下，使用您的个人偏好是完全可以的。
- en: Inside the contacts list, each item shows the display name for the phone number,
    with a button to edit or delete the contact. As `foreach` creates a binding context
    on the individual contact and the edit and delete functions are on the parent,
    the `click` binding uses the `$parent` context property. The `click` binding also
    sends the current model to each of the edit and delete functions, so that these
    functions don't have to try to find the right JavaScript object by looking through
    the full list.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 在联系人列表中，每个条目都显示了电话号码的显示名称，并有一个按钮来编辑或删除联系人。由于 `foreach` 在单个联系人上创建了一个绑定上下文，而编辑和删除功能在父级上，因此
    `click` 绑定使用了 `$parent` 上下文属性。`click` 绑定还将当前模型发送到每个编辑和删除函数，这样这些函数就不必通过遍历整个列表来尝试找到正确的
    JavaScript 对象。
- en: That's really all there is to the application. We've got a list view with searching
    that switches to a view that's reused easily for both editing and creating.
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是应用程序的全部内容。我们有一个带有搜索功能的列表视图，它可以切换到易于重用的视图，用于编辑和创建。
- en: Summary
  id: totrans-355
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In most of this chapter, we reviewed the use of standard Knockout. Hopefully,
    I didn''t lose you in the weeds back there. The important thing is that before
    we move on to extending Knockout with custom functionality or building larger
    applications, you must feel comfortable with the basic use of observables and
    data binding. This includes:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的大部分内容中，我们回顾了标准 Knockout 的使用。希望我没有在细节中迷失你的注意力。重要的是，在我们继续使用自定义功能扩展 Knockout
    或构建更大的应用程序之前，你必须对可观察对象和数据绑定的基本使用感到舒适。这包括：
- en: '`**Extenders**`**: This includes creating extenders and extending observables**'
  id: totrans-357
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`**扩展器**`**: 这包括创建扩展器和扩展可观察对象**'
- en: '****Templates**: This tells us how the flow of control works, what a binding
    context is, inline versus named templates, and containerless control flow**'
  id: totrans-358
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '****模板**：这告诉我们控制流的工作方式，什么是绑定上下文，内联模板与命名模板，以及无容器控制流**'
- en: '**In the next chapter, we will be adding new functionalities to Knockout by
    creating our own binding handlers.**'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: '**在下一章中，我们将通过创建自己的绑定处理程序来为 Knockout 添加新的功能。**'
