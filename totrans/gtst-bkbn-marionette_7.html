<html><head></head><body><div class="chapter" title="Chapter&#xA0;7.&#xA0;Changing and Growing"><div class="titlepage"><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Changing and Growing</h1></div></div></div><p>In the previous chapter, we explored various functions that could be combined to produce a system that is fully integrated, but loosely coupled. In this chapter, we will cover some external pieces of Marionette that are very valuable, and as we progress, you will discover how to change some default features of the framework and combine <code class="literal">Marionette.js</code> with external libraries to make your application perform better. Here is a list of the topics that we will cover:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using <span class="strong"><strong>Asynchronous Module Definitions</strong></span> (<span class="strong"><strong>AMD</strong></span>)</li><li class="listitem" style="list-style-type: disc">Using the <code class="literal">Require.js</code> library</li><li class="listitem" style="list-style-type: disc">Configuring <code class="literal">Require.js</code></li><li class="listitem" style="list-style-type: disc">Using the text plugin to load the templates</li></ul></div><div class="section" title="Using AMD"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec39"/>Using AMD</h1></div></div></div><p>Using the AMD, API will help us to <a id="id156" class="indexterm"/>load scripts on demand, specify the module dependencies, and reduce the script definition order problem. In <a class="link" href="ch05.html" title="Chapter 5. Divide and Conquer – Modularizing Everything">Chapter 5</a>, <span class="emphasis"><em>Divide and Conquer – Modularizing Everything</em></span>, we discussed why building large applications can easily get out of hand. There are multiple aspects to consider, but managing the script modules is a common scenario. We need to make sure that all the scripts are loaded in the right order, combine them, and reduce the number of requests to the servers. This seems to be simple but as the application grows, it is really complex to keep track.</p><p>To illustrate the scenario, we will use a part of the script section from the <code class="literal">Index.html</code> file before we implement an AMD solution as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script src="../libs/jquery.js"&gt;&lt;/script&gt;
&lt;script src="../libs/underscore.js"&gt;&lt;/script&gt;
&lt;script src="../libs/backbone.js"&gt;&lt;/script&gt;
&lt;script src="../libs/backbone.marionette.js"&gt;&lt;/script&gt;
&lt;script src="../libs/backbone.routefilter.js"&gt;&lt;/script&gt;
&lt;script src="../libs/backbone.localStorage.js"&gt;&lt;/script&gt;
&lt;script src="../libs/bootstrap/js/bootstrap.min.js"&gt;&lt;/script&gt;
&lt;script src="app/Books.js"&gt;&lt;/script&gt;
&lt;script src="app/BaseController.js"&gt;&lt;/script&gt;    
&lt;!-- Cart --&gt;
&lt;script src="app/modules/cart/CartApp.js"&gt;&lt;/script&gt;
&lt;script src="app/modules/cart/CartRouter.js"&gt;&lt;/script&gt;
&lt;script src="app/modules/cart/views/Catalog.js"&gt;&lt;/script&gt;
&lt;script src="app/models/BookModels.js"&gt;&lt;/script&gt;
&lt;script src="app/Books.Data.js"&gt;&lt;/script&gt;
&lt;script src="app/main.js"&gt;&lt;/script&gt;</pre></div><p>This list contains files for just a small proof of the concept and we have already started to accumulate a lot of scripts. As we add more modules, services, models, views, and so on, it will start to get less comprehensive and really hard to maintain. For example, at some point, we may lose track of the files that are not being used anymore. In the preceding code, all the scripts are downloaded when the page is loaded, even if the current view is not using them. Our code is modular, but <a id="id157" class="indexterm"/>still it is not easy to write encapsulated code that can be loaded on the fly, injected as dependency, and shared with other modules. Let's review how we can fix this.</p><div class="section" title="Using the Require.js library"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec21"/>Using the Require.js library</h2></div></div></div><p>James Burke introduced the <code class="literal">Require.js</code> <a id="id158" class="indexterm"/>library and it has a great community. The author is an expert in script loading and a contributor to the AMD specification. This book assumes that you know the basics of AMD and so before jumping to the implementation of our application, it will provide you with some basics of the configuration and boilerplate required while using <code class="literal">Require.js</code>. To get the latest build of <code class="literal">Require.js</code>, please go to the project website, <a class="ulink" href="http://requirejs.org/docs/download.html">http://requirejs.org/docs/download.html</a>.</p></div><div class="section" title="Configuring Require.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec22"/>Configuring Require.js</h2></div></div></div><p>To get started with <code class="literal">Require.js</code>, we <a id="id159" class="indexterm"/>will create a file named <code class="literal">main.js</code>. Of course, you can give this file a more appropriate name that follows your naming conventions and business domain. We will write the following code inside the <code class="literal">main.js</code> file:</p><div class="informalexample"><pre class="programlisting">require.config({
   baseUrl: 'src',
  paths: {
    jquery:     'libs/jquery',
    underscore: 'libs/underscore',
    backbone:   'libs/backbone',
    marionette: 'libs/backbone.marionette',
  },
  shim: {
    underscore: {
      exports: '_'
    },
    backbone: {
      deps: ['underscore', 'jquery'],
      exports: 'Backbone'
    },
    marionette : {
      deps : ['jquery', 'underscore', 'backbone'],
      exports : 'Marionette'
    }
  }
});
require(['jquery','underscore','backbone','marionette'], function($,_,Backbone,Marionette) {
  console.log('Hello world from the main file! ');
});</pre></div><p>Let's replace all the script references from our <code class="literal">Index.html</code> file for the next script reference as follows:</p><div class="informalexample"><pre class="programlisting">&lt;script data-main="main" src="libs/require.js"&gt;&lt;/script&gt;</pre></div><p>In this script reference, we pass the name of the file (in our example, the <code class="literal">main.js</code> file) that has all the required configuration to the <code class="literal">data-main</code> attribute. Please note that it's just the name of the file (<code class="literal">main</code>) and not its <a id="id160" class="indexterm"/>extension (<code class="literal">.js</code>) that is passed, because <code class="literal">Require.js</code> assumes that it will be working only with JavaScript files; therefore, the extension is not needed. The source (<code class="literal">src</code>) should point to the path where the <code class="literal">Require.js</code> file is located.</p><p>Now, we are ready to complete a small test to see if we are on the right path. Open the browser and in the console, you should see the log message when you load the <code class="literal">Index.html</code> file.</p><p>Now, let's review each section of the content of the <code class="literal">main.js</code> file to get a better understanding of what's going on.</p><p>In the preceding code snippet, we put all the libraries that we will use under the <code class="literal">paths</code> section of the <code class="literal">require.config</code> <a id="id161" class="indexterm"/>function. On the left-hand side, we assigned the alias of the library and on the right-hand side, we indicated the path of the file—the path that will be relative to the <code class="literal">baseUrl</code> value assigned, in this case, the <code class="literal">src</code> folder.</p><p>The second property of this function is called <a id="id162" class="indexterm"/>
<span class="strong"><strong>shim</strong></span>. The primary use of <code class="literal">shim</code> is for libraries that do not support AMD, but you still need to manage their dependencies. A perfect example for this is <code class="literal">Underscore.js</code>. In this case, <code class="literal">Underscore.js</code> is exported as <code class="literal">_</code> and it does not depend on another library to be loaded. We have a different scenario with <code class="literal">Backbone.js</code> that requires Underscore to work correctly. We have to specify <code class="literal">Underscore.js</code> as a dependency because it is possible that <code class="literal">Backbone.js</code> would try to do something with it before it is loaded.</p><p>The <code class="literal">require</code> function is <a id="id163" class="indexterm"/>placed at the end of the file as follows:</p><div class="informalexample"><pre class="programlisting">require(['jquery','underscore','backbone','marionette'], function($,_,Backbone,Marionette) {
  console.log('Hello world from the main file!);
});</pre></div><p>The preceding code will be the starting point of our application. It is a function definition that gets the exported values as parameters. <a id="id164" class="indexterm"/>At this point, we are just logging a message, but now let's do something more useful.</p></div></div></div>
<div class="section" title="Defining our application module"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec40"/>Defining our application module</h1></div></div></div><p>Now that the core dependencies are <a id="id165" class="indexterm"/>configured using <code class="literal">Require.js</code>, and once those are loaded and ready, we can define our Marionette application and set up the region initializers, commands, and request/response handlers. This is because we need the inside of a single file that we will name <code class="literal">app.js</code> with the idea of keeping all the login details related to the Marionette application object inside of this file. In the following code, our application is defined and ready to work as an AMD module. The following is the content of our <code class="literal">app.js</code> file:</p><div class="informalexample"><pre class="programlisting">define(['marionette'], function(Marionette){
  var Books = new Marionette.Application();
  Books.addRegions({
    main: '#main',
    modal: ModalRegion
  });
  Books.on('initialize:after', function () {
    if (Backbone.history) {
      Backbone.history.start();
    }
  });
  Books.startSubApp = function (appName, args) {
    var currentApp = App.module(appName);
    if (App.currentApp === currentApp) { return; }
    if (App.currentApp) {
      App.currentApp.stop();
    }
    App.currentApp = currentApp;
    currentApp.start(args);
  };
  return Books;
});</pre></div><p>The book's application that we just defined will be used in the <code class="literal">main.js</code> file when we start the application.</p><p>When we add a new file we need to know where it is located and also its alias name. We specify this by going to the <code class="literal">paths</code> section of the <code class="literal">main.js</code> file definition. After this change your <code class="literal">paths</code> section should look like the following: </p><div class="informalexample"><pre class="programlisting">paths: {
  jquery:     'libs/jquery',
  underscore: 'libs/underscore',
  backbone:   'libs/backbone',
  marionette: 'libs/backbone.marionette',
  app:        'app'
},</pre></div><p>Now, we are ready to use this file to start our <a id="id166" class="indexterm"/>Marionette application in the <code class="literal">require</code> function of the <code class="literal">main.js</code> file as follows:</p><div class="informalexample"><pre class="programlisting">require(['app'], function(Books) {
  Books.start();
});</pre></div><p>Note how we injected the book's dependency to start the Marionette application and used the <code class="literal">start()</code> method of the <a id="id167" class="indexterm"/>Marionette application object to fire the initializers.</p><div class="section" title="Writing the subapplications using Require.js"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec23"/>Writing the subapplications using Require.js</h2></div></div></div><p>The module that we <a id="id168" class="indexterm"/>defined is our root app that takes care of starting up the subapplications. The next example shows how we can define the subapplications using <code class="literal">Require.js</code>. As you can see, we can easily adapt our preceding code to use the <code class="literal">require</code> function by sending our script definitions to a configuration file <a id="id169" class="indexterm"/>and injecting the necessary object into our module definition. The following code is from the <code class="literal">CartApp</code> subapplication:</p><div class="informalexample"><pre class="programlisting">define(['app'], function(Books){
  Books.module('CartApp', function (CartApp, Books, Backbone,Marionette, $, _) {
  CartApp.Controller = Marionette.Controller.extend({
    initialize: function (options) { },
    addProduct: function (model) { },
    removeProduct: function(model){ },
  });
  CartApp.addInitializer(function (args) {
    CartApp.controller = new CartApp.Controller({
      mainRegion: args.mainRegion,
    });
  CartApp.controller.show();
  });
  CartApp.addFinalizer(function () {
    if (CartApp.controller) {
      CartApp.controller.close();
      delete CartApp.controller;
    }
  });
  return Books.CartApp;
});
});</pre></div></div><div class="section" title="Modularizing all your components"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec24"/>Modularizing all your components</h2></div></div></div><p>In the following example, we <a id="id170" class="indexterm"/>will show how to write a module for a view to be loaded with <code class="literal">Require.js</code>, but the same concept applies for all the objects/components.</p><p>In the following code, we define a view called <code class="literal">CategoryView.js</code> and gave it the alias name of <code class="literal">categoryView</code> in the <code class="literal">main.js</code> file so that other files can use it.</p><div class="informalexample"><pre class="programlisting">define(['app'], function(Books){
  Books.module('CartApp.CategoryView', function(View, Books, Backbone, Marionette, $, _){
    View.CategoryView = Backbone.Marionette.ItemView.extend({
      tagName : 'li',
      template: '#categoryTemplate',
      events : {
        'mouseenter .info' : 'showDetails',
        'mouseleave .info' : 'hideDetails'
      },
      showDetails : function() {
        this.$( '.info').popover({
          title:this.model.get('name'), 
          content:this.model.get('booksOnCategory')
        }); 
        this.$( '.info').popover('show');
      },
      hideDetails : function() {
        this.$( '.info').popover('hide');
      },
    });
  return Books.CartApp.CategoryView;
  });
});</pre></div><p>The preceding example defined a well-scoped object. When a module does not have any dependencies and it is just a collection, we pass an object literal to <code class="literal">define()</code>. In our scenario, our module has dependencies, so the first argument should be an array of dependency names—in this case, <code class="literal">app</code> is the <a id="id171" class="indexterm"/>alias of our application—and the second argument should be a definition function.</p></div><div class="section" title="Adding the text plugin"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec25"/>Adding the text plugin</h2></div></div></div><p>So far, we have defined the <a id="id172" class="indexterm"/>template property of our views using the ID of the template. This template is inside a script tag and has always been present in the DOM. <a id="id173" class="indexterm"/>But putting all the templates in the HTML file of a SPA won't scale and will give us the same maintenance problem that we had with all the script references in the <code class="literal">Index.html</code> file. A solution to this problem is to use the text plugin.</p><p>You can download the text plugin from the <code class="literal">Require.js</code> page. The following is the link for the download:</p><p>
<a class="ulink" href="http://requirejs.org/docs/download.html#text">http://requirejs.org/docs/download.html#text</a>.</p><p>As with any other script file, we need to give it an alias in the <code class="literal">main.js</code> file and its path in order to start using it.</p><p>The responsibility of the text plugin is to get the template from the server and pass it to our view so that we don't need it in the HTML file.</p><p>In the following code, we passed the relative path to the template using the <code class="literal">!text/path</code> syntax and the function that creates the view receives the exported name of the template as a parameter; in this case, <code class="literal">CategoryTemplate</code>.</p><div class="informalexample"><pre class="programlisting">define(['app', '!text/templates/CategoryTemplate.html'], function(Books, CategoryTemplate){
  Books.module('CartApp.CategoryView', function(View, Books, Backbone, Marionette, $, _){
    View.CategoryView = Backbone.Marionette.ItemView.extend({
      tagName : 'li',
      template: CategoryTemplate,
      events : {'
        'mouseenter .info' : 'showDetails', 
        'mouseleave .info' : 'hideDetails'     
      },
      showDetails : function() {
        this.$( '.info').popover({
          title:this.model.get('name'), 
          content:this.model.get('booksOnCategory')
        });
       this.$( '.info').popover('show');
      },
      hideDetails : function() {
        this.$( '.info').popover('hide');
      },
    });
    return Books.CartApp.CategoryView;
  });
});</pre></div><p>This approach is more maintainable when building a large-scale application, but perhaps you want to keep the initial templates in your <a id="id174" class="indexterm"/>HTML file for performance benefits and the rest of your templates inside the <a id="id175" class="indexterm"/>right file structure.</p></div><div class="section" title="Structuring your files"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec26"/>Structuring your files</h2></div></div></div><p>There are many different options <a id="id176" class="indexterm"/>to define the layout of your files and probably this will be defined depending on the size and type of your project. At the end of the day, the goal should be to create a folder structure that is easy to understand, implement, and maintain.</p><p>In the following example, we categorize the source into common folders, such as models and collections, and specific folders for the application pieces (views and controllers).</p><p>The static dependencies such as CSS, images, and JavaScript libraries required by our code should go under a different directory. It could prevent unintentional modifications to the library code and give us a better understanding of the real business domain.</p><p>The following image shows the base structure where we will fit our files:</p><div class="mediaobject"><img src="graphics/425OS_07_01.jpg" alt="Structuring your files"/></div><p>Having said that, let's dive into some of the details of our application. The following image shows how you might layout your application structure:</p><div class="mediaobject"><img src="graphics/425OS_07_02.jpg" alt="Structuring your files"/></div><p>In the preceding image, we showed the structure of our book store application. This structure makes sense in this particular <a id="id177" class="indexterm"/>case. But the good thing is that we created small meaningful files that can interact with each other in an easier and elegant way, instead of having big files with the logic of different components contained.</p></div><div class="section" title="Using handlebars as a template engine in Marionette"><div class="titlepage"><div><div><h2 class="title"><a id="ch07lvl2sec27"/>Using handlebars as a template engine in Marionette</h2></div></div></div><p>One of the selling points <a id="id178" class="indexterm"/>of Backbone is <a id="id179" class="indexterm"/>that it plays well with the other libraries and this also holds true for Marionette . If we want to use a different template engine, we can do it with ease.</p><p>For this specific example, we will use handlebars, which we can be downloaded from <a class="ulink" href="http://handlebarsjs.com/">http://handlebarsjs.com/</a>.</p><p>Once we have downloaded the <code class="literal">Handlebars.js</code> file, we can add it to our <code class="literal">Index.html</code> file by using the following line:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/javascript" src="libs/handlebars.js"&gt;</pre></div><p>Or, we can do so by specifying an alias and path for it in the <code class="literal">main.js</code> file.</p><p>The syntax difference from the underscore templates is that a handlebars expression is <code class="literal">{{</code>, followed by some content, and then by <code class="literal">}}</code> instead of <code class="literal">&lt;%= expression %&gt;</code> of the <code class="literal">require</code> function. So, a template in handlebars looks like the following:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/html" id="sample-template"&gt;
&lt;p&gt;This is an ItemView template using handlebars&lt;p&gt;
{{ value1 }} &lt;/br&gt;
{{ value2 }} &lt;/br&gt;
&lt;/script&gt;</pre></div><p>In order to use this template in a Marionette view, we must call the following syntax:</p><div class="informalexample"><pre class="programlisting">template : Handlebars.compile($('#sample-template').html());</pre></div><p>The preceding line will grab the <a id="id180" class="indexterm"/>template from the DOM and compile it into a function that will later be used by Marionette to render the view . The following will be the full code for <code class="literal">ItemView</code>:</p><div class="informalexample"><pre class="programlisting">var SampleView = Backbone.Marionette.ItemView.extend({
  template : Handlebars.compile($('#sample-template').html())
});</pre></div><p>To see this working please go to the JSFiddle example at <a class="ulink" href="http://jsfiddle.net/rayweb_on/gXemX/">http://jsfiddle.net/rayweb_on/gXemX/</a>.</p><p>And that's it! There is no global change needed to start using a different template engine. We can also use both the engines if we <a id="id181" class="indexterm"/>want because the definition of the template is at the view level.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch07lvl1sec41"/>Summary</h1></div></div></div><p>In this chapter, we learned that in order to manage the increasing complexity of our application, we must break it down into separate files. This increasing number of files leads to another problem that <code class="literal">Require.js</code> solves in an elegant way. The <code class="literal">Backbone.js</code> development clearly benefits from the use of <code class="literal">Marionette.js</code>, along with other libraries, such as <code class="literal">Require.js</code> and <code class="literal">Handlebars.js</code>, among others. This will definitely make our development environment more solid and at the same time, flexible to changes.</p></div></body></html>