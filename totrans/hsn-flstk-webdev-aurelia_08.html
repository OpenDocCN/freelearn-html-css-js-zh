<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Security</h1>
                </header>
            
            <article>
                
<p>Security is crucial for every application that you plan to build. Security is a very complex topic that should be analyzed and implemented considering best practices and standards. The <strong>Open Web Application Security Project</strong> (<strong>OWASP</strong>) organization is a worldwide non-profit organization focused on improving the security of the applications.</p>
<p>All the applications implement at least a simple security layer known as the authentication and authorization layer, which is responsible for restricting some access and features according to the permissions granted to a user based on the credentials provided to the application. Although this chapter is focused on how to secure our Aurelia applications, we will implement a simple authentication and authorization API as an example to integrate with our Aurelia web application.</p>
<p>In this chapter, we will be covering the following topics:</p>
<ul>
<li>Understanding JSON Web Tokens</li>
<li>Custom authentication and authorization</li>
<li>Introducing Auth0</li>
<li>Social login with Auth0</li>
<li>Single sign-on</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding JSON Web Tokens</h1>
                </header>
            
            <article>
                
<p>We have implemented a RESTful API that serves the information to be displayed into our Aurelia web app. This API doesn't have any security mechanism, so if any malicious users get the endpoint URL, they can run malicious scripts against our application and ruin our application. For that reason, we should reject any management operations performed by unauthorized users.</p>
<p>Our app should implement a mechanism to manage user's access and privileges. There are many ways to implement authentication and authorization. For our application, we will be using an open standard in the industry called <strong>JSON Web Token</strong> (<strong>JWT</strong>).</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">JWT</h1>
                </header>
            
            <article>
                
<p>JWTs <span>are an open, industry standard, </span>RFC 7519<span> (<a href="https://tools.ietf.org/html/rfc7519.html">https://tools.ietf.org/html/rfc7519.html</a>) method for representing claims securely between two parties. The way we use them is simple. First, we authenticate to the backend server by providing a username or password. If our credentials are correct, the backend server will generate a token that will contain the user information that should be persisted in the client side using a local storage mechanism. This JWT should be passed to the server in every request so that the server can recognize who the user is and what permissions this user has; with this information, the server allows or denies the user request.</span></p>
<p>Let's understand how this works. Navigate to <a href="https://jwt.io/">https://jwt.io/</a>; scroll down a little, and you will find the example section similar to the following image:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b2a724d0-8083-4afb-80ea-bb168770cb33.png" style="width:43.00em;height:29.42em;"/></div>
<p>Let's read the information from right to left. On the right, we have the <span class="packt_screen">Decoded</span> section that has three sections:</p>
<ul>
<li><span class="packt_screen">HEADER</span>: Contains the information about the <strong>algorithm</strong> used to <strong>encrypt</strong> the token</li>
<li><span class="packt_screen">PAYLOAD</span>: The piece of <strong>information</strong> that we will define and use in our application, for example, user information</li>
<li><span class="packt_screen">VERIFY SIGNATURE</span>: The signature of the token; we will define a <strong>secret value</strong> to encrypt our token</li>
</ul>
<p>In the left <span class="packt_screen">Encoded</span>, we can see the result of the final token encrypted based on the information of these three sections mentioned earlier.</p>
<p>As you might guess, this encrypted value is calculated in our backend server. This token is delivered to the user every time they log in to the application. They save this token on the client side and then send it on every request using the <kbd>Authorization</kbd> HTTP header. Let's see how all this works.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom authentication and authorization</h1>
                </header>
            
            <article>
                
<p>Let's now understand the two main concepts behind application security that you have to implement in all your projects.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing authentication</h1>
                </header>
            
            <article>
                
<p>Authentication is the process where we validate the identity of a given user and check whether the user has valid credentials to access our application or backend API. With authentication, we restrict the access to users who are not members of our application.</p>
<p>We will create a basic authentication API as the goal of this book is to show you how you can secure your Aurelia application. We won't go into further details about the backend implementation. We will create a hard-coded authentication flow, but you can integrate it with a database using Mongoose, as described in <a href="" target="_blank">Chapter 6</a>,<em> Storing Our Data in MongoDB</em>.</p>
<p>So, let's get our hands dirty. Open the backend project, create a new file in the <kbd>routes</kbd> folder called <kbd>security-api.js</kbd>, and write the following code:</p>
<pre>const <strong>express</strong> = require('express')<br/>const <strong>api</strong> = express.Router()<br/><br/>const <strong>logIn</strong> = (username, password) =&gt; {<br/>    // Logic Here    <br/>}<br/><br/>api<br/>  .route('<strong>/auth</strong>')<br/>  .<strong>post((req, res, next)</strong> =&gt; {<br/>    // Logic here<br/>  })<br/><br/><br/><strong>module.exports = api</strong></pre>
<p>First, we import <kbd>express</kbd> and create an instance of the <kbd>Router</kbd> class. Secondly, we define a function called <kbd>logIn</kbd>, where we will implement the logic to authenticate the user and generate the JWT. Then, we will define a <kbd>/auth</kbd> <span>route </span>to process a <kbd>POST</kbd> endpoint. Finally, we export the API to be used in the main <kbd>server.js</kbd> file.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The authentication logic</h1>
                </header>
            
            <article>
                
<p>Let's create a simple authentication logic. The backend expects a username and password with the value of the administrator. If these values are provided, it will return a valid token; otherwise, it will return <kbd>null</kbd>. Apply the following changes to the code:</p>
<pre>const express = require('express')<br/>const api = express.Router()<br/><br/>const logIn = (username, password) =&gt; {<br/>   <strong> if (username === 'admin' &amp;&amp; password === 'admin') {</strong><br/><strong>        </strong><strong>const userData = {</strong><br/><strong>            name: "Admin"</strong><br/><strong>        }</strong><strong>        </strong><br/><strong>        return generateToken(userData)</strong><strong>        </strong><br/><strong>    }</strong><br/><strong>    return null</strong><br/>}<br/><br/>api<br/>...</pre>
<p>The code is very straightforward. First, we compare the value in a simple <kbd>if</kbd> conditional, and we created a <kbd>userData</kbd> object, which will contain the user information, in this case just a name value is provided. Finally, we will call a <kbd>generateToken</kbd> <span>function </span>and pass <kbd>userData</kbd> to return a valid token.</p>
<p>Let's implement the <kbd>generateToken</kbd> function.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generating the token</h1>
                </header>
            
            <article>
                
<p>We will use an NPM module to generate JWT called <kbd>jsonwebtoken</kbd>. Open a new console and write the following command into the <kbd>wc-backend</kbd> folder to install the module:</p>
<pre><strong>$ npm install jsonwebtoken --save</strong></pre>
<p>Once the installation is finished. Open <kbd>security-api.js</kbd>,<em> </em>and let's import our library, as follows:</p>
<pre>const express = require('express')<br/><strong>const jwt = require('jsonwebtoken')</strong><br/>const api = express.Router()<br/><br/>...</pre>
<p>With our dependency imported in our file, let's implement the <kbd>generateToken</kbd> function. Apply the following changes:</p>
<pre>...<br/>const logIn = (username, password) =&gt; {<br/>    if (username == 'admin' &amp;&amp; password == 'admin') {        <br/>        let userData = {<br/>            name: "Admin"<br/>        }        <br/>        return generateToken(userData)        <br/>    } else {<br/>        return null<br/>    }    <br/>}<br/><br/><strong>const generateToken = userData =&gt; {</strong><br/><strong>   return jwt.sign(userData, "s3cret", { expiresIn: '3h' })</strong><br/><strong>}<br/><br/></strong>...</pre>
<p>That's all! Let's understand the code. We call the sign function of the <kbd>jwt</kbd> object to create our token. We pass the following information to the function:</p>
<ul>
<li><kbd>userData</kbd>: The piece of information we want to tokenize</li>
<li><kbd>secret</kbd>: A secret value that is used to encrypt and validate the token</li>
<li><kbd>expiration</kbd>: The expiration date of the token</li>
</ul>
<p>Now we are ready with the authentication logic. To finish our implementation, we have to make this logic available via our REST Controller.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The authentication REST controller</h1>
                </header>
            
            <article>
                
<p>We have already defined the route that will be responsible to make our logic available as a REST endpoint, so the only step required is to call our <kbd>logIn</kbd> function. Go ahead and apply the following change:</p>
<pre>...<br/><br/>const generateToken = (userData) =&gt; {<br/>   return jwt.sign(userData, "s3cret", { expiresIn: '3h' })<br/>}<br/><br/><br/>api<br/>  .route('/auth')<br/>  .post((req, res, next) =&gt; {<br/>  <strong>  let { username, password } = req.body</strong><br/><strong>    let token = logIn(username, password)</strong><br/><strong>    if (token) {</strong><br/><strong>        res.send(token)</strong><br/><strong>    } else {</strong><br/><strong>        next(new Error("Authentication failed"))</strong><br/><strong>    }</strong><br/>  })<br/><br/><br/>module.exports = api</pre>
<p>First, we extract the <kbd>username</kbd> and <kbd>password</kbd> from the <kbd>req.body</kbd> object. After that, we call the <kbd>logIn</kbd> function and host the result in the <kbd>token</kbd> variable. If the <kbd>token</kbd> is not null, we respond with a successful response by calling the <kbd>res.send</kbd> function. If the token is null, we pass an <kbd>Error</kbd> object into the next parameter, which will raise a global exception along with a failed response.</p>
<p>Lastly, we have to modify the <kbd>server.js</kbd><em> </em>file to register our API to express, as follows:</p>
<pre>const express = require('express')<br/>..<br/><strong>const seurityApi = require('./src/routes/security-api')</strong><br/>const mongooseConfig = require('./src/config/mongoose-connection')<br/>const app = express()<br/><br/>app.use(bodyParser.json())<br/>app.use(teamsApi)<br/><strong>app.use(seurityApi)</strong><br/>...</pre>
<p>Now we are ready to test our implementation. In a new Terminal window, run the following <kbd>curl</kbd> command:</p>
<pre>$ <strong>curl -X POST -H "Content-type: application/json" -d '{"username":"admin", "password":"admin"}' localhost:3000/auth</strong><br/><br/><strong>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiQWRtaW4iLCJpYXQiOjE1MTk1NzYwMDEsImV4cCI6MTUxOTU4NjgwMX0.4cNGYgz_BZZz5GEfN6MS3pkreGTkUBqJS1FZVC3_ew</strong></pre>
<p>If everything is well implemented, you should receive an encrypted JWT as a response.</p>
<p>Cool! It's time to play with authorization. Keep reading!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing authorization</h1>
                </header>
            
            <article>
                
<p>With authentication, we ensure that our application is being used by an authorized person with valid credentials. In most of the applications that you will build in the future, you will find that there are users who have different permissions on the application. For example, a given student might have the permissions to see their grade, but a student is not able to modify the grades. Otherwise, a user who is a teacher can update grades and access other features that a student cannot.</p>
<p>We will implement authorization using another NPM module <kbd>express-jwt-permissions</kbd>. By using this module, we will be able to implement authorization in a very simple way. Open the <kbd>security-api.js</kbd><em> </em>file and apply the following changes:</p>
<pre><br/>const logIn = (username, password) =&gt; {<br/>    if (username == 'admin' &amp;&amp; password == 'admin') {<br/>        <br/>        let userData = {<br/>            name: "Admin",<br/>          <strong>  permissions: ["admin:create:match", "admin:update:scores"]</strong><br/>        }<br/>        <br/>        return generateToken(userData)<br/>        <br/>    } else {<br/>        return null<br/>    }<br/>    <br/>}</pre>
<p>That's all! The previous library will look into the JWT and check whether it has the <kbd>permissions</kbd> attribute defined. If so, we will extract this information and restrict access to users who do not have the admin permission. In the next section, we will implement the admin REST controller and see how we restrict the access to more details.</p>
<p>Having said that, we are ready to start the Admin API implementation!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Admin API</h1>
                </header>
            
            <article>
                
<p>In order to understand how authorization works, let's implement a basic Admin API that will be accessed only by the administrator of our site. Our application has two principal types of users:</p>
<ul>
<li><strong>Normal</strong>: This user is able to see the featured matches and the score</li>
<li><strong>Admin</strong>: This user is responsible to create new matches and update the score</li>
</ul>
<p>We will use two open source NPM modules to manage the restriction workflow in our backend. The following diagram explains this flow in more detail:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/723782aa-7a9b-4e58-a8da-8e4202c53208.png" style="width:30.42em;height:29.25em;"/></div>
<p>Everything starts with a user request that tries to access a restricted endpoint. The backend first validates whether a valid token is present in the HTTP request; this validation is performed by the <kbd>express-jwt</kbd> module. Secondly, if the request has a valid token, the flow will check whether the token has valid permissions to access the restricted endpoint; this validation is performed by <kbd>express-jwt-permissions</kbd>. If the request has a valid token and has permissions, the user request will be able to access the restricted endpoint and perform the action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Managing matches</h1>
                </header>
            
            <article>
                
<p>To create a match, we will need to create a valid Match database schema. We already know how to do it using Mongoose. Let's do it.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the Match schema</h1>
                </header>
            
            <article>
                
<p>Create the <kbd>match.js</kbd><em> </em>file in the <kbd>src/models</kbd> folder. Then, add the following code:</p>
<pre>const mongoose = require('mongoose')<br/><br/>const <strong>MatchSchema</strong> = new mongoose.Schema({<br/>    <strong>team_1</strong>: {<br/>      type: String,        <br/>      min: 3,<br/>      max: 100,<br/>      required: true<br/>    },<br/>   <strong>team_2</strong>: {<br/>      type: String,<br/>      min: 3,<br/>      max: 100,<br/>      required: true<br/>    },<br/>    <strong>score</strong>: {<br/>      team_1: Number,<br/>      team_2: Number<br/>    }<br/>})<br/>  <br/>module.exports = mongoose.model('<strong>match</strong>', MatchSchema)</pre>
<p>We have defined three attributes, the first two—<kbd>team_1</kbd> and <kbd>team_2</kbd>—<span>will store the information of the two teams playing. T</span>he <kbd>score</kbd> of the match. That's all we need for our model.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating the REST controller</h1>
                </header>
            
            <article>
                
<p>Let's start by creating a new file in the <kbd>src/routes</kbd><em> </em>folder named <kbd>admin-api.js</kbd>. Then, write the following code:</p>
<pre>const express = require('express')<br/>const api = express.Router()<br/><br/>api<br/>  .route(<strong>'/admin/match/:id?'</strong>)<br/>  .<strong>post</strong>((req, res, next) =&gt; {<br/>     <br/>     // logic to create Match<br/>     <br/>  })<br/>   .<strong>put</strong>((req, res, next) =&gt; {<br/>     </pre>
<pre>     // logic to update Scores<br/>     <br/>  })<br/><br/><br/>module.exports = api</pre>
<p>You are very familiar with this code structure. First, we import the modules required to define our REST controller. Secondly, we create a <kbd>/admin/match/:id?</kbd> <span>route </span>and define the <kbd>POST</kbd> method to create a new match and another PUT method to update the scores.</p>
<p>Pay attention to the route definition; we are declaring an optional path variable called <kbd>:id</kbd>. To make a path optional, we add the <kbd>?</kbd> operator after its name.</p>
<p>So far so good. Let's implement them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating Matches</h1>
                </header>
            
            <article>
                
<p>Creating a new <kbd>Match</kbd> is simple. We just need to import the <kbd>Match</kbd> model and call its built-in <kbd>save</kbd> method, as follows:</p>
<pre>const express = require('express')<br/>const api = express.Router()<br/><strong>const Match = require('../models/match')</strong><br/><br/>api<br/>  .route('/admin/match/:id?')<br/>  .post((req, res, next) =&gt; {<br/>     <strong> const match = new Match(req.body)</strong><br/><strong>      match.save()</strong><br/><strong>        .then(data =&gt; res.json(data))</strong><br/><strong>        .catch(err =&gt; next(err) )</strong><br/>  })<br/>   .put((req, res, next) =&gt; {<br/>     <br/>     // logic to update Match<br/>     <br/>  })<br/><br/><br/>module.exports = api</pre>
<p>First, we import the <kbd>Match</kbd> model. Then, in the <kbd>POST</kbd> method, we create a new <kbd>Match</kbd> object and call the <kbd>save</kbd> function. If the operation is successful, we send the new <kbd>Match</kbd> via the <kbd>res.json</kbd> method. To test our creation logic, we need to configure the <kbd>server.js</kbd> to use our new Admin API, as follows:</p>
<pre>const express = require('express')<br/>...<br/><strong>const adminApi = require('./src/routes/admin-api')</strong><br/>const mongooseConfig = require('./src/config/mongoose-connection')<br/>const app = express()<br/><br/>app.use(bodyParser.json())<br/>app.use(teamsApi)<br/>app.use(seurityApi)<br/><strong>app.use(adminApi)</strong><br/><br/>app.use((err, req, res, next) =&gt; {</pre>
<p>Once we have applied the previous change, open a new terminal to test things out:</p>
<pre>$ <strong>curl -X POST -H "Content-type: application/json" -d '{"team_1": "Peru", "team_2": "Chile", "score": { "team_1": 20, "team_2": 0} }'  localhost:3000/admin/match/</strong><br/><br/>{"__v":0,"team_1":"Peru","team_2":"Chile","_id":"5a94a2b8221bb505c92d801c","score":{"team_1":20,"team_2":0}}</pre>
<p>Cool! Now we have our creation logic up and running with a great real example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">List Matches</h1>
                </header>
            
            <article>
                
<p>To list our matches, we won't need security, because all the users should be able to get the full list of matches in the applications. So let's implement the <kbd>matches</kbd> API.</p>
<p>So, create a new file called <kbd>matches-api.js</kbd> into the <kbd>src/routes</kbd> folder and apply the following code:</p>
<pre>const express = require('express')<br/>const api = express.Router()<br/>const Match = require('../models/match')<br/><br/>api<br/>  .route('/matches')<br/>  .get((req, res, next) =&gt; {<br/>     Match.find().exec()<br/>        .then(matches =&gt; res.json(matches))<br/>        .catch(err =&gt; next(err))<br/>  })<br/><br/>module.exports = api</pre>
<p>Next, we have to configure the <kbd>server.js</kbd><em> </em>file to map our <kbd>Match</kbd> APIs. In the <kbd>server.js</kbd><em> </em>file, apply the following change:</p>
<pre>...<br/>const adminApi = require('./src/routes/admin-api')<br/><strong>const matchesApi = require('./src/routes/matches-api')</strong><br/>const mongooseConfig = require('./src/config/mongoose-connection')<br/>const app = express()<br/><br/>app.use(bodyParser.json())<br/>app.use(teamsApi)<br/>app.use(seurityApi)<br/>app.use(adminApi)<br/><strong>app.use(matchesApi)</strong><br/><br/>...</pre>
<p>Cool! Let's test things out. Open a Terminal window and execute the following command:</p>
<pre>$ <strong>curl localhost:3000/matches</strong><br/><br/><strong>[{"_id":"5a949f982c1fda05b8c5c00a","team_1":"Peru","team_2":"Chile","__v":0,"score":{"team_1":20,"team_2":0}}]</strong></pre>
<p>That's it! We have our public <kbd>Match</kbd> API.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Updating the Scores</h1>
                </header>
            
            <article>
                
<p>To update the <kbd>score</kbd>, we will require the ID of the match to look up for an existing one. If a valid match is found, we will apply the updates. If no match is found, we have to respond with a <kbd>404 not found</kbd> HTTP response. Otherwise, we respond with a <kbd>Success 200</kbd> HTTP response.</p>
<p>Let's start by creating the <kbd>updateScore</kbd> function, as shown:</p>
<pre>...<br/>const Match = require('../models/match')<br/><br/><strong>const updateScore = async (matchId, teamId) =&gt; {</strong><br/><strong>  try {</strong><br/><strong>    let match = await Match.findById(matchId)</strong><br/><br/><strong>    if (match == null) throw new Error("Match not found")</strong><br/><br/><strong>    if (teamId == 'team_1') {</strong><br/><strong>      match.score.team_1++;</strong><br/><strong>    } else {</strong><br/><strong>      match.score.team_2++;</strong><br/><strong>    }</strong><br/><br/><strong>    match = await match.save()</strong><br/><strong>    return match</strong><br/><br/><strong>  } catch (err) {</strong><br/><strong>    throw err</strong><br/><strong>  }</strong><br/><strong>}</strong><br/><br/><br/>api<br/>  .route('/admin/match/:id?')<br/>...</pre>
<p>Now, let's call our function in the PUT HTTP verb, as illustrated:</p>
<pre>...<br/>api<br/>  .route('/admin/match/:id?')<br/>  .post((req, res, next) =&gt; {<br/>     ...<br/>  })<br/>api<br/>  .route('/admin/match/scores/:id')<br/><strong>   .post((req, res, next) =&gt; {</strong><br/><br/><strong>    const matchId = req.params.id</strong><br/><strong>    const teamId = req.body.teamId</strong><br/><br/><strong>    updateScore(matchId, teamId)</strong><br/><strong>      .then(match =&gt; res.json(match))</strong><br/><strong>      .catch(err =&gt; next(err))</strong><br/><strong>  })</strong><br/>...</pre>
<p>Cool! Let's test things out. Execute the following <kbd>curl</kbd> command to update the match we created earlier:</p>
<pre><strong>$ curl -X POST -H "Content-type: application/json" -d '{"teamId": "team_1" }'  localhost:3000/admin/match/scores/5a94a2b8221bb505c92d801c</strong><br/><br/><strong>{"_id":"5a94a2b8221bb505c92d801c","team_1":"Peru","team_2":"Chile","__v":0,"score":{"team_1":21,"team_2":0}}</strong></pre>
<p>Note that the <kbd>team_1</kbd> (<kbd>Peru</kbd> team) now has <kbd>21</kbd> goals in its score, and the <kbd>Chile</kbd> team has <kbd>0</kbd>.</p>
<p>Awesome! Now we are able to create a new Match and update the scores. Let's use <kbd>express-jwt</kbd> and <kbd>express-jwt-permissions</kbd> to secure our APIs. Keep reading!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Securing the REST controller</h1>
                </header>
            
            <article>
                
<p>Now it's time to secure our API. To do this, let's start by installing our two NPM modules. Open a Terminal window and run the following command:</p>
<pre><strong>$ npm install --save express-jwt express-jwt-permissions</strong></pre>
<p>Once the installation is done, let's validate our token.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validate token</h1>
                </header>
            
            <article>
                
<p>Every HTTP request has to send the JWT in its authorization header. The <kbd>express-jwt</kbd> middleware will check whether a valid token has been passed. If so, the request will continue its flow, otherwise the backend will respond with an unauthorized exception.</p>
<p>Go ahead and apply the following changes to the <kbd>admin-api.js</kbd><em> </em>file:</p>
<pre>...<br/>const Match = require('../models/match')<br/><strong>const auth =require('express-jwt')</strong><br/><br/>const updateScore = async (matchId, teamId) =&gt; {<br/>  ...<br/>}<br/><br/>api<br/>  .route('/admin/match/:id?')<br/>  .post(<strong>auth({ secret: 's3cret'}</strong>),<br/>  (req, res, next) =&gt; {<br/>    ...<br/>  })<br/>...</pre>
<p>First, we start importing the <kbd>express-jwt</kbd> module and instantiate a new constant called <kbd>auth</kbd>. Secondly, we use the <kbd>auth</kbd> function and pass a JSON object that has the <kbd>secret</kbd> attribute; we will use the same secret value we used to sign our tokens in <kbd>security-api.js</kbd>:</p>
<pre><span>return</span><span> </span><span>jwt</span><span>.</span><span>sign</span><span>(</span><span>userData</span><span>, </span><span>"<strong>s3cret</strong>"</span><span>, { expiresIn: </span><span>'3h'</span><span> })</span></pre>
<div>
<p>The <kbd>auth</kbd> function is responsible for checking whether a valid token has been passed in the authorization header. Let's try to create a new <kbd>Match</kbd> entity without passing a valid token. Open the Terminal window and execute the following command:</p>
</div>
<pre><strong>$ curl -X POST -H "Content-type: application/json" -d '{"team_1": "Peru", "team_2": "France", "score": { "team_1": 5, "team_2": 5} }'  localhost:3000/admin/match/<br/><br/></strong>{"error":"No authorization token was found"}<br/><strong><br/></strong></pre>
<p>As you can see, this time we are receiving an error message that says that our backend API is waiting for a valid token and none has been provided. So, to tackle this situation, we will need to create a valid token first. Let's create a valid token by calling our security API and logging in as admins. Execute the following command:</p>
<pre><strong>$ curl -X POST -H "Content-type: application/json" -d '{"username":"admin", "password":"admin"}' localhost:3000/auth<br/><br/>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiQWRtaW4iLCJpYXQiOjE1MTk2OTgyMjksImV4cCI6MTUxOTcwOTAyOX0.HQiz-NbBDBc9kVyBRNUeMsrDexEsk92WXoRyijNp1Rk<br/></strong></pre>
<p>A new valid token has been created for me. Be aware that this token has a random value, so the token generated for you will be completely different.</p>
<p>Once we have a valid token, let's try again; however, this time we will pass the token using the <kbd>Authorization</kbd> HTTP headers, as follows:</p>
<pre><strong>$ curl -X POST -H "Content-type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiQWRtaW4iLCJpYXQiOjE1MTk2OTgyMjksImV4cCI6MTUxOTcwOTAyOX0.HQiz-NbBDBc9kVyBRNUeMsrDexEsk92WXoRyijNp1Rk" -d '{"team_1": "Peru", "team_2": "France", "score": { "team_1": 5, "team_2": 5} }'  localhost:3000/admin/match/</strong><br/><br/><strong>{"__v":0,"team_1":"Peru","team_2":"France","_id":"5a94c2559e11b6089b2b265e","score":{"team_1":5,"team_2":5}}</strong></pre>
<p>Cool! Now we are able to create a new <kbd>Match</kbd>. Pay attention to the syntax that we have used to pass the token. We have used the <kbd>Authorization: Bearer &lt;token&gt;</kbd> syntax.</p>
<p>We have protected our API, but what about if we have two different types of administrators? Let's say that one group of administrators can be limited to only add <kbd>Match</kbd> entities, and the other group of administrators is limited to only update the scores. We need a way to manage this separation of roles. Let's learn how permissions work.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Validate permissions</h1>
                </header>
            
            <article>
                
<p>Permissions allow us to limit the access to a group of resources. You should be aware that authentication is not enough if we want to secure our backend APIs. To implement permissions, open the <kbd>admin-api.js</kbd><em> </em>file and apply the following changes:</p>
<pre>...<br/>const auth =require('express-jwt')<br/><strong>const guard = require('express-jwt-permissions')()</strong><br/><br/>const updateScore = async (matchId, teamId) =&gt; {<br/>  ...<br/>}<br/><br/>api<br/>  .route('/admin/match/:id?')<br/>  .post(auth({ secret: 's3cret'}),<br/>   <strong> guard.check('admin:create:match'),</strong><br/>    (req, res, next) =&gt; {<br/><br/>      ...    <br/><br/>  })<br/>...</pre>
<p>First, we start by initializing a <kbd>guard</kbd> constant. Secondly, we call <kbd>guard.check</kbd>; this function will look for the <kbd>admin:create:match</kbd> permission in the JWT. Remember that these permissions have to be present in the token. If the user has permission, the flow will continue and the new <kbd>Match</kbd> will be created. Otherwise, we will receive a <kbd>Could not find permissions</kbd> error.</p>
<p>Let's try to create a new <kbd>Match</kbd>; execute the following command:</p>
<pre><strong>$ curl -X POST -H "Content-type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiQWRtaW4iLCJpYXQiOjE1MTk2OTgyMjksImV4cCI6MTUxOTcwOTAyOX0.HQiz-NbBDBc9kVyBRNUeMsrDexEsk92WXoRyijNp1Rk" -d '{"team_1": "Peru", "team_2": "Brasil", "score": { "team_1": 80, "team_2": 5} }'  localhost:3000/admin/match/</strong><br/><br/><strong>{"error":"Permission Denied"}</strong></pre>
<p>That's interesting! Although we are authenticated and are passing a valid token, why are we not able to create the <kbd>Match</kbd>? Let's look at the user token generation logic. Open the <kbd>security-api.js</kbd> file:</p>
<pre>...<br/>const logIn = (username, password) =&gt; {<br/>    if (username == 'admin' &amp;&amp; password == 'admin') {<br/><br/>        let userData = {<br/>            <strong>name: "Admin"</strong><br/>        }<br/><br/>        return generateToken(userData)<br/><br/>    } else {<br/>        return null<br/>    }<br/><br/>}<br/>...</pre>
<p>As you can see, our token doesn't have the permissions defined. Let's fix this by adding the right permissions:</p>
<pre>...    <br/>    let userData = {<br/>       <strong>name: "Admin",<br/>      permissions: ["admin:create:match"]   </strong><br/>    }<br/>...</pre>
<p>That's all. Let's generate a new token by logging in again, and let's test things out.</p>
<p>First, execute the following command to generate a valid token:</p>
<pre><strong>$</strong> <strong>curl -X POST -H "Content-type: application/json" -d '{"username":"admin", "password":"admin"}' localhost:3000/auth<br/><br/>eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiQWRtaW4iLCJpYXQiOjE1MTk2OTk4MzIsImV4cCI6MTUxOTcxMDYzMn0.cVTtJHcbQ2J76s6uRjuySCWq4dKXlNzAfInl0ZLgri<br/></strong></pre>
<p>Cool! this new token contains the permissions. Next, let's try to create the new <kbd>Match</kbd> again by passing this new token:</p>
<pre><strong>$ curl -X POST -H "Content-type: application/json" -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJuYW1lIjoiQWRtaW4iLCJpYXQiOjE1MTk2OTgyMjksImV4cCI6MTUxOTcwOTAyOX0.HQiz-NbBDBc9kVyBRNUeMsrDexEsk92WXoRyijNp1Rk" -d '{"team_1": "Peru", "team_2": "China", "score": { "team_1": 5, "team_2": 5} }'  localhost:3000/admin/match/</strong><br/><br/><strong>{"__v":0,"team_1":"Peru","team_2":"China","_id":"5a94c87987d2820a0d1931e7","score":{"team_1":5,"team_2":5}}</strong></pre>
<p>Hot dog! We are now able to manage authentication and authorization in our backend API. Of course, you can improve this security authentication by saving a collection of users in a MongoDB database and create different users with different roles. Also, implement <kbd>log out</kbd> using <kbd>express-jwt-blacklist</kbd> and in another fashion, but for the purpose of this book, we are good with this basic implementation. Keep reading!</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introducing Auth0</h1>
                </header>
            
            <article>
                
<p>Managing authentication and authorization by ourselves might become a really difficult task to do. Imagine that you need to implement security logic for web applications, mobile applications, and desktop apps. Even your customer might ask you to integrate their applications to social networks and use multifactor authentication or use a password-less method. Although we have implemented the security for our application, we encourage you not to write security code yourself unless you are creating a really simple application.</p>
<p>So, in this section, we will implement authentication and authorization using one popular service called Auth0 (<a href="https://auth0.com">https://auth0.com</a>). This service will help us empower our authentication flows, such as these:</p>
<ul>
<li>Social login</li>
<li>Single sign-on</li>
<li>Email authentication</li>
<li>Multifactor</li>
<li>Password-less authentication</li>
<li>Fingerprint login</li>
<li>LDAP integration</li>
</ul>
<p>Also, Auth0 provides monitoring and other out-of-the-box services that will help us manage our user's information.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A simple example</h1>
                </header>
            
            <article>
                
<p>Although we use our custom implementation for the world cup application, we have prepared a simple example to show you how to use Auth0 with Aurelia. You can download the code from <a href="https://github.com/EriksonMurrugarra/AureliaAuth0">https://github.com/EriksonMurrugarra/AureliaAuth0</a>.</p>
<p>Auth0 implements JWT; this should ring a bell for you, because we have implemented our custom Auth0 implementation using JWT. Let's start by creating a free account on Auth0.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Creating an account</h1>
                </header>
            
            <article>
                
<p>First, navigate to the official Auth0 site, <a href="https://auth0.com">https://auth0.com</a>, and click on the <span class="packt_screen">SIGN UP</span> button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/64ab4512-aa22-4725-940a-c9e9ed7db6cf.png" style="width:42.33em;height:4.42em;"/></div>
<p>Then, fill the form with your email and password, and click on the <span class="packt_screen">SIGN UP</span> button or use your social network accounts:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a432796a-b2b4-4dc3-b9f1-ef532e3b613b.png" style="width:23.58em;height:30.25em;"/></div>
<p>Once the sign-up process is complete, you should be redirected to your administration dashboard. The administration dashboard will allow you to configure the different security mechanisms that you can implement in just a few seconds. Let's continue by registering an application to generate some valid configuration values to connect our Aurelia application to Auth0.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering an Auth0 client application</h1>
                </header>
            
            <article>
                
<p>If you have previous experience of working with third-party service providers, you<span> might</span> have noted that in order to use their services, you have to register an application in order to get some private keys that you will use to access your third-party provider's resource. The same happens with Auth0; we should first register an application and then use the keys generated to configure our apps.</p>
<p>On the dashboard page, go ahead and select the <span class="packt_screen">Applications</span> menu and click on the <span class="packt_screen">CREATE CLIENT</span> button:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/0af642dc-d0cd-41c3-bb85-9b262c9d6775.png" style="width:48.92em;height:7.75em;"/></div>
<p>After clicking on the <span class="packt_screen">CREATE CLIENT</span> button, fill the following form with your application's name and select <span class="packt_screen">Single Page Application</span> for the client type; then, click on <span class="packt_screen">CREATE</span>:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a3539d94-cb2d-41d1-8b4d-5c5b79383d9a.png" style="width:42.92em;height:34.58em;"/></div>
<p>Once we create the client, a new configuration page will be displayed. Navigate to the <span class="packt_screen">Settings</span> tab and you will see the following configuration values:</p>
<ul>
<li><span class="packt_screen">Name</span>: The name of our application</li>
<li><span class="packt_screen">Domain</span>: The domain you previously registered in the sign-up process</li>
<li><span class="packt_screen">Client</span> <span class="packt_screen">ID</span>: A unique ID that makes your application unique</li>
<li><span class="packt_screen">Client Secret</span>: The secret value used to sign the JWT that Auth0 will generate</li>
<li><span class="packt_screen">Allowed Callback URL</span>: The list of URL that Auth0 will redirect when the authentication is a success</li>
</ul>
<p>That's it. Before we explore the application's code, let's start understanding how Auth0 manages authentication by analyzing the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/bcee34dc-5eab-475e-8c88-d95bf08b82a9.png" style="width:34.25em;height:22.08em;"/></div>
<p>The flow begins when the <span class="packt_screen">User</span> wants to log in to the application. You might have a kind of Navigation bar with a button that when clicked on will trigger a JavaScript function that will call an Auth0 JavaScript login function. Secondly, the user will be redirected to a built-in <span class="packt_screen">Auth0 Login Form</span> and will have to enter their credentials to sign up. The credentials entered by the users are validated by Auth0; if the Auth0 finds a valid user with the provided credentials, it will generate a valid JWT that will be sent to the user/Aurelia app. This JWT will be used to access your backend resources. Remember that you can use the <span class="packt_screen">Client Secret</span> property to decrypt the token in the backend.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exploring our example application</h1>
                </header>
            
            <article>
                
<p>First, we will need to download the source code from the GitHub repository at <a href="https://github.com/EriksonMurrugarra/AureliaAuth">https://github.com/EriksonMurrugarra/AureliaAuth0</a>. Let's open a Terminal window in the folder of your preference and run the following command:</p>
<pre><strong>$ cd /some/path</strong><br/><strong>$</strong> <strong>git clone https://github.com/EriksonMurrugarra/AureliaAuth0</strong></pre>
<p>Once the source code is downloaded, we will need to install the dependencies and run the application. Let's get into the source code folder and execute the following commands:</p>
<pre><strong>$ cd AureliaAuth0</strong><br/><strong>$</strong> <strong>npm install</strong><br/><strong>...</strong><br/><strong>$</strong> <strong>au run --watch</strong><br/><br/><strong>Writing app-bundle.js...<br/>Writing vendor-bundle.js...<br/>Finished 'writeBundles'<br/>Application Available At: http://localhost:9000<br/>BrowserSync Available At: http://localhost:3001</strong></pre>
<p>Let's open a new browser and navigate to <a href="http://localhost:9000">http://localhost:9000</a>, which will display a simple home page with a <span class="packt_screen">Log In</span> option in the Navigation bar:</p>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/e415a435-9158-4cda-b22b-36ced3142b62.png" style="width:27.42em;height:15.83em;"/></div>
<p>Cool! We have our application up and running, but we will need to configure it first before we can log in successfully. Go ahead and open the following <kbd>auth-service.js</kbd> file located in the <kbd>src</kbd> folder. We will need to replace the values for the configuration values that we got when we created our client application on Auth0. In our case, the values are the following:</p>
<pre>...  <br/>auth0 = new auth0.WebAuth({<br/>   <strong> domain: 'eriksonmurrugarra.auth0.com',</strong><br/><strong>    clientID: 'LBmldq5O0XHPYz4SAyMr03ThgfMOiHs7',</strong><br/><strong>    redirectUri: 'http://localhost:9000/callback',</strong><br/><strong>    audience: 'https://eriksonmurrugarra.auth0.com/userinfo',</strong><br/><strong>    responseType: 'token id_token',</strong><br/><strong>    scope: 'openid'</strong><br/>  })<br/>...</pre>
<p>It's important to mention that the <kbd>redirectUri</kbd> should be registered in Auth0 in the application settings in <span class="packt_screen">Allowed Callback URLs</span>.</p>
<p>Cool! Save the changes and click on the <span class="packt_screen">LOG IN</span> button to be redirected to the following page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e95aa9bc-bfd6-48be-b0a0-67aa82fc10b0.png" style="width:23.50em;height:24.08em;"/></div>
<p>The previous page is provided by Auth0; you might note that the URL has changed. It means that every time that our users are asked to log in, they will be redirected to Auth0. As you haven't created any user account yet, you will need to sign up first. Once you are done with the registration process, you will be redirected to the home page:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/77b34e64-3aaa-426f-b3d8-1b9f0df94bda.png" style="width:23.50em;height:19.58em;"/></div>
<p>That's it! Now you are logged in to the application using a more secure strategy. Remember that you should never implement authentication and authentication yourself. It is best practice to use a third-party service. The developers who created the services such as Auth0 will definitely have had years of experience creating the most secure authentication and authorization mechanism than you.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Social Login with Auth0</h1>
                </header>
            
            <article>
                
<p>There is an important truth behind the human behavior when they are in front of any registration form. Most of your users will hate your application if you make them waste their valid time asking for personal information that they have already filled in their favorite social network. Even if you try to create the best user experience for your <span class="packt_screen">SIGN UP</span> form, they will avoid them. So, how do we make our users happy and avoid them having to do this horrible sign-up process? Social Login integration to the rescue!</p>
<p>Implementing Social Login might be repetitive work in case you have multiple social networks that you need to integrate into your application. Instead of implementing everything yourself, why don't we use an existing service that can help us in this process? Auth0 to the rescue!</p>
<p>Let's implement Social Login in just 3 minutes. Yeah! you read well, just 3 minutes. Go ahead and navigate to your Auth0 dashboard at <a href="https://manage.auth0.com">https://manage.auth0.com</a> and navigate to the <span class="packt_screen">Connections/Social</span> menu. Then, go ahead and activate the social networks that you want to integrate with your authentication flow, as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d1724f15-8f04-49f5-96fa-32dafa5b6107.png"/></div>
<p>As you can see, I have enabled <span class="packt_screen">Google</span> and <span class="packt_screen">Facebook</span> for the authentication flow. Remember that you will need to register an application on Facebook and Twitter first and then use the keys generated to configure the Social Login methods.</p>
<p>We are almost done. To finish the process, we just need to tell our client application that we want to enable social login. To do this, let's navigate to the <span class="packt_screen">Clients</span> menu and get into the <span class="packt_screen">MyAuth0App</span> client application. Then, navigate to the <span class="packt_screen">Connections</span> tab and enable <span class="packt_screen">Facebook</span> and <span class="packt_screen">Twitter</span> in the <span class="packt_screen">Social</span> section, as demonstrated:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/c7cc56ad-644e-4a5e-827d-d51b1ebda387.png" style="width:83.67em;height:58.92em;"/></div>
<p>Once we have everything configured, the next time when your users try to log in to the application, they will see the following form:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/e54f530f-d07e-4f6f-8c57-b40d3dc51c1c.png" style="width:30.25em;height:33.50em;"/></div>
<p>Cool! Now we know how to integrate our applications to allow our users to sign in to our application, allowing them to use their favorite social network accounts.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Single sign-on</h1>
                </header>
            
            <article>
                
<p>If you are implementing a big enterprise solution that consists of different distributed applications that require authentication and authorization but require to use the same user's database, you will need to implement a different flow to manage the authentication in all these independent applications. This mechanism is called <strong>single sign-on</strong> (<strong>SSO</strong>), which <span>will </span>basically ask for login once in any of your applications and will reuse the same generated token in all the applications. The following diagram explains this flow:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b8322976-0b08-43a9-a2c9-48f6004c0048.png" style="width:33.50em;height:19.33em;"/></div>
<p>In the preceding illustration, there are three applications. Let's suppose that these three different applications are developed by the same company and the employees use the three applications. Imagine that in order to access each application, the employees have to log in to each application using different credentials, or they can choose to use the same username and password for the three apps.</p>
<p>Why should our users log in again to another application if these applications share the same user information? First, a user will log in to the server and retrieve a valid token. Once the first application is logged in to, it can save the token as cookies or in <kbd>LocalStorage</kbd> in the browser. When the user accesses Application 02, the app should detect that there is an existing token and should use it to access the server without asking for credentials.</p>
<p>Now that you know how SSO works, You are free to implement SSO by yourself or use an external service. Auth0 has an awesome support for SSO.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we created a custom implementation to manage authentication and authorization in order to protect the use of our API from unauthorized users. You have seen that implementing Auth0 on your own might be a difficult task and will require more security layers than the ones we have implemented. A good practice is to use an external service to implement authentication and authorization in your projects. We created a simple application that uses one of the most popular third-party services, called Auth0.</p>
<p>We also covered how to integrate social login to our application, but we implemented this feature using Auth0 built-in social connection features. You can implement social authentication on your own, but again, it is better to spend energy on your application login rather than wasting time implementing features that can be achieved in no time using a third-party service.</p>
<p>We looked at how SSO works in theory and learned that it is a simple process reusing the user token in all your different applications.</p>
<p>That's it! In the next chapter, you will learn how to apply end-to-end tests on your Aurelia applications. Keep reading!</p>


            </article>

            
        </section>
    </body></html>