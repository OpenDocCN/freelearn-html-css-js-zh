- en: Chapter 8. Information Lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any information system has a lifecycle. Individual components in these systems
    have their own lifecycles as well. Cumulatively, these can be easy to deal with
    or overwhelmingly difficult. In frontend JavaScript architectures, the tendency
    is toward the latter. The reason is simple, the lifecycles that our components
    go through, fundamentally alter the flow of information over time in ways that
    are close to impossible to predict.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter is about the information life cycle in Flux architectures. Flux
    is different from other architectures in that it puts emphasis on scaling information
    instead of on JavaScript components. We'll begin exploring this theme with a look
    at the difficulties we've faced for years, using the typical component lifecycles
    found in modern JavaScript frameworks. Then, we'll contrast this approach with
    that of Flux, where high-level components are relatively static.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll jump into the concept of scaling information and how this leads
    to more sane architectures that are much easier to maintain than alternative approaches.
    We'll close the chapter with a discussion on inactive stores—stores that aren't
    actively serving a view with data. Let's get to it.
  prefs: []
  type: TYPE_NORMAL
- en: Component life cycle difficulties
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One aspect of scaling a frontend architecture is cleaning up unused resources.
    This frees memory for new resources that get created as the user interacts with
    the application. JavaScript is garbage-collected, meaning that once an object
    doesn't have any references to it, it's eligible for collection the next time
    the collector runs. This gets us partway there; in that, there's no need to manually
    allocate/de-allocate memory. However, we have a whole other category of scaling
    issues, and they're all related to the lifecycle of components.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll talk about the scenarios where we want to reclaim unused
    resources and how this generally happens in frontend architectures. Then, we'll
    look at the challenges that component dependencies present, in the context of
    lifecycle management. Finally, we'll look at memory leak scenarios. Even with
    the best tools in place, there's always the possibility that our code has done
    something to circumvent memory management.
  prefs: []
  type: TYPE_NORMAL
- en: Reclaiming unused resources
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Something that happens a lot throughout the course of an application, is that
    new resources are created while old resources are destroyed. This is in response
    to user interactivity—as they traverse the features of the application, new components
    get created in order to present new information. Much of this creation and destruction
    of JavaScript objects and DOM elements is transparent to us—the tools we employ
    can take care of this for us. The following diagram captures the idea of a component
    that frees internal resources as it changes state:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Reclaiming unused resources](img/B05419_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The key lies with the lifecycle of our components. Depending on the framework
    that's responsible for managing this lifecycle, different things can happen at
    different times. For instance, your component is instantiated and stored when
    it's parent component is created. When your component is rendered, it inserts
    new DOM elements and keeps a reference to them. Finally, when the component's
    parent is destroyed, our component is instructed to remove its DOM elements and
    release any references to them. This is an oversimplified work-flow, but the general
    idea is the same no matter how many moving parts there are. The job of the tools
    we use is to handle the lifecycle of our components in a way that reclaims unused
    components.
  prefs: []
  type: TYPE_NORMAL
- en: Why is reclaiming unused components so important? The fundamental limitation
    we face is that memory is finite, and we're trying to build a robust application
    that scales well. Removing components from memory when they're no longer needed,
    makes room for new components to be created when they're needed. So, what's the
    big deal if we're using a framework that has well-defined lifecycles for our components
    and handles a lot of the messy details for us?
  prefs: []
  type: TYPE_NORMAL
- en: One limiting factor to this approach is that with a complex application that
    has lots of moving parts, the framework is constantly creating and destroying
    objects. This inevitably leads to the garbage collector getting invoked frequently,
    causing pauses in the main JavaScript execution thread. In the worst case, this
    can lead to pauses in the user experience due to unresponsive user events. The
    other potential pitfall of automatically managed component lifecycles is that
    the framework doesn't always know what we're thinking, and this can lead to hidden
    dependencies that end up breaking the flow of the component create/destroy lifecycle.
  prefs: []
  type: TYPE_NORMAL
- en: Hidden dependencies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Patterns that define the lifecycle of a particular type of component are a
    good thing—provided that our components abide by their lifecycle one hundred percent
    of the time. This rarely works out because we''re trying to build something unique
    that solves a problem for our users, not a piece of software that plays nice with
    a framework just for the sake of it. The biggest risk here is that we''ll accidentally
    prevent the framework from properly freeing resources by introducing dependencies.
    These dependencies might make perfect sense in the context of our application,
    but as far as the framework is concerned, it doesn''t know about them, and this
    breaks in unpredictable ways. Take a look at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Hidden dependencies](img/B05419_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The actual scenarios we face will be a little more nuanced than the scenario
    depicted here. The general theme is that frameworks that manage lifecycles are
    unforgiving. All it takes is a dependency in the wrong place to completely invalidate
    everything that the framework is doing for the application. However, this is the
    cost/benefit of having lifecycles for architectural components in the first place.
    The benefit being that we need to reclaim components to make way for new ones,
    and if a framework can automate this arduous task for us, all the better. The
    risk is that any time things are created and destroyed, there's a chance that
    this isn't done properly, leading to memory leaks.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leaks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When our code is constantly creating and destroying objects, the JavaScript
    garbage collector thrashes, and we experience performance hiccups. However, this
    is a minor problem compared to leaky JavaScript components that are never fully
    garbage-collected. This tends to happen when our application code has ideas that
    don't quite fit with those of the framework that manages the lifecycle of our
    components. Obviously memory leaks are a huge scalability issue and one that want
    to avoid at all costs.
  prefs: []
  type: TYPE_NORMAL
- en: So what we have are two related scalability issues with regard to the lifecycle
    of components in our architecture. First, we don't want to constantly create and
    destroy objects because this has garbage-collection pausing problems. Second,
    we don't want to leak memory by introducing hidden dependencies that the framework
    isn't aware of, breaking the intended lifecycle. As we'll see in the following
    section, Flux architectures help with both aspects of component lifecycle issues.
    There isn't a lot of creation/destruction of components in a Flux architecture.
    This reduces the probability of introducing logic that breaks the lifecycle of
    a given component. Later in the chapter, we'll see how Flux focuses on information
    rather than JavaScript components to achieve scale.
  prefs: []
  type: TYPE_NORMAL
- en: Flux structures are static
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Given that the need to constantly create and destroy objects presents an opportunity
    for scaling issues, it seems that we should create and destroy as little as possible.
    It turns out that Flux architectures are different in this area in that much of
    the component infrastructure is static.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we'll look at what sets Flux apart from other architectures
    in this regard, starting with the singleton pattern that's used by many modules.
    Then, we'll compare the traditional MVC model approach to Flux stores. Lastly,
    we'll take a look at static view components and see if this is an idea worth pursuing
    in order to achieve scale.
  prefs: []
  type: TYPE_NORMAL
- en: Singleton pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you've probably noticed by now, most of the modules we've worked with so
    far in this book have exported a single instance. The dispatcher exposes a single
    instance of the `Dispatcher` class from the Facebook Flux package. This is the
    singleton pattern in action.
  prefs: []
  type: TYPE_NORMAL
- en: The basic idea is that there's only one instance of a class, creating more is
    never necessary because the first instance is all we'll ever need. This bodes
    well with the scaling issues we've discussed in this chapter, where constant creation
    and destruction makes our code vulnerable to errors. These errors ultimately prevent
    the application from scaling, due to memory leaks or performance problems.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, Flux architectures tend to assemble the plumbing between the components
    at startup time, and this pluming stays in place permanently. Think about the
    physical plumbing where you live, it sits idle when it's not being used. However,
    the cost of tearing out the physical plumbing to reclaim the space, and the cost
    of replacing it when needed simply doesn't add up. The overhead of having static
    plumbing structures within our walls isn't a scaling bottleneck in our day-to-day
    lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'So while we can avoid some of the creation and destruction of objects by following
    the singleton pattern, there are tradeoffs. For example, the single pattern isn''t
    necessarily a good pattern. At least not in all our modules where everything is
    a class, and yet, everything is only instantiated once. Let''s look at a store
    module and see if we can implement something that doesn''t actually require a
    store. First, let''s implement a typical store module which exports a singleton
    class instance for comparison:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s only a handful of properties that the outside world requires from
    this module. It needs the state, so other components can read it. It needs the
    identifier of dispatcher registration, so other components can depend on it using
    `waitFor()`. And, it needs the `EventEmitter`, so other components can listen
    for store state changes. Let''s now implement a store that doesn''t actually require
    instantiating a new class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, we're exporting the bare necessities that allow other components
    to treat this module as a store. And it is indeed a store, it's simply structured
    differently. Instead of exporting a singleton class instance, which has the essential
    store interface, we're directly exporting the pieces of the interface. Is there
    any fundamental advantage to either approach? No, there's not. If you prefer classes
    and the ability to extend a base class, then stick with the singleton pattern.
    If you feel that classes are ugly and unnecessary, stick with the module approach.
  prefs: []
  type: TYPE_NORMAL
- en: At the end of the day, the architectural result is the same. The store simply
    exists. There's no need to create and destroy the store as the user interacts
    with the application. There's nothing preventing us from doing this—setting up
    and tearing down stores as the state of the application changes. But as we'll
    see later in the chapter, there's really no advantage to doing this, just as there's
    no advantage to tearing your walls apart when the sink isn't running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see these two stores in action. Aside from how they''re imported, they''re
    indistinguishable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Comparison to models
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Remember the idea that stores represent features at the top-level of our application?
    Well, top-level features generally aren't created and destroyed constantly throughout
    the lifetime of the application. Models on the other hand, our friends from the
    family of MV* architectures, often represent more fine-grained data domains. And
    because of this, they need to pop in and out of existence.
  prefs: []
  type: TYPE_NORMAL
- en: For example, suppose we're on the search page of an application, and there's
    a bunch of results displayed. The individual results are likely models, representative
    of some structure returned by the API. The view that renders the search results
    probably knows how to display these modules. When the results change or the user
    navigates to another part of the application, the models are inevitably destroyed.
    This is part of the whole lifecycle discussion we had earlier in the chapter.
    It's not a simple deletion—there's cleanup steps that need to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: With Flux stores, we don't have the same level of complexity. There's views
    that listen to a given store, but that's it. When the state of a store changes,
    like when some search result data is deleted from the store state, the views are
    notified. It's then up to the view to reflect this changed data by re-rendering
    the UI. With Flux, the cleanup is a simple deletion problem, both from the point
    of view of the DOM and of the store. The fact that we're not blowing away entire
    stores while the user interacts with the application means that there's less chance
    for our architectural components to fall out of sync with one another.
  prefs: []
  type: TYPE_NORMAL
- en: Static views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since views are the components responsible for rendering information that the
    user can see, it would make sense that the view is cleaned up when the user isn't
    looking at it, right? Well, not necessarily. Revisiting the plumbing analogy,
    when we leave the kitchen, we turn the tap in the sink off. We don't get a toolbox
    and start ripping out pipes. The notion that views in a Flux architecture can
    be static is in fact viable. It's the water we need to turn off in order to scale,
    not the plumbing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some views that are created at startup and never destroyed as
    the user interacts with the application. First, we''ll implement a class-based
    static view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This looks like your typical class that you would find in a Flux architecture.
    It''s instantiated within the module and exported. The content itself is rendered
    by reducing an array to a `<strong>` tag. We''ll see why we''re rendering such
    a tag like this when we look at the store. But first, let''s look at another static
    view that takes the form of a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the functional style of React components that you were introduced to
    in the previous chapter. As you can see, there''s nothing much to it, as React
    takes care of a lot of the heavy lifting for us. Now let''s take a look at the
    store that both of these views relies on for information:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that both actions—`SHOW_CLASS` and `SHOW_FUNCTION`—are processed
    the same way. One action sets a piece of state while deleting another. Let''s
    discuss this approach here for a moment. The `classContent` and `functionContent`
    state properties both use single-item arrays for a string value. Both of our views
    iterate over these arrays—using `map()` and `reduce()`. The reason we''re doing
    it this way is to keep logic out of the views. The business logic that operates
    on stores should stay in the store. However, views need to know what to display
    and what to remove. By always iterating over a collection, like an array, the
    content generation is consistent and logic-free. Let''s see how both of these
    views are used in `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The `classView` is straightforward to use. It's imported and rendered. The store
    state handling is encapsulated within the `view` module. The `FunctionView` React
    component on the other hand, needs to be set up with a handler function that's
    called when `myStore` changes state. Technically, this isn't a static view, because
    it's a function that's called whenever `React.render()` is called. However, in
    the context of Flux, it does behave a lot like a static view, because it's the
    React rendering system that handles the creation and destruction of view components—our
    code isn't creating or destroying anything—only passing components to `render()`.
  prefs: []
  type: TYPE_NORMAL
- en: Scaling information
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you've seen so far in this chapter, Flux doesn't try to scale things that
    don't need to be scaled. For example, stores and views are often created just
    once during startup. Trying to clean these components repeatedly as the application
    changes state over time is simply error-prone. It's scaling the information that
    Flows through our Flux components that will knock our system over if we're not
    careful.
  prefs: []
  type: TYPE_NORMAL
- en: We'll start this section off with a look at how our Flux architectures can scale
    well on their own, without massive amounts of data entering the system. This also
    serves to illustrate the idea that these are in fact two separate problems—scaling
    the infrastructure of our Flux components versus scaling the volume of data that
    our architecture is able to process. Then, we'll discuss the topic of designing
    our user interfaces for less information, to make the design process of scalable
    components straightforward. We'll explore the role of Flux actions when it comes
    time to scale our system up to the next level.
  prefs: []
  type: TYPE_NORMAL
- en: What scales well?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As our application grows, it needs to scale in response to things like new feature
    requests, and growing datasets. The question is, which of these scaling issues
    is most deserving of our attention? It should be the issue with the highest potential
    to topple our system. Generally speaking, this has more to do with the input data
    than it does with the configuration of our Flux components. For instance, there's
    a potential scaling issue if we're processing input data in polynomial time instead
    of logarithmic time.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why our Flux architecture doesn''t need to concern itself with lifecycles
    and maintaining the plumbing between components the same way other architectures
    do. Will having a lot of components occupy more memory than they need to and is
    this expensive in terms of performance? Sure, this is always a consideration—we
    don''t want to have more components then we need. In practice, this type of overhead
    is hardly noticeable by users. Let''s take look at the impact a large component
    infrastructure has on performance. First, the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'There''s nothing much to this view because there doesn''t need to be. We''re
    not testing the rendering performance of the view itself—we''re testing the scalability
    of the architecture. So all that''s required is that the view exists and can listen
    to a store. We''re passing the store instance in through the constructor because
    we''re creating several instances of this view that listen to different stores,
    as we''ll see here in a moment. Let''s look at the store code next:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a pretty basic store that does a pretty basic calculation when `MY_ACTION`
    is dispatched. Again, this is intentional. Now let''s see how these components
    can scale in a Flux architecture without much data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: We're measuring the startup cost of creating these components and setting up
    their listeners, because this will typically add to the startup cost of a Flux
    application. But as we can see here, getting all these components ready is inconsequential
    in terms of user experience. The big test comes when the actions are dispatched.
  prefs: []
  type: TYPE_NORMAL
- en: This setup causes one million view render calls to happen, and it takes about
    half a second. This is the plumbing in the wall of our application, and it really
    doesn't benefit us to tear it down and set it all back up again later. This aspect
    of the architecture scales well. It's the data that enters the system, and the
    logic that operates on it that's the real scaling challenge. If we have to run
    this same test again with an action payload of a 1000 item array that was sorted
    by the store, we might have a problem.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We'll address more fine-grained performance testing scenarios in [Chapter 13](ch13.html
    "Chapter 13. Testing and Performance"), *Testing and Benchmarking*.
  prefs: []
  type: TYPE_NORMAL
- en: Minimal information required
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you just saw, the notion that Flux components and their connections can be
    statically-defined is valid. At least, in terms of scaling challenges, having
    static plumbing in place isn't going to be the thing that knocks our system down
    when we try to scale it. It's the data that flows into the system, and the means
    by which we transform it into information for the user. This is the thing that's
    very difficult to scale, and so, it's best that we do as little of it as possible.
  prefs: []
  type: TYPE_NORMAL
- en: It may sound trivially obvious at first, but having less information to display
    scales well. This can easily be overlooked because we're out to build features,
    not to measure the volume of information output from our views. Sometimes, this
    is the most effective way, or possibly the only way, to fix scaling problems.
  prefs: []
  type: TYPE_NORMAL
- en: When we're designing a Flux architecture for our application, we have to keep
    information scalability in mind. Often, the best angle to look at the problem
    is from the UI itself. If there's a way that we can axe certain things, in an
    effort to reduce clutter, we also reduce the amount of information that views
    need to generate. Potentially, we can remove an entire data flow from our application
    simply by changing what the user sees. Lean user interfaces scale well.
  prefs: []
  type: TYPE_NORMAL
- en: Something else to be on the lookout for is information that leaks out of store
    components. By this, I mean information that a store generates for no real purpose.
    This could have been something that used to be relevant to how the view worked,
    but when the feature changed, we forgot to take out the relevant information.
    Or, it could simply be an oversight in the design—we're generating information
    that the view doesn't actually need, and its been this way from day one. These
    problems are difficult to spot, but easy to fix. The only foolproof approach is
    to periodically audit our views to ensure that they're consuming the information
    that they need and nothing more.
  prefs: []
  type: TYPE_NORMAL
- en: Actions that scale
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Actions are the gatekeepers of any data that wants to enter our Flux system—if
    it's not an action payload, then it's not data that we care about. Action creator
    functions aren't problematic to scale, as they don't do much. The most complex
    aspect of an action creator function is managing asynchronous behavior, if necessary.
    But this isn't a fundamental scaling problem, every JavaScript application has
    asynchronous components. There's two fundamental ways that actions can thwart
    our scaling efforts.
  prefs: []
  type: TYPE_NORMAL
- en: The first is having too many actions. This means that there's more opportunity
    for programmer error due to all the possibilities. It becomes less obvious which
    action creator should be used in which context. The same problem can happen when
    there are few actions and too many action creator parameters. This directly inhibits
    our ability to get the right data into the stores of our application.
  prefs: []
  type: TYPE_NORMAL
- en: The second way that actions can stumble when we try to scale our system is that
    the action creator functions are doing too much. For example, an action creator
    function might try to filter out some of the API response data in an effort to
    slim down the data that's handed off to the stores through the dispatcher. This
    is hugely problematic, because it violates the Flux rule that all state and all
    logic that changes state belongs in stores.
  prefs: []
  type: TYPE_NORMAL
- en: It's understandable how something like this can happen though, when under pressure
    to scale an application, the most obvious place to fix data problems is at the
    source. In this case, the source is the handler of the AJAX response. The better
    way to handle this is to tweak the API itself and have the action creator function
    supply the appropriate parameters to get the smaller set of data. When state transformations
    move outside of stores in the frontend, we reduce the likelihood of scaling successfully
    because we increase the likelihood of other issues taking place.
  prefs: []
  type: TYPE_NORMAL
- en: Inactive stores
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we explored the idea that we can have a relatively
    static component infrastructure in our Flux architecture. This isn't something
    that causes concerns about scalability. Rather, it's the large amounts of data
    that's held in our stores. In this final section, we'll cover some scenarios in
    which we have a store with lots of data as its state, and we don't want our application
    to become memory-bloated.
  prefs: []
  type: TYPE_NORMAL
- en: The first approach involves deleting the data from the store, freeing resources.
    We can take this approach a step further by adding heuristics to our store logic
    that determines that nothing has changed and there's no need to touch the DOM
    by emitting a change event. Finally, we'll talk about some of the side-effects
    caused by deleting store data and how to deal with them.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting store data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Something we have to think long and hard about with our Flux components is how
    data that enters the system will eventually exit the system. If we only put data
    in without taking any of it out, we've got a problem. In fact, this activity is
    fundamental to Flux architectures, because removing data from store states is
    also how we remove other data structures, such as DOM nodes and event handler
    functions.
  prefs: []
  type: TYPE_NORMAL
- en: Earlier in the chapter, we saw that by emptying an array, we could tell the
    view to remove UI elements. This is essentially how we scale Flux applications—by
    removing the data that has potential to cause scaling headaches. Imagine a store
    that had a collection with thousands of items in it. This collection would not
    only be expensive to process as is, but it also has the potential to grow much
    larger.
  prefs: []
  type: TYPE_NORMAL
- en: 'The simple solution is to empty this collection out when it''s no longer needed.
    Let''s revisit this approach. First, here''s what the view looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'A couple of buttons and a list of items—pretty simple. When a button is clicked,
    it calls an action creator function. Let''s turn our attention to the store now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HIDE_ALL` action simply deletes all the items by assigning an empty array.
    This is exactly what we''re after—deleting data when it''s no longer needed. This
    is the real scaling challenge, cleaning up data that has the potential to be big
    and expensive to process. The `HIDE_ODD` action is a variation that filters out
    even numbers. Lastly, let''s see how this all comes together in `main.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Optimizing inactive stores
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One potential scaling issue with the setup we've used in the preceding example
    is that the view itself performs some expensive computation. For example, we can't
    rule out the possibility that even with an empty array as the supplied information
    to render, the view has some implementation issues. This is problematic in a Flux
    architecture, because actions are always being dispatched to stores, which in
    turn notify views that are listening to them. So it's important that views are
    fast.
  prefs: []
  type: TYPE_NORMAL
- en: This is where React fits really well into Flux. React components are meant to
    be re-rendered in a top–down fashion, from the root component all the way down
    to the leaves. It's able to do this efficiently because of the virtual DOM it
    uses under the hood to compute patches that are then applied to the real DOM.
    This eliminates many performance issues because issuing a lot of DOM API calls
    is a performance bottleneck. On the other hand, it would be slightly naive to
    assume that the store will be publishing changes to an efficient React component.
  prefs: []
  type: TYPE_NORMAL
- en: Stores are responsible for emitting change events when the time is right. Therefore,
    we could determine within the store that when a given action is dispatched, there's
    no need to emit a change event. This would involve some sort of heuristic that
    would determine that the view is already displaying the appropriate information
    given the state of the store, and that emitting a change event now would be of
    no value. By doing this, we could avoid any performance challenges in the view.
    The problem with this approach is that we're building up complexity in our store.
    It's probably better that we emit change events consistently and deal with views
    that are doing things inefficiently. Or if we're not using React as the view layer
    yet, perhaps this is an argument in favor of doing so.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at implementing advanced change detection heuristics
    in our view components.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping store data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, you've seen how to remove data from stores in a way that scales
    well. If the user has moved from one part of the user interface to another, then
    we likely want to delete any store data that's no longer needed in this new section.
    The idea is that rather than take out all of our JavaScript components, we focus
    on the data in our stores, the aspect of our application that's the most difficult
    to scale. However, there's a potential problem with this approach that we need
    to consider.
  prefs: []
  type: TYPE_NORMAL
- en: What happens if another store depends on the data that we've just removed? For
    example, the user is on a page that's driven by state from store A. They then
    move on to another page, which is driven by store B, which depends on store A.
    But we've just deleted the state inside of store A—isn't this going to be a problem
    for store B?
  prefs: []
  type: TYPE_NORMAL
- en: 'This isn''t a common case—the majority of our stores won''t have any dependencies,
    and we should be safe to delete unused data. However, we need to come up with
    a game plan for stores that do have dependencies. Let''s walk through an example
    and start with the views. First, we have the radio button view, which is a simple
    control that allows the user to toggle from a list of users to a list of groups:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The change event for both radio buttons is hooked up to an action creator function,
    which affects the display of our two other views—we''ll look at these next, starting
    with the user list view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty straightforward, and you can see that there''s a group dependency here,
    as we''re displaying the group that the user belongs to. We''ll dig into that
    dependency momentarily, but for now, let''s look at the group list view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s take a look at the stores that drive these views, starting with
    the radio button store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see here that we''re using the single-item array technique once again.
    This is why we have the `map()` call in the view that uses this store''s data.
    The idea is that to hide one of these buttons, we can do it right here in the
    store by setting it to an empty collection—keeping logic out of the view. Notice
    that we''ve set up some basic getter functions to make dealing with these single-item
    arrays easier as well. Now let''s check out the groups store:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This store has two pieces of state—`_groups` and `groups`. Yes, they''re basically
    the same thing. The difference is that the view depends on `groups`, not on `_groups`.
    The `Groups` store is able to compute the groups state based on `_groups`. This
    means that we can safely delete the `groups` state to update the view rendering
    while the `_groups` state isn''t touched. Other stores can depend on this store
    now, without risk of any data disappearing. Let''s take a look at the users store
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see that the `Users` store is able to depend on the `_groups` state
    from the `Groups` store in order to build the state that''s needed by the user
    list view. This store follows the same pattern as the `Groups` store in that it
    has a `_users` state and a `users` state. This allows for other views to depend
    on `_users` if necessary, and we can still wipe the `users` state to clear the
    UI. However, if it turns out that nothing is dependent on this store, we can revert
    the pattern so that there''s only one piece of state that''s deleted when no longer
    required by the current view. Lastly, let''s take a look at the `main.js` module
    and see how this all fits together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The focus of scaling a Flux architecture is on the information that stores produce,
    rather than the various components. This chapter started with a discussion on
    the common practices of other architectures that involve the constant creation
    and destruction of JavaScript components. This is done to free resources, but
    it comes at a cost—the potential for error. Next, we looked at the relatively
    static nature of Flux architectures, where components have a long life. They don't
    have to constantly create and destroy components, which means that there's less
    potential for issues.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we covered the concept of scaling information. We did so by demonstrating
    that our JavaScript components and the connections between them were the least
    of our worries when it comes to scaling the architecture. The real challenge comes
    when there's a lot of data to process, and the data that enters the system is
    likely to grow much faster than the number of JavaScript components we have.
  prefs: []
  type: TYPE_NORMAL
- en: We closed the chapter with some examples of how to deal with unused store data.
    This is ultimately the most important aspect of scaling a Flux architecture since
    it gives the browser back unused resources. In the next chapter, we'll tackle
    the topic of immutable stores. This is something we've alluded to throughout the
    book, and we'll give it some focused attention now.
  prefs: []
  type: TYPE_NORMAL
