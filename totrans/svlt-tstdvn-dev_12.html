<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-135"><a id="_idTextAnchor134"/>12</h1>
<h1 id="_idParaDest-136"><a id="_idTextAnchor135"/>Using Component Mocks to Clarify Tests</h1>
<p>The preceding chapter introduced the concept of a test double and showed how <code>vi.fn</code> can be used to swap out unwanted behavior within your Vitest test suites. The same technique can be used for Svelte components, but it’s a little more complicated.</p>
<p>Imagine you’re writing unit tests for a component named <code>Parent</code>, and that component itself renders another developer-defined component, named <code>Child</code>. By default, when your tests render <code>Parent</code>, <code>Child</code> is rendered too. But using a component mock can stop that from happening. It swaps out the real <code>Child</code> for a test double.</p>
<p>There are various reasons why you’d want to do this:</p>
<ul>
<li>The <code>Child</code> component already has its own unit test suite, and you don’t want to repeat yourself (a form of overtesting, described in detail in the <em class="italic">Avoiding component </em><em class="italic">mocks</em> section)</li>
<li>The <code>Child</code> component has behavior on mount, such as fetching data via the Fetch API, that you’d rather avoid running within your test</li>
<li>The <code>Child</code> component comes from a third-party library and it’s more important that you verify the props it is rendered with, rather than verifying the behavior of the third-party component itself</li>
</ul>
<p>The downside of using component mocks is that they’re complex, and if you’re not careful, they can become a burden.</p>
<p class="callout-heading">Staying safe with test doubles</p>
<p class="callout">The number-one rule when using component mocks, and test doubles in general, is to avoid building any control logic (<code>if</code> statements and loops) into them. Instead, when you use <code>mockReturnValue</code> or <code>mockResolvedValue</code> to specify the value that is returned, always prefer to return fixed values.</p>
<p class="callout">An easy way to ensure that happens is to ensure that each unit test gets its own test double instance. In other words, avoid setting up a test double in a <code>beforeEach</code> block and reusing it across all tests.</p>
<p class="callout">If you’re struggling to keep test doubles simple, that can be a sign that the application code design is too complex. Try reconfiguring the object under test, perhaps by splitting it out into a number of separate objects.</p>
<p>This chapter covers the following topics:</p>
<ul>
<li>Avoiding component mocks when possible</li>
<li>Using hand-rolled component stubs</li>
<li>Using a component mock library</li>
</ul>
<p>By the end of the chapter, you will be confident with using component mocking techniques and know when to use them.</p>
<h1 id="_idParaDest-137"><a id="_idTextAnchor136"/>Technical requirements</h1>
<p>The code for the chapter can be found online at <a href="https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start">https://github.com/PacktPublishing/Svelte-with-Test-Driven-Development/tree/main/Chapter12/Start</a>.</p>
<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Avoiding component mocks</h1>
<p>This section<a id="_idIndexMarker402"/> covers how to build your application without using component mocks. Of course, the application we’ve built up to this point hasn’t used any, so you already know it’s possible.</p>
<p>The SvelteKit application we’ve built has a page route component that renders a list of <code>Birthday</code> components and a <code>BirthdayForm</code> component. Both of these components are covered by their own test suites, so they are certainly candidates for using component mocks. The page route component would simply check that it renders <code>Birthday</code> and <code>BirthdayForm</code> in the right way, and avoid testing any of the birthdays themselves.</p>
<p>But there’s not much point in doing this. Neither of these components has any behavior on mount, so there’s no trouble in letting them render.</p>
<p>The biggest risk you<a id="_idIndexMarker403"/> have in not using component mocks is that of <code>Birthday</code> component test suite and repeating them in the page route test suite.</p>
<p><em class="italic">Figure 12</em><em class="italic">.1</em> shows how the test suites for a <code>Parent</code> and <code>Child</code> component can be developed without overtesting. The <code>Parent</code> test suite only needs to test a single flow to <code>Child</code> to prove the connection. If there are any interesting return flows of data back from <code>Child</code> into <code>Parent</code> (such as component event bindings), then they should be tested too.</p>
<div><div><img alt="Figure 12.1 – Overtesting caused by repeated tests at two levels in a component hierarchy" height="598" src="img/Figure_12.1_B19611.jpg" width="1491"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – Overtesting caused by repeated tests at two levels in a component hierarchy</p>
<p>Thankfully, TDD has a couple of rules that avoid the problem of overtesting.</p>
<h2 id="_idParaDest-139"><a id="_idTextAnchor138"/>Avoiding overtesting using TDD</h2>
<p>Imagine first that you’re<a id="_idIndexMarker405"/> building your <a id="_idIndexMarker406"/>application using a bottom-up approach, which is the approach this book has followed. That means that you write the <code>Child</code> component and its test suite before writing the <code>Parent</code> component and its test suite.</p>
<p>When you begin test-driving <code>Parent</code>, you write a test that will bring in the <code>Child</code> component. (The test description might be something such as <em class="italic">displays the birthday information</em>.) Recall the TDD rule of <em class="italic">make the simplest change that could possibly work</em>. Since you’ve already written the <code>Child</code> component at your disposal, then the simplest change is to simply bring in the <code>Child</code> component.</p>
<p>Then, the rule of the <em class="italic">Red</em> test comes into play, and this is the crucial one that avoids overtesting. You can’t work on a <a id="_idIndexMarker407"/>test unless you see it fail. But if your first test brought in the <code>Child</code> component, you <a id="_idIndexMarker408"/>suddenly get all the behavior of <code>Child</code> for free. So, if you’re following TDD, it’s impossible to write a <em class="italic">Red</em> test for all the behavior of <code>Child</code>, because it will already pass.</p>
<p>Now imagine that you started by building the <code>Parent</code> component and at some point felt the urge to extract a <code>Child</code> component (you might think of this as a top-down approach). How do you go about extracting <code>Child</code>? If you’re being strict, you might start by rewriting the tests for <code>Child</code>, as we did in <a href="B19611_09.xhtml#_idTextAnchor111"><em class="italic">Chapter 9</em></a>, <em class="italic">Extracting Logic Out of the Framework</em>, when we extracted the birthday repository. But generally, you wouldn’t stop there: you’d want to go back and delete those extra tests from <code>Parent</code>.</p>
<p>You could view this as part of the <em class="italic">Refactor</em> step of the TDD cycle. In fact, we did this in the preceding chapter when we ended up deleting a bunch of tests as we changed out the system functionality.</p>
<p>To repeat the message of this section: you don’t always need to use mocks. If you have a single test to prove the connection between <code>Parent</code> and <code>Child</code>, that’s often enough. Moreover, using TDD can naturally lead to you using this approach.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Using hand-rolled component stubs</h1>
<p>In this section, we’ll look at a simple <a id="_idIndexMarker409"/>but effective way of mocking components, by building hand-rolled component stubs. This isn’t as clever as using a component mock library, but it’s simpler and easier to understand. Often, the simplest approach is the best choice.</p>
<p>To recap what we’re trying to do: we have a child component that we want to avoid rendering, perhaps because it has mount behavior or it’s a complex third-party component.</p>
<p>Hand-rolled component stubs rely on Vitest’s <code>vi.mock</code> function combined with a special <code>__mocks__</code> directory. You create a stub component with the same name as your component, but inside a <code>__mocks__</code> directory at the same level as the component itself. Then, you<a id="_idIndexMarker410"/> instruct Vitest to use the mock using the <code>vi.mock</code> statement placed at the top of your test file. This will mean the entire test suite uses the mock.</p>
<p>We can demonstrate this using the page route component test suite, building mocks for the <code>Birthday</code> and <code>BirthdayForm</code> components. These components don’t have any side effects on mount, and they aren’t third party, but they do have their own test suites. So, even though it doesn’t feel necessary to make this change, it’s not unsafe to do so.</p>
<p>Since this work isn’t necessary, we’ll build an example test suite in a test file named <code>page.mocks.test.js</code>. Although this isn’t how I’d do this in the real world, it does highlight how you can have both mocked and non-mocked unit tests within the same code base.</p>
<p>We’ll start with a look at how to verify props using a stub component. Then, we’ll look at checking the ordering of instances, followed by dealing with complex prop verification, and finishing with a look at how to dispatch component events.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Rendering all props within a component stub</h2>
<p>In the preceding chapter, you<a id="_idIndexMarker411"/> saw that it’s important to verify the props that are passed into a test double. Component stubs are no different. The way we do this is to ensure that the component stub renders all the props and then use standard DOM matchers to verify their presence.</p>
<p>Let’s begin by creating a hand-rolled component stub for the <code>Birthday</code> component:</p>
<ol>
<li>Create a new directory named <code>src/routes/birthdays/__mocks__</code>. The special name is picked up automatically by Vitest as a location for your mocks.</li>
<li>Create a new file named <code>src/routes/birthdays/__mocks__/Birthday.svelte</code> with the following content. It does nothing but render out all the props that are passed in:<pre class="source-code">
&lt;script&gt;
  export let name;
  export let dob;
&lt;/script&gt;
&lt;div&gt;
  {name}
  {dob}
&lt;/div&gt;</pre></li>
<li>Now create a new test file named <code>src/routes/birthdays/page.mock.test.js</code> and start with the usual <code>import</code> statements. Notice<a id="_idIndexMarker412"/> how <code>vi</code> is included; we’ll use that in the next step:<pre class="source-code">
import {
  describe,
  it,
  expect,
  vi
} from 'vitest';
import {
  render,
  screen
} from '@testing-library/svelte';
import { click } from '@testing-library/user-event';
import {
  createBirthday
} from 'src/factories/birthday.js';
import Page from './+page.svelte';</pre></li>
<li>Next, just below the <code>import</code> statements, add a call to <code>vi.mock</code>. The path given must match <a id="_idIndexMarker413"/>the path to the <em class="italic">actual</em> <code>Birthday</code> component. Vitest will pick up the mock and load that instead:<pre class="source-code">
vi.mock('./Birthday.svelte');</pre></li>
<li>Now, start a new <code>describe</code> block, together with a sample <code>birthdays</code> array. All our tests will use this:<pre class="source-code">
describe('/birthdays', () =&gt; {
  const birthdays = [
    createBirthday('Hercules', '1994-02-02', {
      id: '123'
    }),
    createBirthday('Athena', '1989-01-01', {
      id: '234'
    })
  ];
});</pre></li>
<li>Time for the first test. This is going to check that given the two birthdays defined previously, each of the correct bits of information is displayed on screen:<pre class="source-code">
it('displays a Birthday component for each birthday', () =&gt; {
  render(Page, { data: { birthdays } });
  expect(
    screen.queryByText(/Hercules/)
  ).toBeVisible();
  expect(
    screen.queryByText(/1994-02-02/)
  ).toBeVisible();
  expect(
    screen.queryByText(/Athena/)
  ).toBeVisible();
  expect(
    screen.queryByText(/1989-01-01/)
  ).toBeVisible();
});</pre></li>
</ol>
<p class="callout-heading">Testing lists of components</p>
<p class="callout">This test checks <em class="italic">two</em> birthdays, not one: since <a id="_idIndexMarker414"/>we’re interested in the listing behavior – one <code>Birthday</code> component per entry – it’s important to test that a list of birthdays does in fact give a list of <code>Birthday</code> components. A single birthday isn’t enough to prove a list.</p>
<ol>
<li value="7">Because our<a id="_idIndexMarker415"/> implementation already exists, this test should already pass. But it’s important to prove the test works, and this time we want to also verify that the mock has been picked up. So, first delete the contents of the <em class="italic">actual</em> <code>Birthday</code> component (not the mock). The test should <em class="italic">still</em> pass. (Make sure you use the <code>v src/routes/birthdays/page.mocks.test.js</code> command to run your tests, otherwise you’ll see all the failures from other test suites.) This should convince you that the mock is being picked up.</li>
<li>Undo your changes to the <code>Birthday</code> component, and now let’s make a change to make the test fail. In the page route component at <code>src/routes/birthday/+page.svelte</code>, comment out the rendering of the <code>Birthday</code> component, like this:<pre class="source-code">
&lt;<strong class="bold">!--</strong>Birthday
  name={birthday.name}
  dob={birthday.dob}
/<strong class="bold">--</strong>&gt;</pre></li>
<li>Run the tests with <code>v src/routes/birthdays/page.mocks.test.js</code> and verify the test now fails. Then, undo your change.</li>
</ol>
<p>You’ve now learned <a id="_idIndexMarker416"/>about the basic usage of component stubs.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Checking the ordering of component instances</h2>
<p>Sometimes, when <a id="_idIndexMarker417"/>we are dealing with lists of components, we want to check the ordering of instances. We can check that using the <code>data-testid</code> attribute to get hold of each specific instance.</p>
<p>There is a general piece of advice to avoid using <code>data-testid</code> in tests. This is good advice, but your component stubs are a part of your test suite, not the application code, so it’s safe to use them here.</p>
<p class="callout-heading">When to use list ordering tests</p>
<p class="callout">The test in this section isn’t very TDD-like; it proves what I’d consider the <em class="italic">default</em> ordering of lists. If you already <a id="_idIndexMarker418"/>have a test that checks that data is listed, like the one in <em class="italic">step 6</em> of the preceding section, then the simplest way to make that pass is to implement the default ordering. So, writing a test like the one in <em class="italic">writing a test like the one your'e about to see</em> will likely pass by default, and is therefore an invalid test.</p>
<p>Let’s start:</p>
<ol>
<li>Update the component stub to add a <code>data-testid</code> attribute, like this:<pre class="source-code">
&lt;script&gt;
  export let name;
  export let dob;
&lt;/script&gt;
&lt;div <strong class="bold">data-testid="Birthday"</strong>&gt;
  {name}
  {dob}
&lt;/div&gt;</pre></li>
<li>Now, write a test that proves the ordering. It uses <code>queryAllByTestId</code> to return a list of <a id="_idIndexMarker419"/>elements that match a specific <code>data-testid</code> attribute <a id="_idIndexMarker420"/>value, in the order they are listed in the document:<pre class="source-code">
it('displays the Birthdays in the same order as the props passed in', () =&gt; {
  render(Page, { data: { birthdays } });
  const birthdayEls =
    screen.queryAllByTestId('Birthday');
  expect(birthdayEls[0]).toHaveTextContent(
    /Hercules/
  );
  expect(birthdayEls[1]).toHaveTextContent(
    /Athena/
  );
});</pre></li>
<li>This will pass, but make sure you verify it doesn’t pass by using the same commenting-out trick from previously.</li>
</ol>
<p>It’s also worth pointing out that there is another way to write an ordering test that doesn’t involve<a id="_idIndexMarker421"/> using the <code>data-testid</code> attribute. You could<a id="_idIndexMarker422"/> instead get hold of the <code>ol</code> element on the page, then map each of the <code>li</code> elements to their text content and check that it is an array in the order that you expect.</p>
<h2 id="_idParaDest-143"><a id="_idTextAnchor142"/>Dealing with complex props</h2>
<p>Sometimes, the props to your <a id="_idIndexMarker423"/>component are objects or arrays, and if you were to render them all out within the component stub, you’d end up with a whole bunch of code in the stub. There’s a shorter way of outputting prop values, which is to use the <code>JSON.stringify</code> function.</p>
<p>Let’s do that now for the <code>BirthdayForm</code> component:</p>
<ol>
<li>Create a new file named <code>src/routes/birthdays/__mocks__/BirthdayForm.svelte</code> with the following content:<pre class="source-code">
&lt;script&gt;
  export let form;
&lt;/script&gt;
&lt;div&gt;
  Editing {JSON.stringify(form)}
&lt;/div&gt;</pre></li>
<li>In your test suite, add a new call to <code>vi.mock</code> that pulls in this component, next to the previous call to <code>vi.mock</code>:<pre class="source-code">
vi.mock('./BirthdayForm.svelte');</pre></li>
<li>Next, add the following helper function at the top of the test suite:<pre class="source-code">
const firstEditButton = () =&gt;
  screen.queryAllByRole('button', {
    name: 'Edit'
  })[0];</pre></li>
<li>Then, add the next test, as<a id="_idIndexMarker424"/> shown; it also calls <code>JSON.stringify</code>. This should pass, but make sure to verify it before finishing:<pre class="source-code">
it('passes the currently edited birthday to the BirthdayForm component', async () =&gt; {
  render(Page, { data: { birthdays } });
  await click(firstEditButton());
  expect(
    screen.queryByText(
      `Editing ${JSON.stringify(birthdays[0])}`
    )
  ).toBeInTheDocument();
});</pre></li>
</ol>
<p>You will note the coupling between the component stub and the test suite. This component stub is quite awkward. What I find is that this technique of utilising <code>JSON.stringify</code> is generally fine as long as it’s the single pattern you use to check complex props and is used consistently between developers.</p>
<h2 id="_idParaDest-144"><a id="_idTextAnchor143"/>Dispatching component events</h2>
<p>The final <a id="_idIndexMarker425"/>component stub technique we will look at is the mechanism to dispatch component events. As in the last section, this is awkward, because it’s impossible to raise a component event on a hand-rolled stub without having a dispatcher object defined within the stub itself.</p>
<p>One way to deal with this is to just stick a button into the stub and use that to dispatch the event:</p>
<p class="callout-heading">Warning</p>
<p class="callout">The following example doesn’t make a huge amount of sense in the context of our application: the actual <code>BirthdayForm</code> component doesn’t have this <em class="italic">cancel</em> behavior, and if this feature <em class="italic">did</em> exist, it would probably make more sense to have the <strong class="bold">Cancel</strong> button within the page route, avoiding the need for a component event.</p>
<ol>
<li>Update the <code>BirthdayForm</code> component <a id="_idIndexMarker426"/>stub to include a <code>button</code> element that dispatches a <code>cancel</code> event:<pre class="source-code">
&lt;script&gt;
  import { createEventDispatcher } from 'svelte';
  <strong class="bold">const dispatcher = createEventDispatcher();</strong>
  <strong class="bold">export let form;</strong>
&lt;/script&gt;
&lt;div<strong class="bold"> data-testid="BirthdayForm"</strong>&gt;
  Editing {JSON.stringify(form)}
  <strong class="bold">&lt;button on:click={() =&gt; dispatcher('cancel')} /&gt;</strong>
&lt;/div&gt;</pre></li>
<li>Now, you can add a test that checks what happens when the <code>cancel</code> event is dispatched:<pre class="source-code">
it('cancels editing', async () =&gt; {
  render(Page, { data: { birthdays } });
  await click(firstEditButton());
  const button = screen
    .getByTestId('BirthdayForm')
    .querySelector('button');
  await click(button);
  expect(
    screen.queryByText(
      `Editing ${JSON.stringify(birthdays[0])}`
    )
  ).not.toBeInTheDocument();
});</pre></li>
<li>To make this <a id="_idIndexMarker427"/>pass, update the <code>page</code> component to respond to the <code>cancel</code> event:<pre class="source-code">
&lt;BirthdayForm
  form={editing}
  <strong class="bold">on:cancel={() =&gt; (editing = null)}</strong>
/&gt;</pre></li>
</ol>
<p>Remember, the <em class="italic">real</em> <code>BirthdayForm</code> component doesn’t have this behavior, and this exposes a big problem with mocking components: it’s challenging to keep the mock aligned with real implementations.</p>
<p>Avoiding hand-rolled mocks and using a library is one way to deal with this problem, as we’ll see in the next section.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor144"/>Using a component mock library</h1>
<p>In the last chapter, you saw how you <a id="_idIndexMarker428"/>can use <code>vi.fn</code> to spy on functions. The <code>svelte-component-double</code> npm package can be used in a similar fashion, achieving the same effect as the hand-rolled mocks you’ve just learned about.</p>
<p>The package includes matchers such as <code>toBeRendered</code> and <code>toBeRenderedWithProps</code> to check that the component is indeed rendered in the way you wanted.</p>
<p>Let’s split this into a couple of parts: installing the library and writing tests.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Installing the library</h2>
<p>The library requires a<a id="_idIndexMarker429"/> bit of setup to get the relevant matchers into place:</p>
<ol>
<li>Run the following command to install the package:<pre class="source-code">
<strong class="bold">npm install --save-dev svelte-component-double</strong></pre></li>
<li>Then, create a new file named <code>src/vitest/registerSvelteComponentDouble.js</code> with the following content. It registers the matchers and also gives us global access to the <code>componentDouble</code> function, which is not required but makes mock setup easier:<pre class="source-code">
import { expect } from 'vitest';
import
  as matchers
from 'svelte-component-double/vitest';
expect.extend(matchers);
import {
  componentDouble
} from 'svelte-component-double';
globalThis.componentDouble = componentDouble;</pre></li>
<li>Then, update your <code>vite.config.js</code> file to include the new setup file:<pre class="source-code">
setupFiles: [
  ...<strong class="bold">,</strong>
  <strong class="bold">'./src/vitest/registerSvelteComponentDouble.js'</strong>
],</pre></li>
</ol>
<p>You’re now ready to <a id="_idIndexMarker430"/>use the library in your tests.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Writing tests using the componentDouble function</h2>
<p>Now, we will<a id="_idIndexMarker431"/> rewrite the mock test suite to<a id="_idIndexMarker432"/> use the library rather than hand-rolled component stubs:</p>
<ol>
<li>Start by redefining the two calls to <code>vi.mock</code> with the following definitions. Each call to <code>componentDouble</code> gets a string identifier. This appears in your DOM output and is used in expectation failures:<pre class="source-code">
vi.mock('./Birthday.svelte', async () =&gt; ({
  default: componentDouble('Birthday')
}));
vi.mock('./BirthdayForm.svelte', async () =&gt; ({
  default: componentDouble('BirthdayForm')
}));</pre></li>
<li>You’ll also need to add two <code>import</code> statements at the top of the file so that you can access the mock object. Although it looks like you’re importing the actual components, you’ll actually get the component doubles:<pre class="source-code">
import Birthday from './Birthday.svelte';
import BirthdayForm from './BirthdayForm.svelte';</pre></li>
<li>It’s also important to reset the component doubles between each test. That’s because <code>vi.mock</code> will only<a id="_idIndexMarker433"/> generate a double once per test suite. Add the following two calls to <code>beforeEach</code> at the top of the <code>describe</code> block:<pre class="source-code">
describe('/birthdays', () =&gt; {
  <strong class="bold">beforeEach(Birthday.reset);</strong>
  <strong class="bold">beforeEach(BirthdayForm.reset);</strong>
  ...
});</pre></li>
<li>You’ll also <a id="_idIndexMarker434"/>need to update the <code>import</code> statement to pull in the <code>beforeEach</code> function:<pre class="source-code">
import {
  ...<strong class="bold">,</strong>
  <strong class="bold">beforeEach</strong>
} from 'vitest';</pre></li>
<li>Now for the first test. The makes use of the matcher <code>toBeRendered</code>, which checks that the component appears somewhere in the document. Update the first test to look like the following:<pre class="source-code">
it('displays a Birthday component for each birthday, () =&gt; {
  render(Page, { data: { birthdays } });
  <strong class="bold">expect(Birthday).toBeRendered();</strong>
});</pre></li>
<li>To run this test, mark it as <code>it.only</code> and then run Vitest on this test suite. You should see it passing; you can verify it in the usual way, by commenting out the <code>Birthday</code> component instance in the page route component. This time, you’ll see a failure printed as follows:<pre class="source-code">
Error: Expected "Birthday" component double to be rendered but it was not</pre></li>
<li>Undo that change so the test is passing again.</li>
<li>We know that <a id="_idIndexMarker435"/>not just one <code>Birthday</code> is displayed, but two. We can use the <code>toBeRenderedWithProps</code> matcher to check for individual instances of the component. Update<a id="_idIndexMarker436"/> the same test to use that matcher, like this:<pre class="source-code">
it('displays a Birthday component for each birthday', () =&gt; {
  render(Page, { data: { birthdays } });
  <strong class="bold">expect(Birthday).toBeRenderedWithProps({</strong>
  <strong class="bold">  name: 'Hercules',</strong>
  <strong class="bold">  </strong><strong class="bold">dob: '1994-02-02'</strong>
  <strong class="bold">});</strong>
  <strong class="bold">expect(Birthday).toBeRenderedWithProps({</strong>
  <strong class="bold">  name: 'Athena',</strong>
  <strong class="bold">  dob: '1989-01-01'</strong>
  <strong class="bold">});</strong>
});</pre></li>
</ol>
<p>Notice how the calls to <code>toBeRenderedWithProps</code> do not need to specify the full set of props. If the given subset matches, the expectation passes. That means we can avoid checking the <code>id</code> field, which is unnecessary detail for the purposes of this test.</p>
<ol>
<li value="9">If you comment out the rendering of <code>Birthday</code> in the component, you’ll see what a failure for<a id="_idIndexMarker437"/> this matcher looks like:<pre class="source-code">
Error: Expected "Birthday" component double to have been rendered once with props but it was not
Expected: Object {
  "dob": "1994-02-02",
  "name": "Hercules",
}
Received:</pre></li>
<li>The second test in this test suite checks the ordering of components. We can do that with the library<a id="_idIndexMarker438"/> by using the <code>propsOfAllInstances</code> function that exists on the double. Update the test to read as follows:<pre class="source-code">
it('displays the Birthdays in the same order as the props passed in', () =&gt; {
  render(Page, { data: { birthdays } });
  <strong class="bold">expect(Birthday.propsOfAllInstances()).toEqual([</strong>
  <strong class="bold">  expect.objectContaining({ name: 'Hercules' }),</strong>
  <strong class="bold">  expect.objectContaining({ name: 'Athena' })</strong>
  <strong class="bold">]);</strong>
});</pre></li>
<li>The first test for <code>BirthdayForm</code> no longer needs any <code>JSON.stringify</code> magic. We can just test the object prop directly. Update the test as follows:<pre class="source-code">
it('passes the currently edited birthday to the BirthdayForm component', async () =&gt; {
  render(Page, { data: { birthdays } });
  await click(firstEditButton());
  <strong class="bold">expect(BirthdayForm).toBeRenderedWithProps({</strong>
  <strong class="bold">  form: birthdays[0]</strong>
  <strong class="bold">});</strong>
});</pre></li>
<li>And finally, the last test <a id="_idIndexMarker439"/>can make use of the <code>dispatch</code> double function to dispatch an event to<a id="_idIndexMarker440"/> the parent component. Note how much simpler this is than the hand-rolled mock:<pre class="source-code">
it('cancels editing', async () =&gt; {
  render(Page, { data: { birthdays } });
  await click(firstEditButton());
  <strong class="bold">await BirthdayForm.dispatch('cancel');</strong>
  <strong class="bold">expect(BirthdayForm).not.toBeRenderedWithProps({</strong>
  <strong class="bold">  form: birthdays[0]</strong>
  <strong class="bold">});</strong>
});</pre></li>
</ol>
<p>These last two tests show how much simpler it can be to use a component mock library over hand-rolled mocks. That completes this section. You’ve now discovered all there is to using the <code>svelte-component-double</code> library to simplify your test suites.</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Summary</h1>
<p>This chapter has taken a very detailed look at component mocks. We started by looking at how it’s often possible to avoid using component mocks in the majority of cases, which is important because component mocks are a big cause of complexity in test suites.</p>
<p>You then saw how to use hand-rolled mocks that take advantage of Vitest’s <code>vi.mock</code> function together with component stubs in the specially named <code>__mocks__</code> directory. You also saw how they can quickly become complex.</p>
<p>Finally, we looked at using the <code>svelte-component-double</code> library to avoid using hand-rolled mocks. This provides a couple of simple matchers together with some helper functions to assist you in writing tests.</p>
<p>That completes all the unit testing topics within this book. The next chapter adds one more testing technique: using Cucumber.js to write <strong class="bold">Behavior-Driven Development</strong> (<strong class="bold">BDD</strong>) style tests for your team.</p>
</div>
</div></body></html>