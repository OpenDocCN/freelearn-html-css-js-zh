- en: Web and Service Workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's suppose that you are building a cool web app, say, to factorize a number
    to two prime numbers. Now, this involves a lot of CPU-intensive work, which will
    block the main UI thread. The main UI thread is the traffic lane that the end
    user directly observes and perceives. If it seems congested (laggy) or blocked,
    even for a few seconds, it destroys the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: This is where web workers come into the picture. Web workers can be thought
    of as those side-lanes available on the road where you can divert heavy and slow
    (CPU-intensive) trucks so that you don't block a user's shining Lamborghini on
    the main road (the main UI thread).
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, service workers are quite cool, too. A service worker is
    your own programmable network proxy, which sits right in between the user's internet
    connection and your website. There will be more on that in the *Working with service
    workers* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to web workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to dedicated workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up dedicated workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to shared workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up shared workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up inline web workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Communication with the main thread
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to service workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up service workers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An introduction to the concept of threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Simply put, a thread is a simple and independent snippet of running code. It
    is a container in which your tasks get executed. Before web workers, JavaScript
    provided just a single thread; that is, the main thread for the developers to
    do everything in.
  prefs: []
  type: TYPE_NORMAL
- en: This created some problems with advancements in tech. Suppose you're running
    a smooth CSS3 animation, and suddenly you need to do a heavy calculation on the
    JavaScript end for some reason. This'll make the animation sluggish if you do
    it on the main thread. However, if you offload it to a web worker that runs in
    its own thread, it will have no effect on the user experience.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because web workers run in their own threads, they cannot have access to the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`DOM`: It is not thread-safe to access it from web workers and the main UI
    script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`parent` object: Basically, this gives access to some DOM APIs that for the
    same reason as stated above, would be thread-unsafe to access'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`window` object: BOM (Browser Object Model); access to this is also thread-unsafe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`document` object: `DOM` object; hence, thread-unsafe'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Web workers lack access to all of the aforementioned items because it is not
    thread-safe to give workers access to them. Let's learn more about what I mean
    by that.
  prefs: []
  type: TYPE_NORMAL
- en: What makes something thread-safe?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When two or more threads access a common data source, extreme care must be taken,
    because there is a high chance of data corruption and thread safety conditions
    such as deadlocks, preconditions, race conditions, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript did not add thread support from the very start. With web workers
    introducing a **sort-of** threading environment in JavaScript, it'll help to understand
    a few conditions associated with threads in general.
  prefs: []
  type: TYPE_NORMAL
- en: What, exactly, is a deadlock?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A deadlock is a situation where two threads are waiting for each other, for
    whatever reasons, and the reasons of both threads depend on each other. The following
    figure will explain what deadlock means:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2baf6d73-527e-4759-b8b3-762242b2d7c9.png)'
  prefs: []
  type: TYPE_IMG
- en: Clearly, both threads (people with guns) need the other thread's resource in
    order to proceed. So, nobody proceeds.
  prefs: []
  type: TYPE_NORMAL
- en: What, exactly, is a race condition?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **race condition** is a problem that can happen if a DOM is allowed to be
    accessed by web workers. A race condition is a condition where two threads race,
    or compete, to read/modify a single data source. This is dangerous because when
    both threads try to modify the data at same time, and it is unknown which one
    will modify the data first. Consider the following example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose two threads are working on the same variable in memory:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Race conditions can be avoided by using **semaphores**, which is nothing but
    locking a shared data resource, until one thread is done with it and releases
    it back.
  prefs: []
  type: TYPE_NORMAL
- en: '**Just a fun fact:** If you ever use `sudo apt-get update` on Ubuntu or any
    Linux distro supporting `apt-get` as the package manager, and try to run another
    `apt-get update` command in another Terminal, you''ll get this error:'
  prefs: []
  type: TYPE_NORMAL
- en: '`E: Unable to lock the administration directory (/var/lib/dpkg/) is another
    process using it?`'
  prefs: []
  type: TYPE_NORMAL
- en: Linux locks the directory to avoid a possible race condition in which two commands
    overwrite each other's results.
  prefs: []
  type: TYPE_NORMAL
- en: Most languages have just a single thread that interacts with and updates the
    UI, and other threads can only post messages to the main thread to update the
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to web workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web worker is, essentially, a piece of JS code which does not run in the
    same thread as your main application. And by thread, I literally mean a different
    thread. The web workers truly enable JS to work in a multi-threaded mode. A question
    that might arise here is, What are the differences between asynchronous operations
    and web workers?
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, they are more or less the same thing. The web workers
    take away loads from the main thread for a while and then come back with the results.
    However understand the fact that `async` functions run on the UI thread, whereas
    web workers do not. Also, web workers are long-lived, and live inside a separate
    thread, whereas asynchronous operators, as we discussed in *Chapter 4, Asynchronous
    Programming,* follow the *Event loop*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance-wise, web workers are also much faster than traditional asynchronous
    operations. Here''s a test which sorts randomly generated arrays of lengths **10K**
    and **1M** as an asynchronous operation and web worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fd49ce5-f3e9-4e78-9db0-669da6798119.png)'
  prefs: []
  type: TYPE_IMG
- en: Take note that **2,493 ops/sec** means that JS was able to sort **2,493** arrays
    of length **10K** in **1** second! Async JS, on the other hand, was able to sort
    about 67 arrays of length **10K** in **1** second, which is still pretty darn
    fast, but quite a lot slower than its competitor.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if worker support is available
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although web workers have been around for quite a long time and support is very
    strong, you still might want to check if web worker support is available in a
    client's browser (for example, Opera Mini doesn't support it). If it isn't, then
    just load the web worker file in the main script as well, and let your user feel
    the heat.
  prefs: []
  type: TYPE_NORMAL
- en: 'Web workers are available as a `window` object, so that is pretty much all
    you have to check in order to get started:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Working with dedicated web workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dedicated workers** are the workers dedicated to a single main script. That
    means the worker cannot interact with any other script, apart from the main script
    on the page or any other domain.'
  prefs: []
  type: TYPE_NORMAL
- en: Let us try to understand dedicated workers by setting one up.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a dedicated worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calling a `new Worker()` with a filename in the constructor argument is all
    you need to do to spawn a dedicated worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Using the `new Worker` constructor, we created a `Worker` instance. This will
    make the browser download the `myworker.js` file and start a new OS thread for
    it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we can place in the `myworker.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This logs `Hello world` inside the console.
  prefs: []
  type: TYPE_NORMAL
- en: A worker can create a sub-worker itself, and everything below will apply to
    that, as well.
  prefs: []
  type: TYPE_NORMAL
- en: Working with dedicated workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dedicated workers can communicate with their spawning script, listening to certain
    events which trigger when either of the scripts sends/receives a message.
  prefs: []
  type: TYPE_NORMAL
- en: These events can be handled in both scripts (worker and main script) using certain
    event handlers. Let us learn how to achieve that.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for messages on the main script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can listen to what a worker sent to the main script with the `onmessage`
    event. This is how it''ll look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, our script is listening for messages sent by the worker. Every time a
    worker sends a message (which we'll see how to do in a minute, in the *Sending
    messages from the main script* section), the previous event is triggered and we
    console the data.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for messages on the worker script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Workers themselves have access to the `self` object, to which you can attach
    similar event listeners, as previously discussed. Let us see how that goes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Here, the message event listener is fired whenever the main script sends a message
    to this particular web worker. We simply console-log what the main script sent
    with `console.log(e.data)`.
  prefs: []
  type: TYPE_NORMAL
- en: You can omit the `self` keyword here if you wish. By default, in workers, events
    will be attached to `self`.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages from the main script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay! Once you''ve set up the listener event correctly, you will want to send
    some tasks to the worker for it to do. This is how to achieve that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Alright. Here, we're giving a task to the worker to add two numbers. Note that
    we are able to pass objects/arrays to the `postMessage` method, which is actually
    used to post/deliver a message to the worker which is spawned.
  prefs: []
  type: TYPE_NORMAL
- en: Objects messaged through `postMessage` are copied and not referenced. This means
    that, if the worker script modifies this object in any way, it will not reflect
    in the main `script` object. This is important for message passing consistency.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can receive this object at the other end (that is, the worker) and process
    it in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Here, on receiving the message, we check if the main script wants the worker
    to add numbers. If that's the case, we reduce the array value to a single value
    using the inbuilt `reduce` method to add all numbers in the passed array.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages from the worker script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the main script, `postMessage` is used in the worker script to communicate
    to the main script. Let us see how to post the previous result to the main script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, just like in the preceding code, we're reducing the array value to the
    `sum`, and then actually sending back whatever we did to the main UI script with
    the `postMessage` function. The passed object can be received by calling the script
    inside its own listening method.
  prefs: []
  type: TYPE_NORMAL
- en: '`script.js` would look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that we're sending the `task` to the worker in the form of
    an object, and the worker nicely performs the calculation and sends it to the
    main script, which is further handled by the message event listener attached to
    the `awesomeworker`, which simply writes the result to the document.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible that your worker might throw an error because of malformed data
    sent by the main script. In that case, the `onerror` method of the worker is called
    in the main script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we attached an error event listener, and for now, we're just logging it
    to the console. You might want to send it to a server to actually log it for further
    analysis in a production app.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worker is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In the previous case, the worker throws an error, which is visible in the main
    script as an `ErrorEvent` object. From there, you can handle the error.
  prefs: []
  type: TYPE_NORMAL
- en: Throwing an error from a web worker doesn't permanently stop it from working.
    It is still usable unless terminated.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can terminate a worker when you think it is no longer required. You can
    terminate a worker from either the worker itself or the parent script. Let us
    see how to do this in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating from the worker script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it might be required to terminate a worker within the worker when
    the worker is performing some sort of async task whose duration can be variable.
    There is a method called `close()` available inside the worker for that purpose:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Terminating from the main script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, you can terminate a worker from the main script, as well, if you
    wish to. After terminating, your worker instance can no longer be used to post
    messages to. It also kills any executing process in your worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `myworker.js` file for this would be:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Killing from within the worker involves calling `close()`, while from the parent
    script it involves calling `terminate()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Transferring (not copying) data through postMessage
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to actually just transfer large amounts of data using the `postMessage`
    function. What does that mean, and how it is different from what we've been doing
    so far with `postMessage`?
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the actual syntax of `postMessage` is: `postMessage(aMessage, transferList)`.'
  prefs: []
  type: TYPE_NORMAL
- en: What this means is, whatever you pass as `transferList` is apparently lost in
    the worker that sent it. You actually gave the other script the authority to own
    that data. You transferred the ownership of that data to that other script. Remember,
    this is different from what used to usually happen (that is, you can still access
    the object in the same script that sent it to the web worker/main script) because
    in this case, the data is not copied. Its ownership is transferred.
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it lightning fast to transfer very large amounts of data across
    web workers. Transferable objects include things like `ArrayBuffer`. Here''s an
    example of how to work with it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the size of our `ArrayBuffer` went from 100 to 0\. This is
    because you no longer have access to the `ArrayBuffer` memory, because you transferred
    it to some other script.
  prefs: []
  type: TYPE_NORMAL
- en: Working with shared workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed previously, shared workers are workers that multiple scripts can
    access, given that they follow the same origin policy (more on this in a later
    section named *Same origin policy*).
  prefs: []
  type: TYPE_NORMAL
- en: The API is a little different from dedicated workers, because these workers
    can be accessed by any script, so there's a need to manage all the connections
    via different ports baked into the `SharedWorker` object.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a shared worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A shared worker can be created by calling the `SharedWorker` constructor and
    providing the name of the file as the argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we used the `SharedWorker` constructor to create an instance of a `sharedworker`
    object. Unlike with dedicated workers, you won''t be able to see the HTTP network
    request in the browser made to the `myworker.js` file. This is important because
    the browser has to maintain only one instance of this file across multiple scripts
    calling this web worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Unlike dedicated workers, this does not log `Hello World!` in the main website's
    console. This is because shared workers do not get loaded into only that page.
    A shared worker is loaded once for every file accessing it. Therefore, it has
    its own console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In Google Chrome, to debug a shared worker, open `chrome://inspect/#workers`
    after opening the page which is responsible for launching the shared worker. There,
    you''ll have the option to debug it: ("Inspect" link)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57bd90a5-58ae-4621-b2c6-872208f41713.png)'
  prefs: []
  type: TYPE_IMG
- en: With that done, let's proceed to the guide to setting up listeners on shared
    workers.
  prefs: []
  type: TYPE_NORMAL
- en: Working with shared workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shared workers can communicate with their spawning script, listening to certain
    events which trigger when either of the scripts sends/receives a message. However,
    unlike dedicated workers, here we have to explicitly register the `onmessage`
    event on every connection.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for messages on the main script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, unlike with dedicated workers, we have to add the `onmessage` event on
    the port property which is available on the shared worker object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This event is triggered whenever our `SharedWorker` replies to this particular
    script.
  prefs: []
  type: TYPE_NORMAL
- en: Notice the line `awesomeworker.port.start();`, which instructs the shared worker
    to interact with this script. When using `addEventListener`, it is mandatory to
    start the communication with the `port.start()` line from both files (worker and
    script) for two-way communication.
  prefs: []
  type: TYPE_NORMAL
- en: Listening for messages on the worker script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, `self` is defined here; however, `window` is not. So, you can use  `self.addEventListener`
    or `addEventListener` (or just `onconnect = function()`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Here, the event contains the details about the ports our script is connected
    to. We pick up the connecting port and establish a connection with it.
  prefs: []
  type: TYPE_NORMAL
- en: Similar to our main script, we have to specify `port.start()` here for a successful
    communication between the two files.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages from parent scripts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that any script in the same origin (basically, same origin means that you're
    accessing it from multiple URLs covered under the same domain; for example, [https://www.google.co.in/](https://www.google.co.in/)[ ](https://www.google.co.in/)accessing
    `google.com/script.js` follows the same origin, but [facebook.com](https://www.facebook.com/)
    accessing `google.com/script.js` does not. There will be more on same origin in
    a later section named *Same origin policy*) can access the shared worker in the
    same way our previous `script.js`  accesses it, with the worker being in the same
    state for every file which accesses it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you''ll send a message from a script to a worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is similar to dedicated workers, with the exception that we have to explicitly
    mention the port object here.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `myworker.js` file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned previously, we need to do a `port.start()` to establish the communication
    between the worker and the main script if we use `addEventListener` to add the
    callbacks. Then we assign an event listener for `onmessage` for this particular
    port.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we just log to console what the calling script has to say to the worker.
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages from the worker script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve recognized the difference between how we call methods in dedicated
    workers versus how we call them in shared workers, well done! Instead of just
    calling methods on `self`, we''re calling all the dedicated web worker methods
    on the port object, which is how the worker distinguishes between so many scripts
    that (can possibly) talk to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: It is exactly like the code above, but with the exception that this time our
    shared worker replies to whoever sent the message and says `Hello` to it.
  prefs: []
  type: TYPE_NORMAL
- en: If you have two instances of the HTML page which loads `script.js` (that is,
    the new `SharedWorker`) running, both have separate port connections with the
    shared worker.
  prefs: []
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, error handling is a bit tricky. Since the error can occur anywhere in
    the script by any port (any parent file), you have to manually send the error
    to every port. But for that, you''ll have to store the ports, as well (when they''re
    connected). Here''s how it should look:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Here you can see that we are manually sending the error information to every
    parent file. Thereafter, you can handle the error in the parent file itself.
  prefs: []
  type: TYPE_NORMAL
- en: As a side note, it is good practice to have access to all connections in an
    array inside your shared worker. It might be helpful in some cases, such as when
    you want different pages to communicate with each other!
  prefs: []
  type: TYPE_NORMAL
- en: Terminating a shared worker connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can terminate a parent's connection from the shared worker, or completely
    shut down the shared worker. However, the latter can only be done by the worker's
    JS. The following sections talk about how you can terminate a single parent's
    connection with the worker.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating a single parent-worker connection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When this code is called, the connection between the parent and worker is shut
    down, and you''ll no longer be able to make use of that worker object to post
    messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Although the worker still lives, it loses its connection from the script which
    calls `.port.close()`.
  prefs: []
  type: TYPE_NORMAL
- en: After the connection is closed, the worker won't be able to send/receive messages
    from the main script. However, the main script can always call the shared web
    worker again by creating a new instance with the `new SharedWorker` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Terminating a shared worker completely
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A shared worker can itself be permanently terminated by calling `self.close()`
    inside its JS. You can also send a message from the parent script to kill the
    worker:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: We simply sent a message from our main script to our shared worker and passed
    the message that the shared worker should be terminated permanently.
  prefs: []
  type: TYPE_NORMAL
- en: 'The worker file looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: After verifying that the main script really wants to terminate the worker for
    all instances, the worker calls the `close` method on itself, which terminates
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to inline web workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to create a web worker from a single file without actually having
    a separate JS file for your web worker. However, I still recommend that you create
    a different file for your web workers, for the sake of clarity of code and to
    make it more modular. Modularity is always preferred in programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of `blob` URLs to actually point data in memory to a URL, and
    then load the `blob` URL instead of an actual file URL. Since this URL is generated
    dynamically only on the user''s computer, you do not need to create a separate
    file for that particular web worker. Here''s how we''ll do that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: It sometimes makes it easy to quickly fire a small web worker. However, this
    approach won't work for shared web workers. You'll need to have a separate file
    for them. This is because `SharedWorker` relies on the fact that all instances
    are loaded from one single file. However, creating a URL for blob data creates
    different URLs every time. So two pages, even if they have the same JS code, would
    have different URLs, and hence, different instances of `SharedWorker`.
  prefs: []
  type: TYPE_NORMAL
- en: Same origin policy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, I said a couple of times that shared workers will be available only
    to those parent files which share the same origin. What does that mean?
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider the URL [http://www.packtpub.com/all.](http://www.packtpub.com/all)
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a table demonstrating which URLs will be of the same origin with this
    domain, and which won''t be:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **New URL** | **Same** **Origin** | **Reason** |'
  prefs: []
  type: TYPE_TB
- en: '| [http://www.packtpub.com/support](http://www.packtpub.com/support) | Yes
    | - |'
  prefs: []
  type: TYPE_TB
- en: '| `http://www.packtpub.com/account/abc/xyz` | Yes | - |'
  prefs: []
  type: TYPE_TB
- en: '| [https://www.packtpub.com/all](https://www.packtpub.com/all) | No | Different
    protocol |'
  prefs: []
  type: TYPE_TB
- en: '| [http://username:password@www.packtpub.com/all](http://username:password@www.packtpub.com/all)
    | Yes | - |'
  prefs: []
  type: TYPE_TB
- en: '| `http://www.packtpub.com:8000/somepage` | No | Different port number |'
  prefs: []
  type: TYPE_TB
- en: '| `http://packtpub.com/somepage` | No | Different host |'
  prefs: []
  type: TYPE_TB
- en: '| `http://dev.packtpub.com/somepage` | No | Different host |'
  prefs: []
  type: TYPE_TB
- en: By now, I believe that you will be able to guess what makes something the same
    origin and what does not. Yes, you're right! The same host, port, and protocol
    make two URLs under the same origin. For listed URLs which have their answers
    as yes, only those URLs will be able to access the shared worker spun by [http://www.packtpub.com/all](http://www.packtpub.com/all).
  prefs: []
  type: TYPE_NORMAL
- en: Working with service workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service workers! They finally give developers precise control of the network
    layer by creating a network proxy in JavaScript. Using service workers, you can
    intercept and modify network resource requests, handle how caching is done, and
    respond appropriately when the user's network is down.
  prefs: []
  type: TYPE_NORMAL
- en: Let us show, step-by-step, how to set up a service worker and its associated
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for service workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prerequisites for service workers are:'
  prefs: []
  type: TYPE_NORMAL
- en: Because service workers are so powerful (almost like a network proxy) to avoid
    certain attacks, they're only available for domains running on HTTPS. However,
    they run fine on `localhost`, as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They heavily depend on promises, which we've already covered in depth in *Chapter
    4, Asynchronous Programming*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for browser support
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is easy to check whether a client''s browser supports service workers or
    not:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, I'll assume that a service worker is available in the user's browser,
    to avoid unnecessary code indentations every time.
  prefs: []
  type: TYPE_NORMAL
- en: The service worker life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following figure illustrates how a service worker lives:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bae86247-0f7d-4967-accd-515a09c38a9c.png)'
  prefs: []
  type: TYPE_IMG
- en: It is clear from the diagram that first a service worker needs to be installed.
    Then it triggers certain events which we can catch in our code to handle different
    stuff. Let us now discuss how to implement all of these steps, in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Registering a service worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, your main script has to register the service worker to the browser.
    Here''s how:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `reg` object is associated with information about the registration of your
    service worker.
  prefs: []
  type: TYPE_NORMAL
- en: A service worker registration code can be safely run multiple times. If already
    registered, the browser will not re-register it.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can debug service workers here: Chrome-->Inspect-->Service Workers.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that a service worker script's scope is the scope where it is located.
    For example, the preceding file is located in the root directory (`localhost/sw.js`),
    so it can intercept all `localhost/*` requests. If it were located in, say, `localhost/directory/sw.js`,
    then it would be able to intercept only `localhost/directory/*` requests.
  prefs: []
  type: TYPE_NORMAL
- en: Installing service workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once your worker is registered, an install event is triggered inside your service
    worker file. Here, we''ll set up caching of our resources. A lot of new terms
    are coming your way; hold tight:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Okay! What happened?
  prefs: []
  type: TYPE_NORMAL
- en: We added an install event listener to our `sw.js` file, which is triggered when
    our service worker is registered.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`e.waitUntil` accepts a promise (and we do give it a promise; remember that
    the `async function` returns a promise, and we invoked that function, as well).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we have something known as **CacheStorage** in browsers. We add resources
    to the cache by naming that cache and then using the `addAll` method to add the
    resources we want to cache.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass an array of all the files/paths we want to add to our cache storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The installation event is over.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is completely optional to set up caching inside the installation event itself.
    We can do it later, after the install event, as well. For example, you can set
    up caching on the go when fetching new resources.
  prefs: []
  type: TYPE_NORMAL
- en: Fetching with service workers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once everything is ready, you should be able to intercept requests with your
    service workers with the `fetch` event, in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Hang on! Let''s see what happened here:'
  prefs: []
  type: TYPE_NORMAL
- en: This listener will be fired whenever the browser makes a fetch request under
    its registration scope (we discussed that earlier).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`respondWith` also accepts a promise, which we gave it.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, we check whether or not the requested file is already present in our cache
    (using `catches.match(e.request)`). If it is, we return the cached file directly.
    If not, we use the fetch API (we discussed this in the previous chapter) to fetch
    the response, and the execution continues.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can also console-log `e.request` and play around with it a little to modify
    the request. It gives the developer of the site immense power over his own site,
    and thus should not be handled by anyone else. This is the reason service workers
    are available only over the  HTTPS protocol, to avoid a man-in-the-middle attack.
  prefs: []
  type: TYPE_NORMAL
- en: Service workers are a relatively new technology, and a lot of work is going
    on in their spec. Check out ;[http://bit.ly/serviceworkers ](http://bit.ly/serviceworkers)for
    any updates.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So, finally, we've had the chance to take a look at web workers and service
    workers and the great parts of the multi-threading environment provided by JavaScript!
    While service workers are the future of progressive web apps, web workers will
    be there to back them for any high-load task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Combine these techs in just the right way, and everything seems possible! In
    the next chapter, we''re going to take a look at very interesting concepts introduced
    in JavaScript for the first time: shared memory and atomics.'
  prefs: []
  type: TYPE_NORMAL
