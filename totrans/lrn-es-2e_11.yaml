- en: Web and Service Workers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络和服务工作者
- en: Let's suppose that you are building a cool web app, say, to factorize a number
    to two prime numbers. Now, this involves a lot of CPU-intensive work, which will
    block the main UI thread. The main UI thread is the traffic lane that the end
    user directly observes and perceives. If it seems congested (laggy) or blocked,
    even for a few seconds, it destroys the user experience.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你正在构建一个酷炫的Web应用，比如说，将一个数分解为两个质数。现在，这涉及到大量的CPU密集型工作，这将阻塞主UI线程。主UI线程是最终用户直接观察和感知的交通车道。如果它看起来拥堵（卡顿）或阻塞，即使只有几秒钟，也会破坏用户体验。
- en: This is where web workers come into the picture. Web workers can be thought
    of as those side-lanes available on the road where you can divert heavy and slow
    (CPU-intensive) trucks so that you don't block a user's shining Lamborghini on
    the main road (the main UI thread).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是web工作者发挥作用的地方。可以将web工作者想象为道路上的那些侧车道，你可以将重型和缓慢（CPU密集型）的卡车转移到那里，这样你就不至于阻塞主路上的用户闪亮的兰博基尼（主UI线程）。
- en: On the other hand, service workers are quite cool, too. A service worker is
    your own programmable network proxy, which sits right in between the user's internet
    connection and your website. There will be more on that in the *Working with service
    workers* section.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，服务工作者也非常酷。服务工作者是你自己的可编程网络代理，它位于用户互联网连接和你的网站之间。在*与服务工作者一起工作*部分将有更多关于这个话题的介绍。
- en: 'In this chapter, we''ll cover:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Introduction to threads
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 线程的介绍
- en: Introduction to web workers
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 网络工作者的介绍
- en: Introduction to dedicated workers
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 专用工作者的介绍
- en: Setting up dedicated workers
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置专用工作者
- en: Introduction to shared workers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 共享工作者的介绍
- en: Setting up shared workers
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置共享工作者
- en: Setting up inline web workers
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置内联web工作者
- en: Communication with the main thread
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与主线程的通信
- en: Introduction to service workers
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务工作者的介绍
- en: Setting up service workers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置服务工作者
- en: An introduction to the concept of threads
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 线程概念的介绍
- en: Simply put, a thread is a simple and independent snippet of running code. It
    is a container in which your tasks get executed. Before web workers, JavaScript
    provided just a single thread; that is, the main thread for the developers to
    do everything in.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，线程是一个简单且独立的运行代码片段。它是你的任务被执行的容器。在web工作者之前，JavaScript只提供了一个线程；即开发者的主线程，用于做所有事情。
- en: This created some problems with advancements in tech. Suppose you're running
    a smooth CSS3 animation, and suddenly you need to do a heavy calculation on the
    JavaScript end for some reason. This'll make the animation sluggish if you do
    it on the main thread. However, if you offload it to a web worker that runs in
    its own thread, it will have no effect on the user experience.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这在技术进步方面造成了一些问题。假设你正在运行一个平滑的CSS3动画，突然你需要因为某种原因在JavaScript端进行一些重量级的计算。如果你在主线程上这样做，这会使动画变得迟缓。然而，如果你将其卸载到在其自己的线程中运行的web
    worker，它将不会对用户体验产生影响。
- en: 'Because web workers run in their own threads, they cannot have access to the
    following:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于web workers在其自己的线程中运行，它们无法访问以下内容：
- en: '`DOM`: It is not thread-safe to access it from web workers and the main UI
    script'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DOM`：从web工作者和主UI脚本访问它不是线程安全的'
- en: '`parent` object: Basically, this gives access to some DOM APIs that for the
    same reason as stated above, would be thread-unsafe to access'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`parent`对象：基本上，这提供了访问一些DOM API的权限，正如上述原因，访问这些API也是线程不安全的'
- en: '`window` object: BOM (Browser Object Model); access to this is also thread-unsafe'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`window`对象：浏览器对象模型（BOM）；访问此对象也是线程不安全的'
- en: '`document` object: `DOM` object; hence, thread-unsafe'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`document`对象：`DOM`对象；因此，线程不安全'
- en: Web workers lack access to all of the aforementioned items because it is not
    thread-safe to give workers access to them. Let's learn more about what I mean
    by that.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: Web工作者无法访问上述所有内容，因为给予工作者访问它们不是线程安全的。让我们更深入地了解我所说的意思。
- en: What makes something thread-safe?
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是线程安全？
- en: When two or more threads access a common data source, extreme care must be taken,
    because there is a high chance of data corruption and thread safety conditions
    such as deadlocks, preconditions, race conditions, and so on.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个或更多线程访问一个公共数据源时，必须非常小心，因为数据损坏和线程安全条件（如死锁、先决条件、竞争条件等）的可能性很高。
- en: JavaScript did not add thread support from the very start. With web workers
    introducing a **sort-of** threading environment in JavaScript, it'll help to understand
    a few conditions associated with threads in general.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: What, exactly, is a deadlock?
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A deadlock is a situation where two threads are waiting for each other, for
    whatever reasons, and the reasons of both threads depend on each other. The following
    figure will explain what deadlock means:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/2baf6d73-527e-4759-b8b3-762242b2d7c9.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Clearly, both threads (people with guns) need the other thread's resource in
    order to proceed. So, nobody proceeds.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: What, exactly, is a race condition?
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A **race condition** is a problem that can happen if a DOM is allowed to be
    accessed by web workers. A race condition is a condition where two threads race,
    or compete, to read/modify a single data source. This is dangerous because when
    both threads try to modify the data at same time, and it is unknown which one
    will modify the data first. Consider the following example.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose two threads are working on the same variable in memory:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Race conditions can be avoided by using **semaphores**, which is nothing but
    locking a shared data resource, until one thread is done with it and releases
    it back.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '**Just a fun fact:** If you ever use `sudo apt-get update` on Ubuntu or any
    Linux distro supporting `apt-get` as the package manager, and try to run another
    `apt-get update` command in another Terminal, you''ll get this error:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
- en: '`E: Unable to lock the administration directory (/var/lib/dpkg/) is another
    process using it?`'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: Linux locks the directory to avoid a possible race condition in which two commands
    overwrite each other's results.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: Most languages have just a single thread that interacts with and updates the
    UI, and other threads can only post messages to the main thread to update the
    UI.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to web workers
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The web worker is, essentially, a piece of JS code which does not run in the
    same thread as your main application. And by thread, I literally mean a different
    thread. The web workers truly enable JS to work in a multi-threaded mode. A question
    that might arise here is, What are the differences between asynchronous operations
    and web workers?
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
- en: If you think about it, they are more or less the same thing. The web workers
    take away loads from the main thread for a while and then come back with the results.
    However understand the fact that `async` functions run on the UI thread, whereas
    web workers do not. Also, web workers are long-lived, and live inside a separate
    thread, whereas asynchronous operators, as we discussed in *Chapter 4, Asynchronous
    Programming,* follow the *Event loop*.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
- en: 'Performance-wise, web workers are also much faster than traditional asynchronous
    operations. Here''s a test which sorts randomly generated arrays of lengths **10K**
    and **1M** as an asynchronous operation and web worker:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0fd49ce5-f3e9-4e78-9db0-669da6798119.png)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
- en: Take note that **2,493 ops/sec** means that JS was able to sort **2,493** arrays
    of length **10K** in **1** second! Async JS, on the other hand, was able to sort
    about 67 arrays of length **10K** in **1** second, which is still pretty darn
    fast, but quite a lot slower than its competitor.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: Checking if worker support is available
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although web workers have been around for quite a long time and support is very
    strong, you still might want to check if web worker support is available in a
    client's browser (for example, Opera Mini doesn't support it). If it isn't, then
    just load the web worker file in the main script as well, and let your user feel
    the heat.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: 'Web workers are available as a `window` object, so that is pretty much all
    you have to check in order to get started:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Working with dedicated web workers
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Dedicated workers** are the workers dedicated to a single main script. That
    means the worker cannot interact with any other script, apart from the main script
    on the page or any other domain.'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Let us try to understand dedicated workers by setting one up.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a dedicated worker
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Calling a `new Worker()` with a filename in the constructor argument is all
    you need to do to spawn a dedicated worker:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Using the `new Worker` constructor, we created a `Worker` instance. This will
    make the browser download the `myworker.js` file and start a new OS thread for
    it.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: 'This is what we can place in the `myworker.js` file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This logs `Hello world` inside the console.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
- en: A worker can create a sub-worker itself, and everything below will apply to
    that, as well.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: Working with dedicated workers
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dedicated workers can communicate with their spawning script, listening to certain
    events which trigger when either of the scripts sends/receives a message.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
- en: These events can be handled in both scripts (worker and main script) using certain
    event handlers. Let us learn how to achieve that.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: Listening for messages on the main script
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We can listen to what a worker sent to the main script with the `onmessage`
    event. This is how it''ll look:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Here, our script is listening for messages sent by the worker. Every time a
    worker sends a message (which we'll see how to do in a minute, in the *Sending
    messages from the main script* section), the previous event is triggered and we
    console the data.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Listening for messages on the worker script
  id: totrans-68
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Workers themselves have access to the `self` object, to which you can attach
    similar event listeners, as previously discussed. Let us see how that goes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, the message event listener is fired whenever the main script sends a message
    to this particular web worker. We simply console-log what the main script sent
    with `console.log(e.data)`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: You can omit the `self` keyword here if you wish. By default, in workers, events
    will be attached to `self`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages from the main script
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay! Once you''ve set up the listener event correctly, you will want to send
    some tasks to the worker for it to do. This is how to achieve that:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Alright. Here, we're giving a task to the worker to add two numbers. Note that
    we are able to pass objects/arrays to the `postMessage` method, which is actually
    used to post/deliver a message to the worker which is spawned.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Objects messaged through `postMessage` are copied and not referenced. This means
    that, if the worker script modifies this object in any way, it will not reflect
    in the main `script` object. This is important for message passing consistency.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we can receive this object at the other end (that is, the worker) and process
    it in the following way:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Here, on receiving the message, we check if the main script wants the worker
    to add numbers. If that's the case, we reduce the array value to a single value
    using the inbuilt `reduce` method to add all numbers in the passed array.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages from the worker script
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similar to the main script, `postMessage` is used in the worker script to communicate
    to the main script. Let us see how to post the previous result to the main script:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, just like in the preceding code, we're reducing the array value to the
    `sum`, and then actually sending back whatever we did to the main UI script with
    the `postMessage` function. The passed object can be received by calling the script
    inside its own listening method.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: '`script.js` would look like the following:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you can see that we're sending the `task` to the worker in the form of
    an object, and the worker nicely performs the calculation and sends it to the
    main script, which is further handled by the message event listener attached to
    the `awesomeworker`, which simply writes the result to the document.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Error handling in workers
  id: totrans-88
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible that your worker might throw an error because of malformed data
    sent by the main script. In that case, the `onerror` method of the worker is called
    in the main script:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we attached an error event listener, and for now, we're just logging it
    to the console. You might want to send it to a server to actually log it for further
    analysis in a production app.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: 'The worker is as follows:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In the previous case, the worker throws an error, which is visible in the main
    script as an `ErrorEvent` object. From there, you can handle the error.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: Throwing an error from a web worker doesn't permanently stop it from working.
    It is still usable unless terminated.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
- en: Terminating workers
  id: totrans-96
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can terminate a worker when you think it is no longer required. You can
    terminate a worker from either the worker itself or the parent script. Let us
    see how to do this in the next section.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: Terminating from the worker script
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sometimes, it might be required to terminate a worker within the worker when
    the worker is performing some sort of async task whose duration can be variable.
    There is a method called `close()` available inside the worker for that purpose:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Terminating from the main script
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, you can terminate a worker from the main script, as well, if you
    wish to. After terminating, your worker instance can no longer be used to post
    messages to. It also kills any executing process in your worker:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `myworker.js` file for this would be:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-105
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Killing from within the worker involves calling `close()`, while from the parent
    script it involves calling `terminate()` methods.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: Transferring (not copying) data through postMessage
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is possible to actually just transfer large amounts of data using the `postMessage`
    function. What does that mean, and how it is different from what we've been doing
    so far with `postMessage`?
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Well, the actual syntax of `postMessage` is: `postMessage(aMessage, transferList)`.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: What this means is, whatever you pass as `transferList` is apparently lost in
    the worker that sent it. You actually gave the other script the authority to own
    that data. You transferred the ownership of that data to that other script. Remember,
    this is different from what used to usually happen (that is, you can still access
    the object in the same script that sent it to the web worker/main script) because
    in this case, the data is not copied. Its ownership is transferred.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: 'This makes it lightning fast to transfer very large amounts of data across
    web workers. Transferable objects include things like `ArrayBuffer`. Here''s an
    example of how to work with it:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: You can see that the size of our `ArrayBuffer` went from 100 to 0\. This is
    because you no longer have access to the `ArrayBuffer` memory, because you transferred
    it to some other script.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: Working with shared workers
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As discussed previously, shared workers are workers that multiple scripts can
    access, given that they follow the same origin policy (more on this in a later
    section named *Same origin policy*).
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: The API is a little different from dedicated workers, because these workers
    can be accessed by any script, so there's a need to manage all the connections
    via different ports baked into the `SharedWorker` object.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a shared worker
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A shared worker can be created by calling the `SharedWorker` constructor and
    providing the name of the file as the argument:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Here, we used the `SharedWorker` constructor to create an instance of a `sharedworker`
    object. Unlike with dedicated workers, you won''t be able to see the HTTP network
    request in the browser made to the `myworker.js` file. This is important because
    the browser has to maintain only one instance of this file across multiple scripts
    calling this web worker:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Unlike dedicated workers, this does not log `Hello World!` in the main website's
    console. This is because shared workers do not get loaded into only that page.
    A shared worker is loaded once for every file accessing it. Therefore, it has
    its own console.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'In Google Chrome, to debug a shared worker, open `chrome://inspect/#workers`
    after opening the page which is responsible for launching the shared worker. There,
    you''ll have the option to debug it: ("Inspect" link)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/57bd90a5-58ae-4621-b2c6-872208f41713.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
- en: With that done, let's proceed to the guide to setting up listeners on shared
    workers.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Working with shared workers
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Shared workers can communicate with their spawning script, listening to certain
    events which trigger when either of the scripts sends/receives a message. However,
    unlike dedicated workers, here we have to explicitly register the `onmessage`
    event on every connection.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: Listening for messages on the main script
  id: totrans-128
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Here, unlike with dedicated workers, we have to add the `onmessage` event on
    the port property which is available on the shared worker object:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This event is triggered whenever our `SharedWorker` replies to this particular
    script.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Notice the line `awesomeworker.port.start();`, which instructs the shared worker
    to interact with this script. When using `addEventListener`, it is mandatory to
    start the communication with the `port.start()` line from both files (worker and
    script) for two-way communication.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Listening for messages on the worker script
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Similarly, `self` is defined here; however, `window` is not. So, you can use  `self.addEventListener`
    or `addEventListener` (or just `onconnect = function()`):'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Here, the event contains the details about the ports our script is connected
    to. We pick up the connecting port and establish a connection with it.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Similar to our main script, we have to specify `port.start()` here for a successful
    communication between the two files.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages from parent scripts
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Note that any script in the same origin (basically, same origin means that you're
    accessing it from multiple URLs covered under the same domain; for example, [https://www.google.co.in/](https://www.google.co.in/)[ ](https://www.google.co.in/)accessing
    `google.com/script.js` follows the same origin, but [facebook.com](https://www.facebook.com/)
    accessing `google.com/script.js` does not. There will be more on same origin in
    a later section named *Same origin policy*) can access the shared worker in the
    same way our previous `script.js`  accesses it, with the worker being in the same
    state for every file which accesses it.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s how you''ll send a message from a script to a worker:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: This is similar to dedicated workers, with the exception that we have to explicitly
    mention the port object here.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'The `myworker.js` file looks like:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: As mentioned previously, we need to do a `port.start()` to establish the communication
    between the worker and the main script if we use `addEventListener` to add the
    callbacks. Then we assign an event listener for `onmessage` for this particular
    port.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we just log to console what the calling script has to say to the worker.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: Sending messages from the worker script
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'If you''ve recognized the difference between how we call methods in dedicated
    workers versus how we call them in shared workers, well done! Instead of just
    calling methods on `self`, we''re calling all the dedicated web worker methods
    on the port object, which is how the worker distinguishes between so many scripts
    that (can possibly) talk to it:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经认识到我们在专用工作者和共享工作者中调用方法的方式之间的区别，做得好！我们不是在`self`上调用方法，而是在端口对象上调用所有专用Web工作者方法，这是工作者区分许多（可能）与之通信的脚本的方式：
- en: '[PRE22]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: It is exactly like the code above, but with the exception that this time our
    shared worker replies to whoever sent the message and says `Hello` to it.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 它与上面的代码完全一样，但这次我们的共享工作者回复了发送消息的人，并向它说“你好”。
- en: If you have two instances of the HTML page which loads `script.js` (that is,
    the new `SharedWorker`) running, both have separate port connections with the
    shared worker.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您有两个实例的HTML页面正在运行，加载`script.js`（即新的`SharedWorker`），它们都与共享工作者有独立的端口连接。
- en: Error handling
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 错误处理
- en: 'Here, error handling is a bit tricky. Since the error can occur anywhere in
    the script by any port (any parent file), you have to manually send the error
    to every port. But for that, you''ll have to store the ports, as well (when they''re
    connected). Here''s how it should look:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，错误处理有点棘手。由于错误可能由任何端口（任何父文件）在任何脚本中发生，您必须手动将错误发送到每个端口。但为此，您还必须存储端口（当它们连接时）。以下是它应该看起来像什么：
- en: '[PRE23]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Here you can see that we are manually sending the error information to every
    parent file. Thereafter, you can handle the error in the parent file itself.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您可以看到我们正在手动将错误信息发送到每个父文件。之后，您可以在父文件本身中处理错误。
- en: As a side note, it is good practice to have access to all connections in an
    array inside your shared worker. It might be helpful in some cases, such as when
    you want different pages to communicate with each other!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，在您的共享工作者内部有一个数组访问所有连接是一个好习惯。在某些情况下可能会有所帮助，例如，当您想要不同的页面相互通信时！
- en: Terminating a shared worker connection
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断开共享工作者连接
- en: You can terminate a parent's connection from the shared worker, or completely
    shut down the shared worker. However, the latter can only be done by the worker's
    JS. The following sections talk about how you can terminate a single parent's
    connection with the worker.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从共享工作者那里断开父进程的连接，或者完全关闭共享工作者。然而，后者只能由工作者的JS完成。以下章节将讨论您如何断开单个父进程与工作者的连接。
- en: Terminating a single parent-worker connection
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 断开单个父-工作者连接
- en: 'When this code is called, the connection between the parent and worker is shut
    down, and you''ll no longer be able to make use of that worker object to post
    messages:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 当调用此代码时，父进程与工作者之间的连接被关闭，您将无法再使用该工作者对象来发送消息：
- en: '[PRE24]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Although the worker still lives, it loses its connection from the script which
    calls `.port.close()`.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管工作者仍然存在，但它失去了调用`.port.close()`的脚本的连接。
- en: After the connection is closed, the worker won't be able to send/receive messages
    from the main script. However, the main script can always call the shared web
    worker again by creating a new instance with the `new SharedWorker` constructor.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 连接关闭后，工作者将无法从主脚本发送/接收消息。然而，主脚本始终可以通过使用`new SharedWorker`构造函数创建一个新的实例来再次调用共享Web工作者。
- en: Terminating a shared worker completely
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 完全断开共享工作者
- en: 'A shared worker can itself be permanently terminated by calling `self.close()`
    inside its JS. You can also send a message from the parent script to kill the
    worker:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在其JS内部调用`self.close()`来永久终止共享工作者。您也可以从父脚本发送消息来杀死工作者：
- en: '[PRE25]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We simply sent a message from our main script to our shared worker and passed
    the message that the shared worker should be terminated permanently.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们只是从我们的主脚本向我们的共享工作者发送了一条消息，并传递了共享工作者应该被永久终止的消息。
- en: 'The worker file looks like:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 工作者文件看起来像：
- en: '[PRE26]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: After verifying that the main script really wants to terminate the worker for
    all instances, the worker calls the `close` method on itself, which terminates
    it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在验证主脚本确实想要终止所有实例的工作者之后，工作者在其自身上调用`close`方法，从而终止它。
- en: Introduction to inline web workers
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内联Web工作者的介绍
- en: It is possible to create a web worker from a single file without actually having
    a separate JS file for your web worker. However, I still recommend that you create
    a different file for your web workers, for the sake of clarity of code and to
    make it more modular. Modularity is always preferred in programming.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make use of `blob` URLs to actually point data in memory to a URL, and
    then load the `blob` URL instead of an actual file URL. Since this URL is generated
    dynamically only on the user''s computer, you do not need to create a separate
    file for that particular web worker. Here''s how we''ll do that:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It sometimes makes it easy to quickly fire a small web worker. However, this
    approach won't work for shared web workers. You'll need to have a separate file
    for them. This is because `SharedWorker` relies on the fact that all instances
    are loaded from one single file. However, creating a URL for blob data creates
    different URLs every time. So two pages, even if they have the same JS code, would
    have different URLs, and hence, different instances of `SharedWorker`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Same origin policy
  id: totrans-176
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Earlier, I said a couple of times that shared workers will be available only
    to those parent files which share the same origin. What does that mean?
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
- en: Let us consider the URL [http://www.packtpub.com/all.](http://www.packtpub.com/all)
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s a table demonstrating which URLs will be of the same origin with this
    domain, and which won''t be:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: '| **New URL** | **Same** **Origin** | **Reason** |'
  id: totrans-180
  prefs: []
  type: TYPE_TB
- en: '| [http://www.packtpub.com/support](http://www.packtpub.com/support) | Yes
    | - |'
  id: totrans-181
  prefs: []
  type: TYPE_TB
- en: '| `http://www.packtpub.com/account/abc/xyz` | Yes | - |'
  id: totrans-182
  prefs: []
  type: TYPE_TB
- en: '| [https://www.packtpub.com/all](https://www.packtpub.com/all) | No | Different
    protocol |'
  id: totrans-183
  prefs: []
  type: TYPE_TB
- en: '| [http://username:password@www.packtpub.com/all](http://username:password@www.packtpub.com/all)
    | Yes | - |'
  id: totrans-184
  prefs: []
  type: TYPE_TB
- en: '| `http://www.packtpub.com:8000/somepage` | No | Different port number |'
  id: totrans-185
  prefs: []
  type: TYPE_TB
- en: '| `http://packtpub.com/somepage` | No | Different host |'
  id: totrans-186
  prefs: []
  type: TYPE_TB
- en: '| `http://dev.packtpub.com/somepage` | No | Different host |'
  id: totrans-187
  prefs: []
  type: TYPE_TB
- en: By now, I believe that you will be able to guess what makes something the same
    origin and what does not. Yes, you're right! The same host, port, and protocol
    make two URLs under the same origin. For listed URLs which have their answers
    as yes, only those URLs will be able to access the shared worker spun by [http://www.packtpub.com/all](http://www.packtpub.com/all).
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Working with service workers
  id: totrans-189
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Service workers! They finally give developers precise control of the network
    layer by creating a network proxy in JavaScript. Using service workers, you can
    intercept and modify network resource requests, handle how caching is done, and
    respond appropriately when the user's network is down.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Let us show, step-by-step, how to set up a service worker and its associated
    methods.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
- en: Prerequisites for service workers
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Prerequisites for service workers are:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: Because service workers are so powerful (almost like a network proxy) to avoid
    certain attacks, they're only available for domains running on HTTPS. However,
    they run fine on `localhost`, as well.
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They heavily depend on promises, which we've already covered in depth in *Chapter
    4, Asynchronous Programming*.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking for browser support
  id: totrans-196
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is easy to check whether a client''s browser supports service workers or
    not:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Here, I'll assume that a service worker is available in the user's browser,
    to avoid unnecessary code indentations every time.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: The service worker life cycle
  id: totrans-200
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following figure illustrates how a service worker lives:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bae86247-0f7d-4967-accd-515a09c38a9c.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
- en: It is clear from the diagram that first a service worker needs to be installed.
    Then it triggers certain events which we can catch in our code to handle different
    stuff. Let us now discuss how to implement all of these steps, in detail.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: Registering a service worker
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, your main script has to register the service worker to the browser.
    Here''s how:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `reg` object is associated with information about the registration of your
    service worker.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: A service worker registration code can be safely run multiple times. If already
    registered, the browser will not re-register it.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
- en: 'You can debug service workers here: Chrome-->Inspect-->Service Workers.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
- en: Note that a service worker script's scope is the scope where it is located.
    For example, the preceding file is located in the root directory (`localhost/sw.js`),
    so it can intercept all `localhost/*` requests. If it were located in, say, `localhost/directory/sw.js`,
    then it would be able to intercept only `localhost/directory/*` requests.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
- en: Installing service workers
  id: totrans-211
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once your worker is registered, an install event is triggered inside your service
    worker file. Here, we''ll set up caching of our resources. A lot of new terms
    are coming your way; hold tight:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Okay! What happened?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: We added an install event listener to our `sw.js` file, which is triggered when
    our service worker is registered.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`e.waitUntil` accepts a promise (and we do give it a promise; remember that
    the `async function` returns a promise, and we invoked that function, as well).'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then we have something known as **CacheStorage** in browsers. We add resources
    to the cache by naming that cache and then using the `addAll` method to add the
    resources we want to cache.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We pass an array of all the files/paths we want to add to our cache storage.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The installation event is over.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is completely optional to set up caching inside the installation event itself.
    We can do it later, after the install event, as well. For example, you can set
    up caching on the go when fetching new resources.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
- en: Fetching with service workers
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Once everything is ready, you should be able to intercept requests with your
    service workers with the `fetch` event, in the following way:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Hang on! Let''s see what happened here:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: This listener will be fired whenever the browser makes a fetch request under
    its registration scope (we discussed that earlier).
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这个监听器将在浏览器在其注册范围内进行fetch请求时被触发（我们之前讨论过这一点）。
- en: '`respondWith` also accepts a promise, which we gave it.'
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`respondWith`也接受一个承诺，这是我们给它提供的。'
- en: Then, we check whether or not the requested file is already present in our cache
    (using `catches.match(e.request)`). If it is, we return the cached file directly.
    If not, we use the fetch API (we discussed this in the previous chapter) to fetch
    the response, and the execution continues.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们检查请求的文件是否已经存在于我们的缓存中（使用`catches.match(e.request)`）。如果是，我们直接返回缓存的文件。如果不是，我们使用fetch
    API（我们之前章节讨论过）来获取响应，然后继续执行。
- en: You can also console-log `e.request` and play around with it a little to modify
    the request. It gives the developer of the site immense power over his own site,
    and thus should not be handled by anyone else. This is the reason service workers
    are available only over the  HTTPS protocol, to avoid a man-in-the-middle attack.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在控制台中打印出`e.request`并稍作修改以修改请求。这给了网站开发者对其自己网站巨大的控制权，因此不应由其他人处理。这也是为什么service
    workers仅在HTTPS协议上可用，以避免中间人攻击。
- en: Service workers are a relatively new technology, and a lot of work is going
    on in their spec. Check out ;[http://bit.ly/serviceworkers ](http://bit.ly/serviceworkers)for
    any updates.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: Service workers是一项相对较新的技术，它们的标准正在经历许多工作。查看[http://bit.ly/serviceworkers](http://bit.ly/serviceworkers)获取任何更新。
- en: Summary
  id: totrans-230
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: So, finally, we've had the chance to take a look at web workers and service
    workers and the great parts of the multi-threading environment provided by JavaScript!
    While service workers are the future of progressive web apps, web workers will
    be there to back them for any high-load task.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终，我们有机会查看web workers和service workers以及JavaScript提供的多线程环境中的精彩部分！虽然service
    workers是渐进式Web应用的未来，但web workers将支持它们处理任何高负载任务。
- en: 'Combine these techs in just the right way, and everything seems possible! In
    the next chapter, we''re going to take a look at very interesting concepts introduced
    in JavaScript for the first time: shared memory and atomics.'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 正确地结合这些技术，似乎一切皆有可能！在下一章中，我们将探讨JavaScript首次引入的非常有趣的概念：共享内存和原子操作。
