- en: 12\. Guide to Promises in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: This chapter explores asynchronous programming in TypeScript using promises
    and discusses uses for asynchronous programming and how it is implemented in single-threaded
    JavaScript with the event loop. By the end of the chapter, you should have a solid
    understanding of how promises work and how TypeScript can enhance them. You will
    also be able to build a promise-based app using the concepts taught in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we learned about asynchronous programming using callbacks.
    With this knowledge, we can manage concurrent requests and write non-blocking
    code that allows our applications to render web pages faster or serve concurrent
    requests on a Node.js server.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how promises allow us to write more readable,
    concise code to better manage asynchronous processes and forever escape deep callback
    nesting, sometimes known as "callback hell." We will explore the evolution of
    the `Promise` object and how it eventually became part of the JavaScript language.
    We'll look at different transpilation targets for TypeScript and how TypeScript
    can enhance promises and allow developers to leverage generics to infer return
    types.
  prefs: []
  type: TYPE_NORMAL
- en: We will work on some practical exercises, such as managing multiple API requests
    from a website and managing concurrency in Node.js. We will use the Node.js FileSystem
    API to perform asynchronous operations on files and see how powerful asynchronous
    programming can be.
  prefs: []
  type: TYPE_NORMAL
- en: The Evolution of and Motivation for Promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we''ve learned, a callback is a function that is given as an argument to
    another function, in effect saying, "do this when you are done." This capability
    has been in JavaScript since its inception in 1995 and can work very well, but
    as the complexity of JavaScript applications grew through the 2000s, developers
    found callback patterns and nesting in particular to be too messy and unreadable,
    giving rise to complaints about "callback hell" as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In addition to making code more readable and concise, promises have advantages
    beyond callbacks in that promises are objects that contain the state of the resolving
    asynchronous function. This means that a promise can be stored and either queried
    for the current state or called via its `then()` or `catch()` methods at any time
    to obtain the resolved state of the promise. We'll discuss those methods later
    in this chapter, but it's worth calling out at the beginning here that promises
    are more than syntactic sugar. They open up entirely new programming paradigms
    in which event handling logic can be decoupled from the event itself, just by
    storing the event in a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Promises are not unique to JavaScript but were first proposed as a computer
    programming concept in the 1970s.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more information, refer to Friedman, Daniel; David Wise (1976). *The Impact
    of Applicative Programming on Multiprocessing*. International Conference on Parallel
    Processing. pp. 263–272.
  prefs: []
  type: TYPE_NORMAL
- en: As web frameworks gained popularity, proposals for promises started to appear
    in 2009 and libraries such as jQuery started implementing promise-like objects
    in 2011\.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information, refer to the following: [https://groups.google.com/g/commonjs/c/6T9z75fohDk](https://groups.google.com/g/commonjs/c/6T9z75fohDk)
    and [https://api.jquery.com/category/version/1.5/](https://api.jquery.com/category/version/1.5/)'
  prefs: []
  type: TYPE_NORMAL
- en: It wasn't long before Node.js started to have some promise libraries as well.
    Google's AngularJS bundled the Q library. All of these libraries wrapped callbacks
    in a higher-level API that appealed to developers and helped them to write cleaner
    and more readable code.
  prefs: []
  type: TYPE_NORMAL
- en: In 2012, promises were proposed as an official specification in order to standardize
    the API. The specification was accepted in 2015 and has since been implemented
    in all major browsers as well as Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For more details, refer to [http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor](http://www.ecma-international.org/ecma-262/6.0/#sec-promise-constructor).
  prefs: []
  type: TYPE_NORMAL
- en: '"Promisification," the ability to wrap an existing asynchronous function in
    a promise, was added to many libraries and became part of the `util` package in
    the standard Node.js library as of version 8.0 (released in 2017).'
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript, as a superset of JavaScript, will always support native language
    features such as promises; however, TypeScript does not provide polyfills, so
    if the target environment doesn't support native promises, a library is required.
  prefs: []
  type: TYPE_NORMAL
- en: Most JavaScript runtimes (such as a web browser or Node.js server) are single-threaded
    execution environments. That means the main JavaScript process will only do one
    thing at a time. Thanks to the event loop, the runtime will seem like it's capable
    of doing many things at once as long as we write non-blocking code. The event
    loop recognizes asynchronous events and can turn to other tasks while it waits
    for those events to resolve.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the example of a web page that needs to call an API to load data into
    a table. If that API call were blocking, then that would mean the page render
    couldn''t complete until the data loaded. Our user would have to stare at a blank
    page until all the data loaded and page elements rendered. But because of the
    event loop, we can register a listener that allows rendering of the website to
    continue and then load the table when our data is finally returned. This is visualized
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.1: A typical event loop'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_12_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.1: A typical event loop'
  prefs: []
  type: TYPE_NORMAL
- en: 'This can be implemented using callbacks or promises. The event loop is what
    makes this possible. Node.js works similarly, but now we may be responding to
    requests from a multitude of clients. In this simple example, three different
    requests are being made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 12.2: Multiple requests'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_12_02.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.2: Multiple requests'
  prefs: []
  type: TYPE_NORMAL
- en: The API is not blocking so additional requests can come in even when the initial
    one has not been served. The requests are served in the order the work is completed.
  prefs: []
  type: TYPE_NORMAL
- en: Anatomy of a Promise
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A promise is a JavaScript object that can exist in three states: *pending*,
    *fulfilled*, or *rejected*. Although promises can be instantly fulfilled or rejected,
    it is most typical for a promise to be created in a pending state and then resolved
    to be fulfilled or rejected as an operation succeeds or fails. Promises are chainable
    and implement several convenience methods that we''ll go into.'
  prefs: []
  type: TYPE_NORMAL
- en: To understand the states of a promise better, it's important to know that the
    states of a promise cannot be queried. As a programmer, we do not check the state
    of the promise and take action based on that state. Rather we provide a function
    callback that will be invoked when the promise reaches that state. For example,
    we make an HTTP request to our backend server and get a promise in response. Now
    we have set up our event and we merely need to tell the promise what to do next
    and how to handle any errors. Examples of this will follow.
  prefs: []
  type: TYPE_NORMAL
- en: The Promise Callback
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A promise can be instantiated using the `new` keyword and `Promise` constructor.
    When instantiated in this way, `Promise` expects a callback argument that contains
    the actual work to be done. The callback has two arguments of its own, `resolve`
    and `reject`. These arguments can be called explicitly to either resolve or reject
    the promise. For example, we can create a promise that resolves after 100 ms like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'We could also create a promise that rejects after 100 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: then and catch
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Promises can be chained into callback functions of their own using `then` and
    `catch`. The callback function given to `then` will fire only once the promise
    is fulfilled and the callback function given to `catch` will only fire if the
    promise is rejected. Most libraries that return promises will automatically call
    `resolve` and `reject`, so we only need to provide `then` and `catch`. Here''s
    an example using the Fetch API:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: This code will make a call to our backend server and log out the result. If
    the call fails, it'll log that too.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this were a real application, we might have a couple of functions, `showData`
    and `handleError`, that could manage what our application does with the response
    from the server. In that case, the use of `fetch` would likely be something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Using promises like this shows how we can decouple our asynchronous processes
    from business logic and display elements.
  prefs: []
  type: TYPE_NORMAL
- en: Pending State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A pending promise is one that has yet to complete its work. It''s simple to
    create a promise that is forever stuck in a pending state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This promise will never do anything as neither `resolve` nor `reject` are ever
    called. The promise will remain in a pending state. If we execute this code, it'll
    print out `Promise { <pending> }`. As noted above, we do not query the state of
    a promise but rather provide a callback for the eventual resolution of a promise.
    The sample code above contains a promise that can never be resolved and as such
    could be seen as invalid code. There is no use case for promises that cannot resolve.
  prefs: []
  type: TYPE_NORMAL
- en: Fulfilled State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a promise that is fulfilled immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This will log out `Promise { 'fulfilled!' }`.
  prefs: []
  type: TYPE_NORMAL
- en: Unlike the pending state, creating a promise that resolves immediately has a
    few more practical use cases. The primary use of an immediately resolved promise
    would be when working with an API that expects a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Rejected State
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can create a promise that is fulfilled immediately:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This will log out `Promise { <rejected> 'rejected!' }` and then throw an unhandled
    promise rejection warning. Rejected promises always need to be caught. Failure
    to catch a promise rejection may cause our program to crash!
  prefs: []
  type: TYPE_NORMAL
- en: As with the fulfilled state, the primary use case for immediately rejecting
    a promise would be for writing a good unit test, but there may be secondary use
    cases in which some process throws an error during an asynchronous workflow and
    it may make sense to return a rejected promise. This circumstance would be most
    likely when working with a third-party library where the API isn't quite to our
    liking and we need to wrap it with something more in line with the rest of our
    application architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Chaining
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One of the main advantages of promises over callbacks is the ability to chain
    promises together. Consider a function that waits 1 second, generates a random
    number between 0 and 99, and adds it to the previous result. There are better
    ways to write recursive functions, but this is meant to simulate a website making
    several calls to a backend:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample output of this program is the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Each time we call `getTheValue`, we wait 1 second, then generate a random number
    and add it to the value we passed in. In a real-world scenario, we can think of
    this as a program that completes several asynchronous tasks, using the output
    from the last one as input to the next.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As the starting point of the program is a random number, your output would be
    different from the one presented above.
  prefs: []
  type: TYPE_NORMAL
- en: Everything in the previous program works correctly; however, the callback nesting
    isn't very nice to look at and could be challenging to maintain or debug. The
    next exercise will teach you how you can write more readable and maintainable
    code using promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.01: Chaining Promises'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we will refactor the preceding example and chain promises
    to eliminate nesting and make the code more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can be found here: [https://packt.link/IO8Pz](https://packt.link/IO8Pz).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Write the following program, which refactors the previous example using promises:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The nesting is gone and the code is a lot more readable. Our `getTheValue` function
    now returns a promise instead of using a callback. Because it returns a promise,
    we can call `.then()` on the promise, which can be chained into another promise
    call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the program. The chain of promises will resolve each in turn and we''ll
    get similar output to the previous program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that you will get an output that is different from the one shown above
    because the program uses a random number as the starting point.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Chaining can also be a big help when it comes to error conditions. If my `getTheValue`
    function rejects the promise, I''m able to catch the error by chaining a single
    `catch` to the end of the chain:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We are introducing a 10% chance (the chance our number when divided by 10 will
    have a remainder of 0) of throwing an error on each iteration. On average, our
    program will fail more often than it executes successfully now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: finally
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to `then` and `catch` methods, the `Promise` object also exposes
    a `finally` method. This is a callback function that will be called regardless
    of whether an error is thrown or caught. It's great for logging, closing a database
    connection, or simply cleaning up resources, regardless of how the promise is
    eventually resolved.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can add a `finally` callback to the above promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Now `"We are done!"` will be logged regardless of whether or not we trip the
    `"Bad modulus!"` error condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Promise.all
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Promise.all` is one of the most useful utility methods that `Promise` has
    to offer. Even code written with async/await syntax (see *Chapter 13, Async/Await*)
    can make good use of `Promise.all`. This method takes an iterable (likely an array)
    of promises as an argument and resolves all of them. Let''s see how we can change
    our example promise using `Promise.all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The output should be similar to the ones obtained for the preceding examples.
    In this example, we call the same function 10 times, but imagine these are 10
    different API calls we need to reach and then sum the total. Each call takes approximately
    1 second. If we chain a series of promises, this operation will take just over
    10 seconds. By using `Promise.all`, we are able to run those operations in parallel
    and now it takes only 1 second to complete the function.
  prefs: []
  type: TYPE_NORMAL
- en: '`Promise.all` is useful any time you can run two or more asynchronous processes
    in parallel. It can be useful for persisting data to multiple database tables,
    letting multiple independent components render in a web browser independently,
    or making multiple HTTP requests. A good example of making multiple HTTP requests
    in parallel would be a service that monitors the uptime and ping duration of other
    services. There''s no reason such an operation would need to be synchronous and
    `Promise.all` lets us wait on several web requests within the same process.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.02: Recursive Promise.all'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, instead of repeating the same function call 10 times, let''s
    optimize the programs from the previous examples to be more DRY (don''t repeat
    yourself). We can load up an array of promises and then use `Promise.all` to resolve
    all the promises in parallel and use `catch` and `finally` to resolve errors and
    ensure we return some output:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can also be found here: [https://packt.link/KNpqx](https://packt.link/KNpqx).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code will be our starting place for this refactor:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In order to catch errors and make the program recursive, we'll need to wrap
    `Promise.all` in a function. Recursion is a pattern in which the same function
    can be called multiple times within the same execution.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To add the recursion, create a new function and make the `Promise.all` statement
    the body of that function. Then call the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We can use some functional programming techniques to, rather than having an
    array in which `getTheValue()` is repeated 10 times, programmatically construct
    an array of 10 elements, all of which are that function call. Doing this won't
    change how our program operates, but it will make it a bit nicer to work with.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Update the code given in the preceding step with the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The logic here is that `Array(10)` creates a new array of 10 elements, `fill(null)`
    will initialize the array, then `map` will remap the array elements to be the
    `getTheValue()` function call.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Th above code actually calls the function and returns the pending promise to
    the array that is already wrapped in `Promise.all`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we want to use recursion in the case of an error. We will change our `catch()`
    callback from simply logging the error to starting the process over again. In
    this case, our business rule is we want the entire set of calculations to complete
    and we will restart if there is an error. The code to do this is very easy as
    `catch()` expects a function as its callback so we can just pass our `doIt` function
    back to it again.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Pass the `doIt` function back to `catch()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that we do not invoke the callback function here. We want to pass a function
    and it will be invoked in the case of an error.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We will now want to clean up our error messages a little so we can have a clean run:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'When we run the program, we''ll see a few iterations of the program looping.
    The output may be something like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that depending on the number of iterations, you might get an output different
    from the one shown above.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Promise.allSettled
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This method is a variation on `Promise.all`, which is ideal for when it''s
    acceptable for some of our promises to resolve successfully and some of them to
    be rejected. Let''s see how it''s different from `Promise.all`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The program will generate output like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ve made a couple of enhancements here. For one thing, we are now passing
    the array size into `generateTheNumber`, which can give a bit more flavor or variation
    to our program. The main improvement now is the use of `Promise.allSettled`. Now,
    `Promise.allSettled` allows us to have a mix of successes and failures, unlike
    `Promise.all`, which will call the `then()` method if all the promises resolve
    successfully or call the `catch()` method if any of them fail. The output of `Promise.allSettled`
    could look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Each of the resolved promises will have a status containing the string `'fulfilled'`
    if the promise resolved successfully or `'rejected'` if there was an error. Fulfilled
    promises will have a `value` property containing the value the promise resolved
    to and rejected promises will have a `reason` property containing the error.
  prefs: []
  type: TYPE_NORMAL
- en: In the example given, we are totaling the rejected promises and summing the
    values of the fulfilled promises, then returning that as a new object. To perform
    this operation, we use the built-in array function `reduce()`. Now, `reduce()`
    will iterate over each element of an array and collect transformed results in
    an accumulator, which is returned by the function. `MapReduce` functions are common
    in functional programming paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: Note that `Promise.allSettled` is a fairly recent addition to ECMAScript, having
    landed in Node.js 12.9\. In order to use it, you'll need to set your `compilerOptions`
    target to `es2020` or `esnext` in your `tsconfig.json` file. Most modern browsers
    support this method, but it's a good idea to verify support before using this
    recent feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.03: Promise.allSettled'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''ve seen an example of using `Promise.allSettled` to produce a mixed result
    of fulfilled and rejected promises. Now let''s combine `Promise.allSettled` and
    `Promise.all` to aggregate multiple results of our runs of `getTheValue()`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can also be found here: [https://packt.link/D8jIQ](https://packt.link/D8jIQ).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start with the code from the example above. We are going to want to call `generateTheNumber()`
    three times. Once we have all the results, we can sort them to print out the highest
    and lowest results. We can use the same `Array().fill().map()` technique described
    above to create a new array of `generateTheNumber()` calls:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now that we can resolve three separate calls, we need to manage the output.
    First, we can log out the results to see what we need to do next:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We log out `[undefined, undefined, undefined]`. That's not what we wanted. The
    reason for this is `generateTheNumber` doesn't actually return its promise – it
    didn't need to in the prior example.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can fix that by adding a `return` statement and removing the `void` return
    type. We also need our callback function to return the results instead of simply
    logging them out. All these changes would help a program like this integrate into
    a larger application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The last step to complete this exercise is we only want to output the highest
    and lowest totals. To accomplish this, we can use the `Array.map()` function to
    extract only the totals from the output and the `Array.sort()` function to order
    the above output from lowest to highest, then print the totals from the first
    and last entries:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You might get an output similar to the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that only a section of the actual output is displayed for ease of presentation.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This exercise showed us how we can filter and sort the results of many promises
    and create data structures that accurately reflect the state of our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Promise.any
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: At the other end of the spectrum from `Promise.allSettled` lies `Promise.any`.
    This method takes an iterable (or array) of promises, but instead of settling
    all of them, it will resolve to the value of the first promise that resolves successfully.
    `Promise.any` is so new it has yet to be implemented in every browser and at the
    time of writing is not available in the LTS version of Node.js. You should check
    compatibility and availability before using it.
  prefs: []
  type: TYPE_NORMAL
- en: Promise.race
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Promise.race` has been around for some time and is similar to `Promise.any`.
    Now, `Promise.race` again takes an iterable of promises and executes them all.
    The first promise that resolves or rejects will resolve or reject the race. This
    is in contrast to `Promise.any` in that if the first promise in `Promise.any`
    rejects, the other promises still have an opportunity to resolve successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, one promise always rejects in 1 second while the other resolves
    at a random interval between 0 and 2 seconds. If the `oneSecond` promise wins
    the race, the entire promise is rejected. If `upToTwoSeconds` takes less than
    a second, then the promise resolves successfully with the message `"Made It!"`.
  prefs: []
  type: TYPE_NORMAL
- en: A practical example of using `Promise.race` might be a timeout and fallback
    feature where if the primary web service can't respond within an expected amount
    of time, the application either switches to a secondary source for data or exhibits
    some other behavior. Or perhaps we want to deal with a slow render issue in a
    web browser where if a screen paint hasn't finished in the expected amount of
    time, we switch to a simpler view. There are lots of cases where `Promise.race`
    can ease the complexity of handling asynchronous operations in TypeScript.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing Promises with Types
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The example we're working with so far specifies the type of input to the promise,
    but we have to provide a type for the result in each step of the chain. That's
    because TypeScript doesn't know what the promise may resolve to so we have to
    tell it what kind of type we're getting as the result.
  prefs: []
  type: TYPE_NORMAL
- en: 'In other words, we''re missing out on one of TypeScript''s most powerful features:
    *type inference*. Type inference is the ability for TypeScript to know what the
    type of something should be without having to be told. A very simple example of
    type inference would be the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: No type is specified. This is because TypeScript understands that the variable
    `hello` is being assigned a string and cannot be reassigned. If we try to pass
    this variable as an argument to a function that expects another type, we will
    get a compilation error, even though we never specified the type. Let's apply
    type inference to promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s look at the type definition for the `Promise` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '`T` is what''s known as a generic. It means any type can be specified to take
    the place of `T`. Let''s say we define a promise like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'What we''re doing here is stating the `resolve` argument will resolve to an
    unknown type. The receiving code will need to provide a type for it. This can
    be improved by adding a type value for `T`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Now the promise constructor resolves to a type of `Promise<string>`. When the
    promise becomes fulfilled, it is expected to return a type of `string`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine an example where casting the return type of a promise becomes important:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'If you put this example into an IDE such as VS Code, you''ll see that you have
    a type error on the `result` parameter given to `printResult`. The type that the
    promise returned by `getPromise` is unknown but `printResult` expects `number`.
    We can fix this problem by providing a type to the promise when we declare it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: We have added `<number>` immediately after our promise declaration and TypeScript
    knows this promise is expected to resolve to a number. This type-checking will
    also be applied to the resolution of our promise. For example, if we tried to
    resolve to a value of `"Hello!"`, we'd get another type error now that our promise
    is expected to return a number.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.04: Asynchronous Rendering'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we''ll create a simple website with synchronous rendering
    and refactor it so the rendering is asynchronous:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can also be found here: [https://packt.link/q8rka](https://packt.link/q8rka).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Clone the project from GitHub ([https://packt.link/q8rka](https://packt.link/q8rka))
    to begin. Then, install dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We just installed TypeScript into our project as well as `http-server`, which
    is a simple Node.js HTTP server that will allow us to run our website on localhost.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now we'll add a few files to get the project started.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the root of your project, create a file called `index.html` and add the
    following lines to it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, optionally add a stylesheet as the default styles are quite an eyesore.
    Bring your own or use something simple like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a file called `data.json` to represent the data we are fetching from a
    remote server:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'One more to go. Let''s add a TypeScript file called `data-loader.ts`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's all you need to run a local service with a TypeScript web application!
    Later in the book, we'll see some more robust solutions, but for now, this will
    let us focus on the TypeScript without too many bells or whistles around.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To see our application, we''ll need to transpile the TypeScript and start the
    local server. For the best experience, we''ll need two separate Command Prompt
    windows. In one of them, we''ll type a command to transpile the TypeScript and
    watch for changes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'And in the other window, we''ll start our server with a flag to avoid caching
    so we can see our changes right away:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'If we navigate to `http://localhost:8080`, we''ll see our application load
    and receive this message:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Something hasn''t worked correctly. What we want to see is `"Here is your data:
    Hello Promise!"`. If we go and look at the TypeScript code, we''ll see this line:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This isn't working correctly. `fetch` is an asynchronous request. We are just
    seeing the unresolved promise and printing it to the screen.
  prefs: []
  type: TYPE_NORMAL
- en: Another warning sign is the use of `any` in the `updateUI` function. Why is
    the `any` type being used there when it should be a string? That's because TypeScript
    won't allow us to use a string. TypeScript knows we're calling `updateUI` with
    an unresolved promise and so we'll get a type error if we try to treat that as
    a string type. New developers sometimes think they are fixing a problem by using
    `any`, but more often than not they will be ignoring valid errors.
  prefs: []
  type: TYPE_NORMAL
- en: In order to get this code to work correctly, you will need to refactor it so
    that the promise `fetch` returns is resolved. When it works correctly, `fetch`
    returns a response object that exposes a `data` method that also returns a promise,
    so you will need to resolve two promises in order to display the data on your
    page.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The fetch library is a web API for browsers that is a great improvement on the
    original `XMLHttpRequest` specification. It retains all the power of `XMLHttpRequest`
    but the API is much more ergonomic and as such is used by many web applications,
    rather than installing a third-party client library. `fetch` is not implemented
    in Node.js natively but there are some libraries that provide the same functionality.
    We'll take a look at those later in the chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Libraries and Native Promises — Third-Party Libraries, Q, and Bluebird
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated previously, promises became part of the ECMAScript standard in 2015\.
    Up until that point, developers used libraries such as Q or Bluebird to fill the
    gap in the language. While many developers choose to use native promises, these
    libraries remain quite popular with weekly downloads still growing. That said,
    we should carefully consider whether it's a good idea to depend on a third-party
    library over a native language feature. Unless one of these libraries provides
    some critical functionality that we can't do without, we should prefer native
    features over third-party libraries. Third-party libraries can introduce bugs,
    complexity, and security vulnerabilities and require extra effort to maintain.
    This isn't an indictment against open source.
  prefs: []
  type: TYPE_NORMAL
- en: Open source projects (such as TypeScript) are an essential part of today's developer
    ecosystem. That said, it's still a good idea to carefully choose our dependencies
    and make sure they are well-maintained libraries that are not redundant with native features.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s also worth noting that the APIs of third-party libraries may differ from
    the native language feature. For example, the Q library borrows a deferred object
    from the jQuery implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'This written in a native promise is more like the examples we''ve seen so far:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: There's nothing inherently wrong with the Q implementation here, but it's non-standard
    and this may make our code less readable to other developers or prevent us from
    learning standard best practices.
  prefs: []
  type: TYPE_NORMAL
- en: Bluebird is more similar to the native promise. In fact, it could be used as
    a polyfill.
  prefs: []
  type: TYPE_NORMAL
- en: Polyfilling Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TypeScript will transpile code, but it will *not* polyfill native language features
    that are not present in your target environment. This is critical to understand
    to avoid frustration and mysterious bugs. What TypeScript will do for us is allow
    us to specify the target environment. Let's look at a simple example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following `tsconfig.json` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'Now consider this module in `promise.ts`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'Our code will transpile fine. We enter `npx` `tsc` and the transpiled JavaScript
    output looks very much like our TypeScript code. The only difference is the type
    has been removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'However, consider if we change the target to `es5`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: 'Now the project will no longer build:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: TypeScript even warns me that I might want to fix my target. Note that `"es2015"`
    and `"es6"` are the same thing (as are `"es2016"` and `"es7"`, and so on). This
    is a somewhat confusing convention that we simply need to get used to.
  prefs: []
  type: TYPE_NORMAL
- en: This will be fine if I can build my project for an `es6+` environment (such
    as a current version of Node.js or any modern browser), but if I need to support
    a legacy browser or a very old version of Node.js, then "fixing" this by setting
    the compilation target higher will only result in a broken application. We'll
    need to use a polyfill.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this case, Bluebird can be a really good choice as it has an API very similar
    to native promises. In fact, all I will need to do is `npm` `install` `bluebird`
    and then import the library into my module. The Bluebird library does not include
    typings so to have full IDE support, you''d need to also `install` `@types/bluebird`
    as a `devDependency`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: My transpiled code will now run in a very early version of Node.js, such as
    version 0.10 (released in 2013).
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that Bluebird is designed to be a full-featured `Promise` library. If
    I''m just looking for a polyfill, I might prefer to use something like `es6-promise`.
    Its use is exactly the same. I `npm` `install` `es6-promise` and then import the
    `Promise` class into my module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: If you want to try this yourself, be aware that modern versions of TypeScript
    won't even run on Node.js 0.10! You'll have to transpile your code in a recent
    version (such as Node.js 12) and then switch to Node.js 0.10 to execute the code.
    To do this, it's a good idea to use a version manager such as `nvm` or `n`.
  prefs: []
  type: TYPE_NORMAL
- en: This is actually a great example of the power of TypeScript. We can write and
    build our code on a modern version but target a legacy runtime. Setting the compilation
    target will make sure we build code that is suitable for that runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Promisify
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promisification is the practice of taking an asynchronous function that expects
    a callback and turning it into a promise. This is essentially a convenience utility
    that allows you to always write in promises instead of having to use the callbacks
    of a legacy API. It can be really helpful to promisify legacy APIs so that all
    our code can use promises uniformly and be easy to read. But it's more than just
    a convenience to convert callbacks into promises. Some modern APIs will only accept
    promises as parameters. If we could only work on some code with callbacks, we
    would have to wrap the callback asynchronous code with promises manually. Promisification
    saves us the trouble and potentially many lines of code.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s work through an example of *promisifying* a function that expects a
    callback. We have a few options to choose from. Bluebird again provides this functionality
    with `Promise.promisify`. This time, we''ll try a polyfill, `es6-promisify`. Let''s
    start with a function that expects a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'Functions that can be promisified follow a convention where the first argument
    into the callback is an error object. If the error is null or undefined, then
    the function is considered to have been invoked successfully. Here, I am calling
    `asyncAdder`, giving it two numbers and a callback function. My callback understands
    that `asyncAdder` will have an error in the first argument position if an error
    was thrown or the sum of the two numbers in the second argument position if it
    was successful. By adhering to this pattern, the function can be promisified.
    First, we `npm install` `es6-promisify` and then we import the module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: We use the `promisify` import to wrap our function and now we can work exclusively
    with promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Bluebird gives us exactly the same functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Node.js util.promisify
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Node.js introduced its own version of `promisify` as a native feature in version
    8 (2017). Instead of using `es6-promise` or Bluebird, if we are targeting a Node.js
    8+ environment, we can leverage the `util` package. Note that since we are writing
    TypeScript, we will need to add the `@types/node` dependency to take advantage
    of this package. Otherwise, TypeScript will not understand our import. We''ll
    run `npm` `install` `-D @types/node`. The `-D` flag will install the type as a
    `devDependency`, which means it can be excluded from production builds:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: Obviously, if we want our code to run in a browser, this won't work and we should
    use one of the other libraries, such as Bluebird, to enable this functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Asynchronous FileSystem
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As of Node.js 10 (released 2018), the FileSystem API (`fs`) comes with promisified
    async versions of all the functions as well as blocking synchronous versions of
    them. Let's look at the same operation with all three alternatives.
  prefs: []
  type: TYPE_NORMAL
- en: fs.readFile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Many Node.js developers have worked with this API. This method will read a
    file, taking the file path as the first argument and a callback as the second
    argument. The callback will receive one or two arguments, an error (should one
    occur) as the first argument and a data buffer object as the second argument,
    should the read be successful:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: We read the file and log out the contents asynchronously. Anyone who has worked
    with the Node.js `fs` library in the past has probably seen code that looks like
    this. The code is non-blocking, which means even if the file is very large and
    the read is very slow, it won't prevent the application from performing other
    operations in the meantime. There's nothing wrong with this code other than it's
    not as concise and modern as we might like.
  prefs: []
  type: TYPE_NORMAL
- en: In the example above, we're reading the file and logging to the console – not
    very useful, but in a real-world scenario, we might be reading a config file on
    startup, handling the documents of clients, or managing the lifecycle of web assets.
    There are many reasons you might need to access the local filesystem in a Node.js
    application.
  prefs: []
  type: TYPE_NORMAL
- en: fs.readFileSync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fs` library also exposes a fully synchronous API, meaning its operations
    are blocking and the event loop won''t progress until these operations are complete.
    Such blocking operations are more often used with command-line utilities where
    taking full advantage of the event loop isn''t a priority and instead, simple,
    clean code is the priority. With this API, we can write some nice, concise code
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: It could be tempting to write code like this and call it a day, but `readFileSync`
    is a blocking operation so we must beware. The main execution thread will actually
    be paused until this work is complete. This may still be appropriate for a command-line
    utility, but it could be a real disaster to put code like this in a web API.
  prefs: []
  type: TYPE_NORMAL
- en: The fs Promises API
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fs` library exposes the promises API, which can give us the best of both
    worlds, asynchronous execution and concise code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: Using the promises API lets us write nearly as concise code as the synchronous
    version, but now we are fully asynchronous, making the code suitable for a high-throughput
    web application or any other process where a blocking operation would be unacceptable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.05: The fs Promises API'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will use the `fs` promises API to concatenate two files
    into one. Whenever possible, make your code DRY (don''t repeat yourself) by using
    functions. You''ll need to use `readFile` and `writeFile`. The only dependencies
    needed for this program are `ts-node` (for execution), `typescript`, and `@types/node`
    so we have the types for the built-in `fs` and `path` libraries in Node.js:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can also be found here: [https://packt.link/M3MH3](https://packt.link/M3MH3).'
  prefs: []
  type: TYPE_NORMAL
- en: Using the file in the GitHub repo as a basis for this exercise, navigate to
    the exercise directory and type `npm` `i` to install these dependencies.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We are going to want to read two separate files using `readFile` and then use
    `writeFile` to write our output text file. The sample project already has two
    text files with some simple text. Feel free to add your own files and text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'This project could be completed using `readFileSync` and `writeFileSync`. That
    code would look something like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `resolve` function from the path library resolves paths on your filesystem
    and is often used alongside the `fs` library, as depicted above. Both these libraries
    are part of the Node.js standard library so we need only install typings, not
    the libraries themselves.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We can execute this program with `npx` `ts-node` `file-concat.ts`. This will
    produce a file called `output.txt`, which contains this text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: So this works without promises. And this is probably fine for a command-line
    utility executed by a single user on a single workstation. However, if this kind
    of code were put into a web server, we might start to see some blocking issues.
    Synchronous filesystem calls are *blocking* and block the event loop. Doing this
    in a production application can cause latency or failure.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We could solve this problem using `readFile` and `writeFile`, which are both
    asynchronous functions that take callbacks, but then we''d need to nest the second
    `readFile` inside the first. The code would look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We are now clear of blocking issues, but the code is looking quite ugly. It's
    not hard to imagine another developer failing to understand the intent of this
    code and introducing a bug. Additionally, by putting the second `readFile` as
    a callback in the first, we are making the function slower than it needs to be.
    In a perfect world, those calls can be made in parallel. To do that, we can leverage
    the promises API.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The best way to do things in parallel with promises is `Promise.all`. We can
    wrap our two `readFile` calls in a single `Promise.all`. To do that, we need to
    promisify `readFile`. Lucky for us, the `fs` library comes with a helper that
    will do that for us. Instead of importing `readFile`, we import promises from
    `fs` and call the `readFile` method on that object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These two reads will now run asynchronously in parallel. Now we can handle
    the output and use the same `array.join` function from the earlier example along
    with `promises.writeFile`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This code is looking quite a lot cleaner than the nested code above. When we
    execute it with `npx` `ts-node` `file-concat.ts`, we get the expected output of
    `output.txt` containing the concatenated text:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE68]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now that we have this working, we can certainly imagine much more complicated
    programs manipulating other types of files, such as a PDF merge function as a
    web service. Though some of the internals would be a lot more challenging to implement,
    the principles would be the same.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with Databases
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It is very common for Node.js applications to work with a backend database such
    as `mysql` or `postgres`. It is critical that queries against a database be made
    asynchronously. Production-grade Node.js web services may serve thousands of requests
    per second. If it were necessary to pause the main execution thread for queries
    made synchronously against a database, these services just wouldn't scale at all.
    Asynchronous execution is critical to making this work.
  prefs: []
  type: TYPE_NORMAL
- en: The process of negotiating a database connection, sending a SQL string, and
    parsing the response is complicated and not a native feature of Node.js and so
    we will almost always use a third-party library to manage this. These libraries
    are guaranteed to implement some kind of callback or promise pattern and we'll
    see it throughout their documentation and examples. Depending on the library you
    choose, you may have to implement a callback pattern, you may get to work with
    promises, or you may be presented with `async`/`await` (see *Chapter 13 Async/Await*).
    You may even get a choice of any of these as it's definitely possible to provide
    all of the above as options.
  prefs: []
  type: TYPE_NORMAL
- en: For these examples, we'll use `sqlite`. Now, `sqlite` is a nice library that
    implements a fairly standard SQL syntax and can operate against a static file
    as a database or even run in memory. We will use the in-memory option. This means
    that there is nothing that needs to be done to set up our database. But we will
    have to run a few scripts to create a table or two and populate it on startup.
    It would be fairly simple to adapt these exercises to work with `mysql`, `postgres`,
    or even `mongodb`. All of these databases can be installed on your workstation
    or run in a Docker container for local development.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the first example, let''s look at `sqlite3`. This library has an asynchronous
    API. Unlike more permanent and robust databases such as `mysql` or `postgres`,
    some `sqlite` client libraries are actually synchronous, but we won''t be looking
    at those as they aren''t very useful for demonstrating how promises work. So `sqlite3`
    implements an asynchronous API, but it works entirely with callbacks. Here is
    an example of creating an in-memory database, adding a table, adding a row to
    that table, and then querying back the row we added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: This is exactly what developers mean when they complain about "callback hell."
    Again, this code executes perfectly well, but it is needlessly verbose, becomes
    deeply nested, and repeats itself, especially in the error-handling department.
    Of course, the code could be improved by adding abstractions and chaining together
    methods, but that doesn't change the fact that callbacks aren't a very modern
    way to think about writing Node.js code.
  prefs: []
  type: TYPE_NORMAL
- en: Since all of these callbacks follow the pattern of expecting the first argument
    to be an error object, we could promisify `sqlite3`, but as is often the case,
    somebody has already done this work for us and provided a library called simply
    `sqlite` that mimics the exact API of `sqlite3`, but implements a promise API.
  prefs: []
  type: TYPE_NORMAL
- en: 'I can rewrite the same code using this library and the result is a good deal
    more pleasing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: We've dropped nearly half of the lines of code and it's not nested as deeply.
    This still could be improved, but it's much cleaner now. Best of all, we have
    a single `catch` block followed by `finally`, to make sure the database connection
    is closed at the end.
  prefs: []
  type: TYPE_NORMAL
- en: Developing with REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the next exercise, we'll build a RESTful API. REST is a very common standard
    for web traffic. Most websites and web APIs operate using REST. It stands for
    Representational State Transfer and defines concepts such as operations (sometimes
    called "methods" or even "verbs") such as `GET`, `DELETE`, `POST`, `PUT`, and
    `PATCH` and resources (the "path" or "noun"). The full scope of REST is beyond
    this book.
  prefs: []
  type: TYPE_NORMAL
- en: Developers working on RESTful APIs frequently find it useful to work with some
    sort of REST client. The REST client can be configured to make different kinds
    of requests and display the responses. Requests can be saved and run again in
    the future. Some REST clients allow the creation of scenarios or test suites.
  prefs: []
  type: TYPE_NORMAL
- en: Postman is a popular and free REST client. If you don't already have a REST
    client you're comfortable working with, try downloading Postman at [https://www.postman.com/downloads/](https://www.postman.com/downloads/)
    before the next exercise. Once you've installed Postman, check its documentation
    ([https://learning.postman.com/docs/getting-started/sending-the-first-request/](https://learning.postman.com/docs/getting-started/sending-the-first-request/))
    and get ready for the next exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 12.06: Implementing a RESTful API backed by sqlite'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, you will create a REST API backed by `sqlite`. In this project,
    you will implement all CRUD (create, read, update, and delete) operations in the
    `sqlite` database and we will expose the corresponding REST verbs (`POST`, `GET`,
    `PUT`, and `DELETE`) from our web server:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this exercise can also be found here: [https://packt.link/rlX7G](https://packt.link/rlX7G).'
  prefs: []
  type: TYPE_NORMAL
- en: To get started, clone the project from GitHub and change to the directory for
    this exercise.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Install the dependencies:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE71]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This will install typings for Node.js, as well as `ts-node` and `typescript`
    as development dependencies while `sqlite` and `sqlite3` are regular dependencies.
    All of these dependencies are already specified in the project's `package.json`
    file. Some of the dependencies, such as `@types/node`, `ts-node`, and `typescript`,
    are specified as `devDependencies` and others are regular dependencies. For the
    purpose of this exercise, the distinction is not going to matter but it's a common
    practice to run application builds so that only the necessary dependencies are
    part of the production build, thus the separation. The way to run this kind of
    build is `npm install --production` if you only wish to install the production
    dependencies or `npm prune --production` if you've already installed your `devDependencies`
    and wish to remove them.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s create a file to hold our `sqlite` database. Add a file in the root
    of your project called `db.ts`. We''ll go with an object-oriented approach for
    the database and create a singleton object to represent our database and access
    patterns. One reason for doing this is we are going to want to maintain the state
    of whether or not the database has been initialized. Calling open on an in-memory
    `sqlite` database will destroy the database and create another one immediately,
    thus we only want to open the database connection if it isn''t already open:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE72]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It's always a good idea to create a class or interface to describe our entity,
    so here we have created `PromiseModel`. It will be useful to other parts of our
    application to be able to understand the properties our entity has as well as
    their types, since the database will only return untyped query results. We export
    the interface so that it can be used by other modules.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Our database is an object with a constructor that will have a private member
    representing the actual database connection and a Boolean value to track whether
    the database has been initialized. Let''s add a method for initialization:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we check to see if we've already initialized the database. If so, we're
    done and we resolve the promise. If not, we call `open`, then once that promise
    has resolved, run our table creation SQL, and then finally update the state of
    the database so that we don't accidentally re-initialize it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We could try to initialize the database in the constructor. The problem with
    that approach is that constructors do not resolve promises before returning. Constructor
    functions may call methods that return promises, but they will not resolve the
    promise. It's usually cleaner to create the singleton object and then invoke the
    initialization promise separately. For more information about singleton classes,
    see *Chapter 8, Dependency Injection in TypeScript*.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now let''s add some methods. This will be pretty simple since our table only
    has two columns:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method takes an object of type `PromiseModel` as an argument, sends a prepared
    statement (a parameterized SQL statement that is safe from SQL injection attacks),
    and then returns `RunResult`, which contains some metadata about the operation
    that took place. Since the `sqlite` library ships with typings, we're able to
    infer the return type without needing to specify it. The return type in this case
    is `Promise<ISqlite.RunResult<sqlite.Statement>>`. We could paste all of that
    into our code, but it's much cleaner the way it is. Remember, if a good type can
    be inferred, it's best to just let TypeScript do the heavy lifting.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In addition to the `create` method, we will want `delete`, `getAll`, `getOne`,
    and `update` methods. The `delete` method is very straightforward:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we''re calling `db.run` again, we''re again returning that `RunResult`
    type. Let''s see what it looks like to return some of your own data:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: These methods use type parameters to specify the expected return types. If the
    type parameters were omitted, these methods would return `any` types, which wouldn't
    be very helpful to the other parts of our application.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Last of all is the `update` method. This one will use our `PromiseModel` again
    to type check the input:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The final code for the class looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The next step is to build an HTTP server implementing a RESTful interface. Many
    Node.js developers use frameworks such as Express.js, Fastify, or NestJS, but
    for this exercise, we're just going to build a basic HTTP server. It won't have
    all the niceties of those frameworks, but it'll help us focus on asynchronous programming.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To create our server, we''ll create a class called `App` and expose an instance
    of it. Create a file called `app.ts` and declare the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Our `App` class takes an argument of the port number we''ll run our server
    on. The class will maintain the state of the running server as well as the database
    connection. Like our `PromiseDB` class, the constructor needs to be supplemented
    by an `initialize` method to handle the asynchronous setup:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This method uses `Promise.all` so that we can initialize our database and server
    in parallel. When both are ready, it'll log a message letting us know the application
    is ready to handle requests. We are calling the `initialize` method on the `PromiseDB`
    instance that we've exposed to our `App` class. Unfortunately, `server.listen`
    doesn't return a promise but instead implements a fairly primitive API that requires
    a callback so we are wrapping it in our own promise. It's tempting to want to
    wrap `server.listen` in `util.promisify`, but even that won't work because `util.promisify`
    expects the callback function to expect the first argument to be an error object
    and the `server.listen` callback doesn't take any arguments. Sometimes, despite
    our best efforts, we just have to use a callback, but we can usually wrap them
    with promises.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We''re also going to need to add a `requestHandler` method. `createServer`
    is a method exposed by the `http` module in Node.js. It takes an argument that
    should be a function to handle requests and supply a response. Again, the API
    for the `http` module is fairly low-level:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We want our application to direct all traffic on the `/promise` resource to
    our promises API. This will allow us to add more resources (maybe `/admin` or
    `/users`) later on. The request handler's job is to see if we have requested the
    `/promise` route and then direct traffic to that specific router. Since we haven't
    defined any other resources, we'll return a 404 if we request any other route.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we are handling the `OPTIONS` HTTP verb differently than any other.
    If we get a request with that verb, we set the `"Access-Control-Allow-Origin"`
    header and return a successful response. This is for development convenience.
    The topic of CORS is beyond the scope of this book, and readers are encouraged
    to learn more about it before implementing it in a production environment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'That error handler needs a definition, so let''s add one:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This is a nice one-liner that by default will throw a 500 status code `Internal
    Server Error`, but can take optional parameters to return any error code or message.
    Our default handler sets the status code to 404 and provides the message `"Not
    Found"`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We add a call to `initialize` at the end and we''re good to go. Let''s take
    another look at the `App` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If you've implemented all this in code, you're probably still getting an error
    on `promiseRouter`. That's because we haven't written that yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Add a `router.ts` file to your project. This will be the last part we need to
    build this simple API. A more complicated application would hopefully include
    a more sophisticated directory structure and most likely be based on a leading
    framework such as Express.js or NestJS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unlike our database and server modules, the router is stateless. It does not
    need to be initialized and does not track any variables. We could still create
    a class for our router, but let's instead use a functional programming style.
    There's really no right or wrong way to do this. Instead of using classes for
    our database and server, we could likewise use a functional style.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We're going to work on creating several handlers, tie them together with a router
    based on HTTP verbs, and also create a body parser. Let's start with the body parser.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Readers who have some experience with the Express.js framework may have used
    its powerful `bodyParser` module. It''s normally a good idea to use an off-the-shelf
    solution for something like that, but in this exercise, you will write your own
    in order to get a closer look at how we can take the request or `IncomingMessage`
    object as a stream and convert it into a typed object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE84]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The data stream is again a fairly low-level API that we must wrap in a promise.
    The stream is event-based, as are a lot of the Node.js APIs. In this case, we
    are listening for two separate events, `data` and `end`. Each time we get a `data`
    event, we add data to the `body` string. When we receive the `end` event, we can
    finally resolve our promise. Since the data is a string at this point and we want
    an object, we will use `JSON.parse` to parse the object. `JSON.parse` must be
    wrapped with `try/catch` to catch any parsing errors.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By default, `JSON.parse` returns an `any` type. This type is too broad to be
    of any use in checking our application for type correctness. Fortunately, we can
    add proper type checking by setting the return type of `parseBody` to `Promise<PromiseModel>`.
    This will narrow the type of the object returned by `JSON.parse` to `PromiseModel`
    and the rest of our application can expect that type to have been parsed. Note
    that this is a compile-time check and does not guarantee the correct data has
    come from a third-party source such as an end user. It is advisable to combine
    type checks with validators or type guards to ensure consistency. When in doubt,
    employ good error handling.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that you have a good method for parsing the request body, let''s add one
    to handle the create action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE85]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This function parses the body of the request, attempts to insert it into our
    database, and then responds with a default 200 response if the operation was successful.
    Note that the chained catch at the end will catch any errors that occur in the
    promise. If our body parsing fails, the error will be caught here, even though
    it's placed after `db.create` in the chain.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now let''s handle the delete action:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The HTTP `DELETE` verb does not use a body. Instead, we will take the ID of
    the row we want to delete from the URL. We'll see how that routing works in a moment.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The `GET` operations need to return some data and will use `JSON.stringify`
    to serialize their response objects to send them to a client:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE87]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The update action looks similar to delete:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, we just need a router. Your router will need to make a decision based
    on the HTTP verb used as well as any request parameter that may refer to the ID
    of the row we want to interact with. We will also set the `Content-Type` header
    to `application/json` for all responses. Then we simply need to delegate to the
    correct handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now it''s time to try our application. We installed `ts-node` earlier. This
    library allows us to transpile and run our TypeScript program in a single step.
    It is not necessarily recommended to use `ts-node` in production, but it makes
    for a very handy development tool. Let''s try it now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE90]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see the following on your console:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE91]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This implies that your application is ready to start receiving requests. If
    not, you may have a typo somewhere. Let's try it out. You can either use a REST
    client or curl. This exercise uses Postman
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you make a `GET` request to `http://localhost:3000/promise`, you will get
    an empty array ([]) back:![Figure 12.3: Initial GET request'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14508_12_03.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.3: Initial GET request'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: This is because we haven't created any records yet.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Try a `POST` with the payload `{"desc":"Always lint your code"}`:![Figure 12.4:
    POST data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14508_12_04.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.4: POST data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now the `GET` request returns `[{"id":1,"desc":"Always lint your code"}]`:![Figure
    12.5: Use GET to retrieve data'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14508_12_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.5: Use GET to retrieve data'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you do a request to `http://localhost:3000/promise/1`, you will get a single
    object back:![Figure 12.6: Single object'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14508_12_06.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.6: Single object'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you request `http://localhost:3000/promise/2`, you will get nothing:![Figure
    12.7: No items found'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/B14508_12_07.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 12.7: No items found'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you request `http://localhost:3000/something-else`, you will get a 404 response:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 12.8: 404 response'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_12_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.8: 404 response'
  prefs: []
  type: TYPE_NORMAL
- en: Looks like things are working. Experiment with the different HTTP verbs. Try
    giving invalid input and see how the error handling works. We'll use this API
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Putting It All Together – Building a Promise App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've learned techniques for using promises in web projects as well as Node.js
    APIs. Let's combine our earlier exercises to build a web application that renders
    progressively as data is ready and makes use of asynchronous programming on the
    server to avoid blocking the event loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 12.01: Building a Promise App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this activity, we're going to build a web application that talks to the API
    we just built. Although frameworks such as Angular, React, and Vue are very popular,
    those are covered in later chapters so we will build a very basic TypeScript application
    with no bells or whistles.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This activity provides a UI application that communicates with the backend API
    we built in *Exercise 12.06*, *Implementing a RESTful API backed by sqlite*. In
    order to get the output shown, you will need to have your API running. Return
    to that exercise for help if you need it.
  prefs: []
  type: TYPE_NORMAL
- en: This UI application will connect to our API and allow us to modify the data
    we store in our database. We will be able to list out the data we've saved (the
    promises we make), create new items to save, and delete items. Our UI application
    will need to make `GET`, `POST`, and `DELETE` calls to our backend API. It will
    need to use an HTTP client to do that. We could install a library such as `axios`
    to handle that or we could use the native Fetch API available in all modern web
    browsers.
  prefs: []
  type: TYPE_NORMAL
- en: Our web application will also need to be able to dynamically update the UI.
    Modern view libraries such as `react` or `vue` do that for us, but in this case
    we are framework-free so we'll need to use more DOM (document object model) APIs
    such as `getElementById`, `createElement`, and `appendChild`. These are natively
    available in all web browsers with no libraries needed.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing this application using promises will be critical because all of
    the API calls will be asynchronous. We will perform an action, such as a click,
    our application will call the API, then it will respond with data and then and
    only then will the promise resolve and cause a change in the DOM state.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some high-level steps that will enable you to create the app:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The code file for this activity can be found here: [https://packt.link/RlYli](https://packt.link/RlYli).'
  prefs: []
  type: TYPE_NORMAL
- en: Create a static `html` page with `css` to be served via `http-server` for local development.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an `app.ts` file to make a web request to the backend using `fetch` and
    do the required DOM manipulation based on the response.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transpile the `app.ts` file into `app.js` and test against the local server
    using a web browser.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Make adjustments to `app.ts` and continue testing until all the scenarios are working.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once you have completed the activity, you should be able to view the form on
    `localhost:8080`. An example is shown here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 12.9: Completed form'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/B14508_12_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 12.9: Completed form'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found via [this link](B14508_Solution_ePub.xhtml#_idTextAnchor441).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned how promises came to be a part of the ECMAScript standard, taken
    a tour of the native implementation, and worked through sample projects using
    promises to solve real-world problems. We also explored how TypeScript can enhance
    the promise spec and how we can polyfill promises when targeting environments
    that don't include native promise support. We contrasted the Bluebird promise
    library with native promises. We learned about different ways of interacting with
    the filesystem using Node.js and we also covered managing asynchronous database
    connections and queries. In the end, we put all of this together into a working
    application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will build upon the asynchronous programming paradigm
    by covering `async` and `await`. We'll discuss when to use these over promises
    and the place promises still have in the TypeScript ecosystem.
  prefs: []
  type: TYPE_NORMAL
