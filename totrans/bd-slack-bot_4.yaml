- en: Chapter 4. Using Data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we''ve seen how to process keywords, commands, and API calls, we will
    look at the next logical step in bot building: persistent data storage and retrieval.
    References to data can be kept in JavaScript by assigning said data to a variable;
    however, its use is limited to when the program is running. If the program is
    stopped or restarted, we lose the data. Hence, persistent data storage is required
    for certain tasks.'
  prefs: []
  type: TYPE_NORMAL
- en: This allows us to build bots that can, for instance, keep track of a leaderboard
    or store a to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Connecting to Redis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Saving and retrieving data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Error handling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discovered how to create a competitive roll bot
    that allows users to play a "Who can roll the highest" game. Although it worked
    admirably, the feature sorely missing is a leaderboard of sorts, where each user's
    wins and losses are stored and an overall winners list is kept.
  prefs: []
  type: TYPE_NORMAL
- en: Such a feature wouldn't be difficult to produce; however, the largest problem
    comes in storing the data. Any data stored in JavaScript variables would be lost
    once the program ends or crashes. A better solution would then be to maintain
    a persistent database, which our bot can write to and read from.
  prefs: []
  type: TYPE_NORMAL
- en: There is a wide variety of database services to choose from; you might already
    be familiar with MySQL or MongoDB. For the example bots in this chapter, we will
    pick a service that is easy to set up and simple to use.
  prefs: []
  type: TYPE_NORMAL
- en: 'The database service we will use is Redis: [http://redis.io/](http://redis.io/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The Redis website describes the technology as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '*"Redis is an open source (BSD licensed), in-memory data structure store, used
    as database, cache and message broker. It supports data structures such as strings,
    hashes, lists, sets, sorted sets with range queries, bitmaps, hyperloglogs and
    geospatial indexes with radius queries. Redis has built-in replication, Lua scripting,
    LRU eviction, transactions, and different levels of on-disk persistence, and provides
    high availability via Redis Sentinel and automatic partitioning with Redis Cluster."*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: A simpler explanation is that Redis is an efficient in-memory key-value store.
    Keys can be simple strings, hashes, lists (an ordered collection), sets (unordered
    collection of non-repeating values), or sorted sets (ordered or ranked collection
    of non-repeating values). Despite the complex official description, setting up
    and using Redis is a quick and painless process.
  prefs: []
  type: TYPE_NORMAL
- en: Redis' advantages are its impressive speed, cross-platform communication, and
    simplicity.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Getting started with Redis is simple, but we will only be exploring the tip
    of the Redis iceberg. For more information on advanced uses of Redis, visit the
    Redis website.
  prefs: []
  type: TYPE_NORMAL
- en: There are many Redis client implementations written in a wide variety of languages
    ([http://redis.io/clients](http://redis.io/clients)), but we will use a Node-based
    Redis client.
  prefs: []
  type: TYPE_NORMAL
- en: Bear in mind that Redis is but one solution to the persistent data problem.
    Other solutions might include the use of a MySQL relational or a MongoDB non-relational
    database.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Redis
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To connect to Redis, we will use the Node Redis package. First, we must install
    and run our Redis server so Node will have something to connect to. Follow the
    instructions for your operating system of choice.
  prefs: []
  type: TYPE_NORMAL
- en: Mac OS X
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The simplest way to install Redis is through the `homebrew` package manager.
    `homebrew` makes it easy to install applications and services through the command
    line.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unable to use `homebrew`, visit the Redis quick start guide to install
    Redis manually: ([http://redis.io/topics/quickstart](http://redis.io/topics/quickstart)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unsure whether you have Homebrew installed, open a terminal and
    run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'If nothing returns, run the following in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Follow the onscreen prompts until `homebrew` is successfully installed. To
    install Redis, run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the installation has completed, you can start a Redis server by using
    the following command in your terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Windows
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Visit the official Microsoft GitHub project for Redis and grab the latest release
    here: [https://github.com/MSOpenTech/redis/releases](https://github.com/MSOpenTech/redis/releases).
    Once unzipped, you can run `redis-server.exe` to start the service and `redis-cli.exe`
    to connect to the server through the shell.'
  prefs: []
  type: TYPE_NORMAL
- en: Unix
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Refer to the Redis quickstart page for instructions on how to install on Linux/Unix
    systems: [http://redis.io/topics/quickstart](http://redis.io/topics/quickstart).'
  prefs: []
  type: TYPE_NORMAL
- en: Once installed, you can start the server with the `redis-server` command and
    connect to the server via `redis-cli`. These commands function in the exact same
    way on OS X.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that Redis is installed, start the service and you should see something
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Unix](img/B05384_04_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Redis successfully starting a server
  prefs: []
  type: TYPE_NORMAL
- en: Redis is now up and ready to be used on the default port 6379\. Other ports
    may be used instead, but the default port is sufficient for our purposes.
  prefs: []
  type: TYPE_NORMAL
- en: Connecting to Redis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To demonstrate how to connect to Redis, we will create a new bot project (including
    the `Bot` class defined in [Chapter 3](ch03.html "Chapter 3. Adding Complexity"),
    *Adding Complexity*). We''ll start by installing the Redis Node client, executing
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create a new `index.js` file and paste in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This snippet will import the Redis client and connect to the local instance
    running via the `createClient()` method. When not supplied with any arguments,
    the aforementioned method will assume the service is running locally on the default
    port of 6379\. If you wish to connect to a different host and port combination,
    then you can supply them with following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: For the purposes of this book, we will be using an unsecure Redis server. Without
    authentication or other security measures, your data could be accessed and edited
    by anyone who connects to your data service. If you intend to use Redis in a production
    environment, it is strongly recommended you read up on Redis security.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, ensure that you have the Redis client running in a different terminal
    window and start up our bot in the usual way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'If all goes well, you should be greeted by this happy message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting to Redis](img/B05384_04_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our Node app has successfully connected to the local Redis server
  prefs: []
  type: TYPE_NORMAL
- en: As promised, setting up and connecting to Redis was an easy and quick endeavor.
    Next, we will look at actually setting and getting data from our server.
  prefs: []
  type: TYPE_NORMAL
- en: Saving and retrieving data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let''s look at what the Redis client has to offer us. Add the following
    lines to `index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we will set the value "Hello world!" in Redis with the key
    `hello`. In the `get` command, we specify the key we wish to use to retrieve a
    value.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Node Redis client is entirely **asynchronous**. This means that you have
    to supply a callback function with each command if you wish to process data.
  prefs: []
  type: TYPE_NORMAL
- en: 'A common mistake is to use the Node Redis client in a synchronous way. Here''s
    an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This, perhaps confusingly, results in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: This is because the `get` function will have returned the Boolean `false` before
    the request to the Redis server has been made.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the correct code and you should see the successful retrieval of the **Hello
    world!** data:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Saving and retrieving data](img/B05384_04_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our stored value is successfully retrieved
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The maximum file size of a Redis string is 512 megabytes. If you need to store
    something larger than this, consider using multiple key/value pairings.
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing Redis functionality, a good tip is to use the Redis client''s
    built-in `print` command for easy debugging and testing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This will print the following in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As we progress through the chapter, we will introduce more useful functions
    and methods provided by the Redis client. For a complete list and documentation,
    visit [https://github.com/NodeRedis/node_redis](https://github.com/NodeRedis/node_redis).
  prefs: []
  type: TYPE_NORMAL
- en: Connecting bots
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With our Redis server set up and the basic commands covered, let's apply what
    we've learned to a simple bot. In this example, we will code a bot that instructs
    the bot to *remember* a phrase based on a given key value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following code to your `index.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the familiar `respondTo` command introduced in the `Bot` class of the
    previous chapter, we set up our bot to listen for the keyword `store` and then
    set that value in the Redis data store, using the message sender''s name as a
    key. Let''s see this in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Connecting bots](img/B05384_04_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Our bot remembers what we told it to
  prefs: []
  type: TYPE_NORMAL
- en: Notice how we use the callback function of the set method to ensure that the
    data was saved correctly, and informing the user if it was not.
  prefs: []
  type: TYPE_NORMAL
- en: While not terribly impressive behavior, the important thing to realize is that
    our bot has successfully stored values in the Redis data store. Redis will store
    the key value pairing on the local disk, which means that even if the bot and/or
    Redis server are stopped and started again the data will persist.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic storage
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once again, let's increase the complexity a bit. In the previous example, the
    key used to store data is always the command giver's name. In reality, this is
    impractical as it means a user could only store one thing at a time, overwriting
    the value each time they issued the command. In this next section, we will be
    augmenting our bot to allow the user to specify the key of the value to be stored,
    allowing for the storage of multiple values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Delete the previous `respondsTo` commands and paste in the following snippets,
    noting the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'In this interpretation, we expect the user to provide a command in the following
    format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: To extract the key and value from the command, we first use JavaScript's `Array.shift`
    to remove and return the value at index 0 of the `args` array. Then, it's a simple
    case of collecting the rest of the arguments as the value by using `Array.join`.
    Now, we apply what we learned in the previous section to store the user-defined
    key and value in the Redis instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'When the `retrieve` command is given, we use the same `Array.shift` technique
    to extract the key requested. We will then use it to retrieve the stored data.
    Let''s see it is in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Dynamic storage](img/B05384_04_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Storing and retrieving multiple entities
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Emojis within a message's text are converted into their basic text components.
    For instance, the thumbs up emoji is translated to `:+1`. This conversion works
    both ways, which means that Slack will automatically render any emoji text the
    bot sends.
  prefs: []
  type: TYPE_NORMAL
- en: Hashes, lists, and sets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we''ve used a single data type for our keys and values: strings. While
    keys are limited to string values, Redis allows for the value to be a variety
    of different data types. The different types are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: String
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hash
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: List
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sorted set
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are already familiar with strings, so let's work down the list and explain
    the different data types.
  prefs: []
  type: TYPE_NORMAL
- en: Hashes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Hashes are similar to JavaScript objects. However, they differ in that Redis
    hashes do not support nested objects. All the property values of a hash will be
    cast to strings. Take the following JavaScript object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `baz` property contains an object, and we can store the `obj` object in
    Redis by using the `hmset` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we retrieve the data with `hgetall`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This will log the following line in our terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Redis has stored the nested `baz` object by first calling the `Object.toString()`
    function on it, which means that the string value is returned when we perform
    our `hgetall` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'A workaround is to leverage JavaScript''s `JSON` object to stringify our nested
    object before storing and then parsing the object returned from Redis. Observe
    the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'When executed, we see the logged result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The examples given here only stringify and parse objects nested one level deep.
    In order to stringify and parse an object of *N* depth, look into the recursion
    programming technique. A good example can be found at [https://msdn.microsoft.com/en-us/library/wwbyhkx4(v=vs.94).aspx](https://msdn.microsoft.com/en-us/library/wwbyhkx4(v=vs.94).aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Lists
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Redis lists are functionally the same as JavaScript arrays. Like with objects,
    the value of every index is converted into a string when storing. When dealing
    with a multidimensional array (for example, an array containing a subset of arrays)
    the `toString` function will be called before storing in Redis. A simple `Array.join(',')`
    can be used to convert this string value back to an array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `lpush` and `rpush` commands can be used to store our list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding snippet, we are pushing our array of heroes to the right of
    the list. This works exactly the same as JavaScript's `Array.push`, where the
    new values are appended to the existing array. In this case, it means that previously
    empty list now contains our `heroes` array.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can push to the left of the array to prepend to the list:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This will result in our list looking like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, to access our Redis list we can use the `lrange` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The second and third arguments provided to `lrange` are the selection start
    and end position. To return all the elements in the list rather than a subset,
    we can provide -1 as an end position.
  prefs: []
  type: TYPE_NORMAL
- en: Sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Sets are similar to Redis lists with one very useful difference: sets do not
    allow duplicates. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we use the Redis client''s `sadd` to store the set and `smembers` to
    retrieve it. In the second line, we attempt to add the fruit `''bananas''` to
    the `''fruits''` list, but since the value already exists, the `sadd` call silently
    fails. The retrieved set is as expected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You might notice that the ordering of the retrieved 'fruits' set is different
    from the order that it was stored in. This is because a set is built using `HashTable`,
    which means there are no guarantees to the order of the elements. If you want
    to store your elements in a particular order, you must use a list or a sorted
    set.
  prefs: []
  type: TYPE_NORMAL
- en: Sorted sets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Functioning as a sort of hybrid between lists and sets, sorted sets have a
    specific order and cannot contain duplicates. See the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the `zadd` method, we specify the key for our sorted set and an array
    of values. The array indicates the order of the stored set by following this format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'The `zrange` method uses similar arguments to `lrange`, we specify the start
    and end positions of the set to be returned. This method will return the set in
    ascending order:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'We can reverse this by using `zrevrange`. Note how we also provide the `withscores`
    string as an argument. This argument will return the scores of each element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `withscores` argument can be used for all sorted set retrieval methods.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have realized already, sorted sets especially shine when used to
    keep track of game scores or leaderboards. With that in mind, let's revisit our
    "roll" bot from [Chapter 3](ch03.html "Chapter 3. Adding Complexity"), *Adding
    Complexity*, and add a leaderboard of winners.
  prefs: []
  type: TYPE_NORMAL
- en: Best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Any user should be able to store data in Redis via bot commands; it is however
    recommended you ensure that the data storage methods cannot be easily abused.
    Accidental abuse might happen in the form of many different Redis calls in a short
    amount of time. For more information on Slack channel spam and remedies, revisit
    [Chapter 2](ch02.html "Chapter 2. Your First Bot"), *Your First Bot*.
  prefs: []
  type: TYPE_NORMAL
- en: 'By restricting bot traffic, we can ensure that Redis does not receive an inordinate
    amount of write and retrieve actions. If you ever find that Redis latency is not
    as good as it should be, visit this webpage to help troubleshoot: [http://redis.io/topics/latency](http://redis.io/topics/latency).'
  prefs: []
  type: TYPE_NORMAL
- en: Let's now look at how we can improve familiar bot behavior with the addition
    of Redis data storage.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, here is our `roll` command, with the new Redis store code highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: To store the user's win, we use the Redis client's `zincrby` method, which will
    increment the winner's score by one. Note how we can specify how much to increment
    by in the second argument. If the key (the winner's name here) doesn't exist in
    the set, it is automatically created with the score 0 and then incremented by
    the specified amount.
  prefs: []
  type: TYPE_NORMAL
- en: 'To retrieve the scoreboard, lets add the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the `scoreboard` command is given, we immediately look for the reverse
    range by using the `zrevrange` method. This will asynchronously return an array
    in the format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we transform that array into a two-dimensional array by splitting the
    names and scores into nested arrays, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Formatting the data in this way makes it easy for us to send the name and score
    to the channel, preceded by the placing on the scoreboard (the index of the array
    plus one).
  prefs: []
  type: TYPE_NORMAL
- en: 'The final result in Slack shows us a working scoreboard:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Best practices](img/B05384_04_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: A scoreboard achieved through persistent data storage
  prefs: []
  type: TYPE_NORMAL
- en: 'Before moving on to another example, let''s look at how to delete a Redis key/value
    pairing. Replace your `scoreboard` command with the following, taking note of
    the highlighted code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Now if the command `scoreboard wipe` is given, we use the Redis client's `del`
    function to wipe the key/value pairing by specifying the key.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also add in some error handling that sends an error message if there are
    no scores at all:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Best practices](img/B05384_04_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Deleting data should be used with caution
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In a real-world example, scoreboards and other sensitive data constructs should
    only be deleted by a user with admin rights. Remember that you can check whether
    the command issuer is an admin by checking the `user.is_admin` property.
  prefs: []
  type: TYPE_NORMAL
- en: Simple to-do example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With the basics of Redis covered, we shall now move on to create a simple to-do
    Slack bot. The aim of this bot is to allow users to create a to-do list, allowing
    them to add, complete, and delete a task from this list as they go about their
    day.
  prefs: []
  type: TYPE_NORMAL
- en: 'This time, we will start with a skeleton of what we want and build each feature
    step by step. Start by adding this new command to your bot:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'The bot''s behavior will change depending on the second command given after
    the initial `todo` command. In this instance, a `switch` statement is ideal. We
    allow for five options: `add`, `complete`, `delete`, `help`, and a default option
    that is triggered when anything else is passed in.'
  prefs: []
  type: TYPE_NORMAL
- en: The `help` and default behaviors have already been completed, as they are fairly
    straightforward. In the latter's case, we retrieve the Redis set, send out an
    error if it doesn't exist or has no items and otherwise send the total to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple to-do example](img/B05384_04_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Display a message if there are no to-dos
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a to-do task is simple as well. We are using a Redis set, as we do not
    want to allow duplicates in our list. To add an item, we use the previously introduced
    `sadd` command. To make our `switch` statement less cluttered, all the code will
    be moved to a separate function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'And the `addTask` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: All arguments after the first two (`todo add`) are joined into a single string
    and added to our set with the user's name as our key. Remember, duplicates are
    not allowed in a Redis set, so it's safe to store the task without doing any prior
    checking. We do check to make sure the task argument is not empty, sending a gentle
    reminder of how to use the "add" function if it is.
  prefs: []
  type: TYPE_NORMAL
- en: After the task is set, we display a confirmation and the entire to-do list.
    This is behavior that we will implement for every action, as it's a good practice
    to show the user what they've done and how it's impacted the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of adding tasks to our to-do list:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple to-do example](img/B05384_04_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Redis' set takes care of the index for us
  prefs: []
  type: TYPE_NORMAL
- en: 'Next up is the `complete` command, which takes the number of a task as an argument:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the accompanying `completeTask` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This action is a little more complicated, as we have to do a little more error
    handling to begin with. First, we make sure that the argument provided is a valid
    number by using the ES6 `Number.isNaN` method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Be careful when using ES5's `isNaN` method or ES6's `Number.isNaN` method, as
    they can be confusing. These methods answer the question *is the value equal to
    the type NaN? rather than is the value a number?* For more information, visit
    [https://ponyfoo.com/articles/es6-number-improvements-in-depth#numberisnan](https://ponyfoo.com/articles/es6-number-improvements-in-depth#numberisnan).
  prefs: []
  type: TYPE_NORMAL
- en: After retrieving the set from Redis, we ensure that tasks exist, that the number
    provided makes sense (for example, not less than 1 or more than the length of
    the set), and that the task hasn't already been completed. The latter is determined
    by whether the task has any tilde (`~`) operators contained within. Messages containing
    a tilde as the first and last character will render in strikethrough style within
    Slack.
  prefs: []
  type: TYPE_NORMAL
- en: To complete a task, we remove the task from the Redis set (using `srem`) after
    assigning it to the `task` variable, and then add it to Redis again with the strikethrough
    style.
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple to-do example](img/B05384_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Complete a task by referencing its task number
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, let''s look at the delete function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'Here''s the accompanying function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The first thing to note in this function is how we use a type of function overloading
    to achieve two different outcomes, depending on the arguments passed in.
  prefs: []
  type: TYPE_NORMAL
- en: Because JavaScript is a loosely typed language, we can perform actions depending
    on whether the `target` argument is a string or a number. In the case of a string
    (and provided that that string equals *all*), we delete the entire set from Redis
    using the `del` command, clearing the whole to-do list.
  prefs: []
  type: TYPE_NORMAL
- en: In case of a number, we only delete the task specified, provided that the target
    is a valid number we can use (for example, not smaller than 1 and not greater
    than the length of the set).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here''s the multiple functionality of the `delete` command in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Simple to-do example](img/B05384_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: List the to-dos, delete a task, add another, and then delete the whole list
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, the reader has learned the basics of the persistent data storage
    Redis and how to use it through the Node Redis client. We outlined the reasons
    why Redis lends itself well for use with bots, particularly when keeping a score
    list or storing multiple small items.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will introduce the concept of **natural language processing**
    (**NLP**) and see how to evaluate and generate natural language for use in a bot.
  prefs: []
  type: TYPE_NORMAL
