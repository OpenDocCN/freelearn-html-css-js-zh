- en: Chapter 10. Game On
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A quick browse through any of the online app stores quickly shows that the largest
    segment of the mobile applications market belongs to gaming. While most programmers
    would not think of JavaScript when it comes to developing games, it is actually
    well suited for a wide variety of games, including turn-based strategy games.
  prefs: []
  type: TYPE_NORMAL
- en: 'These games require only limited animation and can easily be built using the
    Sencha Touch Framework and the Sencha.io platform for communication. For turn-based
    strategy games, we only need to do a few basic things such as:'
  prefs: []
  type: TYPE_NORMAL
- en: Build a game board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build the individual pieces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle moves
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle the outcomes when one piece attacks another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handle communication of the moves between players at the end of a turn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Define the end of the game
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While this might seem a trivial style of game, it covers everything from tic-tac-toe
    to chess, poker, Go, Risk, and the incredibly complex tabletop strategy games
    of the pre-Internet era, such as Axis and Allies.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you really want an idea of how complex some of these games can get, take
    a look at [http://boardgamegeek.com/](http://boardgamegeek.com/) and check out
    the strategy section.
  prefs: []
  type: TYPE_NORMAL
- en: Since we don't have an entire book to dedicate to this single topic, we are
    going to start with a relatively simple game of checkers. We will also explore
    some of the possible ways to take this simple game and build on it to create more
    complex games.
  prefs: []
  type: TYPE_NORMAL
- en: Building the basic board
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With any type of turn-based strategy game, it all starts with the board. The
    board determines where the pieces are placed and where they are allowed to move.
  prefs: []
  type: TYPE_NORMAL
- en: A board for checkers or chess consists of an 8 by 8 grid of squares. The squares
    alternate in color between light and dark (typically red and black for a dedicated
    checkers board).
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, only the dark squares can be used by the pieces in checkers.
  prefs: []
  type: TYPE_NORMAL
- en: You could use a number of different Sencha Touch components to create such a
    board, but for these purposes a DataView is probably the most appropriate. A DataView
    will allow us to tap and select the piece we want to move as well as the place
    we want to move it to. These selection methods are already built into the DataView.
    We can also apply styles based on these selections to let the user know which
    moves are valid.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the square model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our DataView will be fed by a store with a model we call `Square`. It looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This model carries five key pieces of information:'
  prefs: []
  type: TYPE_NORMAL
- en: '`squareID` tells us exactly where the square is located on our board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The value for `occupiedBy` tells us if the square is currently occupied by a
    red piece, a black piece, or if it is unoccupied (`none`).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`pieceType` will tell us if we are dealing with a regular piece or a king.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `decoration` setting will allow us to indicate the current movement path
    for the pieces and if a particular piece has been jumped.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `background` setting controls the background color of the piece. We will
    use this to set a style in our xTemplate for the DataView.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our initial load in of data would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This would continue on to give us eight rows of eight squares per row. Squares
    are designated A through H and rows are numbered 1 through 8\. This data will
    also lay out our initial pieces in the standard layout for the start of a checkers
    game.
  prefs: []
  type: TYPE_NORMAL
- en: You will also notice that when we alternate the backgrounds, we keep the last
    item of the row and the first item of the next row as the same color (`H1` and
    `A2` are both `dark`). This gives us our checkerboard pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating the square model](img/8901OS_10_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The actual board image itself is a single background image. We have arranged
    our DataView to fit over the board and align with the individual squares. This
    will let us place elements on any square we choose using CSS. The `dataview` code
    is included as one of the items in our `view/Main.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This DataView has a `cls` value of `board` so we can set the background image
    to the big checkerboard image in our `resources/css/app.css` file.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring itemTpl
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We also make extensive use of classes in the `itemTpl` config. Let''s take
    a look at the template line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'The first line sets up a `div` element with a `class` value of `gameSquare`.
    Each `gameSquare` is set in the `app.css` file to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This sets the individual items in our DataView to line up with our game board.
    By setting `position: relative`, we can also position items absolutely within
    `gameSquare`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We also add a class for `{background}`. This value will be pulled from our
    data store and it will be either light or dark. We add this class so we can change
    the font color for our dark tiles to white. In the CSS, this looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The next class we set is `decoration`. The `decoration` class will be used
    to show arrows for movement and a negation symbol when a piece will be jumped
    as part of a move as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring itemTpl](img/8901OS_10_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These images can be inserted into a style using the `before` CSS selector. This
    selector will insert content before our `div` element. In this case, we will insert
    a green arrow to indicate the direction the piece is moving.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, a piece moving up and to the left will have its `decoration` value
    set to `up_left` and the following style is applied in our `app.css` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'By using `position: absolute`, we can set the `top` and `left` position of
    our image to any value we like including a negative number. The negative number
    places it up and to the left of the actual square (overlapping the square to the
    upper-left corner). The high `z-index` value insures that the image appears on
    top of the other images and text.'
  prefs: []
  type: TYPE_NORMAL
- en: We have similar CSS styles created for `.up_right`, `.down_left`, and `.down_right`.
    This gives us indicators for four diagonal directions of movement.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of our images have been saved in the `resources/images` directory. If you
    change the location of the images, you will need to adjust the CSS file to match
    your setup.
  prefs: []
  type: TYPE_NORMAL
- en: 'We also have a decoration class called `removed`. This class uses the CSS selector
    `after` to insert content after the `div` element and display our negation symbol
    over a piece that will be jumped during the current move. The CSS looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: It is similar to our styles for our arrows, except we need this symbol to show
    up over the top of our piece. We set its `top` and `left` attribute to `0` and
    because the image is the same size as our square, it floats over the top of the
    image of our piece. The higher z-index assures that it is the top element.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next line of `itemTpl` is what controls the piece that occupies the square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: We use a `tpl if` statement here to check and see if the square is occupied
    and if so, by what kind of piece. We use two of our data values to determine this
    value.
  prefs: []
  type: TYPE_NORMAL
- en: The first is `occupiedBy`, which can be `red`, `black`, or `none`.
  prefs: []
  type: TYPE_NORMAL
- en: The second is `pieceType`, which can be `regular`, `king`, or `none`.
  prefs: []
  type: TYPE_NORMAL
- en: If both data values are set to `none`, we do not place a piece in the square.
    If we have a piece in the square, we use the combination of `occupiedBy` and `pieceType`
    to determine our image.
  prefs: []
  type: TYPE_NORMAL
- en: '![Exploring itemTpl](img/8901OS_10_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: These CSS values along with the individual squares from our DataView allow us
    to set the appearance of every square on the board by using the values stores
    in our data store.
  prefs: []
  type: TYPE_NORMAL
- en: Our individual moves can be created using the `select` event in our DataView.
    By setting the `mode` attribute to `MULTI`, the user can tap the piece they want
    to move and then the square they wish to move to. They can continue to tap squares
    if they are in a position to jump multiple pieces. We can also use the DataView's
    built-in `x-item-selected` class to highlight the squares the user has tapped.
  prefs: []
  type: TYPE_NORMAL
- en: 'We just add the highlighted styles to our stylesheet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This gives us a green border to match our arrows and changes the text color
    as well. We also set a slightly different text color in our dark squares for readability.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have all of our different display possibilities mapped out, we need
    to set up the logic for the game.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the game controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game controller is where the logic for our game will go. Here we will follow
    the basic rules for checkers:'
  prefs: []
  type: TYPE_NORMAL
- en: Pieces are initially arranged on the opposite sides of the board in three rows,
    only on the black squares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pieces can move diagonally
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pieces can only move to an empty square
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Regular pieces can only move forward
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pieces can only move one square, unless jumping over an adjacent piece
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Pieces can only jump one piece at a time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Jumped pieces are removed from the board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: King pieces can move forward and backwards
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A regular piece that reaches the opposite side of the board is changed to a
    king piece, ending their current turn
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The game is finished when all the pieces from one side have been jumped and
    removed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Our controller will check each move to see if it follows these rules and remove
    the pieces that have been jumped. For the purposes of this chapter, we will only
    be creating a local game. This is one in which two players would play by passing
    back and forth a single device. However, this game could easily be modified to
    allow for networked play using Sencha.io or an external API.
  prefs: []
  type: TYPE_NORMAL
- en: Before we dive into the code for the controller, we need to add some things
    to our main view. We need a way for each user to start and finish a turn. We will
    also need a way to show a previous turn so that a user can see what occurred during
    the last move.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, we will add a toolbar with two buttons to the bottom of our main
    view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: We will expand the functionality of these two buttons in our controller, so
    that they will also allow us to finish a turn or clear a currently selected move
    if we change our mind before finishing.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's see how this all fits together in the controller.
  prefs: []
  type: TYPE_NORMAL
- en: 'As always, we start out by setting up our controller with the `control` and
    `refs` sections:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: We create references for our board and our two buttons. In the `control` section,
    we add `select` and `deselect` functions for our board, and `tap` functions for
    our two buttons. The `mainBtn` function will start a turn and execute the finished
    move. The `altBtn` function will show the previous turn or clear the current set
    of moves. We will swap the text and functionality appropriately as part of the
    `tap` functions.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to track the turns, we are going to add two custom variables to our
    controller. These go down below our `refs` section (inside the `config` section):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `previousTurn` variable will store red or black for `player`, `piece` (piece
    that was moved), `moves` (moves that were made—as an array), and `removedPieces`
    (pieces removed—as an array). This will let us highlight the squares from the
    previous turn when the user clicks on the **Show Previous Turn** button.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `currentTurn` variable stores the same information as `previousTurn`, but
    it also adds `Boolean` data for:'
  prefs: []
  type: TYPE_NORMAL
- en: '`endOfTurn`: Has the user confirmed and completed the current move?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`hasJumped`: Has the user jumped a piece as part of their turn?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`started`: Has the user pressed the **Start Turn** button?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`kingable`: Has the user reached the opposite end of the board as part of the
    current move?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also set the value for player to `black` by default, as black traditionally
    moves first in checkers.
  prefs: []
  type: TYPE_NORMAL
- en: By declaring these `previousTurn` and `currentTurn` variables as part of `config`,
    we automatically create getters and setters for both. This means we can do things
    like `this.getPreviousTurn()` and `this.setCurrentTurn()` inside any of our controller
    functions. We will be using these functions extensively throughout the controller.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding basic controller functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another thing that we will be using extensively in this controller is the concept
    of **subordinate functions** . These are functions that are called by other functions.
    While it might seem counter intuitive at first, splitting larger functions apart
    into smaller sub functions makes the logic easier to follow.
  prefs: []
  type: TYPE_NORMAL
- en: This is especially true in the case of game logic, where the rules for the game
    can quickly spiral into a series of incomprehensible "if…then" statements. By
    splitting the logic into smaller functions, the logic is much easier to check.
    You can simply use `console.log()` to output the value you start with and the
    value you finish with in each of the smaller functions. This makes it much easier
    to tell which pieces are functioning as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this application, we have some smaller functions that help us with our
    game logic. We won''t go into great detail about these smaller functions but they
    can be found in the `controller/Game.js` file. These functions include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`nextLetter` and `previousLetter`: Given a letter and a distance, these two
    functions return the next or previous letter in the sequence. For example, `nextLetter(''c'',
    2)` would return `e` when called. These will help us determine positioning on
    the board.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`getIntermediateSquare`: Given a *from location* and a *to location*, this
    function will return the square located between the two squares. This is used
    when a piece is jumped, so we can determine if a move is valid and apply the correct
    decorations to the square (arrows and negation symbol for jumped pieces).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`isKingable`: Given the location the piece is moving to, is it eligible to
    be kinged?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clearTurn`: Clears out any old data from the current term and deselects any
    selected squares in the DataView.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`clearDecorations`: Clears any decorations from the data store (clearing this
    data also removes it from the display).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Aside from these smaller functions, the main logic for the board is handled
    in the `select` event. This event needs to check and see if we have a valid move,
    and then add the appropriate decorations to the board. These decorations will
    show the selected piece, the direction of the move, and any affected squares or
    pieces.
  prefs: []
  type: TYPE_NORMAL
- en: The game board logic
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The game logic will function as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A player clicks on the **Start Turn** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The game responds with an alert telling the player it is black's or red's turn.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player taps a piece.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The game checks that a valid piece was tapped and stores the information in
    the `currentMove` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player taps a destination square.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The game checks if the destination is valid and stores the information in the
    `currentMove` variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The player can then tap **Finish** **Turn!** to complete the turn or tap additional
    squares if jumping multiple pieces (finally tapping **Finish** **Turn!** when
    all moves for the turn are complete).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the player taps **Finish Turn!**, the system removes any jumped pieces,
    removes all decorations for the move, and stores the move in the `previousMove`
    variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will begin our trip through the game logic at the most logical place, the
    function that fires when the user clicks on the **Start Turn** button.
  prefs: []
  type: TYPE_NORMAL
- en: Starting a turn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Our **Start Turn** button actually has two functions that it handles, starting
    and finishing the turn. This means that we will switch functionality based on
    the current status (text) of the button. In the controller, this button is referred
    to as `mainBtn` and the tap function looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: We start by grabbing our `currentTurn` variable using `this.getCurrentTurn()`.
    If the game has just started, the turn belongs to black. The rest of our values
    will be empty or false at this point.
  prefs: []
  type: TYPE_NORMAL
- en: We then check to see what the text value of the button is, so that we can determine
    what to do next. If the text is `Start Turn`, we need to change the text of the
    button to `Finish Turn!`.
  prefs: []
  type: TYPE_NORMAL
- en: Our other button (`altBtn`) also changes its text based on the status of the
    current turn. If we are starting a new turn, `altBtn` will be set to `Clear Move`.
    This will allow the player to clear the move if they change their mind before
    finishing.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we update our `turn` value for `started` to `true`. This lets us know
    that the current move has begun. We use the function called `clearTurn()` to clear
    out any old turn data and remove any previous selections from the board. We then
    inform the current player that it is their turn.
  prefs: []
  type: TYPE_NORMAL
- en: If the text of the button is set to `Finish Turn!`, the button will commit the
    selected move(s) for the current turn using another sub function called `commitTurn()`.
    We then change the current player, clear out the turn data, and reset the text
    for our two buttons. We'll come back to finishing a turn a bit later, but first
    we need to see what happens once the turn begins.
  prefs: []
  type: TYPE_NORMAL
- en: Checking the turn
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the turn has started, the user taps on the DataView to move a piece. We
    then need to make sure that each selection they make is valid. We do this by listening
    to the DataView's `select` event with a function called `doSelect()`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first thing we want to make sure of is that the user has selected a valid
    piece, so the first thing we do is get the current turn:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we have a few moves we know are illegal, in which case we can return
    false to prevent the player from selecting this moves:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This prevents the user from moving before the turn starts or after it has ended.
    We also don''t want the user to select any or the light squares on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'With the obvious illegal moves out of the way, we start checking for allowed
    moves, starting with this one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: This checks that we are at the beginning of a turn (`turn.moves.length == 0`)
    and the player has not clicked one of his or her opponent's pieces. If so, we
    return false to prevent the selection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: If we are at the beginning of a move and the user has clicked the correct piece,
    we add the record onto the beginning of our `moves` array.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We store `moves` in reverse order so that the first move in the list is the
    last move made. This is because it makes it much easier to grab the first element
    in the array (which will always be `turns.moves[0]`), than it is to count the
    array elements to grab the one on the end of the array.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the current turn with our new information and return true, so that
    the selection event fires and the square the piece is in highlights.
  prefs: []
  type: TYPE_NORMAL
- en: 'If this is not the first move (`turn.moves.length` is greater than zero), it
    means the user has previously selected a piece and is now selecting a square for
    the piece to move into. If this is the case, we move on to the next `else` statement,
    which checks to see if the move is legal under our game rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: If the move is legal, we also check `isKingable()` to see if the player has
    reached the opposite side of the board. If the move is legal, we set the turn
    appropriately and add the arrows for the move using the `decorateCurrentTurn()`
    function. We will take a closer look at how the `decorateCurrentTurn()` function
    works a little later, but first we want to cover the logic behind the `isLegalMove()`
    function.
  prefs: []
  type: TYPE_NORMAL
- en: Checking if a move is legal
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `isLegalMove()` function is called when the user has selected a valid piece
    and is attempting to move it to a new square. The move isn't actually committed
    in this function, we are just checking to see if the square the player taps is
    a valid move. If it is, we allow the DataView's `select` event to fire by returning
    true.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for this application includes extensive console logs inside
    this function. These will print out information to the console in Safari or Chrome
    and should help when trying to follow the logic inside this function. Try clicking
    on valid and invalid moves while looking at the console to see which pieces of
    the function are responding, and how the move is validated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make this determination, we follow the basic rules for checkers and examine
    the move with the following criteria:'
  prefs: []
  type: TYPE_NORMAL
- en: The destination square cannot be occupied
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The move must be in the correct direction (regular pieces can only move forward)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The move can be one square away from the current position
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The move can be two squares away from the current position, *if* there is an
    opponent's piece in between the two squares
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Since this is a rather large function, we will cover it in several parts, starting
    with the overall skeleton and filling in the details as we go.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start our function by passing it values for our `from` and `to` locations
    for the move. We then grab the current turn and set some variables for later use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The first thing we check is if the destination square is occupied using `to.get('occupiedBy')`.
    If the square is clear this variable should be `none` and if it is occupied, it
    will be either `red` or `black`. If we get back `red` or `black`, we immediately
    return false which will exit our `isLegalMove()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we use the `split` function to take our values for `to` and `from`, and
    split them into an array. Since we `split` on `''`, it assigns the letter (A-H)
    to the first element of the array (`fromID[0]` and `toID[0]`) and assigns the
    number (1-8) to the second element of the array (`fromID[1]` and `toID[1]`).
  prefs: []
  type: TYPE_NORMAL
- en: We then use `Math.abs` to give us the distance between the two number values.
    `abs` is an absolute value, which ensures that we get back a positive number even
    if `fromID[1]` is greater than `toID[1]`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to note that this distance is the row distance and not the actual
    number of squares between the start and the end of the move.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to make sure our distance is one row (no jumping) or two rows
    (jumping). If it's neither, we return false and do not allow the move. These two
    sections are currently empty, so let's fill them out with some code.
  prefs: []
  type: TYPE_NORMAL
- en: 'As it turns out, these two options also have a few possibilities we need to
    account for. We will start off with a possible move of one row:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This checks our distance of one row and it also makes sure that the user does
    not jump a piece and then attempt to move a single row afterwards as part of the
    same move.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside of this `if` statement, we need to check three possibilities:'
  prefs: []
  type: TYPE_NORMAL
- en: Is the piece a king?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the piece red?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Is the piece black?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'These criteria determine which direction the piece can move and allow us to
    check if the move is valid. For the king we check the following condition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Here we use our `nextLetter()` and `previousLetter()` functions as part of
    a check to see if the move is on the diagonal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking if a move is legal](img/8901OS_10_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the example above, a king located in the **2** row of the board can move
    to either the **1** row or the **3** row, in the **D** or **F** column. Since
    our previous `doSelect()` function already checked to make sure we did not select
    a light background, we know that these are all valid moves. This is true for a
    king of either color.
  prefs: []
  type: TYPE_NORMAL
- en: We then call `setEndOfTurn()` and return true to fire the select function and
    select the square.
  prefs: []
  type: TYPE_NORMAL
- en: 'For regular red and black pieces, we need to make sure the move is in the correct
    direction. For red, this looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Since our rows are numbered 1 - 8 from top to bottom and red moves from bottom
    to top, we need to make sure that the row number we are coming from is less than
    the row number we are going to (`toID[1] < fromID[1]`).
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking if a move is legal](img/8901OS_10_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: We also need to make sure we are going to the next or previous letter before
    calling `setEndOfTurn()` and returning true to select the square in the DataView.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the black pieces, we will be moving from top to bottom, so we need to make
    sure our destination row is greater than our starting row. This will close out
    our `if` statement for distances of one row (no jumping):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'As before, this checks our row letters to make sure we only move to the adjacent
    rows, calls `setEndOfTurn()` and returns true to select the square:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking if a move is legal](img/8901OS_10_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have our single row moves accounted for, we need to take a look
    at what happens when we try to move a distance of two rows.
  prefs: []
  type: TYPE_NORMAL
- en: 'From the user''s perspective, they will select a piece by tapping on it, and
    then select an empty square with an opponent''s piece in between the two squares.
    If additional jumps are available, the play will tap those squares as well before
    clicking on the **Finish Move** button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Checking if a move is legal](img/8901OS_10_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In this example, the player would tap the red king piece and then tap the three
    squares (shown here with check marks) before clicking on the **Finish Move** button.
    Let's take a look at how the code checks for this move.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where we fill out the second `if` statement inside of our `isValidMove()`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This will check our row distance and grab the square located between the `from`
    and `to` locations using a `getIntermediateSquare()` function. In the preceding
    example, the move from **D5** to **B3** would grab **C4** as the intermediate
    square.
  prefs: []
  type: TYPE_NORMAL
- en: Much like before, we will also need to check and see if the piece is black,
    red, or a king so we can make sure the jump is in the correct direction. However,
    there are a few new wrinkles to allow for.
  prefs: []
  type: TYPE_NORMAL
- en: First, we have to make sure that there is an opposing piece in between the `from`
    and `to` locations. Second, we need to allow for multiple jumps.
  prefs: []
  type: TYPE_NORMAL
- en: If you remember back at the top of our controller, we had two variables for
    `currentTurn` and `previousTurn`. Inside of these were empty arrays for `moves`
    and `removedPieces`. We will use these arrays to store the multiple jumps.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the king pieces, we open up a new `if` statement, right below where we
    grabbed the intermediate square:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Once we know that we have a `King` piece, we don't need to check for the direction
    of the jump, we just need to make sure that the `intermediate` piece is the opposite
    color from the piece that is moving (our `occupiedBy` piece). Once we have determined
    this is a valid king jump, we use `unshift` to add the move onto the beginning
    of our array of moves.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Remember we need to add things to the beginning of the `moves` array, so we
    can quickly access the most recent of these moves later on by using `moves[0]`
    in our other functions. This is necessary for placing the arrow decorations correctly
    (as we will see later on). It is less critical for our `removedPieces` array,
    which places the negation symbol directly over the piece. So for `removedPieces`,
    we use the `push()` function instead.
  prefs: []
  type: TYPE_NORMAL
- en: We also add the `intermediate` location to our `removedPieces` array and set
    `hasJumped` to `true`. This lets us know that there are potentially more moves
    to be executed. Finally, we use `setCurrentTurn()` to record the location the
    user selected and return true to select the square in the DataView.
  prefs: []
  type: TYPE_NORMAL
- en: 'For moving a red piece, we run a check to see if the piece is jumping forward
    by checking to make sure that `toID[1] < fromID[1]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: We also check to see if the piece that was jumped is black. The rest of the
    code follows the same pattern as the code for the king jump.
  prefs: []
  type: TYPE_NORMAL
- en: 'We add the same basic code block to check the jump for a black piece:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Again, we check our direction using `toID[1] > fromID[1]`, and check our intermediate
    square for a red piece. The rest of the code follows the same pattern as the code
    for both the red and the king jumps.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of our `isValidMove()` function, after all the `if` statements,
    we close out the function with `return false`. This covers us when the user does
    something totally outside of our set of `if…then` rules.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have determined if the move is valid, we need to add the correct classes
    to our game board to let the user know they have chosen a valid move, and what
    will happen when the move is finished.
  prefs: []
  type: TYPE_NORMAL
- en: Decorating the move
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once the user has started a turn and clicked on a square, there needs to be
    some indication that a valid move was selected. This happens as part of the `doSelect()`
    function and it happens in two different ways.
  prefs: []
  type: TYPE_NORMAL
- en: The first way is that when we validate the selected move, we return either `true`
    or `false`. When we return `true`, that DataView fires the `select` event and
    the selected square is highlighted (this is the default behavior for a DataView).
  prefs: []
  type: TYPE_NORMAL
- en: When we return `false`, we actually prevent the `select` event from firing and
    the square is not highlighted.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier in the chapter, the highlight color is controlled with
    CSS styles and a class of `x-item-selected`. This class is automatically applied
    to any selected item in a DataView. We can use a similar methodology to add additional
    CSS decorations to our squares, which will give the user a better idea of what
    is happening in the game.
  prefs: []
  type: TYPE_NORMAL
- en: This happens in the `decorateCurrentTurn()` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in the chapter we talked about our decoration classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`up_left`: This suggests an arrow in the upper-left corner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`up_right`: This suggests an arrow in the upper-right corner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`down_left`: This suggests an arrow in the lower-left corner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`down_right`: This suggests an arrow in the lower-right corner'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removed`: This suggests a negation center in the middle of the square'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the game board, they look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Decorating the move](img/8901OS_10_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The `decorateTurn()` function will loop through our array of moves for a turn
    and apply the correct styles.
  prefs: []
  type: TYPE_NORMAL
- en: 'We start by getting the `fromID` and `toID` values for the move and splitting
    it into an array with two elements: a number and a letter. Then we compare them
    to create a class name that corresponds to one of our four arrows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, let''s assume we have a piece moving from **E4** to **D3**. If
    we split these values and check them in the preceding code, we would see that:'
  prefs: []
  type: TYPE_NORMAL
- en: 4 < 3 is false and we would set the value of `cls` to `up`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: D < C is also false and we would add the text `_left` to our `cls` value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This leaves us with a class of `up_left` applied to our square, and an arrow
    in the upper-left corner.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Comparing greater than / less than for text values in JavaScript compares the
    ASCII values for the letters. This is fine if you are comparing single letters,
    all with the same case, but it can become problematic in many cases. For example,
    "Z" < "a" is actually true in JavaScript, because all uppercase letters have a
    lower ASCII value than lowercase letters. In this case we are comparing a single
    uppercase letter to another single uppercase letter, which works just fine.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have set our arrow to indicate the direction using `from.set('decoration',
    cls);`, we need to account for any pieces to be removed. We handle this by looping
    through our `removedPieces` array that is part of our `turn` variable. We add
    `'removed'` to the class for all of the pieces in this array. The space in front
    of the string means that it will be added as an additional class on the square.
  prefs: []
  type: TYPE_NORMAL
- en: This means the CSS class would be something like `"up_left removed"`, if the
    turn jumps over a piece that is up and to the left of its current location. Both
    styles would be applied to the square, giving it an upper-left arrow and a negation
    symbol.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have applied our styles for each move, we call `this.getBoard().refresh();`
    to refresh the board and make everything show up.
  prefs: []
  type: TYPE_NORMAL
- en: 'The beauty of creating a separate function for `decorateTurn()` is that we
    can use it to decorate the previous turn as well as the current one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This function runs a check to see if we have a previous turn. If we do, we just
    pass it along to our decorate turn function and let it handle showing the appropriate
    decorations. If you were feeling particularly ambitious, you could store all the
    turns and replay every one of them by looping through and passing each turnoff
    to the `decorateTurn()` function.
  prefs: []
  type: TYPE_NORMAL
- en: However, before we get too ambitious, let's take a look at how we clear a move
    and its decorations.
  prefs: []
  type: TYPE_NORMAL
- en: Clearing the move
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When we clear a move, we need to accomplish two main things: clear the data
    out of our `currentTurn` variable and clear the decoration values out of our store.
    We split this into two separate functions to make things easier to update and
    maintain. The first function handles resetting the values for our `currentTurn`
    variable and then deselects everything on the board:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The second function clears all of the decorations from the store. You might
    remember from previously in the chapter, the decorations are the arrows that indicate
    movement and the negation symbols used to designate a jumped piece. These are
    all applied as CSS styles to the squares in our DataView. When we clear the value
    for decoration on each square in the store, the DataView will automatically remove
    the arrows and symbols from the display.
  prefs: []
  type: TYPE_NORMAL
- en: Going beyond the finished game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Playing through the finished game can lead to some interesting ideas for modifications
    and improvements.
  prefs: []
  type: TYPE_NORMAL
- en: '![Going beyond the finished game](img/8901OS_10_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The squares could easily be adapted to the traditional hex grid used in most
    tabletop role-playing games.
  prefs: []
  type: TYPE_NORMAL
- en: '![Going beyond the finished game](img/8901OS_10_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Even with a hex layout, the basic logic flow for the game still remains the
    same:'
  prefs: []
  type: TYPE_NORMAL
- en: The user selects a piece and we check if it is a valid selection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The user selects a destination and we check if the destination is valid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If it is a valid move we provide visual feedback through CSS to tell the user
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We determine the result of the move and remove or modify pieces as appropriate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We check to see if the game has ended and if not, we repeat the process for
    the next player
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The validation is also still a matter of math and some basic `if…then` logic.
    Granted, this logic can become much more complex, but the basic rules and game
    flow will remain the same.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, CSS transitions could be used to add a more visual appeal to the
    game play. A number of options can be found in the documentation at [http://docs.sencha.com/touch/2-0/#!/api/Ext.Anim](http://docs.sencha.com/touch/2-0/#!/api/Ext.Anim).
  prefs: []
  type: TYPE_NORMAL
- en: These variations allow you to take a simple game model and truly make it your
    own.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter we covered the creation of a basic game of checkers:'
  prefs: []
  type: TYPE_NORMAL
- en: We built the basic game board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explored the CSS and HTML structure to create our layout
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We built the basic game controller and covered the game board logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We showed you how to start, validate, decorate, and clear the moves on the board
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also talked about some options for expanding the game and making it your
    own original idea
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
