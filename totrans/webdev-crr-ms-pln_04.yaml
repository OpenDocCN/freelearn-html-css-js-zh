- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Managing, Securing, and Working with Code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Over the last two chapters, we’ve spent a fair amount of time looking at actual
    code and getting you acclimated to the nuts and bolts, so to speak, of web development.
    It should be obvious that most of your time will likely be spent “twiddling bits,”
    as we software nerds like to say!
  prefs: []
  type: TYPE_NORMAL
- en: But you’ve also seen that there is a lot more to it than just *writing* code.
    In this chapter, we’ll look at a few more of those “not writing code” things,
    including the idea of source control (how you keep track of the changes to your
    code), operating systems (Linux in particular), **integrated development environments**
    (**IDEs**) (tools that help you write code without leaving one consolidated application),
    security, and even one or two other languages that commonly come into play for
    web developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’ll touch on the following “non-code,” so to speak, topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the code – source control management systems
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Thinking like a hacker – securing the web
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working all in one place – IDEs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the operating system – Linux
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As in the previous chapter, I will assume you have already downloaded the source
    code for this book from GitHub, as outlined in the *Technical requirements* section
    of [*Chapter 2*](B18315_02.xhtml#_idTextAnchor061). For this chapter, we’ll again
    be dealing with the code in the `ch-03/2-spa` directory.
  prefs: []
  type: TYPE_NORMAL
- en: The other thing you’ll need to do is get Git installed. For that, head over
    to [https://git-scm.com](https://git-scm.com) and find the download package appropriate
    for your system. I will leave this as an exercise for you, but it’s nothing unusual,
    so I know you can handle it.
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the code – source control management systems
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Okay; so, you’ve spent a few hours hacking code – maybe you’ve built a nifty-keen
    little user registration page, for example. As someone in the mafia might say:
    it’d be a shame if something were to happen to that code, wouldn’t it? Surely
    there must be a way to protect your code, and indeed, there is: **source control**.'
  prefs: []
  type: TYPE_NORMAL
- en: Let me start by telling you how us old fogies used to do source control.
  prefs: []
  type: TYPE_NORMAL
- en: Every so often, we would create a new directory in our project directory and
    name it something like “HTML_complete_8-6-1991_1-30pm.” Then, we’d copy all the
    files from our project into it. We’d work on the project a little more, and maybe
    later we’d create another directory named “JS_complete_8-6-1991_4:30pm” and again
    copy all the project files into it.
  prefs: []
  type: TYPE_NORMAL
- en: Think that through for a moment. At the point I completed the HTML for the project,
    I essentially made a backup of the current state of all the files in my project.
    When the JavaScript was done, I made another copy. What I had was a history of
    the files in the project. Later, if I was working on the JavaScript and made a
    mistake and found it suddenly didn’t work, I could go back to one of those directories
    and compare the JavaScript to what it was when it last worked.
  prefs: []
  type: TYPE_NORMAL
- en: 'While it was ugly and completely manual, this was essentially a form of source
    control, or **version control** as it’s often called (for obvious reasons: each
    directory represents a past version of the code).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Further, we would frequently, often at the end of the day, copy all those directories
    onto some central server somewhere, one that was being properly backed up all
    the time. This provides a layer of protection: even if the hard drive in our computer
    were to die, we’d have a copy of our code on that server. We might lose some work
    if we were in the middle of coding and hadn’t created a new version directory
    recently, but it’s better than having lost everything. At least we could get back
    to the last saved version at worst.'
  prefs: []
  type: TYPE_NORMAL
- en: It’s a good system in that it provides history and some level of protection,
    but being so manual means it’s very prone to errors. Plus, it’s not all that robust.
    For example, if we need to compare a file to a previous version, how do we do
    that? Back then, it was as “simple” as “putting both files on the screen side-by-side,
    going through them, and trying to spot the changes.” That’s not a great approach.
    And then there are other things you might want to do, such as keep notes alongside
    the code about your progress. Sure, you could create a `notes.txt` file and save
    it, but again, it’s a manual process, and it also varies from developer to developer
    since no two will likely land on the same directory naming conventions and approaches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Surely there must now, literally decades later, be a better answer, right?
    Indeed, there is: **source code** **management** (**SCM**).'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing SCM
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This is where SCM comes in. An SCM system, or version control system, as we
    say, is a piece of software that records changes to your project files over time,
    more or less automatically. SCM provides ways for you to review the history of
    your project, compare files, recall specific versions of files, attach notes to
    your changes, and more.
  prefs: []
  type: TYPE_NORMAL
- en: 'They also do something else that was difficult back in the ugly manual source
    control days: they allow multiple developers to work on the same code simultaneously.
    They do this by tracking the changes of each contributor and managing the process
    of **merging**. Merging is when you have two copies of a file with changes from
    two different people (usually – though it *could* be the same person), and you
    need to combine the changes into one canonical version of the file. When you’re
    a single developer working on a project, this is unlikely to ever come up, but
    it’s a crucial concern in software development when working on a team.'
  prefs: []
  type: TYPE_NORMAL
- en: SCM is considered a foundational tool in software development, meaning that
    in a professional environment, you’ll virtually always be using SCM. These days,
    it’s even unusual for a single developer to not use SCM since there is tremendous
    value in being able to go back in time, so to speak, and see what a file looked
    like at various points in time.
  prefs: []
  type: TYPE_NORMAL
- en: 'SCM has a couple of key points to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Version tracking*: SCM keeps a history of every change made to the files in
    a **repository**, or repo for short, which is another way to describe your project
    directory (it’s not *exactly* the same, but conceptually, that’s the way you can
    think of it for now). Not only does it keep a record of the file’s contents, but
    it also includes who changed it and when the changes were made, and it usually
    includes some sort of note about the change from the developer. This helps track
    the progress of your project, understand how the code base is evolving, and of
    course gives you a way to roll back changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Rollback*: This is simply the ability to retrieve a previous version of a
    file if problems are found (or if you just decide that subsequent changes can
    be thrown away).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Collaboration*: Multiple developers can work on the same code base simultaneously.
    An SCM system manages changes from different people and merges them, allowing
    for collaborative work without overwriting each other’s contributions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Branching*: Sometimes, developers may need to work on something that is somewhat
    experimental. To avoid such experiments messing up the existing presumably good
    code, they can create a branch, which effectively is a copy of the project at
    the time the branch is created. The developer then does their work, saving their
    changes to that branch, all the while not touching the good code. Eventually,
    if the experiment proves fruitful, it can be merged into the good code, making
    it a permanent part of the main project code.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Conflict resolution*: When two copies of a file are merged, they may sometimes
    conflict – for example, if two developers change the same line of code. When that
    happens, the SCM can alert the developer attempting to merge the code that there
    is a conflict that they need to manually resolve (which usually means deciding
    which file the change should come from), and then completing the merge.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Safety*: SCM serves as a backup, of sorts. If project files become corrupt,
    they can be retrieved from the SCM system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that you know what SCM is, let’s talk about the options you have in SCM
    systems.
  prefs: []
  type: TYPE_NORMAL
- en: Accepting the false choice – Git it is!
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Look, I’m just going to cut to the chase here: you almost don’t have a choice
    in what SCM system to use nowadays, it’s gonna be something called Git.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are several SCM systems out there; names such as Mercurial, CVS, Subversion,
    Bitbucket, and Perforce are ones you may have heard of. But the simple truth is
    that the industry has almost entirely coalesced around Git, created by the same
    person who created the Linux operating system: Linus Torvalds. Git was built in
    2005 specifically for those working on the Linux kernel to be able to collaborate
    more easily.'
  prefs: []
  type: TYPE_NORMAL
- en: Git is somewhat unique from many other SCM systems in that it is *distributed*.
    What this means is that every developer has a copy of an entire Git repository,
    including a full history of all changes. This is unusual in that most other SCMs
    are *centralized*, meaning there is one canonical copy of the code, plus all the
    history that goes along with it, and developers only get copies of the code on
    their machines to work on, and never the full history. The benefit of a distributed
    SCM is that they do not require a network connection to a central server all the
    time as a centralized SCM does (though it’s important to note that in *most* cases,
    even when you use Git, there *is* a centralized copy – it’s just that you don’t
    need to be constantly connected to it with Git like with other SCM systems).
  prefs: []
  type: TYPE_NORMAL
- en: Git became popular for many reasons, but one of the big ones is speed and performance.
    With other SCMs, merging changes can sometimes take a fair bit of time. We’re
    not talking about hours here, but even a few seconds add up throughout a workday.
    Git is very optimized for speed from the ground up and most operations happen
    almost instantly. One of the key ways in which Git’s performance won over most
    developers is when it comes to branching. The way Git does branching is fundamentally
    different from most other SCM systems and is far more lightweight. While creating
    a branch in Subversion, for example, may take several seconds or even minutes
    if the content you’re branching from is large enough, with Git, it’s practically
    instant, no matter the size of the content.
  prefs: []
  type: TYPE_NORMAL
- en: Because Git gained a lot of popularity very quickly – and at this point, it
    is the de facto standard SCM in the software development world – everyone started
    integrating it into other tools, So, now, today, you can work with Git in practically
    every bit of developer tooling out there, some of which we’ll get to later in
    this chapter. It has a very large community and support system, so any time you
    run into problems with Git, you’ll have no problem getting help.
  prefs: []
  type: TYPE_NORMAL
- en: Git can be (relatively) simply used from the command line, and many developers
    will tell you that this is the *best* way to use Git. I’m not one of those developers.
    But I do think it’s where you should *start*, so that’s exactly what we’ll do
    now!
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Git
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: What we’re going to do here is add source control to the project from the previous
    chapter (more specifically, the SPA version in the `ch-03/2-spa` directory of
    the source code download you should already have by now). This allows you to begin
    making changes to the code and allows Git to track and manage those changes for
    you, providing you with all the benefits that SCM confers (such as being able
    to go back to previous versions later).
  prefs: []
  type: TYPE_NORMAL
- en: 'What you’ll want to do is start by making a copy of the project directory.
    Then, look for a `.git` directory inside of it:'
  prefs: []
  type: TYPE_NORMAL
- en: If you find it, go ahead and delete it
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you don’t see it, that’s okay – you’re good to go
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This directory is one that Git creates to store information it needs to do its
    job. If you got the source code for this book from GitHub, then it may have that
    directory. However, since what we’re going to do here will cause that directory
    to be created, you’ll want to make sure you start from a clean slate with no `.git`
    directory present.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once that’s done, go to a command prompt and enter this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Press *Enter* and ensure you get a response similar to `git version 2.42.0.windows.2`
    (the version may differ, and it won’t say `windows` if you’re on Mac or Linux,
    but you get the idea). So long as this happens, you’re good to go with Git.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, navigate to the copy of the project directory you created, and
    let’s get this thing under source control!
  prefs: []
  type: TYPE_NORMAL
- en: Using the most common Git commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Working with Git at a basic level – which most days is all you need – isn’t
    too tough and boils down to maybe a dozen common commands. Let’s run through those
    now by using one of the project directories from the previous chapter – let’s
    say the `ch-03/2-spa` one. Launch a command prompt and navigate to that directory
    now.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a new repository (or cloning an existing repository)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To set up a new repository, the first step is to tell Git that you want the
    current directory to be a Git repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see something like what’s shown in *Figure 4**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1: Initializing a Git repo](img/B18315_04_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: Initializing a Git repo'
  prefs: []
  type: TYPE_NORMAL
- en: Note that after executing the `git init` command, I listed the directory, but
    there was no `.git` directory visible, a directory that Git creates to store all
    its metadata about your repo. That’s because it’s hidden. So, to see it, you must
    execute `dir /a`. That confirms that Git did its thing, and we now have ourselves
    a repo.
  prefs: []
  type: TYPE_NORMAL
- en: Note for Linux and Mac users
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this book, because I am primarily a Windows user, I’ve written it
    largely Windows-centric. In most cases, what you would see and do on a Linux or
    Mac machine will be the same. But, in a few cases, things are different between
    Windows and Linux or Mac. An example is that while `dir /a` works in Windows,
    under Linux or Mac, you would instead use `ls -a`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, you may not always be starting a project and thus a repository.
    If you are starting work on someone else’s project, you would most likely do what’s
    called **cloning** their repo. This means copying their repo to your local machine.
    To do that, you use this command instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This gives you the same result as initializing a repo: the current directory
    becomes a Git repo, with a hidden `.``git` directory.'
  prefs: []
  type: TYPE_NORMAL
- en: The main difference between initializing and cloning an existing repo is that
    cloning also causes all the files in the repo to be copied into the current directory.
    However, when you start with an empty repo after initializing one, there are no
    files in the repo (even though they may be physically in the directory – Git isn’t
    aware of them yet though).
  prefs: []
  type: TYPE_NORMAL
- en: Adding files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Just creating a repo doesn’t do all that much. At this point, Git isn’t even
    aware of any of the files that are in the directory, or any you may add later.
    You have to tell Git about each file you want it to track. To do this, you can
    use the `git` `add` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, in our project, there should currently be four files: `index.html`,
    `index.js`, `package.json`, and `styles.css`. So, execute a `git add` command
    for each and execute the following four commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, just as an example of what happens if you use an incorrect name, enter
    this command as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should be like that shown in *Figure 4**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.2: Adding the files from our project, plus a mistake!](img/B18315_04_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.2: Adding the files from our project, plus a mistake!'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, I also attempted to add a file that doesn’t exist, and you can
    see that Git alerts us to that fact. Also, note the warning Git provides for the
    `package.json` file. You may not get this depending on your operating system,
    and either way, it shouldn’t make much difference to us, but it’s nice of Git
    to let us know what it’ll do.
  prefs: []
  type: TYPE_NORMAL
- en: In general, getting no error or warning means the command is successful. That’s
    a common pattern with Linux commands that you’ll want to keep in mind. Git is
    intrinsically tied to Linux development, as discussed earlier, so it makes sense
    that it would work this way.
  prefs: []
  type: TYPE_NORMAL
- en: Checking status
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To make sure Git is now aware of our files, we can ask it for the current status:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This command shows the status of changes. In *Figure 4**.3*, you can see that
    all four files are **to be committed**. This means they are in a special area
    of the Git repo called the **staging area**. Simply put, this is where changes
    that Git is aware of, but which haven’t yet been committed – meaning made a permanent
    part of the repo – are stored:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.3: The status, including what’s in the staging area](img/B18315_04_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.3: The status, including what’s in the staging area'
  prefs: []
  type: TYPE_NORMAL
- en: Committing changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'How do we move the changes from the staging area into the repo itself? That’s
    easy: we commit them!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Committing changes can be done with the `git` `commit` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'You must provide a message to go along with the commit, which should be some
    meaningful description of what the changes are. If you’re working on a new feature
    and this code implements it, then you’ll want to say something like “These changes
    implement the *X* change.” But it’s up to you – whatever makes sense. You might
    enter something like this, which I think is a sensible enough message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'In *Figure 4**.4*, you can see the result of that command:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.4: Committing our project files to the repo](img/B18315_04_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.4: Committing our project files to the repo'
  prefs: []
  type: TYPE_NORMAL
- en: You can also see that I executed `git status` again, and now there are no files
    in the staging area, as expected.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing the commit history
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To see a list of the commits that have occurred in your repo, execute the `git`
    `log` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This command shows the chronological commit history for the current branch.
    I’ll talk about branches shortly, but for now, you just need to know that Git
    creates a `master` branch by default, and unless you tell it otherwise, that’s
    where all your work will go. Note that `master` is sometimes named `main`, depending
    on what version of Git you’re using or what tools might be in play on top of Git.
    Whichever name you see, it means the same thing.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 4**.5*, you can see what the output of this command looks like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.5: The git log command in action](img/B18315_04_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.5: The git log command in action'
  prefs: []
  type: TYPE_NORMAL
- en: But what if you want to see what files were changed? By default, `git log` will
    just list the commits that occurred, along with the messages, date/time, and who
    committed it. But this is where another command, `git show`, comes into play.
    In *Figure 4**.5*, I execute it after the `git log` command, and there it shows
    me the list of files that were added to the repo as part of that commit. If you
    drop the `–name-only` option, it will show you the contents of each of those files
    too, along with what changed in them as part of that commit (obviously, when adding
    files as we did here, the *entire file* changed as far as Git was concerned, changed
    from not being in the repo to being in the repo).
  prefs: []
  type: TYPE_NORMAL
- en: By the way, what’s that `e0b60a5e` thing after the `–name-only` option? That’s
    a hash, which in this context is a unique identifier associated with the commit.
    More precisely, it’s the first 8 characters of the hash – you can see the full
    hash displayed after the word `commit` in the `git log` and `git show` output.
    8 characters are nearly always all you need to guarantee Git can find the unique
    hash (the reasons for that gets deep into cryptography and advanced mathematics,
    so you have to just take it on faith that it’s almost impossible for a hash for
    two commits to be the same), and it’s all we need to enter (though you *can* put
    the full hash if you’re masochistic!)
  prefs: []
  type: TYPE_NORMAL
- en: Removing files and restoring removed files
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If you can add files to a Git repo, then surely you can also remove them, and
    indeed you can! To remove a file, Git provides the `rm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As with adding a file, `git rm` only affects the staging area. To remove the
    file, you need to execute `git commit` again to make the change permanent in the
    repo.
  prefs: []
  type: TYPE_NORMAL
- en: 'But rather than just doing that, I want to show you something else important:
    restoring deleted files. In *Figure 4**.6*, I’ve deleted a file, but I’ve done
    a bit more after that as well (note that you should read this top to bottom, left
    to right, as this is all one continuous flow of events, but I had to split the
    screen capture in half to fit it all here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.6: Deleting and restoring a file](img/B18315_04_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.6: Deleting and restoring a file'
  prefs: []
  type: TYPE_NORMAL
- en: First, I listed the directory to see the files. Next, I executed the `git status`
    command to ensure there were no staged changes. After that, I removed the `styles.css`
    file with `git rm styles.css`, immediately listed the directory to confirm it
    was deleted, and then executed the `git status` command again to see that it was
    marked as deleted. At this point, the deletion is *staged*, but it hasn’t been
    permanently deleted from the repo yet.
  prefs: []
  type: TYPE_NORMAL
- en: 'Given that fact, there’s still time to save the file! First, we need to tell
    Git to ignore the deletion in the staging area. That’s done with the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'However, when you list the directory again, you will find that the file still
    isn’t present. We have to tell Git to physically restore the file now because
    the previous command only told it that we no longer want to delete it. So, executing
    the following command does the trick:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'But you can’t execute that until you execute the previous command with `–-staged`
    as an option. Git can get a little confusing at times to be sure, and most of
    that confusion comes about because of this sort of dual-commit procedure: first,
    you tell Git what changes you want to make (you stage them) and then you make
    the changes to the repo (you commit them).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Even if you commit the deletion, there are still ways to get the file back.
    You would have to use the `git log` command to look back through the history,
    find the version you want, and then use another command to restore it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This will bring the file back into your project, at which point you can re-commit
    it if you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a branch
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you work in Git, you will sometimes want to work on some code that may
    or may not ultimately make it into your repo. Maybe you’re experimenting and don’t
    want to risk messing up your good, working code. In such cases, you can create
    a new *branch*, which you can think of as a completely separate copy of all of
    your code in the repo. You give a branch a name, and by doing that, you can then
    switch between branches, which alters where your changes get stored (or in other
    words, which copy of the code is affected). Changes to one branch (copy of your
    code) won’t affect any other branch unless you specifically tell Git you want
    them to.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a branch, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This creates a new branch, leaving your `master` branch (the one Git creates
    and uses by default) just as it is. At this point, the branch is a copy of the
    branch you were working in before. This is `master` in our case since that’s the
    only branch we had.
  prefs: []
  type: TYPE_NORMAL
- en: Switching branches
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To ensure your changes go into the new branch, you must switch to it. You can
    switch to a branch at any point with a simple command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Now, any files you add and commit will go into the named branch. Any other branch,
    including `master`, will be unaffected. So, you can feel free to experiment all
    you like, assured that your previous code is safe and sound.
  prefs: []
  type: TYPE_NORMAL
- en: Merging
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Eventually, though, you’ll likely want the code from your experimental branch
    to be in your `master` branch, once you get it working right. That’s where merging
    comes in. Merging simply means taking changes from one place and putting them
    in another. In the case of Git, those places are branches.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you’re working in a branch you named `experiment`. You worked on
    that code for a while, got it working, and now you want to bring those changes
    into your `master` branch. You would first switch to the `master` branch, then
    execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Assuming `<branch>` was `experiment`, the changes from that branch will be merged
    into `master`. New files will be copied in, deleted files will be removed, and
    changes to existing files will be made in `master`. In the end, everything that
    was in the `experiment` branch, including all the history associated with all
    the commits you may have done, will be in `master` now too.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you wish, you can now delete the `experiment` branch since you no longer
    need it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: To be clear, while branching isn’t what I’d call an advanced topic – because
    it *is* pretty common – it is an entirely *optional* topic in that you never *have*
    to use branches. That’s why I haven’t shown examples of these commands – you can
    get into them if and when you need to.
  prefs: []
  type: TYPE_NORMAL
- en: When using Git, developers tend to adopt a specific *workflow*, meaning how
    they interact with Git and progress their work. And while some Git workflows heavily
    emphasize branching, others actively seek to avoid them. Some workflows dictate
    that *all* work should be done in small “feature” branches and then merged into
    `master`. Others say that work should be done in `master`, but then that each
    release should result in a new branch from `master`. Still, others say that `master`
    should be the only branch at all times and that **tags** – a Git feature that
    conceptually allows you to create a named copy of the repo at a given moment in
    time – is the way to go.
  prefs: []
  type: TYPE_NORMAL
- en: In any case, so long as you know what branches are – which you now do! – you
    should be prepared to deal with whatever workflow you encounter. And, when it’s
    just you working on a project, feel free to implement any workflow you like, or
    keep it simple and only deal with `master` at all times. You’ll still get the
    benefits of version control either way.
  prefs: []
  type: TYPE_NORMAL
- en: The last topic we need to discuss has to do with when you’re working with a
    remote repo.
  prefs: []
  type: TYPE_NORMAL
- en: Pushing and pulling changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: So far, you’ve only been dealing with a local repo, meaning it’s right there
    on your machine. This is good because it provides SCM and version tracking, but
    it doesn’t let others work on your code with you, nor does it protect you from
    hardware failures on your machine. To deal with both issues, you will often deal
    with a remote repo.
  prefs: []
  type: TYPE_NORMAL
- en: Fundamentally, a remote repo is no different than a local repo, it’s just that
    it’s accessible over a network. If you’ve been following along, then to some extent,
    you’ve already dealt with a remote repo when you grabbed a copy of the code for
    this book from GitHub. But you very likely only download a copy of the files in
    the repo, and it effectively is no longer a Git repo (if there’s no hidden `.git`
    directory, then that’s the case).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you work with a remote repo, whether you create it yourself or clone someone
    else’s, you have two new concepts to consider: pushing and pulling.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When you commit changes to your local repo, even if it’s a copy of someone
    else’s remote repo, it only affects your local copy. To get your committed changes
    into the remote repo, you must *push* the changes to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This command sends your committed changes to a remote repository. The `remote`
    value is the name of the remote repo, which more times than not will be the origin.
    The `branch` value is the branch from your local repo that you want to push changes
    from.
  prefs: []
  type: TYPE_NORMAL
- en: 'That’s good, but what about getting new changes from the remote repo? To get
    changes from the remote repo, you *pull* them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This command fetches and merges changes on the remote server to your working
    directory. As with push, the `remote` value will most often be the origin, and
    `branch` is what local branch in your repo you want the changes merged into.
  prefs: []
  type: TYPE_NORMAL
- en: 'With just these two commands, you can interact with a remote repository, allowing
    you and others to work on the code simultaneously. But where will that remote
    repo live? There are many options, including hosting it yourself, but one of the
    most popular is one you’ve already met: GitHub!'
  prefs: []
  type: TYPE_NORMAL
- en: GitHub – Git, but nice
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**GitHub** is to Git as a computer is to electricity. While it is the electricity
    – and Git – that do the actual work, you would probably prefer the experience
    of interacting with a computer – and GitHub! As you saw in the previous section,
    you can work with Git on a command line, but you may have noticed it isn’t the
    most pleasant experience. And believe me when I say that you’ve only seen the
    basics… it gets worse!'
  prefs: []
  type: TYPE_NORMAL
- en: But GitHub seeks to solve that problem by providing a much more user-friendly
    way to work with Git. GitHub, as you presumably saw when you accessed the code
    for this book, is a web-based platform where developers store and manage their
    projects, and optionally make them available to the world. It’s built on top of
    Git, and while Git handles the nitty-gritty of tracking changes to files in a
    project, GitHub provides a user-friendly interface to work with it, plus a lot
    of extra features, such as bug tracking, task management, social networking features
    for developers, and even hosting of projects such as websites (**GitHub Pages**,
    as it’s called). Think of Git as the engine under the hood, and GitHub as the
    car built around it, offering a more comfortable and feature-rich ride than the
    engine alone would (boy, the visual image of someone riding a car engine down
    the road is something, isn’t it?).
  prefs: []
  type: TYPE_NORMAL
- en: GitHub allows you to clone a repo, work on it locally, and then push changes
    to it (subject to privileges to do so, one of the added features it puts on top
    of Git). GitHub also offers **Actions**, which are bits of code the owner of a
    repo can set up to execute when various events occur. For example, there may be
    an Action to build the project whenever someone pushes to the repo, and then deploy
    a new version of the project, say a website, where it can be accessed by all.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub adds an issue tracker to repos so that users of your project can submit
    bug reports and you can track and manage progress on their resolution.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub provides an online code editing platform too, so you could work on a
    project entirely on GitHub itself if you wanted to. Many developers like their
    tools to be local on their machines, and they use GitHub as just a remote repository,
    but it can do a lot more if you so choose.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub even offers AI in the form of CoPilot. This is a feature that can provide
    real-time coding suggestions as you type, saving you time and maybe even solutions
    to problems you would have otherwise gotten stuck on. It does this by training
    the AI on repos in GitHub, so you in effect get the combined knowledge, wisdom,
    and experience of everyone else using GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: I could go on because GitHub is more than just a host of Git repos – it’s more
    like a central hub for developers to do their work. But the great thing about
    it is that you can dip a toe in at the start and then jump in completely later,
    or leave just the toe in. It’s entirely up to you how far into GitHub you go.
    And I should point out that there are alternatives to GitHub. But the simple truth
    is that GitHub is pretty much king. It is used by far more developers than any
    competitor out there. You’ll almost certainly deal with GitHub in some fashion
    as you continue your web developer journey, it’s just a question of to what extent.
  prefs: []
  type: TYPE_NORMAL
- en: I assume that you’ve downloaded the code for this book, which means you’ve already
    created a GitHub account. But if you haven’t, now is the time! Either way, I strongly
    suggest spending some time playing around on GitHub. I would suggest creating
    a repo, adding a file or two, and editing them, all on GitHub itself. Then, practice
    cloning the repo onto your local machine, edit and add files again, and then push
    to GitHub and see how the changes show up there. I think you’ll quickly see the
    value in GitHub and appreciate how it smooths some of the rough edges of Git in
    the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that you have an idea of how to manage source code with Git, let’s talk
    about a different topic, one that every developer has to keep in mind at all times
    as they code: security.'
  prefs: []
  type: TYPE_NORMAL
- en: Thinking like a hacker – securing the web
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating secure websites takes a lot of time, effort, and attention to detail
    across several layers. “Security-in-depth” is a common phrase that means you don’t
    just lock the door – you also have a security camera, a guard dog, and bars on
    the windows to keep your home safe. In the same way, writing secure code is part
    of it, as is ensuring your servers are “hardened” against attacks. This is an
    extremely expansive topic, and it has only grown in importance over the years.
    We’ve all certainly seen all the security breaches that have happened in recent
    years, and most of us have probably been personally impacted in some way. Unfortunately,
    this stuff ain’t easy to get right.
  prefs: []
  type: TYPE_NORMAL
- en: But it all starts with writing secure code, and to do that, you must have some
    knowledge of the types of things hackers – or *threat actors*, as we call them
    in professional circles – look for in your code to exploit. Well, they usually
    aren’t looking at your code per se; they’re looking at your website, trying to
    infer how your code is written, and then looking for weaknesses in it.
  prefs: []
  type: TYPE_NORMAL
- en: Common exploits
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The good news is that these days, exploits – weaknesses that a hacker can use
    to breach your security – by and large fall into a few broad categories.
  prefs: []
  type: TYPE_NORMAL
- en: SQL injection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Without knowing what SQL is, this one is hard to explain. But, to give you the
    crib notes version… SQL is a special language that allows you to get data out
    of a database. For example, if your database contains a list of checking accounts,
    you might get a list of them by executing the `select * from checking_accounts`
    SQL statement.
  prefs: []
  type: TYPE_NORMAL
- en: 'A **SQL injection** attack works on the premise of such statements in conjunction
    with the fact that developers don’t always code them safely. When they don’t,
    it allows a threat actor to modify those statements through clever values in forms.
    By doing so, they are then able to access data they shouldn’t be able to. Thankfully,
    this is an easy problem to avoid: it just requires developers to write code that
    uses SQL statements in a specific way.'
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site scripting (XSS)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'XSS is a technique threat actors use that allows them to inject malicious scripts
    (we’re talking about JavaScript here) into content viewed by other users, potentially
    stealing data, or impersonating users. This exploit is a great example of why
    security is so difficult: you may be thinking that this requires someone to be
    able to access your server to modify your code, but that’s not the case. Instead,
    clever usage of things such as email, where it’s often possible to embed links
    and other web content, allows someone to embed their malicious script, which can
    then launch a web browser to your legitimate site, with that script then able
    to do its dirty work as if it was part of your website.'
  prefs: []
  type: TYPE_NORMAL
- en: The main point here is that threat actors will often attack your website *indirectly*,
    in ways that won’t even initially make sense to you because they do things in
    ways that you never normally would. “Thinking like a hacker” requires you to have
    a good understanding of how things work on the web to then be able to connect
    things in ways they were never intended to get to an exploit, and sometimes, those
    connected things may be several steps removed from the target of the attack.
  prefs: []
  type: TYPE_NORMAL
- en: You can take steps to remove potentially dangerous content from anything sent
    to the server, and you can encode output in special ways so that even if something
    slips through, it won’t have the desired effect when it gets to the user’s browser.
    For example, when taking in data from the user, you can look for any instances
    of JavaScript keywords and strip them out, because that’s rarely something you
    want to allow in user input. You would need to do this on the server side to be
    safe, so you would run all user input through a cleansing function that looks
    for those keywords, or other potentially problematic strings such as `<script>`,
    and remove them. You would also want to do the same thing on the output side,
    meaning any data you send to the browser should similarly be cleansed just in
    case something slipped into your data through another means, such as a data load
    to your database (when this happens, it’s called a stored XSS attack because the
    malicious content somehow got stored and might have an effect when returned to
    the browser).
  prefs: []
  type: TYPE_NORMAL
- en: Cross-site request forgery (CSRF)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: CSRF is a way to trick a user’s browser into executing some unwanted action
    and it appearing to be a legitimate action from the user. This comes in several
    forms, with one of the more common ways being when a website uses a cookie – small
    pieces of information stored on a user’s browser – to identify that user. If someone
    can steal that cookie, they can effectively impersonate the legitimate user. Imagine
    stealing the cookie for a user’s banking site – a threat actor could transfer
    all the money out before the real user is aware of it.
  prefs: []
  type: TYPE_NORMAL
- en: Stealing cookies isn’t always as hard as it sounds if certain precautions aren’t
    taken (cookies have various security settings that developers should set properly
    to make them much more difficult to steal). Usage of a CSRF token is also common,
    which is a unique, random string that changes with each request. This way, even
    if someone steals your cookies, without the CSRF token, they wouldn’t be able
    to do anything. Other variations of CSRF require other mitigations, but it’s situation-specific.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to defenses for specific exploits like these, there are some basic
    coding practices you can use to help avoid security issues.
  prefs: []
  type: TYPE_NORMAL
- en: Secure coding practices
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you write code, you should keep a few key things in mind. Doing so will help
    you avoid not only the previously mentioned issues but a whole lot more.
  prefs: []
  type: TYPE_NORMAL
- en: Implement secure authentication
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should always implement strong password policies and use **multi-factor
    authentication** (**MFA**) to protect user accounts where possible. MFA means
    that a user must prove themselves through more than one factor, where a factor
    is something you are, something you know, and something you have. For example,
    logging into a site may require a username (who you are) a password (what you
    know), and perhaps a one-time code sent to your phone (something you have). While
    a threat actor managing to steal your password can happen (and your username isn’t
    generally considered sensitive in the first place), it’s unlikely they would also
    have your cell phone, so by requiring multiple factors, you’ve now defended that
    website.
  prefs: []
  type: TYPE_NORMAL
- en: Use encryption
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unless you have a very good reason not to, you should always use HTTPS so that
    the data that is transmitted between a browser and a server is encrypted. (The
    only good reason I can think of not to use HTTPS nowadays is when working on your
    machine during development since there is more configuration involved to use HTTPS
    than plain old HTTP that you simply may not want to deal with during development.)
  prefs: []
  type: TYPE_NORMAL
- en: This avoids a form of attack called **Man-in-the-Middle** (**MITM**). In such
    an attack, a threat actor might gain control of a router on the network that your
    data passes through when sent to the server. In that situation, they can view
    that data, which may well include your username and password, and if you don’t
    have MFA, they can then log in as you all they want. Encryption makes it so that
    all they’ll ever see is a stream of gibberish.
  prefs: []
  type: TYPE_NORMAL
- en: Handle errors properly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you write code, almost every language has ways that you can handle error
    conditions. This is important because when such errors occur, they can leak information
    about the underlying architecture of your website, or even allow a threat actor
    to sneak snippets of code that can then be executed in the context of your code.
    To avoid this, you should always ensure that error messages displayed to users
    give as little information as possible about your technology stack, and you should
    always try to use the error handling mechanisms your language of choice provides
    so that nothing can “slip out,” so to speak, that a threat actor can use against
    you.
  prefs: []
  type: TYPE_NORMAL
- en: Perform code reviews and do robust testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Regularly review code for vulnerabilities and perform security testing, including
    penetration testing and static code analysis.
  prefs: []
  type: TYPE_NORMAL
- en: Static code analysis tools look at your code without executing it and look for
    patterns that frequently denote security concerns. Static analysis can uncover
    other problems, not just security problems. It can find logic flaws that might
    result in bugs and can point out places where your code isn’t written to acceptable
    standards.
  prefs: []
  type: TYPE_NORMAL
- en: Penetration testing, usually abbreviated as pen testing, involves people (known
    as “white hat” hackers) actively trying to hack your website – with your approval,
    of course! They, try to find ways past your security by, for example, looking
    for clues about what technology you’re using and then searching for known vulnerabilities.
    They can also look for flaws in your code, based just on how it works, that allows
    them to breach your security.
  prefs: []
  type: TYPE_NORMAL
- en: Both of these are valuable because they point out things you may have missed
    yourself that you can then correct. Being proactive like this allows you to remediate
    these findings before the bad guys get in there and do bad guys things!
  prefs: []
  type: TYPE_NORMAL
- en: Implement the principle of least privilege
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is typically more at the operating system level than the code level, but
    sometimes, it does leak into the code level. Regardless, the idea is that you
    should only grant the permissions necessary to perform a task to a given user,
    reducing the potential impact of a breach if one should occur. Remember when we
    discussed the root user in Linux earlier? Well, if a threat actor can gain access
    as the root user, they have the keys to the kingdom – they can do anything. However,
    if they can only get into your server as a user who has limited access rights
    to files and directories, then even though they’ve breached your security, the
    damage they can do is limited.
  prefs: []
  type: TYPE_NORMAL
- en: Set security headers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Servers can set various headers on responses to browsers that are called **content
    security policy** (**CSP**) headers, as well as X-Frame-Options and Strict-Transport-Security
    headers. These tell the browser what they are allowed to do with the content the
    server returns. Properly configuring these headers can limit what a threat actor
    can do on your website, in some cases eliminating certain classes of exploits
    entirely (well, “entirely” is never a good thing to say when it comes to web security,
    but it certainly makes it much more challenging for the bad guys, which is essentially
    the overall goal to all of this – make it so difficult that it isn’t worth their
    time basically).
  prefs: []
  type: TYPE_NORMAL
- en: Do regular updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should almost always use the latest versions of things such as languages,
    libraries, and server software because they tend to have been patched against
    previously discovered security problems. New ones can always be discovered, so
    this is something that is an ongoing task.
  prefs: []
  type: TYPE_NORMAL
- en: Validate input
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When you get data from a client, you must always assume it contains security
    exploits. From the perspective of the server, a client is never to be trusted!
    So, we do things such as sanitizing input data, which means ensuring that all
    input data meets specific criteria to prevent malformed data from entering the
    system, this could lead to exploits. For example, if you have a form field that
    is for entering the user’s age, that’s intended to be a number. And, even if you
    have JavaScript on the page that ensures that’s the case, a threat actor has other
    ways to make that data not be a number. When the server gets it, if it assumes
    it’s a number – if it assumes the client is trusted – then non-numeric data can
    slip in, and there might be a way to use that to a threat actor’s benefit. Therefore,
    your server code *must* validate that what the client sent *is* a number as expected.
    Never, ever, ever trust the client! If you remember nothing else from this entire
    section, remember this, because it alone will help you avoid many, if not most,
    security exploits out there.
  prefs: []
  type: TYPE_NORMAL
- en: Encode output
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Imagine that you have a website that gets stock ticker values from a remote
    service. Further, imagine that you store that data in your database and show it
    to your users. Now, your website might be perfectly coded, so it sanitizes all
    the data it gets from the user. Hooray! But what about the data you get from that
    remote service? Did *they* do *their* job as well as *you* did? Maybe not!
  prefs: []
  type: TYPE_NORMAL
- en: In that case, you may wind up with malicious content in the form of JavaScript
    code stored in your database, and then when you render that JavaScript on your
    page, it can execute within the context of your page as if you had written it
    yourself, but doing the bidding of the bad guys. This is called a stored CSS attack
    because the malicious code was stored somewhere and snuck in “through the back
    door,” so to speak. To avoid this, you need to encode the data that is sent to
    your clients, removing certain content that can lead to exploits.
  prefs: []
  type: TYPE_NORMAL
- en: How this encoding is implemented varies greatly depending on many factors –
    far too many to detail here. But generally, it involves replacing certain characters
    or sequences of characters with others that are considered safe. Just as one example,
    if a user can submit data that contains the text `alert(1)` and it is saved in
    your database and is then later used on your page, that JavaScript code will execute
    as if you wrote it yourself. To deal with that, you may need to encode the `(`
    and `)` characters as `&#40;` and `&#41;`, respectively, which are special sequences
    that will ensure the code isn’t executed.
  prefs: []
  type: TYPE_NORMAL
- en: Securely manage configuration
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is common to need certain pieces of sensitive information in your code. For
    example, your code may need a username and password to connect to a database.
    If you embed this information in your code, then anyone who manages to see the
    code now has those credentials. This can be avoided by securely storing those
    credentials, usually in some special system specialized and designed for such
    sensitive information. Your code will then request the credentials from that system
    only when needed, and then they are only ever stored in the server’s memory for
    a short period.
  prefs: []
  type: TYPE_NORMAL
- en: Monitor file uploads
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If your application allows file uploads, ensure that they are scanned for malware
    and have strict controls on the types and sizes of files. If you are building
    a website where people can show others their photo albums, for example, you’ll
    want to implement code that ensures only graphics files are uploaded. Plus, you
    will probably want to have code that ensures no file greater than maybe 10 Mb
    is uploaded. This way, you can stop users from uploading, say, large executable
    files that could be malware through which to attack your server.
  prefs: []
  type: TYPE_NORMAL
- en: Secure data storage properly
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Something that comes up often is needing to store user credentials – usernames
    and passwords, most typically. You may think that storing them in a database on
    your server is safe, but that isn’t the case. Someone may be able to gain access
    to that database. And if you store it in a file instead of a database, then the
    same may be true.
  prefs: []
  type: TYPE_NORMAL
- en: 'No, you have to store that data securely. How would you do so in this case?
    You may think that you can encrypt the password and store that, right? **Encryption**
    is when we take a value and generate another value that looks like gibberish,
    but where that gibberish can be used to reproduce the original value given another
    value – the key – that was used to encrypt it. In other words, encryption is a
    two-way function: one way encrypts some data given a key value and the other way
    de-crypts it (turns it back into the original data) given the key.'
  prefs: []
  type: TYPE_NORMAL
- en: That seems safe, right? Even if someone gets your database, they’ll just see
    gibberish for the password (the username doesn’t typically need to be protected
    in any way). That’s true… unless they also get your encryption key! And that may
    not be very hard considering your code has to have the key to decrypt the password
    and see if what the user entered is correct.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, what you should do in this case is hash the password. Unlike encryption,
    which is two-way, `abc123` (not a good password, but work with me here!). If we
    hash that password, we might get a hash value of `z9x8`. So, we can never take
    `z9x8` and get `abc123` from it, but we’ll always get `z9x8` if we feed the hash
    function `abc123`.
  prefs: []
  type: TYPE_NORMAL
- en: This is useful because if we store `z9x8` in our database, it means that even
    if someone steals it, they can never get the real password. But our server code
    can still validate that user! All it has to do is take the password they enter
    when logging in and hash it. If the has value we get matches the hash value stored
    in the database, then we know they entered the right password.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between hashing and encrypting is something that developers often
    get wrong in my experience, and this scenario is a common one where knowing the
    difference is the difference between a secure login system versus one that isn’t.
  prefs: []
  type: TYPE_NORMAL
- en: By incorporating these (and other) practices, web developers can significantly
    reduce the attack surface – all the different paths through your security a threat
    actor might exploit – of web applications and defend against the ever-evolving
    landscape of cyber threats.
  prefs: []
  type: TYPE_NORMAL
- en: More on hashing
  prefs: []
  type: TYPE_NORMAL
- en: Hashes aren’t just for passwords and security. You saw them used earlier when
    discussing Git. Hashes there work the same way – the content of a commit is run
    through a hash function to generate the hash value – but in Git, it’s used not
    for security but for uniquely identifying a commit since a hash value would be
    unique to the content that was committed given that there is no other combination
    of characters that could result in the same hash value (strictly speaking, this
    isn’t 100% true, but the odds of two different input strings producing the same
    hash value – something we call a hash collision – is statistically so unlikely
    that we can say it’s true).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s switch gears a bit and talk about what in many cases will wind up
    being the development tool you deal with the most day-to-day: IDEs.'
  prefs: []
  type: TYPE_NORMAL
- en: Working all in one place – IDEs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 1*](B18315_01.xhtml#_idTextAnchor015), I showed you some very basic
    HTML and suggested that you enter it into a plain text editor such as Notepad
    if you’re using Windows. For a long time, that’s all there was – just plain text
    editors. After a while, they got more advanced. For example, some could recognize
    various programming languages and provide color coding to make them easier to
    digest, or they could recognize functions in something such as JavaScript and
    show you a list to the side. They started to become more than just plain text
    editors – in other words, they started to become aware of the *content* of the
    text.
  prefs: []
  type: TYPE_NORMAL
- en: 'Not long after that started to happen, a new evolution occurred: IDEs. These
    are pieces of software that provide comprehensive facilities to developers. You
    might almost say an IDE is a text editor that is *hyper*-aware of the text being
    edited. It understands what you’re doing and aids you in many ways. IDEs increase
    your productivity by combining most of the common activities involved in writing
    software into a single application. You stay in one place as you work and have
    everything you need at your fingertips rather than having to jump between several
    windows or interfaces to get your work done.'
  prefs: []
  type: TYPE_NORMAL
- en: 'An IDE typically includes the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Code editor*: I mean, obviously, right?! But it’s a text editor that’s specialized
    for writing and editing programming source code and typically includes features
    such as syntax highlighting, code formatting, and code navigation.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Compiler or interpreter*: Some programming languages need to be turned into
    other languages before they can be run. It sounds weird, but it’s true! This process
    is called *compilation*, and it’s done with a *compiler*. Languages that *can*
    be run exactly as they are use an *interpreter* instead. However, regardless of
    which is needed, it’s a tool you have to engage somehow, and usually, it’s a separate
    command-line interface. But with an IDE, it’s all built-in and controlled with
    the IDE interface, so you never have to leave it, which is a key benefit of an
    IDE.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugger*: A debugger is a tool that helps you test and debug your code by
    allowing things such as executing the code line by line, viewing the state of
    variables at any moment in time, or skipping sections of code so you can focus
    on specific areas. Any IDE worth its salt will have a solid debugger built into
    it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Build automation*: Once you’re done writing your code and have tested and
    debugged it, you usually need to create some sort of package that the underlying
    operating system or runtime environment will use when you want to distribute your
    app to others. This, we say, is when you “build and package” your app, and IDEs
    provide ways to automate this normally manual process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*SCM*: An IDE will almost certainly know how to work with Git and other SCM
    systems, and they will usually provide a more visual approach to using them. Some
    people greatly prefer this approach to the command line – I’m one of them – because
    it allows you to not have to remember a bunch of commands and options and instead
    work with your code and SCM more abstractly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Extensibility*: Any good IDE will have some mechanism to extend its capabilities,
    whether they’re called plugins, extensions, or something else. Through this, you
    can add support for new languages, or tools.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: IDEs come in all shapes and sizes. Some are free, some cost money, some are
    just good text editors with a few added capabilities, and some can do so much
    that they could seemingly pilot the space shuttle if you asked them to!
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following subsections, we’ll look at several of the most popular IDEs.
    As you read about them and look at the example screenshots, notice the similarities:
    they all, generally, have an area in the center for editing source code, surrounded
    by several small tool windows or areas. This is, generically, the point of an
    IDE: give you a solid, content-aware text editor at the cen[ter with context-aware
    tools](https://code.visualstudio.com) around it to help get your work done.'
  prefs: []
  type: TYPE_NORMAL
- en: VS Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: VS Code (https://code.visualstudio.com) may well be the most popular IDE today.
    It hails from Microsoft and is billed as a free, lightweight, cross-platform (meaning
    it can run on Windows, Mac, Linux, and even on the web itself!) source code editor
    with built-in support for JavaScript, TypeScript (we’ll get to this in later chapters),
    and Node. It is generally a pretty bare-bones IDE out of the box, but it is extremely
    extensible through a rich ecosystem of extensions for other languages, runtimes,
    tools, and technologies, so you can make it do just about anything you need.
  prefs: []
  type: TYPE_NORMAL
- en: Developers tend to like VS Code because it “gets out of their way.” Some people
    find some other IDEs to have a little *too* much capability, believe it or not!
    After all, at the end of the day, it all comes down to the code you’re writing,
    so an environment that takes space away from seeing your code is sometimes not
    what you want. VS Code, by default at least, does a good job of focusing on your
    code, but you can add to it later as you see fit.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.7* shows VS Code, though do note that this is my current setup,
    so you’re seeing more there than you’ll get by default since I’ve installed many
    extensions already (which you can tell by the number of icons on the left – by
    default, there would only be a few of those, but some of the extensions I’ve added
    also add icons there):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.7: VS Code](img/B18315_04_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.7: VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: With that said though, notice how there isn’t a lot around the code. There’s
    just the code, a project directory list on the left, and a command prompt on the
    right. And by default, the command prompt won’t even be shown. That’s what “gets
    out of your way” means, and you can contrast that to something such as Eclipse
    or IntelliJ IDEA when [I show them shortly since they sho](https://visualstudio.microsoft.com)w
    a bit more by default.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Visual Studio** (https://visualstudio.microsoft.com), in a sense, is the
    big brother of VS Code and also happens to be from Microsoft. It predates VS Code
    by many years (probably even decades at this point). Historically, Visual Studio
    has primarily been for working with Microsoft languages such as .NET and C#, but
    over the years, it has grown to encompass just about every technology out there,
    whether from Microsoft or not. Microsoft offers a slightly limited free community
    edition, and then a full-featured version that comes along with a paid subscription
    model (this can cost as low as around $500 and as high as around $6,000 at the
    time of writing).'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio used to be something of a joke in that it was very heavy, very
    slow, and tended to not be as stable as you want something you’re writing original
    code in. But that couldn’t be further from what it is today. Now, it’s a very
    highly respected and well-regarded IDE that lots of people swear by.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.8* shows what Visual Studio looks like. Unlike VS Code, I haven’t
    done a lot of customization to my Visual Studio installation, so a fresh install
    won’t look too much different than this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.8: Visual Studio](img/B18315_04_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.8: Visual Studio'
  prefs: []
  type: TYPE_NORMAL
- en: I mentioned that Visual Studio is something of the big brother to VS Code. What
    I mean by that is that Visual Studio includes more functionality, at least out
    of the box. It has more robust debugging facilities, can more seamlessly work
    with various types of servers, and can even be used to debug Windows-native applications
    in real-time. VS Code, since its inception, has narrowed that gap, especially
    when the right extensions [are installed, but Visual](https://www.eclipse.org/ide)
    Studio is still more feature-rich out of the box.
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Eclipse** (https://www.eclipse.org/ide) might be the most famous IDE out
    there. It’s a free (though donations are greatly appreciated!) and open-source
    IDE that has historically been primarily for Java development, but just like Visual
    Studio, it has grown over the years and now can do it all.'
  prefs: []
  type: TYPE_NORMAL
- en: Eclipse is rather old, though I don’t say that pejoratively, simply that it’s
    been around for a long, long time. Like Visual Studio, it wasn’t always as well-regarded
    as it is now. Over the years, its performance has improved significantly, as has
    the relative simplicity and coherence of its user interface, to a point now where
    a lot of people love Eclipse.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 4**.9* shows what Ec[lipse looks like in action:](https://www.jetbrains.com/idea)'
  prefs: []
  type: TYPE_NORMAL
- en: '[![Figure 4.9: Eclipse](img/B18315_04_9.jpg)](https://www.jetbrains.com/idea)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 4.9: Eclipse'
  prefs: []
  type: TYPE_NORMAL
- en: IntelliJ IDEA
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: IntelliJ IDEA (or simply IDEA) (https://www.jetbrains.com/idea) is an IDE by
    the company JetBrains. This is another IDE that started primarily for a specific
    technology – Java, in this case – but rapidly grew to be able to handle almost
    everything else. This is my personal favorite due to its excellent performance,
    stability, and extreme extensibility. JetBrains offers a free community edition,
    as well as a paid advanced version.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth noting that the community edition has a few more significant limitations
    as opposed to the others listed here, namely that web development is somewhat
    limited. Fortunately, the cost of a paid license isn’t all that much (as of this
    writing, it’s $169 for the first year, $135 for the second year, and then $101
    for each year after that for a license for an individual developer) and *for sure*
    it’s well worth that money for the power it puts in your hands. It is, of course,
    more for an organization ($599 per year), so it comes down to what kind of license
    you need.
  prefs: []
  type: TYPE_NORMAL
- en: 'In any case, *Figure 4**.10* reveals what IDEA looks like, at least in my case,
    with quite a few extensions active in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.10: IntelliJ IDEA](img/B18315_04_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.10: IntelliJ IDEA'
  prefs: []
  type: TYPE_NORMAL
- en: This is by no means an exhaustive list, but I think these four are probably
    the most popular at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s jump tracks and touch on another topic that you should be aware of,
    that being operating systems – more specifically, Linux.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the operating system – Linux
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So, you write your code, and you write it securely, and you get it under SCM.
    But what do you do when it comes time to deploy your code – that is, put it where
    it will run? There’s no singular answer to this question because how and where
    you can run your code is a question with myriad answers. But one thing is for
    sure: they’re all going to involve an operating system of some sort in some fashion.'
  prefs: []
  type: TYPE_NORMAL
- en: While Windows is, at the time of writing, still the world’s most popular desktop
    operating system, the story is very different when we talk about servers. While
    you will find a good number of Windows-based servers out there too, most servers
    run Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '**Linux** is an open-source operating system written and first released by
    Linus Torvalds in 1991\. The basic architecture of Linux is based on the Unix
    operating system, which was initially released way back in 1971, though it has
    a history – in a slightly different form – stretching back to the 1960s. Linux’s
    history is also the history of the internet in a sense as its use grew right alongside
    the internet. It became the backbone for server infrastructure, powering websites
    and online services due to its robustness and flexibility, and is also the poster
    child for the **free/open-source software** (**FOSS**) movement as easily the
    largest and most well-known open source project ever.'
  prefs: []
  type: TYPE_NORMAL
- en: Unix, and hence Linux, is stable, generally secure, and free, which makes it
    quite popular for many purposes. It is fundamentally based on principles of modularity
    and reusability, meaning it can be tweaked and reorganized with specific goals
    in mind. It is this quality that makes it flexible and gives rise to hundreds,
    if not thousands, of distributions – or *distros* – which are just variants of
    Linux, different collections of system libraries and tweaked kernels and such.
    Different distros have different focuses. Some are built as specifically as web
    servers; some are geared toward desktop machines; some have very small memory
    and hardware requirements making them ideal for small embedded systems; some are
    targeted to musicians; some are targeted to scientists… and so on.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s take a high-level look at some of the very basics of Linux, including
    its overall structure, some of the most common commands you might encounter, and
    the role of security in Linux.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of Linux
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The basic structure of Linux can be understood as a series of layers, one on
    top of the other. Starting from the lowest layer, we have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Kernel*: A piece of software that’s responsible for managing hardware resources
    primarily – things such as the CPU, memory, and peripheral devices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Filesystem*: Any operating system will need to include a filesystem – the
    structure of how information is stored on a storage device. Linux supports many
    different filesystems, but for the most part, it abstracts the differences away
    so that you can treat any filesystem the same as any other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Shell*: The interface that’s used by a user to interact with the kernel. In
    most cases, out of the box, this is a command line interface (and even for Linux
    distros that have a GUI, there is always a command line interface available as
    well).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Utilities*: Software tools for managing the system. These are just small programs,
    each with very small, explicit purposes – things such as creating users, managing
    files, viewing system resource usage, and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Applications*: User-level programs such as browsers and word processors.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linux distributions bundle the kernel with various software, both utilities
    and applications, to create complete operating systems. This software provides
    the basic commands you can execute at the Linux command line, which by default
    is how you interact with the operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Basic commands
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While there are hundreds of commands you can execute at a Linux command line,
    there is a much smaller set of commands you’ll use frequently. What that set of
    commands is will depend on what you’re doing, but some of the most important and
    most-used commands would certainly include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ls`: List directory contents'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cd` and `pwd`: Change directory (navigate the filesystem) and print working
    directory (tell you where you are on the filesystem)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`grep`: Search text in files'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`cp` and `mv`: Copy file or directory and move file or directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`rm`: Remove file or directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`sudo`: Execute a command as another user'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`mkdir`: Make a new directory in the current working directory'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`man`: View manual pages (instructions for various commands)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`chmod`: Change file and directory permissions'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`touch`: Create a new file or update the last accessed and modified date/time
    on an existing file'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ps` and `kill`: View information about the processes currently running on
    the system and stop (kill) them if needed'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`less` and `more`: Inspect the contents of a file (`more` is a simplistic application
    that offers fairly basic viewing features, whereas `less` offers more advanced
    features, such as two-way scrolling, robust searching, and more interactivity
    for the user)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This is in no way a comprehensive list, nor is it attempting to be. There are
    plenty more commands out there, and perhaps one of the best places to find them
    is the *Man Page* *Repository*: [https://www.unix.com/man-page-repository.php](https://www.unix.com/man-page-repository.php)).'
  prefs: []
  type: TYPE_NORMAL
- en: 'But, of all of them, `man` might be the one to remember most. That’s because
    it’s a command that can give you information about *other* commands! For example,
    if you forget what the syntax of the `cp` command is – syntax being the form and
    structure of the command and any information you might have to provide to it –
    you can simply execute `man cp` to get that information, as you can see in *Figure
    4**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.11: The output of executing man cp](img/B18315_04_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.11: The output of executing man cp'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see how you are provided with information about how to use the
    command, including a brief description of its purpose, some examples of its syntax,
    and the various options it supports. More is given for this command than you can
    see in a static image on the page, but when using `man` for real, you can continue
    to scroll through the documentation, which can be quite long for some commands,
    while rather short for others – it all depends on what the command is and everything
    it can do.
  prefs: []
  type: TYPE_NORMAL
- en: Security and the one “weird” Linux fact you need to know
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Linux is, at its core, very security-conscious. It is also at its core a multi-user
    system. Every file and directory is owned by a specific user and user group, and
    a user who doesn’t own a file or isn’t in an appropriate group cannot access it.
    Linux has a robust system of permissions, which is to say the various rights a
    user or group has for a file or directory. You can give users the right to read
    a file but not edit it, for example. The ability to run a file – assuming it’s
    a program of some sort – is its own right, meaning you might be able to read and
    edit a program file but not execute it.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions are hierarchical as well, meaning that you can be granted rights
    to a directory, which then filters down to the directories and files under it
    by default (though you can alter the rights for a specific file or subdirectory
    too). This allows for very granular control over access rights for various users,
    making it safe for them to work on the same system without risking conflicting
    with one another.
  prefs: []
  type: TYPE_NORMAL
- en: The one exception to all this security stuff is the special root user. This
    user is, in a sense, the god of the machine. The root user can do anything, to
    any file or directory, at any time. There is always a root user account, although
    sometimes, it may not be usable by any human user. This is necessary because some
    operations are so core to Linux itself that no other user *should* be able to
    do it. Or it should be very limited at the least. In such cases, Linux offers
    the ability to temporarily “switch” to the root user, meaning you can, as a regular
    old user, execute a specific command as if you were the root user, assuming you’ve
    been granted special rights to do that. This allows high-level system management
    tasks to be available to users as needed but in a very tightly controlled fashion.
  prefs: []
  type: TYPE_NORMAL
- en: I’ve mentioned files several times, and surely you know what files are because
    they’re no different from any other operating system, but Linux has one fact that
    is a little weird when you first encounter it – everything in Linux is a file.
    And when I say everything, I mean (almost) *everything*.
  prefs: []
  type: TYPE_NORMAL
- en: In Linux, “everything is a file” means that the operating system allows you
    to work with things that aren’t files the same way you do actual files. To put
    it another way, it’s the idea that Linux handles input and output to and from
    resources such as hard drives, modems, keyboards, printers, and other system resources
    and devices as streams of data exposed through the filesystem, as if they were
    files on that filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: The consequence of this is that not only can actual files be interacted with
    from the command line or other programs using file operations such as reading
    and writing, but so can directories, system information, hardware devices, and
    even some system processes. For example, accessing a device such as a printer
    might involve writing data to a file that represents the printer, which will cause
    the printer to physically print that data on a piece of paper. Or you might read
    from a file representing the system’s memory usage to see how much free memory
    you have. This design makes programming and resource management more uniform and
    simpler since you don’t need to use any special methods to deal with hardware
    devices and system resources, and you can use all the same commands and utilities
    as you would with regular files.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you have a (very) broad idea of what Linux is all about, let’s talk
    about why it’s even important to know about for a web developer.
  prefs: []
  type: TYPE_NORMAL
- en: Linux for web developers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Linux being so commonly used for servers, that means knowing Linux is a
    valuable thing for a web developer. Now, to be clear, there is knowing Linux and
    then there’s *knowing* Linux. A web developer probably doesn’t need to be a stone-cold
    Linux expert like, say, a server administrator does; those folks must have very
    deep knowledge of the system and how to work with it, and that simply takes a
    lot of time and experience. Certainly, as a web developer, the more you know the
    better, but you can start slowly with just some basics, and that’ll be sufficient
    so that you aren’t lost.
  prefs: []
  type: TYPE_NORMAL
- en: Fortunately, getting your feet wet with Linux is pretty easy. Several websites
    will let you run Linux in your browser or will connect you to a Linux instance
    on the server that you can then interact with through your browser. Either way,
    you’ll get a command-line interface right there in your browser, with no need
    to install Linux on your machine!
  prefs: []
  type: TYPE_NORMAL
- en: 'One good option for playing with Linux like this is [https://bellard.org/jslinux](https://bellard.org/jslinux).
    Here, you can choose from several distros and have them running in your browser,
    as you can see in *Figure 4**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.12: Alpine Linux running in your browser, courtesy of JavaScript/Linux](img/B18315_04_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.12: Alpine Linux running in your browser, courtesy of JavaScript/Linux'
  prefs: []
  type: TYPE_NORMAL
- en: 'I strongly suggest taking some time to play around here – it’s not like you
    can do any harm! To get you started with some basics, start by executing the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `cd` command stands for *change directory*. Here, you’re navigating to the
    **root directory**, which is the parent to all the others on the system.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see what’s in that directory, execute this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The `ls` command is short for *list*, as in *list directory contents*. Here,
    the `-lha` options each tell `ls` that you want the listing shown a specific way.
    The `l` option tells it you want a long listing, meaning it shows more details.
    The `h` option tells it you want all numbers shown in a more human-readable form
    (4k for a file size instead of 4,096, for example), and the `a` option tells it
    not to hide entries that begin with a period, which denotes hidden files and directories.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, navigate to your home directory, which is a directory every Linux user
    gets by default, with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The tilde character is a special one that Linux knows means you want to go to
    your home directory. Normally, when you use the `cd` command, you have to specify
    the full directory path, either starting from the root directory or the current
    directory. But navigating to your home directory is such a common thing that Linux
    provides this helpful shortcut.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the tilde isn’t the real directory path – it’s just a shortcut. To
    see the real path, use this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The `pwd` command stands for *print working directory*. The value you see will
    always be `/home/<your username>`. Your username will usually be determined by
    the administrator of the machine (in the case of one of the online Linux playgrounds,
    a user will almost certainly be created when Linux starts up). Of course, if you
    set Linux up yourself, then you will have chosen the username as part of the setup
    process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s create a file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Execute a directory listing again (and maybe this time just execute `ls` without
    any options to see the difference) and you’ll now see a new file named `my_file`.
    There are many ways to edit files in Linux and many ways to get content into a
    file, so let’s try perhaps the simplest way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The string in quotes will be written into the file (*echoed* to it). To see
    that it has, you can list the contents of the file like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The `cat` command is short for *concatenate*, but it also is used to print to
    the standard output, which is the screen where the command prompt itself is. So,
    `cat my_file` outputs the contents of the file to the screen, and you should see
    the string in quote in it when you do.
  prefs: []
  type: TYPE_NORMAL
- en: The last thing I’ll touch on is users and permissions. Earlier, I mentioned
    that every user of a Linux system gets a home directory. Every unique user on
    the system will not only have a home directory but a user account. Linux, and
    Unix, which it’s based on, is inherently a multi-user system, and it’s these user
    accounts – and the rights they have – that allow the system to be shared. No other
    user of the system is allowed to touch the contents of your home directory unless
    you specifically allow them to.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you list the directory contents again using the `-lha` option, one of the
    things you’ll see, in the second and third column of data, is the owner of the
    file and the primary group name, respectively. The meaning of the owner of the
    file should be obvious: it’ll be your *username*! Since you created the file,
    you own it and you can do whatever you like with it. However, anyone in the same
    user group, denoted by the third column, can also access the file.'
  prefs: []
  type: TYPE_NORMAL
- en: Groups are a way users can be organized in Linux for easier administration.
    When you create the file, the group may well be the same as your username. That
    simply means that on this particular Linux system, by default, a group is created
    for each user, named the same as the username. Since no one else will be in that
    group, it means that the file is truly only accessible by the user. In a way,
    it means that the group is irrelevant in this case.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to give ownership to another user, there’s a command for that:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The `chown` command stands for change owner. After executing it, you will no
    longer be able to access the file yourself since the username specified in the
    command will own it (you typically wouldn’t do this in your home directory, but
    you definitely can).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can’t allow a specific user the ability to edit your file, but what you
    can do is give anyone in the group the ability to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `chmod` command, short for *change mode*, means to change the access mode,
    or permissions, of something. This command can take a wide range of options in
    several forms, but in this example, `g+w` simply means to add (`+`) the write
    (`w`) permission to the primary group (`g`). After that, anyone in that group
    will be able to edit the file.
  prefs: []
  type: TYPE_NORMAL
- en: A couple of times now, I said that only you, by default, will be able to edit
    your file, but that’s not 100% true. You should also be aware that there is always
    a user named root on a Linux system. This is, in a sense, the god of the machine.
    The root user can do everything at all times and the root user account is meant
    for the administrator(s) of the machine.
  prefs: []
  type: TYPE_NORMAL
- en: However, even administrators will often log into the system as regular, non-root
    users, meaning they have no special privileges. This is an important security
    maxim known as the principle of least privilege. This means that a user should
    have the rights necessary to perform their duties, and no more. However, an administrator
    needs to have greater rights, so what they are allowed to do is *elevate* their
    privileges *temporarily*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To execute privileged commands, they have to use a special command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The `sudo` command stands for `super user do`, and it means “Hey, Linux, if
    I’m allowed, I want to execute this command as if I was the root user.” The system
    will maintain a list of commands that each user is allowed to execute with `sudo`,
    and doing so is the same as executing that command if they were logged in as root,
    but only for as long as it takes to execute the command. That’s the key. Note
    that you may not be able to experiment with `sudo` with an online Linux playground,
    but it’s an important concept to be aware of because even non-administrators will
    often have access to some degree of elevated privileges through `sudo`, and it’s
    commonly needed to get your work done on Linux.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we’ve covered the “non-code,” so to speak, topics for this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing the roadmap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'With this chapter concluded, we can now show a few more squares in our web
    developer roadmap:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.13: The roadmap, with a few more boxes filled in](img/B18315_04_13_NEW.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.13: The roadmap, with a few more boxes filled in'
  prefs: []
  type: TYPE_NORMAL
- en: Well now, that’s starting to fill out nicely, isn’t it? This chapter revealed
    the **Source Control**, **Security**, and **Linux** boxes. It also built on a
    few others, including networking and developer tooling. We’re moving right along!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched on several topics that are of large importance to
    web developers, but which aren’t explicitly about writing code. This included
    SCM – primarily in the form of Git, Linux, secure coding practices, and IDEs.
    You saw how SCM is a key component of your web development workflow, how IDEs
    can make your life a lot easier in that work, how thinking about security from
    the ground up when writing code is of paramount importance, and how Linux is the
    one operating system to rule them all, one operating system to find them, one
    operating system to bring them all and in the darkness bind them (sorry, I’m a
    geek – I couldn’t resist the cheap Lord of the Rings reference!).
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll continue looking at some things that continue the
    theme of this chapter – that is, topics that you’ll need to know about that may
    not directly be code (but of course, it’s *all* about the code in *some* fashion
    ultimately). This includes the famous term “the cloud,” virtual machines and containers,
    DevOps (whatever that is!), Python, graphic design, UX, and responsive design.
    Let’s keep pushing this boulder up the hill, shall we?
  prefs: []
  type: TYPE_NORMAL
