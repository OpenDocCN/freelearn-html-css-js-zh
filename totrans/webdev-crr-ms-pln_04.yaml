- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Managing, Securing, and Working with Code
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管理、安全和协作代码
- en: Over the last two chapters, we’ve spent a fair amount of time looking at actual
    code and getting you acclimated to the nuts and bolts, so to speak, of web development.
    It should be obvious that most of your time will likely be spent “twiddling bits,”
    as we software nerds like to say!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去的两章中，我们花了很多时间查看实际代码，让你熟悉网络开发的细节。很明显，你大部分的时间可能会花在“玩弄位元”，正如我们这些软件极客喜欢说的！
- en: But you’ve also seen that there is a lot more to it than just *writing* code.
    In this chapter, we’ll look at a few more of those “not writing code” things,
    including the idea of source control (how you keep track of the changes to your
    code), operating systems (Linux in particular), **integrated development environments**
    (**IDEs**) (tools that help you write code without leaving one consolidated application),
    security, and even one or two other languages that commonly come into play for
    web developers.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 但你也看到了，这不仅仅是*编写*代码那么简单。在本章中，我们将探讨更多“非编写代码”的事情，包括源控制（如何跟踪代码的变化）、操作系统（特别是 Linux）、**集成开发环境**（**IDE**）（帮助你在一个统一的应用程序中编写代码的工具）、安全，甚至一些常见的语言，这些语言对于网络开发者来说经常被用到。
- en: 'In this chapter, we’ll touch on the following “non-code,” so to speak, topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将简要介绍以下“非代码”主题：
- en: Controlling the code – source control management systems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制代码 - 版本控制系统
- en: Thinking like a hacker – securing the web
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 像黑客一样思考 - 保护网络
- en: Working all in one place – IDEs
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在一个地方完成所有工作 - 集成开发环境
- en: Understanding the operating system – Linux
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解操作系统 - Linux
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As in the previous chapter, I will assume you have already downloaded the source
    code for this book from GitHub, as outlined in the *Technical requirements* section
    of [*Chapter 2*](B18315_02.xhtml#_idTextAnchor061). For this chapter, we’ll again
    be dealing with the code in the `ch-03/2-spa` directory.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 就像上一章一样，我将假设你已经从 GitHub 下载了本书的源代码，正如在[*第二章*](B18315_02.xhtml#_idTextAnchor061)的“技术要求”部分中概述的那样。对于本章，我们还将处理
    `ch-03/2-spa` 目录中的代码。
- en: The other thing you’ll need to do is get Git installed. For that, head over
    to [https://git-scm.com](https://git-scm.com) and find the download package appropriate
    for your system. I will leave this as an exercise for you, but it’s nothing unusual,
    so I know you can handle it.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要做的一件事是安装 Git。为此，请访问 [https://git-scm.com](https://git-scm.com) 并找到适合您系统的下载包。我将把这留作你的练习，但没什么不寻常的，所以我知道你能处理它。
- en: Controlling the code – source control management systems
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制代码 - 版本控制系统
- en: 'Okay; so, you’ve spent a few hours hacking code – maybe you’ve built a nifty-keen
    little user registration page, for example. As someone in the mafia might say:
    it’d be a shame if something were to happen to that code, wouldn’t it? Surely
    there must be a way to protect your code, and indeed, there is: **source control**.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧；所以，你已经花了几小时编写代码——也许你构建了一个小巧的用户注册页面，例如。就像黑手党的人可能会说：如果代码出了问题，那真是太遗憾了，不是吗？当然，一定有保护你代码的方法，而且确实有：**版本控制**。
- en: Let me start by telling you how us old fogies used to do source control.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我先从告诉你我们这些老古董是如何做版本控制的开始。
- en: Every so often, we would create a new directory in our project directory and
    name it something like “HTML_complete_8-6-1991_1-30pm.” Then, we’d copy all the
    files from our project into it. We’d work on the project a little more, and maybe
    later we’d create another directory named “JS_complete_8-6-1991_4:30pm” and again
    copy all the project files into it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们会不时地在项目目录中创建一个新的目录，并给它起一个像“HTML_complete_8-6-1991_1-30pm”这样的名字。然后，我们会把项目中的所有文件复制到里面。我们会继续工作在项目上，也许稍后我们还会创建另一个名为“JS_complete_8-6-1991_4:30pm”的目录，再次将所有项目文件复制进去。
- en: Think that through for a moment. At the point I completed the HTML for the project,
    I essentially made a backup of the current state of all the files in my project.
    When the JavaScript was done, I made another copy. What I had was a history of
    the files in the project. Later, if I was working on the JavaScript and made a
    mistake and found it suddenly didn’t work, I could go back to one of those directories
    and compare the JavaScript to what it was when it last worked.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 想想看。在我完成项目的 HTML 代码时，我实际上备份了项目所有文件当前的状态。当 JavaScript 完成时，我又做了另一个副本。我所拥有的就是项目文件的历史记录。后来，如果我在处理
    JavaScript 时犯了一个错误，发现它突然不工作了，我可以回到那些目录之一，并将 JavaScript 与它最后一次工作时的状态进行比较。
- en: 'While it was ugly and completely manual, this was essentially a form of source
    control, or **version control** as it’s often called (for obvious reasons: each
    directory represents a past version of the code).'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这很丑陋且完全手动，但这本质上是一种源代码控制，或者通常称为**版本控制**（很明显的原因：每个目录代表代码的一个过去版本）。
- en: 'Further, we would frequently, often at the end of the day, copy all those directories
    onto some central server somewhere, one that was being properly backed up all
    the time. This provides a layer of protection: even if the hard drive in our computer
    were to die, we’d have a copy of our code on that server. We might lose some work
    if we were in the middle of coding and hadn’t created a new version directory
    recently, but it’s better than having lost everything. At least we could get back
    to the last saved version at worst.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们经常，通常在一天结束时，将所有这些目录复制到某个中央服务器上，一个始终得到适当备份的服务器。这提供了一层保护：即使我们的电脑硬盘损坏，我们也会在服务器上有一个代码副本。如果我们正在编码，并且最近没有创建新的版本目录，我们可能会丢失一些工作，但比丢失一切要好。至少在最坏的情况下，我们可以回到最后保存的版本。
- en: It’s a good system in that it provides history and some level of protection,
    but being so manual means it’s very prone to errors. Plus, it’s not all that robust.
    For example, if we need to compare a file to a previous version, how do we do
    that? Back then, it was as “simple” as “putting both files on the screen side-by-side,
    going through them, and trying to spot the changes.” That’s not a great approach.
    And then there are other things you might want to do, such as keep notes alongside
    the code about your progress. Sure, you could create a `notes.txt` file and save
    it, but again, it’s a manual process, and it also varies from developer to developer
    since no two will likely land on the same directory naming conventions and approaches.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 它是一个很好的系统，因为它提供了历史记录和一定程度的保护，但因为是手动操作，所以很容易出错。此外，它并不十分健壮。例如，如果我们需要将一个文件与之前的版本进行比较，我们该如何操作？当时，这“简单”到“将两个文件并排放置在屏幕上，逐个检查，试图找出变化。”这不是一个好的方法。然后还有其他你可能想要做的事情，比如在代码旁边记录你的进度。当然，你可以创建一个`notes.txt`文件并保存它，但同样，这也是一个手动过程，而且它因开发者而异，因为没有人会使用相同的目录命名约定和方法。
- en: 'Surely there must now, literally decades later, be a better answer, right?
    Indeed, there is: **source code** **management** (**SCM**).'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，现在，几十年后，肯定有更好的答案，对吧？确实如此：**源代码管理**（SCM）。
- en: Introducing SCM
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍SCM
- en: This is where SCM comes in. An SCM system, or version control system, as we
    say, is a piece of software that records changes to your project files over time,
    more or less automatically. SCM provides ways for you to review the history of
    your project, compare files, recall specific versions of files, attach notes to
    your changes, and more.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是软件配置管理（SCM）发挥作用的地方。我们所说的SCM系统，或者说版本控制系统，是一种软件，它会自动记录项目文件随时间的变化。SCM为你提供了查看项目历史、比较文件、召回特定版本的文件、为你的更改添加注释等功能。
- en: 'They also do something else that was difficult back in the ugly manual source
    control days: they allow multiple developers to work on the same code simultaneously.
    They do this by tracking the changes of each contributor and managing the process
    of **merging**. Merging is when you have two copies of a file with changes from
    two different people (usually – though it *could* be the same person), and you
    need to combine the changes into one canonical version of the file. When you’re
    a single developer working on a project, this is unlikely to ever come up, but
    it’s a crucial concern in software development when working on a team.'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 他们还做了在那些丑陋的手动源代码控制时代难以做到的事情：他们允许多个开发者同时处理同一份代码。他们通过跟踪每个贡献者的更改并管理合并过程来实现这一点。合并是指你有两个文件副本，分别来自两个人（通常是——尽管也可能是同一个人）的更改，你需要将这些更改合并成一个文件的规范版本。当你是一个单独的开发者在一个项目上工作时，这种情况不太可能发生，但在团队开发中，这是一个至关重要的关注点。
- en: SCM is considered a foundational tool in software development, meaning that
    in a professional environment, you’ll virtually always be using SCM. These days,
    it’s even unusual for a single developer to not use SCM since there is tremendous
    value in being able to go back in time, so to speak, and see what a file looked
    like at various points in time.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: SCM被认为是软件开发的基础工具，这意味着在一个专业环境中，你几乎总是使用SCM。如今，一个单独的开发者不使用SCM的情况甚至变得不寻常，因为能够回溯到过去，从某种意义上说，查看文件在各个时间点的样子，具有巨大的价值。
- en: 'SCM has a couple of key points to it:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: SCM有几个关键点：
- en: '*Version tracking*: SCM keeps a history of every change made to the files in
    a **repository**, or repo for short, which is another way to describe your project
    directory (it’s not *exactly* the same, but conceptually, that’s the way you can
    think of it for now). Not only does it keep a record of the file’s contents, but
    it also includes who changed it and when the changes were made, and it usually
    includes some sort of note about the change from the developer. This helps track
    the progress of your project, understand how the code base is evolving, and of
    course gives you a way to roll back changes.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*版本跟踪*：源代码管理（SCM）记录了存储库中每个文件所做的每个更改的历史，或简称为“repo”，这是描述你的项目目录的另一种方式（它并不完全相同，但从概念上讲，你现在可以这样思考）。它不仅记录了文件的内容，还包括了谁更改了它以及何时进行更改，通常还包括开发者对更改的一些注释。这有助于跟踪项目进度，了解代码库是如何演变的，当然也为你提供了一个回滚更改的方法。'
- en: '*Rollback*: This is simply the ability to retrieve a previous version of a
    file if problems are found (or if you just decide that subsequent changes can
    be thrown away).'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*回滚*：这仅仅是当发现问题（或者你只是决定后续的更改可以被丢弃）时，能够检索文件先前版本的能力。'
- en: '*Collaboration*: Multiple developers can work on the same code base simultaneously.
    An SCM system manages changes from different people and merges them, allowing
    for collaborative work without overwriting each other’s contributions.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*协作*：多个开发者可以同时在同一代码库上工作。源代码管理（SCM）系统管理来自不同人的更改并将它们合并，允许在没有覆盖彼此贡献的情况下进行协作工作。'
- en: '*Branching*: Sometimes, developers may need to work on something that is somewhat
    experimental. To avoid such experiments messing up the existing presumably good
    code, they can create a branch, which effectively is a copy of the project at
    the time the branch is created. The developer then does their work, saving their
    changes to that branch, all the while not touching the good code. Eventually,
    if the experiment proves fruitful, it can be merged into the good code, making
    it a permanent part of the main project code.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*分支*：有时，开发者可能需要做一些实验性的工作。为了避免这些实验破坏现有的可能良好的代码，他们可以创建一个分支，这实际上是在创建分支时项目的副本。然后开发者进行他们的工作，将更改保存到该分支，同时不触及良好代码。最终，如果实验证明是成功的，它可以合并到良好代码中，使其成为主项目代码的永久部分。'
- en: '*Conflict resolution*: When two copies of a file are merged, they may sometimes
    conflict – for example, if two developers change the same line of code. When that
    happens, the SCM can alert the developer attempting to merge the code that there
    is a conflict that they need to manually resolve (which usually means deciding
    which file the change should come from), and then completing the merge.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*冲突解决*：当两个文件的副本合并时，有时可能会发生冲突——例如，如果两个开发者修改了同一行代码。当这种情况发生时，源代码管理（SCM）可以提醒试图合并代码的开发者存在需要手动解决的冲突（通常意味着决定更改应该来自哪个文件），然后完成合并。'
- en: '*Safety*: SCM serves as a backup, of sorts. If project files become corrupt,
    they can be retrieved from the SCM system.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*安全性*：源代码管理（SCM）充当一种备份。如果项目文件损坏，可以从SCM系统中恢复。'
- en: Now that you know what SCM is, let’s talk about the options you have in SCM
    systems.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了什么是源代码管理（SCM），让我们来谈谈你在源代码管理系统中拥有的选项。
- en: Accepting the false choice – Git it is!
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接受错误的选择——Git 就是！
- en: 'Look, I’m just going to cut to the chase here: you almost don’t have a choice
    in what SCM system to use nowadays, it’s gonna be something called Git.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我就直接说重点了：现在你几乎在源代码管理（SCM）系统选择上没有选择，它将是一种叫做 Git 的东西。
- en: 'There are several SCM systems out there; names such as Mercurial, CVS, Subversion,
    Bitbucket, and Perforce are ones you may have heard of. But the simple truth is
    that the industry has almost entirely coalesced around Git, created by the same
    person who created the Linux operating system: Linus Torvalds. Git was built in
    2005 specifically for those working on the Linux kernel to be able to collaborate
    more easily.'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在市面上有几种源代码管理（SCM）系统；如 Mercurial、CVS、Subversion、Bitbucket 和 Perforce 等名字你可能听说过。但简单的事实是，整个行业几乎已经完全围绕
    Git 聚集，Git 是由创建了 Linux 操作系统的人创建的：林纳斯·托瓦兹。Git 是在 2005 年为那些在 Linux 内核上工作的人构建的，以便他们能够更容易地协作。
- en: Git is somewhat unique from many other SCM systems in that it is *distributed*.
    What this means is that every developer has a copy of an entire Git repository,
    including a full history of all changes. This is unusual in that most other SCMs
    are *centralized*, meaning there is one canonical copy of the code, plus all the
    history that goes along with it, and developers only get copies of the code on
    their machines to work on, and never the full history. The benefit of a distributed
    SCM is that they do not require a network connection to a central server all the
    time as a centralized SCM does (though it’s important to note that in *most* cases,
    even when you use Git, there *is* a centralized copy – it’s just that you don’t
    need to be constantly connected to it with Git like with other SCM systems).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: Git与其他许多SCM系统相比，有些独特之处在于它是*分布式的*。这意味着每个开发者都有一个Git仓库的完整副本，包括所有更改的完整历史记录。这在其他大多数SCM系统中是不寻常的，因为它们是*集中的*，意味着有一个代码的权威副本，以及与之相关的所有历史记录，开发者只能在他们的机器上获取代码副本来工作，而不会得到完整的历史记录。分布式SCM的好处是它们不需要像集中式SCM那样始终连接到中央服务器（尽管需要注意的是，在*大多数*情况下，即使使用Git，也存在一个集中副本——只是你不需要像使用其他SCM系统那样始终与之保持连接）。
- en: Git became popular for many reasons, but one of the big ones is speed and performance.
    With other SCMs, merging changes can sometimes take a fair bit of time. We’re
    not talking about hours here, but even a few seconds add up throughout a workday.
    Git is very optimized for speed from the ground up and most operations happen
    almost instantly. One of the key ways in which Git’s performance won over most
    developers is when it comes to branching. The way Git does branching is fundamentally
    different from most other SCM systems and is far more lightweight. While creating
    a branch in Subversion, for example, may take several seconds or even minutes
    if the content you’re branching from is large enough, with Git, it’s practically
    instant, no matter the size of the content.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Git因其许多原因而变得流行，但其中一个重要原因是速度和性能。与其他SCM相比，合并更改有时可能需要相当长的时间。我们这里不是在说几个小时，但即使在工作日中，几秒钟的累积也会产生影响。Git从一开始就非常优化速度，大多数操作几乎瞬间完成。Git性能赢得大多数开发者青睐的关键方式之一是分支。Git进行分支的方式在大多数其他SCM系统中是根本不同的，并且更加轻量。例如，在Subversion中创建分支可能需要几秒钟，甚至几分钟，如果分支的内容足够大，而Git，无论内容大小，几乎都是瞬间的。
- en: Because Git gained a lot of popularity very quickly – and at this point, it
    is the de facto standard SCM in the software development world – everyone started
    integrating it into other tools, So, now, today, you can work with Git in practically
    every bit of developer tooling out there, some of which we’ll get to later in
    this chapter. It has a very large community and support system, so any time you
    run into problems with Git, you’ll have no problem getting help.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 由于Git迅速获得了大量人气——并且到目前为止，它是软件开发界的既定标准SCM——每个人都开始将其集成到其他工具中。因此，现在，今天，你几乎可以在所有开发者工具中使用Git，其中一些我们将在本章后面讨论。它有一个非常大的社区和支持系统，所以无论何时你在Git中遇到问题，你都不会有问题获得帮助。
- en: Git can be (relatively) simply used from the command line, and many developers
    will tell you that this is the *best* way to use Git. I’m not one of those developers.
    But I do think it’s where you should *start*, so that’s exactly what we’ll do
    now!
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: Git可以从命令行（相对）简单地使用，许多开发者会告诉你这是使用Git的*最佳*方式。我不是那些开发者之一。但我确实认为你应该从这里*开始*，所以这正是我们现在要做的！
- en: Getting started with Git
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用Git
- en: What we’re going to do here is add source control to the project from the previous
    chapter (more specifically, the SPA version in the `ch-03/2-spa` directory of
    the source code download you should already have by now). This allows you to begin
    making changes to the code and allows Git to track and manage those changes for
    you, providing you with all the benefits that SCM confers (such as being able
    to go back to previous versions later).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里要做的，是将上一章的项目（更具体地说，是源代码下载中`ch-03/2-spa`目录下的SPA版本）添加源代码控制。这允许你开始对代码进行修改，并让Git为你跟踪和管理这些更改，为你提供所有SCM（源代码管理）带来的好处（例如，以后能够回退到之前的版本）。
- en: 'What you’ll want to do is start by making a copy of the project directory.
    Then, look for a `.git` directory inside of it:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要做的第一件事是复制项目目录。然后，在其内部查找`.git`目录：
- en: If you find it, go ahead and delete it
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你找到了，就继续删除它
- en: If you don’t see it, that’s okay – you’re good to go
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你没有看到它，那没关系——你可以继续进行
- en: This directory is one that Git creates to store information it needs to do its
    job. If you got the source code for this book from GitHub, then it may have that
    directory. However, since what we’re going to do here will cause that directory
    to be created, you’ll want to make sure you start from a clean slate with no `.git`
    directory present.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 这个目录是 Git 创建的用于存储它执行工作所需信息的目录。如果您从 GitHub 获取了这本书的源代码，那么它可能包含那个目录。然而，由于我们在这里要执行的操作将导致创建该目录，您需要确保您从一个没有任何
    `.git` 目录的干净状态开始。
- en: 'Once that’s done, go to a command prompt and enter this command:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，转到命令提示符并输入以下命令：
- en: '[PRE0]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Press *Enter* and ensure you get a response similar to `git version 2.42.0.windows.2`
    (the version may differ, and it won’t say `windows` if you’re on Mac or Linux,
    but you get the idea). So long as this happens, you’re good to go with Git.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 按*Enter*键并确保您得到一个类似于`git version 2.42.0.windows.2`（版本可能不同，如果您在 Mac 或 Linux 上，则不会显示`windows`，但您应该明白这个意思）。只要发生这种情况，您就可以使用
    Git 了。
- en: At this point, navigate to the copy of the project directory you created, and
    let’s get this thing under source control!
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 到此为止，导航到您创建的项目目录的副本，让我们将这个项目置于源代码控制之下！
- en: Using the most common Git commands
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用最常用的 Git 命令
- en: Working with Git at a basic level – which most days is all you need – isn’t
    too tough and boils down to maybe a dozen common commands. Let’s run through those
    now by using one of the project directories from the previous chapter – let’s
    say the `ch-03/2-spa` one. Launch a command prompt and navigate to that directory
    now.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在基本级别上使用 Git（这在大多数日子里都是您所需要的）并不太困难，并且归结为可能是一打常见的命令。现在，让我们通过使用上一章中的一个项目目录——比如说
    `ch-03/2-spa` 目录——来运行这些命令。现在启动命令提示符并导航到该目录。
- en: Setting up a new repository (or cloning an existing repository)
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置新仓库（或克隆现有仓库）
- en: 'To set up a new repository, the first step is to tell Git that you want the
    current directory to be a Git repository:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 要设置新仓库，第一步是告诉 Git 您希望当前目录成为一个 Git 仓库：
- en: '[PRE1]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'You should see something like what’s shown in *Figure 4**.1*:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到类似于*图 4.1*1*所示的内容：
- en: '![Figure 4.1: Initializing a Git repo](img/B18315_04_1.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.1：初始化 Git 仓库](img/B18315_04_1.jpg)'
- en: 'Figure 4.1: Initializing a Git repo'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.1：初始化 Git 仓库
- en: Note that after executing the `git init` command, I listed the directory, but
    there was no `.git` directory visible, a directory that Git creates to store all
    its metadata about your repo. That’s because it’s hidden. So, to see it, you must
    execute `dir /a`. That confirms that Git did its thing, and we now have ourselves
    a repo.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在执行 `git init` 命令后，我列出了目录，但没有看到可见的 `.git` 目录，这是 Git 创建的用于存储有关您仓库的所有元数据的目录。这是因为它是隐藏的。因此，要查看它，您必须执行
    `dir /a`。这确认了 Git 已经完成了它的工作，我们现在有一个仓库了。
- en: Note for Linux and Mac users
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 和 Mac 用户注意事项
- en: Throughout this book, because I am primarily a Windows user, I’ve written it
    largely Windows-centric. In most cases, what you would see and do on a Linux or
    Mac machine will be the same. But, in a few cases, things are different between
    Windows and Linux or Mac. An example is that while `dir /a` works in Windows,
    under Linux or Mac, you would instead use `ls -a`.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书的整个过程中，因为我主要是一个 Windows 用户，所以我主要写了以 Windows 为中心的书籍。在大多数情况下，您在 Linux 或 Mac
    机器上看到和做的将是一样的。但是，在少数情况下，Windows 和 Linux 或 Mac 之间会有所不同。一个例子是，虽然 `dir /a` 在 Windows
    上有效，但在 Linux 或 Mac 下，您将使用 `ls -a` 代替。
- en: 'Of course, you may not always be starting a project and thus a repository.
    If you are starting work on someone else’s project, you would most likely do what’s
    called **cloning** their repo. This means copying their repo to your local machine.
    To do that, you use this command instead:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，您可能并不总是从开始一个项目和相应的仓库。如果您开始处理别人的项目，您很可能会做被称为**克隆**他们仓库的事情。这意味着将他们的仓库复制到您的本地机器上。为此，您可以使用这个命令代替：
- en: '[PRE2]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'This gives you the same result as initializing a repo: the current directory
    becomes a Git repo, with a hidden `.``git` directory.'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为您初始化仓库的结果相同：当前目录变成一个 Git 仓库，并包含一个隐藏的 `.git` 目录。
- en: The main difference between initializing and cloning an existing repo is that
    cloning also causes all the files in the repo to be copied into the current directory.
    However, when you start with an empty repo after initializing one, there are no
    files in the repo (even though they may be physically in the directory – Git isn’t
    aware of them yet though).
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化现有仓库和克隆现有仓库之间的主要区别在于，克隆还会将仓库中的所有文件复制到当前目录中。然而，在初始化一个空仓库后，仓库中没有任何文件（尽管它们可能物理上存在于目录中——但
    Git 还没有意识到它们）。
- en: Adding files
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加文件
- en: 'Just creating a repo doesn’t do all that much. At this point, Git isn’t even
    aware of any of the files that are in the directory, or any you may add later.
    You have to tell Git about each file you want it to track. To do this, you can
    use the `git` `add` command:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 仅创建一个仓库并没有做什么。在这个阶段，Git 甚至还没有意识到目录中的任何文件，或者你可能稍后添加的任何文件。你必须告诉 Git 你想要它跟踪的每个文件。为此，你可以使用
    `git` `add` 命令：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For example, in our project, there should currently be four files: `index.html`,
    `index.js`, `package.json`, and `styles.css`. So, execute a `git add` command
    for each and execute the following four commands:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在我们的项目中，目前应该有四个文件：`index.html`、`index.js`、`package.json` 和 `styles.css`。因此，为每个文件执行
    `git add` 命令，并执行以下四个命令：
- en: '[PRE4]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Also, just as an example of what happens if you use an incorrect name, enter
    this command as well:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，仅作为一个例子，如果你使用了一个错误的名字，输入以下命令：
- en: '[PRE5]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The output should be like that shown in *Figure 4**.2*:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 输出应该像*图 4*.2*中所示：
- en: '![Figure 4.2: Adding the files from our project, plus a mistake!](img/B18315_04_2.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.2：添加项目文件，加上一个错误！](img/B18315_04_2.jpg)'
- en: 'Figure 4.2: Adding the files from our project, plus a mistake!'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.2：添加项目文件，加上一个错误！
- en: As you can see, I also attempted to add a file that doesn’t exist, and you can
    see that Git alerts us to that fact. Also, note the warning Git provides for the
    `package.json` file. You may not get this depending on your operating system,
    and either way, it shouldn’t make much difference to us, but it’s nice of Git
    to let us know what it’ll do.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我也尝试添加了一个不存在的文件，你可以看到 Git 提醒我们这一点。此外，请注意 Git 为 `package.json` 文件提供的警告。这取决于你的操作系统，无论如何，这不应该对我们有很大影响，但
    Git 让我们知道它将做什么是很好的。
- en: In general, getting no error or warning means the command is successful. That’s
    a common pattern with Linux commands that you’ll want to keep in mind. Git is
    intrinsically tied to Linux development, as discussed earlier, so it makes sense
    that it would work this way.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，没有错误或警告意味着命令成功。这是 Linux 命令中常见的模式，你需要记住这一点。Git 与 Linux 开发内在相关，如前所述，因此它以这种方式工作是有意义的。
- en: Checking status
  id: totrans-77
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查状态
- en: 'To make sure Git is now aware of our files, we can ask it for the current status:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 Git 现在知道我们的文件，我们可以要求它提供当前状态：
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This command shows the status of changes. In *Figure 4**.3*, you can see that
    all four files are **to be committed**. This means they are in a special area
    of the Git repo called the **staging area**. Simply put, this is where changes
    that Git is aware of, but which haven’t yet been committed – meaning made a permanent
    part of the repo – are stored:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令显示更改的状态。在*图 4*.3*中，你可以看到所有四个文件都**需要提交**。这意味着它们位于 Git 仓库的一个特殊区域，称为**暂存区**。简单来说，这就是
    Git 已知的更改，但尚未提交——也就是说，尚未成为仓库的永久部分——存储的地方：
- en: '![Figure 4.3: The status, including what’s in the staging area](img/B18315_04_3.jpg)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.3：状态，包括暂存区的内容](img/B18315_04_3.jpg)'
- en: 'Figure 4.3: The status, including what’s in the staging area'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：状态，包括暂存区的内容
- en: Committing changes
  id: totrans-83
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提交更改
- en: 'How do we move the changes from the staging area into the repo itself? That’s
    easy: we commit them!'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们如何将更改从暂存区移动到仓库本身？这很简单：我们提交它们！
- en: 'Committing changes can be done with the `git` `commit` command:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 提交更改可以使用 `git` `commit` 命令：
- en: '[PRE7]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'You must provide a message to go along with the commit, which should be some
    meaningful description of what the changes are. If you’re working on a new feature
    and this code implements it, then you’ll want to say something like “These changes
    implement the *X* change.” But it’s up to you – whatever makes sense. You might
    enter something like this, which I think is a sensible enough message:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 你必须提供一条与提交一起的消息，这应该是对更改的一些有意义的描述。如果你正在开发一个新功能，并且此代码实现了它，那么你可能想说“这些更改实现了 *X*
    变更。”但由你决定—— whatever makes sense. 你可能会输入如下内容，我认为这是一个足够合理的消息：
- en: '[PRE8]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In *Figure 4**.4*, you can see the result of that command:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 4*.4*中，你可以看到该命令的结果：
- en: '![Figure 4.4: Committing our project files to the repo](img/B18315_04_4.jpg)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4：将我们的项目文件提交到仓库](img/B18315_04_4.jpg)'
- en: 'Figure 4.4: Committing our project files to the repo'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：将我们的项目文件提交到仓库
- en: You can also see that I executed `git status` again, and now there are no files
    in the staging area, as expected.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以看到我再次执行了 `git status`，现在暂存区中没有文件，正如预期的那样。
- en: Viewing the commit history
  id: totrans-93
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 查看提交历史
- en: 'To see a list of the commits that have occurred in your repo, execute the `git`
    `log` command:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看你仓库中发生的提交列表，执行 `git` `log` 命令：
- en: '[PRE9]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: This command shows the chronological commit history for the current branch.
    I’ll talk about branches shortly, but for now, you just need to know that Git
    creates a `master` branch by default, and unless you tell it otherwise, that’s
    where all your work will go. Note that `master` is sometimes named `main`, depending
    on what version of Git you’re using or what tools might be in play on top of Git.
    Whichever name you see, it means the same thing.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令显示当前分支的按时间顺序的提交历史。我很快会谈到分支，但现在您只需要知道Git默认创建一个`master`分支，除非您告诉它否则，所有的工作都会放在那里。请注意，`master`有时被称为`main`，这取决于您使用的Git版本或可能覆盖Git的工具。无论您看到哪个名称，它都意味着相同的意思。
- en: 'In *Figure 4**.5*, you can see what the output of this command looks like:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在**图 4**.5*中，您可以查看该命令的输出结果：
- en: '![Figure 4.5: The git log command in action](img/B18315_04_5.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5：git log 命令的实际操作](img/B18315_04_5.jpg)'
- en: 'Figure 4.5: The git log command in action'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：git log 命令的实际操作
- en: But what if you want to see what files were changed? By default, `git log` will
    just list the commits that occurred, along with the messages, date/time, and who
    committed it. But this is where another command, `git show`, comes into play.
    In *Figure 4**.5*, I execute it after the `git log` command, and there it shows
    me the list of files that were added to the repo as part of that commit. If you
    drop the `–name-only` option, it will show you the contents of each of those files
    too, along with what changed in them as part of that commit (obviously, when adding
    files as we did here, the *entire file* changed as far as Git was concerned, changed
    from not being in the repo to being in the repo).
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果您想查看哪些文件被更改了呢？默认情况下，`git log`只会列出发生的提交，包括消息、日期/时间和谁提交了它。但这就是另一个命令`git show`发挥作用的地方。在**图
    4**.5*中，我在执行`git log`命令之后执行了它，那里显示了我作为那次提交的一部分添加到仓库中的文件列表。如果您省略了`–name-only`选项，它还会显示那些文件的每个内容，以及作为那次提交的一部分它们的变化（显然，当我们添加文件时，从不在仓库中到在仓库中，从Git的角度来看，整个文件都发生了变化）。
- en: By the way, what’s that `e0b60a5e` thing after the `–name-only` option? That’s
    a hash, which in this context is a unique identifier associated with the commit.
    More precisely, it’s the first 8 characters of the hash – you can see the full
    hash displayed after the word `commit` in the `git log` and `git show` output.
    8 characters are nearly always all you need to guarantee Git can find the unique
    hash (the reasons for that gets deep into cryptography and advanced mathematics,
    so you have to just take it on faith that it’s almost impossible for a hash for
    two commits to be the same), and it’s all we need to enter (though you *can* put
    the full hash if you’re masochistic!)
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便问一下，`–name-only`选项后面的那个`e0b60a5e`是什么东西？那是一个哈希值，在这个上下文中，它是与提交相关联的唯一标识符。更确切地说，它是哈希值的前8个字符——您可以在`git
    log`和`git show`输出的`commit`词后面看到完整的哈希值。8个字符几乎总是足够保证Git可以找到唯一的哈希值（原因涉及到密码学和高级数学，所以您必须相信这是几乎不可能的，两个提交的哈希值相同），这是我们需要的所有内容（尽管如果您愿意，您可以输入完整的哈希值）！
- en: Removing files and restoring removed files
  id: totrans-102
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 删除文件和恢复已删除的文件
- en: 'If you can add files to a Git repo, then surely you can also remove them, and
    indeed you can! To remove a file, Git provides the `rm` command:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您可以向Git仓库添加文件，那么当然您也可以删除它们，而且确实可以！要删除文件，Git提供了`rm`命令：
- en: '[PRE10]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As with adding a file, `git rm` only affects the staging area. To remove the
    file, you need to execute `git commit` again to make the change permanent in the
    repo.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与添加文件一样，`git rm`只影响暂存区。要删除文件，您需要再次执行`git commit`以使更改在仓库中永久化。
- en: 'But rather than just doing that, I want to show you something else important:
    restoring deleted files. In *Figure 4**.6*, I’ve deleted a file, but I’ve done
    a bit more after that as well (note that you should read this top to bottom, left
    to right, as this is all one continuous flow of events, but I had to split the
    screen capture in half to fit it all here):'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 但而不仅仅是这样做，我想向您展示另一个重要的东西：恢复已删除的文件。在**图 4**.6*中，我已经删除了一个文件，但在那之后我还做了一些其他的事情（注意，您应该从上到下、从左到右阅读，因为这是一系列连续的事件，但我不得不将屏幕截图分成两半以适应这里）：
- en: '![Figure 4.6: Deleting and restoring a file](img/B18315_04_6.jpg)'
  id: totrans-107
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6：删除和恢复文件](img/B18315_04_6.jpg)'
- en: 'Figure 4.6: Deleting and restoring a file'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：删除和恢复文件
- en: First, I listed the directory to see the files. Next, I executed the `git status`
    command to ensure there were no staged changes. After that, I removed the `styles.css`
    file with `git rm styles.css`, immediately listed the directory to confirm it
    was deleted, and then executed the `git status` command again to see that it was
    marked as deleted. At this point, the deletion is *staged*, but it hasn’t been
    permanently deleted from the repo yet.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我列出了目录以查看文件。接下来，我执行了`git status`命令以确保没有暂存更改。然后，我使用`git rm styles.css`删除了`styles.css`文件，立即列出目录以确认它已被删除，然后再次执行`git
    status`命令以查看它已被标记为已删除。在这个时候，删除操作是*暂存的*，但它还没有从仓库中永久删除。
- en: 'Given that fact, there’s still time to save the file! First, we need to tell
    Git to ignore the deletion in the staging area. That’s done with the following
    command:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个事实，还有时间保存文件！首先，我们需要告诉Git忽略暂存区的删除操作。这可以通过以下命令完成：
- en: '[PRE11]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'However, when you list the directory again, you will find that the file still
    isn’t present. We have to tell Git to physically restore the file now because
    the previous command only told it that we no longer want to delete it. So, executing
    the following command does the trick:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当你再次列出目录时，你会发现文件仍然不存在。我们必须现在告诉Git物理恢复文件，因为之前的命令只是告诉它我们不再想删除它。所以，执行以下命令就能解决问题：
- en: '[PRE12]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'But you can’t execute that until you execute the previous command with `–-staged`
    as an option. Git can get a little confusing at times to be sure, and most of
    that confusion comes about because of this sort of dual-commit procedure: first,
    you tell Git what changes you want to make (you stage them) and then you make
    the changes to the repo (you commit them).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 但你必须先执行带有`–-staged`选项的上一条命令。Git有时可能会有些令人困惑，确实如此，大部分的困惑都源于这种双重提交过程：首先，你告诉Git你想要做出的更改（你将它们暂存），然后你对仓库做出更改（你提交它们）。
- en: 'Even if you commit the deletion, there are still ways to get the file back.
    You would have to use the `git log` command to look back through the history,
    find the version you want, and then use another command to restore it:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 即使你提交了删除操作，仍然有方法恢复文件。你必须使用`git log`命令回顾历史，找到你想要的版本，然后使用另一个命令来恢复它：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This will bring the file back into your project, at which point you can re-commit
    it if you wish.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把文件恢复到你的项目中，此时你可以根据需要重新提交它。
- en: Creating a branch
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建分支
- en: When you work in Git, you will sometimes want to work on some code that may
    or may not ultimately make it into your repo. Maybe you’re experimenting and don’t
    want to risk messing up your good, working code. In such cases, you can create
    a new *branch*, which you can think of as a completely separate copy of all of
    your code in the repo. You give a branch a name, and by doing that, you can then
    switch between branches, which alters where your changes get stored (or in other
    words, which copy of the code is affected). Changes to one branch (copy of your
    code) won’t affect any other branch unless you specifically tell Git you want
    them to.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在Git中工作时，你有时会想要工作在可能或可能不会最终进入你的仓库的某些代码上。也许你正在实验，不想冒破坏你良好、有效代码的风险。在这种情况下，你可以创建一个新的*分支*，你可以将其视为仓库中所有代码的完全独立的副本。你给分支起一个名字，然后通过这样做，你可以切换到不同的分支，这会改变你的更改存储的位置（或者换句话说，哪个代码副本受到影响）。一个分支（你的代码副本）的更改不会影响任何其他分支，除非你明确告诉Git你想让它们影响。
- en: 'To create a branch, use this command:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建分支，使用以下命令：
- en: '[PRE14]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This creates a new branch, leaving your `master` branch (the one Git creates
    and uses by default) just as it is. At this point, the branch is a copy of the
    branch you were working in before. This is `master` in our case since that’s the
    only branch we had.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这将创建一个新的分支，而你的`master`分支（Git默认创建并使用的分支）保持原样。在这个时候，分支是你之前正在工作的分支的副本。在我们的例子中，这是`master`分支，因为我们只有一个分支。
- en: Switching branches
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换分支
- en: 'To ensure your changes go into the new branch, you must switch to it. You can
    switch to a branch at any point with a simple command:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保你的更改进入新分支，你必须切换到它。你可以在任何时间点通过简单的命令来切换到分支：
- en: '[PRE15]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Now, any files you add and commit will go into the named branch. Any other branch,
    including `master`, will be unaffected. So, you can feel free to experiment all
    you like, assured that your previous code is safe and sound.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你添加和提交的任何文件都将进入命名的分支。包括`master`在内的任何其他分支都不会受到影响。所以，你可以自由地实验，确信你之前的代码是安全可靠的。
- en: Merging
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 合并
- en: Eventually, though, you’ll likely want the code from your experimental branch
    to be in your `master` branch, once you get it working right. That’s where merging
    comes in. Merging simply means taking changes from one place and putting them
    in another. In the case of Git, those places are branches.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，最终，一旦你的实验分支工作正常，你可能会想要将代码从你的实验分支推送到 `master` 分支。这就是合并的作用。合并简单地说就是从一个地方取走更改并将其放入另一个地方。在
    Git 的情况下，这些地方是分支。
- en: 'Let’s say you’re working in a branch you named `experiment`. You worked on
    that code for a while, got it working, and now you want to bring those changes
    into your `master` branch. You would first switch to the `master` branch, then
    execute this command:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你在一个名为 `experiment` 的分支上工作。你在这段代码上工作了一段时间，使其工作正常，现在你想要将这些更改合并到你的 `master`
    分支中。你首先切换到 `master` 分支，然后执行以下命令：
- en: '[PRE16]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Assuming `<branch>` was `experiment`, the changes from that branch will be merged
    into `master`. New files will be copied in, deleted files will be removed, and
    changes to existing files will be made in `master`. In the end, everything that
    was in the `experiment` branch, including all the history associated with all
    the commits you may have done, will be in `master` now too.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 假设 `<branch>` 是 `experiment`，那么该分支的更改将被合并到 `master`。新文件将被复制进来，已删除的文件将被移除，现有文件的更改将在
    `master` 中进行。最终，`experiment` 分支中的所有内容，包括所有与你可能做的所有提交相关的历史记录，现在也将出现在 `master` 中。
- en: 'If you wish, you can now delete the `experiment` branch since you no longer
    need it:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你愿意，你现在可以删除 `experiment` 分支，因为你不再需要它：
- en: '[PRE17]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: To be clear, while branching isn’t what I’d call an advanced topic – because
    it *is* pretty common – it is an entirely *optional* topic in that you never *have*
    to use branches. That’s why I haven’t shown examples of these commands – you can
    get into them if and when you need to.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了明确起见，虽然分支不是我会称之为高级主题的东西——因为它确实很常见——但它是一个完全**可选**的主题，你永远**不必**使用分支。这就是为什么我没有展示这些命令的例子——如果你需要，你可以了解它们。
- en: When using Git, developers tend to adopt a specific *workflow*, meaning how
    they interact with Git and progress their work. And while some Git workflows heavily
    emphasize branching, others actively seek to avoid them. Some workflows dictate
    that *all* work should be done in small “feature” branches and then merged into
    `master`. Others say that work should be done in `master`, but then that each
    release should result in a new branch from `master`. Still, others say that `master`
    should be the only branch at all times and that **tags** – a Git feature that
    conceptually allows you to create a named copy of the repo at a given moment in
    time – is the way to go.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用 Git 时，开发者倾向于采用一种特定的**工作流程**，这意味着他们如何与 Git 交互并推进工作。虽然一些 Git 工作流程非常强调分支，但其他工作流程则积极避免使用分支。一些工作流程规定所有工作都应该在小的“功能”分支上完成，然后合并到
    `master`。另一些则说工作应该在 `master` 上完成，但每个发布都应该从 `master` 创建一个新的分支。还有一些工作流程说 `master`
    应该始终是唯一的分支，而**标签**——Git 的一个功能，在概念上允许你在给定的时间点创建仓库的命名副本——是前进的方式。
- en: In any case, so long as you know what branches are – which you now do! – you
    should be prepared to deal with whatever workflow you encounter. And, when it’s
    just you working on a project, feel free to implement any workflow you like, or
    keep it simple and only deal with `master` at all times. You’ll still get the
    benefits of version control either way.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，只要你知道什么是分支——你现在知道了！——你应该准备好处理你遇到的任何工作流程。而且，当你独自在一个项目上工作时，你可以自由地实施任何你喜欢的流程，或者保持简单，始终只处理
    `master`。无论如何，你都会得到版本控制的好处。
- en: The last topic we need to discuss has to do with when you’re working with a
    remote repo.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要讨论的最后一个话题与你在使用远程仓库时的情况有关。
- en: Pushing and pulling changes
  id: totrans-138
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 推送和拉取更改
- en: So far, you’ve only been dealing with a local repo, meaning it’s right there
    on your machine. This is good because it provides SCM and version tracking, but
    it doesn’t let others work on your code with you, nor does it protect you from
    hardware failures on your machine. To deal with both issues, you will often deal
    with a remote repo.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你只处理了本地仓库，这意味着它就在你的机器上。这是好事，因为它提供了版本控制和跟踪，但它不允许其他人与你一起工作，也不能保护你免受机器硬件故障的影响。为了处理这两个问题，你通常会处理远程仓库。
- en: Fundamentally, a remote repo is no different than a local repo, it’s just that
    it’s accessible over a network. If you’ve been following along, then to some extent,
    you’ve already dealt with a remote repo when you grabbed a copy of the code for
    this book from GitHub. But you very likely only download a copy of the files in
    the repo, and it effectively is no longer a Git repo (if there’s no hidden `.git`
    directory, then that’s the case).
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，远程仓库与本地仓库没有区别，只是它可以通过网络访问。如果你一直在跟随，那么在某种程度上，当你从GitHub获取这本书的代码副本时，你已经处理了一个远程仓库。但你很可能只下载了仓库中的文件副本，它实际上已经不再是一个Git仓库（如果没有隐藏的`.git`目录，那就是这种情况）。
- en: 'When you work with a remote repo, whether you create it yourself or clone someone
    else’s, you have two new concepts to consider: pushing and pulling.'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 当你与远程仓库一起工作时，无论你是自己创建它还是克隆别人的，你都需要考虑两个新的概念：推送和拉取。
- en: 'When you commit changes to your local repo, even if it’s a copy of someone
    else’s remote repo, it only affects your local copy. To get your committed changes
    into the remote repo, you must *push* the changes to it:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当你对你本地的仓库进行更改时，即使它是别人远程仓库的副本，这也只会影响你的本地副本。要将你的提交更改推送到远程仓库，你必须将更改**推送到**它：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This command sends your committed changes to a remote repository. The `remote`
    value is the name of the remote repo, which more times than not will be the origin.
    The `branch` value is the branch from your local repo that you want to push changes
    from.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将你的提交更改发送到远程仓库。`remote`值是远程仓库的名称，通常情况下会是`origin`。`branch`值是你想要从本地仓库中推送到远程仓库的分支。
- en: 'That’s good, but what about getting new changes from the remote repo? To get
    changes from the remote repo, you *pull* them:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但如何从远程仓库获取新的更改呢？要从远程仓库获取更改，你需要**拉取**它们：
- en: '[PRE19]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This command fetches and merges changes on the remote server to your working
    directory. As with push, the `remote` value will most often be the origin, and
    `branch` is what local branch in your repo you want the changes merged into.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个命令将远程服务器上的更改合并到你的工作目录中。与推送类似，`remote`值通常会是`origin`，而`branch`是你想要将更改合并到本地仓库中的哪个分支。
- en: 'With just these two commands, you can interact with a remote repository, allowing
    you and others to work on the code simultaneously. But where will that remote
    repo live? There are many options, including hosting it yourself, but one of the
    most popular is one you’ve already met: GitHub!'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 只需要这两个命令，你就可以与远程仓库交互，允许你和他人同时工作在代码上。但那个远程仓库会住在哪里呢？有很多选择，包括自己托管，但最受欢迎的一个你已经见过：GitHub！
- en: GitHub – Git, but nice
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub – Git，但更友好
- en: '**GitHub** is to Git as a computer is to electricity. While it is the electricity
    – and Git – that do the actual work, you would probably prefer the experience
    of interacting with a computer – and GitHub! As you saw in the previous section,
    you can work with Git on a command line, but you may have noticed it isn’t the
    most pleasant experience. And believe me when I say that you’ve only seen the
    basics… it gets worse!'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '**GitHub**对于Git来说，就像电脑对于电力一样。虽然电力和Git是实际工作的，但你可能更愿意与电脑和GitHub交互！正如你在上一节中看到的，你可以在命令行上使用Git，但你可能已经注意到这不是最愉快的体验。而且请相信我，你看到的只是基础……它会变得更糟！'
- en: But GitHub seeks to solve that problem by providing a much more user-friendly
    way to work with Git. GitHub, as you presumably saw when you accessed the code
    for this book, is a web-based platform where developers store and manage their
    projects, and optionally make them available to the world. It’s built on top of
    Git, and while Git handles the nitty-gritty of tracking changes to files in a
    project, GitHub provides a user-friendly interface to work with it, plus a lot
    of extra features, such as bug tracking, task management, social networking features
    for developers, and even hosting of projects such as websites (**GitHub Pages**,
    as it’s called). Think of Git as the engine under the hood, and GitHub as the
    car built around it, offering a more comfortable and feature-rich ride than the
    engine alone would (boy, the visual image of someone riding a car engine down
    the road is something, isn’t it?).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 但 GitHub 通过提供一种更用户友好的方式来与 Git 一起工作来解决这一问题。GitHub，正如你访问这本书的代码时可能看到的那样，是一个基于网络的平台，开发者在这里存储和管理他们的项目，并且可以选择将其提供给全世界。它是建立在
    Git 之上的，虽然 Git 负责跟踪项目中文件变更的繁琐细节，但 GitHub 提供了一个用户友好的界面来与之交互，以及许多额外功能，例如错误跟踪、任务管理、为开发者提供的社会化网络功能，甚至可以托管项目，如网站（称为
    **GitHub Pages**）。将 Git 想象为引擎盖下的引擎，GitHub 则是围绕它构建的汽车，比单独的引擎提供更舒适和功能丰富的驾驶体验（哇，想象一下有人在路上骑着汽车引擎的画面，是不是很有趣？）。
- en: GitHub allows you to clone a repo, work on it locally, and then push changes
    to it (subject to privileges to do so, one of the added features it puts on top
    of Git). GitHub also offers **Actions**, which are bits of code the owner of a
    repo can set up to execute when various events occur. For example, there may be
    an Action to build the project whenever someone pushes to the repo, and then deploy
    a new version of the project, say a website, where it can be accessed by all.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 允许你克隆一个仓库，在本地工作，然后将更改推送到它（前提是你有权限这样做，这是它在 Git 之上添加的附加功能之一）。GitHub 还提供
    **Actions**，这是仓库所有者可以设置在发生各种事件时执行的代码片段。例如，可能有一个动作在有人向仓库推送时构建项目，然后部署项目的新的版本，比如一个网站，所有人都可以访问。
- en: GitHub adds an issue tracker to repos so that users of your project can submit
    bug reports and you can track and manage progress on their resolution.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 为仓库添加了一个问题跟踪器，这样你的项目的用户就可以提交错误报告，而你也可以跟踪和管理他们解决问题的进度。
- en: GitHub provides an online code editing platform too, so you could work on a
    project entirely on GitHub itself if you wanted to. Many developers like their
    tools to be local on their machines, and they use GitHub as just a remote repository,
    but it can do a lot more if you so choose.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 还提供了一个在线代码编辑平台，所以如果你想的话，可以在 GitHub 上完全完成一个项目。许多开发者喜欢他们的工具在本地机器上，他们只是将
    GitHub 用作远程仓库，但如果你选择，它可以做更多的事情。
- en: GitHub even offers AI in the form of CoPilot. This is a feature that can provide
    real-time coding suggestions as you type, saving you time and maybe even solutions
    to problems you would have otherwise gotten stuck on. It does this by training
    the AI on repos in GitHub, so you in effect get the combined knowledge, wisdom,
    and experience of everyone else using GitHub.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub 甚至提供 AI 功能，即 CoPilot。这是一个可以在你键入时提供实时编码建议的功能，为你节省时间，甚至可能解决你原本可能会卡住的问题。它是通过在
    GitHub 上的仓库上训练 AI 来实现的，因此你实际上获得了使用 GitHub 的每个人的综合知识、智慧和经验。
- en: I could go on because GitHub is more than just a host of Git repos – it’s more
    like a central hub for developers to do their work. But the great thing about
    it is that you can dip a toe in at the start and then jump in completely later,
    or leave just the toe in. It’s entirely up to you how far into GitHub you go.
    And I should point out that there are alternatives to GitHub. But the simple truth
    is that GitHub is pretty much king. It is used by far more developers than any
    competitor out there. You’ll almost certainly deal with GitHub in some fashion
    as you continue your web developer journey, it’s just a question of to what extent.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以继续说，因为 GitHub 不仅仅是一个 Git 仓库的托管者——它更像是一个开发者工作的中心枢纽。但它的好处在于，你可以从开始时浅尝辄止，然后完全投入其中，或者只留下脚趾头。你完全可以根据自己的意愿决定在
    GitHub 中走多远。我还应该指出，GitHub 有替代品。但简单的事实是，GitHub 几乎是王者。它被比任何竞争对手都要多的开发者使用。在你继续你的网络开发者旅程的过程中，你几乎肯定会以某种方式与
    GitHub 打交道，这只是一个程度的问题。
- en: I assume that you’ve downloaded the code for this book, which means you’ve already
    created a GitHub account. But if you haven’t, now is the time! Either way, I strongly
    suggest spending some time playing around on GitHub. I would suggest creating
    a repo, adding a file or two, and editing them, all on GitHub itself. Then, practice
    cloning the repo onto your local machine, edit and add files again, and then push
    to GitHub and see how the changes show up there. I think you’ll quickly see the
    value in GitHub and appreciate how it smooths some of the rough edges of Git in
    the process.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设你已经下载了这本书的代码，这意味着你已经创建了一个GitHub账户。但如果你还没有，现在就是时候了！无论如何，我强烈建议你花些时间在GitHub上玩玩。我会建议创建一个仓库，添加一个或两个文件，并在GitHub上本身编辑它们。然后，练习在本地机器上克隆仓库，再次编辑和添加文件，然后将更改推送到GitHub，看看这些更改是如何显示在那里的。我认为你很快就会看到GitHub的价值，并欣赏它在过程中如何使Git的一些粗糙边缘变得平滑。
- en: 'Now that you have an idea of how to manage source code with Git, let’s talk
    about a different topic, one that every developer has to keep in mind at all times
    as they code: security.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用Git管理源代码，让我们谈谈一个不同的主题，这是每个开发者编码时都必须时刻牢记的主题：安全。
- en: Thinking like a hacker – securing the web
  id: totrans-159
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以黑客的思维思考——保护网络
- en: Creating secure websites takes a lot of time, effort, and attention to detail
    across several layers. “Security-in-depth” is a common phrase that means you don’t
    just lock the door – you also have a security camera, a guard dog, and bars on
    the windows to keep your home safe. In the same way, writing secure code is part
    of it, as is ensuring your servers are “hardened” against attacks. This is an
    extremely expansive topic, and it has only grown in importance over the years.
    We’ve all certainly seen all the security breaches that have happened in recent
    years, and most of us have probably been personally impacted in some way. Unfortunately,
    this stuff ain’t easy to get right.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 创建安全的网站需要大量的时间、精力和对多个层面的细致关注。“深度安全”是一个常见的短语，意味着你不仅仅是要锁上门——你还需要一个安全摄像头、一只看门狗和窗户上的栅栏来保护你的家。同样，编写安全的代码也是其中的一部分，确保你的服务器能够抵御攻击。这是一个极其广泛的话题，而且它在过去几年中变得越来越重要。我们确实都看到了近年来发生的所有安全漏洞，我们中的大多数人可能以某种方式受到了个人影响。不幸的是，这些东西并不容易做对。
- en: But it all starts with writing secure code, and to do that, you must have some
    knowledge of the types of things hackers – or *threat actors*, as we call them
    in professional circles – look for in your code to exploit. Well, they usually
    aren’t looking at your code per se; they’re looking at your website, trying to
    infer how your code is written, and then looking for weaknesses in it.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 但一切始于编写安全的代码，而要做到这一点，你必须了解黑客——或者我们专业人士称之为“威胁行为者”——在代码中寻找以利用的某些类型的事物。好吧，他们通常不是在查看你的代码本身；他们是在查看你的网站，试图推断你的代码是如何编写的，然后寻找其中的弱点。
- en: Common exploits
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 常见漏洞
- en: The good news is that these days, exploits – weaknesses that a hacker can use
    to breach your security – by and large fall into a few broad categories.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 好消息是，如今，利用——黑客可以利用来突破你安全性的弱点——基本上可以分为几个广泛的类别。
- en: SQL injection
  id: totrans-164
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL注入
- en: Without knowing what SQL is, this one is hard to explain. But, to give you the
    crib notes version… SQL is a special language that allows you to get data out
    of a database. For example, if your database contains a list of checking accounts,
    you might get a list of them by executing the `select * from checking_accounts`
    SQL statement.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不了解SQL是什么，这很难解释。但是，为了给你一个简略版……SQL是一种特殊语言，允许你从数据库中获取数据。例如，如果你的数据库包含一个支票账户列表，你可能会通过执行`select
    * from checking_accounts` SQL语句来获取这些账户的列表。
- en: 'A **SQL injection** attack works on the premise of such statements in conjunction
    with the fact that developers don’t always code them safely. When they don’t,
    it allows a threat actor to modify those statements through clever values in forms.
    By doing so, they are then able to access data they shouldn’t be able to. Thankfully,
    this is an easy problem to avoid: it just requires developers to write code that
    uses SQL statements in a specific way.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: '**SQL注入**攻击基于这样的语句，以及开发者并不总是安全地编写它们的现实。当他们不这样做时，它允许威胁行为者通过表单中的巧妙值来修改这些语句。通过这样做，他们就能够访问他们不应该能够访问的数据。幸运的是，这是一个容易避免的问题：只需要开发者编写以特定方式使用SQL语句的代码。'
- en: Cross-site scripting (XSS)
  id: totrans-167
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站脚本（XSS）
- en: 'XSS is a technique threat actors use that allows them to inject malicious scripts
    (we’re talking about JavaScript here) into content viewed by other users, potentially
    stealing data, or impersonating users. This exploit is a great example of why
    security is so difficult: you may be thinking that this requires someone to be
    able to access your server to modify your code, but that’s not the case. Instead,
    clever usage of things such as email, where it’s often possible to embed links
    and other web content, allows someone to embed their malicious script, which can
    then launch a web browser to your legitimate site, with that script then able
    to do its dirty work as if it was part of your website.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: XSS 是攻击者使用的一种技术，允许他们将恶意脚本（我们这里指的是JavaScript）注入其他用户查看的内容中，可能窃取数据或冒充用户。这个漏洞是一个很好的例子，说明了为什么安全性如此困难：您可能认为这需要有人能够访问您的服务器来修改您的代码，但事实并非如此。相反，通过巧妙地使用电子邮件（在电子邮件中通常可以嵌入链接和其他网络内容），允许某人嵌入他们的恶意脚本，然后可以启动一个网络浏览器访问您的合法网站，该脚本随后能够像它属于您的网站一样执行其恶意行为。
- en: The main point here is that threat actors will often attack your website *indirectly*,
    in ways that won’t even initially make sense to you because they do things in
    ways that you never normally would. “Thinking like a hacker” requires you to have
    a good understanding of how things work on the web to then be able to connect
    things in ways they were never intended to get to an exploit, and sometimes, those
    connected things may be several steps removed from the target of the attack.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的主要观点是，攻击者通常会间接地攻击您的网站，以您最初甚至都不理解的方式。 “像黑客一样思考”需要您对网络上的事物有良好的理解，然后才能以他们从未打算达到漏洞的方式连接事物，有时，这些连接的事物可能距离攻击目标有数步之遥。
- en: You can take steps to remove potentially dangerous content from anything sent
    to the server, and you can encode output in special ways so that even if something
    slips through, it won’t have the desired effect when it gets to the user’s browser.
    For example, when taking in data from the user, you can look for any instances
    of JavaScript keywords and strip them out, because that’s rarely something you
    want to allow in user input. You would need to do this on the server side to be
    safe, so you would run all user input through a cleansing function that looks
    for those keywords, or other potentially problematic strings such as `<script>`,
    and remove them. You would also want to do the same thing on the output side,
    meaning any data you send to the browser should similarly be cleansed just in
    case something slipped into your data through another means, such as a data load
    to your database (when this happens, it’s called a stored XSS attack because the
    malicious content somehow got stored and might have an effect when returned to
    the browser).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以采取措施从发送到服务器的任何内容中移除可能危险的内容，并且您可以通过特殊方式编码输出，即使某些内容意外通过，在到达用户的浏览器时也不会产生预期效果。例如，在接收用户数据时，您可以查找任何JavaScript关键字实例并将它们删除，因为这通常不是您希望允许出现在用户输入中的内容。为了安全起见，您需要在服务器端执行此操作，因此您会运行所有用户输入通过一个清洗函数，该函数查找这些关键字或其他可能有问题字符串，如`<script>`，并将它们删除。您还希望在输出端执行相同操作，这意味着您发送到浏览器的任何数据都应该类似地被清洗，以防通过其他方式（例如，将数据加载到您的数据库中）意外地进入您的数据（当这种情况发生时，被称为存储型XSS攻击，因为恶意内容以某种方式被存储，并在返回浏览器时可能产生影响）。
- en: Cross-site request forgery (CSRF)
  id: totrans-171
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跨站请求伪造 (CSRF)
- en: CSRF is a way to trick a user’s browser into executing some unwanted action
    and it appearing to be a legitimate action from the user. This comes in several
    forms, with one of the more common ways being when a website uses a cookie – small
    pieces of information stored on a user’s browser – to identify that user. If someone
    can steal that cookie, they can effectively impersonate the legitimate user. Imagine
    stealing the cookie for a user’s banking site – a threat actor could transfer
    all the money out before the real user is aware of it.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: CSRF 是一种欺骗用户浏览器执行某些不受欢迎的操作并使其看起来像是用户合法操作的方法。这有多种形式，其中一种更常见的方式是当网站使用cookie（存储在用户浏览器上的小信息块）来识别该用户。如果有人能够窃取该cookie，他们就可以有效地冒充合法用户。想象一下窃取一个用户的银行网站的cookie——攻击者可以在真实用户意识到之前将所有钱转走。
- en: Stealing cookies isn’t always as hard as it sounds if certain precautions aren’t
    taken (cookies have various security settings that developers should set properly
    to make them much more difficult to steal). Usage of a CSRF token is also common,
    which is a unique, random string that changes with each request. This way, even
    if someone steals your cookies, without the CSRF token, they wouldn’t be able
    to do anything. Other variations of CSRF require other mitigations, but it’s situation-specific.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不采取某些预防措施，窃取cookies并不像听起来那么困难（cookies有各种安全设置，开发者应该正确设置以使它们更难被窃取）。使用CSRF令牌也很常见，这是一个随着每个请求而变化的唯一随机字符串。这样，即使有人偷走了你的cookies，没有CSRF令牌，他们也无法做任何事情。CSRF的其他变体需要其他缓解措施，但这取决于具体情况。
- en: In addition to defenses for specific exploits like these, there are some basic
    coding practices you can use to help avoid security issues.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 除了针对这些特定攻击的防御措施之外，还有一些基本的编码实践可以帮助你避免安全问题。
- en: Secure coding practices
  id: totrans-175
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全编码实践
- en: As you write code, you should keep a few key things in mind. Doing so will help
    you avoid not only the previously mentioned issues but a whole lot more.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写代码时，你应该牢记几个关键点。这样做不仅能帮助你避免之前提到的问题，还能避免更多的问题。
- en: Implement secure authentication
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施安全的身份验证
- en: You should always implement strong password policies and use **multi-factor
    authentication** (**MFA**) to protect user accounts where possible. MFA means
    that a user must prove themselves through more than one factor, where a factor
    is something you are, something you know, and something you have. For example,
    logging into a site may require a username (who you are) a password (what you
    know), and perhaps a one-time code sent to your phone (something you have). While
    a threat actor managing to steal your password can happen (and your username isn’t
    generally considered sensitive in the first place), it’s unlikely they would also
    have your cell phone, so by requiring multiple factors, you’ve now defended that
    website.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该始终实施强大的密码策略，并在可能的情况下使用**多因素认证**（**MFA**）来保护用户账户。MFA意味着用户必须通过多个因素来证明自己，其中因素是你是谁、你知道什么以及你有什么。例如，登录一个网站可能需要用户名（你是谁）、密码（你知道什么），以及可能发送到你的手机上的一次性代码（你有什么）。虽然攻击者可能设法窃取你的密码（你的用户名通常不是敏感信息），但他们不太可能同时拥有你的手机，所以通过要求多个因素，你现在已经保护了该网站。
- en: Use encryption
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用加密
- en: Unless you have a very good reason not to, you should always use HTTPS so that
    the data that is transmitted between a browser and a server is encrypted. (The
    only good reason I can think of not to use HTTPS nowadays is when working on your
    machine during development since there is more configuration involved to use HTTPS
    than plain old HTTP that you simply may not want to deal with during development.)
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 除非你有非常充分的理由不这样做，否则你应该始终使用HTTPS，以确保浏览器和服务器之间传输的数据被加密。（我能想到的现在不使用HTTPS的唯一好理由是在开发过程中在你的机器上工作，因为使用HTTPS比简单的HTTP涉及更多的配置，你可能不想在开发过程中处理这些问题。）
- en: This avoids a form of attack called **Man-in-the-Middle** (**MITM**). In such
    an attack, a threat actor might gain control of a router on the network that your
    data passes through when sent to the server. In that situation, they can view
    that data, which may well include your username and password, and if you don’t
    have MFA, they can then log in as you all they want. Encryption makes it so that
    all they’ll ever see is a stream of gibberish.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以避免一种称为**中间人攻击**（**MITM**）的攻击形式。在这种攻击中，攻击者可能会控制你的数据在发送到服务器时通过网络的路由器。在这种情况下，他们可以查看这些数据，这些数据可能包括你的用户名和密码，如果你没有多因素认证（MFA），他们就可以随意登录。加密使得他们只能看到一串乱码。
- en: Handle errors properly
  id: totrans-182
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确处理错误
- en: When you write code, almost every language has ways that you can handle error
    conditions. This is important because when such errors occur, they can leak information
    about the underlying architecture of your website, or even allow a threat actor
    to sneak snippets of code that can then be executed in the context of your code.
    To avoid this, you should always ensure that error messages displayed to users
    give as little information as possible about your technology stack, and you should
    always try to use the error handling mechanisms your language of choice provides
    so that nothing can “slip out,” so to speak, that a threat actor can use against
    you.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写代码时，几乎每种语言都有处理错误条件的方法。这很重要，因为当这些错误发生时，它们可能会泄露关于你网站底层架构的信息，甚至可能允许威胁行为者偷偷将代码片段注入你的代码中，然后在你的代码上下文中执行。为了避免这种情况，你应该始终确保显示给用户的错误消息尽可能少地透露你的技术栈信息，并且你应该始终尝试使用你选择的语言提供的错误处理机制，以便没有任何东西“泄露出去”，也就是说，威胁行为者可以利用它来对付你。
- en: Perform code reviews and do robust testing
  id: totrans-184
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行代码审查并进行稳健的测试
- en: Regularly review code for vulnerabilities and perform security testing, including
    penetration testing and static code analysis.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 定期审查代码以发现漏洞，并执行安全测试，包括渗透测试和静态代码分析。
- en: Static code analysis tools look at your code without executing it and look for
    patterns that frequently denote security concerns. Static analysis can uncover
    other problems, not just security problems. It can find logic flaws that might
    result in bugs and can point out places where your code isn’t written to acceptable
    standards.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 静态代码分析工具在执行代码之前检查你的代码，寻找经常表示安全问题的模式。静态分析可以发现其他问题，而不仅仅是安全问题。它可以发现可能导致错误的逻辑错误，并指出你的代码没有按照可接受标准编写的位置。
- en: Penetration testing, usually abbreviated as pen testing, involves people (known
    as “white hat” hackers) actively trying to hack your website – with your approval,
    of course! They, try to find ways past your security by, for example, looking
    for clues about what technology you’re using and then searching for known vulnerabilities.
    They can also look for flaws in your code, based just on how it works, that allows
    them to breach your security.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 渗透测试，通常简称为pen testing，涉及人员（被称为“白帽”黑客）在获得你同意的情况下积极尝试攻击你的网站！他们试图通过例如寻找你使用的技术线索，然后搜索已知漏洞的方式来绕过你的安全措施。他们还可以根据代码的工作方式寻找代码中的缺陷，这使他们能够突破你的安全防线。
- en: Both of these are valuable because they point out things you may have missed
    yourself that you can then correct. Being proactive like this allows you to remediate
    these findings before the bad guys get in there and do bad guys things!
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法都很有价值，因为它们能指出你可能自己忽略的问题，然后你可以进行纠正。这样积极主动的做法让你有机会在坏人介入之前修复这些发现！
- en: Implement the principle of least privilege
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实施最小权限原则
- en: This is typically more at the operating system level than the code level, but
    sometimes, it does leak into the code level. Regardless, the idea is that you
    should only grant the permissions necessary to perform a task to a given user,
    reducing the potential impact of a breach if one should occur. Remember when we
    discussed the root user in Linux earlier? Well, if a threat actor can gain access
    as the root user, they have the keys to the kingdom – they can do anything. However,
    if they can only get into your server as a user who has limited access rights
    to files and directories, then even though they’ve breached your security, the
    damage they can do is limited.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这通常是在操作系统级别而不是代码级别，但有时，它确实会渗透到代码级别。无论如何，理念是你应该只授予执行特定任务所必需的权限给特定用户，以减少如果发生安全漏洞可能造成的潜在影响。记得我们之前讨论过Linux中的root用户吗？嗯，如果威胁行为者能够以root用户身份获得访问权限，他们就有了王国的钥匙——他们可以做任何事情。然而，如果他们只能以对文件和目录只有有限访问权限的用户身份进入你的服务器，那么即使他们已经突破你的安全防线，他们能造成的损害也是有限的。
- en: Set security headers
  id: totrans-191
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设置安全头信息
- en: Servers can set various headers on responses to browsers that are called **content
    security policy** (**CSP**) headers, as well as X-Frame-Options and Strict-Transport-Security
    headers. These tell the browser what they are allowed to do with the content the
    server returns. Properly configuring these headers can limit what a threat actor
    can do on your website, in some cases eliminating certain classes of exploits
    entirely (well, “entirely” is never a good thing to say when it comes to web security,
    but it certainly makes it much more challenging for the bad guys, which is essentially
    the overall goal to all of this – make it so difficult that it isn’t worth their
    time basically).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器可以在对浏览器的响应上设置各种头信息，称为**内容安全策略**（**CSP**）头信息，以及X-Frame-Options和Strict-Transport-Security头信息。这些告诉浏览器它们可以对服务器返回的内容执行什么操作。正确配置这些头信息可以限制威胁行为者在你的网站上能做的事情，在某些情况下甚至可以完全消除某些类型的漏洞（好吧，“完全”这个词在网络安全方面说起来永远不是什么好事，但它确实让坏人更难，而这基本上是所有这些的总体目标——让它们难以做到，基本上不值得他们花时间）。
- en: Do regular updates
  id: totrans-193
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定期更新
- en: You should almost always use the latest versions of things such as languages,
    libraries, and server software because they tend to have been patched against
    previously discovered security problems. New ones can always be discovered, so
    this is something that is an ongoing task.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 你几乎总是应该使用最新版本的诸如语言、库和服务器软件等，因为它们往往已经针对之前发现的安全问题进行了修补。新的问题总是可能被发现，因此这是一项持续的任务。
- en: Validate input
  id: totrans-195
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 验证输入
- en: When you get data from a client, you must always assume it contains security
    exploits. From the perspective of the server, a client is never to be trusted!
    So, we do things such as sanitizing input data, which means ensuring that all
    input data meets specific criteria to prevent malformed data from entering the
    system, this could lead to exploits. For example, if you have a form field that
    is for entering the user’s age, that’s intended to be a number. And, even if you
    have JavaScript on the page that ensures that’s the case, a threat actor has other
    ways to make that data not be a number. When the server gets it, if it assumes
    it’s a number – if it assumes the client is trusted – then non-numeric data can
    slip in, and there might be a way to use that to a threat actor’s benefit. Therefore,
    your server code *must* validate that what the client sent *is* a number as expected.
    Never, ever, ever trust the client! If you remember nothing else from this entire
    section, remember this, because it alone will help you avoid many, if not most,
    security exploits out there.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从客户端获取数据时，你必须始终假设它包含安全漏洞。从服务器的角度来看，客户端永远不可信！因此，我们做一些事情，比如清理输入数据，这意味着确保所有输入数据都符合特定标准，以防止格式不正确的数据进入系统，这可能导致漏洞。例如，如果你有一个用于输入用户年龄的表单字段，它应该是一个数字。即使你在页面上有JavaScript确保这一点，威胁行为者也有其他方法让那些数据不是数字。当服务器接收到它时，如果它假设它是一个数字——如果它假设客户端是可信的——那么非数字数据可能会悄悄进入，并且可能存在利用这些数据的方法。因此，你的服务器代码*必须*验证客户端发送的确实是预期的数字。永远不要，永远不要信任客户端！如果你从这个整个部分中记住什么，记住这一点，因为它单独就能帮助你避免许多，如果不是大多数安全漏洞。
- en: Encode output
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 编码输出
- en: Imagine that you have a website that gets stock ticker values from a remote
    service. Further, imagine that you store that data in your database and show it
    to your users. Now, your website might be perfectly coded, so it sanitizes all
    the data it gets from the user. Hooray! But what about the data you get from that
    remote service? Did *they* do *their* job as well as *you* did? Maybe not!
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你有一个网站从远程服务获取股票行情数据。进一步想象，你将那些数据存储在你的数据库中并向用户展示。现在，你的网站可能代码编写得非常完美，因此它会清理从用户那里获取的所有数据。太好了！但是，你从那个远程服务获取的数据怎么办？他们是否像你一样很好地完成了他们的工作？也许没有！
- en: In that case, you may wind up with malicious content in the form of JavaScript
    code stored in your database, and then when you render that JavaScript on your
    page, it can execute within the context of your page as if you had written it
    yourself, but doing the bidding of the bad guys. This is called a stored CSS attack
    because the malicious code was stored somewhere and snuck in “through the back
    door,” so to speak. To avoid this, you need to encode the data that is sent to
    your clients, removing certain content that can lead to exploits.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你可能会在你的数据库中以JavaScript代码的形式存储恶意内容，然后当你将这段JavaScript渲染到页面上时，它可以在你的页面上下文中执行，就像是你自己编写的，但执行的是坏人的命令。这被称为存储CSS攻击，因为恶意代码被存储在某个地方，通过“后门”悄悄进入。为了避免这种情况，你需要对发送给客户端的数据进行编码，移除可能导致漏洞的某些内容。
- en: How this encoding is implemented varies greatly depending on many factors –
    far too many to detail here. But generally, it involves replacing certain characters
    or sequences of characters with others that are considered safe. Just as one example,
    if a user can submit data that contains the text `alert(1)` and it is saved in
    your database and is then later used on your page, that JavaScript code will execute
    as if you wrote it yourself. To deal with that, you may need to encode the `(`
    and `)` characters as `&#40;` and `&#41;`, respectively, which are special sequences
    that will ensure the code isn’t executed.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编码的实现方式因许多因素而大相径庭——太多以至于无法在此详细说明。但一般来说，它涉及用被认为是安全的其他字符或字符序列替换某些字符或字符序列。举一个例子，如果用户可以提交包含文本
    `alert(1)` 的数据，并且它被保存在你的数据库中，然后后来在页面上使用，那么这段JavaScript代码将像你亲自编写的那样执行。为了处理这种情况，你可能需要将
    `(` 和 `)` 字符分别编码为 `&#40;` 和 `&#41;`，这些是特殊序列，将确保代码不会执行。
- en: Securely manage configuration
  id: totrans-201
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 安全地管理配置
- en: It is common to need certain pieces of sensitive information in your code. For
    example, your code may need a username and password to connect to a database.
    If you embed this information in your code, then anyone who manages to see the
    code now has those credentials. This can be avoided by securely storing those
    credentials, usually in some special system specialized and designed for such
    sensitive information. Your code will then request the credentials from that system
    only when needed, and then they are only ever stored in the server’s memory for
    a short period.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码中需要某些敏感信息是很常见的。例如，你的代码可能需要用户名和密码来连接到数据库。如果你将此信息嵌入到代码中，那么任何能够看到代码的人现在都有了这些凭据。这可以通过安全地存储这些凭据来避免，通常是在一些专门为这种敏感信息设计的特殊系统中。然后，你的代码只在需要时从该系统请求凭据，并且它们只在服务器内存中短暂存储。
- en: Monitor file uploads
  id: totrans-203
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 监控文件上传
- en: If your application allows file uploads, ensure that they are scanned for malware
    and have strict controls on the types and sizes of files. If you are building
    a website where people can show others their photo albums, for example, you’ll
    want to implement code that ensures only graphics files are uploaded. Plus, you
    will probably want to have code that ensures no file greater than maybe 10 Mb
    is uploaded. This way, you can stop users from uploading, say, large executable
    files that could be malware through which to attack your server.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的应用程序允许文件上传，确保对文件进行恶意软件扫描，并对文件类型和大小进行严格控制。例如，如果你正在构建一个人们可以展示他们相册的网站，你将希望实施代码以确保只上传图形文件。此外，你可能还希望有代码来确保没有大于可能10
    Mb的文件被上传。这样，你可以阻止用户上传可能包含恶意软件的大型可执行文件，这些恶意软件可能被用来攻击你的服务器。
- en: Secure data storage properly
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 正确安全地存储数据
- en: Something that comes up often is needing to store user credentials – usernames
    and passwords, most typically. You may think that storing them in a database on
    your server is safe, but that isn’t the case. Someone may be able to gain access
    to that database. And if you store it in a file instead of a database, then the
    same may be true.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 经常出现的情况是需要存储用户凭据——通常是用户名和密码。你可能认为将它们存储在服务器上的数据库中是安全的，但这并不是真的。有人可能能够访问那个数据库。如果你将它们存储在文件中而不是数据库中，情况可能也是如此。
- en: 'No, you have to store that data securely. How would you do so in this case?
    You may think that you can encrypt the password and store that, right? **Encryption**
    is when we take a value and generate another value that looks like gibberish,
    but where that gibberish can be used to reproduce the original value given another
    value – the key – that was used to encrypt it. In other words, encryption is a
    two-way function: one way encrypts some data given a key value and the other way
    de-crypts it (turns it back into the original data) given the key.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 不，你必须安全地存储这些数据。你在这个情况下会如何做？你可能认为你可以加密密码并存储它，对吧？**加密**是我们取一个值并生成另一个看起来像乱码的值，但这个乱码可以用来在给定另一个值——密钥——的情况下重新生成原始值。换句话说，加密是一个双向函数：一种方式是使用密钥值加密一些数据，另一种方式是使用密钥解密它（将其转换回原始数据）。
- en: That seems safe, right? Even if someone gets your database, they’ll just see
    gibberish for the password (the username doesn’t typically need to be protected
    in any way). That’s true… unless they also get your encryption key! And that may
    not be very hard considering your code has to have the key to decrypt the password
    and see if what the user entered is correct.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来很安全，对吧？即使有人得到了你的数据库，他们也只能看到密码的乱码（通常不需要以任何方式保护用户名）。这是真的……除非他们也得到了你的加密密钥！考虑到你的代码需要密钥来解密密码并检查用户输入是否正确，这可能并不难。
- en: Instead, what you should do in this case is hash the password. Unlike encryption,
    which is two-way, `abc123` (not a good password, but work with me here!). If we
    hash that password, we might get a hash value of `z9x8`. So, we can never take
    `z9x8` and get `abc123` from it, but we’ll always get `z9x8` if we feed the hash
    function `abc123`.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，你应该做的是对密码进行哈希处理。与加密不同，加密是双向的，`abc123`（这不是一个好的密码，但请配合我继续这个例子！）如果我们对那个密码进行哈希处理，我们可能会得到一个哈希值`z9x8`。所以，我们永远不能从`z9x8`中得到`abc123`，但如果我们给哈希函数输入`abc123`，我们总是会得到`z9x8`。
- en: This is useful because if we store `z9x8` in our database, it means that even
    if someone steals it, they can never get the real password. But our server code
    can still validate that user! All it has to do is take the password they enter
    when logging in and hash it. If the has value we get matches the hash value stored
    in the database, then we know they entered the right password.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有用，因为如果我们把`z9x8`存储在我们的数据库中，这意味着即使有人偷走了它，他们也无法得到真正的密码。但我们的服务器代码仍然可以验证用户！它只需要做的是，在用户登录时，对用户输入的密码进行哈希处理。如果我们得到的哈希值与数据库中存储的哈希值匹配，那么我们就知道他们输入了正确的密码。
- en: The difference between hashing and encrypting is something that developers often
    get wrong in my experience, and this scenario is a common one where knowing the
    difference is the difference between a secure login system versus one that isn’t.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希和加密之间的区别是开发者经常出错的地方，在我的经验中，这个场景是知道区别是安全登录系统与不安全登录系统之间的区别。
- en: By incorporating these (and other) practices, web developers can significantly
    reduce the attack surface – all the different paths through your security a threat
    actor might exploit – of web applications and defend against the ever-evolving
    landscape of cyber threats.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 通过采用这些（以及其他）实践，网络开发者可以显著减少攻击面——所有可能被攻击者利用的安全路径——从而防御不断演变的网络威胁格局。
- en: More on hashing
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于哈希的内容
- en: Hashes aren’t just for passwords and security. You saw them used earlier when
    discussing Git. Hashes there work the same way – the content of a commit is run
    through a hash function to generate the hash value – but in Git, it’s used not
    for security but for uniquely identifying a commit since a hash value would be
    unique to the content that was committed given that there is no other combination
    of characters that could result in the same hash value (strictly speaking, this
    isn’t 100% true, but the odds of two different input strings producing the same
    hash value – something we call a hash collision – is statistically so unlikely
    that we can say it’s true).
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 哈希不仅用于密码和安全。你之前在讨论Git时看到了它们的使用。那里的哈希工作方式相同——提交的内容通过哈希函数运行以生成哈希值——但在Git中，它不是用于安全，而是用于唯一标识一个提交，因为哈希值将唯一对应于提交的内容，因为不存在其他字符组合可以产生相同的哈希值（严格来说，这并不完全正确，但两个不同的输入字符串产生相同哈希值的概率——我们称之为哈希冲突——在统计上如此之低，以至于我们可以认为这是真的）。
- en: 'Now, let’s switch gears a bit and talk about what in many cases will wind up
    being the development tool you deal with the most day-to-day: IDEs.'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转换一下话题，谈谈在许多情况下将成为你日常处理最多的开发工具：集成开发环境（IDEs）。
- en: Working all in one place – IDEs
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在一个地方完成所有工作——集成开发环境（IDE）
- en: In [*Chapter 1*](B18315_01.xhtml#_idTextAnchor015), I showed you some very basic
    HTML and suggested that you enter it into a plain text editor such as Notepad
    if you’re using Windows. For a long time, that’s all there was – just plain text
    editors. After a while, they got more advanced. For example, some could recognize
    various programming languages and provide color coding to make them easier to
    digest, or they could recognize functions in something such as JavaScript and
    show you a list to the side. They started to become more than just plain text
    editors – in other words, they started to become aware of the *content* of the
    text.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第一章*](B18315_01.xhtml#_idTextAnchor015)中，我向你展示了一些非常基础的HTML，并建议如果你使用Windows系统，可以将它输入到记事本这样的纯文本编辑器中。长期以来，就是这样——只有纯文本编辑器。过了一段时间，它们变得更加高级。例如，一些编辑器可以识别各种编程语言并提供颜色编码，使它们更容易理解，或者它们可以识别JavaScript中的函数，并在旁边显示一个列表。它们开始不仅仅只是纯文本编辑器——换句话说，它们开始意识到文本的*内容*。
- en: 'Not long after that started to happen, a new evolution occurred: IDEs. These
    are pieces of software that provide comprehensive facilities to developers. You
    might almost say an IDE is a text editor that is *hyper*-aware of the text being
    edited. It understands what you’re doing and aids you in many ways. IDEs increase
    your productivity by combining most of the common activities involved in writing
    software into a single application. You stay in one place as you work and have
    everything you need at your fingertips rather than having to jump between several
    windows or interfaces to get your work done.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 在那之后不久，又发生了一次新的演变：集成开发环境（IDE）。这些软件为开发者提供了全面的设施。你几乎可以说IDE是一个对正在编辑的文本非常*敏感*的文本编辑器。它理解你在做什么，并以多种方式帮助你。IDE通过将编写软件时涉及的大部分常见活动组合到一个应用程序中，提高了你的生产力。你在工作的地方保持不变，并且所有你需要的东西都在你的指尖，而不是需要跳转到几个窗口或界面来完成工作。
- en: 'An IDE typically includes the following:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 一个IDE通常包括以下内容：
- en: '*Code editor*: I mean, obviously, right?! But it’s a text editor that’s specialized
    for writing and editing programming source code and typically includes features
    such as syntax highlighting, code formatting, and code navigation.'
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*代码编辑器*：我的意思很明显，对吧？！但这是一个专门用于编写和编辑编程源代码的文本编辑器，通常包括诸如语法高亮、代码格式化和代码导航等功能。'
- en: '*Compiler or interpreter*: Some programming languages need to be turned into
    other languages before they can be run. It sounds weird, but it’s true! This process
    is called *compilation*, and it’s done with a *compiler*. Languages that *can*
    be run exactly as they are use an *interpreter* instead. However, regardless of
    which is needed, it’s a tool you have to engage somehow, and usually, it’s a separate
    command-line interface. But with an IDE, it’s all built-in and controlled with
    the IDE interface, so you never have to leave it, which is a key benefit of an
    IDE.'
  id: totrans-221
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*编译器或解释器*：一些编程语言在运行之前需要转换为其他语言。这听起来很奇怪，但这是真的！这个过程被称为*编译*，通常使用*编译器*来完成。那些*可以直接运行*的语言则使用*解释器*。然而，无论需要哪种工具，你都必须以某种方式与之交互，通常是一个独立的命令行界面。但有了集成开发环境（IDE），所有这些功能都内置其中，并通过IDE界面进行控制，因此你永远不需要离开它，这是IDE的一个关键优势。'
- en: '*Debugger*: A debugger is a tool that helps you test and debug your code by
    allowing things such as executing the code line by line, viewing the state of
    variables at any moment in time, or skipping sections of code so you can focus
    on specific areas. Any IDE worth its salt will have a solid debugger built into
    it.'
  id: totrans-222
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*调试器*：调试器是一个工具，它通过允许执行代码的逐行执行、在任何时刻查看变量的状态或跳过代码段以便你能够专注于特定区域等方式，帮助你测试和调试代码。任何值得拥有的IDE都会内置一个强大的调试器。'
- en: '*Build automation*: Once you’re done writing your code and have tested and
    debugged it, you usually need to create some sort of package that the underlying
    operating system or runtime environment will use when you want to distribute your
    app to others. This, we say, is when you “build and package” your app, and IDEs
    provide ways to automate this normally manual process.'
  id: totrans-223
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*构建自动化*：一旦你编写完代码并测试和调试了它，你通常需要创建某种类型的包，当你想将应用程序分发给他人时，底层操作系统或运行时环境将使用这个包。我们说，这就是你“构建和打包”应用程序的时候，IDE提供了自动化这个通常手动过程的方法。'
- en: '*SCM*: An IDE will almost certainly know how to work with Git and other SCM
    systems, and they will usually provide a more visual approach to using them. Some
    people greatly prefer this approach to the command line – I’m one of them – because
    it allows you to not have to remember a bunch of commands and options and instead
    work with your code and SCM more abstractly.'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*源代码管理（SCM）*：IDE 几乎肯定知道如何与 Git 和其他源代码管理系统（SCM）一起工作，并且它们通常会提供一种更直观的方式来使用它们。有些人非常偏爱这种方法，而不是命令行——我就是其中之一——因为它允许您不必记住一大堆命令和选项，而是更抽象地与代码和
    SCM 一起工作。'
- en: '*Extensibility*: Any good IDE will have some mechanism to extend its capabilities,
    whether they’re called plugins, extensions, or something else. Through this, you
    can add support for new languages, or tools.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*可扩展性*：任何好的集成开发环境（IDE）都将有一些机制来扩展其功能，无论是称为插件、扩展还是其他什么。通过这种方式，您可以添加对新语言或工具的支持。'
- en: IDEs come in all shapes and sizes. Some are free, some cost money, some are
    just good text editors with a few added capabilities, and some can do so much
    that they could seemingly pilot the space shuttle if you asked them to!
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 集成开发环境（IDE）有各种各样的形状和大小。有些是免费的，有些需要付费，有些只是带有一些附加功能的良好文本编辑器，而有些可以做很多事情，以至于如果您要求它们，它们似乎可以驾驶航天飞机！
- en: 'In the following subsections, we’ll look at several of the most popular IDEs.
    As you read about them and look at the example screenshots, notice the similarities:
    they all, generally, have an area in the center for editing source code, surrounded
    by several small tool windows or areas. This is, generically, the point of an
    IDE: give you a solid, content-aware text editor at the cen[ter with context-aware
    tools](https://code.visualstudio.com) around it to help get your work done.'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的小节中，我们将探讨几个最受欢迎的集成开发环境（IDE）。当您阅读有关它们的内容并查看示例截图时，请注意它们的相似之处：它们通常都有一个用于编辑源代码的中心区域，周围环绕着几个小的工具窗口或区域。这基本上是
    IDE 的目的：在中心提供一个坚实的、内容感知的文本编辑器，并围绕它提供上下文感知的工具（https://code.visualstudio.com）来帮助您完成工作。
- en: VS Code
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: VS Code
- en: VS Code (https://code.visualstudio.com) may well be the most popular IDE today.
    It hails from Microsoft and is billed as a free, lightweight, cross-platform (meaning
    it can run on Windows, Mac, Linux, and even on the web itself!) source code editor
    with built-in support for JavaScript, TypeScript (we’ll get to this in later chapters),
    and Node. It is generally a pretty bare-bones IDE out of the box, but it is extremely
    extensible through a rich ecosystem of extensions for other languages, runtimes,
    tools, and technologies, so you can make it do just about anything you need.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: VS Code（https://code.visualstudio.com）可能是今天最受欢迎的 IDE。它来自微软，被宣传为免费、轻量级、跨平台（这意味着它可以在
    Windows、Mac、Linux 上运行，甚至可以在网络上运行！）源代码编辑器，内置对 JavaScript、TypeScript（我们将在后面的章节中介绍）和
    Node 的支持。它通常是一个相当基础的 IDE，但通过丰富的扩展生态系统，它可以非常容易地扩展，以支持其他语言、运行时、工具和技术，因此您可以使其完成几乎所有您需要的任务。
- en: Developers tend to like VS Code because it “gets out of their way.” Some people
    find some other IDEs to have a little *too* much capability, believe it or not!
    After all, at the end of the day, it all comes down to the code you’re writing,
    so an environment that takes space away from seeing your code is sometimes not
    what you want. VS Code, by default at least, does a good job of focusing on your
    code, but you can add to it later as you see fit.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 开发者倾向于喜欢 VS Code，因为它“不会妨碍他们”。有些人发现一些其他 IDE 的功能“有点太多”，信不信由你！毕竟，最终，一切都归结于您所编写的代码，所以一个占用您查看代码空间的环境有时可能不是您想要的。至少默认情况下，VS
    Code 在专注于您的代码方面做得很好，但您可以根据需要稍后添加功能。
- en: '*Figure 4**.7* shows VS Code, though do note that this is my current setup,
    so you’re seeing more there than you’ll get by default since I’ve installed many
    extensions already (which you can tell by the number of icons on the left – by
    default, there would only be a few of those, but some of the extensions I’ve added
    also add icons there):'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4.7* 展示了 VS Code，但请注意，这目前是我的设置，所以您看到的内容比默认设置要多，因为我已经安装了许多扩展（您可以通过左侧图标数量来判断——默认情况下，只有几个这样的图标，但我添加的一些扩展也添加了图标在那里）：'
- en: '![Figure 4.7: VS Code](img/B18315_04_7.jpg)'
  id: totrans-232
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7：VS Code](img/B18315_04_7.jpg)'
- en: 'Figure 4.7: VS Code'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：VS Code
- en: With that said though, notice how there isn’t a lot around the code. There’s
    just the code, a project directory list on the left, and a command prompt on the
    right. And by default, the command prompt won’t even be shown. That’s what “gets
    out of your way” means, and you can contrast that to something such as Eclipse
    or IntelliJ IDEA when [I show them shortly since they sho](https://visualstudio.microsoft.com)w
    a bit more by default.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，但请注意代码周围并没有太多东西。只有代码、左侧的项目目录列表和右侧的命令提示符。默认情况下，命令提示符甚至不会显示。这就是“不挡你的路”的意思，你可以将其与
    Eclipse 或 IntelliJ IDEA 进行对比，我在稍后展示它们时，它们默认会显示更多内容。
- en: Visual Studio
  id: totrans-235
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio
- en: '**Visual Studio** (https://visualstudio.microsoft.com), in a sense, is the
    big brother of VS Code and also happens to be from Microsoft. It predates VS Code
    by many years (probably even decades at this point). Historically, Visual Studio
    has primarily been for working with Microsoft languages such as .NET and C#, but
    over the years, it has grown to encompass just about every technology out there,
    whether from Microsoft or not. Microsoft offers a slightly limited free community
    edition, and then a full-featured version that comes along with a paid subscription
    model (this can cost as low as around $500 and as high as around $6,000 at the
    time of writing).'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio** (https://visualstudio.microsoft.com) 在某种意义上是 VS Code 的“大哥”，而且恰好也是微软的产品。它比
    VS Code 诞生早很多年（可能现在甚至几十年）。从历史上看，Visual Studio 主要用于处理微软的语言，如 .NET 和 C#，但多年来，它已经扩展到几乎涵盖所有技术，无论这些技术是否来自微软。微软提供了一种稍微有限制的免费社区版，以及一个功能齐全的版本，该版本附带付费订阅模式（在撰写本文时，这可能低至约
    500 美元，高至约 6000 美元）。'
- en: Visual Studio used to be something of a joke in that it was very heavy, very
    slow, and tended to not be as stable as you want something you’re writing original
    code in. But that couldn’t be further from what it is today. Now, it’s a very
    highly respected and well-regarded IDE that lots of people swear by.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 以前曾是一种笑话，因为它非常沉重、非常慢，而且往往不如你编写原始代码时希望的那样稳定。但现在，它已经成为一个非常受尊重和好评的
    IDE，很多人对其赞不绝口。
- en: '*Figure 4**.8* shows what Visual Studio looks like. Unlike VS Code, I haven’t
    done a lot of customization to my Visual Studio installation, so a fresh install
    won’t look too much different than this:'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.8* 展示了 Visual Studio 的外观。与 VS Code 不同，我对我的 Visual Studio 安装并没有做太多的定制，所以全新安装看起来不会与这个有很大不同：'
- en: '![Figure 4.8: Visual Studio](img/B18315_04_8.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8：Visual Studio](img/B18315_04_8.jpg)'
- en: 'Figure 4.8: Visual Studio'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：Visual Studio
- en: I mentioned that Visual Studio is something of the big brother to VS Code. What
    I mean by that is that Visual Studio includes more functionality, at least out
    of the box. It has more robust debugging facilities, can more seamlessly work
    with various types of servers, and can even be used to debug Windows-native applications
    in real-time. VS Code, since its inception, has narrowed that gap, especially
    when the right extensions [are installed, but Visual](https://www.eclipse.org/ide)
    Studio is still more feature-rich out of the box.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 我提到 Visual Studio 是 VS Code 的“大哥”。我的意思是 Visual Studio 包含更多的功能，至少在开箱即用的情况下。它拥有更强大的调试功能，可以更无缝地与各种类型的服务器协同工作，甚至可以实时调试
    Windows 原生应用程序。VS Code 自诞生以来，已经缩小了这一差距，尤其是在安装了正确的扩展之后，但 Visual Studio 仍然在开箱即用的情况下功能更丰富。
- en: Eclipse
  id: totrans-242
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Eclipse
- en: '**Eclipse** (https://www.eclipse.org/ide) might be the most famous IDE out
    there. It’s a free (though donations are greatly appreciated!) and open-source
    IDE that has historically been primarily for Java development, but just like Visual
    Studio, it has grown over the years and now can do it all.'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '**Eclipse** (https://www.eclipse.org/ide) 可能是市面上最著名的 IDE。它是一个免费（尽管捐赠非常受欢迎！）且开源的
    IDE，历史上主要用于 Java 开发，但就像 Visual Studio 一样，它随着时间的发展已经变得无所不能。'
- en: Eclipse is rather old, though I don’t say that pejoratively, simply that it’s
    been around for a long, long time. Like Visual Studio, it wasn’t always as well-regarded
    as it is now. Over the years, its performance has improved significantly, as has
    the relative simplicity and coherence of its user interface, to a point now where
    a lot of people love Eclipse.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 Eclipse 相对较老，但我并不是在贬低它，只是说它已经存在很长时间了。就像 Visual Studio 一样，它并不是一开始就受到如此好评。多年来，它的性能显著提高，用户界面的相对简单性和一致性也有所提升，现在很多人都非常喜欢
    Eclipse。
- en: '*Figure 4**.9* shows what Ec[lipse looks like in action:](https://www.jetbrains.com/idea)'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '*图 4**.9* 展示了 Eclipse 在实际操作中的样子：](https://www.jetbrains.com/idea)'
- en: '[![Figure 4.9: Eclipse](img/B18315_04_9.jpg)](https://www.jetbrains.com/idea)'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: '[![图4.9: Eclipse](img/B18315_04_9.jpg)](https://www.jetbrains.com/idea)'
- en: 'Figure 4.9: Eclipse'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '图4.9: Eclipse'
- en: IntelliJ IDEA
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: IntelliJ IDEA
- en: IntelliJ IDEA (or simply IDEA) (https://www.jetbrains.com/idea) is an IDE by
    the company JetBrains. This is another IDE that started primarily for a specific
    technology – Java, in this case – but rapidly grew to be able to handle almost
    everything else. This is my personal favorite due to its excellent performance,
    stability, and extreme extensibility. JetBrains offers a free community edition,
    as well as a paid advanced version.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: IntelliJ IDEA（或简称IDEA）(https://www.jetbrains.com/idea)是由JetBrains公司开发的一个IDE。这是另一个主要为了特定技术——在这个案例中是Java——而开始的IDE，但它迅速发展，能够处理几乎所有其他的事情。这是我个人最喜欢的，因为它出色的性能、稳定性和极端的可扩展性。JetBrains提供免费社区版，以及付费的高级版本。
- en: It’s worth noting that the community edition has a few more significant limitations
    as opposed to the others listed here, namely that web development is somewhat
    limited. Fortunately, the cost of a paid license isn’t all that much (as of this
    writing, it’s $169 for the first year, $135 for the second year, and then $101
    for each year after that for a license for an individual developer) and *for sure*
    it’s well worth that money for the power it puts in your hands. It is, of course,
    more for an organization ($599 per year), so it comes down to what kind of license
    you need.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，社区版与这里列出的其他版本相比，有一些更显著的限制，尤其是Web开发方面有所局限。幸运的是，付费许可证的成本并不高（截至本文写作时，第一年为169美元，第二年为135美元，之后每年为101美元，针对个人开发者的许可证），而且*绝对*物有所值，因为它将强大的功能交到了你的手中。当然，它更适合组织（每年599美元），所以这取决于你需要哪种许可证。
- en: 'In any case, *Figure 4**.10* reveals what IDEA looks like, at least in my case,
    with quite a few extensions active in it:'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，*图4**.10* 展示了IDEA的样子，至少在我的情况下，其中激活了相当多的扩展：
- en: '![Figure 4.10: IntelliJ IDEA](img/B18315_04_10.jpg)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图4.10: IntelliJ IDEA](img/B18315_04_10.jpg)'
- en: 'Figure 4.10: IntelliJ IDEA'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '图4.10: IntelliJ IDEA'
- en: This is by no means an exhaustive list, but I think these four are probably
    the most popular at the time of writing.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一份详尽的列表，但我想这些四个在写作时可能是最受欢迎的。
- en: Now, let’s jump tracks and touch on another topic that you should be aware of,
    that being operating systems – more specifically, Linux.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转换话题，触及另一个你应该了解的主题，那就是操作系统——更具体地说，是Linux。
- en: Understanding the operating system – Linux
  id: totrans-256
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解操作系统——Linux
- en: 'So, you write your code, and you write it securely, and you get it under SCM.
    But what do you do when it comes time to deploy your code – that is, put it where
    it will run? There’s no singular answer to this question because how and where
    you can run your code is a question with myriad answers. But one thing is for
    sure: they’re all going to involve an operating system of some sort in some fashion.'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你编写代码，并安全地编写它，将其置于版本控制之下。但当部署代码的时候——也就是说，将其放置在运行的地方——你该怎么办呢？这个问题没有单一的答案，因为你可以如何以及在哪里运行你的代码是一个有无数答案的问题。但有一点是肯定的：它们都将涉及某种形式的操作系统。
- en: While Windows is, at the time of writing, still the world’s most popular desktop
    operating system, the story is very different when we talk about servers. While
    you will find a good number of Windows-based servers out there too, most servers
    run Linux.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然截至本文写作时，Windows仍然是世界上最受欢迎的桌面操作系统，但当我们谈到服务器时，情况就完全不同了。虽然你也会发现很多基于Windows的服务器，但大多数服务器都运行Linux。
- en: '**Linux** is an open-source operating system written and first released by
    Linus Torvalds in 1991\. The basic architecture of Linux is based on the Unix
    operating system, which was initially released way back in 1971, though it has
    a history – in a slightly different form – stretching back to the 1960s. Linux’s
    history is also the history of the internet in a sense as its use grew right alongside
    the internet. It became the backbone for server infrastructure, powering websites
    and online services due to its robustness and flexibility, and is also the poster
    child for the **free/open-source software** (**FOSS**) movement as easily the
    largest and most well-known open source project ever.'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '**Linux** 是由Linus Torvalds于1991年编写并首次发布的开源操作系统。Linux的基本架构基于Unix操作系统，该操作系统最初于1971年发布，尽管它的历史——以一种稍微不同的形式——可以追溯到20世纪60年代。从某种意义上说，Linux的历史也是互联网的历史，因为它的使用与互联网同步增长。它因其稳健性和灵活性而成为服务器基础设施的骨干，为网站和在线服务提供动力，并且也是**免费/开源软件**（**FOSS**）运动的典范，无疑是迄今为止最大和最知名的开放源代码项目。'
- en: Unix, and hence Linux, is stable, generally secure, and free, which makes it
    quite popular for many purposes. It is fundamentally based on principles of modularity
    and reusability, meaning it can be tweaked and reorganized with specific goals
    in mind. It is this quality that makes it flexible and gives rise to hundreds,
    if not thousands, of distributions – or *distros* – which are just variants of
    Linux, different collections of system libraries and tweaked kernels and such.
    Different distros have different focuses. Some are built as specifically as web
    servers; some are geared toward desktop machines; some have very small memory
    and hardware requirements making them ideal for small embedded systems; some are
    targeted to musicians; some are targeted to scientists… and so on.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: Unix，因此Linux，是稳定的、通常安全的、免费的，这使得它在许多用途中都相当受欢迎。它基于模块化和可重用性的原则，这意味着它可以有针对性地调整和重新组织。正是这种特性使其具有灵活性，并导致了数百（如果不是数千）个发行版——或称*distros*——它们只是Linux的变体，不同的系统库集合和调整过的内核等。不同的发行版有不同的重点。有些被构建成专门的服务器；有些针对桌面机器；有些具有非常小的内存和硬件要求，使其成为小型嵌入式系统的理想选择；有些针对音乐家；有些针对科学家……等等。
- en: Now, let’s take a high-level look at some of the very basics of Linux, including
    its overall structure, some of the most common commands you might encounter, and
    the role of security in Linux.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们从高层次上了解一下Linux的一些基本概念，包括其整体结构、您可能会遇到的一些最常见命令，以及安全在Linux中的作用。
- en: The structure of Linux
  id: totrans-262
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Linux的结构
- en: 'The basic structure of Linux can be understood as a series of layers, one on
    top of the other. Starting from the lowest layer, we have the following:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: Linux的基本结构可以理解为一系列层，一层叠在另一层之上。从最底层开始，我们有以下内容：
- en: '*Kernel*: A piece of software that’s responsible for managing hardware resources
    primarily – things such as the CPU, memory, and peripheral devices.'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*内核*：一种主要负责管理硬件资源（如CPU、内存和外设）的软件。'
- en: '*Filesystem*: Any operating system will need to include a filesystem – the
    structure of how information is stored on a storage device. Linux supports many
    different filesystems, but for the most part, it abstracts the differences away
    so that you can treat any filesystem the same as any other.'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*文件系统*：任何操作系统都需要包含文件系统——信息在存储设备上的存储结构。Linux支持许多不同的文件系统，但大部分情况下，它抽象了差异，以便您可以像对待任何其他文件系统一样对待任何文件系统。'
- en: '*Shell*: The interface that’s used by a user to interact with the kernel. In
    most cases, out of the box, this is a command line interface (and even for Linux
    distros that have a GUI, there is always a command line interface available as
    well).'
  id: totrans-266
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Shell*：用户用于与内核交互的界面。在大多数情况下，默认情况下，这是一个命令行界面（即使是具有GUI的Linux发行版，也始终有一个可用的命令行界面）。'
- en: '*Utilities*: Software tools for managing the system. These are just small programs,
    each with very small, explicit purposes – things such as creating users, managing
    files, viewing system resource usage, and so on.'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*实用程序*：用于管理系统的小型软件工具。这些只是具有非常小、明确目的的小程序——例如创建用户、管理文件、查看系统资源使用情况等。'
- en: '*Applications*: User-level programs such as browsers and word processors.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*应用程序*：用户级程序，如浏览器和文字处理器。'
- en: Linux distributions bundle the kernel with various software, both utilities
    and applications, to create complete operating systems. This software provides
    the basic commands you can execute at the Linux command line, which by default
    is how you interact with the operating system.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: Linux发行版将内核与各种软件捆绑在一起，包括实用程序和应用程序，以创建完整的操作系统。这些软件提供了您可以在Linux命令行中执行的基礎命令，默认情况下，这是您与操作系统交互的方式。
- en: Basic commands
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基础命令
- en: 'While there are hundreds of commands you can execute at a Linux command line,
    there is a much smaller set of commands you’ll use frequently. What that set of
    commands is will depend on what you’re doing, but some of the most important and
    most-used commands would certainly include the following:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可以在Linux命令行中执行数百条命令，但您经常使用的命令集要小得多。这个命令集将取决于您要做什么，但一些最重要且最常用的命令肯定包括以下内容：
- en: '`ls`: List directory contents'
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ls`：列出目录内容'
- en: '`cd` and `pwd`: Change directory (navigate the filesystem) and print working
    directory (tell you where you are on the filesystem)'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cd`和`pwd`：更改目录（在文件系统中导航）和打印工作目录（告诉您在文件系统中的位置）'
- en: '`grep`: Search text in files'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`grep`: 在文件中搜索文本'
- en: '`cp` and `mv`: Copy file or directory and move file or directory'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`cp`和`mv`：复制文件或目录，移动文件或目录'
- en: '`rm`: Remove file or directory'
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rm`：删除文件或目录'
- en: '`sudo`: Execute a command as another user'
  id: totrans-277
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sudo`：以其他用户身份执行命令'
- en: '`mkdir`: Make a new directory in the current working directory'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`mkdir`：在当前工作目录中创建新目录'
- en: '`man`: View manual pages (instructions for various commands)'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`man`：查看手册页（各种命令的说明）'
- en: '`chmod`: Change file and directory permissions'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`chmod`：更改文件和目录权限'
- en: '`touch`: Create a new file or update the last accessed and modified date/time
    on an existing file'
  id: totrans-281
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`touch`：创建新文件或更新现有文件的最后访问和修改日期/时间'
- en: '`ps` and `kill`: View information about the processes currently running on
    the system and stop (kill) them if needed'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ps` 和 `kill`：查看系统上当前正在运行的过程信息，并在需要时停止（杀死）它们'
- en: '`less` and `more`: Inspect the contents of a file (`more` is a simplistic application
    that offers fairly basic viewing features, whereas `less` offers more advanced
    features, such as two-way scrolling, robust searching, and more interactivity
    for the user)'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`less` 和 `more`：检查文件内容（`more` 是一个功能相当基础的程序，提供了相当基本的查看功能，而 `less` 提供了更高级的功能，例如双向滚动、强大的搜索和更多用户交互性）'
- en: 'This is in no way a comprehensive list, nor is it attempting to be. There are
    plenty more commands out there, and perhaps one of the best places to find them
    is the *Man Page* *Repository*: [https://www.unix.com/man-page-repository.php](https://www.unix.com/man-page-repository.php)).'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 这绝对不是一个详尽的列表，也不是试图成为。还有很多其他的命令，也许找到它们最好的地方是 *Man 页面存储库*：[https://www.unix.com/man-page-repository.php](https://www.unix.com/man-page-repository.php))。
- en: 'But, of all of them, `man` might be the one to remember most. That’s because
    it’s a command that can give you information about *other* commands! For example,
    if you forget what the syntax of the `cp` command is – syntax being the form and
    structure of the command and any information you might have to provide to it –
    you can simply execute `man cp` to get that information, as you can see in *Figure
    4**.11*:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，在所有这些命令中，`man` 可能是你要记住的最重要的一个。这是因为它是一个可以给你提供关于 *其他* 命令信息的命令！例如，如果你忘记了 `cp`
    命令的语法——语法是指命令的形式和结构以及你可能需要提供给它的任何信息——你只需执行 `man cp` 来获取这些信息，就像你在 *图 4.11* 中看到的那样：
- en: '![Figure 4.11: The output of executing man cp](img/B18315_04_11.jpg)'
  id: totrans-286
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11：执行 man cp 的输出](img/B18315_04_11.jpg)'
- en: 'Figure 4.11: The output of executing man cp'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：执行 man cp 的输出
- en: Here, you can see how you are provided with information about how to use the
    command, including a brief description of its purpose, some examples of its syntax,
    and the various options it supports. More is given for this command than you can
    see in a static image on the page, but when using `man` for real, you can continue
    to scroll through the documentation, which can be quite long for some commands,
    while rather short for others – it all depends on what the command is and everything
    it can do.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到你提供了有关如何使用该命令的信息，包括其目的的简要描述、一些语法示例以及它支持的各个选项。对于这个命令，页面上给出的信息比静态图像中看到的要多，但在实际使用
    `man` 时，你可以继续滚动文档，对于某些命令来说，文档可能相当长，而对于其他命令来说则相当短——这完全取决于命令是什么以及它能做什么。
- en: Security and the one “weird” Linux fact you need to know
  id: totrans-289
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安全性和你需要知道的 Linux 一个“奇怪”事实
- en: Linux is, at its core, very security-conscious. It is also at its core a multi-user
    system. Every file and directory is owned by a specific user and user group, and
    a user who doesn’t own a file or isn’t in an appropriate group cannot access it.
    Linux has a robust system of permissions, which is to say the various rights a
    user or group has for a file or directory. You can give users the right to read
    a file but not edit it, for example. The ability to run a file – assuming it’s
    a program of some sort – is its own right, meaning you might be able to read and
    edit a program file but not execute it.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: Linux 在其核心是非常注重安全的。它也是一个多用户系统。每个文件和目录都属于特定的用户和用户组，一个不拥有文件或不在适当组中的用户无法访问它。Linux
    有一个强大的权限系统，也就是说用户或组对文件或目录的各种权利。例如，你可以给用户读取文件的权利但不允许编辑它。运行文件的能力——假设它是一种程序——是其自身的权利，这意味着你可能能够读取和编辑程序文件但不能执行它。
- en: Permissions are hierarchical as well, meaning that you can be granted rights
    to a directory, which then filters down to the directories and files under it
    by default (though you can alter the rights for a specific file or subdirectory
    too). This allows for very granular control over access rights for various users,
    making it safe for them to work on the same system without risking conflicting
    with one another.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 权限也是分层的，这意味着你可以被授予对目录的权限，这些权限默认情况下会向下过滤到其下的目录和文件（尽管你也可以更改特定文件或子目录的权限）。这允许对各种用户的访问权限进行非常细粒度的控制，使得他们在同一系统上工作而不会相互冲突变得安全。
- en: The one exception to all this security stuff is the special root user. This
    user is, in a sense, the god of the machine. The root user can do anything, to
    any file or directory, at any time. There is always a root user account, although
    sometimes, it may not be usable by any human user. This is necessary because some
    operations are so core to Linux itself that no other user *should* be able to
    do it. Or it should be very limited at the least. In such cases, Linux offers
    the ability to temporarily “switch” to the root user, meaning you can, as a regular
    old user, execute a specific command as if you were the root user, assuming you’ve
    been granted special rights to do that. This allows high-level system management
    tasks to be available to users as needed but in a very tightly controlled fashion.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些安全问题的例外是特殊的root用户。这个用户在某种程度上是机器的神。root用户可以随时对任何文件或目录做任何事情。始终存在root用户账户，尽管有时可能没有人能使用它。这是必要的，因为有些操作对于Linux本身来说非常核心，其他用户*不应该*能够执行它们。至少，它们应该非常有限。在这种情况下，Linux提供了临时“切换”到root用户的能力，这意味着你作为一个普通用户，可以执行一个特定的命令，就像你是root用户一样，前提是你已被授予执行该操作的特殊权限。这允许在需要时将高级系统管理任务提供给用户，但以一种非常严格控制的模式。
- en: I’ve mentioned files several times, and surely you know what files are because
    they’re no different from any other operating system, but Linux has one fact that
    is a little weird when you first encounter it – everything in Linux is a file.
    And when I say everything, I mean (almost) *everything*.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经多次提到文件，你肯定知道什么是文件，因为它们与其他任何操作系统没有区别，但当你第一次接触Linux时，会发现一个有点奇怪的事实——Linux中的一切都是文件。当我说是（几乎）一切时，我的意思确实是这样的。
- en: In Linux, “everything is a file” means that the operating system allows you
    to work with things that aren’t files the same way you do actual files. To put
    it another way, it’s the idea that Linux handles input and output to and from
    resources such as hard drives, modems, keyboards, printers, and other system resources
    and devices as streams of data exposed through the filesystem, as if they were
    files on that filesystem.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在Linux中，“一切皆文件”意味着操作系统允许你以处理实际文件相同的方式处理那些不是文件的事物。换句话说，这是Linux将输入和输出到诸如硬盘、调制解调器、键盘、打印机和其他系统资源及设备视为通过文件系统暴露的数据流，就像它们是该文件系统上的文件一样。
- en: The consequence of this is that not only can actual files be interacted with
    from the command line or other programs using file operations such as reading
    and writing, but so can directories, system information, hardware devices, and
    even some system processes. For example, accessing a device such as a printer
    might involve writing data to a file that represents the printer, which will cause
    the printer to physically print that data on a piece of paper. Or you might read
    from a file representing the system’s memory usage to see how much free memory
    you have. This design makes programming and resource management more uniform and
    simpler since you don’t need to use any special methods to deal with hardware
    devices and system resources, and you can use all the same commands and utilities
    as you would with regular files.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这种做法的后果是，不仅可以通过命令行或其他程序使用文件操作（如读取和写入）与实际文件进行交互，还可以与目录、系统信息、硬件设备以及一些系统进程进行交互。例如，访问打印机等设备可能涉及向代表打印机的文件写入数据，这将导致打印机在纸上物理打印这些数据。或者你可能从代表系统内存使用的文件中读取，以查看你有多少空闲内存。这种设计使得编程和资源管理更加统一和简单，因为你不需要使用任何特殊方法来处理硬件设备和系统资源，你可以使用与常规文件相同的所有命令和实用程序。
- en: Now that you have a (very) broad idea of what Linux is all about, let’s talk
    about why it’s even important to know about for a web developer.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 既然你对Linux有了（非常）广泛的了解，让我们来谈谈为什么对于一个网络开发者来说了解Linux甚至很重要。
- en: Linux for web developers
  id: totrans-297
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 网络开发者的Linux
- en: With Linux being so commonly used for servers, that means knowing Linux is a
    valuable thing for a web developer. Now, to be clear, there is knowing Linux and
    then there’s *knowing* Linux. A web developer probably doesn’t need to be a stone-cold
    Linux expert like, say, a server administrator does; those folks must have very
    deep knowledge of the system and how to work with it, and that simply takes a
    lot of time and experience. Certainly, as a web developer, the more you know the
    better, but you can start slowly with just some basics, and that’ll be sufficient
    so that you aren’t lost.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Linux 在服务器上被广泛使用，这意味着了解 Linux 对于网络开发者来说是一笔宝贵的财富。现在，为了清楚起见，了解 Linux 和 *真正了解*
    Linux 是两回事。网络开发者可能不需要像服务器管理员那样成为一个冷酷的 Linux 专家；这些人必须对系统及其操作有非常深入的了解，而这需要大量的时间和经验。当然，作为一个网络开发者，你了解得越多越好，但你可以从一些基础知识开始慢慢学习，这样你就不会迷失方向。
- en: Fortunately, getting your feet wet with Linux is pretty easy. Several websites
    will let you run Linux in your browser or will connect you to a Linux instance
    on the server that you can then interact with through your browser. Either way,
    you’ll get a command-line interface right there in your browser, with no need
    to install Linux on your machine!
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，在 Linux 中入门相当容易。有几个网站允许你在浏览器中运行 Linux，或者将你连接到服务器上的 Linux 实例，然后你可以通过浏览器与之交互。无论哪种方式，你都会在浏览器中获得一个命令行界面，无需在你的机器上安装
    Linux！
- en: 'One good option for playing with Linux like this is [https://bellard.org/jslinux](https://bellard.org/jslinux).
    Here, you can choose from several distros and have them running in your browser,
    as you can see in *Figure 4**.12*:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里像这样玩 Linux 的一个好选项是 [https://bellard.org/jslinux](https://bellard.org/jslinux)。在这里，你可以选择几个发行版，并在浏览器中运行它们，正如你在
    *图 4.12* 中可以看到的。12*：
- en: '![Figure 4.12: Alpine Linux running in your browser, courtesy of JavaScript/Linux](img/B18315_04_12.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12：在浏览器中运行的 Alpine Linux，由 JavaScript/Linux 提供](img/B18315_04_12.jpg)'
- en: 'Figure 4.12: Alpine Linux running in your browser, courtesy of JavaScript/Linux'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：在浏览器中运行的 Alpine Linux，由 JavaScript/Linux 提供
- en: 'I strongly suggest taking some time to play around here – it’s not like you
    can do any harm! To get you started with some basics, start by executing the following
    command:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 我强烈建议花些时间在这里玩玩——你不可能造成任何伤害！为了让你开始学习一些基础知识，首先执行以下命令：
- en: '[PRE20]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The `cd` command stands for *change directory*. Here, you’re navigating to the
    **root directory**, which is the parent to all the others on the system.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: '`cd` 命令代表 *更改目录*。在这里，你正在导航到 **根目录**，它是系统上所有其他目录的父目录。'
- en: 'To see what’s in that directory, execute this command:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看该目录的内容，请执行以下命令：
- en: '[PRE21]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `ls` command is short for *list*, as in *list directory contents*. Here,
    the `-lha` options each tell `ls` that you want the listing shown a specific way.
    The `l` option tells it you want a long listing, meaning it shows more details.
    The `h` option tells it you want all numbers shown in a more human-readable form
    (4k for a file size instead of 4,096, for example), and the `a` option tells it
    not to hide entries that begin with a period, which denotes hidden files and directories.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: '`ls` 命令的缩写是 *list*，即 *列出目录内容*。在这里，`-lha` 选项中的每一个都告诉 `ls` 你希望以特定的方式显示列表。`l`
    选项告诉它你想要一个长列表，这意味着它会显示更多细节。`h` 选项告诉它你希望所有数字以更易于阅读的形式显示（例如，文件大小为 4k 而不是 4,096），而
    `a` 选项告诉它不要隐藏以点开头的条目，这表示隐藏的文件和目录。'
- en: 'Next, navigate to your home directory, which is a directory every Linux user
    gets by default, with this command:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，使用以下命令导航到你的主目录，这是每个 Linux 用户默认获得的目录：
- en: '[PRE22]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The tilde character is a special one that Linux knows means you want to go to
    your home directory. Normally, when you use the `cd` command, you have to specify
    the full directory path, either starting from the root directory or the current
    directory. But navigating to your home directory is such a common thing that Linux
    provides this helpful shortcut.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 波浪字符是一个特殊的字符，Linux 知道这意味着你想要进入你的主目录。通常，当你使用 `cd` 命令时，你必须指定完整的目录路径，要么从根目录开始，要么从当前目录开始。但是导航到你的主目录是一件如此常见的事情，以至于
    Linux 提供了这个有用的快捷方式。
- en: 'However, the tilde isn’t the real directory path – it’s just a shortcut. To
    see the real path, use this command:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，波浪号并不是真正的目录路径——它只是一个快捷方式。要查看真正的路径，请使用以下命令：
- en: '[PRE23]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `pwd` command stands for *print working directory*. The value you see will
    always be `/home/<your username>`. Your username will usually be determined by
    the administrator of the machine (in the case of one of the online Linux playgrounds,
    a user will almost certainly be created when Linux starts up). Of course, if you
    set Linux up yourself, then you will have chosen the username as part of the setup
    process.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: '`pwd`命令代表*打印工作目录*。你看到的值始终是`/home/<你的用户名>`。你的用户名通常由机器管理员确定（在在线Linux游乐场的情况下，当Linux启动时，几乎肯定会创建一个用户）。当然，如果你自己设置了Linux，那么你将在设置过程中选择用户名。'
- en: 'Next, let’s create a file:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个文件：
- en: '[PRE24]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Execute a directory listing again (and maybe this time just execute `ls` without
    any options to see the difference) and you’ll now see a new file named `my_file`.
    There are many ways to edit files in Linux and many ways to get content into a
    file, so let’s try perhaps the simplest way:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 再次执行目录列表（这次可能只需执行`ls`而不带任何选项以查看差异）现在你会看到一个名为`my_file`的新文件。在Linux中编辑文件和将内容放入文件的方法有很多，所以让我们尝试最简单的方法：
- en: '[PRE25]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The string in quotes will be written into the file (*echoed* to it). To see
    that it has, you can list the contents of the file like so:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 引号中的字符串将被写入文件（*回显*到它）。要查看这一点，你可以像这样列出文件的内容：
- en: '[PRE26]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The `cat` command is short for *concatenate*, but it also is used to print to
    the standard output, which is the screen where the command prompt itself is. So,
    `cat my_file` outputs the contents of the file to the screen, and you should see
    the string in quote in it when you do.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`cat`命令代表*连接*，但它也用于打印到标准输出，即命令提示符所在的屏幕。因此，`cat my_file`会将文件内容输出到屏幕，当你这样做时，你应该会看到其中的引号字符串。'
- en: The last thing I’ll touch on is users and permissions. Earlier, I mentioned
    that every user of a Linux system gets a home directory. Every unique user on
    the system will not only have a home directory but a user account. Linux, and
    Unix, which it’s based on, is inherently a multi-user system, and it’s these user
    accounts – and the rights they have – that allow the system to be shared. No other
    user of the system is allowed to touch the contents of your home directory unless
    you specifically allow them to.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我要讨论的最后一件事是用户和权限。之前我提到，Linux系统的每个用户都会得到一个家目录。系统上的每个唯一用户不仅会有一个家目录，还会有一个用户账户。Linux及其基础Unix本质上是多用户系统，正是这些用户账户以及它们拥有的权利使得系统可以被共享。除非你明确允许，否则系统上的其他用户不允许触摸你的家目录的内容。
- en: 'If you list the directory contents again using the `-lha` option, one of the
    things you’ll see, in the second and third column of data, is the owner of the
    file and the primary group name, respectively. The meaning of the owner of the
    file should be obvious: it’ll be your *username*! Since you created the file,
    you own it and you can do whatever you like with it. However, anyone in the same
    user group, denoted by the third column, can also access the file.'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次使用`-lha`选项列出目录内容，你会在数据的第二列和第三列看到一些内容，分别是文件的所有者和主要组名。文件所有者的含义应该是显而易见的：它将是你的*用户名*！由于你创建了文件，所以你拥有它，你可以随意处理它。然而，同一用户组的任何人（由第三列表示），也可以访问该文件。
- en: Groups are a way users can be organized in Linux for easier administration.
    When you create the file, the group may well be the same as your username. That
    simply means that on this particular Linux system, by default, a group is created
    for each user, named the same as the username. Since no one else will be in that
    group, it means that the file is truly only accessible by the user. In a way,
    it means that the group is irrelevant in this case.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 组是用户在Linux中组织以便更容易管理的一种方式。当你创建文件时，组可能正好与你的用户名相同。这意味着在这个特定的Linux系统中，默认情况下，为每个用户创建一个与用户名相同的组。由于没有人会在这个组中，这意味着文件真正只能由用户访问。从某种意义上说，这意味着在这种情况下组是不相关的。
- en: 'If you want to give ownership to another user, there’s a command for that:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要将所有权赋予另一个用户，有一个命令可以做到这一点：
- en: '[PRE27]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `chown` command stands for change owner. After executing it, you will no
    longer be able to access the file yourself since the username specified in the
    command will own it (you typically wouldn’t do this in your home directory, but
    you definitely can).
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: '`chown`命令代表更改所有者。执行后，你将无法再自己访问该文件，因为命令中指定的用户名将拥有它（你通常不会在主目录中这样做，但你绝对可以）。'
- en: 'You can’t allow a specific user the ability to edit your file, but what you
    can do is give anyone in the group the ability to do so:'
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能允许特定用户编辑你的文件的能力，但你所能做的是给组中的任何人这样的能力：
- en: '[PRE28]'
  id: totrans-329
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `chmod` command, short for *change mode*, means to change the access mode,
    or permissions, of something. This command can take a wide range of options in
    several forms, but in this example, `g+w` simply means to add (`+`) the write
    (`w`) permission to the primary group (`g`). After that, anyone in that group
    will be able to edit the file.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '`chmod`命令，简称“更改模式”，意味着更改某物的访问模式或权限。这个命令可以接受多种形式的广泛选项，但在这个例子中，`g+w`仅仅意味着向主要组（`g`）添加（`+`）写（`w`）权限。之后，该组中的任何人都可以编辑文件。'
- en: A couple of times now, I said that only you, by default, will be able to edit
    your file, but that’s not 100% true. You should also be aware that there is always
    a user named root on a Linux system. This is, in a sense, the god of the machine.
    The root user can do everything at all times and the root user account is meant
    for the administrator(s) of the machine.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前说过，默认情况下只有你自己能编辑你的文件，但这并不完全正确。你也应该知道，Linux系统中始终有一个名为root的用户。从某种意义上说，这是机器的神。root用户可以随时做任何事情，root用户账户是为机器的管理员（们）准备的。
- en: However, even administrators will often log into the system as regular, non-root
    users, meaning they have no special privileges. This is an important security
    maxim known as the principle of least privilege. This means that a user should
    have the rights necessary to perform their duties, and no more. However, an administrator
    needs to have greater rights, so what they are allowed to do is *elevate* their
    privileges *temporarily*.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使是管理员也经常以普通、非root用户身份登录系统，这意味着他们没有特殊权限。这是一个重要的安全原则，称为最小权限原则。这意味着用户应该拥有完成其职责所需的权利，而无需更多。然而，管理员需要更大的权利，所以他们允许的是**临时提升**他们的权限。
- en: 'To execute privileged commands, they have to use a special command:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 要执行特权命令，他们必须使用一个特殊的命令：
- en: '[PRE29]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The `sudo` command stands for `super user do`, and it means “Hey, Linux, if
    I’m allowed, I want to execute this command as if I was the root user.” The system
    will maintain a list of commands that each user is allowed to execute with `sudo`,
    and doing so is the same as executing that command if they were logged in as root,
    but only for as long as it takes to execute the command. That’s the key. Note
    that you may not be able to experiment with `sudo` with an online Linux playground,
    but it’s an important concept to be aware of because even non-administrators will
    often have access to some degree of elevated privileges through `sudo`, and it’s
    commonly needed to get your work done on Linux.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: '`sudo`命令代表“超级用户执行”，意思是“嘿，Linux，如果允许的话，我想以root用户身份执行这个命令。”系统会维护一个列表，列出每个用户可以使用`sudo`执行的命令，这样做等同于以root用户登录时执行该命令，但仅限于执行命令所需的时间。这就是关键。请注意，你可能无法在一个在线Linux沙盒中实验`sudo`，但这是一个需要了解的重要概念，因为即使是非管理员也常常可以通过`sudo`获得一定程度的提升权限，这在Linux上完成工作通常是必需的。'
- en: And with that, we’ve covered the “non-code,” so to speak, topics for this chapter.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，我们可以说我们已经涵盖了这一章的“非代码”主题。
- en: Reviewing the roadmap
  id: totrans-337
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回顾路线图
- en: 'With this chapter concluded, we can now show a few more squares in our web
    developer roadmap:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 本章结束后，我们现在可以在我们的网络开发者路线图中展示一些更多的方块：
- en: '![Figure 4.13: The roadmap, with a few more boxes filled in](img/B18315_04_13_NEW.jpg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![图4.13：路线图，填入了一些更多的框](img/B18315_04_13_NEW.jpg)'
- en: 'Figure 4.13: The roadmap, with a few more boxes filled in'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.13：路线图，填入了一些更多的框
- en: Well now, that’s starting to fill out nicely, isn’t it? This chapter revealed
    the **Source Control**, **Security**, and **Linux** boxes. It also built on a
    few others, including networking and developer tooling. We’re moving right along!
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在内容开始变得丰富起来，不是吗？这一章揭示了**源代码控制**、**安全性**和**Linux**这些框。它还建立了一些其他内容，包括网络和开发者工具。我们正在稳步前进！
- en: Summary
  id: totrans-342
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we touched on several topics that are of large importance to
    web developers, but which aren’t explicitly about writing code. This included
    SCM – primarily in the form of Git, Linux, secure coding practices, and IDEs.
    You saw how SCM is a key component of your web development workflow, how IDEs
    can make your life a lot easier in that work, how thinking about security from
    the ground up when writing code is of paramount importance, and how Linux is the
    one operating system to rule them all, one operating system to find them, one
    operating system to bring them all and in the darkness bind them (sorry, I’m a
    geek – I couldn’t resist the cheap Lord of the Rings reference!).
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们提到了几个对网络开发者来说非常重要的主题，但它们并不直接涉及编写代码。这包括源代码管理（SCM）——主要是以Git的形式，Linux，安全的编码实践和集成开发环境（IDE）。你看到了源代码管理是如何成为你网络开发工作流程的关键组成部分，IDE是如何使你的工作变得更容易，思考在编写代码时从底层考虑安全性是多么重要，以及Linux是如何统治所有操作系统的，一个操作系统去寻找它们，一个操作系统将它们全部带来，并在黑暗中将它们束缚（抱歉，我是个极客——我忍不住要引用《指环王》的廉价引用！）。
- en: In the next chapter, we’ll continue looking at some things that continue the
    theme of this chapter – that is, topics that you’ll need to know about that may
    not directly be code (but of course, it’s *all* about the code in *some* fashion
    ultimately). This includes the famous term “the cloud,” virtual machines and containers,
    DevOps (whatever that is!), Python, graphic design, UX, and responsive design.
    Let’s keep pushing this boulder up the hill, shall we?
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨一些延续本章主题的内容——也就是说，一些你可能需要了解但并非直接与代码相关的话题（当然，最终它们都以某种形式与代码有关）。这包括著名的术语“云”，虚拟机、容器，DevOps（无论那是什么！），Python，图形设计，用户体验（UX）和响应式设计。让我们继续把这块巨石推上山，好吗？
