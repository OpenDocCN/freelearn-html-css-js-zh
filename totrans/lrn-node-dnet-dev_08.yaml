- en: Chapter 8. Mastering Asynchronicity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Our JavaScript primer ([Chapter 3](part0022.xhtml#aid-KVCC1 "Chapter 3. A JavaScript
    Primer"), *A JavaScript Primer*) covered all the important concepts to let us
    start building our application. But there is one fundamental aspect of JavaScript
    programming worth exploring in more detail: asynchronicity.'
  prefs: []
  type: TYPE_NORMAL
- en: '[Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Why Node.js?"), *Why Node.js?*,
    discussed the asynchronous programming model of Node.js. It described the consistent
    approach used throughout Node.js APIs and third-party libraries. Recall that each
    asynchronous method takes a callback function that gets passed error and result
    arguments, for example, the `fs.stat` function we saw in [Chapter 1](part0014.xhtml#aid-DB7S2
    "Chapter 1. Why Node.js?"), *Why Node.js?*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: However, the callback pattern has some weaknesses. Performing error handling
    and combining results from multiple asynchronous operations can become quite clumsy.
    There are alternative asynchronous patterns available in JavaScript that address
    these issues. The idea of multiple competing patterns might seem worrying in itself,
    though. Having a single consistent approach was one of the benefits of Node.js
    discussed in [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Why Node.js?"),
    *Why Node.js?*.
  prefs: []
  type: TYPE_NORMAL
- en: We should also revisit the idea of Node.js APIs and libraries being asynchronous
    throughout. We need to consider how this applies to our own code. This is not
    just something we need to worry about if writing a module for use by a third-party.
    Even within our own applications, most modules will need to expose their functionality
    through an asynchronous interface. If not, we severely limit the freedom of how
    we implement these modules.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing asynchronous interfaces to our own modules
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Observing some of the weaknesses of the callback pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Refactoring away from callbacks to make our asynchronous code more readable
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Seeing how we can still benefit from the consistency of Node.js's asynchronous
    programming model
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the callback pattern for asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s look at one of the methods from our games service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The interface of this function is synchronous: you call it and get a value
    back. [Chapter 4](part0025.xhtml#aid-NQU21 "Chapter 4. Introducing Node.js Modules"),
    *Introducing Node.js Modules*, introduced the games service as the module responsible
    for how we store our games. The interface shouldn''t need to change if we change
    the storage implementation. This isn''t quite the case at the moment, though.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As discussed before, most Node.js libraries are asynchronous. Synchronous interfaces
    can''t make use of asynchronous implementations. Let''s say the `get` function
    wants to make use of an asynchronous method in a third-party `datastore` library.
    What would that look like? The comments in the following (non-working) code describe
    the problem:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This is a problem in general, not just in JavaScript. In other platforms, you
    could delay returning until the asynchronous operation has completed. This turns
    an asynchronous operation into a blocking operation. In Node.js (and other JavaScript
    environments), blocking in this way is not an option. It would be incompatible
    with the single-threaded, non-blocking, event-driven execution model.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing the callback pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To allow our games service to be able to make use of asynchronous libraries,
    we need to give it an asynchronous interface. Note that almost all libraries in
    the Node.js ecosystem are asynchronous. If they weren't, they would be limited
    in the same way as our games service currently is.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can rewrite the interface of our `get` function to follow the standard asynchronous
    callback pattern. Let''s see what effect this has on using an asynchronous third-party
    `datastore` library (again, this is non-working code, with a fictional `datastore`
    object):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, in this case we could simplify the preceding code as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'In general, though, we might want to do some more processing of the result
    from a third-party library. So our function might look more like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Assuming `processResult` is internal to our module, it's fine for it to have
    a synchronous interface for now. If it needs to do asynchronous work later, we
    can change its interface without affecting the consumers of our module.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our games service module''s *public* interface does need to be entirely asynchronous,
    though. We''re not actually changing the implementation of the module yet. This
    makes updating the interface quite straightforward. We can make the following
    changes in `src/services/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that this is slightly unrealistic, though. Control would normally return
    to the caller before an asynchronous method completes. We can achieve this by
    using `process.nextTick` to schedule the execution of the callback on the next
    tick of the event loop (refer to [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Why
    Node.js?"), *Why Node.js?*, if you want a refresher on the event loop):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Updating the rest of our application to consume this asynchronous interface
    is a trickier task. This is why it is worth always writing module interfaces to
    be asynchronous from the start. We should definitely address this before expanding
    our application any further.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming asynchronous interfaces
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The games service is called by the games route, the index route, and by our
    tests. Let''s look at the corresponding changes to each of these in turn. The
    following code is from `src/routes/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the changes are straightforward. Each call to a games service
    function now passes in a callback. The callback contains the logic that used to
    follow the call to the games service function. Each callback also needs to handle
    the possibility of an error value. In this case, we simply pass it to the Express
    `next` callback so it will be handled by our global error handler.
  prefs: []
  type: TYPE_NORMAL
- en: 'Although these changes are straightforward, they have introduced some repetitive
    boilerplate to our code. This is even more of a problem in the index route; take
    a look at the code from `src/routes/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, we need to combine the result of two different asynchronous calls. This
    leads to nested callbacks. We also have to repeat the error-handling code at each
    stage. Note also that we only start the second asynchronous operation after the
    first one completes. It would be better to start the operations in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Recall that, while JavaScript itself is single-threaded, asynchronous operations
    may perform work in parallel, for example, network, disk, and other I/O operations.
    Running multiple operations in parallel would need even more complicated (and
    error-prone) boilerplate code. For an example of how this might work, consider
    the changes to make the `beforeEach` function in the games service test asynchronous.
    The following code is from `src/test/services/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we need to make an unknown number of calls to the asynchronous remove
    method. The `done` callback must be invoked when they are all complete. There
    are several ways of achieving this, but they all involve additional boilerplate.
    The approach here is the simplest possible, keeping count of the number of complete
    operations. Also note that we are omitting error handling, since this is test
    code. In production code, we would have to worry about error handling as well,
    making things even more complicated.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are other changes to the tests to make use of the new asynchronous interface
    of the games service. They are excluded here for brevity. They are similar to
    the changes in `index.js`. You can see a full set of changes by viewing this chapter's
    first commit in the Git repository at [https://github.com/NodeJsForDevelopers/chapter08](https://github.com/NodeJsForDevelopers/chapter08).
  prefs: []
  type: TYPE_NORMAL
- en: This all seems quite unsatisfactory. Our code has become more complicated, repetitive,
    and harder to read. Fortunately, we can address these issues by using a different
    approach to writing asynchronous code.
  prefs: []
  type: TYPE_NORMAL
- en: Writing cleaner asynchronous code using promises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Promises** are an alternative pattern to callbacks for writing asynchronous
    code. A promise represents an operation that hasn''t completed yet but is expected
    to do so in the future. As the name *promise* suggests, a promise is a contract
    to eventually provide a value or a reason for failure (that is, an error). You
    may already be familiar with this pattern from Tasks in .NET or Futures in Java.
    A promise has three possible states:'
  prefs: []
  type: TYPE_NORMAL
- en: '**pending** represents an in-progress operation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**fulfilled** representing a successful operation, with a result value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**rejected** representing an unsuccessful operation, with a failure reason'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When executing a single operation, the callback-based and promise-based approaches
    appear quite similar. The power of promises comes when combining asynchronous
    operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider an example where we have asynchronous library functions for obtaining,
    processing, and aggregating data. We want to perform these operations in turn
    then display the result, handling errors as we go. Using callbacks, it might look
    like this (in non-runnable, fictional code):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'This has many of the same problems we encountered in our own code in the previous
    section: nested callbacks, extra boilerplate, and repetitive error-handling. If
    these functions instead returned promises, the equivalent of the above code would
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `then` function applies a function to the resulting value of a promise,
    returning a new promise. In this way, we construct a chain of promises representing
    a series of operations.
  prefs: []
  type: TYPE_NORMAL
- en: The `then` function takes two arguments, which are both callbacks. If the asynchronous
    operation returns an error, the second argument will be invoked instead. In the
    above example, if the `library.aggregateData` call fails, then we will log an
    error.
  prefs: []
  type: TYPE_NORMAL
- en: If the second `then` callback parameter is omitted, any errors propagate along
    the chain of promises. In the above example, this means that if the `library.processData`
    call fails, then `library.aggregateData` will not be called and our error-logging
    callback will still be invoked.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you only care about the error case, you can just specify an error callback
    using the `catch` function instead of `then`. You can also use this together with
    propagation to rewrite the preceding code more clearly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Here, errors at any point propagate to a final promise which we check for errors.
    Note that this rewritten version would also catch any errors thrown by our success-logging
    callback, which the preceding version would not have done. You should always call
    `catch` at the end of a promise chain, unless you are returning the resulting
    promise object to be consumed elsewhere.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing promise-based asynchronous code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s apply the promise pattern to our existing application. First, we''ll
    need to update our game service API to expose promises instead of callbacks. As
    before, this is straightforward since our game service doesn''t actually use any
    asynchronous operations in its implementation (yet). A promised-based version
    of our games service looks like the following (in `src/services/games.js`):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating a promise-based interface is even simpler than a callback-based one.
    We can create a promise for an already known value using the `Promise.resolve()`
    function. Each function in our games service looks much like the original synchronous
    version, just with an extra call to `Promise.resolve`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you pass a promise argument to `Promise.resolve`, then you get back a promise
    that behaves like the original argument. If you pass any other value, you get
    an already resolved promise for that value. This can be useful if you need to
    operate on a variable that might be a promise or a value. You can pass it to `Promise.resolve`,
    then treat it consistently as a promise.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the promise pattern
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we need to update the rest of our codebase to use promises. Let''s look
    through the same files as before, starting with the games route. See the following
    code from `src/routes/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'This file was the simplest before, so shows the least difference here. We still
    have a little repetition of boilerplate (for example, the `catch` call). Still,
    the promise-based approach is more compact and readable than with callbacks. Now
    let''s look at the index route code from `src/routes/index.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: This is a little better. There is less repetition, but still some nesting and
    boilerplate. Note that the outermost `then` callback returns a promise (chained
    from `games.availableTo`). When a `then` callback returns a promise, this is effectively
    flattened, so the overall promise returns the value of the inner promise. This
    flattening also applies to the propagation of errors, so we don't need to call
    `catch` on the inner promise explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code is still a little confusing to follow. There is actually a way to
    make it much more readable, which we''ll come back to shortly. Let''s first look
    at the `beforeEach` function in the games service test in the following code from
    `test/service/games.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'This has become much shorter and more linear. Let''s break down what each line
    does:'
  prefs: []
  type: TYPE_NORMAL
- en: '`service.availableTo` returns a promise of an array of games'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first `then` callback uses `array.map` to convert this into a *promise of
    an array of promises* of delete operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The next `then` callback uses `Promise.all` to convert this into a single promise
    for the whole array of delete operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Promise.all` function takes an array of promises and returns a promise
    that resolves when all of the promises in the array have resolved or is rejected
    as soon as any promise in the array is rejected.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The final `then` callback is invoked when the promise returned from `Promise.all`
    resolves, that is, when all the delete operations are complete, and invokes Mocha's
    `done` callback
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that unlike with the callback-based approach, it is also trivial to implement
    error handling. We just pass in the `done` callback as the error handler (second
    argument) to the final `then` call. We can take a similar approach in the tests
    themselves as we've done here with the `beforeEach` callback. Again, the updates
    to the tests are omitted for brevity, but you can find them in the book's companion
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Parallelising operations using promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can also make use of the `Promise.all` function to simplify the index route.
    Recall that our code is invoking the two asynchronous operations one after the
    other. In the callback-based approach, attempting to execute these in parallel
    would have made the code even more complicated. With promises, it actually makes
    our code more readable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: This is shorter and much easier to understand. We kick off two asynchronous
    operations to load data, then make use of the data as soon as both operations
    have completed.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The only slight drawback of the preceding approach is that we have to get each
    of the two values back out of the array by their index. In Node.js v6 or higher,
    we could avoid this and make the code more readable still by using **destructuring**
    to assign two named parameters from the values in the array, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This isn't used in the example above for back-compatibility with Node.js v4\.
    We will discuss destructuring in more detail in [Chapter 14](part0081.xhtml#aid-2D7TI1
    "Chapter 14. Node.js and Beyond"), *Node.js and Beyond*.
  prefs: []
  type: TYPE_NORMAL
- en: Combining asynchronous programming patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Promises allow us to address some of the shortcomings of the callback pattern
    and write more readable code. Now we have a new problem, though. One of the merits
    of Node.js is the consistent approach to asynchronous programming. We seem to
    have negated this by introducing promises as well as the conventional callback
    pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, although native promises are new to ECMAScript 2015, the concept
    is not new. There are many pre-existing libraries that provide their own implementation
    of promises.
  prefs: []
  type: TYPE_NORMAL
- en: 'Fortunately, these competing approaches to asynchronous programming are actually
    very consistent. The biggest value of the consistency in the Node.js-style callback
    pattern comes from the following:'
  prefs: []
  type: TYPE_NORMAL
- en: All library functions are asynchronous (non-blocking) by default
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All asynchronous operations return a single value or an error
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Promises are completely consistent with the above points. There is also excellent
    compatibility between different implementations of promises in JavaScript. This
    is thanks to the Promises/A+ specification ([http://promisesaplus.com](http://promisesaplus.com)).
    This essentially defines the behavior of the `then` method. Any promise library
    you are likely to come across will follow this spec. Native JavaScript promises
    are also designed to be compatible with it. These means that all of these libraries
    and native JavaScript promises are interoperable.
  prefs: []
  type: TYPE_NORMAL
- en: So all libraries using callbacks follow the same convention and all promise
    libraries follow the same specification. The only issue remaining is converting
    between promises and callbacks. There are several promise libraries that can do
    this for us.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you just want to convert a few standard callback functions to promises,
    you can use `denodeify`, which can be installed using npm. Our `fs.stat` example
    from earlier would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: You will also find that many libraries expose functions that can return a promise
    or accept a callback and so can be invoked with either pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have seen how to expose the standard Node.js callback interface
    in our own modules. We have made use of promises to produce more readable asynchronous
    code. Finally, we have seen how we can use promises together with standard Node.js
    callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we can implement our own asynchronous APIs, we can expand on our application
    and start making use of other libraries that provide asynchronous interfaces.
    In the next chapter, we will make use of this to introduce persistent storage
    to our application.
  prefs: []
  type: TYPE_NORMAL
