- en: Chapter 8. Mastering Asynchronicity
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第八章。掌握异步性
- en: 'Our JavaScript primer ([Chapter 3](part0022.xhtml#aid-KVCC1 "Chapter 3. A JavaScript
    Primer"), *A JavaScript Primer*) covered all the important concepts to let us
    start building our application. But there is one fundamental aspect of JavaScript
    programming worth exploring in more detail: asynchronicity.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的JavaScript入门指南([第三章](part0022.xhtml#aid-KVCC1 "第三章。JavaScript入门"))涵盖了所有重要的概念，使我们能够开始构建我们的应用程序。但JavaScript编程的一个基本方面值得更深入地探索：异步性。
- en: '[Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Why Node.js?"), *Why Node.js?*,
    discussed the asynchronous programming model of Node.js. It described the consistent
    approach used throughout Node.js APIs and third-party libraries. Recall that each
    asynchronous method takes a callback function that gets passed error and result
    arguments, for example, the `fs.stat` function we saw in [Chapter 1](part0014.xhtml#aid-DB7S2
    "Chapter 1. Why Node.js?"), *Why Node.js?*:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '[第一章](part0014.xhtml#aid-DB7S2 "第一章。为什么选择Node.js？")，*为什么选择Node.js？*，讨论了Node.js的异步编程模型。它描述了Node.js
    API和第三方库中使用的统一方法。回想一下，每个异步方法都接受一个回调函数，该函数传递错误和结果参数，例如我们在[第一章](part0014.xhtml#aid-DB7S2
    "第一章。为什么选择Node.js？")，*为什么选择Node.js？*中看到的`fs.stat`函数：'
- en: '[PRE0]'
  id: totrans-3
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: However, the callback pattern has some weaknesses. Performing error handling
    and combining results from multiple asynchronous operations can become quite clumsy.
    There are alternative asynchronous patterns available in JavaScript that address
    these issues. The idea of multiple competing patterns might seem worrying in itself,
    though. Having a single consistent approach was one of the benefits of Node.js
    discussed in [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Why Node.js?"),
    *Why Node.js?*.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，回调模式有一些弱点。执行错误处理和组合多个异步操作的结果可能会变得相当笨拙。JavaScript中有一些替代的异步模式可以解决这些问题。多个竞争模式本身可能看起来令人担忧。在[第一章](part0014.xhtml#aid-DB7S2
    "第一章。为什么选择Node.js？")，*为什么选择Node.js？*中讨论的Node.js的一个好处是拥有一个单一的一致方法。
- en: We should also revisit the idea of Node.js APIs and libraries being asynchronous
    throughout. We need to consider how this applies to our own code. This is not
    just something we need to worry about if writing a module for use by a third-party.
    Even within our own applications, most modules will need to expose their functionality
    through an asynchronous interface. If not, we severely limit the freedom of how
    we implement these modules.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还应该重新审视Node.js API和库始终异步这一想法。我们需要考虑这如何应用到我们自己的代码中。这不仅仅是在为第三方编写模块时需要担心的事情。即使在我们的应用程序内部，大多数模块也需要通过异步接口公开其功能。如果不这样做，我们将严重限制我们实现这些模块的自由度。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing asynchronous interfaces to our own modules
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向我们的模块引入异步接口
- en: Observing some of the weaknesses of the callback pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 观察回调模式的某些弱点
- en: Refactoring away from callbacks to make our asynchronous code more readable
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过重构移除回调，使我们的异步代码更易读
- en: Seeing how we can still benefit from the consistency of Node.js's asynchronous
    programming model
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 看看我们如何仍然可以从Node.js异步编程模型的一致性中受益
- en: Using the callback pattern for asynchronous code
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用回调模式进行异步代码
- en: 'Let''s look at one of the methods from our games service:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们游戏服务中的一种方法：
- en: '[PRE1]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The interface of this function is synchronous: you call it and get a value
    back. [Chapter 4](part0025.xhtml#aid-NQU21 "Chapter 4. Introducing Node.js Modules"),
    *Introducing Node.js Modules*, introduced the games service as the module responsible
    for how we store our games. The interface shouldn''t need to change if we change
    the storage implementation. This isn''t quite the case at the moment, though.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数的接口是同步的：你调用它并返回一个值。[第四章](part0025.xhtml#aid-NQU21 "第四章。介绍Node.js模块")，*介绍Node.js模块*，介绍了游戏服务作为负责我们存储游戏的模块。如果我们更改存储实现，接口不需要改变。然而，目前情况并非如此。
- en: 'As discussed before, most Node.js libraries are asynchronous. Synchronous interfaces
    can''t make use of asynchronous implementations. Let''s say the `get` function
    wants to make use of an asynchronous method in a third-party `datastore` library.
    What would that look like? The comments in the following (non-working) code describe
    the problem:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，大多数Node.js库都是异步的。同步接口无法利用异步实现。假设`get`函数想要在第三方`datastore`库中使用异步方法。那会是什么样子？以下（非工作）代码中的注释描述了问题：
- en: '[PRE2]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This is a problem in general, not just in JavaScript. In other platforms, you
    could delay returning until the asynchronous operation has completed. This turns
    an asynchronous operation into a blocking operation. In Node.js (and other JavaScript
    environments), blocking in this way is not an option. It would be incompatible
    with the single-threaded, non-blocking, event-driven execution model.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个普遍存在的问题，不仅仅是在JavaScript中。在其他平台上，你可以延迟返回，直到异步操作完成。这会将异步操作转换为阻塞操作。在Node.js（以及其他JavaScript环境中），这种方式是不可行的。它将与单线程、非阻塞、事件驱动的执行模型不兼容。
- en: Exposing the callback pattern
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 暴露回调模式
- en: To allow our games service to be able to make use of asynchronous libraries,
    we need to give it an asynchronous interface. Note that almost all libraries in
    the Node.js ecosystem are asynchronous. If they weren't, they would be limited
    in the same way as our games service currently is.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的游戏服务能够使用异步库，我们需要给它一个异步接口。请注意，Node.js生态系统中的几乎所有库都是异步的。如果不是，它们将受到与我们的游戏服务当前相同的限制。
- en: 'We can rewrite the interface of our `get` function to follow the standard asynchronous
    callback pattern. Let''s see what effect this has on using an asynchronous third-party
    `datastore` library (again, this is non-working code, with a fictional `datastore`
    object):'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将我们的`get`函数的接口重写为遵循标准的异步回调模式。让我们看看这会对使用异步第三方`datastore`库产生什么影响（再次强调，以下代码是无效的，包含一个虚构的`datastore`对象）：
- en: '[PRE3]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Of course, in this case we could simplify the preceding code as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这种情况下，我们可以将前面的代码简化如下：
- en: '[PRE4]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'In general, though, we might want to do some more processing of the result
    from a third-party library. So our function might look more like this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，通常我们可能想要对第三方库的结果进行更多处理。因此，我们的函数可能看起来更像是这样：
- en: '[PRE5]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Assuming `processResult` is internal to our module, it's fine for it to have
    a synchronous interface for now. If it needs to do asynchronous work later, we
    can change its interface without affecting the consumers of our module.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 假设`processResult`是我们模块内部的一个函数，它现在有一个同步接口是完全可以的。如果它需要稍后执行异步工作，我们可以更改其接口，而不会影响我们模块的消费者。
- en: 'Our games service module''s *public* interface does need to be entirely asynchronous,
    though. We''re not actually changing the implementation of the module yet. This
    makes updating the interface quite straightforward. We can make the following
    changes in `src/services/games.js`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的游戏服务模块的**公共**接口确实需要完全异步。我们还没有真正改变模块的实现。这使得更新接口变得相当直接。我们可以在`src/services/games.js`中做出以下更改：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note that this is slightly unrealistic, though. Control would normally return
    to the caller before an asynchronous method completes. We can achieve this by
    using `process.nextTick` to schedule the execution of the callback on the next
    tick of the event loop (refer to [Chapter 1](part0014.xhtml#aid-DB7S2 "Chapter 1. Why
    Node.js?"), *Why Node.js?*, if you want a refresher on the event loop):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这虽然有些不切实际。通常，在异步方法完成之前，控制权会返回给调用者。我们可以通过使用`process.nextTick`在事件循环的下一次tick上安排回调的执行来实现这一点（如果你想要复习事件循环，请参阅[第1章](part0014.xhtml#aid-DB7S2
    "第1章。为什么Node.js?")，*为什么Node.js?*）：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Updating the rest of our application to consume this asynchronous interface
    is a trickier task. This is why it is worth always writing module interfaces to
    be asynchronous from the start. We should definitely address this before expanding
    our application any further.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 将我们的应用程序的其余部分更新为消费这个异步接口是一个更复杂的任务。这就是为什么始终编写从开始就是异步的模块接口是值得的。我们绝对应该在进一步扩展我们的应用程序之前解决这个问题。
- en: Consuming asynchronous interfaces
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 消费异步接口
- en: 'The games service is called by the games route, the index route, and by our
    tests. Let''s look at the corresponding changes to each of these in turn. The
    following code is from `src/routes/games.js`:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏服务被游戏路由、索引路由以及我们的测试调用。让我们依次查看这些更改。以下代码来自`src/routes/games.js`：
- en: '[PRE8]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: In this case, the changes are straightforward. Each call to a games service
    function now passes in a callback. The callback contains the logic that used to
    follow the call to the games service function. Each callback also needs to handle
    the possibility of an error value. In this case, we simply pass it to the Express
    `next` callback so it will be handled by our global error handler.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，更改很简单。现在对游戏服务函数的每次调用都传递一个回调。回调包含原本跟随游戏服务函数调用的逻辑。每个回调还需要处理错误值的可能性。在这种情况下，我们只需将其传递给Express的`next`回调，这样它就会被我们的全局错误处理器处理。
- en: 'Although these changes are straightforward, they have introduced some repetitive
    boilerplate to our code. This is even more of a problem in the index route; take
    a look at the code from `src/routes/index.js`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些变化很简单，但它们在我们的代码中引入了一些重复的模板代码。在索引路由中，这个问题更为严重；看看`src/routes/index.js`中的代码：
- en: '[PRE9]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, we need to combine the result of two different asynchronous calls. This
    leads to nested callbacks. We also have to repeat the error-handling code at each
    stage. Note also that we only start the second asynchronous operation after the
    first one completes. It would be better to start the operations in parallel.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要合并两个不同异步调用的结果。这导致了嵌套回调。我们还得在每个阶段重复错误处理代码。注意，我们只有在第一个异步操作完成后才开始第二个异步操作。并行启动操作会更好。
- en: 'Recall that, while JavaScript itself is single-threaded, asynchronous operations
    may perform work in parallel, for example, network, disk, and other I/O operations.
    Running multiple operations in parallel would need even more complicated (and
    error-prone) boilerplate code. For an example of how this might work, consider
    the changes to make the `beforeEach` function in the games service test asynchronous.
    The following code is from `src/test/services/games.js`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 回想一下，虽然JavaScript本身是单线程的，但异步操作可以在并行中执行工作，例如网络、磁盘和其他I/O操作。并行运行多个操作需要更复杂的（且容易出错的）模板代码。为了说明这可能如何工作，考虑将游戏服务测试中的`beforeEach`函数变为异步操作所做的更改。以下代码来自`src/test/services/games.js`：
- en: '[PRE10]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Here, we need to make an unknown number of calls to the asynchronous remove
    method. The `done` callback must be invoked when they are all complete. There
    are several ways of achieving this, but they all involve additional boilerplate.
    The approach here is the simplest possible, keeping count of the number of complete
    operations. Also note that we are omitting error handling, since this is test
    code. In production code, we would have to worry about error handling as well,
    making things even more complicated.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们需要对异步的移除方法进行未知数量的调用。当所有调用都完成时，必须调用`done`回调。有几种实现方式，但它们都涉及额外的模板代码。这里的方法是最简单的，通过计数完成操作的次数。另外，请注意，我们省略了错误处理，因为这是测试代码。在生产代码中，我们还需要考虑错误处理，这使得事情变得更加复杂。
- en: Note
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other changes to the tests to make use of the new asynchronous interface
    of the games service. They are excluded here for brevity. They are similar to
    the changes in `index.js`. You can see a full set of changes by viewing this chapter's
    first commit in the Git repository at [https://github.com/NodeJsForDevelopers/chapter08](https://github.com/NodeJsForDevelopers/chapter08).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 测试中还有一些其他的变化，以利用游戏服务的新的异步接口。为了简洁，这里省略了这些变化。它们与`index.js`中的变化类似。您可以通过查看Git仓库中该章节的第一个提交来查看完整的变更集，Git仓库地址为[https://github.com/NodeJsForDevelopers/chapter08](https://github.com/NodeJsForDevelopers/chapter08)。
- en: This all seems quite unsatisfactory. Our code has become more complicated, repetitive,
    and harder to read. Fortunately, we can address these issues by using a different
    approach to writing asynchronous code.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都显得相当令人不满意。我们的代码变得更加复杂、重复，且难以阅读。幸运的是，我们可以通过使用不同的方法来编写异步代码来解决这些问题。
- en: Writing cleaner asynchronous code using promises
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用承诺（promises）编写更干净的异步代码
- en: '**Promises** are an alternative pattern to callbacks for writing asynchronous
    code. A promise represents an operation that hasn''t completed yet but is expected
    to do so in the future. As the name *promise* suggests, a promise is a contract
    to eventually provide a value or a reason for failure (that is, an error). You
    may already be familiar with this pattern from Tasks in .NET or Futures in Java.
    A promise has three possible states:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '**承诺（Promises**）是编写异步代码的回调模式的替代方案。承诺代表一个尚未完成但预期将来会完成的操作。正如其名“承诺”所暗示的，承诺是一个最终提供值或失败原因（即错误）的合同。您可能已经从.NET中的任务或Java中的未来（Futures）中熟悉了这种模式。承诺有三个可能的状态：'
- en: '**pending** represents an in-progress operation'
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**pending** 表示一个进行中的操作'
- en: '**fulfilled** representing a successful operation, with a result value'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**fulfilled** 表示一个成功的操作，带有结果值'
- en: '**rejected** representing an unsuccessful operation, with a failure reason'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**rejected** 表示一个不成功的操作，带有失败原因'
- en: When executing a single operation, the callback-based and promise-based approaches
    appear quite similar. The power of promises comes when combining asynchronous
    operations.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当执行单个操作时，基于回调和基于承诺的方法看起来非常相似。承诺的力量在于组合异步操作。
- en: 'Consider an example where we have asynchronous library functions for obtaining,
    processing, and aggregating data. We want to perform these operations in turn
    then display the result, handling errors as we go. Using callbacks, it might look
    like this (in non-runnable, fictional code):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个例子，我们有一个异步库函数用于获取、处理和聚合数据。我们希望依次执行这些操作，然后显示结果，并在执行过程中处理错误。使用回调，代码可能看起来像这样（以下为不可运行的虚构代码）：
- en: '[PRE11]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This has many of the same problems we encountered in our own code in the previous
    section: nested callbacks, extra boilerplate, and repetitive error-handling. If
    these functions instead returned promises, the equivalent of the above code would
    be as follows:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这与我们之前章节中自己代码中遇到的问题有很多相同之处：嵌套回调、额外的样板代码和重复的错误处理。如果这些函数返回承诺，那么上述代码的等效代码如下：
- en: '[PRE12]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `then` function applies a function to the resulting value of a promise,
    returning a new promise. In this way, we construct a chain of promises representing
    a series of operations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`then`函数将一个函数应用到承诺的结果值上，并返回一个新的承诺。通过这种方式，我们构建了一系列操作表示的承诺链。'
- en: The `then` function takes two arguments, which are both callbacks. If the asynchronous
    operation returns an error, the second argument will be invoked instead. In the
    above example, if the `library.aggregateData` call fails, then we will log an
    error.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`then`函数接受两个参数，这两个参数都是回调。如果异步操作返回错误，则将调用第二个参数。在上面的例子中，如果`library.aggregateData`调用失败，我们将记录一个错误。'
- en: If the second `then` callback parameter is omitted, any errors propagate along
    the chain of promises. In the above example, this means that if the `library.processData`
    call fails, then `library.aggregateData` will not be called and our error-logging
    callback will still be invoked.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果省略了第二个`then`回调参数，任何错误都会沿着承诺链传播。在上面的例子中，这意味着如果`library.processData`调用失败，则不会调用`library.aggregateData`，并且我们的错误日志回调仍然会被调用。
- en: 'If you only care about the error case, you can just specify an error callback
    using the `catch` function instead of `then`. You can also use this together with
    propagation to rewrite the preceding code more clearly:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只关心错误情况，你可以直接使用`catch`函数指定一个错误回调，而不是使用`then`。你还可以结合传播机制来更清晰地重写前面的代码：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Here, errors at any point propagate to a final promise which we check for errors.
    Note that this rewritten version would also catch any errors thrown by our success-logging
    callback, which the preceding version would not have done. You should always call
    `catch` at the end of a promise chain, unless you are returning the resulting
    promise object to be consumed elsewhere.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，任何位置的错误都会传播到最后一个承诺，我们检查是否有错误。请注意，这个重写的版本也会捕获成功日志回调抛出的任何错误，而前面的版本则不会。你应该始终在承诺链的末尾调用`catch`，除非你正在返回结果承诺对象以供其他地方消费。
- en: Implementing promise-based asynchronous code
  id: totrans-61
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现基于承诺的异步代码
- en: 'Let''s apply the promise pattern to our existing application. First, we''ll
    need to update our game service API to expose promises instead of callbacks. As
    before, this is straightforward since our game service doesn''t actually use any
    asynchronous operations in its implementation (yet). A promised-based version
    of our games service looks like the following (in `src/services/games.js`):'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将承诺模式应用到我们现有的应用程序中。首先，我们需要更新我们的游戏服务API，以暴露承诺而不是回调。和之前一样，这很简单，因为我们的游戏服务在实现中实际上并没有使用任何异步操作（目前还没有）。我们的游戏服务的基于承诺的版本如下（在`src/services/games.js`中）：
- en: '[PRE14]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Creating a promise-based interface is even simpler than a callback-based one.
    We can create a promise for an already known value using the `Promise.resolve()`
    function. Each function in our games service looks much like the original synchronous
    version, just with an extra call to `Promise.resolve`.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 创建基于承诺的接口甚至比基于回调的接口更简单。我们可以使用`Promise.resolve()`函数为已知值创建一个承诺。我们游戏服务中的每个函数看起来都和原始的同步版本很相似，只是多了一个调用`Promise.resolve`。
- en: Note
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you pass a promise argument to `Promise.resolve`, then you get back a promise
    that behaves like the original argument. If you pass any other value, you get
    an already resolved promise for that value. This can be useful if you need to
    operate on a variable that might be a promise or a value. You can pass it to `Promise.resolve`,
    then treat it consistently as a promise.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将承诺参数传递给`Promise.resolve`，那么你将得到一个行为与原始参数相同的承诺。如果你传递任何其他值，你将得到一个已解析的承诺，该承诺对应于该值。这在你需要操作可能是一个承诺或值的变量时很有用。你可以将其传递给`Promise.resolve`，然后一致地将其作为承诺处理。
- en: Consuming the promise pattern
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 消费承诺模式
- en: 'Now we need to update the rest of our codebase to use promises. Let''s look
    through the same files as before, starting with the games route. See the following
    code from `src/routes/games.js`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们需要更新我们的代码库的其余部分以使用承诺。让我们看看之前的相同文件，从游戏路由开始。请看以下来自 `src/routes/games.js` 的代码：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This file was the simplest before, so shows the least difference here. We still
    have a little repetition of boilerplate (for example, the `catch` call). Still,
    the promise-based approach is more compact and readable than with callbacks. Now
    let''s look at the index route code from `src/routes/index.js`:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这个文件之前是最简单的，所以这里的变化最少。我们仍然有一些样板代码的重复（例如，`catch` 调用）。尽管如此，基于承诺的方法比回调更紧凑且易于阅读。现在让我们看看来自
    `src/routes/index.js` 的索引路由代码：
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This is a little better. There is less repetition, but still some nesting and
    boilerplate. Note that the outermost `then` callback returns a promise (chained
    from `games.availableTo`). When a `then` callback returns a promise, this is effectively
    flattened, so the overall promise returns the value of the inner promise. This
    flattening also applies to the propagation of errors, so we don't need to call
    `catch` on the inner promise explicitly.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点改进。重复较少，但仍然有一些嵌套和样板代码。注意最外层的 `then` 回调返回一个承诺（从 `games.availableTo` 连接）。当一个
    `then` 回调返回一个承诺时，这实际上会被扁平化，因此整体承诺返回内部承诺的值。这种扁平化也适用于错误的传播，因此我们不需要在内部承诺上显式调用 `catch`。
- en: 'This code is still a little confusing to follow. There is actually a way to
    make it much more readable, which we''ll come back to shortly. Let''s first look
    at the `beforeEach` function in the games service test in the following code from
    `test/service/games.js`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码仍然有点难以理解。实际上有一种方法可以使它更容易阅读，我们稍后会回到这个问题。首先，让我们看看以下来自 `test/service/games.js`
    的游戏服务测试中的 `beforeEach` 函数：
- en: '[PRE17]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This has become much shorter and more linear. Let''s break down what each line
    does:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这已经变得非常短且线性。让我们分析每一行的作用：
- en: '`service.availableTo` returns a promise of an array of games'
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`service.availableTo` 返回一个包含游戏数组的承诺'
- en: The first `then` callback uses `array.map` to convert this into a *promise of
    an array of promises* of delete operations
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个 `then` 回调使用 `array.map` 将其转换为 *包含删除操作承诺的数组承诺*
- en: The next `then` callback uses `Promise.all` to convert this into a single promise
    for the whole array of delete operations
  id: totrans-78
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个 `then` 回调使用 `Promise.all` 将其转换为整个删除操作数组的单个承诺
- en: Note
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `Promise.all` function takes an array of promises and returns a promise
    that resolves when all of the promises in the array have resolved or is rejected
    as soon as any promise in the array is rejected.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`Promise.all` 函数接受一个承诺数组，并在数组中所有承诺都解析或数组中的任何承诺被拒绝时立即拒绝返回一个承诺。'
- en: The final `then` callback is invoked when the promise returned from `Promise.all`
    resolves, that is, when all the delete operations are complete, and invokes Mocha's
    `done` callback
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `Promise.all` 返回的承诺解析时，即所有删除操作完成时，将调用 Mocha 的 `done` 回调
- en: Note that unlike with the callback-based approach, it is also trivial to implement
    error handling. We just pass in the `done` callback as the error handler (second
    argument) to the final `then` call. We can take a similar approach in the tests
    themselves as we've done here with the `beforeEach` callback. Again, the updates
    to the tests are omitted for brevity, but you can find them in the book's companion
    code.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，与基于回调的方法不同，错误处理也非常简单。我们只需将 `done` 回调作为错误处理程序（第二个参数）传递给最终的 `then` 调用。我们可以在测试本身中采取类似的方法，就像我们在
    `beforeEach` 回调中所做的那样。再次提醒，为了简洁，省略了测试的更新，但你可以从书籍的配套代码中找到它们。
- en: Parallelising operations using promises
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用承诺并行化操作
- en: 'We can also make use of the `Promise.all` function to simplify the index route.
    Recall that our code is invoking the two asynchronous operations one after the
    other. In the callback-based approach, attempting to execute these in parallel
    would have made the code even more complicated. With promises, it actually makes
    our code more readable:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以利用 `Promise.all` 函数简化索引路由。回想一下，我们的代码是依次调用两个异步操作。在基于回调的方法中，尝试并行执行这些操作会使代码更加复杂。使用承诺，实际上使我们的代码更易于阅读：
- en: '[PRE18]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This is shorter and much easier to understand. We kick off two asynchronous
    operations to load data, then make use of the data as soon as both operations
    have completed.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这更短，更容易理解。我们启动两个异步操作来加载数据，然后在两个操作都完成后立即使用这些数据。
- en: Tip
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'The only slight drawback of the preceding approach is that we have to get each
    of the two values back out of the array by their index. In Node.js v6 or higher,
    we could avoid this and make the code more readable still by using **destructuring**
    to assign two named parameters from the values in the array, as follows:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 前述方法的唯一小缺点是我们必须通过索引从数组中获取两个值。在 Node.js v6 或更高版本中，我们可以通过使用 **解构** 来从数组中的值分配两个命名参数，从而避免这种情况，并使代码更加易于阅读，如下所示：
- en: '[PRE19]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This isn't used in the example above for back-compatibility with Node.js v4\.
    We will discuss destructuring in more detail in [Chapter 14](part0081.xhtml#aid-2D7TI1
    "Chapter 14. Node.js and Beyond"), *Node.js and Beyond*.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 这在上述示例中没有用于与 Node.js v4 的向后兼容性。我们将在第 14 章（[part0081.xhtml#aid-2D7TI1 "第 14 章.
    Node.js 和更远"]）中更详细地讨论解构，*Node.js 和更远*。
- en: Combining asynchronous programming patterns
  id: totrans-91
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 组合异步编程模式
- en: Promises allow us to address some of the shortcomings of the callback pattern
    and write more readable code. Now we have a new problem, though. One of the merits
    of Node.js is the consistent approach to asynchronous programming. We seem to
    have negated this by introducing promises as well as the conventional callback
    pattern.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺（Promises）使我们能够解决回调模式的一些不足，并编写更易于阅读的代码。然而，我们遇到了一个新的问题。Node.js 的一大优点是它对异步编程的一致性方法。通过引入承诺以及传统的回调模式，我们似乎已经否定了这一点。
- en: Furthermore, although native promises are new to ECMAScript 2015, the concept
    is not new. There are many pre-existing libraries that provide their own implementation
    of promises.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管原生的承诺是 ECMAScript 2015 中的新特性，但这个概念并不新鲜。有许多现有的库提供了它们自己的承诺实现。
- en: 'Fortunately, these competing approaches to asynchronous programming are actually
    very consistent. The biggest value of the consistency in the Node.js-style callback
    pattern comes from the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，这些异步编程的竞争方法实际上非常一致。Node.js 风格回调模式一致性的最大价值来自于以下方面：
- en: All library functions are asynchronous (non-blocking) by default
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有库函数默认都是异步的（非阻塞的）
- en: All asynchronous operations return a single value or an error
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有异步操作都返回单个值或错误
- en: Promises are completely consistent with the above points. There is also excellent
    compatibility between different implementations of promises in JavaScript. This
    is thanks to the Promises/A+ specification ([http://promisesaplus.com](http://promisesaplus.com)).
    This essentially defines the behavior of the `then` method. Any promise library
    you are likely to come across will follow this spec. Native JavaScript promises
    are also designed to be compatible with it. These means that all of these libraries
    and native JavaScript promises are interoperable.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 承诺与上述点完全一致。JavaScript 中不同承诺实现的兼容性也非常好。这要归功于 Promises/A+ 规范（[http://promisesaplus.com](http://promisesaplus.com)）。这本质上定义了
    `then` 方法的行为。你可能会遇到的任何承诺库都将遵循此规范。原生的 JavaScript 承诺也设计为与之兼容。这意味着所有这些库和原生 JavaScript
    承诺都是可互操作的。
- en: So all libraries using callbacks follow the same convention and all promise
    libraries follow the same specification. The only issue remaining is converting
    between promises and callbacks. There are several promise libraries that can do
    this for us.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，所有使用回调的库都遵循相同的约定，所有承诺库都遵循相同的规范。唯一剩下的问题是转换承诺和回调。有几个承诺库可以为我们完成这项工作。
- en: 'If you just want to convert a few standard callback functions to promises,
    you can use `denodeify`, which can be installed using npm. Our `fs.stat` example
    from earlier would look like this:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你只想将几个标准回调函数转换为承诺，可以使用 `denodeify`，它可以通过 npm 安装。我们之前提到的 `fs.stat` 示例将看起来像这样：
- en: '[PRE20]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: You will also find that many libraries expose functions that can return a promise
    or accept a callback and so can be invoked with either pattern.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 你还会发现许多库公开了可以返回承诺或接受回调的函数，因此可以使用任一模式调用。
- en: Summary
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have seen how to expose the standard Node.js callback interface
    in our own modules. We have made use of promises to produce more readable asynchronous
    code. Finally, we have seen how we can use promises together with standard Node.js
    callbacks.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们看到了如何在我们的模块中公开标准的 Node.js 回调接口。我们使用了承诺来生成更易于阅读的异步代码。最后，我们看到了如何结合使用承诺和标准的
    Node.js 回调。
- en: Now that we can implement our own asynchronous APIs, we can expand on our application
    and start making use of other libraries that provide asynchronous interfaces.
    In the next chapter, we will make use of this to introduce persistent storage
    to our application.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们能够实现自己的异步API，我们可以扩展我们的应用程序并开始使用提供异步接口的其他库。在下一章中，我们将利用这一点向我们的应用程序引入持久存储。
