- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Echo Location – Skipping the Page Object Model
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have used the **Page Object Model** (**POM**) to encapsulate the
    UI elements and interactions with a page within an object. We can usually see
    our target objective *clearly* with the XPath or CSS locator, but consider the
    superheroes who get the job done blindly in the dark. While the POM has many merits,
    there are scenarios where finding objects by text alone, in the dark, based on
    some clues, can offer advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Quick prototyping and simplified test creation**: For quick and dirty testing
    or prototyping, it might be overkill to establish a full-fledged POM of thousands
    of objects. In such cases, directly locating elements can speed up the initial
    test development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Handling elements with dynamic content**: In modern web applications, the
    content can be highly dynamic. Elements may not have fixed IDs, classes, or other
    attributes. Text content is often more stable in later releases behind the scenes
    in the DOM.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code readability**: Tests written with direct text queries can sometimes
    be more readable and self-explanatory. Anyone reading the test can understand
    the user interactions being mimicked, without needing to dive into the page objects
    to understand what each method does.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: A reduced code base
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation in plain English
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a visible button, field, and list by name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting a visible element from a collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A reduced code base
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Skipping the POM reduces the amount of code you have to maintain. This can be
    particularly beneficial in smaller projects or proof-of-concept implementations,
    where quick development is more important than long-term maintainability.
  prefs: []
  type: TYPE_NORMAL
- en: While a “text-based” approach has its merits, it’s crucial to note that this
    is not a one-size-fits-all solution. It is intended to remain highly reliable,
    reducing the amount of maintenance required.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will enhance our element location by passing just text.
    Which method is used will provide a clue as to the node types to return for consideration.
    What does it mean if we can just click `setValueAdv("First name", "Paul")` into
    the **First Name** field, or even select **2** from the **Number of** **Guests**
    list?
  prefs: []
  type: TYPE_NORMAL
- en: We will enhance our three custom functions, allowing them to identify elements
    only based on a string. In addition to passing an object, a simple text string
    will be passed to the `clickAdv()`, `setValueAdv()`, and `selectAdv()` methods.
    This way, we can eliminate some of the page objects entirely.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Automation in plain English
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Clicking a named button or link
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Entering text into a named field
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Selecting an item from a named list
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Chasing a rabbit hole more than three layers deep
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Automation in plain English
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will continue to further modify our custom methods by allowing two different
    types of classes to be passed. Our methods still support a `WebdriverIO WebElement`,
    but now, we will enhance them with a string. For example, let’s say we want to
    click the **HALLOWEEN PARTY** button at the top of the CandyMapper site. Consider
    this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – A DevTools view of the HALLOWEEN PARTY link](img/B19395_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – A DevTools view of the HALLOWEEN PARTY link
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the POM approach to find the link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'By using the echo location superpower, this line of code could be smart enough
    to find the proper link with just this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, you could enter an email into a field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'You could also add a total of two guests to accompany you to the party:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we can enhance the method to split along a path that is either an object
    or a string; in this case, we can use our `getValidObject()` to return a collection
    of visible elements that contain the string. In addition, we can deduce the type
    of elements to seek, based on the verb of the action being called. `ClickAdv()`
    will look for buttons, links, and similar elements. `SetValue()` will look for
    input fields or `textarea` nodes. `SelectAdv()` will interact with lists.
  prefs: []
  type: TYPE_NORMAL
- en: Quick tip
  prefs: []
  type: TYPE_NORMAL
- en: While we could extend this to our `assertAdv()` function, it is not recommended.
    The problem is that the `assertAdv()` function with a string would need a lot
    more context. It would be nearly impossible to determine whether we are validating
    a button state, a field value, a list item, or some displayed text. It is better
    to keep this simple and just confirm that the text we seek is visible on the page
    and highlight all potential matches. For anything else, just pass the `WebElement`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Our first step is to extend a code path that will interact with both `WebElement`
    and a string in the `clickAdv()` method. This same process will apply to the `getValidElement()`
    function, which we’ll do in the following section. Lastly, the `SetValueAdv()`
    and `Selectadv()` functions will be modified with their relative sections in `getValidElement()`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a named button
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In each of the three custom functions, we will extend the element types that
    are passed to include strings like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If a string is passed, we will use it to identify a valid element of the type
    passed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we provide a clue that this element will be a button. The same
    will be done next for returning a field to set a value.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a named input field
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The same will be modified for `setValueAdv` in a similar fashion. However,
    we will instruct `getValidElement` to seek out an input or `textarea` field class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As with the last two functions, we will extend `selectAdv()` with a final clue
    string.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a named list
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Finally, `selectAdv()` will be modified as well. The types of elements that
    might match will be listed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Now that these three methods are updated, we need to enhance the `getValidElement()`
    method to return an element that fits each verb type.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a visible button by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The first enhancement in the `getValidElement()` method is to allow a string
    to be passed, as with the three preceding methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The first check that we can perform is to see whether there are *any* elements
    that might match what we seek. In this case, we can leverage both an XPath and
    a CSS locator for a second time. This XPath locator will seek any node that contains
    the text passed to the method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no elements returned, a second attempt will be done with a CSS
    selector using the `href` property. This property often contains the text string
    in a lowercase set, oriented by dashes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we have three types of elements to sort through. Let us deal with each
    one separately, starting with a button for a click:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If this returns no matching element, we can try this case-insensitive approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have a good shot at finding a button based solely on a string passed
    into the function. Let us do the same for input fields and text areas.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a visible field by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we have to gather a collection of fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'If there are no matches, we will take a second shot at finding text areas relative
    to a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Finally, we will do the same for a collection of lists.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a visible list by name
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Next, we will try to find a list element based on the text:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'If no `Select` element matches either of these, then we take a final shot by
    searching for a combo box relative to a label:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: We are not done quite yet. The collection of elements returned must be filtered
    for visibility.
  prefs: []
  type: TYPE_NORMAL
- en: Getting a visible element from a collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have a collection of potential elements, we will parse through
    them to find the first one that is visible:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'At this point, we have made an educated guess as to which element is being
    referenced. All we need to do is return the element to be interacted with from
    the calling method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: At this point, you might see ways to further identify collections, We encourage
    you to modify the two or three sample locators to work with your particular framework,
    but...
  prefs: []
  type: TYPE_NORMAL
- en: Beware the endless rabbit hole!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As we come to the end of this section, you may have noticed that we have given
    no more than three examples to dynamically locate multiple nodes by text. And
    for good reason. You might spend hours trying to find a fifth or sixth template
    that will return the perfect collection of elements. We recommend limiting the
    search to just three attempts. It is just not worth the time to go deeper down
    this rabbit hole, reducing accuracy and slowing the result search time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we demonstrated how to dynamically locate elements using just
    a string, much like how a superhero uses their keen senses to pinpoint villains
    just by their silhouette. We employed a clue from each action, narrowing down
    the pool of potential elements to those pertinent to the requested action, akin
    to a superhero zeroing in on their target. Lastly, we established a boundary on
    the number of attempts to identify a valid element, similar to how a superhero
    might limit their efforts in a search before changing tactics.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will explore expanding our testing to multiple environments,
    paralleling how a superhero adapts to different challenges in various suburbs
    of Metropolis.
  prefs: []
  type: TYPE_NORMAL
