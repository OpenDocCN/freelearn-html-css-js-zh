["```js\n// Eat some CPU cycles...\n// Taken from http://adambom.github.io/parallel.js/\nfunction work(n) {\n    var i = 0;\n    while (++i < n * n) {}\n    return i;\n}\n\n// There's no handlers in the queue, so this is\n// executed immediately.\nprocess.nextTick(() => {\n    console.log('first handler');\n});\n\n// The previous handler was quick to exit, so this\n// handler is executed without delay.\nprocess.nextTick(() => {\n    console.log('second handler');\n});\n\n// Starts immediately because the previous handler\n// exited quickly. However, this handler executes\n// some CPU intensive code.\nprocess.nextTick(() => {\n    console.log('hogging the CPU...');\n    work(100000);\n});\n\n// This handler isn't run immediately, because the\n// handler before this one takes a while to complete.\nprocess.nextTick(() => {\n    console.log('blocked handler');\n});\n```", "```js\n// We need the \"http\" module for HTTP-related\n// code.\nvar http = require('http');\n\n// Creates the server instance, and sets of the\n// callback function that's called on every request\n// event for us.\nvar server = http.createServer((req, res) => {\n\n    // The response header is always going to be plain\n    // text.\n    res.setHeader('Content-Type', 'text/plain');\n\n    // If the request URL is \"hello\" or \"world\", we\n    // respond with some text immediately. Otherwise,\n    // if the request URL is \"/\", we simulate a slow\n    // response by using \"setTimeout()\" to finish the\n    // request after 5 seconds.\n    if (req.url === '/hello') {\n        res.end('Hello');\n    } else if (req.url === '/world') {\n        res.end('World');\n    } else {\n        setTimeout(() => {\n            res.end('Hello World');\n        }, 5000);\n    }\n});\n\n// Starts the server.\nserver.listen(8081);\nconsole.log('listening at http://localhost:8081');\n```", "```js\n// We need the \"http\" module.\nvar http = require('http');\n\n// Creates some sample data, an array of \n// numbers.\nvar array = new Array(1000)\n    .fill(null)\n    .map((v, i) => i);\n\n// Creates the HTTP server, and the request\n// callback function.\nvar server = http.createServer((req, res) => {\n    var size = 25,\n        i = 0;\n\n    // This function is called when we need to\n    // schedule a chunk of data to be written to\n    // the response.\n    function schedule() {\n\n        // Here's the actual scheduling, \n        // \"process.nextTick()\" let's other handlers, \n        // if any, run while we're streaming our writes\n        // to the response.\n        process.nextTick(() => {\n            let chunk = array.slice(i, i + size);\n\n            // If there's a chunk of data to write, \n            // write it, then schedule the next round by\n            // calling \"schedule()\". Otherwise, we can\n            // \"end()\" the response.\n            if (chunk.length) {\n                res.write(chunk.toString() + '\\n');\n                i += size;\n                schedule();\n            } else {\n                res.end();\n            }   \n        }); \n    }   \n\n    // Kicks off the stream writing scheduler.\n    schedule();\n});\n\n// Starts the server.\nserver.listen(8081);\nconsole.log('listening at http://localhost:8081');\n```", "```js\nvar http = require('http');\n\n// Our sample user data.\nvar users = [\n    { name: 'User 1' },\n    { name: 'User 2' },\n    { name: 'User 3' },\n    { name: 'User 4' }\n];\n\nvar server = http.createServer((req, res) => {\n\n    // We'll be returning JSON data.\n    res.setHeader('Content-Type', 'application/json');\n\n    var id = /\\/(\\d+)/.exec(req.url),\n        user;\n\n    // If a user is found from the ID in the URL, return\n    // a JSON string of it. Otherwise, respond with a 404.\n    if (id && (user = users[+id[1]])) {\n        res.end(JSON.stringify(user));\n    } else {\n        res.statusCode = 404;\n        res.statusReason = http.STATUS_CODES[404];\n        res.end();\n    }\n\n});\n\nserver.listen(8082);\nconsole.log('Users service at http://localhost:8082');\n```", "```js\n// Our sample preference data.\nvar preferences = [\n    { spam: false },\n    { spam: true },\n    { spam: false },\n    { spam: true }\n];\n\nvar server = http.createServer((req, res) => {\n\n    // We'll be returning JSON data.\n    res.setHeader('Content-Type', 'application/json');\n\n    var id = /\\/(\\d+)/.exec(req.url),\n        preference;\n\n    // If the ID in the URL finds a sample preference,\n    // return the JSON string for it. Otherwise,\n    // respond with a 404.\n    if (id && (preference = preferences[+id[1]])) {\n        res.end(JSON.stringify(preference));\n    } else {\n        res.statusCode = 404;\n        res.statusMessage = http.STATUS_CODES[404];\n        res.end();\n    }\n});\n\nserver.listen(8083);\nconsole.log('Preference service: http://localhost:8083');\n```", "```js\nvar http = require('http');\n\nvar server = http.createServer((req, res) => {\n\n    // Looks for a user ID in the URL.\n    var id = /\\/(\\d+)/.exec(req.url);\n\n    // If there's no ID in the URL, don't\n    // even try handling the request.\n    if (!id) {\n        res.end();\n        return;\n    }\n\n    // This promise is resolved when the call to\n    // the \"users\" service responds with data. This\n    // service is another server, running on port\n    // 8082.\n    var user = new Promise((resolve, reject) => {\n        http.get({\n            hostname: 'localhost',\n            port: 8082,\n            path: `/${id[1]}`\n        }, (res) => {\n            res.on('data', (data) => {\n                resolve(JSON.parse(data.toString()));\n            });\n        });\n    });\n\n    // This promise is resolved when the call to\n    // the \"preference\" service responds with data. This\n    // service is just another web server, running\n    // on port 8082.\n    var preference = new Promise((resolve, reject) => {\n        http.get({\n            hostname: 'localhost',\n            port: 8083,\n            path: `/${id[1]}`\n        }, (res) => {\n            res.on('data', (data) => {\n                resolve(JSON.parse(data.toString()));\n            });\n        });\n    });\n\n    // Once both the user and the preference services have\n    // responded, we have all the data we need to render \n    // the page.\n    Promise.all([ user, preference ]).then((results) => {\n        let user = results[0],\n            preference = results[1];\n\n        res.end(`\n            <p><strong>Name:</strong> ${user.name}</p>\n            <p><strong>Spam:</strong> ${preference.spam}</p>\n        `);\n    });\n});\n\nserver.listen(8081);\nconsole.log('Listening at http://localhost:8081');\n```", "```js\n// We need the \"fs\" module to read files.\nvar fs = require('fs');\nvar path = require('path');\n\n// The file path we're working with.\nvar filePath = path.join(__dirname, 'words');\n\n// Starts the timer for reading our \"words\" file.\nconsole.time('reading words');\n\n// Reads the entire file into memory, then fires\n// a callback with the data.\nfs.readFile(filePath, (err, data) => {\n    console.timeEnd('reading words');\n    // → reading words: 5ms\n\n    console.log('size',\n        `${(data.length / 1024 / 1024).toFixed(2)}MB`);\n    // →  size 2.38MB\n});\n```", "```js\n// Creates a promise that's resolved once all the \n// file chunks have been read into memory.\nvar contents = new Promise((resolve, reject) => {\n\n    // Opens the \"filePath\" for reading. The file\n    // descriptor, like a file identifier, is needed\n    // when we call \"fs.read()\" later on.\n    fs.open(filePath, 'r', (err, fd) => {\n\n        // Set up some variables needed for reading\n        // a file one chunk at a time. We need to know\n        // how big the file is, that does in \"size\". The\n        // \"buffer\" is where the chunks go as they're\n        // read. And we have the \"chunk\" size, and the\n        // number of \"bytes\" read so far.\n        var size = fs.fstatSync(fd).size,\n            buffer = new Buffer(size),\n            chunk = 1024,\n            read = 0;\n\n        // We wrap this reading iteration in a named\n        // function because it's recursive.\n        function schedule() {\n\n            // The reading of a chunk always happens in\n            // the next tick of the IO loop. This gives\n            // other queued handlers a chance to run while \n            // we're reading this file.\n            // process.nextTick(() => {\n\n                // Makes sure the last chunk fits evenly\n                // into the buffer.\n                if ((read + chunk) > size) {\n                    chunk = size - read;\n                }\n\n                // Reads the chunk of data into the buffer,\n                // and increments the \"read\" counter.\n                fs.read(fd, buffer, read, chunk, read);\n                read += chunk;\n\n                // Check if there's still data to read. If\n                // yes, \"schedule()\" the next \"read()\". If\n                // no, resolve the promise with the \"buffer\".\n                if (read < size) {\n                    schedule();\n                } else {\n                    resolve(buffer);\n                }\n            });\n        }\n\n        // Kicks off the reading and scheduling process.\n        schedule();\n    });\n});\n\n// When the promise is resolved, show how many words\n// were read into the buffer by splitting them by\n// newlines.\ncontents.then((buffer) => {\n    console.log('words read',\n        buffer.toString().split('\\n').length);\n    // → words read 235887\n});\n```", "```js\n// We need the \"fs\" and the \"path\" modules for\n// working with files.\nvar fs = require('fs');\nvar path = require('path');\n\n// The two files we'll be working with.\nvar filePath1 = path.join(__dirname, 'output1'),\n    filePath2 = path.join(__dirname, 'output2');\n\n// The sample array we'll be writing to files.\nvar array = new Array(1000)\n    .fill(null)\n    .map((v, i) => i);\n\n// Starts a timer for writing the entire array to\n// the file in one shot.\nconsole.time('output1');\n\n// Performs the file write and stops the timer when\n// it's complete.\nfs.writeFile(filePath1, array.toString(), (err) => {\n    console.timeEnd('output1');\n});\n```", "```js\n// Creates a promise that's resolved when all chunks\n// have been written to file.\nvar written = new Promise((resolve, reject) => {\n\n    // Opens the file for writing, and the callback\n    // starts writing chunks.\n    fs.open(filePath2, 'w', (err, fd) => {\n        var chunk = 50,\n            i = 0;\n\n        // The recursive scheduler places the call\n        // to perform the write into the IO event loop\n        // queue.\n        function schedule() {\n            process.nextTick(() => {\n\n                // The chunk of data from \"array\" to \n                // write.\n                let slice = array.slice(i, i + chunk);\n\n                // If there's a chunk to write, write it.\n                // If not, close the file and resolve the\n                // promise.\n                if (slice.length) {\n                    fs.write(fd, slice.toString(), i);\n                    i += chunk;\n                    schedule();\n                } else {\n                    fs.close(fd);\n                    resolve();\n                }\n            });\n        }\n\n        // Kicks of the chunk/write scheduler.\n        schedule();\n    });\n});\n\n// When the promise is resolved, it means the file has been\n// written.\nwritten.then(() => {\n    console.log('finished writing');\n});\n```", "```js\n// All the modules we need.\nvar fs = require('fs');\nvar path = require('path');\nvar stream = require('stream');\n\n// Creates a simple upper-case transformation\n// stream. Each chunk that's passed in is\n// \"pushed\" to the next stream in upper-case.\nvar transform = new stream.Transform({\n    transform: function(chunk) {\n        this.push(chunk.toString().toUpperCase());\n    }\n});\n\n// The file names we're using.\nvar inputFile = path.join(__dirname, 'words'),\n    outputFile = path.join(__dirname, 'output');\n\n// Creates an \"input\" stream that reads from\n// \"inputFile\" and an \"output\" stream that writes\n// to \"outputFile\".\nvar input = fs.createReadStream(inputFile),\n    output = fs.createWriteStream(outputFile);\n\n// Starts the IO by building the following \n// pipeline: input -> transform -> output.\ninput.pipe(transform);\ntransform.pipe(output);\n```"]