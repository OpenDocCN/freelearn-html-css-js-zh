<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05" class="calibre1"/>Chapter 5. Creating a To-do Application with Backbone.js</h1></div></div></div><p class="calibre7">In the previous chapters, we learned how to create real-time chat with Socket.IO. We made a blog application with AngularJS and used Express to create a simple website. This chapter is dedicated to another popular framework—Backbone.js. Backbone.js is one of the first JavaScript <a id="id187" class="calibre1"/>frameworks that gained popularity. There are models that deal with the data, views that control the logic and the user interface, and the built-in router that handles the changes in the browser's address. The framework plays really well with jQuery, which makes it attractive to almost every JavaScript developer. In this chapter, we are going to build a simple application for storing short tasks. At the end, we will be able to create, edit, delete tasks, and mark them as finished.</p><p class="calibre7">In this chapter, we will cover the following topics:</p><div class="book"><ul class="itemizedlist"><li class="listitem">The basics of Backbone.js</li><li class="listitem">Writing the Node.js code that manages the to-do lists</li><li class="listitem">Coding the frontend using Backbone.js</li></ul></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js">
<div class="book" title="Exploring the Backbone.js framework"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch05lvl1sec36" class="calibre1"/>Exploring the Backbone.js framework</h1></div></div></div><p class="calibre7">Before<a id="id188" class="calibre1"/> starting with the example's application, we should check out the main features of the framework. Sometimes, it's good to know what is going on under the hood. So, let's dive in.</p></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js">
<div class="book" title="Exploring the Backbone.js framework">
<div class="book" title="Recognizing the framework dependency"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec25" class="calibre1"/>Recognizing the framework dependency</h2></div></div></div><p class="calibre7">Most of the <a id="id189" class="calibre1"/>software that we use nowadays is built on top of other libraries or tools. Normally, they are called <span class="strong"><strong class="calibre8">dependencies</strong></span><a id="id190" class="calibre1"/>. Backbone.js has only one hard dependency—that's Underscore.js, which is a library full of utility functions. There are functions such as <code class="email">forEach</code>, <code class="email">map</code>, or <code class="email">union</code> for arrays. We can extend an object and retrieve its keys or values. All these are functionalities we need sometimes, but they are missing in the built-in JavaScript objects. So, we should include the library in our page. Otherwise, Backbone.js will throw an error because of the missing functionalities.</p><p class="calibre7">Backbone.js<a id="id191" class="calibre1"/> works really well with jQuery. It checks whether the library is available and starts using it right away. It's a nice collaboration because we can speed up our work with the various jQuery methods. It's not a must-have dependency and the framework still works without it, but it simplifies the DOM manipulations.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js">
<div class="book" title="Exploring the Backbone.js framework">
<div class="book" title="Extending the functionality"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec26" class="calibre1"/>Extending the functionality</h2></div></div></div><p class="calibre7">The framework<a id="id192" class="calibre1"/> has a few independent components that we will use. So, the idea is that we will create new classes that inherit the functionality of the base implementations. These components have the <code class="email">extend</code> method, which accepts an object—our custom logic. At the end, our properties will overwrite the original code. The following is a new view class that we will create:</p><div class="informalexample"><pre class="programlisting">var ListView = Backbone.View.extend({
  render: function() {
    // ...
  }
});
var list = new ListView();</pre></div><p class="calibre7">There are no mandatory modules. There is no strictly defined central entry point of our application. Everything is up to us, which is good. All the parts are so decoupled, which makes Backbone.js easy to work with.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js">
<div class="book" title="Exploring the Backbone.js framework">
<div class="book" title="Understanding Backbone.js as an event-driven framework"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch05lvl2sec27" class="calibre1"/>Understanding Backbone.js as an event-driven framework</h2></div></div></div><p class="calibre7">By event driven,<a id="id193" class="calibre1"/> we mean that the application flow is determined by events, that is, every class/object in the framework dispatches messages that notify the rest of the components about some action. In other words, every object we create can accept listeners and can trigger events. This makes our application extremely flexible and communicative. This approach encourages modular programming, and it really helps in building solid architectures. The <code class="email">Backbone.Events</code> module<a id="id194" class="calibre1"/> is a module that delivers this functionality. The following example code explains how we can extend the <code class="email">Backbone.Events</code> module:</p><div class="informalexample"><pre class="programlisting">var object = {};
_.extend(object, Backbone.Events);
object.on("event", function(msg) {
  console.log(msg);
});
object.trigger("event", "an event");</pre></div><p class="calibre7">Underscore.js <code class="email">extend</code> method merges the passed objects into one. In our case, we will produce an object<a id="id195" class="calibre1"/> that has the observer pattern implemented. This leads us to conclude that every view, model, or collection produced by Backbone.js has the <code class="email">on</code> and <code class="email">trigger</code> methods available.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js">
<div class="book" title="Exploring the Backbone.js framework">
<div class="book" title="Using models"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch05lvl2sec28" class="calibre1"/>Using models</h2></div></div></div><p class="calibre7">The model is <a id="id196" class="calibre1"/>an important part of every Backbone.js project. Its primary function is to hold our data. The model keeps, validates, and synchronizes data with the server. Together with this, the model can notify the outside world of the events that happen inside the module. The following example code explains how we can extend the <code class="email">Backbone.Model</code> module:</p><div class="informalexample"><pre class="programlisting">var User = Backbone.Model.extend({
  defaults: {
    name: '',
    password: '',
    isAdmin: false
  }
});
var user = new User({
  name: 'John',
  password: '1234'
});
console.log(user.get('name'));</pre></div><p class="calibre7">The information in the model is kept in a hash table. There are properties and values. We have the <code class="email">set</code> and <code class="email">get</code> methods to access the data. Once something is changed, the model triggers an event. You may wonder why we need to wrap the data into a class. In the beginning, <code class="email">Backbone.Model</code> looks like an unnecessary abstraction. However, very soon you will realize that such a concept is really powerful. First, we can attach as many views as we want to the same model, and by attach we mean listening to a <code class="email">change</code> event. We can update the model and change the user interface as well. The second thing is that we can connect the model to a server-side API and immediately synchronize the information via an Ajax request. We will do this in an example application later.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js">
<div class="book" title="Exploring the Backbone.js framework">
<div class="book" title="Using collections"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch05lvl2sec29" class="calibre1"/>Using collections</h2></div></div></div><p class="calibre7">Very often, <a id="id197" class="calibre1"/>we will need to store the models in an array. The collections are made for such cases. The <code class="email">Backbone.Collection</code> module<a id="id198" class="calibre1"/> has methods such as <code class="email">add</code>, <code class="email">remove</code>, and <code class="email">forEach</code> for interaction with the stored items. It can also fetch multiple models from an external source and that's what it is used mostly for. Of course, the collection needs to know what is the type of the model. The following example code explains how we can extend the <code class="email">Backbone.Collection</code> module:</p><div class="informalexample"><pre class="programlisting">var User = Backbone.Model.extend({
  defaults: {
    name: '',
    password: '',
    isAdmin: false
  }
});
var Accounts = Backbone.Collection.extend({
  model: User
});
var accounts = new Accounts();
accounts.add({name: 'John'});
accounts.add({name: 'Steve'});
accounts.add({name: 'David'});
accounts.forEach(function(model) {
  console.log(model.get('name'));
});</pre></div><p class="calibre7">The example shows the same <code class="email">User</code> model class, but this is placed inside a collection. We can easily add new users and retrieve their names. Similar to the <code class="email">Backbone.Model</code> module, every collection can sync our data with an external server via HTTP requests.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js">
<div class="book" title="Exploring the Backbone.js framework">
<div class="book" title="Implementing views"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_7"><a id="ch05lvl2sec30" class="calibre1"/>Implementing views</h2></div></div></div><p class="calibre7">The views in<a id="id199" class="calibre1"/> Backbone.js take care of the user interface and its business logic, that is, when compared to the usual <span class="strong"><strong class="calibre8">Model-View-Controller</strong></span> (<span class="strong"><strong class="calibre8">MVC</strong></span>) pattern<a id="id200" class="calibre1"/>, here, the view and the controller are merged in one place. Again, there is a base class that we have to extend. An interesting thing is that a DOM element is automatically created for us. We can control its type, class, or ID, and it is always there. This is really handy because we can build our interface dynamically behind the scenes and add it to the page only once, avoiding the multiple reflows and repaints of the browser. This can increase the performance of our application.</p><p class="calibre7">There is a certain popular wrong implementation of Backbone.js views. I myself made a lot of mistakes till I understood how everything is supposed to work. The idea is to bind the view's <code class="email">render</code> method to a change in the model. By doing this, the interface will be automatically updated. <a id="id201" class="calibre1"/>It is also important to find the balance and keep the classes short. Sometimes, we may end up with a really long view, which controls a big portion of our page. A good practice is to divide the parts into smaller pieces. It's just a lot easier for maintenance and testing. The following example code explains how we can extend the <a id="id202" class="calibre1"/>
<code class="email">Backbone.View</code> module:</p><div class="informalexample"><pre class="programlisting">var LabelView = Backbone.View.extend({
  tagName: 'span'
});
var label = new LabelView();
console.log(label.el);</pre></div><p class="calibre7">The <code class="email">tagName</code> property determines the type of the generated DOM element. It's a good practice to operate only with that created element. It's not a good idea to attach it to another view or somewhere in the DOM tree. This should happen outside the class. There are some tricky sections we must watch out for when we need to attach event listeners, for example, <code class="email">click</code>. However, the framework has a solution for such cases. We will see it later in this chapter.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js">
<div class="book" title="Exploring the Backbone.js framework">
<div class="book" title="Using the router"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_8"><a id="ch05lvl2sec31" class="calibre1"/>Using the router</h2></div></div></div><p class="calibre7">So far, we<a id="id203" class="calibre1"/> learned about models, collections, and views. There is one more thing that is widely used, especially when we need to build a single-page application like ours—the router. It's a module that maps a function to a specific URL. It supports the new history API so that it can handle addresses such as <code class="email">/page/action/32</code>. The HTML5 history API is a standardized way to manipulate the browser history via a script. If the browser doesn't support this API, then it works with the good old fragment version, that is, <code class="email">#page/action/32</code>.</p><p class="calibre7">The following example code explains how we can extend the <code class="email">Backbone.Router</code> module:</p><div class="informalexample"><pre class="programlisting">var Workspace = Backbone.Router.extend({
  routes: {
    "help":                 "help",
    "search/:query":        "search",
    "search/:query/p:page": "search"
  },
  help: function() {
    // ...
  },
  search: function(query, page) {
    // ...
  }
});</pre></div><p class="calibre7">We just have to <a id="id204" class="calibre1"/>define our routes and the module is responsible for the rest. Keep in mind that we may use dynamic URLs, that is, URLs that contain dynamic parts, like with the <code class="email">search</code> route in the preceding code.</p><p class="calibre7">The router itself collaborates with another module called <code class="email">Backbone.history</code>. This is the class that listens to <code class="email">hashchange</code> events or <code class="email">pushState</code> events triggered by the browser. So, once the routes are initialized, we should run <code class="email">Backbone.history.start()</code> in order to fire the matched route handler. We will see this in action while writing the client-side part of the application.</p></div></div></div>

<div class="book" title="Chapter&#xA0;5.&#xA0;Creating a To-do Application with Backbone.js">
<div class="book" title="Exploring the Backbone.js framework">
<div class="book" title="Talking to the backend"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_9"><a id="ch05lvl2sec32" class="calibre1"/>Talking to the backend</h2></div></div></div><p class="calibre7">As we mentioned,<a id="id205" class="calibre1"/> Backbone.js offers automatic synchronization with the server-side data. This, of course, needs some efforts from our side, and they are more like the things we need to do at the backend part of the application. The client-side JavaScript makes <span class="strong"><strong class="calibre8">CRUD</strong></span><a id="id206" class="calibre1"/> (<span class="strong"><strong class="calibre8">create</strong></span>, <span class="strong"><strong class="calibre8">read</strong></span>, <span class="strong"><strong class="calibre8">update</strong></span>, and <span class="strong"><strong class="calibre8">delete</strong></span>) HTTP requests and the server will process them. Every model and collection should have a <code class="email">url</code> property (or method) set, and we will send the information to this address. It's only one URL, so the different operations are using different request methods—<code class="email">GET</code>, <code class="email">POST</code>, <code class="email">PUT</code>, and <code class="email">DELETE</code>. In our example, the key moment is to wire Backbone.js's objects to the Node.js server. Once this is done, we will be able to manage the to-do lists easily directly from the browser.</p></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Writing the backend of the application"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec37" class="calibre1"/>Writing the backend of the application</h1></div></div></div><p class="calibre7">The <a id="id207" class="calibre1"/>backend is<a id="id208" class="calibre1"/> the Node.js part, which will take care of the data delivery and will serve the necessary HTML, CSS, and JavaScript functionalities. In order to learn something new in every chapter, we will use different approaches for the common tasks. For sure, there are things that we need to do every time, for example, running a server that listens on a particular port. JavaScript is a really interesting language, and in most cases, we can solve the same problems in completely different ways. In the previous chapters, we used Express to send assets to the users. In addition, there were examples where we did this directly by reading the files with the filesystem API. However, this time, we will <a id="id209" class="calibre1"/>combine the ideas of the two methods, that is, the code that we will use will read the resources from the hard disk and we will work with dynamic paths.</p></div>

<div class="book" title="Writing the backend of the application">
<div class="book" title="Running the Node.js server"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec33" class="calibre1"/>Running the Node.js server</h2></div></div></div><p class="calibre7">We will start<a id="id210" class="calibre1"/> the project in an empty directory. In the beginning, we need an empty <code class="email">index.js</code> file that will host the Node.js server. Let's put the following content in the <code class="email">index.js</code> file:</p><div class="informalexample"><pre class="programlisting">var http = require('http'),
  fs = require('fs'),
  files = {},
  debug = true,
  port = 3000;
var respond = function(file, res) {
  var contentType;
  switch(file.ext) {
    case "css": contentType = "text/css"; break;
    case "html": contentType = "text/html"; break;
    case "js": contentType = "application/javascript"; break;
    case "ico": contentType = "image/ico"; break;
    default: contentType = "text/plain";
  }
  res.writeHead(200, {'Content-Type': contentType});
  res.end(file.content);
}
var serveAssets = function(req, res) {
  var file = req.url === '/' ? 'html/page.html' : req.url;
  if(!files[file] || debug) {
    try {
      files[file] = {
        content: fs.readFileSync(__dirname + "/" + file),
        ext: file.split(".").pop().toLowerCase()
      }
    } catch(err) {
      res.writeHead(404, {'Content-Type': 'plain/text'});
      res.end('Missing resource: ' + file);
      return;
    }
  }
  respond(files[file], res);
}
var app = http.createServer(function (req, res) {
  serveAssets(req, res);
}).listen(port, '127.0.0.1');
console.log("Listening on 127.0.0.1:" + port);</pre></div><p class="calibre7">The script starts with the definition of some global variables. The <code class="email">http</code> module is used to run the Node.js server<a id="id211" class="calibre1"/> and <code class="email">fs</code> is run to access the files. The <code class="email">files</code> object acts as a cache for already requested files. Reading the files from the hard disk can be a very expensive operation, so there is really no need to do this in every single request. It's a good practice to cache the content whenever possible. The <code class="email">debug</code> variable is set to <code class="email">true</code> while we are developing the application. This actually turns off our caching mechanisms because otherwise, we need to restart the server every time we make changes to some of the HTML, CSS, or JavaScript files. There is a short <code class="email">respond</code> method, which accepts an object with the following format:</p><div class="informalexample"><pre class="programlisting">{
  content: '...',
  ext: '...'
}</pre></div><p class="calibre7">The <code class="email">content</code> property is the actual file's content and the <code class="email">ext</code> property represents the file's extension. The same method also needs the <code class="email">response</code> object, so it can send information to the browser. Based on the file's type, we set the proper <code class="email">Content-Type</code> header. This is important because if we skip this, the browser may not process the resource correctly. Next, the <code class="email">serveAssets</code> method gets the current requested path and tries to read the actual file from the system. It also checks whether the file is not in the cache or whether we are in the debug mode. If the file is missing, it sends a 404 error page to the browser. The last lines simply run the server and pass the <code class="email">request</code> and <code class="email">response</code> objects to <code class="email">serveAssets</code>. With this code, we are able to request files with URLs that match their actual directory path.</p></div></div>

<div class="book" title="Writing the backend of the application">
<div class="book" title="Managing the to-do lists"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec34" class="calibre1"/>Managing the to-do lists</h2></div></div></div><p class="calibre7">We have set up<a id="id212" class="calibre1"/> the server, so we can now continue writing the business logic, that is, the logic that will manage the tasks from our to-do list. Let's define the following two new variables at the top of the file:</p><div class="informalexample"><pre class="programlisting">var todos = [],
  ids = 0;</pre></div><p class="calibre7">The <code class="email">todos</code> array will keep our tasks. Every task will be a simple JavaScript object, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">{
  id: &lt;number&gt;,
  text: &lt;string&gt;,
  done: &lt;true | false&gt;
}</pre></div><p class="calibre7">We will<a id="id213" class="calibre1"/> increment the <code class="email">ids</code> variable every time we need to add a new to-do activity. So, every object in the array will have a unique ID attached to it. Of course, normally, we will not rely on a single number to identify the different tasks, but the <code class="email">ids</code> variable will work for our little experiment. The following is the function that will add a new element to the <code class="email">todos</code> array:</p><div class="informalexample"><pre class="programlisting">var addToDo = function(data) {
  data.id = ++ids;
  todos.push(data);
  return data;
}</pre></div><p class="calibre7">We should have two other methods for deleting and editing a to-do list. They are as follows:</p><div class="informalexample"><pre class="programlisting">var deleteToDo = function(id) {
  var arr = [];
  for(var i=0; i&lt;todos.length; i++) {
    if(todos[i].id !== parseInt(id)) {
      arr.push(todos[i]);
    }
  }
  todos = arr;
  return id;
}
var editToDo = function(id, data) {
  for(var i=0; i&lt;todos.length; i++) {
    if(todos[i].id === parseInt(id)) {
      todos[i].text = data.text;
      todos[i].done = data.done;
      return todos[i];
    }
  }
}</pre></div><p class="calibre7">The <code class="email">deleteToDo</code> function<a id="id214" class="calibre1"/> loops through the elements and skips the one that matches the passed ID. The <code class="email">editToDo</code> function is almost the same, except that it updates the properties of the stored object.</p><p class="calibre7">We have methods<a id="id215" class="calibre1"/> to manage the data; now, we have to write the part that will use them. In general, our server has two roles. The first one is to deliver the usual HTML, CSS, and JavaScript functionalities to the browser. The other one is to act as a REST service, that is, accept the CRUD type of requests and respond to them. Backbone.js will send JSON objects and will expect to receive resources in the same format. So, we have the <code class="email">respond</code> function and the following code defines the <code class="email">respondJSON</code> function, which will send the data to the browser:</p><div class="informalexample"><pre class="programlisting">var respondJSON = function(json, res) {
  res.writeHead(200, {'Content-Type': 'application/json'});
  res.end(JSON.stringify(json));
}</pre></div><p class="calibre7">The entry point of our server is the handler of the <code class="email">http.createServer</code> method. This is where we need to divide the application's flow, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var app = http.createServer(function (req, res) {
  if(req.url.indexOf('/api') === 0) {
    serveToDos(req, res);
  } else {
    serveAssets(req, res);
  }
}).listen(port, '127.0.0.1');</pre></div><p class="calibre7">We will check whether the current URL starts with <code class="email">/api</code>. If not, then we serve the assets. Otherwise, the request is considered as a CRUD operation, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var serveToDos = function(req, res) {
  if(req.url.indexOf('/api/all') === 0) {
    respondJSON(todos, res);
  } else if(req.url.indexOf('/api/todo') === 0) {
    if(req.method == 'POST') {
      processPOSTRequest(req, function(data) {
        respondJSON(addToDo(data), res);
      });
    } else if(req.method == 'DELETE') {
      deleteToDo(req.url.split("/").pop());
      respondJSON(todos, res);
    } else if(req.method == 'PUT') {
      processPOSTRequest(req, function(data) {
        respondJSON(editToDo(req.url.split("/").pop(), data), res);
      });
    }
  } else {
    respondJSON({error: 'Missing method'}, res);
  }
}</pre></div><p class="calibre7">There are two<a id="id216" class="calibre1"/> paths that control everything. The <code class="email">/api/all</code> path responds with a JSON code that contains all the to-do lists available. The next <code class="email">/api/todo</code> path is responsible for creating, editing, and deleting a task. The actual address that is used is <code class="email">http://localhost:3000/api/todo/4</code>, where the number at the end is the ID of an element in the <code class="email">todos</code> array. That's why we need <code class="email">req.url.split("/").pop()</code>, which extracts the number from the URL. There is one additional function called <code class="email">processPOSTRequest</code>. It's a helper that gets the data sent via the <code class="email">POST</code> or <code class="email">PUT</code> methods. In Express, the same functionality is provided by the <code class="email">bodyParser</code> middleware. The <code class="email">processPOSTRequest</code> function is given in the following code:</p><div class="informalexample"><pre class="programlisting">var processPOSTRequest = function(req, callback) {
  var body = '';
  req.on('data', function (data) {
    body += data;
  });
  req.on('end', function () {
    callback(JSON.parse(body));
  });
}</pre></div><p class="calibre7">At the end, maybe it's a good idea to fill the <code class="email">todos</code> array with some tasks. Add the following methods just to have something to display once we build the frontend:</p><div class="informalexample"><pre class="programlisting">addToDo({text: "Learn JavaScript", done: false});
addToDo({text: "Learn Node.js", done: false});
addToDo({text: "Learn BackboneJS", done: false});</pre></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Writing the frontend"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec38" class="calibre1"/>Writing the frontend</h1></div></div></div><p class="calibre7">In this<a id="id217" class="calibre1"/> section, we will develop the client-side logic—the code<a id="id218" class="calibre1"/> that will run in the browser of the users. This includes the listing and managing of the to-do lists delivered by the Node.js part.</p></div>

<div class="book" title="Writing the frontend">
<div class="book" title="Looking into the base of the application"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch05lvl2sec35" class="calibre1"/>Looking into the base of the application</h2></div></div></div><p class="calibre7">Before we start coding, let's have a look at the file structure<a id="id219" class="calibre1"/>. The following figure shows how our project should look:</p><div class="mediaobject"><img src="../images/00010.jpeg" alt="Looking into the base of the application" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The <code class="email">index.js</code> file contains the Node.js code that we already wrote. The <code class="email">.css</code> and <code class="email">.html</code> directories hold the styles and the HTML markup of the page. In the <code class="email">.js</code> folder, we will put the collection, model, and views of Backbone.js. Along with that, there are the framework's dependencies and the main application's <code class="email">app.js</code> file. Let's start with the <code class="email">page.html</code> file:</p><div class="informalexample"><pre class="programlisting">&lt;!doctype html&gt;
&lt;html&gt;
  &lt;head&gt;
     &lt;link rel="stylesheet" type="text/css" href="css/styles.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;

    &lt;div id="menu"&gt;           
      &lt;a href="#new"&gt;Add new ToDo&lt;/a&gt;
      &lt;a href="#"&gt;Show all ToDos&lt;/a&gt;
    &lt;/div&gt;
    &lt;div id="content"&gt;&lt;/div&gt;
    
    &lt;script src="js/vendors/jquery-1.10.2.min.js"&gt;&lt;/script&gt;
    &lt;script src="js/vendors/underscore-min.js"&gt;&lt;/script&gt;
    &lt;script src="js/vendors/backbone.js"&gt;&lt;/script&gt;
    &lt;script src="js/app.js"&gt;&lt;/script&gt;
    &lt;script src="js/models/ToDo.js"&gt;&lt;/script&gt;
    &lt;script src="js/collections/ToDos.js"&gt;&lt;/script&gt;
    &lt;script src="js/views/list.js"&gt;&lt;/script&gt;
    &lt;script src="js/views/add.js"&gt;&lt;/script&gt;
    &lt;script src="js/views/edit.js"&gt;&lt;/script&gt;
    &lt;script&gt;
      window.onload = app.init;
    &lt;/script&gt;
    &lt;/body&gt;
&lt;/html&gt;</pre></div><p class="calibre7">The styles are added to the <code class="email">head</code> tag of the page. The scripts are put at the end, just before closing the <code class="email">body</code> tag. <a id="id220" class="calibre1"/>We do this because the JavaScript files usually block the rendering of the page. Adding them at the top of the page means that the browser will not get the necessary styles and HTML markup and will not display anything to the user.</p><p class="calibre7">We have a menu with two buttons. The first one will show a form where the user can add a new to-do list. The second one shows the home page, that is, a list with all the tasks. The content <code class="email">div</code> element will be the host container where we will render Backbone.js's views. The bootstrapping of the application is done in the <code class="email">init</code> method of the <code class="email">app</code> object as follows:</p><div class="informalexample"><pre class="programlisting">var app = (function() {
  var init = function() { }
  return {
    models: {},
    collections: {},
    views: {},
    init: init
  }
})();</pre></div><p class="calibre7">We will use the <span class="strong"><strong class="calibre8">Revealing Module</strong></span> pattern<a id="id221" class="calibre1"/>. The <code class="email">app</code> object has its own private scope. Its public API consists of namespaces for the models, collections, and views. The last thing is the <code class="email">init</code> method. It's a good practice to use namespaces. They encapsulate our application and prevent collisions.</p><p class="calibre7">The first thing <a id="id222" class="calibre1"/>we want to do is to display the current available tasks. Let's write a few things in advance. It is clear that we will put the user interface in the content <code class="email">div</code> element. So, it is a good idea to cache a reference to that element because we will use it multiple times. We can define a variable and assign a jQuery object to it as follows:</p><div class="informalexample"><pre class="programlisting">var content;
var init = function() {
  content = $("#content");
}</pre></div><p class="calibre7">Next, we need a view class that will list the data. However, the view itself should not make requests to the backend. That's the job of the model—<code class="email">/js/models/ToDo.js</code>; its code is given as follows:</p><div class="informalexample"><pre class="programlisting">app.models.ToDo = Backbone.Model.extend({
  defaults: {
    text: '',
    done: false
  },
  url: function() {
      return '/api/todo/' + this.get("id");
  }
});</pre></div><p class="calibre7">We are using the namespace created in <code class="email">/js/app.js</code>. Backbone.js offers the <code class="email">defaults</code> property, which we may use to define the initial values. Here, the <code class="email">url</code> method is very important. Without it, the framework can't send requests to the server. The logic that manages the to-do lists at the backend requires an ID. That's why we need to construct the URL dynamically.</p><p class="calibre7">And, of course, we may have a lot of tasks, so we need a<code class="email">/js/collections/ToDos.js </code>collection, and its code is given as follows:</p><div class="informalexample"><pre class="programlisting">app.collections.ToDos = Backbone.Collection.extend({
  model: app.models.ToDo,
  url: '/api/all'
});</pre></div><p class="calibre7">We set up the URL<a id="id223" class="calibre1"/> directly as a string. The collection should also know what kind of models are stored in it and we pass the model's class. Keep in mind that we actually extended the classes here. In the following code, we will create an instance of the collection class and call the <code class="email">fetch</code> method, which gets the to-do lists stored in the Node.js part:</p><div class="informalexample"><pre class="programlisting">var content,
   todos;
var init = function() {
    content = $("#content");
    todos = new app.collections.ToDos();
    todos.fetch({ success: function() {
      
  }});
}</pre></div><p class="calibre7">Our application is useless without the data. We will use the <code class="email">success</code> callback and will render the list view once the information arrives.</p><p class="calibre7">Before we proceed with the code of the /<code class="email">js/views/list.js</code> file, we will clarify a few things about the Backbone.js's views. We mentioned in the beginning of the chapter that there is a DOM element that is automatically created for us. It's available as a <code class="email">.el</code> property of the view. There are a few common tasks that we will probably do. The first one is binding DOM events to functions inside the view class. This can happen by applying a value to the <code class="email">events</code> property, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">events: {
  'click #delete': 'deleteToDo',
  'click #edit': 'editToDo',
  'click #change-status': 'changeStatus'
}</pre></div><p class="calibre7">We start with the type of the event followed by an element selector. The value is a function of the view. A big advantage of this technique for event handling is that the <code class="email">this</code> keyword in the handler points to the right place, that is, the view. We may need to call <code class="email">delegateEvents</code> to reassign the listeners. This is needed when we update the HTML code of the view's DOM element.</p><p class="calibre7">The other interesting<a id="id224" class="calibre1"/> thing regarding Backbone.js's views is the <code class="email">render</code> method. What we normally do there is update the content of the <code class="email">.el</code> object. We can use any code we like, but it is good practice to avoid placing HTML tags. That's the function where most developers use a template engine. In our example, we will use the Underscore.js template. It accepts a string and an object with data. As we don't want to place the HTML as a string inside the view, we will add it to the <code class="email">page.html</code> file. The markup will be placed inside a script tag, so it doesn't mess up the rest of the valid HTML code. The good news is that we could still get it via jQuery by simply querying the tag. For example, the following is the template used in <code class="email">/js/views/list.js</code>:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="tpl-list-item"&gt;
  &lt;li data-index="&lt;%= index %&gt;" class="&lt;%= done %&gt;"&gt;
    &lt;span&gt;&lt;%= index+1 %&gt;. &lt;%= text %&gt;&lt;/span&gt;
    &lt;a href="#edit/&lt;%= index %&gt;" id="edit"&gt;edit&lt;/a&gt;
    &lt;a href="javascript:void(0);" id="change-status"&gt;&lt;%= statusLabel %&gt;&lt;/a&gt;
     &lt;a href="javascript:void(0);" id="delete"&gt;delete&lt;/a&gt;
  &lt;/li&gt;
&lt;/script&gt;</pre></div><p class="calibre7">There are data placeholders for the item's index, text, and status. We will replace them with actual values during the rendering.</p></div></div>

<div class="book" title="Writing the frontend">
<div class="book" title="Listing the to-do activities"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch05lvl2sec36" class="calibre1"/>Listing the to-do activities</h2></div></div></div><p class="calibre7">Let's continue<a id="id225" class="calibre1"/> with the code of the list view. The one that will show the current added to-do activity is as follows:</p><div class="informalexample"><pre class="programlisting">app.views.list = Backbone.View.extend({
  events: {
    'click #delete': 'deleteToDo',
    'click #change-status': 'changeStatus'
  },
  getIndex: function(e) {
    return parseInt(e.target.parentNode.getAttribute("data-index"));
  },
  deleteToDo: function(e) {
    this.model.at(this.getIndex(e)).destroy();
    this.render();
  },
  changeStatus: function(e) {
    var self = this;
    var model = this.model.at(this.getIndex(e));
    model.save({ done: !model.get("done") }, {
      wait: true,
      success: function() {
        self.render()
      }
    });
  },
  render: function() {
    var html = '&lt;ul class="list"&gt;', 
    self = this;
    this.model.each(function(todo, index) {
    var template = _.template($("#tpl-list-item").html());
    html += template({ 
      text: todo.get("text"),
        index: index,
        done: todo.get("done") ? "done" : "not-done",
        statusLabel: todo.get("done") ? "mark as not done" : "mark as done"
      });
    });
    html += '&lt;/ul&gt;';
    this.$el.html(html);
    this.delegateEvents();
    return this;
  }
});</pre></div><p class="calibre7">We define the <a id="id226" class="calibre1"/>view class in the correct namespace. We will pass the collection of to-do activities as a model, so the <code class="email">this.model</code> statement will give us an access to all the tasks. In the <code class="email">render</code> method, we loop through every model and construct an unordered list, which is at the end and appended to the DOM element. We are using <code class="email">$el</code> instead of <code class="email">el</code> because our project has jQuery included, and Backbone.js automatically starts working with it. Note that we are sending different values of <code class="email">done</code> and <code class="email">statusLabel</code> based on the status of the task. If we check the preceding template, we will see that <code class="email">done</code> is actually a CSS class. Applying a different class will allow us to distinguish the items in the list. We should not forget to run the <code class="email">delegateEvents</code> method at the end. We are updating the children elements of <code class="email">$el</code>, so every event listener that is attached is removed.</p><p class="calibre7">In the beginning <a id="id227" class="calibre1"/>of the class, we define two events. The first one deletes a to-do activity from the system. Backbone.js has a destroy method for such cases. However, to reach the exact model from the collection, we need its index (ID). If we check the HTML template, will see that every <code class="email">li</code> tag has a <code class="email">data-index</code> attribute that contains exactly what we need. That's what the <code class="email">getIndex</code> helper does—it gets the value of that attribute. Similarly, <code class="email">changeStatus</code> updates the <code class="email">done</code> field of the to-do lists. After every modification, we call the <code class="email">render</code> method. This is quite important for the users because they have to see that the change is done.</p><p class="calibre7">Now, let's change the <code class="email">app.js</code> file a bit and render the view, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var content,
  todos;
var showList = function() {
  content.empty().append(list.render().$el);
}
var init = function() {
  content = $("#content");
  todos = new app.collections.ToDos();
  list = new app.views.list({model: todos});
  todos.fetch({ success: function() {
    showList();
  }});
}</pre></div><p class="calibre7">There is one new method, <code class="email">showList</code>, which triggers the rendering of the view and appends its DOM element to the content <code class="email">div</code> element. Now, if we run the application by typing <code class="email">node ./index.js</code> in our console, we will see the three to-do activities, which we added, being displayed on the screen.</p></div></div>

<div class="book" title="Writing the frontend">
<div class="book" title="Adding, deleting, and editing the to-do lists"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch05lvl2sec37" class="calibre1"/>Adding, deleting, and editing the to-do lists</h2></div></div></div><p class="calibre7">The next logical step <a id="id228" class="calibre1"/>is to develop the code for the adding, editing, and deleting of tasks. So, we need two new pages, additional logic to show the two new views, and a few lines that will remove tasks. We will also need a router that will handle the new content. To simplify the process, let's directly see <a id="id229" class="calibre1"/>how the final <code class="email">/js/app.js</code> file looks:</p><div class="informalexample"><pre class="programlisting">var app = (function() {
  var todos, content, list, add, edit, router;
  var showList = function() {
    content.empty().append(list.render().$el);
  }
  var showNewToDoForm = function() {
    content.empty().append(add.$el);
    add.delegateEvents();
  }
  var showEditToDoForm = function(data) {
    content.empty().append(edit.render(data).$el);
  }
  var home = function() {
    router.navigate("", {trigger: true});
  }
  var RouterClass = Backbone.Router.extend({
    routes: {
      "new": "newToDo",
      "edit/:index": "editToDo",
      "": "list"
    },
    list: showList,
    newToDo: showNewToDoForm,
    editToDo: function(index) {
      showEditToDoForm({ index: index });
    }
  });
  var init = function() {
    todos = new app.collections.ToDos();
    list = new app.views.list({model: todos});
    edit = (new app.views.edit({model: todos}));
    add = (new app.views.add({model: todos})).render();
    content = $("#content");
    todos.fetch({ success: function() {
      router = new RouterClass();
      Backbone.history.start();
    }});
    add.on("saved", home);
    edit.on("edited", home);
  }
  return {
    models: {},
    collections: {},
    views: {},
    init: init
  }
})();</pre></div><p class="calibre7">We have put a few <a id="id230" class="calibre1"/>new variables at the top. The <code class="email">add</code> and <code class="email">edit</code> variables represent the two new views. There are two new functions that change the content <code class="email">div</code> element. Note that we are not calling the <code class="email">render</code> method of the <code class="email">add</code> view. This is because there is nothing dynamic in it, which means that there is no need to render it repeatedly. It's just a form that submits data. The <code class="email">showEditToDoForm</code> function is almost the same as the <code class="email">showList</code> function, except that we expect one additional parameter—<code class="email">data</code>. This should be an object with a format <code class="email">{index: &lt;number&gt;}</code>. Once we have the index of the to-do list, we can easily get its fields. We will need these fields because we have to fill the form for editing.</p><p class="calibre7">Next, the home <a id="id231" class="calibre1"/>method simply uses the <code class="email">navigate</code> method of the router and returns the user to the <code class="email">list</code> view. The next thing in the script is the definition of the router. The described paths call the functions that we just went through. It's the mapping of URL addresses to JavaScript functions.</p><p class="calibre7">There are quite a <a id="id232" class="calibre1"/>few new things inside the <code class="email">init</code> method, so let's have a closer look. The two new views, <code class="email">add</code> and <code class="email">edit</code>, are initialized, and again they accept the collection's to-do activities. We will also start listening for two events. The views dispatch the <code class="email">saved</code> event when a new to-do activity is added and the <code class="email">edited</code> event when some of the tasks are updated.</p><p class="calibre7">The view for adding new tasks is as follows:</p><div class="informalexample"><pre class="programlisting">app.views.add = Backbone.View.extend({
  events: {
    "click button": "save"
  },
  save: function() {
    var textarea = this.$el.find("textarea");
    var value = textarea.val();
    if(value != "") {
      var self = this;
      this.model.create({ text: value }, { 
        wait: true,
        success: function() {
          textarea.val("");
          self.trigger("saved");
        }
      });
    } else {
      alert("Please, type something.");
    }
  },
  render: function() {
    var template = _.template($("#tpl-todo").html());
    this.$el.html(template());
    this.delegateEvents();
     return this;
  }
});</pre></div><p class="calibre7">There is validation of <a id="id233" class="calibre1"/>the user's input. If there is text entered in the <code class="email">textarea</code> element, we call the <code class="email">create</code> method of the collection that initializes a new model. It also sends a <code class="email">POST</code> request to the <a id="id234" class="calibre1"/>server. Once the operation finishes, we empty the textbox and trigger the <code class="email">saved</code> event so that the code in <code class="email">/js/app.js</code> can <a id="id235" class="calibre1"/>forward the user to the home page. The views for adding and editing need a separate template. The following is the code of that template:</p><div class="informalexample"><pre class="programlisting">&lt;script type="text/template" id="tpl-todo"&gt;
  &lt;div class="form"&gt;
    &lt;textarea&gt;&lt;/textarea&gt;
     &lt;button&gt;save&lt;/button&gt;
  &lt;/div&gt;
&lt;/script&gt;</pre></div><p class="calibre7">The <code class="email">/js/views/edit.js</code> file has almost the same code, which is given as follows:</p><div class="informalexample"><pre class="programlisting">app.views.edit = Backbone.View.extend({
  events: {
    'click button': 'save'
  },
  save: function() {
    var textarea = this.$el.find('textarea');
    var value = textarea.val();
    if(value != '') {
      var self = this;
      this.selectedModel.save({text: value}, {
      wait: true,
      success: function() {
        self.trigger('edited');
      }
    });
    } else {
      alert('Please, type something.');
    }
  },
  render: function(data) {
    this.selectedModel = this.model.at(data.index);
    var template = _.template($('#tpl-todo').html());
    this.$el.html(template());
    this.$el.find('textarea').val(this.selectedModel.get('text'));
    this.delegateEvents();
    return this;
  }
});</pre></div><p class="calibre7">The difference is that <a id="id236" class="calibre1"/>it puts a value in the <code class="email">textarea</code> element <a id="id237" class="calibre1"/>and calls the <code class="email">save</code> method of the edited model instead of the <code class="email">create</code> function of the whole collection.</p></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch05lvl1sec39" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we learned how to work with Backbone.js. We used a model, collection, router, and several views to implement a simple to-do application. Thankfully, due to the event-driven nature of the framework, we bound everything together. Node.js took an interesting and important part in this small project. It handled the requests from the client-side's JavaScript and acted as a REST service.</p><p class="calibre7">The next chapter is dedicated to command-line programming. We will see how to use Node.js from the command line and will develop a script that uploads our photos to Flickr.</p></div></body></html>