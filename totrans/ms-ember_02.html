<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;2.&#xA0;Understanding Ember.js Objects and Mixins"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02" class="calibre1"/>Chapter 2. Understanding Ember.js Objects and Mixins</h1></div></div></div><p class="calibre7">Having learned how to create a basic Ember.js application in the previous chapter, this chapter will introduce us to Ember.js objects, which are the foundation of the rest of the base classes. Therefore, most of the concepts discussed will be applied throughout the book. By the end of this chapter, we'll be able to:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Create Ember.js objects</li><li class="listitem">Define, get, and set object properties</li><li class="listitem">Define computed properties</li><li class="listitem">Register property change observers</li><li class="listitem">Use mixins</li></ul></div></div>

<div class="book" title="Chapter&#xA0;2.&#xA0;Understanding Ember.js Objects and Mixins">
<div class="book" title="Creating objects in Ember.js"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch02lvl1sec13" class="calibre1"/>Creating objects in Ember.js</h1></div></div></div><p class="calibre7">We<a id="id29" class="calibre1"/> all <a id="id30" class="calibre1"/>know how to define and create instances of function objects in JavaScript, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">function Point(x, y, z){
  this.x = x;
  this.y = y;
  this.z = z;
}

Point.prototype.logX = function(){
  console.log(this.x);
}
Point.prototype.logY = function(){
  console.log(this.y);
}

Point.prototype.logZ = function(){
  console.log(this.z);
}

var point = new Point(3, 5, 7);
point.logX();
// 3point.logY();
// 5point.logZ();
// 7</pre></div><p class="calibre7">The preceding <a id="id31" class="calibre1"/>example creates instances of a defined <code class="email">Point</code> object that has three methods.</p><p class="calibre7">Ember.js uses<a id="id32" class="calibre1"/> JavaScript prototypes to simulate object-oriented features. More importantly, it introduces conveniences that enable easier inheritance and management of objects in the evented browser environment. A class, which is an object definition, is usually created by <span class="strong"><em class="calibre9">extending</em></span> another user-defined or built-in class, typically <code class="email">Ember.Object</code>. Classes have two methods, <code class="email">create</code> and <code class="email">extend</code>, which are used to create instances of objects and perform inheritance respectively. For example, the preceding code snippet would be implemented in Ember.js as:</p><div class="informalexample"><pre class="programlisting">var Point = Ember.Object.extend({
  x: null,
  y: null,
  z: null,
  logX: function(){
    console.log(this.get('x'));
  },
  logY: function(){
    console.log(this.get('y'));
  },
  logZ: function(){
    console.log(this.get('z'));
  }
});</pre></div><p class="calibre7">We have just created an Ember.js class that has three properties <code class="email">x</code>, <code class="email">y</code>, and <code class="email">z</code>, and their corresponding log methods. To create a new instance of this class, we will call the <code class="email">create()</code> method on the class, as shown in the following example:</p><div class="informalexample"><pre class="programlisting">var point = Point.create({
  x: 3,
  y: 5,
  z: 7
}); point.logX();
// 3point.logY();
// 5point.logZ();
// 7</pre></div><p class="calibre7">We can go further and extend our <code class="email">Point</code> class to form a new class using the <code class="email">extend()</code> method. For example, we can define a <code class="email">Vector</code> class that defines an <code class="email">add()</code> method, which adds to a provided vector, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var Vector = Point.extend({
  add: function(vector){
   
   var x = this.get('x') + vector.get('x');
   var y = this.get('y') + vector.get('y');
   var z = this.get('z') + vector.get('z');
   
   this.set('x', x);
   this.set('y', y);
   this.set('z', z);
   
  }
});

var vectorA = Vector.create({
  x: 3,
  y: 5,
  z: 7
});

var vectorB = Vector.create({
  x: 1,
  y: 2,
  z: 3
});

vectorA.add(vectorB);

vectorA.logX();
// 4vectorA.logY();
// 7vectorA.logZ();
// 10</pre></div><p class="calibre7">After <a id="id33" class="calibre1"/>extending<a id="id34" class="calibre1"/> the <code class="email">Point</code> class to a <code class="email">Vector</code> class in the example, we created two vectors named <code class="email">vectorA</code> and <code class="email">vectorB</code>, and finally composed them.</p></div></div>
<div class="book" title="Accessing object properties"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec14" class="calibre1"/>Accessing object properties</h1></div></div></div><p class="calibre7">We have <a id="id35" class="calibre1"/>just seen how Ember.js objects are created. Did you notice how Ember.js object properties are accessed? Ember.js provides the <code class="email">get</code> and <code class="email">set</code> property accessor methods. Why not access these values directly? Well, these methods are used to recalculate values as well as notify any changes made when necessary. For example:</p><div class="informalexample"><pre class="programlisting">var point = Point.create();
point.set('x', 3);
console.log(point.get('x')); // 3</pre></div><p class="calibre7">Properties <a id="id36" class="calibre1"/>can also be read and set collectively using the <a id="id37" class="calibre1"/>
<code class="email">getProperties</code> and <a id="id38" class="calibre1"/>
<code class="email">setProperties</code> methods. This prevents Ember.js from unnecessarily making too many notifications about these changes, for example:</p><div class="informalexample"><pre class="programlisting">var point = Point.create();
point.setProperties({
  x: 1,
  y: 2,
  z: 3
});
console.log(point.getProperties('x', 'y', 'z'));
//{x: 1, y: 2, z: 3}</pre></div></div>
<div class="book" title="Defining class instance methods"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec15" class="calibre1"/>Defining class instance methods</h1></div></div></div><p class="calibre7">Classes <a id="id39" class="calibre1"/>can also define instance methods. These methods have a similar signature to object properties, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var MyClass = ClassName.extend({
  methodName: function(){
    // method implementation
  }
});</pre></div><p class="calibre7">Ember.js provides the ability to reuse implementations of parent methods in extended classes by the use of the <a id="id40" class="calibre1"/>
<code class="email">_super()</code> method. For example, the following example reimplements and reuses the <code class="email">logX</code> method in the <code class="email">Point</code> class:</p><div class="informalexample"><pre class="programlisting">var MyPoint = Point.extend({
  logX: function(){
   var x = this._super(); // call parent method
   console.log('x: %s', x);
  }
});
var myPoint = MyPoint.create({
  x: 3
});
myPoint.logX(); // x: 3</pre></div><p class="calibre7">Ember.js objects usually define a constructor method called <code class="email">init()</code>, which is called on an instance <a id="id41" class="calibre1"/>creation. Any initializations should be done inside this method. It's worth noting that the <code class="email">_super()</code> method should always be called on any inherited methods such as <code class="email">init()</code> to avoid losing parent implementations, for example:</p><div class="informalexample"><pre class="programlisting">var Book = Ember.Object.extend({
  init: function(){
    this._super();
    this.set('name', 'Mastering Ember.js'); // initialization
  }
});</pre></div></div>
<div class="book" title="Defining computed properties"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec16" class="calibre1"/>Defining computed properties</h1></div></div></div><p class="calibre7">What is a <a id="id42" class="calibre1"/>computed property? A computed property is the one whose value is returned from a function. For example:</p><div class="informalexample"><pre class="programlisting">var Movie = Ember.Object.extend({
  name: function(){
    return 'Transformers';
  }.property()
});

var movie = Movie.create();
console.log(movie.get('name')); // Transformers</pre></div><p class="calibre7">The preceding example creates a computed property <code class="email">name</code> that returns the name of a movie instance.</p><p class="calibre7">We simply transformed a method into a computed property by chaining the <code class="email">property()</code> function to it. The true power of computed properties comes from them being able to produce different values based on prespecified dependent properties. These dependent properties are usually passed as arguments to the <a id="id43" class="calibre1"/>
<code class="email">property()</code> function. For example:</p><div class="informalexample"><pre class="programlisting">var Movie = Ember.Object.extend({
  year: '2007',
  seriesNumber: '1',
  name: function(){
    return this.get('seriesNumber') + '. Transformers - ' + this.get('year');
  }.property('year', 'seriesNumber')
})

var movie = Movie.create();
console.log(movie.get('name')); // 1. Transformers – 2007

movie.set('year', '2014');
movie.set('seriesNumber', '4');
console.log(movie.get('name')); // 4. Transformers – 2014</pre></div><p class="calibre7">In the preceding example, the <code class="email">name</code> property is always recomputed whenever a movie's <code class="email">seriesNumber</code> and <code class="email">year</code> change.</p><p class="calibre7">Computed properties <a id="id44" class="calibre1"/>can also have property dependencies of enumerable data. The <code class="email">@each</code> helper<a id="id45" class="calibre1"/> can be used to set up computed properties on such kinds of properties. For example:</p><div class="informalexample"><pre class="programlisting">var Country = Ember.Object.extend({
  stateNames: function(){
  return this.get('states').map(function(state){
    return state['name'];
  });
  }.property('states.@each.name')
});

var country = Country.create({
  states: [ {name: 'Texas'}, {name: 'Ohio'} ],
});
console.log(country.get('stateNames')); // ['Texas', 'Ohio']

country.set('states', [ {name: 'Alabama'}, {name: 'Arizona'} ]);
console.log(country.get('stateNames')); // ['Alabama', 'Arizona']</pre></div><p class="calibre7">In the preceding example, we created a <code class="email">country</code> object that has two <code class="email">states</code>. We then defined a computed property, <code class="email">stateNames</code> that returns an array of the state names. A change to any of the state names results in a recalculation of the property.</p></div>
<div class="book" title="Defining property observers"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec17" class="calibre1"/>Defining property observers</h1></div></div></div><p class="calibre7">In <a id="id46" class="calibre1"/>addition to computed properties, you can also set <code class="email">observers</code> to properties. Observers are functions that get called when the properties they subscribe to change. They have the same signature as computed properties but use the <a id="id47" class="calibre1"/>
<code class="email">observers</code> function, as shown in the following code:</p><div class="informalexample"><pre class="programlisting">var MyClass = ClassName.extend({
  observerName: function(){
    // observer implementation
  }.observes([properties, ...])
});</pre></div><p class="calibre7">The following example defines a session class that sets up an observer that makes the user relogin as soon as the session expires:</p><div class="informalexample"><pre class="programlisting">var Session = Em.Object.extend({
  expiredChanged: function(){
    if (this.get('expired')){
      window.location.assign('/login');
    }
  }.observes('expired')
});</pre></div><p class="calibre7">Observers have no<a id="id48" class="calibre1"/> strict naming convention, but most developers name observers by appending <code class="email">DidChange</code> to the property that is being observed, as shown:</p><div class="informalexample"><pre class="programlisting">var Song = Em.Object.extend({
  playedDidChange: function(){
    
  }.observes('played')
});</pre></div><p class="calibre7">Just like computed properties, observers can also subscribe to an unlimited number of properties:</p><div class="informalexample"><pre class="programlisting">var Player = Em.Object.extend({
  inMotion: function(){
  
  }.observes('running', 'walking)
});</pre></div><p class="calibre7">Here, the <code class="email">inMotion</code> property will be recalculated when either the <code class="email">running</code> or <code class="email">walking</code> property changes.</p><p class="calibre7">Observers can also be set up and torn down using the <a id="id49" class="calibre1"/>
<code class="email">addObserver()</code> and <code class="email">removeObserver()</code> methods<a id="id50" class="calibre1"/> respectively. These become handy when you want to manage observers yourself. For example, the preceding sample can be rewritten as:</p><div class="informalexample"><pre class="programlisting">var Session = Em.Object.extend({
  init: function(){

    var self = this;

    self._super();
    self.addObserver('expired', function(){
    if (self.get('expired')){
      self.removeObserver('expired');
      window.location.assign('/login');
    }
  });
  
}
});</pre></div><p class="calibre7">As shown in the preceding code, the <code class="email">addObserver</code> method takes at least two arguments: the property <a id="id51" class="calibre1"/>to observe and the function to call whenever the property changes. In our example, we also tear down the observer listener by calling the <code class="email">removeObserver</code> method. This method takes one argument, which is the property to unbind from.</p><p class="calibre7">Ember.js also provides a way to pass the context to use in the <a id="id52" class="calibre1"/>
<code class="email">observer</code> function. For example:</p><div class="informalexample"><pre class="programlisting">var Session = Em.Object.extend({
  init: function(){

    this._super();
    this.addObserver('expired', this, function(){
      if (this.get('expired')){
        this.removeObserver('expired');
        window.location.assign('/login');
      }
    });
    
  }
});</pre></div><p class="calibre7">It is important to note that observers only fire on property changes that occur after object initialization. An <code class="email">on('init')</code> method <a id="id53" class="calibre1"/>can be applied to an observer to make it fire on changes that could occur during an object initialization. For example:</p><div class="informalexample"><pre class="programlisting">var Song = Em.Object.extend({
  skipped: false,
  played: false,
  skippedDidChange: function(){
    // does not fire on object initialization
    console.log('song was skipped');
  }.observes('skipped'),
  playedDidChange: function(){
    // fires on object initialization
    console.log('song finished playing');
  }.observes('played').on('init'),
  init: function(){
    this._super();
    this.set('skipped', true);
    this.set('played', true);
  }
});

Song.create();</pre></div><p class="calibre7">The example <a id="id54" class="calibre1"/>defines two observers: <code class="email">skippedDidChange</code> and <code class="email">playedDidChange</code>, of which, only the latter is called after an object initialization.</p></div>
<div class="book" title="Creating property bindings"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec18" class="calibre1"/>Creating property bindings</h1></div></div></div><p class="calibre7">Ember.js <a id="id55" class="calibre1"/>provides support for both one- and two-way bindings. A binding is a link between two properties of the same or different objects, such that they are always in sync. This means that an update to one of the properties results in the other property being updated to the new value. Bindings are defined in the following signature:</p><div class="informalexample"><pre class="programlisting">property: Ember.computed.alias('otherProperty'),</pre></div><p class="calibre7">In this case, the two properties <code class="email">property</code> and <code class="email">otherProperty</code> always stay in sync. Here's an example:</p><div class="informalexample"><pre class="programlisting">var author = Em.Object.create({
  name: 'J. K. Rowling'
});

var book = Em.Object.create({
  name: 'Harry Potter',
  authorName: Ember.computed.alias('author.name')
});

console.log(book.get('authorName')); // J. K. Rowling

author.set('name', 'Joanne Rowling');
console.log(book.get('authorName')); //  Joanne Rowling</pre></div><p class="calibre7">In the preceding example, the <code class="email">book</code> instance has an <code class="email">author</code> property that binds to the created global author instance. Any changes made to the name of the author will be reflected in the bound book author property. Likewise, any changes made to the book's author property will be propagated back to the global author as shown:</p><div class="informalexample"><pre class="programlisting">book.set('authorName', 'Joanne Jo Rowling');
console.log(author.get('name')); // Joanne Jo Rowling</pre></div><p class="calibre7">This is an example of a two-way binding where an update to either property results in the other property being updated.</p><p class="calibre7">Ember.js also supports one-way bindings where updates are unidirectional. A property can subscribe to <a id="id56" class="calibre1"/>updates from a different property but will not update the latter if the former changes. For example:</p><div class="informalexample"><pre class="programlisting">var author = Em.Object.create({
  name: 'J. K. Rowling'
});

var book = Em.Object.create({
  name: 'Harry Potter',
  authorName: Ember.computed.oneWay('author')
});

console.log(book.get('authorName')); // J. K. Rowling

book.set('author.name', 'Joanne Rowling');
// author's name remains unchanged
console.log(author.get('name')); //  J. K. Rowling</pre></div><p class="calibre7">In the preceding snippet, the book property changes will not affect the bound author's name property.</p></div>
<div class="book" title="Using mixins"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec19" class="calibre1"/>Using mixins</h1></div></div></div><p class="calibre7">Mixins<a id="id57" class="calibre1"/> are <a id="id58" class="calibre1"/>abstract definitions that define methods and properties that classes and objects can reuse. For example, consider these two objects:</p><div class="informalexample"><pre class="programlisting">var myView = Em.View.create({
  sum: function(a, b){
    return a+b;
  }
});

var myController = Em.Controller.create({
  sum: function(a, b){
    return a+b;
  }
});</pre></div><p class="calibre7">These two objects share a common function that can be abstracted into a mixin:</p><div class="informalexample"><pre class="programlisting">var sumMixin = Em.Mixin.create({
  sum: function(a, b){
    return a+b;
  }
});

var myView = Em.View.createWithMixins(sumMixin);

var myController = Em.Controller.createWithMixins(sumMixin);</pre></div><p class="calibre7">Any <a id="id59" class="calibre1"/>number of mixins can be passed to objects or classes on creation or definition, respectively:</p><div class="informalexample"><pre class="programlisting">App.Number = Em.Object.extend(sumMixin, diffMixin, productMixin);</pre></div><p class="calibre7">It is important to note that mixins are always <span class="strong"><em class="calibre9">created</em></span> and never <span class="strong"><em class="calibre9">extended</em></span>. The example also showed that objects reusing mixins are always created using the <code class="email">createWithMixins</code> method<a id="id60" class="calibre1"/> on instantiation and not the <code class="email">create</code> method. However, classes still use the <code class="email">extend</code> method when applying mixins.</p></div>
<div class="book" title="Reopening classes and instances"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec20" class="calibre1"/>Reopening classes and instances</h1></div></div></div><p class="calibre7">Sometimes, it is <a id="id61" class="calibre1"/>necessary to update class implementations without redefining them. This is usually necessary when we do not wish to extend built-in classes, but only want to update their implementations. Ember.js refers to this as reopening of classes and objects. Class methods and properties can be reimplemented using the <code class="email">reopenClass</code> method<a id="id62" class="calibre1"/>, while <a id="id63" class="calibre1"/>instance methods and properties can be updated using the <a id="id64" class="calibre1"/>
<code class="email">reopen</code> method. It's however discouraged to change built-ins as they may change in future versions.</p><p class="calibre7">For example:</p><div class="informalexample"><pre class="programlisting">var Book = Em.Object.extend();

Book.reopen({
  id: null,
  title: null,
  purchase: function(){
    console.log('sold');
  }
});

Book.reopenClass({
  getById: function(id){
      return Book.create({
        id: '456',
        title: 'Harry Potter'
      });
  } 
});

Book.create({
  id: 456,
  title: 'Harry Potter'
});

var book = Book.getById(456);

book.purchase();</pre></div><p class="calibre7">In the preceding <a id="id65" class="calibre1"/>example, we <a id="id66" class="calibre1"/>added an instance method, <code class="email">purchase</code>, and two properties, <code class="email">id</code> and <code class="email">name</code> to the already defined <code class="email">Book</code> class. We have also added a class method, <code class="email">getById</code>, without extending the class.</p></div>
<div class="book" title="Event subscription"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec21" class="calibre1"/>Event subscription</h1></div></div></div><p class="calibre7">Another way of <a id="id67" class="calibre1"/>notifying changes in an application is through event subscription. This paradigm is used heavily in Node.js to channel messages and events across different components of an application. Ember.js provides the <code class="email">Ember.Evented</code> mixin<a id="id68" class="calibre1"/> that can be used to serve archive this easily. For example, blocks in a board game can subscribe to instructions from an actuator as in the following example:</p><div class="informalexample"><pre class="programlisting">var GRID_SIZE = 4; 
var actuator = Em.Object.createWithMixins(Em.Evented);

var block = Em.Object.createWithMixins(Em.Evented);
acuator.on('moveRight', function(){
  var x = block.get('x') + 1;
  x = x % GRID_SIZE; 
  block.set('x', x);
});

actuator.trigger('moveRight');</pre></div><p class="calibre7">The mixin provides five essential methods, two of which have been illustrated in the preceding example:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">on</code>: This<a id="id69" class="calibre1"/> is used to subscribe to an event</li><li class="listitem"><code class="email">off</code>: This<a id="id70" class="calibre1"/> is used to disable a subscription</li><li class="listitem"><code class="email">one</code>: This<a id="id71" class="calibre1"/> is used to subscribe once to an event</li><li class="listitem"><code class="email">trigger</code>: This <a id="id72" class="calibre1"/>is used to emit an event</li><li class="listitem"><code class="email">has</code>: This is<a id="id73" class="calibre1"/> used to check if an event has been subscribed to</li></ul></div></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch02lvl1sec22" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">This chapter has focused on introducing Ember.js objects. We will use these objects extensively in the next chapter, where we will learn how state management is accomplished in Ember.js using routers. We will discuss how to construct routes and routers. That being said, you should have learned the following Ember.js object concepts in this chapter:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Creating objects and classes in Ember.js</li><li class="listitem">Getting and setting object properties</li><li class="listitem">Defining computed properties</li><li class="listitem">Defining property observers</li><li class="listitem">Creating property bindings</li><li class="listitem">Using mixins</li><li class="listitem">Reopening Ember.js classes</li></ul></div><p class="calibre7">In the next chapter, we will be discussing routes, which are one of these classes that are extended from <code class="email">Ember.Object</code>.</p></div></body></html>