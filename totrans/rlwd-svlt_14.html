<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer043">
<h1 class="chapter-number" id="_idParaDest-200"><a id="_idTextAnchor202"/>14</h1>
<h1 id="_idParaDest-201"><a id="_idTextAnchor203"/>Exploring Custom Transitions</h1>
<p>In this chapter, we will delve into the world of custom transitions in Svelte. So far, we have explored Svelte’s built-in transitions and how they can be used to create engaging and dynamic user interfaces. However, there may be situations where the built-in transitions don’t quite meet your requirements and you want to create something more unique. This is where custom transitions come <span class="No-Break">into play.</span></p>
<p>Custom transitions allow you to take full control over the animations and effects that you want to achieve in your Svelte application. This chapter will guide you through the process of creating your own custom transitions, whether they are CSS- or JavaScript-based. We will explore the transition contract, which serves as the foundation for creating custom transitions, and provide practical examples to help you <span class="No-Break">get started.</span></p>
<p>By the end of this chapter, you will have a solid understanding of how to create custom transitions in Svelte, and you will be equipped with the knowledge to implement them in your own projects, taking your user interfaces to the <span class="No-Break">next level.</span></p>
<p>This chapter includes sections on the <span class="No-Break">following topics:</span></p>
<ul>
<li>The <span class="No-Break">transition contract</span></li>
<li>Writing a custom CSS transition using the <span class="No-Break"><strong class="source-inline">css</strong></span><span class="No-Break"> function</span></li>
<li>Writing a custom JavaScript transition using the <span class="No-Break"><strong class="source-inline">tick</strong></span><span class="No-Break"> function</span></li>
</ul>
<h1 id="_idParaDest-202"><a id="_idTextAnchor204"/>Technical requirements</h1>
<p>This chapter will be somewhat code-heavy, but don’t worry—you can find all the code samples used in this chapter on GitHub <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor205"/>The transition contract</h1>
<p>Before we dive into creating custom transitions, it’s essential to understand the foundation upon which they are built: the <span class="No-Break">transition contract.</span></p>
<p>If you’ve read <a href="B18887_09.xhtml#_idTextAnchor135"><span class="No-Break"><em class="italic">Chapter 9</em></span></a>, you’ll be familiar with the concept of a store contract. Just as a store is an object that adheres to a specific store contract, a transition is a function that follows a transition contract. By understanding and adhering to these contracts, you can create custom transitions that integrate seamlessly with Svelte’s built-in <span class="No-Break">transition system.</span></p>
<p>The transition contract <a id="_idIndexMarker539"/>consists of a single function that is responsible for <a id="_idIndexMarker540"/>the transition. This function accepts <span class="No-Break">two arguments:</span></p>
<ul>
<li><strong class="source-inline">node</strong>: The target DOM element that the transition will be <span class="No-Break">applied to</span></li>
<li><strong class="source-inline">params</strong>: An object containing <span class="No-Break">configuration options</span></li>
</ul>
<p>The function should return an object that describes how the transition should be executed. We will delve into the details of this returned object later in <span class="No-Break">the section.</span></p>
<p>Here is an example of a custom transition that adheres to the <span class="No-Break">transition contract:</span></p>
<pre class="source-code">
function customTransition(node, params) {
  const config = { ... };
  return config;
}</pre> <p>In the preceding code snippet, we have created a custom transition named <strong class="source-inline">customTransition</strong>. We did this by declaring a <strong class="source-inline">customTransition</strong> function that takes in two parameters: <strong class="source-inline">node</strong> and <strong class="source-inline">params</strong>. This function then returns an object—which we’ll refer to as <strong class="source-inline">config</strong>—that describes <span class="No-Break">the transition.</span></p>
<p>To relate the custom transition we’ve just created back to the usage of a transition in Svelte, here, we see how the <strong class="source-inline">customTransition</strong> function is applied to a <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">div&gt;</strong></span><span class="No-Break"> element:</span></p>
<pre class="source-code">
&lt;div transition:customTransition={{ duration: 500 }}&gt;some text&lt;/div&gt;</pre> <p>When the <strong class="source-inline">&lt;div&gt;</strong> element is inserted or about to be removed from the DOM, Svelte will attempt to play the transition. Svelte does this by calling the <strong class="source-inline">customTransition</strong> function with a reference to the <strong class="source-inline">&lt;div&gt;</strong> element and the <strong class="source-inline">config</strong> object passed to <span class="No-Break">the transition:</span></p>
<pre class="source-code">
const config = customTransition(div, { duration: 500 });</pre> <p>This <strong class="source-inline">config</strong> object returned by <strong class="source-inline">customTransition</strong> will determine how the transition is <span class="No-Break">played out.</span></p>
<p>Now, let’s focus <a id="_idIndexMarker541"/>on the requirements for the <strong class="source-inline">config</strong> object returned by the custom <span class="No-Break">transition function.</span></p>
<p>The <strong class="source-inline">config</strong> object<a id="_idIndexMarker542"/> returned from a custom transition should include at least one of the following properties <span class="No-Break">or methods:</span></p>
<ul>
<li><strong class="source-inline">delay</strong>: A number specified in milliseconds. This specifies how long to wait before the <span class="No-Break">transition begins.</span></li>
<li><strong class="source-inline">duration</strong>: A number specified in milliseconds. The duration that the transition will play. This determines how fast or slow the animation appears to <span class="No-Break">the user.</span></li>
<li><strong class="source-inline">easing</strong>: A function for easing the transition. This function determines the rate of change in the transition’s progress <span class="No-Break">over time.</span></li>
<li><strong class="source-inline">css</strong>: A function that is called with two parameters: <strong class="source-inline">progress</strong> and <strong class="source-inline">remaining</strong>. Here,  <strong class="source-inline">progress</strong> is a value between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong> representing the progress of the transition, and the value of the <strong class="source-inline">remaining</strong> parameter is equal to <strong class="source-inline">1 - </strong><span class="No-Break"><strong class="source-inline">progress</strong></span><span class="No-Break">.</span><p class="list-inset">This function should return a string containing the CSS styles to be applied to the target <span class="No-Break">DOM element.</span></p></li>
<li><strong class="source-inline">tick</strong>: A function that is called repeatedly during the transition with two parameters: <strong class="source-inline">progress</strong> and <strong class="source-inline">remaining</strong>. Here, <strong class="source-inline">progress</strong> is a value between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong> indicating the progress of the transition, and the value of the <strong class="source-inline">remaining</strong> parameter is equal to <strong class="source-inline">1 - </strong><span class="No-Break"><strong class="source-inline">progress</strong></span><span class="No-Break">.</span><p class="list-inset">This function can be <a id="_idIndexMarker543"/>used to update the DOM element’s styles based on the <span class="No-Break">current progress.</span></p></li>
</ul>
<p>Here is a more <a id="_idIndexMarker544"/>complete sample of a custom transition that follows the <span class="No-Break">transition contract:</span></p>
<pre class="source-code">
import { cubicInOut } from 'svelte/easing';
function customTransition(node, params) {
  return {
    duration: 1000,
    delay: 500,
    easing: cubicInOut,
    css: (progress) =&gt; `opacity: ${progress}`,
  };
}</pre> <p>In the preceding code snippet, our custom transition, named <strong class="source-inline">customTransition</strong>, returns an object that describes the transition’s <strong class="source-inline">duration</strong>, <strong class="source-inline">delay</strong>, <strong class="source-inline">easing</strong>, and <span class="No-Break"><strong class="source-inline">css</strong></span><span class="No-Break"> styles.</span></p>
<p>We saw <strong class="source-inline">delay</strong>, <strong class="source-inline">duration</strong>, and <strong class="source-inline">easing</strong> in the previous chapter when applying transitions to an element. Since the behavior of these properties remains the same in this context, let us focus on something new: the <strong class="source-inline">css</strong> and <span class="No-Break"><strong class="source-inline">tick</strong></span><span class="No-Break"> functions.</span></p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor206"/>The css function</h2>
<p>As you might <a id="_idIndexMarker545"/>remember from the last section of the previous chapter, <em class="italic">How Svelte transitions work under the hood</em>, Svelte animates transitions using a <a id="_idIndexMarker546"/>combination of CSS and JavaScript. It leverages CSS <strong class="source-inline">@keyframe</strong> rules along with the <strong class="source-inline">animation</strong> property for CSS animations and the <strong class="source-inline">requestAnimationFrame</strong> function for <span class="No-Break">JavaScript animations.</span></p>
<p>The <strong class="source-inline">css</strong> function is used to generate CSS <strong class="source-inline">@keyframe</strong> rules for custom transitions. If the <strong class="source-inline">css</strong> function is defined in the returned object of a custom transition, Svelte will call this function when an element is inserted into the DOM or about to be removed from the DOM. Svelte will call the <strong class="source-inline">css</strong> function as many times as necessary, depending on the duration and easing of the transition, in order to generate the appropriate <strong class="source-inline">@</strong><span class="No-Break"><strong class="source-inline">keyframe</strong></span><span class="No-Break"> rules.</span></p>
<p>The <a id="_idIndexMarker547"/>first parameter of the <strong class="source-inline">css</strong> function relates to the progress of <a id="_idIndexMarker548"/>the transition. <strong class="source-inline">progress</strong> is a number between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, where <strong class="source-inline">0</strong> represents the element being out of view, and 1 represents the element being in its final position on <span class="No-Break">the screen.</span></p>
<p>For example, when transitioning an element in after it has been inserted into the DOM, the value of <strong class="source-inline">progress</strong> starts at <strong class="source-inline">0</strong> and moves toward <strong class="source-inline">1</strong>. Conversely, when transitioning an element out before it is removed from the DOM, the value of <strong class="source-inline">progress</strong> starts at <strong class="source-inline">1</strong> and moves <span class="No-Break">toward </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
<p>You can use <strong class="source-inline">progress</strong> to calculate the CSS styles necessary to create your <span class="No-Break">custom transition.</span></p>
<p>For example, if we want to create a transition that fades an element from transparent to fully visible, we can use <strong class="source-inline">progress</strong> to calculate the opacity value throughout <span class="No-Break">the transition:</span></p>
<ul>
<li>When the element is out of view (value of <strong class="source-inline">progress</strong> is <strong class="source-inline">0</strong>), we want the element to be transparent (value of <strong class="source-inline">opacity</strong> should <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">)</span></li>
<li>When the element is in view (value of <strong class="source-inline">progress</strong> is <strong class="source-inline">1</strong>), we want the element to be fully visible (value of <strong class="source-inline">opacity</strong> should <span class="No-Break">be </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">)</span></li>
</ul>
<p>The relationship between <strong class="source-inline">progress</strong> and <strong class="source-inline">opacity</strong> can be represented by the diagram shown in <span class="No-Break"><em class="italic">Figure 14</em></span><span class="No-Break"><em class="italic">.1</em></span><span class="No-Break">:</span></p>
<p class="IMG---Figure">igure 14.1: Relationship between progress and opacity</p>
<p>We are going <a id="_idIndexMarker549"/>to derive the value of <strong class="source-inline">opacity</strong> from the value of <strong class="source-inline">progress</strong> in the <strong class="source-inline">css</strong> function, <span class="No-Break">like so:</span></p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    css: <strong class="bold">(progress) =&gt; `opacity: ${progress}`</strong>,
  };
}</pre> <p>Applying the<a id="_idIndexMarker550"/> transition in the preceding code will give you an element that fades from transparent to visible when inserted into the DOM and fades back to transparent when removed from <span class="No-Break">the DOM.</span></p>
<p>Let us take another example. Let us create a transition that flies the element from the right to its final position. Here, the translation of the element changes throughout the transition, and we can use <strong class="source-inline">progress</strong> to calculate <span class="No-Break">the translation:</span></p>
<ul>
<li>When the element is out of view (value of <strong class="source-inline">progress</strong> is <strong class="source-inline">0</strong>), we want the element to be on the right (value of <strong class="source-inline">translateX</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">100px</strong></span><span class="No-Break">)</span></li>
<li>When the element is in view (value of <strong class="source-inline">progress</strong> is <strong class="source-inline">1</strong>), we want the element to be at its final position (value of <strong class="source-inline">translateX</strong> <span class="No-Break">is </span><span class="No-Break"><strong class="source-inline">0px</strong></span><span class="No-Break">)</span></li>
</ul>
<p>Here’s a diagram depicting the relationship between <strong class="source-inline">progress</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">translateX</strong></span><span class="No-Break">:</span></p>
<p class="IMG---Figure">igure 14.2: Relationship between progress and translateX</p>
<p>Unlike the <a id="_idIndexMarker551"/>previous example, the value of <strong class="source-inline">translateX</strong> is the inverse of <strong class="source-inline">progress</strong>: when <strong class="source-inline">progress</strong> is <strong class="source-inline">0</strong>, <strong class="source-inline">translateX</strong> has a nonzero value; when <strong class="source-inline">progress</strong> is 1, <strong class="source-inline">translateX</strong> <span class="No-Break">becomes </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
<p>So, to <a id="_idIndexMarker552"/>calculate the <strong class="source-inline">translateX</strong> value, we use <strong class="source-inline">1 – progress</strong> times a value, as you can see in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    css: <strong class="bold">(progress) =&gt; `transform: translateX(${(1 – progress) * 100}px)`</strong>,
  };
}</pre> <p>When applying the <strong class="source-inline">customTransition</strong> function in the preceding code snippet to an element, as the element is added to the DOM, the element will fly in from the right to its final position. And because calculating the inverse of <strong class="source-inline">progress</strong> (<strong class="source-inline">1 – progress</strong>) is so commonly done, the value is provided as a second argument of the <span class="No-Break"><strong class="source-inline">css</strong></span><span class="No-Break"> function.</span></p>
<p>So, here is our custom transition again, but using the second argument instead to calculate <span class="No-Break">the translation:</span></p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    css: <strong class="bold">(progress, remaining) =&gt; `transform: translateX(${remaining * 100}px)`</strong>,
  };
}</pre> <p>The <strong class="source-inline">css</strong> function <a id="_idIndexMarker553"/>returns a CSS string that can consist of multiple CSS declarations. You separate each CSS declaration with a semicolon, just <a id="_idIndexMarker554"/>as you would in a <strong class="source-inline">style</strong> attribute of an element. For example, let’s create a transition that combines fading in and translating from the <span class="No-Break">right simultaneously:</span></p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    css: (progress, remaining) =&gt; `opacity: ${progress}; transform: translateX(${remaining * 100}px); `,
  };
}</pre> <p>In the preceding code snippet, we combine both fading in and translating from the right simultaneously. The returned CSS string contains multiple CSS declarations separated by semicolons, one for <strong class="source-inline">opacity</strong> and another for <strong class="source-inline">transform</strong>, that will be applied during <span class="No-Break">the transition.</span></p>
<p>Now that we have covered the <strong class="source-inline">css</strong> function, let us look at the <span class="No-Break"><strong class="source-inline">tick</strong></span><span class="No-Break"> function.</span></p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor207"/>The tick function</h2>
<p>The <strong class="source-inline">tick</strong> function <a id="_idIndexMarker555"/>serves as an alternative to the <strong class="source-inline">css</strong> function<a id="_idIndexMarker556"/> for creating custom transitions. Unlike the <strong class="source-inline">css</strong> function, which is used to generate CSS <strong class="source-inline">@keyframe</strong> rules for the animation, the <strong class="source-inline">tick</strong> function allows you to animate a transition using JavaScript. This can provide more fine-grained control over the transition, enabling the creation of more complex animations that may not be easily achieved with <span class="No-Break">CSS alone.</span></p>
<p>The <strong class="source-inline">tick</strong> function is called repeatedly during the transition through <strong class="source-inline">requestAnimationFrame</strong>. Similar to the <strong class="source-inline">css</strong> function, the <strong class="source-inline">tick</strong> function accepts two parameters: <strong class="source-inline">progress</strong> and <strong class="source-inline">remaining</strong>. The <strong class="source-inline">progress</strong> parameter is a value between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, where <strong class="source-inline">0</strong> represents the element being out of view, and 1 represents the element being in its final position on the screen, while the <strong class="source-inline">remaining</strong> parameter is equal to <strong class="source-inline">1 – progress</strong>. These parameters can be used to modify the DOM element the transition is applied to, based on the current progress of <span class="No-Break">the transition.</span></p>
<p>For example, if we <a id="_idIndexMarker557"/>want to create a fade-in transition <a id="_idIndexMarker558"/>using the <strong class="source-inline">tick</strong> function, you can update the element’s opacity based on the progress value, as <span class="No-Break">illustrated here:</span></p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    tick: (progress) =&gt; {
      node.style.opacity = progress;
    },
  };
}</pre> <p>Based on the preceding code snippet, Svelte triggers the <strong class="source-inline">tick</strong> function during every animation frame throughout <span class="No-Break">the transition.</span></p>
<p>When the element starts to appear, the <strong class="source-inline">progress</strong> value is <strong class="source-inline">0</strong>, and we use this <strong class="source-inline">progress</strong> value to set the initial <strong class="source-inline">opacity</strong> value of the element <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0</strong></span><span class="No-Break">.</span></p>
<p>As the transition continues, the <strong class="source-inline">tick</strong> function is called with <strong class="source-inline">progress</strong> values between <strong class="source-inline">0</strong> and <strong class="source-inline">1</strong>, and we update the element’s <strong class="source-inline">opacity</strong> value based on the <span class="No-Break"><strong class="source-inline">progress</strong></span><span class="No-Break"> value.</span></p>
<p>At the end of the transition, the <strong class="source-inline">tick</strong> function is called one last time with a <strong class="source-inline">progress</strong> value of 1. At this point, we set the element’s <strong class="source-inline">opacity</strong> value to its final value <span class="No-Break">of 1.</span></p>
<p>The <strong class="source-inline">tick</strong> function in the preceding code snippet operates similarly to the custom fade-in transition we created using the <strong class="source-inline">css</strong> function. Both approaches modify the element’s <strong class="source-inline">opacity</strong> value throughout the transition. The key difference lies in how they <span class="No-Break">are executed.</span></p>
<p>Svelte calls the <strong class="source-inline">css</strong> function multiple times with different progress values at the beginning of the transition to construct the CSS <strong class="source-inline">@keyframe</strong> rules. Once this is done, the <strong class="source-inline">css</strong> function is not called again during the transition. The newly created CSS <strong class="source-inline">@keyframe</strong> rule is then applied to the element through the CSS <strong class="source-inline">animation</strong> property. The <a id="_idIndexMarker559"/>element’s <strong class="source-inline">opacity</strong> value is then updated <span class="No-Break">through CSS.</span></p>
<p>On the other hand, the <strong class="source-inline">tick</strong> function<a id="_idIndexMarker560"/> is called multiple times by Svelte during each animation frame throughout the transition. On every tick call, the element’s <strong class="source-inline">opacity</strong> value is modified <span class="No-Break">by JavaScript.</span></p>
<p>Now that we have learned about the transition contract, let us use this knowledge to create a few more <span class="No-Break">custom transitions.</span></p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor208"/>Writing a custom CSS transition using the css function</h1>
<p>The first <a id="_idIndexMarker561"/>custom transition we will be attempting to write together is an effect often witnessed in presentations, commonly referred to as the “color swipe.” This effect stands out due to its dynamic sweep of color that flows across the screen, creating a sense of energy that captivates the <span class="No-Break">viewer’s attention.</span></p>
<p>The color swipe transition, as its name suggests, involves a sweeping change in color that takes place over <span class="No-Break">an object.</span></p>
<p>Picture this: you’re looking at a static screen, possibly a section of a website. Suddenly, a new color begins to surface from one edge of the screen. Like a wave, this color spreads across the screen, enveloping it. As soon as the color completely covers the screen, it starts to recede from the edge of origin, revealing new content. When the color entirely withdraws, the new content is <span class="No-Break">fully unveiled:</span></p>
<p class="IMG---Figure">igure 14.3: The color swipe transition</p>
<p>The <em class="italic">swipe</em> can move in from any direction—it can move horizontally from left to right, vertically from top to bottom, or <span class="No-Break">even diagonally.</span></p>
<p>We are <a id="_idIndexMarker562"/>going to modify the color swipe transition to apply to paragraph (<strong class="source-inline">&lt;p&gt;</strong>) elements. When a <strong class="source-inline">&lt;p&gt;</strong> element is added to the DOM, a wave of color will sweep over it, unveiling the text within the <strong class="source-inline">&lt;p&gt;</strong> element upon completion of the transition. When the <strong class="source-inline">&lt;p&gt;</strong> element is removed from the DOM, the reverse of the transition is played, concealing the text upon completion of <span class="No-Break">the transition.</span></p>
<p>A visualization of the transition can be <span class="No-Break">seen here:</span></p>
<p class="IMG---Figure">igure 14.4: The color swipe transition on paragraphs</p>
<p>In this section, we will walk through step by step how to create this captivating color swipe transition <span class="No-Break">using Svelte.</span></p>
<p>Since the transition that conceals the text when the <strong class="source-inline">&lt;p&gt;</strong> element is being removed from the DOM is the same as the transition that reveals the text when the <strong class="source-inline">&lt;p&gt;</strong> element is being added but played backward, we will focus on the transition played when a <strong class="source-inline">&lt;p&gt;</strong> element is added to the DOM. This is because when a transition is applied to an element, Svelte will play the same transition when the element is removed, but in reverse. Therefore, by focusing on the transition played when an element is added to the DOM, we effectively cover <span class="No-Break">both scenarios.</span></p>
<p>So, let us get started on creating <span class="No-Break">a transition.</span></p>
<p>Firstly, let us create the structure of our custom transition. Recall the transition contract—a transition is a function that returns an object describing <span class="No-Break">the transition:</span></p>
<pre class="source-code">
&lt;script&gt;
  function colourSwipe(node) {
    // TODO: implement the transition here
    const config = {};
    return config;
  }
&lt;/script&gt;
&lt;p transition:colourSwipe&gt;Some text here&lt;/p&gt;</pre> <p>In the <a id="_idIndexMarker563"/>preceding code snippet, we create a <strong class="source-inline">colourSwipe</strong> transition and apply it to the <strong class="source-inline">&lt;p&gt;</strong> element. Our current task is to implement the <strong class="source-inline">colourSwipe</strong> transition by populating the <span class="No-Break"><strong class="source-inline">config</strong></span><span class="No-Break"> object.</span></p>
<p>The first two fields that we are going to add to the <strong class="source-inline">config</strong> object are <strong class="source-inline">duration</strong> and <strong class="source-inline">delay</strong>. As shown in the following code snippet, we set the duration of the transition to 1 second, and the transition will have no delay <span class="No-Break">to start:</span></p>
<pre class="source-code">
function colourSwipe(node) {
  const config = {
<strong class="bold">    duration: 1000,</strong>
<strong class="bold">    delay: 0,</strong>
  };
  return config;
}</pre> <p>However, often when creating a custom transition, you may want to allow the user of the transition to customize the duration and delay based on where the transition is <span class="No-Break">being applied.</span></p>
<p>For example, a user of the transition may want to have a delay of 200 milliseconds and a duration of 2 seconds by specifying them in the <strong class="source-inline">transition:</strong> directive, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
&lt;div transition:colourSwipe={{ delay: 200, duration: 2000 }} /&gt;</pre> <p>These custom delays and durations specified in the <strong class="source-inline">transition:</strong> directive will be passed into the <strong class="source-inline">colourSwipe</strong> transition as the second argument, which will use them in the <span class="No-Break"><strong class="source-inline">config</strong></span><span class="No-Break"> object:</span></p>
<pre class="source-code">
function colourSwipe(node, <strong class="bold">params</strong>) {
  const config = {
    duration: <strong class="bold">params?.duration ?? 1000</strong>,
    delay: <strong class="bold">params?.delay ?? 0</strong>,
  };
  return config;
}</pre> <p>In the <a id="_idIndexMarker564"/>preceding code snippet, we use the values of <strong class="source-inline">params.duration</strong> and <strong class="source-inline">params.delay</strong> in the <strong class="source-inline">config</strong> object and provide a default value when these parameters aren’t <span class="No-Break">explicitly stated.</span></p>
<p>Now that we have specified the <strong class="source-inline">delay</strong> and the <strong class="source-inline">duration</strong> fields of the transition, let’s turn our attention to the <span class="No-Break">next field—</span><span class="No-Break"><strong class="source-inline">easing</strong></span><span class="No-Break">.</span></p>
<p>We are going to use a <strong class="source-inline">linear</strong> easing, making the transition move at a constant speed, without any acceleration or deceleration. As we did with <strong class="source-inline">duration</strong> or <strong class="source-inline">delay</strong>, we are going to make <strong class="source-inline">easing</strong> customizable by the user. So, in the following code snippet, we set the value of <strong class="source-inline">easing</strong> based on the user-specified easing. If it is left unspecified, we fall back on our default <span class="No-Break">easing—</span><span class="No-Break"><strong class="source-inline">linear</strong></span><span class="No-Break"> easing:</span></p>
<pre class="source-code">
<strong class="bold">import { linear } from 'svelte/easing';</strong>
function colourSwipe(node, params) {
  const config = {
    duration: params?.duration ?? 1000,
    delay: params?.delay ?? 0,
    <strong class="bold">easing: params?.easing ?? linear,</strong>
  };
  return config;
}</pre> <p>Typically, in the process of creating a custom transition, the <strong class="source-inline">duration</strong>, <strong class="source-inline">delay</strong>, and <strong class="source-inline">easing</strong> fields are the simplest to set up. More often than not, we determine default <strong class="source-inline">duration</strong>, <strong class="source-inline">delay</strong>, and <strong class="source-inline">easing</strong> values, and then offer the user the flexibility to tweak these to <span class="No-Break">their liking.</span></p>
<p>Having figured out the <strong class="source-inline">duration</strong>, <strong class="source-inline">delay</strong>, and <strong class="source-inline">easing</strong> values, we now delve into the crux of the transition: coming up with the CSS for the <span class="No-Break">transitioning element.</span></p>
<p>If you observe<a id="_idIndexMarker565"/> the transition carefully, you will notice that the transition can be divided into two distinct stages: the initial half involves the color block expanding to envelop the entire <strong class="source-inline">&lt;p&gt;</strong> element, and the latter half corresponds to the color block retracting to unveil the text within the <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">p&gt;</strong></span><span class="No-Break"> element:</span></p>
<p class="IMG---Figure">igure 14.5: The color swipe transition split into two halves, separated by dotted lines</p>
<p>Let’s explore how we can create these CSS rules to effectively bring to life these stages of <span class="No-Break">the transition.</span></p>
<p>Before we start, let us create a <strong class="source-inline">css</strong> function in our <span class="No-Break"><strong class="source-inline">colourSwipe</strong></span><span class="No-Break"> transition:</span></p>
<pre class="source-code">
function colourSwipe(node, params) {
  const config = {
    duration: params?.duration ?? 1000,
    delay: params?.delay ?? 0,
    easing: params?.easing ?? linear,
    <strong class="bold">css: (progress) =&gt; {}</strong>
  };
  return config;
}</pre> <p>We are going to fill in the <strong class="source-inline">css</strong> function in the preceding <span class="No-Break">code snippet.</span></p>
<p>It’s key to note that the <strong class="source-inline">progress</strong> value begins at <strong class="source-inline">0</strong> at the start of the transition and goes to 1 at the <a id="_idIndexMarker566"/>end of the transition. As we are splitting the transition into two stages, the first stage will see the <strong class="source-inline">progress</strong> value moving from <strong class="source-inline">0</strong> to <strong class="source-inline">0.5</strong>, while the second stage advances from <strong class="source-inline">0.5</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">1</strong></span><span class="No-Break">.</span></p>
<p>Hence, in our <strong class="source-inline">css</strong> function, we will implement different CSS rules for different stages of <span class="No-Break">the transition:</span></p>
<pre class="source-code">
css: (progress) =&gt; {
<strong class="bold">  if (progress &lt;= 0.5) {</strong>
<strong class="bold">  } else {</strong>
<strong class="bold">  }</strong>
}</pre> <p>In the preceding code snippet, you can see that we have added an <strong class="source-inline">if</strong> block in the <strong class="source-inline">css</strong> function, which uses the <strong class="source-inline">progress</strong> value to determine which sets of CSS rules to apply. For the first half of the transition (<strong class="source-inline">progress</strong> &lt;= 0.5), the first set of CSS rules is implemented. For the latter half (<strong class="source-inline">progress</strong> &gt; 0.5), the second set of rules is used. This way, we can customize the element’s appearance in distinct ways throughout the two stages of <span class="No-Break">the transition.</span></p>
<p>In the first half of our transition, we need to create a growing color block. To create this, we will apply a linear gradient on the background of the element. The gradient will transition from a solid color to a transparent color. By aligning the color stop point of the solid color and the transparent color at the same location, we can create a sharp hard line in the <span class="No-Break">gradient transition.</span></p>
<p>For example, if we want a solid red color block that occupies the left 25% of an element, we could apply the <span class="No-Break">following CSS:</span></p>
<pre class="source-code">
background: linear-gradient(to right, red 0, 25%, transparent 25%);</pre> <p>In the preceding snippet, we have a linear gradient moving from left to right, with the red and transparent colors sharing the same color stops at the 25% point. This creates a solid red block on the leftmost 25% of the gradient, while the remaining 75% <span class="No-Break">is transparent.</span></p>
<p>Our choice to use a linear gradient to achieve this color block, as opposed to superimposing another element, shows the simplicity of this approach. It eliminates the necessity of creating an <span class="No-Break">additional element.</span></p>
<p>Another benefit<a id="_idIndexMarker567"/> of setting a linear gradient on the background, instead of resizing the element, is to have a resizing color block effect without actually resizing an element, which would cause re-layout and layout shifts in the DOM. This way, the element with the applied CSS remains static in its original position and size throughout <span class="No-Break">the transition.</span></p>
<p>So, now we’ve figured out the CSS to use, let’s incorporate it into our transition’s <span class="No-Break"><strong class="source-inline">css</strong></span><span class="No-Break"> function.</span></p>
<p>Before that, we need to do some math. We intend to use the value of <strong class="source-inline">progress</strong> to calculate the percentage of the element to be covered by the solid <span class="No-Break">color block.</span></p>
<p>In the first half of the transition, the value of <strong class="source-inline">progress</strong> goes from <strong class="source-inline">0</strong> <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">0.5</strong></span><span class="No-Break">.</span></p>
<p>Within this phase of the transition, the percentage of the element that needs to be covered should range from 0% <span class="No-Break">to 100%.</span></p>
<p>Consequently, by performing arithmetic calculations, we can conclude that the percentage value is 200 times the value <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">progress</strong></span><span class="No-Break">:</span></p>
<pre class="source-code">
const percentage = progress * 200;</pre> <p>Let’s now integrate this into our <span class="No-Break"><strong class="source-inline">css</strong></span><span class="No-Break"> function:</span></p>
<pre class="source-code">
css: (progress) =&gt; {
  if (progress &lt;= 0.5) {
    <strong class="bold">const percentage = progress * 200;</strong>
    <strong class="bold">return `background: linear-gradient(to right, red 0, ${percentage}%, transparent ${percentage}%);`;</strong>
  } else {
  }
}</pre> <p>In the preceding code snippet, we use the calculated percentage to control the size of the solid color block, making it grow from the left from 0% to 100% through the first half of <span class="No-Break">the transition.</span></p>
<p>Now, let’s turn our attention to the second half of the transition, where the solid color block contracts from full width toward the right edge of <span class="No-Break">the element.</span></p>
<p>An alternate way<a id="_idIndexMarker568"/> to envision this is by considering the expansion of the transparent portion from the left edge, covering from 0% to 100% of the element. This mirrors the first half of the transition, with the key difference being that it’s now the transparent color, not the solid one, that grows to fully envelop <span class="No-Break">the element.</span></p>
<p>The formula for calculating the <strong class="source-inline">percentage</strong> value remains the same, but since the <strong class="source-inline">progress</strong> value now ranges from <strong class="source-inline">0.5</strong> to <strong class="source-inline">1</strong>, we need to subtract <strong class="source-inline">0.5</strong> from the <strong class="source-inline">progress</strong> value before multiplying it by 200. So, the equation <span class="No-Break">becomes this:</span></p>
<pre class="source-code">
const percentage = (progress – 0.5) * 200</pre> <p>With this modification, our <strong class="source-inline">css</strong> function now <span class="No-Break">becomes this:</span></p>
<pre class="source-code">
css: (progress) =&gt; {
  if (progress &lt;= 0.5) {
    const percentage = progress * 200;
    return `background: linear-gradient(to right, red 0, ${percentage}%, transparent ${percentage}%);`;
  } else {
    <strong class="bold">const percentage = (progress – 0.5) * 200;</strong>
    <strong class="bold">return `background: linear-gradient(to right, transparent 0, ${percentage}%, red ${percentage}%);`;</strong>
  }
}</pre> <p>In this updated function, the solid color block and transparent areas dynamically resize according to the calculated percentage during the transition, effectively creating the visual illusion of a <span class="No-Break">color swipe.</span></p>
<p>Applying the transition to an element now, you might notice that although we have a functional solid color swipe transition effect, there are a few elements that could be refined for a smoother <span class="No-Break">visual experience.</span></p>
<p>One prominent aspect is that the text within the element remains visible throughout the entire transition. Ideally, it should stay hidden in the first half of the transition, when the solid color block is expanding, and only be revealed in the second half as the color <span class="No-Break">block shrinks.</span></p>
<p>The following screenshot illustrates <span class="No-Break">this issue:</span></p>
<p class="IMG---Figure">igure 14.6: The text is not hidden in the first half of the transition</p>
<p>To <a id="_idIndexMarker569"/>address this, we can set the text color to transparent during the first half of the transition, as shown in the following <span class="No-Break">code snippet:</span></p>
<pre class="source-code">
css: (progress) =&gt; {
  if (progress &lt;= 0.5) {
    const percentage = progress * 200;
    return `background: linear-gradient(to right, red 0, ${percentage}%, transparent ${percentage}%); <strong class="bold">color: transparent;</strong>`;
  } else { /* ... */ }
}</pre> <p>Another issue is that the solid color block remains red, regardless of the text color. Because we are using the CSS <strong class="source-inline">background</strong> property to create a swipe effect, the text remains at the forefront, while the solid color block is in <span class="No-Break">the background.</span></p>
<p>This affects the text-revealing effect from the color block since the full text content becomes fully visible in the second half of the transition. If the solid color block shared the same color as the text, the text would blend with the background. This would create a visual illusion, giving the appearance that the text is being revealed as the color <span class="No-Break">block contracts.</span></p>
<p>The following screenshot illustrates <span class="No-Break">this issue:</span></p>
<p class="IMG---Figure">igure 14.7: The text and block color do not match</p>
<p>To <a id="_idIndexMarker570"/>resolve this, we need to find a way to obtain the color of the text and incorporate it into our linear <span class="No-Break">gradient background.</span></p>
<p>The <strong class="source-inline">window.getComputedStyle()</strong> function allows us to fetch the styles applied to an element. We can use this function to get the color of the text at the beginning of the transition and use that color for our <span class="No-Break">gradient background:</span></p>
<pre class="source-code">
function colourSwipe(node, params) {
  <strong class="bold">const { color } = window.getComputedStyle(node);</strong>
  const config = {
    css: (progress) =&gt; {
      if (progress &lt;= 0.5) {
        const percentage = progress * 200;
        return `background: linear-gradient(to right, <strong class="bold">${color}</strong> 0, ${percentage}%, transparent ${percentage}%); color: transparent;`;
      } else {
        const percentage = (progress – 0.5) * 200;
        return `background: linear-gradient(to right, transparent 0, ${percentage}%, <strong class="bold">${color}</strong> ${percentage}%);`;
      }
    }
  };
  return config;
}</pre> <p>In the <a id="_idIndexMarker571"/>preceding revised code snippet, we replace <strong class="source-inline">red</strong> with the text color we fetched from the <strong class="source-inline">node</strong> element’s <span class="No-Break">computed style.</span></p>
<p>And there you have it—a customized color swipe effect, implemented as a Svelte transition. The complete code can be found <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition</span></a><span class="No-Break">.</span></p>
<p>We went step by step through creating a custom Svelte transition using CSS. Throughout the process, we learned how to implement user-customizable attributes into our transition, such as <strong class="source-inline">duration</strong>, <strong class="source-inline">delay</strong>, and <strong class="source-inline">easing</strong>. In our color swipe transition, we learned how to craft a multi-staged transition and how to segment the <strong class="source-inline">progress</strong> parameter into various stages, utilize its value to compute the CSS rules, and apply it to <span class="No-Break">the element.</span></p>
<p>Hopefully, you are now equipped to create your own custom Svelte transition <span class="No-Break">using CSS.</span></p>
<p>At the start of this chapter, we learned that a transition contract can include not only a <strong class="source-inline">css</strong> function but also a <strong class="source-inline">tick</strong> function. The <strong class="source-inline">tick</strong> function allows us to modify elements during the transition. We’ve explored how to use the <strong class="source-inline">css</strong> function to create a color swipe transition; in the next section, we’ll delve into creating another custom transition, this time using the <span class="No-Break"><strong class="source-inline">tick</strong></span><span class="No-Break"> function.</span></p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor209"/>Writing a custom JavaScript transition using the tick function</h1>
<p>The <a id="_idIndexMarker572"/>custom transition we will attempt to <a id="_idIndexMarker573"/>write in this section is a flipboard transition. The transition emulates the mechanics of vintage airport departure boards. During this transition, each letter of the text <em class="italic">flips</em>, cycling through characters until it finally lands on the correct one. The transition ends when all the letters have settled into the <span class="No-Break">right character.</span></p>
<p>The following diagram illustrates how the flipboard transition works to reveal the phrase <em class="italic">Hello Svelte</em>, with the vertical axis representing the flow of time from top <span class="No-Break">to bottom:</span></p>
<p class="IMG---Figure">igure 14.8: Flipboard transition visualized</p>
<p>At the onset of the transition, letters begin to appear from left to right, starting as a dash (<strong class="source-inline">-</strong>) and then flipping through random characters before settling on the correct one. This flipping motion continues from left to right until all letters have aligned with their corresponding characters, unveiling the <span class="No-Break">intended phrase.</span></p>
<p>The entire transition process involves modifying characters within the element, transitioning from a blank state through jumbled characters, and finally to the correct text. Since there are no style or layout changes needed, we are not using the <strong class="source-inline">css</strong> function to implement this transition. The <strong class="source-inline">tick</strong> function is the perfect candidate to implement this transition <span class="No-Break">in Svelte.</span></p>
<p>Now that we’ve defined how the flipboard transition would look, let us start implementing <span class="No-Break">this transition.</span></p>
<p>Building on what <a id="_idIndexMarker574"/>we learned with the color swipe transition in the previous section, the flipboard <a id="_idIndexMarker575"/>transition begins in a similar way. Here is the basic code structure for our <span class="No-Break">flipboard transition:</span></p>
<pre class="source-code">
&lt;script&gt;
  function flipboard(node, params) {
    const config = {
      duration: params?.duration ?? 1000,
      delay: params?.delay ?? 0,
      easing: params?.easing ?? linear,
      tick: (progress) =&gt; {
        // TODO: implement the transition here
      },
    };
    return config;
  }
&lt;/script&gt;
&lt;p transition:flipboard&gt;Hello Svelte.&lt;/p&gt;</pre> <p>In the preceding code snippet, we have defined a <strong class="source-inline">flipboard</strong> function that adheres to the transition contract. It takes in two arguments, <strong class="source-inline">node</strong> and <strong class="source-inline">params</strong>, and returns a transition configuration—an object that describes the transition. As such, we are able to apply the <strong class="source-inline">flipboard</strong> function as a transition using the <strong class="source-inline">transition:</strong> directive on a <strong class="source-inline">&lt;</strong><span class="No-Break"><strong class="source-inline">div&gt;</strong></span><span class="No-Break"> element.</span></p>
<p>Within the flipboard transition, we’ve set up the basic parameters, such as defining the <strong class="source-inline">duration</strong>, <strong class="source-inline">delay</strong>, and <strong class="source-inline">easing</strong> values, while leaving a placeholder for the <strong class="source-inline">tick</strong> function, where we will implement <span class="No-Break">the transition.</span></p>
<p>To create a flipboard transition, we start by obtaining the text content of the element that will be transitioning. Then, each time the <strong class="source-inline">tick</strong> function is called, we determine the text to display based on the <strong class="source-inline">progress</strong> value and update the <span class="No-Break">element accordingly.</span></p>
<p>We can retrieve the text of an element using the <span class="No-Break">following API:</span></p>
<pre class="source-code">
const text = node.textContent;</pre> <p>Similarly, to <a id="_idIndexMarker576"/>set the text content of <a id="_idIndexMarker577"/>an element, we assign it through the <span class="No-Break">same property:</span></p>
<pre class="source-code">
node.textContent = text;</pre> <p>Incorporating these into the flipboard transition, here’s what <span class="No-Break">we get:</span></p>
<pre class="source-code">
function flipboard(node, params) {
  <strong class="bold">const text = node.textContent;</strong>
  const config = {
    // ...
    tick: (progress) =&gt; {
      let newText;
      // TODO: compute the newText based on `text` and progress value
      <strong class="bold">node.textContent = newText;</strong>
    },
  };
  return config;
}</pre> <p>In the preceding code snippet, we retrieve the text content of the element at the beginning of the <strong class="source-inline">flipboard</strong> function, right before the transition starts to play on the element. The <strong class="source-inline">tick</strong> function, called repeatedly on every animation frame, computes the new <strong class="source-inline">text</strong> value for the element, based on the original <strong class="source-inline">text</strong> value and current <span class="No-Break"><strong class="source-inline">progress</strong></span><span class="No-Break"> value.</span></p>
<p>The <strong class="source-inline">tick</strong> function’s task is to determine how each letter should be displayed, based on the <strong class="source-inline">progress</strong> value. Some letters might appear as a dash, some as random characters, some as their original value, and others might <span class="No-Break">be hidden.</span></p>
<p>For each letter, its display depends on its position relative to the full text’s length and the current <strong class="source-inline">progress</strong> value. For instance, if a letter is positioned at 30% from the left, and the current <strong class="source-inline">progress</strong> value is <strong class="source-inline">0.5</strong> (or 50%), then that letter should be displayed <span class="No-Break">as is.</span></p>
<p>How do we determine these rules? What leads us to the conclusions <span class="No-Break">just drawn?</span></p>
<p>We want<a id="_idIndexMarker578"/> the element to reveal all its <a id="_idIndexMarker579"/>original characters at the end of the transition. This means that when the <strong class="source-inline">progress</strong> value reaches 1 (or 100%), all letters should display their original character. At the midpoint, with a <strong class="source-inline">progress</strong> value of <strong class="source-inline">0.5</strong> (or 50%), 50% of the letters from the left should show their original character, while the remaining 50% on the right should show either a dash, a random character, or nothing <span class="No-Break">at all.</span></p>
<p>To generalize, if a letter’s position from the left is less than the <strong class="source-inline">progress</strong> value, it should display its original character. Otherwise, it may display a dash, a random character, <span class="No-Break">or nothing.</span></p>
<p>The following diagram illustrates how the <strong class="source-inline">progress</strong> value and the displayed text <span class="No-Break">are related:</span></p>
<p class="IMG---Figure">igure 14.9: The red box shows which letters are displaying the original character at each progress value</p>
<p>The preceding diagram illustrates how the original characters are revealed at different values of <strong class="source-inline">progress</strong>. As the <strong class="source-inline">progress</strong> value increases, more letters in the word display their <span class="No-Break">original characters.</span></p>
<p>To implement <a id="_idIndexMarker580"/>the flipboard effect just described, we will loop through each character, determine its relative position, and then decide whether it should be displayed. For characters <a id="_idIndexMarker581"/>whose position is beyond the current <strong class="source-inline">progress</strong> value, we will display a <span class="No-Break">blank space.</span></p>
<p>Here is the <span class="No-Break">updated code:</span></p>
<pre class="source-code">
tick: (progress) =&gt; {
  let newText = '';
<strong class="bold">  for (let i = 0; i &lt; text.length; i++) {</strong>
<strong class="bold">    const position = i / text.length;</strong>
<strong class="bold">    if (position &lt; progress) {</strong>
<strong class="bold">      // display the original character</strong>
<strong class="bold">      newText += text[i];</strong>
<strong class="bold">    } else {</strong>
<strong class="bold">      // display a blank space instead</strong>
<strong class="bold">      newText += ' ';</strong>
<strong class="bold">    }</strong>
<strong class="bold">  }</strong>
  node.textContent = newText;
},</pre> <p>With this code, the flipboard transition now either shows the original characters or a blank space based on the progress value. When playing the transition, you will see the characters appear one by one from left <span class="No-Break">to right.</span></p>
<p>Having figured out when to show up the original characters, let us continue to determine when the text should display dashes or <span class="No-Break">random characters.</span></p>
<p>Using a similar idea, we can determine whether a letter should display a random character, a dash, or nothing at all. We will introduce a constant number to manage the timing of these changes. If the letter’s position is beyond this constant multiplied by the <strong class="source-inline">progress</strong> value, it will show up as nothing. I’ve chosen a value of 2 for this constant, based on trial and error. It’s a value greater than 1 but not too large, to create the effect of characters appearing gradually from <span class="No-Break">the left.</span></p>
<p>Similarly, we <a id="_idIndexMarker582"/>could also introduce another <a id="_idIndexMarker583"/>constant to manage the display of dashes or random characters. If the letter’s relative position is greater than this new constant times the progress value, but less than 2, the letter will appear as a dash. Otherwise, it will be a random character. For this purpose, I have chosen 1.5, positioning it midway between 1 <span class="No-Break">and 2.</span></p>
<p>The following diagram visually represents these two constants and their effect on <span class="No-Break">the transition:</span></p>
<p class="IMG---Figure">igure 14.10: Relationship between the new text and the original text</p>
<p>In the preceding diagram, you can observe how the characters change during the transition. When the <strong class="source-inline">progress</strong> value is <strong class="source-inline">0.4</strong>, for example, letters at the 40% position are showing original characters, letters at 40% - 60% (<strong class="source-inline">progress</strong> * 1.5) are showing random characters, letters at 60% - 80% (<strong class="source-inline">progress</strong> * 2) are showing dashes, and anything beyond is <span class="No-Break">not shown.</span></p>
<p>Here’s how the updated code for our flipboard <span class="No-Break">transition looks:</span></p>
<pre class="source-code">
tick: (progress) =&gt; {
  let newText = '';
  for (let i = 0; i &lt; text.length; i++) {
    const position = i / text.length;
    if (position &lt; progress) {
      // display the original character
      newText += text[i];
<strong class="bold">    } else if (position &lt; progress * 1.5) {</strong>
<strong class="bold">      // display random characters</strong>
<strong class="bold">      newText += randomCharacter()</strong>
<strong class="bold">    } else if (position &lt; progress * 2) {</strong>
<strong class="bold">      // display dash</strong>
<strong class="bold">      newText += '-';</strong>
    } else {
      // display a blank space instead
      newText += ' ';
    }
  }
  node.textContent = newText;
},</pre> <p>In the <a id="_idIndexMarker584"/>preceding code snippet, I’ve <a id="_idIndexMarker585"/>added two additional conditions to determine when to display dashes or <span class="No-Break">random characters.</span></p>
<p>The <strong class="source-inline">randomCharacter()</strong> function returns a randomly selected character, implemented <span class="No-Break">as follows:</span></p>
<pre class="source-code">
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'
function randomCharacter() {
  return chars[Math.floor(Math.random() * chars.length)];
}</pre> <p>With this code, you have a flipboard transition! Try it out with an element and observe the effect. The characters slowly appear one by one from left to right, starting as a dash, flipping through characters, and finally settling with the <span class="No-Break">correct character.</span></p>
<p>You <a id="_idIndexMarker586"/>may notice one small issue: not <a id="_idIndexMarker587"/>all characters are the same width, so the overall width of the text grows and shrinks. Since each letter is not aligned with its previous position, the flipping effect may not be <span class="No-Break">immediately obvious.</span></p>
<p>To fix this, you can use a monospace font. Monospace fonts, also known as fixed-width fonts, ensure that each letter occupies the same horizontal space. Applying a monospace font to an element enhances the flipping effect, making it more <span class="No-Break">visually distinct.</span></p>
<p>For example, you can set the font <span class="No-Break">as follows:</span></p>
<pre class="source-code">
font-family: monospace;</pre> <p>In this section, we’ve explored how to create a flipboard transition, emulating the appearance of vintage airport departure boards. We’ve learned how to control the appearance of characters based on the progress of the transition, using random characters, dashes, and original text. And through modifying the text of an element, we created a transition that is <span class="No-Break">visually engaging.</span></p>
<p>The complete code for this section can be found <span class="No-Break">at here:</span><a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13"><span class="No-Break">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13</span></a><span class="No-Break">.</span></p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor210"/>Summary</h1>
<p>In this chapter, we have explored how to create custom transitions in Svelte. We went through two detailed examples that utilize the <strong class="source-inline">css</strong> function and the <span class="No-Break"><strong class="source-inline">tick</strong></span><span class="No-Break"> function.</span></p>
<p>Hopefully, you now feel well equipped to write your own custom transition in Svelte, enabling you to craft a more engaging and unique user experience <span class="No-Break">in Svelte.</span></p>
<p>In our next and final chapter, we will delve into how transitions can impact the accessibility of your Svelte application, guiding you in the creation of an engaging and inclusive experience for <span class="No-Break">all users.</span></p>
</div>
</div></body></html>