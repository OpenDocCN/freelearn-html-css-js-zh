<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-200"><a id="_idTextAnchor202"/>14</h1>
<h1 id="_idParaDest-201"><a id="_idTextAnchor203"/>Exploring Custom Transitions</h1>
<p>In this chapter, we will delve into the world of custom transitions in Svelte. So far, we have explored Svelte’s built-in transitions and how they can be used to create engaging and dynamic user interfaces. However, there may be situations where the built-in transitions don’t quite meet your requirements and you want to create something more unique. This is where custom transitions come into play.</p>
<p>Custom transitions allow you to take full control over the animations and effects that you want to achieve in your Svelte application. This chapter will guide you through the process of creating your own custom transitions, whether they are CSS- or JavaScript-based. We will explore the transition contract, which serves as the foundation for creating custom transitions, and provide practical examples to help you get started.</p>
<p>By the end of this chapter, you will have a solid understanding of how to create custom transitions in Svelte, and you will be equipped with the knowledge to implement them in your own projects, taking your user interfaces to the next level.</p>
<p>This chapter includes sections on the following topics:</p>
<ul>
<li>The transition contract</li>
<li>Writing a custom CSS transition using the <code>css</code> function</li>
<li>Writing a custom JavaScript transition using the <code>tick</code> function</li>
</ul>
<h1 id="_idParaDest-202"><a id="_idTextAnchor204"/>Technical requirements</h1>
<p>This chapter will be somewhat code-heavy, but don’t worry—you can find all the code samples used in this chapter on GitHub at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14</a>.</p>
<h1 id="_idParaDest-203"><a id="_idTextAnchor205"/>The transition contract</h1>
<p>Before we dive into creating custom transitions, it’s essential to understand the foundation upon which they are built: the transition contract.</p>
<p>If you’ve read <a href="B18887_09.xhtml#_idTextAnchor135"><em class="italic">Chapter 9</em></a>, you’ll be familiar with the concept of a store contract. Just as a store is an object that adheres to a specific store contract, a transition is a function that follows a transition contract. By understanding and adhering to these contracts, you can create custom transitions that integrate seamlessly with Svelte’s built-in transition system.</p>
<p>The transition contract <a id="_idIndexMarker539"/>consists of a single function that is responsible for <a id="_idIndexMarker540"/>the transition. This function accepts two arguments:</p>
<ul>
<li><code>node</code>: The target DOM element that the transition will be applied to</li>
<li><code>params</code>: An object containing configuration options</li>
</ul>
<p>The function should return an object that describes how the transition should be executed. We will delve into the details of this returned object later in the section.</p>
<p>Here is an example of a custom transition that adheres to the transition contract:</p>
<pre class="source-code">
function customTransition(node, params) {
  const config = { ... };
  return config;
}</pre> <p>In the preceding code snippet, we have created a custom transition named <code>customTransition</code>. We did this by declaring a <code>customTransition</code> function that takes in two parameters: <code>node</code> and <code>params</code>. This function then returns an object—which we’ll refer to as <code>config</code>—that describes the transition.</p>
<p>To relate the custom transition we’ve just created back to the usage of a transition in Svelte, here, we see how the <code>customTransition</code> function is applied to a <code>&lt;</code><code>div&gt;</code> element:</p>
<pre class="source-code">
&lt;div transition:customTransition={{ duration: 500 }}&gt;some text&lt;/div&gt;</pre> <p>When the <code>&lt;div&gt;</code> element is inserted or about to be removed from the DOM, Svelte will attempt to play the transition. Svelte does this by calling the <code>customTransition</code> function with a reference to the <code>&lt;div&gt;</code> element and the <code>config</code> object passed to the transition:</p>
<pre class="source-code">
const config = customTransition(div, { duration: 500 });</pre> <p>This <code>config</code> object returned by <code>customTransition</code> will determine how the transition is played out.</p>
<p>Now, let’s focus <a id="_idIndexMarker541"/>on the requirements for the <code>config</code> object returned by the custom transition function.</p>
<p>The <code>config</code> object<a id="_idIndexMarker542"/> returned from a custom transition should include at least one of the following properties or methods:</p>
<ul>
<li><code>delay</code>: A number specified in milliseconds. This specifies how long to wait before the transition begins.</li>
<li><code>duration</code>: A number specified in milliseconds. The duration that the transition will play. This determines how fast or slow the animation appears to the user.</li>
<li><code>easing</code>: A function for easing the transition. This function determines the rate of change in the transition’s progress over time.</li>
<li><code>css</code>: A function that is called with two parameters: <code>progress</code> and <code>remaining</code>. Here,  <code>progress</code> is a value between <code>0</code> and <code>1</code> representing the progress of the transition, and the value of the <code>remaining</code> parameter is equal to <code>1 - </code><code>progress</code>.<p class="list-inset">This function should return a string containing the CSS styles to be applied to the target DOM element.</p></li>
<li><code>tick</code>: A function that is called repeatedly during the transition with two parameters: <code>progress</code> and <code>remaining</code>. Here, <code>progress</code> is a value between <code>0</code> and <code>1</code> indicating the progress of the transition, and the value of the <code>remaining</code> parameter is equal to <code>1 - </code><code>progress</code>.<p class="list-inset">This function can be <a id="_idIndexMarker543"/>used to update the DOM element’s styles based on the current progress.</p></li>
</ul>
<p>Here is a more <a id="_idIndexMarker544"/>complete sample of a custom transition that follows the transition contract:</p>
<pre class="source-code">
import { cubicInOut } from 'svelte/easing';
function customTransition(node, params) {
  return {
    duration: 1000,
    delay: 500,
    easing: cubicInOut,
    css: (progress) =&gt; `opacity: ${progress}`,
  };
}</pre> <p>In the preceding code snippet, our custom transition, named <code>customTransition</code>, returns an object that describes the transition’s <code>duration</code>, <code>delay</code>, <code>easing</code>, and <code>css</code> styles.</p>
<p>We saw <code>delay</code>, <code>duration</code>, and <code>easing</code> in the previous chapter when applying transitions to an element. Since the behavior of these properties remains the same in this context, let us focus on something new: the <code>css</code> and <code>tick</code> functions.</p>
<h2 id="_idParaDest-204"><a id="_idTextAnchor206"/>The css function</h2>
<p>As you might <a id="_idIndexMarker545"/>remember from the last section of the previous chapter, <em class="italic">How Svelte transitions work under the hood</em>, Svelte animates transitions using a <a id="_idIndexMarker546"/>combination of CSS and JavaScript. It leverages CSS <code>@keyframe</code> rules along with the <code>animation</code> property for CSS animations and the <code>requestAnimationFrame</code> function for JavaScript animations.</p>
<p>The <code>css</code> function is used to generate CSS <code>@keyframe</code> rules for custom transitions. If the <code>css</code> function is defined in the returned object of a custom transition, Svelte will call this function when an element is inserted into the DOM or about to be removed from the DOM. Svelte will call the <code>css</code> function as many times as necessary, depending on the duration and easing of the transition, in order to generate the appropriate <code>@</code><code>keyframe</code> rules.</p>
<p>The <a id="_idIndexMarker547"/>first parameter of the <code>css</code> function relates to the progress of <a id="_idIndexMarker548"/>the transition. <code>progress</code> is a number between <code>0</code> and <code>1</code>, where <code>0</code> represents the element being out of view, and 1 represents the element being in its final position on the screen.</p>
<p>For example, when transitioning an element in after it has been inserted into the DOM, the value of <code>progress</code> starts at <code>0</code> and moves toward <code>1</code>. Conversely, when transitioning an element out before it is removed from the DOM, the value of <code>progress</code> starts at <code>1</code> and moves toward <code>0</code>.</p>
<p>You can use <code>progress</code> to calculate the CSS styles necessary to create your custom transition.</p>
<p>For example, if we want to create a transition that fades an element from transparent to fully visible, we can use <code>progress</code> to calculate the opacity value throughout the transition:</p>
<ul>
<li>When the element is out of view (value of <code>progress</code> is <code>0</code>), we want the element to be transparent (value of <code>opacity</code> should be <code>0</code>)</li>
<li>When the element is in view (value of <code>progress</code> is <code>1</code>), we want the element to be fully visible (value of <code>opacity</code> should be <code>1</code>)</li>
</ul>
<p>The relationship between <code>progress</code> and <code>opacity</code> can be represented by the diagram shown in <em class="italic">Figure 14</em><em class="italic">.1</em>:</p>
<p class="IMG---Figure">igure 14.1: Relationship between progress and opacity</p>
<p>We are going <a id="_idIndexMarker549"/>to derive the value of <code>opacity</code> from the value of <code>progress</code> in the <code>css</code> function, like so:</p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    css: <strong class="bold">(progress) =&gt; `opacity: ${progress}`</strong>,
  };
}</pre> <p>Applying the<a id="_idIndexMarker550"/> transition in the preceding code will give you an element that fades from transparent to visible when inserted into the DOM and fades back to transparent when removed from the DOM.</p>
<p>Let us take another example. Let us create a transition that flies the element from the right to its final position. Here, the translation of the element changes throughout the transition, and we can use <code>progress</code> to calculate the translation:</p>
<ul>
<li>When the element is out of view (value of <code>progress</code> is <code>0</code>), we want the element to be on the right (value of <code>translateX</code> is <code>100px</code>)</li>
<li>When the element is in view (value of <code>progress</code> is <code>1</code>), we want the element to be at its final position (value of <code>translateX</code> is <code>0px</code>)</li>
</ul>
<p>Here’s a diagram depicting the relationship between <code>progress</code> and <code>translateX</code>:</p>
<p class="IMG---Figure">igure 14.2: Relationship between progress and translateX</p>
<p>Unlike the <a id="_idIndexMarker551"/>previous example, the value of <code>translateX</code> is the inverse of <code>progress</code>: when <code>progress</code> is <code>0</code>, <code>translateX</code> has a nonzero value; when <code>progress</code> is 1, <code>translateX</code> becomes <code>0</code>.</p>
<p>So, to <a id="_idIndexMarker552"/>calculate the <code>translateX</code> value, we use <code>1 – progress</code> times a value, as you can see in the following code snippet:</p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    css: <strong class="bold">(progress) =&gt; `transform: translateX(${(1 – progress) * 100}px)`</strong>,
  };
}</pre> <p>When applying the <code>customTransition</code> function in the preceding code snippet to an element, as the element is added to the DOM, the element will fly in from the right to its final position. And because calculating the inverse of <code>progress</code> (<code>1 – progress</code>) is so commonly done, the value is provided as a second argument of the <code>css</code> function.</p>
<p>So, here is our custom transition again, but using the second argument instead to calculate the translation:</p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    css: <strong class="bold">(progress, remaining) =&gt; `transform: translateX(${remaining * 100}px)`</strong>,
  };
}</pre> <p>The <code>css</code> function <a id="_idIndexMarker553"/>returns a CSS string that can consist of multiple CSS declarations. You separate each CSS declaration with a semicolon, just <a id="_idIndexMarker554"/>as you would in a <code>style</code> attribute of an element. For example, let’s create a transition that combines fading in and translating from the right simultaneously:</p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    css: (progress, remaining) =&gt; `opacity: ${progress}; transform: translateX(${remaining * 100}px); `,
  };
}</pre> <p>In the preceding code snippet, we combine both fading in and translating from the right simultaneously. The returned CSS string contains multiple CSS declarations separated by semicolons, one for <code>opacity</code> and another for <code>transform</code>, that will be applied during the transition.</p>
<p>Now that we have covered the <code>css</code> function, let us look at the <code>tick</code> function.</p>
<h2 id="_idParaDest-205"><a id="_idTextAnchor207"/>The tick function</h2>
<p>The <code>tick</code> function <a id="_idIndexMarker555"/>serves as an alternative to the <code>css</code> function<a id="_idIndexMarker556"/> for creating custom transitions. Unlike the <code>css</code> function, which is used to generate CSS <code>@keyframe</code> rules for the animation, the <code>tick</code> function allows you to animate a transition using JavaScript. This can provide more fine-grained control over the transition, enabling the creation of more complex animations that may not be easily achieved with CSS alone.</p>
<p>The <code>tick</code> function is called repeatedly during the transition through <code>requestAnimationFrame</code>. Similar to the <code>css</code> function, the <code>tick</code> function accepts two parameters: <code>progress</code> and <code>remaining</code>. The <code>progress</code> parameter is a value between <code>0</code> and <code>1</code>, where <code>0</code> represents the element being out of view, and 1 represents the element being in its final position on the screen, while the <code>remaining</code> parameter is equal to <code>1 – progress</code>. These parameters can be used to modify the DOM element the transition is applied to, based on the current progress of the transition.</p>
<p>For example, if we <a id="_idIndexMarker557"/>want to create a fade-in transition <a id="_idIndexMarker558"/>using the <code>tick</code> function, you can update the element’s opacity based on the progress value, as illustrated here:</p>
<pre class="source-code">
function customTransition(node, params) {
  return {
    tick: (progress) =&gt; {
      node.style.opacity = progress;
    },
  };
}</pre> <p>Based on the preceding code snippet, Svelte triggers the <code>tick</code> function during every animation frame throughout the transition.</p>
<p>When the element starts to appear, the <code>progress</code> value is <code>0</code>, and we use this <code>progress</code> value to set the initial <code>opacity</code> value of the element to <code>0</code>.</p>
<p>As the transition continues, the <code>tick</code> function is called with <code>progress</code> values between <code>0</code> and <code>1</code>, and we update the element’s <code>opacity</code> value based on the <code>progress</code> value.</p>
<p>At the end of the transition, the <code>tick</code> function is called one last time with a <code>progress</code> value of 1. At this point, we set the element’s <code>opacity</code> value to its final value of 1.</p>
<p>The <code>tick</code> function in the preceding code snippet operates similarly to the custom fade-in transition we created using the <code>css</code> function. Both approaches modify the element’s <code>opacity</code> value throughout the transition. The key difference lies in how they are executed.</p>
<p>Svelte calls the <code>css</code> function multiple times with different progress values at the beginning of the transition to construct the CSS <code>@keyframe</code> rules. Once this is done, the <code>css</code> function is not called again during the transition. The newly created CSS <code>@keyframe</code> rule is then applied to the element through the CSS <code>animation</code> property. The <a id="_idIndexMarker559"/>element’s <code>opacity</code> value is then updated through CSS.</p>
<p>On the other hand, the <code>tick</code> function<a id="_idIndexMarker560"/> is called multiple times by Svelte during each animation frame throughout the transition. On every tick call, the element’s <code>opacity</code> value is modified by JavaScript.</p>
<p>Now that we have learned about the transition contract, let us use this knowledge to create a few more custom transitions.</p>
<h1 id="_idParaDest-206"><a id="_idTextAnchor208"/>Writing a custom CSS transition using the css function</h1>
<p>The first <a id="_idIndexMarker561"/>custom transition we will be attempting to write together is an effect often witnessed in presentations, commonly referred to as the “color swipe.” This effect stands out due to its dynamic sweep of color that flows across the screen, creating a sense of energy that captivates the viewer’s attention.</p>
<p>The color swipe transition, as its name suggests, involves a sweeping change in color that takes place over an object.</p>
<p>Picture this: you’re looking at a static screen, possibly a section of a website. Suddenly, a new color begins to surface from one edge of the screen. Like a wave, this color spreads across the screen, enveloping it. As soon as the color completely covers the screen, it starts to recede from the edge of origin, revealing new content. When the color entirely withdraws, the new content is fully unveiled:</p>
<p class="IMG---Figure">igure 14.3: The color swipe transition</p>
<p>The <em class="italic">swipe</em> can move in from any direction—it can move horizontally from left to right, vertically from top to bottom, or even diagonally.</p>
<p>We are <a id="_idIndexMarker562"/>going to modify the color swipe transition to apply to paragraph (<code>&lt;p&gt;</code>) elements. When a <code>&lt;p&gt;</code> element is added to the DOM, a wave of color will sweep over it, unveiling the text within the <code>&lt;p&gt;</code> element upon completion of the transition. When the <code>&lt;p&gt;</code> element is removed from the DOM, the reverse of the transition is played, concealing the text upon completion of the transition.</p>
<p>A visualization of the transition can be seen here:</p>
<p class="IMG---Figure">igure 14.4: The color swipe transition on paragraphs</p>
<p>In this section, we will walk through step by step how to create this captivating color swipe transition using Svelte.</p>
<p>Since the transition that conceals the text when the <code>&lt;p&gt;</code> element is being removed from the DOM is the same as the transition that reveals the text when the <code>&lt;p&gt;</code> element is being added but played backward, we will focus on the transition played when a <code>&lt;p&gt;</code> element is added to the DOM. This is because when a transition is applied to an element, Svelte will play the same transition when the element is removed, but in reverse. Therefore, by focusing on the transition played when an element is added to the DOM, we effectively cover both scenarios.</p>
<p>So, let us get started on creating a transition.</p>
<p>Firstly, let us create the structure of our custom transition. Recall the transition contract—a transition is a function that returns an object describing the transition:</p>
<pre class="source-code">
&lt;script&gt;
  function colourSwipe(node) {
    // TODO: implement the transition here
    const config = {};
    return config;
  }
&lt;/script&gt;
&lt;p transition:colourSwipe&gt;Some text here&lt;/p&gt;</pre> <p>In the <a id="_idIndexMarker563"/>preceding code snippet, we create a <code>colourSwipe</code> transition and apply it to the <code>&lt;p&gt;</code> element. Our current task is to implement the <code>colourSwipe</code> transition by populating the <code>config</code> object.</p>
<p>The first two fields that we are going to add to the <code>config</code> object are <code>duration</code> and <code>delay</code>. As shown in the following code snippet, we set the duration of the transition to 1 second, and the transition will have no delay to start:</p>
<pre class="source-code">
function colourSwipe(node) {
  const config = {
<strong class="bold">    duration: 1000,</strong>
<strong class="bold">    delay: 0,</strong>
  };
  return config;
}</pre> <p>However, often when creating a custom transition, you may want to allow the user of the transition to customize the duration and delay based on where the transition is being applied.</p>
<p>For example, a user of the transition may want to have a delay of 200 milliseconds and a duration of 2 seconds by specifying them in the <code>transition:</code> directive, as shown in the following code snippet:</p>
<pre class="source-code">
&lt;div transition:colourSwipe={{ delay: 200, duration: 2000 }} /&gt;</pre> <p>These custom delays and durations specified in the <code>transition:</code> directive will be passed into the <code>colourSwipe</code> transition as the second argument, which will use them in the <code>config</code> object:</p>
<pre class="source-code">
function colourSwipe(node, <strong class="bold">params</strong>) {
  const config = {
    duration: <strong class="bold">params?.duration ?? 1000</strong>,
    delay: <strong class="bold">params?.delay ?? 0</strong>,
  };
  return config;
}</pre> <p>In the <a id="_idIndexMarker564"/>preceding code snippet, we use the values of <code>params.duration</code> and <code>params.delay</code> in the <code>config</code> object and provide a default value when these parameters aren’t explicitly stated.</p>
<p>Now that we have specified the <code>delay</code> and the <code>duration</code> fields of the transition, let’s turn our attention to the next field—<code>easing</code>.</p>
<p>We are going to use a <code>linear</code> easing, making the transition move at a constant speed, without any acceleration or deceleration. As we did with <code>duration</code> or <code>delay</code>, we are going to make <code>easing</code> customizable by the user. So, in the following code snippet, we set the value of <code>easing</code> based on the user-specified easing. If it is left unspecified, we fall back on our default easing—<code>linear</code> easing:</p>
<pre class="source-code">
<strong class="bold">import { linear } from 'svelte/easing';</strong>
function colourSwipe(node, params) {
  const config = {
    duration: params?.duration ?? 1000,
    delay: params?.delay ?? 0,
    <strong class="bold">easing: params?.easing ?? linear,</strong>
  };
  return config;
}</pre> <p>Typically, in the process of creating a custom transition, the <code>duration</code>, <code>delay</code>, and <code>easing</code> fields are the simplest to set up. More often than not, we determine default <code>duration</code>, <code>delay</code>, and <code>easing</code> values, and then offer the user the flexibility to tweak these to their liking.</p>
<p>Having figured out the <code>duration</code>, <code>delay</code>, and <code>easing</code> values, we now delve into the crux of the transition: coming up with the CSS for the transitioning element.</p>
<p>If you observe<a id="_idIndexMarker565"/> the transition carefully, you will notice that the transition can be divided into two distinct stages: the initial half involves the color block expanding to envelop the entire <code>&lt;p&gt;</code> element, and the latter half corresponds to the color block retracting to unveil the text within the <code>&lt;</code><code>p&gt;</code> element:</p>
<p class="IMG---Figure">igure 14.5: The color swipe transition split into two halves, separated by dotted lines</p>
<p>Let’s explore how we can create these CSS rules to effectively bring to life these stages of the transition.</p>
<p>Before we start, let us create a <code>css</code> function in our <code>colourSwipe</code> transition:</p>
<pre class="source-code">
function colourSwipe(node, params) {
  const config = {
    duration: params?.duration ?? 1000,
    delay: params?.delay ?? 0,
    easing: params?.easing ?? linear,
    <strong class="bold">css: (progress) =&gt; {}</strong>
  };
  return config;
}</pre> <p>We are going to fill in the <code>css</code> function in the preceding code snippet.</p>
<p>It’s key to note that the <code>progress</code> value begins at <code>0</code> at the start of the transition and goes to 1 at the <a id="_idIndexMarker566"/>end of the transition. As we are splitting the transition into two stages, the first stage will see the <code>progress</code> value moving from <code>0</code> to <code>0.5</code>, while the second stage advances from <code>0.5</code> to <code>1</code>.</p>
<p>Hence, in our <code>css</code> function, we will implement different CSS rules for different stages of the transition:</p>
<pre class="source-code">
css: (progress) =&gt; {
<strong class="bold">  if (progress &lt;= 0.5) {</strong>
<strong class="bold">  } else {</strong>
<strong class="bold">  }</strong>
}</pre> <p>In the preceding code snippet, you can see that we have added an <code>if</code> block in the <code>css</code> function, which uses the <code>progress</code> value to determine which sets of CSS rules to apply. For the first half of the transition (<code>progress</code> &lt;= 0.5), the first set of CSS rules is implemented. For the latter half (<code>progress</code> &gt; 0.5), the second set of rules is used. This way, we can customize the element’s appearance in distinct ways throughout the two stages of the transition.</p>
<p>In the first half of our transition, we need to create a growing color block. To create this, we will apply a linear gradient on the background of the element. The gradient will transition from a solid color to a transparent color. By aligning the color stop point of the solid color and the transparent color at the same location, we can create a sharp hard line in the gradient transition.</p>
<p>For example, if we want a solid red color block that occupies the left 25% of an element, we could apply the following CSS:</p>
<pre class="source-code">
background: linear-gradient(to right, red 0, 25%, transparent 25%);</pre> <p>In the preceding snippet, we have a linear gradient moving from left to right, with the red and transparent colors sharing the same color stops at the 25% point. This creates a solid red block on the leftmost 25% of the gradient, while the remaining 75% is transparent.</p>
<p>Our choice to use a linear gradient to achieve this color block, as opposed to superimposing another element, shows the simplicity of this approach. It eliminates the necessity of creating an additional element.</p>
<p>Another benefit<a id="_idIndexMarker567"/> of setting a linear gradient on the background, instead of resizing the element, is to have a resizing color block effect without actually resizing an element, which would cause re-layout and layout shifts in the DOM. This way, the element with the applied CSS remains static in its original position and size throughout the transition.</p>
<p>So, now we’ve figured out the CSS to use, let’s incorporate it into our transition’s <code>css</code> function.</p>
<p>Before that, we need to do some math. We intend to use the value of <code>progress</code> to calculate the percentage of the element to be covered by the solid color block.</p>
<p>In the first half of the transition, the value of <code>progress</code> goes from <code>0</code> to <code>0.5</code>.</p>
<p>Within this phase of the transition, the percentage of the element that needs to be covered should range from 0% to 100%.</p>
<p>Consequently, by performing arithmetic calculations, we can conclude that the percentage value is 200 times the value of <code>progress</code>:</p>
<pre class="source-code">
const percentage = progress * 200;</pre> <p>Let’s now integrate this into our <code>css</code> function:</p>
<pre class="source-code">
css: (progress) =&gt; {
  if (progress &lt;= 0.5) {
    <strong class="bold">const percentage = progress * 200;</strong>
    <strong class="bold">return `background: linear-gradient(to right, red 0, ${percentage}%, transparent ${percentage}%);`;</strong>
  } else {
  }
}</pre> <p>In the preceding code snippet, we use the calculated percentage to control the size of the solid color block, making it grow from the left from 0% to 100% through the first half of the transition.</p>
<p>Now, let’s turn our attention to the second half of the transition, where the solid color block contracts from full width toward the right edge of the element.</p>
<p>An alternate way<a id="_idIndexMarker568"/> to envision this is by considering the expansion of the transparent portion from the left edge, covering from 0% to 100% of the element. This mirrors the first half of the transition, with the key difference being that it’s now the transparent color, not the solid one, that grows to fully envelop the element.</p>
<p>The formula for calculating the <code>percentage</code> value remains the same, but since the <code>progress</code> value now ranges from <code>0.5</code> to <code>1</code>, we need to subtract <code>0.5</code> from the <code>progress</code> value before multiplying it by 200. So, the equation becomes this:</p>
<pre class="source-code">
const percentage = (progress – 0.5) * 200</pre> <p>With this modification, our <code>css</code> function now becomes this:</p>
<pre class="source-code">
css: (progress) =&gt; {
  if (progress &lt;= 0.5) {
    const percentage = progress * 200;
    return `background: linear-gradient(to right, red 0, ${percentage}%, transparent ${percentage}%);`;
  } else {
    <strong class="bold">const percentage = (progress – 0.5) * 200;</strong>
    <strong class="bold">return `background: linear-gradient(to right, transparent 0, ${percentage}%, red ${percentage}%);`;</strong>
  }
}</pre> <p>In this updated function, the solid color block and transparent areas dynamically resize according to the calculated percentage during the transition, effectively creating the visual illusion of a color swipe.</p>
<p>Applying the transition to an element now, you might notice that although we have a functional solid color swipe transition effect, there are a few elements that could be refined for a smoother visual experience.</p>
<p>One prominent aspect is that the text within the element remains visible throughout the entire transition. Ideally, it should stay hidden in the first half of the transition, when the solid color block is expanding, and only be revealed in the second half as the color block shrinks.</p>
<p>The following screenshot illustrates this issue:</p>
<p class="IMG---Figure">igure 14.6: The text is not hidden in the first half of the transition</p>
<p>To <a id="_idIndexMarker569"/>address this, we can set the text color to transparent during the first half of the transition, as shown in the following code snippet:</p>
<pre class="source-code">
css: (progress) =&gt; {
  if (progress &lt;= 0.5) {
    const percentage = progress * 200;
    return `background: linear-gradient(to right, red 0, ${percentage}%, transparent ${percentage}%); <strong class="bold">color: transparent;</strong>`;
  } else { /* ... */ }
}</pre> <p>Another issue is that the solid color block remains red, regardless of the text color. Because we are using the CSS <code>background</code> property to create a swipe effect, the text remains at the forefront, while the solid color block is in the background.</p>
<p>This affects the text-revealing effect from the color block since the full text content becomes fully visible in the second half of the transition. If the solid color block shared the same color as the text, the text would blend with the background. This would create a visual illusion, giving the appearance that the text is being revealed as the color block contracts.</p>
<p>The following screenshot illustrates this issue:</p>
<p class="IMG---Figure">igure 14.7: The text and block color do not match</p>
<p>To <a id="_idIndexMarker570"/>resolve this, we need to find a way to obtain the color of the text and incorporate it into our linear gradient background.</p>
<p>The <code>window.getComputedStyle()</code> function allows us to fetch the styles applied to an element. We can use this function to get the color of the text at the beginning of the transition and use that color for our gradient background:</p>
<pre class="source-code">
function colourSwipe(node, params) {
  <strong class="bold">const { color } = window.getComputedStyle(node);</strong>
  const config = {
    css: (progress) =&gt; {
      if (progress &lt;= 0.5) {
        const percentage = progress * 200;
        return `background: linear-gradient(to right, <strong class="bold">${color}</strong> 0, ${percentage}%, transparent ${percentage}%); color: transparent;`;
      } else {
        const percentage = (progress – 0.5) * 200;
        return `background: linear-gradient(to right, transparent 0, ${percentage}%, <strong class="bold">${color}</strong> ${percentage}%);`;
      }
    }
  };
  return config;
}</pre> <p>In the <a id="_idIndexMarker571"/>preceding revised code snippet, we replace <code>red</code> with the text color we fetched from the <code>node</code> element’s computed style.</p>
<p>And there you have it—a customized color swipe effect, implemented as a Svelte transition. The complete code can be found at <a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter14/01-css-transition</a>.</p>
<p>We went step by step through creating a custom Svelte transition using CSS. Throughout the process, we learned how to implement user-customizable attributes into our transition, such as <code>duration</code>, <code>delay</code>, and <code>easing</code>. In our color swipe transition, we learned how to craft a multi-staged transition and how to segment the <code>progress</code> parameter into various stages, utilize its value to compute the CSS rules, and apply it to the element.</p>
<p>Hopefully, you are now equipped to create your own custom Svelte transition using CSS.</p>
<p>At the start of this chapter, we learned that a transition contract can include not only a <code>css</code> function but also a <code>tick</code> function. The <code>tick</code> function allows us to modify elements during the transition. We’ve explored how to use the <code>css</code> function to create a color swipe transition; in the next section, we’ll delve into creating another custom transition, this time using the <code>tick</code> function.</p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor209"/>Writing a custom JavaScript transition using the tick function</h1>
<p>The <a id="_idIndexMarker572"/>custom transition we will attempt to <a id="_idIndexMarker573"/>write in this section is a flipboard transition. The transition emulates the mechanics of vintage airport departure boards. During this transition, each letter of the text <em class="italic">flips</em>, cycling through characters until it finally lands on the correct one. The transition ends when all the letters have settled into the right character.</p>
<p>The following diagram illustrates how the flipboard transition works to reveal the phrase <em class="italic">Hello Svelte</em>, with the vertical axis representing the flow of time from top to bottom:</p>
<p class="IMG---Figure">igure 14.8: Flipboard transition visualized</p>
<p>At the onset of the transition, letters begin to appear from left to right, starting as a dash (<code>-</code>) and then flipping through random characters before settling on the correct one. This flipping motion continues from left to right until all letters have aligned with their corresponding characters, unveiling the intended phrase.</p>
<p>The entire transition process involves modifying characters within the element, transitioning from a blank state through jumbled characters, and finally to the correct text. Since there are no style or layout changes needed, we are not using the <code>css</code> function to implement this transition. The <code>tick</code> function is the perfect candidate to implement this transition in Svelte.</p>
<p>Now that we’ve defined how the flipboard transition would look, let us start implementing this transition.</p>
<p>Building on what <a id="_idIndexMarker574"/>we learned with the color swipe transition in the previous section, the flipboard <a id="_idIndexMarker575"/>transition begins in a similar way. Here is the basic code structure for our flipboard transition:</p>
<pre class="source-code">
&lt;script&gt;
  function flipboard(node, params) {
    const config = {
      duration: params?.duration ?? 1000,
      delay: params?.delay ?? 0,
      easing: params?.easing ?? linear,
      tick: (progress) =&gt; {
        // TODO: implement the transition here
      },
    };
    return config;
  }
&lt;/script&gt;
&lt;p transition:flipboard&gt;Hello Svelte.&lt;/p&gt;</pre> <p>In the preceding code snippet, we have defined a <code>flipboard</code> function that adheres to the transition contract. It takes in two arguments, <code>node</code> and <code>params</code>, and returns a transition configuration—an object that describes the transition. As such, we are able to apply the <code>flipboard</code> function as a transition using the <code>transition:</code> directive on a <code>&lt;</code><code>div&gt;</code> element.</p>
<p>Within the flipboard transition, we’ve set up the basic parameters, such as defining the <code>duration</code>, <code>delay</code>, and <code>easing</code> values, while leaving a placeholder for the <code>tick</code> function, where we will implement the transition.</p>
<p>To create a flipboard transition, we start by obtaining the text content of the element that will be transitioning. Then, each time the <code>tick</code> function is called, we determine the text to display based on the <code>progress</code> value and update the element accordingly.</p>
<p>We can retrieve the text of an element using the following API:</p>
<pre class="source-code">
const text = node.textContent;</pre> <p>Similarly, to <a id="_idIndexMarker576"/>set the text content of <a id="_idIndexMarker577"/>an element, we assign it through the same property:</p>
<pre class="source-code">
node.textContent = text;</pre> <p>Incorporating these into the flipboard transition, here’s what we get:</p>
<pre class="source-code">
function flipboard(node, params) {
  <strong class="bold">const text = node.textContent;</strong>
  const config = {
    // ...
    tick: (progress) =&gt; {
      let newText;
      // TODO: compute the newText based on `text` and progress value
      <strong class="bold">node.textContent = newText;</strong>
    },
  };
  return config;
}</pre> <p>In the preceding code snippet, we retrieve the text content of the element at the beginning of the <code>flipboard</code> function, right before the transition starts to play on the element. The <code>tick</code> function, called repeatedly on every animation frame, computes the new <code>text</code> value for the element, based on the original <code>text</code> value and current <code>progress</code> value.</p>
<p>The <code>tick</code> function’s task is to determine how each letter should be displayed, based on the <code>progress</code> value. Some letters might appear as a dash, some as random characters, some as their original value, and others might be hidden.</p>
<p>For each letter, its display depends on its position relative to the full text’s length and the current <code>progress</code> value. For instance, if a letter is positioned at 30% from the left, and the current <code>progress</code> value is <code>0.5</code> (or 50%), then that letter should be displayed as is.</p>
<p>How do we determine these rules? What leads us to the conclusions just drawn?</p>
<p>We want<a id="_idIndexMarker578"/> the element to reveal all its <a id="_idIndexMarker579"/>original characters at the end of the transition. This means that when the <code>progress</code> value reaches 1 (or 100%), all letters should display their original character. At the midpoint, with a <code>progress</code> value of <code>0.5</code> (or 50%), 50% of the letters from the left should show their original character, while the remaining 50% on the right should show either a dash, a random character, or nothing at all.</p>
<p>To generalize, if a letter’s position from the left is less than the <code>progress</code> value, it should display its original character. Otherwise, it may display a dash, a random character, or nothing.</p>
<p>The following diagram illustrates how the <code>progress</code> value and the displayed text are related:</p>
<p class="IMG---Figure">igure 14.9: The red box shows which letters are displaying the original character at each progress value</p>
<p>The preceding diagram illustrates how the original characters are revealed at different values of <code>progress</code>. As the <code>progress</code> value increases, more letters in the word display their original characters.</p>
<p>To implement <a id="_idIndexMarker580"/>the flipboard effect just described, we will loop through each character, determine its relative position, and then decide whether it should be displayed. For characters <a id="_idIndexMarker581"/>whose position is beyond the current <code>progress</code> value, we will display a blank space.</p>
<p>Here is the updated code:</p>
<pre class="source-code">
tick: (progress) =&gt; {
  let newText = '';
<strong class="bold">  for (let i = 0; i &lt; text.length; i++) {</strong>
<strong class="bold">    const position = i / text.length;</strong>
<strong class="bold">    if (position &lt; progress) {</strong>
<strong class="bold">      // display the original character</strong>
<strong class="bold">      newText += text[i];</strong>
<strong class="bold">    } else {</strong>
<strong class="bold">      // display a blank space instead</strong>
<strong class="bold">      newText += ' ';</strong>
<strong class="bold">    }</strong>
<strong class="bold">  }</strong>
  node.textContent = newText;
},</pre> <p>With this code, the flipboard transition now either shows the original characters or a blank space based on the progress value. When playing the transition, you will see the characters appear one by one from left to right.</p>
<p>Having figured out when to show up the original characters, let us continue to determine when the text should display dashes or random characters.</p>
<p>Using a similar idea, we can determine whether a letter should display a random character, a dash, or nothing at all. We will introduce a constant number to manage the timing of these changes. If the letter’s position is beyond this constant multiplied by the <code>progress</code> value, it will show up as nothing. I’ve chosen a value of 2 for this constant, based on trial and error. It’s a value greater than 1 but not too large, to create the effect of characters appearing gradually from the left.</p>
<p>Similarly, we <a id="_idIndexMarker582"/>could also introduce another <a id="_idIndexMarker583"/>constant to manage the display of dashes or random characters. If the letter’s relative position is greater than this new constant times the progress value, but less than 2, the letter will appear as a dash. Otherwise, it will be a random character. For this purpose, I have chosen 1.5, positioning it midway between 1 and 2.</p>
<p>The following diagram visually represents these two constants and their effect on the transition:</p>
<p class="IMG---Figure">igure 14.10: Relationship between the new text and the original text</p>
<p>In the preceding diagram, you can observe how the characters change during the transition. When the <code>progress</code> value is <code>0.4</code>, for example, letters at the 40% position are showing original characters, letters at 40% - 60% (<code>progress</code> * 1.5) are showing random characters, letters at 60% - 80% (<code>progress</code> * 2) are showing dashes, and anything beyond is not shown.</p>
<p>Here’s how the updated code for our flipboard transition looks:</p>
<pre class="source-code">
tick: (progress) =&gt; {
  let newText = '';
  for (let i = 0; i &lt; text.length; i++) {
    const position = i / text.length;
    if (position &lt; progress) {
      // display the original character
      newText += text[i];
<strong class="bold">    } else if (position &lt; progress * 1.5) {</strong>
<strong class="bold">      // display random characters</strong>
<strong class="bold">      newText += randomCharacter()</strong>
<strong class="bold">    } else if (position &lt; progress * 2) {</strong>
<strong class="bold">      // display dash</strong>
<strong class="bold">      newText += '-';</strong>
    } else {
      // display a blank space instead
      newText += ' ';
    }
  }
  node.textContent = newText;
},</pre> <p>In the <a id="_idIndexMarker584"/>preceding code snippet, I’ve <a id="_idIndexMarker585"/>added two additional conditions to determine when to display dashes or random characters.</p>
<p>The <code>randomCharacter()</code> function returns a randomly selected character, implemented as follows:</p>
<pre class="source-code">
const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz1234567890'
function randomCharacter() {
  return chars[Math.floor(Math.random() * chars.length)];
}</pre> <p>With this code, you have a flipboard transition! Try it out with an element and observe the effect. The characters slowly appear one by one from left to right, starting as a dash, flipping through characters, and finally settling with the correct character.</p>
<p>You <a id="_idIndexMarker586"/>may notice one small issue: not <a id="_idIndexMarker587"/>all characters are the same width, so the overall width of the text grows and shrinks. Since each letter is not aligned with its previous position, the flipping effect may not be immediately obvious.</p>
<p>To fix this, you can use a monospace font. Monospace fonts, also known as fixed-width fonts, ensure that each letter occupies the same horizontal space. Applying a monospace font to an element enhances the flipping effect, making it more visually distinct.</p>
<p>For example, you can set the font as follows:</p>
<pre class="source-code">
font-family: monospace;</pre> <p>In this section, we’ve explored how to create a flipboard transition, emulating the appearance of vintage airport departure boards. We’ve learned how to control the appearance of characters based on the progress of the transition, using random characters, dashes, and original text. And through modifying the text of an element, we created a transition that is visually engaging.</p>
<p>The complete code for this section can be found at here:<a href="https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13">https://github.com/PacktPublishing/Real-World-Svelte/tree/main/Chapter13</a>.</p>
<h1 id="_idParaDest-208"><a id="_idTextAnchor210"/>Summary</h1>
<p>In this chapter, we have explored how to create custom transitions in Svelte. We went through two detailed examples that utilize the <code>css</code> function and the <code>tick</code> function.</p>
<p>Hopefully, you now feel well equipped to write your own custom transition in Svelte, enabling you to craft a more engaging and unique user experience in Svelte.</p>
<p>In our next and final chapter, we will delve into how transitions can impact the accessibility of your Svelte application, guiding you in the creation of an engaging and inclusive experience for all users.</p>
</div>
</div></body></html>