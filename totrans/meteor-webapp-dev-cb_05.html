<html><head></head><body><div class="chapter" title="Chapter&#xA0;5.&#xA0;Implementing DDP" id="aid-1IHDQ1"><div class="titlepage"><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Implementing DDP</h1></div></div></div><p>In this chapter, we will cover the following topics:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Reading the DDP stream</li><li class="listitem">Using client-only collections</li><li class="listitem">Implementing a multiserver DDP</li><li class="listitem">Integrating DDP with other technologies</li></ul></div><div class="section" title="Introduction"><div class="titlepage"><div><div><h1 class="title"><a id="ch05lvl1sec47"/>Introduction</h1></div></div></div><p>Fundamental to Meteor is the concept of real-time applications, with the client and server interacting with each other using the<a id="id235" class="indexterm"/> principle of <span class="strong"><strong>data on the wire</strong></span>. The folks at Meteor have developed a protocol for this real-time client-server communication, called the <a id="id236" class="indexterm"/>
<span class="strong"><strong>Distributed Data Protocol</strong></span> (<span class="strong"><strong>DDP</strong></span>). As with everything else in Meteor, DDP is a discreet (albeit core) library, which you can use separately. The recipes in this chapter will show you how DDP works and give you some ideas about what you can do with it outside of its default use in Meteor.</p></div></div>
<div class="section" title="Reading the DDP stream"><div class="titlepage" id="aid-1JFUC2"><div><div><h1 class="title"><a id="ch05lvl1sec48"/>Reading the DDP stream</h1></div></div></div><p>To truly <a id="id237" class="indexterm"/>understand what is going on with DDP (and for debugging purposes) it's useful to be able to read the DDP stream. Seeing DDP in action can not only help with the debugging process, but can also help you to better understand how flexible and useful this protocol is. This recipe will show you how to use Arunoda Susiripala's most excellent DDP Analyzer.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec168"/>Getting ready</h2></div></div></div><p>You will need Meteor, Node, and npm installed. For installation instructions, visit the following URLs:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Node—<a class="ulink" href="http://nodejs.org">http://nodejs.org</a></li><li class="listitem">npm—<a class="ulink" href="https://www.npmjs.com/">https://www.npmjs.com/</a></li></ul></div><p>You <a id="id238" class="indexterm"/>will <a id="id239" class="indexterm"/>also need a project. You can use pretty much<a id="id240" class="indexterm"/> any project you like. Because it offers a decent, controllable amount of client-server communication (in other words, DDP streams), we will use the <code class="literal">todos</code> example application. Note that you can also use your own Meteor project if you like. We are only using this as an example because it's convenient and because we can control the flow of data.</p><p>To install the <code class="literal">todos</code> example, open a terminal window, navigate to a directory of your choice, and enter the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ meteor create --example todos</strong></span>
</pre></div><p>Go ahead and start your Meteor application by entering the following commands:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ cd todos</strong></span>
<span class="strong"><strong>$ meteor</strong></span>
</pre></div><p>You are now ready to install and <a id="id241" class="indexterm"/>run the DDP Analyzer on the <code class="literal">todos</code> app.</p></div><div class="section" title="How to do it..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec169"/>How to do it...</h2></div></div></div><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we need to install the DDP Analyzer. In a terminal window, enter and execute the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm install -g ddp-analyzer</strong></span>
</pre></div><p>Note that you may need to use <code class="literal">sudo</code> when using the <code class="literal">–g</code> operator to make the Analyzer available from anywhere and to make sure it has proper permissions. After a brief installation process, the Analyzer will be installed and ready to be used.</p></li><li class="listitem">Start the Analyzer proxy by entering the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ ddp-analyzer-proxy</strong></span>
</pre></div><p>You will get a message similar to the following:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>DDP Proxy Started on port: 3030</strong></span>
<span class="strong"><strong>===============================</strong></span>
<span class="strong"><strong>Export following env. variables and start your meteor app</strong></span>
<span class="strong"><strong>  export DDP_DEFAULT_CONNECTION_URL=http://localhost:3030</strong></span>
<span class="strong"><strong>  meteor</strong></span>
</pre></div></li><li class="listitem">We now need to restart our Meteor instance with the environmental variable mentioned in the preceding step. In your terminal window, stop the <code class="literal">meteor</code> if it is still running and enter the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ export DDP_DEFAULT_CONNECTION_URL=http://localhost:3030</strong></span>
<span class="strong"><strong>$ meteor</strong></span>
</pre></div></li><li class="listitem">Once the <code class="literal">meteor</code> starts the backup, navigate to <code class="literal">http://localhost:3000</code> in a browser and the DDP Analyzer will be ready for action.</li><li class="listitem">Perform <a id="id242" class="indexterm"/>several tasks, such as adding new <code class="literal">todo</code> items, completing/editing existing items, and so on.</li><li class="listitem">Take a look at the DDP stream in the terminal window where you started the DDP Analyzer. It will look similar to the following screenshot:<div class="mediaobject"><img src="../Images/image00369.jpeg" alt="How to do it..."/></div><p style="clear:both; height: 1em;"> </p><p>You will be able to see all the messages intended for the clients. The numbers in yellow tell you which client it was sent to/from. Messages preceded by <span class="strong"><strong>IN</strong></span>  indicate that the message was sent from the server to the client. If the message is preceded by <span class="strong"><strong>OUT</strong></span>, this indicates the message and outbound request from the client to the server. The messages are in plain text following the color-coded texts.</p><p>With the DDP Analyzer, you can really get under the hood, seeing exactly how DDP works. You'll quickly realize how flexible and simple the protocol is, and you will gain a better understanding of what you can do with it inside your Meteor (or other) applications.</p></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works..."><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec170"/>How it works...</h2></div></div></div><p>DDP, oversimplified, is a <a id="id243" class="indexterm"/>series of messages between two end points. The messages show updates, additions, and deletions, and are transmitted over websockets. This means the messages can be sent in real time, rather than waiting for the traditional client request polling. This cuts down on traffic (chatter) and ensures that the messages are delivered as quickly as possible.</p><p>The DDP Analyzer uses the DDP protocol and listens in on the streaming conversation between your browser and the Meteor application. When you changed the port that DDP executes through using the <code class="literal">DDP_DEFAULT_CONNECTION_URL=</code> command, you rerouted your app through port <code class="literal">3030</code>. The DDP Analyzer listened on this port, proxied the connection to port <code class="literal">3000</code>, and logged all the traffic approaching it in the terminal window.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec171"/>There's more…</h2></div></div></div><p>Once you have finished, be sure to either open a new terminal window or change your environment variable back to port <code class="literal">3000</code> using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ export DDP_DEFAULT_CONNECTION_URL=http://localhost:3000</strong></span>
</pre></div><p>If you don't, your application will stop working because DDP is still running through port <code class="literal">3030</code>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec172"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <span class="emphasis"><em>Using the web console</em></span> recipe in <a class="link" title="Chapter 1. Optimizing Your Workflow" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <span class="emphasis"><em>Optimizing Your Workflow</em></span></li></ul></div></div></div>
<div class="section" title="Using client-only collections"><div class="titlepage" id="aid-1KEEU2"><div><div><h1 class="title"><a id="ch05lvl1sec49"/>Using client-only collections</h1></div></div></div><p>To truly <a id="id244" class="indexterm"/>understand how DDP works, it's helpful to try <span class="emphasis"><em>rolling your own</em></span> as far as communicating with data over the wire is concerned. The best way to do this (and a quite helpful recipe to boot!) is to let the client continue to take advantage of the built-in Mongo collections and programmatically send updates from the server based on some simple logic. This recipe will walk you through creating a client-only collection and manipulating this collection with calls on the server side.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec173"/>Getting ready</h2></div></div></div><p>We are going to need a sample project to use as a baseline. For this baseline, we will quickly create a bookmark application. No bells and whistles, just a simple list of bookmark titles and URLs.</p><p>To do this, we <a id="id245" class="indexterm"/>first need our default template scaffolding. Please create a new project called <code class="literal">bookmarks</code> using the <span class="emphasis"><em>Setting up your project file structure</em></span> recipe in <a class="link" title="Chapter 1. Optimizing Your Workflow" href="part0015.xhtml#aid-E9OE1">Chapter 1</a>, <span class="emphasis"><em>Optimizing Your Workflow</em></span>, as your starting file structure.</p><p>We need to add and remove some Meteor packages. Start by removing the <code class="literal">autopublish</code> package. Open a terminal window, navigate to the root folder of your project, and execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ meteor remove autopublish</strong></span>
</pre></div><p>Next, let's add the <code class="literal">bootstrap</code> package. Execute the following command in your terminal window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ meteor add twbs:bootstrap</strong></span>
</pre></div><p>We will now add the HTML and JavaScript needed to create our <code class="literal">bookmarks</code> program.</p><p>Replace the contents of your <code class="literal">[project root]/client/main.html</code> file with the following:</p><div class="informalexample"><pre class="programlisting">&lt;head&gt;
    &lt;title&gt;Chapter 05&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
    {{&gt; urls}}
&lt;/body&gt;
&lt;template name="urls"&gt;
    &lt;div class="url-container"&gt;
      {{#each bookmarks}}
      &lt;div class="bookmark panel {{selected}}"&gt;
        &lt;div class="panel-heading"&gt;
          &lt;button type="button" class="close"&gt;&lt;span class="glyphicon glyphicon-remove"&gt;&lt;/span&gt;
          &lt;/button&gt;
          {{#if editing}}
            &lt;h3 class="panel-title"&gt;&lt;input type="text" value="{{title}}"&gt;&lt;/h3&gt;
          {{else}}
          &lt;h3 class="panel-title"&gt; {{title}}&lt;/h3&gt;
            {{/if}}
        &lt;/div&gt;
        &lt;div class="panel-body"&gt;
          {{#if src}}
            &lt;a href="{{src}}"&gt;{{src}}&lt;/a&gt;
          {{else}}
            &lt;div class="input-group"&gt;
              &lt;input type="text" class="form-control" placeholder="enter URL here" /&gt;
            &lt;/div&gt;
          {{/if}}
        &lt;/div&gt;
      &lt;/div&gt;
      {{/each}}
      &lt;input type="button" class="btn btn-primary" id="btnNewBM" value="add" /&gt;
    &lt;/div&gt;
&lt;/template&gt;</pre></div><p>Next, in<a id="id246" class="indexterm"/> your <code class="literal">[project root]/client/scripts</code> folder, add the following to <code class="literal">main.js</code>:</p><div class="informalexample"><pre class="programlisting">Meteor.subscribe('urls');</pre></div><p>Then, create a <code class="literal">templateHelpers.js</code> file in the same <code class="literal">scripts</code> folder and add the following <code class="literal">helpers</code> function:</p><div class="informalexample"><pre class="programlisting">Template.urls.helpers({ bookmarks: function () { return URLs.find();
    },
    title: function () { return this.title || this.src;
    },
    editing: function () { return Session.equals('selMark', this._id) &amp;&amp; Session.equals('editMark', this._id);
    },
    selected: function () { return Session.equals('selMark', this._id) ? "panel-warning" : "panel-success";
    },
    src: function () { return this.src || false;
    }
});</pre></div><p>In the same <code class="literal">templateHelpers.js</code> file, add the following <code class="literal">events</code> function:</p><div class="informalexample"><pre class="programlisting">Template.urls.events({
    'click .bookmark': function (e) {
        Session.set('selMark', this._id);
    },
    'dblclick .bookmark': function (e) {
        Session.set('editMark', this._id);
    },
    'blur .panel-title &gt; input': function (e) {
        if (e.currentTarget.value !== this.title) {
            Meteor.call('updateTitle', this._id, e.currentTarget.value, function (err, succ) {
                console.log(succ);
            });
        }
        Session.set('editMark', null);
    },
    'keypress .panel-title &gt; input': function (e) {
        if (e.keyCode == 13 &amp;&amp; e.currentTarget.value !== this.title) {
            Meteor.call('updateTitle', this._id, e.currentTarget.value, function (err, succ) {
                console.log(succ);
                Session.set('editMark', null);
            });
        }
    },
    'click #btnNewBM': function (e) {
        URLs.insert({
            title: 'new bookmark'
        });
    },
    'blur .input-group &gt; input': function (e) {
        if (e.currentTarget.value !== this.src) {
            Meteor.call('updateSRC', this._id, e.currentTarget.value, function (err, succ) {
                console.log(succ);
            });
        }
    },
    'keypress .input-group &gt; input': function (e) {
        if (e.keyCode == 13 &amp;&amp; e.currentTarget.value !== this.src) {
            Meteor.call('updateSRC', this._id, e.currentTarget.value, function (err, succ) {
                console.log(succ);
            });
        }
    },
    'click .close': function (e) {
        Meteor.call('removeBM', this._id, function (err, succ) {

        });
    }
});</pre></div><p>Now, we need <a id="id247" class="indexterm"/>a bit of styling. Open the <code class="literal">style.css</code> file found in your <code class="literal">[project root]/libs/styles</code> folder and replace the existing styles with the following:</p><div class="informalexample"><pre class="programlisting">/* CSS declarations go here */
body {
    font-size:1.5rem;
}

.url-container{
    background-color: rgb(255, 255, 255);
    border-color: rgb(221, 221, 221);
    border-width: 1px;
    border-radius: 4px 4px 0 0;
    -webkit-box-shadow: none;
    box-shadow: none;
    position: relative;
    padding: 45px 15px 15px;
    margin: 20px;
    margin-left:auto;
    margin-right:auto;
    max-width: 90%;
    border-style:solid;
}

.input-group {
    width:90%;
}</pre></div><p>We need to declare our URLs collection, so create a <code class="literal">collections.js</code> file in your <code class="literal">[project root]/both</code> folder and add the following <code class="literal">Mongo.Collection</code> declaration and <code class="literal">String.prototyp</code>
<code class="literal">e</code> function:</p><div class="informalexample"><pre class="programlisting">URLs = new Mongo.Collection("urls");

if (typeof String.prototype.startsWith != 'function') {
    String.prototype.startsWith = function (str){
        return this.slice(0, str.length) == str;
    };
}</pre></div><p>Finally, we add some server logic. Open <code class="literal">[project root]/server/server.js</code> and replace any existing code with the following:</p><div class="informalexample"><pre class="programlisting">    Meteor.publish('urls',function(){
       return URLs.find();
    });
      
    Meteor.methods({
        updateTitle: function(id,title){
            var bmark = URLs.findOne(id);
            if (!bmark) return;
            if (title&amp;&amp; title!==bmark.title){
                URLs.update(id,{$set:{title:title}});
            
            return "updated";
            }
            return "same title";
        },
        updateSRC: function(id,src){
            var bmark = URLs.findOne(id);
            if (!bmark) return;
            if (src&amp;&amp; src!==bmark.src){

                //Adding the http if it doesn't already have it...
                src = src.startsWith('http')? src: 'http://'+src;
                URLs.update(id,{$set:{src:src}});

                return "updated";
            }
            return "same src";
        },
        removeBM: function(id){
            URLs.remove(id);
            return "removed";
        }
    });</pre></div><p>Save all your <a id="id248" class="indexterm"/>changes, start up your <code class="literal">meteor</code> instance, and navigate to your project in a browser (usually <code class="literal">http://localhost:3000</code>). If everything went correctly, you will now have a working <code class="literal">bookmarks</code> app, where you can add URLs and (by double-clicking) add/change the titles for the bookmarks. The following screenshot is a sample of how the browser will look when it is complete:</p><div class="mediaobject"><img src="../Images/image00370.jpeg" alt="Getting ready"/></div><p style="clear:both; height: 1em;"> </p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec174"/>How to do it…</h2></div></div></div><p>We are<a id="id249" class="indexterm"/> going to add a counter at the bottom of our <code class="literal">bookmarks</code> page. This counter will tell us how many secure and non-secure links we have (determined by whether the link starts with <code class="literal">https</code>).</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we will add the client-only collection called <code class="literal">bmcounts</code> and subscribe to it. If we declare the collection anywhere in the <code class="literal">clients</code> folder, the server will not be able see it. Hence, it will be a client-only collection. Open the <code class="literal">main.js</code> file in your client <code class="literal">scripts</code> folder (<code class="literal">[project root]/client/scripts/main.js</code>) and add the following two lines around the existing <code class="literal">Meteor.subscribe('urls')</code> command, as follows:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>BMCounts = new Mongo.Collection("bmcounts");</strong></span>
Meteor.subscribe('urls');
<span class="strong"><strong>Meteor.subscribe('bmcounts', new Mongo.ObjectID());</strong></span>
</pre></div></li><li class="listitem">While we are in the <code class="literal">scripts</code> folder, let's open the <code class="literal">templateHelpers.js</code> file and add the reactive <code class="literal">Template.helpers</code> function which we'll need to display the counts. Add the following function to the bottom of the file:<div class="informalexample"><pre class="programlisting">Template.linkcount.helpers({
    BMCount: function(){
        return BMCounts.findOne();
    }
});</pre></div></li><li class="listitem">Now let's add the HTML template. Open <code class="literal">main.html</code>, found in your <code class="literal">client</code> folder, and add the following code around the <code class="literal">&lt;body&gt;</code> tag:<div class="informalexample"><pre class="programlisting">&lt;body&gt;
    {{&gt; urls}}
<span class="strong"><strong>    {{&gt; linkcou</strong></span>
<span class="strong"><strong>nt}}</strong></span>
&lt;/body&gt;
<span class="strong"><strong>&lt;template name="linkcount"&gt;</strong></span>
<span class="strong"><strong>    {{#with BMCount}}</strong></span>
<span class="strong"><strong>    &lt;div id="counts"&gt;</strong></span>
<span class="strong"><strong>        &lt;button class="btn btn-lg btn-info"&gt;</strong></span>
<span class="strong"><strong>            &lt;span class="glyphicon glyphicon-link"&gt;&lt;/span&gt;</strong></span>
<span class="strong"><strong>            {{unsecureCount}} /</strong></span>
<span class="strong"><strong>            &lt;span class="glyphicon glyphicon-lock"&gt;&lt;/span&gt;</strong></span>
<span class="strong"><strong>            {{secureCount}}</strong></span>
<span class="strong"><strong>        &lt;/button&gt;</strong></span>
<span class="strong"><strong>    &lt;/div&gt;</strong></span>
<span class="strong"><strong>    {{/with}}</strong></span>
<span class="strong"><strong>&lt;/template&gt;</strong></span>
</pre></div></li><li class="listitem">We'll <a id="id250" class="indexterm"/>pretty up our counter a bit with some CSS as well. Open your <code class="literal">style.css</code> file, found in your <code class="literal">lib</code>/<code class="literal">styles</code> director, and add the following CSS declaration:<div class="informalexample"><pre class="programlisting">#counts{
    position:relative;
    float:right;
    margin-right:50px;
}</pre></div></li><li class="listitem">We have some real work to do now on the server side. We need to count and sort the bookmarks as they are added, removed, or changed. Open your <code class="literal">server.js</code> file, found in your <code class="literal">server</code> folder, and add the following <code class="literal">Meteor.publ</code><code class="literal">ish</code> function:<div class="informalexample"><pre class="programlisting">Meteor.publish('bmcounts', function (id) {
  var self = this;
  var count = 0;
  var secCount = 0;
  var initializing = true;
  var handle = URLs.find().observeChanges({
    //TODO: Added
    //TODO: Removed
    //TODO: Changed
  });
  initializing = false;
  self.added("bmcounts", id, {
    unsecureCount: count,
    secureCount: secCount
  });
  self.ready();
  self.onStop(function () {
    handle.stop();
  });
});</pre></div></li><li class="listitem">Inside the <a id="id251" class="indexterm"/>preceding code block, we have three <code class="literal">TODO</code> comments. We first need to create the <code class="literal">added</code> listener. Directly under the <code class="literal">//TODO: Added</code> comment, add the following code:<div class="informalexample"><pre class="programlisting">//TODO: Added
<span class="strong"><strong>added: function (idx, doc) {</strong></span>
<span class="strong"><strong>  if (doc.src &amp;&amp; doc.src.toLowerCase().startsWith('https')) {</strong></span>
<span class="strong"><strong>    secCount++;</strong></span>
<span class="strong"><strong>    if (!initializing)</strong></span>
<span class="strong"><strong>      self.changed("bmcounts", id, {</strong></span>
<span class="strong"><strong>        secureCount: secCount</strong></span>
<span class="strong"><strong>      });</strong></span>
<span class="strong"><strong>  } else {</strong></span>
<span class="strong"><strong>    count++;</strong></span>
<span class="strong"><strong>    if (!initializing)</strong></span>
<span class="strong"><strong>      self.changed("bmcounts", id, {</strong></span>
<span class="strong"><strong>        unsecureCount: count</strong></span>
<span class="strong"><strong>      });</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>},</strong></span>
</pre></div></li><li class="listitem">Next is the <code class="literal">removed</code> listener. Directly under the <code class="literal">//TODO: Removed</code> comment, add the following code:<div class="informalexample"><pre class="programlisting">//TODO: Removed
<span class="strong"><strong>removed: function (idx, doc) {</strong></span>
<span class="strong"><strong>    //really inefficient...</strong></span>
<span class="strong"><strong>    var bms = URLs.find().fetch();</strong></span>
<span class="strong"><strong>    secCount = _.filter(bms,function(bm){</strong></span>
<span class="strong"><strong>      return bm.src &amp;&amp; bm.src.toLowerCase().startsWith('https');</strong></span>
<span class="strong"><strong>    }).length;</strong></span>
<span class="strong"><strong>    count = bms.length - secCount;</strong></span>
<span class="strong"><strong>    self.changed("bmcounts", id, {</strong></span>
<span class="strong"><strong>      unsecureCount: count,</strong></span>
<span class="strong"><strong>      secureCount: secCount</strong></span>
<span class="strong"><strong>    });</strong></span>

<span class="strong"><strong>  },</strong></span>
</pre></div></li><li class="listitem">Finally, the <code class="literal">changed</code> listener. Add the following code directly under the <code class="literal">//TODO: Changed</code> comment:<div class="informalexample"><pre class="programlisting">//TODO: Changed
<span class="strong"><strong>changed: function (idx, doc) {</strong></span>
<span class="strong"><strong>  if (doc.src &amp;&amp; doc.src.toLowerCase().startsWith('https')) {</strong></span>
<span class="strong"><strong>    secCount++;</strong></span>
<span class="strong"><strong>    count--;</strong></span>
<span class="strong"><strong>    self.changed("bmcounts", id, {</strong></span>
<span class="strong"><strong>      unsecureCount: count,</strong></span>
<span class="strong"><strong>      secureCount: secCount</strong></span>
<span class="strong"><strong>    });</strong></span>
<span class="strong"><strong>  }</strong></span>
<span class="strong"><strong>}</strong></span>
</pre></div></li><li class="listitem">Save all <a id="id252" class="indexterm"/>your changes, start your <code class="literal">meteor</code> instance if it isn't already started, and navigate to your project in a browser (usually <code class="literal">http://localhost:3000</code>). You should see a small information button at the bottom-right corner of your screen with a count of secure and non-secure links. Add some new links, delete others, and watch the count change instantly in your browser, similar to the following screenshot:<div class="mediaobject"><img src="../Images/image00371.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec175"/>How it works…</h2></div></div></div><p>All of the client-side code<a id="id253" class="indexterm"/> we just added is exactly the same as it would be for a regular Mongo collection. As far as the client is concerned, everything is normal.</p><p>On the server, however, we'd need to manually update the DDP stream with the <code class="literal">.added</code> and <code class="literal">.changed</code> messages, based on the changes made to the <code class="literal">URLs</code> collection.</p><p>To accomplish this, we start by using the function passed as an argument in the <code class="literal">Meteor.publish()</code> function arguments:</p><div class="informalexample"><pre class="programlisting">Meteor.publish('bmcounts', <span class="strong"><strong>function (id) {</strong></span>
...
});</pre></div><p>This function is rerun every time a client subscribes to the DDP stream. Inside the function, we create a <code class="literal">handle</code> using the <code class="literal">Mongo.Cursor.observeChanges()</code> function:</p><div class="informalexample"><pre class="programlisting">var handle = URLs.find().observeChanges({
  ...
});</pre></div><p>Inside the <code class="literal">observeChanges</code> function, if a document is added (except when initializing), we check whether the <code class="literal">src</code> property begins with <code class="literal">https</code> to see whether we can increment the <code class="literal">secCount</code> (secure count) variable; otherwise, we'll just increment the normal <code class="literal">count</code> variable.</p><p>If a document is removed, we have to do a bit of trickery, but we will recalculate the <code class="literal">secCount</code> and <code class="literal">count</code> variables.</p><p>If a document's <code class="literal">src</code> variable is changed, we will perform the same check as we did in <code class="literal">added</code> and move the increment from <code class="literal">count</code> to <code class="literal">secCount</code>.</p><p>These three situations will happen as the <code class="literal">URLs</code> collection changes in real time. Therefore, after each change, we will call the <code class="literal">self.changed()</code> function, which sends a message to the client via DDP, mimicking the automatic change messages that would be sent if we were modifying the <code class="literal">bmcounts</code> collection normally.</p><p>You will notice that the <code class="literal">bmcounts</code> collection is never used on the server. Instead, we send messages to the client through the <code class="literal">"bmcounts"</code> subscription channel, as in the following example:</p><div class="informalexample"><pre class="programlisting">self.changed("bmcounts", id, {
  ...
});</pre></div><p>This is an important distinction. The client does not subscribe to the actual MondoDB collection. Instead, it subscribes to a <code class="literal">DDP</code> messaging channel. In this case, we're letting the client do the heavy lifting for us by sending the <code class="literal">"bmcounts"</code> subscription messages into the <code class="literal">bmcount</code> client-only collection. In essence, the server is sending data changes over the wire, and the client, being none the wiser, is treating the messages as actual data changes.</p><p>The rest of the method <a id="id254" class="indexterm"/>is cleanup for when a client unsubscribes, using <code class="literal">handle.stop()</code> to complete the initialization. It includes making a <code class="literal">self.added()</code> call, which does the same thing as a <code class="literal">self.changed()</code> call (mimics a data change and sends it over the wire to the subscribed clients). The final step in initialization is to call <code class="literal">self.ready()</code>, which lets the subscribed client know that all the initial data changes have been sent.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec176"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <span class="emphasis"><em>Implementing a partial collection</em></span> recipe in <a class="link" title="Chapter 4. Creating Models" href="part0046.xhtml#aid-1BRPS1">Chapter 4</a>, <span class="emphasis"><em>Creating Models</em></span></li><li class="listitem">The <span class="emphasis"><em>Basic safety – turning off autopublish</em></span> recipe in <a class="link" title="Chapter 9. Securing Your Application" href="part0073.xhtml#aid-25JP21">Chapter 9</a>, <span class="emphasis"><em>Securing Your Application</em></span></li></ul></div></div></div>
<div class="section" title="Implementing multiserver DDP"><div class="titlepage" id="aid-1LCVG2"><div><div><h1 class="title"><a id="ch05lvl1sec50"/>Implementing multiserver DDP</h1></div></div></div><p>The <a id="id255" class="indexterm"/>fun doesn't stop with a single client and server DDP connection. Oh no! Indeed, Meteor has invited everybody to the DDP party, and in this recipe, we're going to see how two Meteor servers can speak to each other using DDP.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec177"/>Getting ready</h2></div></div></div><p>We will be using the code base from the <span class="emphasis"><em>Using client-only collections</em></span> recipe, found in this chapter. Please create an instance of this project and start your <code class="literal">meteor</code> server.</p><p>For this project, we will change the color of the bookmark titles, based on whether the links are secure or not; so we need to make one change to our first project to make the color dependent on the <code class="literal">secType</code> property (which we will create in this recipe). Open the <code class="literal">templateHelpers.js</code> file, found in the <code class="literal">[project root]/client/scripts</code> folder of the first project. Locate the <code class="literal">Template.urls.helpers</code> section and make the following change to the <code class="literal">selected</code> function:</p><div class="informalexample"><pre class="programlisting">Template.urls.helpers({
    …
    selected: function () {
        return Session.equals('selMark', this._id) ? "panel-warning" : this.secType;
    },
    …</pre></div><p>As we will be implementing another Meteor server instance, we will also need to create a new Meteor project. In a terminal window, navigate to a location outside your root project folder, and enter the following commands in the terminal window:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ meteor create typecheck</strong></span>
<span class="strong"><strong>$ cd typecheck</strong></span>
<span class="strong"><strong>$ meteor remove autopublish</strong></span>
<span class="strong"><strong>$ meteor --port 3030</strong></span>
</pre></div><p>This will properly <a id="id256" class="indexterm"/>initialize our second server instance and start it up on port <code class="literal">3030</code>.</p><p>We're now ready to get our second Meteor project talking to our first project!</p></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec178"/>How to do it…</h2></div></div></div><p>We're going to change the color of the bookmark titles using a new bookmark property called <code class="literal">secType</code>. Our new (second) project will check bookmarks as they come across the DDP wire and add a <code class="literal">secType</code> property if needed. Let's get started.</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">First, we will want to make use of the <code class="literal">String.startsWith()</code> function we're familiar with from the <span class="emphasis"><em>Using client-only collections</em></span> recipe. Add the following prototype modifier to the bottom of the <code class="literal">typecheck.js</code> file, found in your second project's root folder:<div class="informalexample"><pre class="programlisting">if (typeof String.prototype.startsWith != 'function') { String.prototype.startsWith = function (str){return this.slice(0, str.length) == str;
    };
}</pre></div></li><li class="listitem">Now, we want to create a server-only file so that we can concentrate on the task at hand. Create a <code class="literal">server</code> folder in your project root and then create and open a file named <code class="literal">DDPChecker.js</code> for editing.</li><li class="listitem">In the <code class="literal">DDPChecker.js</code> file, add the following code to connect and subscribe to the <code class="literal">urls</code> collection from our first project:<div class="informalexample"><pre class="programlisting">conn = DDP.connect("http://localhost:3000");
URLs = new Mongo.Collection("urls",conn);
conn.subscribe("urls");</pre></div></li><li class="listitem">Now, we create a function that checks a record to see whether the <code class="literal">secType</code> variable has been set or not. If it hasn't and if there's an <code class="literal">src</code> property to check, it will update the record with the appropriate <code class="literal">secType</code> variable. Add the following function to the bottom of <code class="literal">DDPChecker.js</code>:<div class="informalexample"><pre class="programlisting">function checkSecType(idx,doc){ if (!doc.src || doc.secType) return;
    if (doc.src.toLowerCase().startsWith('https'))
        doc.secType = 'panel-success';
    else
        doc.secType = 'panel-danger';
    URLs.update(idx,doc);
}</pre></div></li><li class="listitem">The <a id="id257" class="indexterm"/>last piece of the puzzle is to add a call to the <code class="literal">checkSecType</code> function we just created, whenever a record is added or changed. We do this by calling the <code class="literal">observeChanges</code> function and the <code class="literal">URLs.find()</code> cursor. Add the following code to the bottom of <code class="literal">DDPChecker.js</code>:<div class="informalexample"><pre class="programlisting">URLs.find().observeChanges({ added:checkSecType, changed:checkSecType });</pre></div></li><li class="listitem">Open a browser and navigate to your project (usually <code class="literal">http://localhost:3000</code>). The colors of each bookmark should correspond to the security types of the bookmark links, similar to the following screenshot:<div class="mediaobject"><img src="../Images/image00372.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec179"/>How it works…</h2></div></div></div><p>Inside our <a id="id258" class="indexterm"/>second project, we are declaring the <code class="literal">URLs</code> collection and subscribing to changes just like we would in a normal <code class="literal">client</code> app. The difference here is that we're establishing a connection to an existing Meteor server, using the <code class="literal">DDP.Connect()</code> function:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>conn</strong></span> = DDP.connect("http://localhost:3000");
URLs = new Mongo.Collection("urls",<span class="strong"><strong>conn</strong></span>);</pre></div><p>We passed the handle to this connection as an argument, called <code class="literal">conn</code>, when we declared our <code class="literal">URLs</code> collection. This tells Meteor that we're interested in the collection (more accurately, the DDP messages) coming from our first server.</p><p>To avoid redundant code, we created the <code class="literal">checkSecType</code> function, which listens to the changes made to the <code class="literal">URLs</code> collection and sets the <code class="literal">secType</code> property to correspond with the security type of the <code class="literal">src</code> property. We then use the <code class="literal">checkSecType</code> function as the event handler for both <code class="literal">added</code> and <code class="literal">changed</code> events coming through the DDP wire via <code class="literal">observeChanges</code>.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec180"/>There's more…</h2></div></div></div><p>Using DDP as a client isn't unique to Meteor. You can use DDP with nearly any technology. You'll see an example in the <span class="emphasis"><em>Integrating DDP with other technologies</em></span> recipe, found later in this chapter.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec181"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <span class="emphasis"><em>Implementing a partial collection</em></span> recipe in <a class="link" title="Chapter 4. Creating Models" href="part0046.xhtml#aid-1BRPS1">Chapter 4</a>, <span class="emphasis"><em>Creating Models</em></span></li><li class="listitem">The <span class="emphasis"><em>Integrating DDP with other technologies</em></span> recipe in this chapter</li></ul></div></div></div>
<div class="section" title="Integrating DDP with other technologies"><div class="titlepage" id="aid-1MBG22"><div><div><h1 class="title"><a id="ch05lvl1sec51"/>Integrating DDP with other technologies</h1></div></div></div><p>The <a id="id259" class="indexterm"/>party never stops with DDP! DDP libraries are available for most major programming languages and platforms, and you can very quickly get your client, server, or even hardware devices talking to your Meteor server without much effort. This recipe will show you how to connect to a Meteor server using DDP from a <code class="literal">Node.js</code> program.</p><div class="section" title="Getting ready"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec182"/>Getting ready</h2></div></div></div><p>We'll want to use the code base from the <span class="emphasis"><em>Using client-only collections</em></span> recipe, found in this chapter. Please create an instance of that project and start your <code class="literal">meteor</code> server.</p><p>You will need <a id="id260" class="indexterm"/>Node and npm installed to complete this recipe. They are installed with Meteor by default. However, if you need instructions on how to install Node.js and npm, they can be found on the following websites:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Node—<a class="ulink" href="http://nodejs.org">http://nodejs.org</a></li><li class="listitem">NPM—<a class="ulink" href="https://www.npmjs.com/">https://www.npmjs.com/</a></li></ul></div><p>We <a id="id261" class="indexterm"/>will <a id="id262" class="indexterm"/>also need to make sure that the <code class="literal">ddp</code> npm module is installed. Open a terminal window and execute the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ npm -g install ddp</strong></span>
</pre></div><div class="note" title="Note"><h3 class="title"><a id="tip29"/>Tip</h3><p>When installing <code class="literal">npm</code> modules globally, you may need to use the <code class="literal">sudo</code> command, similar to the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ sudo npm –g install ...</strong></span>
</pre></div></div></div><div class="section" title="How to do it…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec183"/>How to do it…</h2></div></div></div><p>We will create a Node service that will check the <code class="literal">src</code> properties for records in our <code class="literal">URLs</code> collection to make sure they're secure (HTTPS). If they aren't secure, the Node service will call our Meteor <code class="literal">updateSRC</code> method and change the <code class="literal">src</code> properties to be secure. To integrate DDP with other technologies, perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">We first create the project folder. In a terminal window, create a <code class="literal">nodecheck</code> folder and <code class="literal">cd</code> to this directory, and add the <code class="literal">ddp</code> <code class="literal">npm</code> module by executing the following commands:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ mkdir nodecheck</strong></span>
<span class="strong"><strong>$ cd nodecheck</strong></span>
<span class="strong"><strong>$ npm install ddp</strong></span>
</pre></div></li><li class="listitem">We now want to create our service. Create a file in the <code class="literal">nodecheck</code> directory named <code class="literal">main.js</code>. Open it for editing and declare the DDP connection by adding the following code:<div class="informalexample"><pre class="programlisting">var DDPClient = require("ddp");

var ddpclient = new DDPClient({
    host: "localhost",
    port: 3000,
    path: "websocket",
    ssl: false,
    autoReconnect: true,
    autoReconnectTimer: 500,
    maintainCollections: true,
    ddpVersion: '1'
});</pre></div></li><li class="listitem">We now <a id="id263" class="indexterm"/>want to connect to our Meteor server using the <code class="literal">.connect()</code> function and display the result of a successful subscription in the console window. Append the following code to <code class="literal">m</code><code class="literal">ain.js</code>:<div class="informalexample"><pre class="programlisting">ddpclient.connect(function (error) {
    if (error) {
        console.log(error);
    } else console.log('successful connection');

    ddpclient.subscribe('urls', [], function () {
        var urls = Object.keys(ddpclient.collections.urls);
        console.log(urls);
    })
});</pre></div></li><li class="listitem">Finally, we will listen to the messages coming across the DDP wire using the <code class="literal">.on()</code> function. We will check all the <code class="literal">added</code> and <code class="literal">changed</code> messages and replace the URL with a secure URL where needed, using the <code class="literal">.call()</code> function to invoke the remote Meteor server <code class="literal">updateSRC</code> method. Append the following code to <code class="literal">m</code><code class="literal">ain.js</code>:<div class="informalexample"><pre class="programlisting">ddpclient.on('message', function (msg) {
    var message = ddpclient.EJSON.parse(msg);
    switch (message.msg) {
    case "added":
    case "changed":
        var url = message.fields.src;
        if (url) {
            if (!url.startsWith('https')) {
                message.fields.src = url.replace('http:', 'https:');
                ddpclient.call('updateSRC', [message.id, message.fields.src], function (err, success) { if (!err) console.log(success);
                    })
            }
        }
        break;
    default:
        break;
    }
});
if (typeof String.prototype.startsWith != 'function') {
    String.prototype.startsWith = function (str) {
        return this.slice(0, str.length) == str;
    };
}</pre></div><p>Okay, we're now ready to run our Node service. Save all your changes, and make sure you have an instance of your original Meteor project open in a browser (usually <code class="literal">http://localhost:3000</code>) so that you can see the changes. They'll happen quickly, so don't blink!</p></li><li class="listitem">In a<a id="id264" class="indexterm"/> terminal window, navigate to your <code class="literal">nodecheck</code> folder and enter the following command:<div class="informalexample"><pre class="programlisting">
<span class="strong"><strong>$ node main.js</strong></span>
</pre></div><p>In your web browser, every link that was previously using <code class="literal">http</code> will now be using <code class="literal">https</code>. If you add another link and intentionally try to enter the link as <code class="literal">http</code>, the running node service will immediately change it to <code class="literal">https</code>. If you look in the terminal window where you ran the node <code class="literal">main.js</code> command, you'll see the word <span class="strong"><strong>updated</strong></span> for every converted link and your web browser will look something like the following screenshot:</p><div class="mediaobject"><img src="../Images/image00373.jpeg" alt="How to do it…"/></div><p style="clear:both; height: 1em;"> </p></li></ol><div style="height:10px; width: 1px"/></div></div><div class="section" title="How it works…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec184"/>How it works…</h2></div></div></div><p>The <a id="id265" class="indexterm"/>Meteor server is listening for client subscription requests using DDP. Since we are using a DDP <code class="literal">client</code> library built for Node (using the <code class="literal">ddp</code> <code class="literal">npm</code> module), we are able to declare our connection using the new <code class="literal">DDPClient()</code> function, connect and subscribe to the <code class="literal">urls</code> channel, and monitor all messages coming through DDP using the <code class="literal">.on()</code> function:</p><div class="informalexample"><pre class="programlisting">var ddpclient = new DDPClient({
  host: "localhost",
  port: 3000,
  ...
});
ddpclient.connect(function (error) {
  ...
  ddpclient.subscribe('urls', ... );
  ...
});
ddpclient.on('message', function (msg) {
  ...
});</pre></div><p>Finally, if we want to make a modification, we can do so by invoking the Meteor server's remote <code class="literal">methods</code> using the <code class="literal">.call()</code> function:</p><div class="informalexample"><pre class="programlisting">ddpclient.call('updateSRC', ... );</pre></div><p>You'll notice that we had to do nothing on the Meteor server side to get this to work. That's the beauty of DDP; the protocol is the same for any compatible DDP library. As long as both systems are using the DDP protocol, the languages, hardware, and operating systems of the systems are immaterial and don't affect communications between the servers.</p><p>As <a id="id266" class="indexterm"/>you can tell, the DDP protocol is quite powerful because it's simple and clean. There are many other aspects to DDP, for which you will want to consult the Meteor and the corresponding GitHub documentation.</p></div><div class="section" title="There's more…"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec185"/>There's more…</h2></div></div></div><p>You can see a fairly up-to-date list of available DDP clients<a id="id267" class="indexterm"/> by visiting Meteoropedia at <a class="ulink" href="http://www.meteorpedia.com/read/DDP_Clients">http://www.meteorpedia.com/read/DDP_Clients</a>.</p></div><div class="section" title="See also"><div class="titlepage"><div><div><h2 class="title"><a id="ch05lvl2sec186"/>See also</h2></div></div></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <span class="emphasis"><em>Using client-only collections</em></span> and <span class="emphasis"><em>Implementing multiserver DDP</em></span> recipes in this chapter</li></ul></div></div></div></body></html>