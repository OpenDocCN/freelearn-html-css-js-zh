- en: 13\. JavaScript Programming Paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Overview
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to apply different JavaScript paradigms;
    use prototypes, inheritance, and anonymous functions; list different types of
    data scopes and closures; declare variables using hoisting; and explain JavaScript
    memory management.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will dig deep into the core features of JavaScript that
    make it a very diverse and multi-paradigm programming language.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, we know the importance of JavaScript at the browser level and its power
    at the server level. We have learned how to install Node.js on the system and
    how to write and execute code. Also, we have gained a huge amount of knowledge
    about the internal and external modules of Node.js. Moreover, web sockets and
    working with databases were also covered in the previous chapters. We learned
    all of this through interesting activities and exercises. Now it's time to strengthen
    this knowledge and learn about the root concepts of JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will go through the different types of JavaScript programming
    paradigms. During the learning phase of any programming language, people usually
    code in a procedural way; instead of planning, they put most of their focus on
    execution and understanding the concepts of that particular programming language.
    But when it comes to working on real-life problems, the procedural way is not
    a scalable option. Luckily, we have a lot of different types of code implementation
    techniques that we can use to model real-life entities with a programming language,
    such as the **object-oriented programming** paradigm, or **OOP**.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a real-world example in which we have to build a project for our
    college. There will be teachers, clerks, students, heads of departments, and so
    on. One way of implementing this project is to write the logic for each of these
    entities separately, which is not a scalable option, and it will not be a flexible
    solution either. Another way is to use the OOP approach, in which we will create
    one `Person` model that will hold a person's designations as keys in the object.
    This way, we are separating people from their designations. We can easily implement
    changes in either `Person` or entities, that is, heads, teachers, students, and
    so on. All the changes to `Person` will automatically be implemented on entities
    because they belong to the `Person` class. There are a lot of other approaches
    that we can use to solve the same types of problems. We will go through some of
    them in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: After that, you will learn what prototypes are and how to use them to achieve
    inheritance. There are a lot of other basics as well. Let's start.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Paradigms
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A programming paradigm is a way or method in which we write code to solve different
    types of problems. Since there are a lot of ways to code, there are a lot of programming
    paradigms that developers use to write code.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript is a multi-paradigm scripting language, which means that it is very
    dynamic in nature and supports various types of programming styles, such as object-oriented,
    imperative, and functional programming. In this book, we will discuss the three
    main programming paradigms that are popular among developers.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can divide programming paradigms into two categories:'
  prefs: []
  type: TYPE_NORMAL
- en: Imperative, which includes **Procedural Programming** and **OOP**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Declarative, which includes **Functional Programming**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will discuss procedural and object-oriented programming.
    Functional programming is quite popular, and there are a lot of concepts to learn,
    so we have dedicated one chapter, named Functional Programming, to cover that
    topic.
  prefs: []
  type: TYPE_NORMAL
- en: The Procedural Paradigm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, this paradigm follows the procedural pattern. In this
    paradigm, we divide our whole program into routines and subroutines. The process
    flow is very linear and synchronous in this coding pattern. It follows a top-down
    approach to programming. It simply involves breaking down the desired result in
    some routines and smaller subroutines. These subroutines will be further divided
    into processes, which will then be executed to achieve the desired result.
  prefs: []
  type: TYPE_NORMAL
- en: Procedural programming uses a top-down approach to write an application, while
    OOP follows a zigzag approach to the data flow. Reusability is one of the most
    important factors when developing large applications. There is less reusability
    in procedural programming compared with OOP, and that is the reason why the object-oriented
    approach is more popular in scalable applications. When developing programs using
    procedural programming, we might plan out a program without thinking about recycling
    code.
  prefs: []
  type: TYPE_NORMAL
- en: The data flow is sequential in procedural programming, but that doesn't mean
    we do not have to plan the data flow. Planning is still involved in procedural
    programming. It takes a much more literal approach. Procedural programming applications
    are structured more like a story format. The procedural approach makes the development
    process much simpler, but it consumes more time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The pros of adapting to the procedural paradigm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A lot of learning resources can be found online.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It has an easier way to track process flow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The implementation of programs is very easy.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The cons of adapting to the procedural paradigm are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: It is difficult to relate to the real world.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There is less data security.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is difficult to solve complex problems with this approach.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The procedural approach is one of the basic approaches that most people use
    when they start learning code. So, to strengthen our concepts, it's always better
    to practice what we have just learned. Let's do an exercise in which we will implement
    a very basic and simple function using straightforward procedural programming.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.01: Implementing Procedural Programming'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, we have a string and we have to capitalize every word in
    it. As per the procedural approach, we have to implement it in such a way that
    each statement executes in a top-down manner. This means that we will start with
    the first statement and by the last statement, we will have our result. In order
    to do that, we have to perform some operations. Let''s look at them one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's create an empty file and call it `procedural.js`. You can change
    the name if you want.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s write a function called `toCapitalize()`, which will take one argument
    as an input. The input parameter will be of the string type only:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this function, let''s first split the input string using spaces. This
    will divide the input string into words and will return an array of all those
    words:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After this statement, `arrayOfString` will hold an array of words, that is [
    '`Once'`, '`upon'`, '`a'`, '`time'`, '`in'`, '`new'`, '`york'`].
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s loop over the array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this `for` loop, extract the first letter of all the words and save
    the result in a variable:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s make this letter uppercase using the `toUpperCase()` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, remove the first letter of every word from the input string and replace
    it with the one we just made uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s join all the words of the array, including the spaces, to make
    a sentence again and return it as the output of the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we can pass any string to this function and it will return the string with
    all the words with the first letter in uppercase:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s execute this script with Node.js and look at the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.1: Output of the procedural exercise'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_01.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.1: Output of the procedural exercise'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see, we now have our desired output: the first letter of each word
    is uppercase. In the code, we have called a lot of methods, such as `split`, `toUpperCase`,
    `slice`, and `join`. All these functions were called in a top-down manner. We
    started with the first statement of this function, where we had our input string,
    and then we processed the input. After the execution of the last statement of
    this function, we have our desired result. This is a simple example of the implementation
    of procedural programming. Next, we will learn how to implement the object-oriented
    approach in programming.'
  prefs: []
  type: TYPE_NORMAL
- en: The Object-Oriented Paradigm
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object-oriented paradigm is one of the most popular paradigms used by developers.
    A lot of programming languages are oriented to this paradigm. The reason for its
    popularity is its ability to model real-life things in code. In this paradigm,
    we can create objects that will represent entities in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use classes to imitate real-world categories, and then we can create objects
    from those classes, which will act like entities. All classes in JavaScript have
    one constructor function that will execute every time we initiate new instances
    of that object. We use the `Class` keyword to create a class, and `constructor`
    is a default function inside each class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Whatever we are initializing in the `constructor` function will have a scope
    level of this whole class. We can use the `new` keyword to create instances of
    this object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Here, the parameter passed when creating the new instance will get passed straight
    to the `constructor` function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.02: Implementing OOP'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The object-oriented paradigm is the best one to implement because we can relate
    the code to real life. We create classes of real-world entities, such as cars,
    furniture, and electronics, and create instances of those classes to represent
    real-world objects. For example, imagine you have a car from the manufacturer
    Audi. The car is an entity that we can represent as a class in OOP. We can create
    an instance of this `car` class, which will represent your car, and this instance
    will hold information about you, such as that the car's owner is you and the car's
    manufacturer is Audi. Each instance will act as the registration of that vehicle.
    That way, we can create relations between the code and the real world.
  prefs: []
  type: TYPE_NORMAL
- en: The best way to understand this is by taking an example from the real world
    and implementing it. Let's consider a simple program that displays information
    about the living beings on Earth. To do this, we have to make a class of living
    beings and we can create multiple instances of that class, such as `Humans`, `Animals`,
    and `Plants`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To start this off, we have to first create a class of `Humans`. There are a
    lot of things that are common in humans, such as age, weight, height, and skin
    and hair color, but in this case, we are only interested in showing their age,
    name, and gender:'
  prefs: []
  type: TYPE_NORMAL
- en: Let's create an empty file and call it `humans.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s create a class called `Humans` and a `constructor` function, which
    will take `name`, `age`, and `gender` as parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s create one more method inside this class, which will print the values
    of `name`, `age`, and `gender` because only the methods of this class have access
    to class variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'From our `Humans` class, we can now create some instances that represent actual
    humans:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we will print both of these objects. They will contain all the information
    we passed to the constructor when we created them:![Figure 13.2: Output for the
    object-oriented exercise'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '](img/C14377_13_02.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.2: Output for the object-oriented exercise'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we now have two instances of the `Humans` class, each of which
    holds information about a human. We can treat these two instances as real humans.
    They have their own `name`, `age`, and `gender`. This will help you a lot when
    writing code because you know the object you are writing the logic for. Similarly,
    we can implement any real-world entity as a class and can create multiple objects
    of that class, which can represent real-world objects.
  prefs: []
  type: TYPE_NORMAL
- en: So far, we know there are a lot of benefits of using OOP, and some of them are
    very useful. Next, we'll look at two very important features that this paradigm
    provides – encapsulation and inheritance. Let's go through each of them and see
    how we can use these concepts with JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: One benefit of using OOP is that it protects the data in classes. We can add
    data to classes that will only be available for the class' methods. Other classes
    will not be able to access that data. It works as a protective shield for the
    class.
  prefs: []
  type: TYPE_NORMAL
- en: As we saw in the previous example, the scope of the `name`, `age`, and `gender`
    variables was limited to the class. All the methods initialized in the class can
    have access to those variables. This is how we can protect data inside a class.
  prefs: []
  type: TYPE_NORMAL
- en: Inheritance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Inheritance is a way in which one class can have access to the properties of
    another class. In the last example, humans can have a lot of different types of
    professions. So, we can inherit the `Humans` class by professions as well. Let's
    examine this concept by doing an exercise. In the last exercise, we created a
    `Humans` class that holds the name, gender, and age information. We will extend
    this class further by creating a new class called `Teacher`. This class will hold
    all the properties of the `Humans` class along with some additional properties
    describing the subject they teach, grades, and more. This will give you an idea
    of how classes are extended and how parent class properties are inherited by other
    classes. Let's jump into the code now.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.03: Inheritance Implementation Using the extends Keyword'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s create a class called `Teacher` that will inherit the properties of
    the `Humans` class. We will use the `extends` keyword to inherit from classes
    in this exercise:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the `extends` keyword to inherit from the class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside this class, we have to pass all the necessary parameters to the `constructor`
    function. Inside the `constructor` function, we will call the `super` function
    and pass the parameters required for the parent class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, `name`, `age`, and `gender` are parameters of the `Humans` class. Using
    the `super` function, we passed these parameters to the `Humans` class and the
    rest of the variables, that is, `subject` and `grade`, are a part of the `Teacher`
    class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s have an `info` method in the `Teacher` class that will print all the
    variables of that class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After we have finished creating the `Teache`r class, let''s create an instance
    of it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s run this script with Node.js:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 13.3: Teacher instance after inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_03.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.3: Teacher instance after inheritance'
  prefs: []
  type: TYPE_NORMAL
- en: 'As you can see in the output, there are some properties, such as `name`, `age`,
    and `gender`, that are not present in the `Teacher` class. These properties are
    inherited from the `Humans` class, which we implemented in *Exercise 13.02: Implementing
    OOP*.'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to achieve inheritance using JavaScript, we can now create
    multiple objects of the `Teacher` class that will inherit all the properties of
    their parent class, `Humans`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at some of the pros of adopting the object-oriented paradigm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reusability**: We can use already-created classes again and again without
    creating new classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-Life modeling**: We can model a real-world concept using OOP, such as
    a chair, person, or car. This makes understanding the implementation easy.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Parallel development**: Classes can be independent, which means we can develop
    more than one class at a time. This results in quicker project development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Team independency**: As OOP supports parallel development, teams can work
    independently of each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secured development**: OOP features, such as inheritance and encapsulation,
    hide data from other classes, thereby improving security. The internal data of
    a class can''t be accessed by external functions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The possible cons of using the object-oriented paradigm:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unnecessary code:** It can create an enormous amount of unnecessary and bloated
    code if it''s not implemented with proper planning.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Duplication**: As OOP can be implemented for each individual class, it can
    lead to code duplication.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Early planning**: Programmers should have a proper plan before designing
    a program.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project size**: Projects developed with OOP are often larger than projects
    developed with other approaches, such as the procedural paradigm.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we have learned about different types of programming paradigms
    we can use with JavaScript. We dug deep into two of the most popular paradigms
    – procedural and object-oriented. We went through different pros and cons of both
    paradigms. We also learned about two of the most important features of OOP, which
    are encapsulation and inheritance.
  prefs: []
  type: TYPE_NORMAL
- en: Basic JavaScript Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Programming paradigms are important, but to understand them in detail, we need
    a basic understanding of different JavaScript concepts. So, let's go through some
    of the core concepts of JavaScript, which will help you get a grasp of JavaScript
    and give you a better understanding of how we can use programming paradigms to
    build scalable solutions to problems.
  prefs: []
  type: TYPE_NORMAL
- en: Prototypes and Prototypical Inheritance
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Objects are very important because they help us manipulate JavaScript to achieve
    the functionality we want. There are a lot of ways to create objects in JavaScript.
    One of the ways is by using a `constructor` function, and whenever we create a
    function, the JavaScript engine adds a `prototype` property to the function. This
    `prototype` property is an object that has a `constructor` property by default.
    This constructor points back to the parent functions. You can see this function
    by calling `functionName.prototype`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s check its `prototype` property by entering `PersonName.prototype`.The
    output will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.4: Prototype property of objects'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_04.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.4: Prototype property of objects'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, we have created a function named `Person` and JavaScript automatically
    binds a `prototype` property to it. You can print the `prototype` and you can
    see that there is a `constructor` property, which holds all the metadata of the
    parent function.
  prefs: []
  type: TYPE_NORMAL
- en: What Is Prototypical Inheritance?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As we know, everything in JavaScript is an object. Every string, integer, array,
    object, and function that you define is an object of its respective parent class.
    Each object in JavaScript holds a `proto` property (`__proto__` keys inside child
    objects are usually referred to as `proto` properties) that holds all the properties
    of its parent class. We can use these `proto` properties to implement inheritance.
    These `prototype` objects act as template objects from which all the child objects
    will inherit methods and properties. We can also override the properties of a
    parent class using this `prototype` property. This linking of prototypes is referred
    to as a prototype chain.
  prefs: []
  type: TYPE_NORMAL
- en: 'Exercise 13.04: Prototypical Inheritance Implementation'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this exercise, let''s implement a very simple function that will take a
    first name and a last name as parameters and return the full name. After this
    exercise, you should be completely clear on how prototypical inheritance works
    and the differences between the two approaches to achieve this output:'
  prefs: []
  type: TYPE_NORMAL
- en: We can implement `firstName` and `lastName` child functions inside the `PersonName`
    parent function that will have the scope to use the values of the parent function.
    We can bind the functions to their parent's prototype because the parent function
    can always access the scope of a child function. Let's implement and observe both
    approaches. Open the Google Chrome Developer Tools console using the `F12` key.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Use this constructor function to create some objects and paste the code in
    the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Whenever we use a `constructor` function to create objects, JavaScript adds
    a property to its object, which is `_proto_`. This `_proto_` property holds the
    link to the prototype of the main function, which can be seen in the following
    output:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.5: Prototype property of instances created with the new keyword'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '](img/C14377_13_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Figure 13.5: Prototype property of instances created with the new keyword'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: As you can see here, the `pName1` object has a `__proto__` property that directly
    points to the prototype of its parent, `PersonName.prototype`. In the next step,
    we can use this `prototype` property to achieve inheritance using JavaScript.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Let''s bind the `fullName` function with the `prototype` property of `Person`
    instead of defining it inside the function:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, create two objects of the `PersonName` method using the `new` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'All the objects created here with the `new` keyword will now contain a `proto`
    property, which will point to its parent prototype, and all the functions and
    properties defined in the parent prototype will be accessible to all its child
    objects. In other words, if we create a function and bind it to the prototype
    of the parent function, that function will be accessible to all its objects using
    the prototype chain object. Now, call the `fullName` function, which is defined
    in the `prototype` property of the `Person` method, using its objects:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output is as follows:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 13.6: Example of a prototype chain'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_06.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.6: Example of a prototype chain'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this exercise, we declare a constructor function (`PersonName`), then we
    create a function (`fullName`) and bind it to its prototype. Then, we create two
    child objects using the function''s constructor. You can see that both of these
    objects have access to the `fullName` function, which is in their parent''s prototype.
    This way, we have achieved inheritance using a prototype chain, as visualized
    in *Figure 13.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.7: References of the __proto__ property'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_07.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.7: References of the __proto__ property'
  prefs: []
  type: TYPE_NORMAL
- en: Now we can create as many instances of `PersonName` as we want, and all those
    instances will always have access to `PersonName.fullName`.
  prefs: []
  type: TYPE_NORMAL
- en: We can even modify the prototypes and the changes will be reflected in all of
    its child objects instantaneously.
  prefs: []
  type: TYPE_NORMAL
- en: Anonymous Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Objects in the JavaScript language are very tricky. Everything in JavaScript
    is an object. So, functions in JavaScript are considered functional objects and
    can be used in the same way as we use objects. Functions in JavaScript can be
    passed as arguments to other functions as well. Any function that also returns
    a function is called a function factory. Let''s have a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'In this example, we have called a function, `calculateSum`, and passed two
    parameters to it. One is a number and the other one is a function. This function
    will return a new function, which will display the passed function followed by
    the result, as can be seen in the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.8: Examples of anonymous functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_08.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.8: Examples of anonymous functions'
  prefs: []
  type: TYPE_NORMAL
- en: In the example, you can see we have used a lot of functions without naming them.
    These functions are very important in JavaScript. A function declared with no
    particular name is called an anonymous function. We use anonymous functions a
    lot when programming in JavaScript. These types of functions are declared dynamically
    at runtime and can be passed as parameters to other functions. For example, `Function
    () {}` is a typical example of an anonymous function. You can assign the return
    value of this function to any variable. Creating functions with this approach
    allows us to create functions on the go. Anonymous functions are mainly used in
    callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: The Differences between Named Functions and Anonymous Functions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The major difference between named and anonymous functions is that when you
    declare a named function, the compiler allocates a stored memory block to that
    function. So, if you have to call it, you can use the name to call it. But with
    anonymous functions, the memory block is assigned to them and the address is returned,
    which we can then store in a variable. This helps us initialize functions in places
    where we can''t declare named functions. We can even change the name with which
    we can call this function by assigning the function to another variable. This
    can be visualized in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.9: Named versus anonymous functions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_09.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.9: Named versus anonymous functions'
  prefs: []
  type: TYPE_NORMAL
- en: Data Scope
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data scoping determines the accessibility of variables, functions, and objects
    in your code during runtime. This means the scope of a variable is controlled
    by the location of the variable declaration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In JavaScript, there are two main types of scopes:'
  prefs: []
  type: TYPE_NORMAL
- en: Global scope
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Local scope, which includes **function level** and **block level**
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Global Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Every JavaScript application has a global scope in which we can define anything
    that all the functions in our application can access. All the variables defined
    outside the functions, blocks, and modules have a global scope. Global variables
    are available for the lifetime of the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way of creating global variables is to use predefined global variables
    such as `process` (in Node.js) and `window` (in browsers). You can bind any value
    to these already defined global variables, and you can access them from anywhere
    inside the application. For example, let''s add the `NODE_VERSION` value to the
    `env` property of `process`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The `process` variable has a global scope during the execution of the program.
    Now, we can access the value that we''ve set (`NODE_VERSION = 10.08`) anywhere
    in our program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Local Scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Variables defined within a function or a block are in a local scope. Only those
    functions that are defined inside that function or block can have access to those
    variables.
  prefs: []
  type: TYPE_NORMAL
- en: Function-Level Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In JavaScript, each function has its own scope. All the variables and functions
    defined inside that function will have access to only each other:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, both functions have different levels of scope. `Function B` can''t access
    the variables defined in `Function A`. The scope of both functions is highlighted
    in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.10: Example of function-level scope'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_10.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.10: Example of function-level scope'
  prefs: []
  type: TYPE_NORMAL
- en: Block-Level Scope
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Block-level scope is similar to function-level scope, but in this type of scope
    we do not initialize any functions. We can separate the scope of variables by
    creating blocks in JavaScript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: We use curly braces to create blocks in JavaScript. The second block can't access
    any variables created in the first block.
  prefs: []
  type: TYPE_NORMAL
- en: Hoisting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We now know that the scope of variables and functions depends on where they
    are declared, but there is an interesting concept in JavaScript, which is called
    **hoisting**. Hoisting is a feature in which the interpreter moves the declarations
    of functions and variables to the top of their scope. This means that variable
    declarations are processed before any code is executed. When any scope is processed,
    first, the whole scope is searched for variable and function declarations. Then,
    the memory space is allocated for each of the variables and functions. After this,
    the body of the function or block is executed line by line.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Hoisting only moves the declaration of the variables and functions, not the
    assignment. The assignment stays in the same position.
  prefs: []
  type: TYPE_NORMAL
- en: 'Functions are hoisted first followed by the variables. So, it is a good practice
    to always first declare functions and then work on the implementation part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Here, both of the blocks will return `undefined`. The output of both blocks
    is the same. The position of the declaration doesn't matter inside a block. The
    first block will not throw any errors relating to variables not being defined.
  prefs: []
  type: TYPE_NORMAL
- en: The Difference between var and let
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the case of `var`, after creating variable definitions, each of the variables
    is initialized with an undefined value, but in the case of `let`/`const`, the
    initialization to undefined does not happen until the line of the declaration.
    In the following code, the variable is in the Temporal Dead Zone and accessing
    it results in a reference error:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s execute this and see the difference by observing the different outputs
    of `var` and `let`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.11: let keyword usage'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_11.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.11: let keyword usage'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the preceding figure, you can see that if we use `let`, it throws a reference
    error. Let''s look at the output using the `var` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.12: var keyword usage'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_12.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.12: var keyword usage'
  prefs: []
  type: TYPE_NORMAL
- en: We see that using the `var` keyword gives the same undefined output for both
    blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Closures
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A closure is a feature in JavaScript where a function defined inside another
    function has access to the parent function''s variables. A closure has three scope
    chains:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Own scope : Variables defined between its curly brackets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Parent function: Properties defined in the parent function'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Global variables: Properties defined in the global scope'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s have a look at an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'We have one main function, which is `outer`. Then, we have declared a `count`
    variable with a value of `1`. We have one more function, `inner`, which is using
    and incrementing the value of `count`. Then, we return the `inner` function. The
    output of the preceding code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.13: Example of closures'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_13.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.13: Example of closures'
  prefs: []
  type: TYPE_NORMAL
- en: When we first call the `outer('A') function`, we are creating a scope for the
    `count` variable and the `inner` function. Then, we return the `inner` function
    and save its address in `funA()`. We did the same with `funB()`.
  prefs: []
  type: TYPE_NORMAL
- en: When we called `funA()` first, it had access to the `count` variable because
    it was in its parent function. So, it printed the value of `count` and updated
    it by adding `1`. When we called it again, it again accessed the parent scope
    and got the updated value of `count`. JavaScript is able to achieve this because
    of closures.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have learned about a lot of the basic features of JavaScript.
    We started with prototypes and used them to implement inheritance. Then, we learned
    about anonymous and named functions and how to use them. We also learned about
    different types of data scopes in JavaScript. Finally, we learned about hoisting
    and closures, which are among the most complicated and important features provided
    by JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: JavaScript Memory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In other technical languages, such as C and C++, memory allocation and deallocation
    is an additional task. We have to use the `malloc()` and `free()` functions in
    C to allocate and deallocate memory for our variables. Thankfully, we do not have
    to take care of memory allocation in JavaScript anymore. JavaScript has a garbage
    collector built into it. JavaScript automatically allocates and frees up memory
    when objects are created and destroyed.
  prefs: []
  type: TYPE_NORMAL
- en: Memory Life Cycle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The memory life cycle of most programming languages is the same. It doesn''t
    matter which language you are using, whether JavaScript, Python, or Java, the
    allocation and deallocation of memory is almost the same. They all follow three
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocate the memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the allocated memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Free the allocated memory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The first and last parts are explicit in low-level languages, which means developers
    have to write code for the allocation and deallocation of memory, but it is mostly
    implicit in high-level languages such as JavaScript. During the compilation of
    your code, the compiler examines all primitive data types used in the code and
    calculates how much memory your program will take. It then allocates the required
    memory to the program in the call stack space. This process of the allocation
    of memory is called static memory allocation. During runtime, the memory allocation
    works in a LIFO (last-in, first-out) manner, which means as functions are called
    and terminated, their memory is added on top of the existing memory and is removed
    in a LIFO order.
  prefs: []
  type: TYPE_NORMAL
- en: Static versus Dynamic Allocation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two types of memory allocation, static and dynamic. Static allocation
    is performed at compile time only. When we compile our code, the compiler figures
    out all the static variables and assigns them memory at that time. Here''s an
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Dynamic allocation, as the name suggests, is done at runtime only because sometimes
    we do not know the exact size of the data, for example, when assigning the response
    of an API to a variable. In this case, we do not know exactly what the API will
    send us, so the memory will be allocated during runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we can't predict the size of the JSON object in advance, so
    this variable will be allocated dynamically. Some of the main differences between
    static and dynamic memory allocation are detailed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the features of static memory allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocates during compile time
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses stack storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good to use when the required amount of memory is known
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses LIFO (Last In, First Out)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Faster execution than a dynamic allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More efficient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Higher performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the features of dynamic memory allocation:'
  prefs: []
  type: TYPE_NORMAL
- en: Allocates during runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Uses heap storage
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Good to use when the required amount of memory is unknown
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: No order of assignment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slower execution than a static allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Less efficient than a static allocation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Slower performance because of memory allocation at runtime
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Releasing Memory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most difficult task is to discern situations when the allocated memory is
    no longer required. JavaScript's garbage collector comes in handy when it comes
    to finding and clearing out unused memory.
  prefs: []
  type: TYPE_NORMAL
- en: Reference-Counting Garbage Collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One way of finding usable variables is by finding their references. If any variable
    has more than one reference, it means that it is possible to use this variable.
    But if we remove all the references to any variable, it becomes useless and it
    will be garbage collected by JavaScript in the next cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a nested object, `obj`. It has a property called `a`, and
    another property, `b`. Now, `obj` is referencing `a` and `a` is referencing `b`.
    The only way to access `b` is through `a`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'If we change the reference of `a` to `b`, then `b` will be garbage collected:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Now, as there is no reference to `b`, the garbage collector will delete it and
    free the memory.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned about how JavaScript automatically manages memory
    and does memory management for us. We learned about static and heap storage devices
    and had an overview of how the garbage collector in JavaScript works. We went
    through reference garbage collection as one of the many ways a garbage collector
    uses to find and clear unused memory in JavaScript programs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Activity 13.01: Creating a Calculator App'
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this chapter, we have learned about different types of paradigms that we
    can use when programming with JavaScript. Now it's time to sharpen our knowledge
    of these paradigms and make sure we know the difference between them when implementing
    paradigms in the real world.
  prefs: []
  type: TYPE_NORMAL
- en: Let's build a simple calculator application using both a procedural and object-oriented
    approach, which will give us a clear example of implementing the solution to a
    problem with different paradigms.
  prefs: []
  type: TYPE_NORMAL
- en: 'The high-level steps for the activity are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create an empty file and call it `procedural.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize an array that will maintain the history of function calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create simple `addition`, `subtraction`, `multiplication`, `division`, and `power`
    functions.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `history` function that will maintain the history of function calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call all the functions one by one with some random numbers as parameters.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now print the history to check the output.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, build the app using OOP. Create a class and call it `calculator`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Initialize a `historyList` array, which will maintain the history of all function
    calls.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create simple `add`, `subtract`, `multiply`, `divide`, and `pow` methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add one more method, which will show the history of the operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an instance of this class and call its method with simple numbers to
    perform mathematical operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the `history` method of the `calculator` class to check the history.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Using both a procedural and an object-oriented approach, the output of this
    code will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 13.14: The same output using the procedural and the object-oriented
    approach'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/C14377_13_14.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Figure 13.14: The same output using the procedural and the object-oriented
    approach'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The solution to this activity can be found on page 754.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that, the outputs of both scripts are exactly the same, but the
    way we implemented them is completely different. This implementation tells us
    that there is more than one way to solve a problem. The best way depends on a
    lot of factors, such as team size, project plans, expectations of the project,
    and others. So, finally, we have achieved the same solution to the same problem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in this book, we have covered client-side and server-side JavaScript
    execution. You learned about the importance of scope in JavaScript, along with
    the basics necessary for a solid foundation in JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we learned about different programming paradigms. We discussed
    two of the popular approaches used by developers, namely procedural and object-oriented.
    Then, we explored the uses of prototypes, data scopes, hoisting, and closures.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s dig deep into the final and most important programming paradigm,
    which is used by a lot of developers: functional programming. In the next chapter,
    we will learn a lot about functional programming, including how and when to use
    it.'
  prefs: []
  type: TYPE_NORMAL
