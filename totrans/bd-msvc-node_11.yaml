- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Caching and Asynchronous Messaging in Microservices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with microservices architecture and Node.js, you need to master
    caching and asynchronous messaging to build the next generation of successful
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll start this chapter by understanding better how to work with caching and
    asynchronous messaging in microservices with Node.js. Caching and asynchronous
    messaging are two important techniques used in microservices architecture to improve
    performance, scalability, and decoupling. Caching involves storing frequently
    accessed data in a cache to improve response times and reduce the load on the
    underlying data sources. Asynchronous messaging enables loose coupling and scalability
    in microservices by decoupling services through message queues or publish-subscribe
    patterns.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have learned how to work with caching and
    asynchronous messaging in Node.js.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side caching and edge caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Microservice-level caching and database query caching
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Message queues and publish-subscribe
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Event-driven architecture
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Client-side caching and edge caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’re going to show you how to work with client-side caching
    and edge caching. Client-side caching and edge caching are strategies used to
    improve performance and reduce the load on servers by storing and serving content
    closer to the user.
  prefs: []
  type: TYPE_NORMAL
- en: Client-side caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Client-side caching** involves storing resources (e.g., HTML pages, stylesheets,
    scripts, images) on the client device (such as a web browser) to avoid repeated
    requests to the server.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of its advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Client-side caching reduces server load by serving cached content directly from
    the client. This means that client-side caching can improve the performance and
    efficiency of both the web server and the web browser. By serving cached content
    directly from the client, the web server does not have to process and send the
    same data repeatedly to the same or different users. This reduces the server load,
    meaning the amount of work or requests that the server has to handle at any given
    time.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It improves page load times for subsequent visits. This means that client-side
    caching can enhance the user experience by making the web pages load faster when
    the user visits them again. By storing a copy of a web page in the browser memory,
    the browser does not have to request and download the same web page again from
    the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enhances user experience by minimizing network requests. This means that
    client-side caching can reduce the number and size of network requests that the
    browser has to make to the server. Network requests are the messages that the
    browser and the server exchange to communicate and transfer data. Network requests
    can take time and consume bandwidth, depending on the distance, speed, and quality
    of the connection. By minimizing network requests, client-side caching can save
    time and bandwidth as well as avoid potential errors or delays that might occur
    during communication.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An API contract outlines the rules and specifications for how services should
    interact. In the context of client-side caching, an API contract can outline the
    rules and specifications for how services should interact with the cached data
    stored on the client’s device, such as the browser.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The caching behavior is controlled by HTTP headers, such as **Cache-Control**
    and **Expires**. This means that client-side caching can be configured and customized
    by using certain HTTP headers that specify for how long and under what conditions
    the data can be cached. HTTP headers are the metadata that accompany the HTTP
    requests and responses between the client and the server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 11**.1* illustrates client-side caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1: Client-side caching](img/B14980_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.1: Client-side caching'
  prefs: []
  type: TYPE_NORMAL
- en: We have learned the basics of client-side caching; now, let’s move on to edge
    caching.
  prefs: []
  type: TYPE_NORMAL
- en: Edge caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Edge caching**, or **content delivery network** (**CDN**) caching, involves
    caching content on servers strategically positioned at the edge of the network
    (closer to users) to reduce latency and improve content delivery speed.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of its advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: Edge caching minimizes latency by serving content from servers closer to the
    user. This means that edge caching can reduce the time it takes for the data to
    travel from the server to the user. **Latency** is the delay or lag that occurs
    when data is transferred over a network. Latency can affect the performance and
    user experience of web applications, especially for dynamic or interactive content.
    By serving content from servers closer to the user, edge caching can minimize
    latency and improve the speed and responsiveness of web applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It distributes content globally, reducing the load on the origin server. This
    means that edge caching can improve the scalability and reliability of the web
    application by spreading the data across multiple servers around the world. This
    reduces the load on the origin server, meaning the main server that hosts the
    original data and application logic.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It enhances scalability and reliability. This means that edge caching can improve
    the ability of the web application to handle more traffic and requests without
    compromising the quality and availability of the service. By distributing the
    data across multiple servers around the world, edge caching can reduce the dependency
    and load on the central server, which might have limited resources and capacity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: CDN providers deploy servers worldwide, and content is cached on these servers
    for quick retrieval. This means that edge caching is often implemented by using
    a CDN, which is a network of servers distributed across the globe that can store
    and deliver data to users. A CDN provider is a company that offers CDN services
    to web applications and websites. By using a CDN provider, web applications and
    websites can cache their data on the CDN servers, which are closer to the users
    than the original server. This way, when a user requests the data, it can be retrieved
    quickly from the CDN server, rather than from the original server.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remember, it is important to apply the caching strategies while working with
    microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, client-side caching and edge caching are powerful techniques for
    optimizing web performance, reducing server loads, and enhancing the overall user
    experience. Understanding cache control headers, cache invalidation strategies,
    and leveraging CDNs is crucial for effective implementation.
  prefs: []
  type: TYPE_NORMAL
- en: With the understanding of these concepts, let’s now move on to microservice-level
    caching and database query caching.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice-level caching and database query caching
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Microservice-level aching and database query caching are strategies employed
    to enhance the performance and scalability of microservices by reducing the need
    for repeated computations and database queries.
  prefs: []
  type: TYPE_NORMAL
- en: Microservice-level caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Microservice-level caching** involves storing and retrieving frequently accessed
    data within individual microservices to avoid redundant computations or external
    calls. Each microservice maintains its own cache, and caching decisions are made
    within the microservice boundaries.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Caching can allow microservices to improve fault tolerance, which is the ability
    of a system to continue functioning despite failures or errors. Caching can act
    as a buffer during temporary service outages or network issues, which can affect
    the availability and performance of microservices. Caching can help microservices
    to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: It can reduce the dependency on external services or databases that might be
    slow, unreliable, or unavailable due to network problems or maintenance. By storing
    the data in a cache, microservices can avoid making unnecessary or repeated requests
    to the original data source and instead serve the data from the cache.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can handle spikes in traffic or demand that might overload the system or
    cause bottlenecks. By storing the data in a cache, microservices can reduce the
    load on the system and improve the response time and throughput of the system.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can recover from failures or errors that might cause data loss or corruption.
    By storing the data in a cache, microservices can preserve the data and restore
    it from the cache if the original data source is compromised or damaged.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of its use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Caching results of computationally expensive operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Storing frequently accessed static data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reducing the load on downstream microservices or databases.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some key considerations for microservice-level caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Granularity**: Determine the appropriate granularity for caching whether
    it’s at the level of individual API endpoints, specific operations, or entire
    datasets.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache invalidation**: Implement strategies to invalidate or update the cache
    when underlying data changes to ensure consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache eviction**: Define policies for removing stale or less frequently used
    items from the cache to manage memory efficiently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Time-to-live** (**TTL**): Set time-to-live values for cached items to control
    how long they are considered valid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the benefits of microservice-level caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Improved performance**: It reduces response times by serving cached data
    locally without making redundant calls to downstream services or databases.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Increased scalability**: It reduces the load on backend services, enhancing
    overall system scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Resilience**: It provides a level of resilience by allowing microservices
    to continue functioning even when downstream services are temporarily unavailable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we have learned some of the concepts, use cases, and key considerations
    of microservice-level caching.
  prefs: []
  type: TYPE_NORMAL
- en: With these concepts learned, we can continue with database query caching.
  prefs: []
  type: TYPE_NORMAL
- en: Database query caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Database query caching** is a technique that stores the results of frequently
    executed queries in a temporary memory, called a cache, for faster access. When
    a query is requested, the database first checks whether the query result is already
    in the cache. If it is, the database returns the cached result without having
    to execute the query again. Database query caching can improve the performance
    and efficiency of the database by reducing the workload and response time of the
    database.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of its use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: Caching the results of read-heavy queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoiding redundant database access for static or slowly changing data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Offloading the database by serving cached results for common queries.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some key considerations for database query caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Query identifiers**: Use unique identifiers for queries to manage and reference
    cached results effectively.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cache invalidation**: Implement strategies to invalidate the cache when underlying
    data changes to maintain data consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Query complexity**: Consider the complexity and cost of queries when deciding
    which ones to cache.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are the benefits of database query caching:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Reduced database load**: Caching query results reduces the need for repeated,
    resource-intensive database access.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lower latency**: It improves response times by serving cached results instead
    of re-executing queries against the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Improved scalability**: It enhances the scalability of the overall system
    by reducing the load on the database.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, microservice-level caching and database query caching are essential
    techniques for optimizing microservices architectures. By strategically caching
    data at both the microservice and database layers, organizations can achieve improved
    performance, scalability, and responsiveness in their distributed systems.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can continue to the next section, in which we will talk about message
    queues and publish-subscribe.
  prefs: []
  type: TYPE_NORMAL
- en: Message queues and publish-subscribe
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Message queues and publish-subscribe (Pub/Sub) are communication patterns commonly
    used in microservices architectures to facilitate asynchronous communication between
    services.
  prefs: []
  type: TYPE_NORMAL
- en: Message queues
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **message queue** is a communication mechanism that allows microservices to
    send and receive messages asynchronously. Messages are placed in a queue by the
    sender and processed by the receiver.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of its use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Task distribution**: A web application that processes user-uploaded files.
    Each file processing task is placed in a message queue, and multiple worker processes
    consume tasks from the queue to handle file processing concurrently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event sourcing**: A system that maintains a log of events to capture changes
    in state. Events are published to a message queue, and various microservices subscribe
    to these events to update their own state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microservices communication**: A system with multiple microservices where
    one microservice generates an event (e.g., user registration) and publishes it
    to a message queue. Other microservices interested in this event can subscribe
    to the queue to perform related actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load leveling**: A system with a peak load of requests. Instead of overwhelming
    a service, incoming requests are placed in a message queue. Workers consume requests
    from the queue, allowing the system to handle peaks more gracefully.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: A system where certain components have varying processing
    loads. By using a message queue, these components can scale independently based
    on their own demand, ensuring efficient resource utilization.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Background processing**: An e-commerce platform that sends order confirmation
    emails. Instead of sending emails synchronously during the checkout process, the
    system places email tasks in a message queue, and a separate service process and
    sends the emails.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-application integration**: A company using multiple software applications
    (e.g., CRM, ERP). Integrating these applications can be achieved by placing messages
    in a queue when specific events occur in one application, triggering actions in
    another application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workflow orchestration**: An order processing system where each step (e.g.,
    order validation, payment processing, shipping) is a separate task. Each step
    publishes a message to a queue upon completion, triggering the next step in the
    workflow.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Delayed or scheduled tasks**: A system that allows users to schedule emails
    to be sent at a later time. The email content and recipient details are placed
    in a message queue with a scheduled delivery time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log and event aggregation**: Distributed applications generate logs and events.
    Instead of relying on individual logs, events are sent to a message queue and
    a centralized logging service consumes and aggregates them for analysis.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of its key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Queue**: A storage mechanism where messages are temporarily held until they
    are consumed by a service.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Producer**: A microservice responsible for sending messages to the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Consumer**: A microservice that retrieves and processes messages from the
    queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of its advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoupling**: It allows services to be decoupled, as the sender and receiver
    are not directly dependent on each other.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronous processing**: It enables asynchronous communication, which can
    improve system responsiveness and scalability.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Load balancing**: It distributes the processing load by allowing multiple
    instances of a service to consume messages from the queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Figure 11**.2* illustrates message queues:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2: Message queues](img/B14980_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 11.2: Message queues'
  prefs: []
  type: TYPE_NORMAL
- en: Having these concepts in mind can help create a better architecture for message
    queues.
  prefs: []
  type: TYPE_NORMAL
- en: We can continue now with publish-subscribe.
  prefs: []
  type: TYPE_NORMAL
- en: Publish-subscribe (Pub/Sub)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Pub/Sub** is a messaging pattern where a microservice (the publisher) broadcasts
    messages to multiple subscribers. Subscribers express interest in certain types
    of messages and receive relevant notifications.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some of its use cases:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Real-time updates**: A social media platform notifying users about new posts,
    comments, or likes in real-time.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event notification**: A payment gateway notifying multiple services about
    a successful payment transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distributed systems coordination**: A microservices architecture where changes
    in user authentication trigger updates in various services, such as user profiles,
    permissions, and analytics.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-cutting concerns**: Publishing events related to system logs, errors,
    or performance metrics, allowing multiple services to subscribe and react accordingly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workflow orchestration**: The orchestration of a series of tasks or processes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cross-application integration**: An ecosystem of applications (CRM, ERP,
    Analytics) where changes in one application trigger actions in others, ensuring
    data consistency.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**IoT device communication**: Smart home devices publishing events related
    to status changes (e.g., temperature, motion detection) and multiple applications
    subscribing to these events for automation or monitoring'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**User notifications**: A messaging application publishing events for new messages,
    and different clients (web, mobile, desktop) subscribing to receive real-time
    notifications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log aggregation and analytics**: Services publishing events related to user
    interactions, and an analytics service subscribing to these events for centralized
    analysis and reporting.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Multi-tenant systems**: A **software as a service** (**SaaS**) platform where
    different organizations subscribe to events related to their specific data or
    customizations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Chat applications**: Users subscribing to chat channels or rooms, and messages
    being published to the relevant channels for real-time delivery.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dynamic configuration updates**: Services subscribing to configuration change
    events, ensuring that they dynamically adjust their behavior based on changes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here are some of its key components:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Publisher**: A microservice responsible for broadcasting messages to the
    system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Topic**: Logical channels or categories to which messages are published.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Subscriber**: A microservice that expresses interest in specific topics and
    receives relevant messages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of its advantages:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Scalability**: It is well-suited for scenarios where multiple services need
    to react to the same event or type of information.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: It allows services to subscribe to specific topics of interest,
    receiving only the messages they need.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven architecture**: It supports the creation of event-driven systems
    where services can react to changes in state.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You need to learn these concepts fast in order to keep updated with the latest
    patterns in microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, message queues and Pub/Sub patterns are fundamental to building
    resilient, scalable, and loosely coupled microservices architectures. The choice
    between them depends on the specific requirements of the system and the desired
    communication patterns between services.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn about event-driven architecture.
  prefs: []
  type: TYPE_NORMAL
- en: Event-driven architecture
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Event-driven architecture** (**EDA**) is a design paradigm that emphasizes
    the production, detection, consumption, and reaction to events in a system. In
    the context of microservices, event-driven architecture provides a flexible and
    scalable approach to handle communication and coordination between services.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is the use case of event-driven architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Event sourcing**: Storing changes to the state of an application as a sequence
    of events. This helps in reconstructing the current state and auditing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Real-time updates**: Broadcasting real-time updates to multiple services
    or clients in response to certain events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Workflow orchestration**: Coordinating the execution of business processes
    across multiple microservices.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Log and monitoring events**: Capturing events related to system logs, errors,
    or performance metrics for monitoring purposes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are its key concepts:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Events**: Events represent occurrences or state changes in a system. Examples
    include user actions, system alerts, or changes in data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event producer**: Microservices that generate and emit events are known as
    event producers. They publish events to a message broker or event bus.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event consumer**: Microservices that subscribe to and process events are
    event consumers. They react to events based on predefined logic.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event bus or message broker**: This acts as a communication channel that
    facilitates the distribution of events from producers to consumers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are the advantages of event-driven architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Decoupling**: Microservices become loosely coupled as they communicate through
    events. This reduces dependencies between services.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scalability**: It allows for easy scalability, as services can be added or
    removed without affecting the entire system.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Flexibility**: It supports flexibility in system design, as services can
    be added or modified independently.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asynchronicity**: It enables asynchronous communication between services,
    promoting responsiveness and agility.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here is the implementation of event-driven architecture:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Message brokers**: Systems often use message brokers such as **Kafka**, **RabbitMQ**,
    or **Apache Pulsar** as the underlying infrastructure to manage the flow of events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event schema**: Defining a clear schema for events helps to ensure consistency
    and understanding between producers and consumers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event handlers**: Microservices have event handlers that subscribe to specific
    types of events and execute predefined logic in response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Event-driven microservices**: Each microservice in the system can act as
    both a producer and a consumer of events, interacting with other services based
    on events.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In summary, event-driven architecture is a powerful paradigm for building resilient
    and scalable microservices systems. It enables a more responsive and adaptable
    architecture by fostering loose coupling between microservices, allowing them
    to evolve independently. Properly implemented, EDA contributes to a more agile
    and efficient microservices ecosystem.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have learned a lot about microservices, how to deal with
    caching, and the different types of caching.
  prefs: []
  type: TYPE_NORMAL
- en: In summary, caching and asynchronous messaging are two techniques that can improve
    the performance, scalability, and reliability of microservice-based applications.
    Caching is the process of storing frequently accessed or expensive data in a temporary
    storage area, such as **Redis**, to reduce the latency and the load on the primary
    data source. Asynchronous messaging is the process of exchanging data between
    microservices or clients in a non-blocking and event-driven manner, using a message
    broker such as **Amazon SQS** or **Amazon SNS**. Caching and asynchronous messaging
    can help to overcome some of the challenges of microservices, such as complexity,
    eventual consistency, and network failures. However, they also require careful
    design and trade-offs, such as data freshness, data synchronization, and message
    ordering.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we are going to learn about ensuring data security with
    the saga pattern, encryption, and security measures.
  prefs: []
  type: TYPE_NORMAL
- en: Quiz time
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is client-side caching and edge caching?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is microservice-level caching?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What are message queues and publish-subscribe?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What is event-driven architecture?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
