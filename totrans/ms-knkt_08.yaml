- en: Chapter 8. Plugins and Other Knockout Libraries
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A big part of effectively working in any area of software is to be familiar
    with the tools used by the community. It is often better to rely on existing libraries
    and plugins that have been used and tested in the real world than try to reinvent
    the wheel on each new project. In this chapter, we will be looking at some of
    the most popular Knockout plugins:'
  prefs: []
  type: TYPE_NORMAL
- en: Knockout Validation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knockout Mapping
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knockout Kendo
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: KoGrid
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knockout Bootstrap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knockout Switch-Case
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knockout Projections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knockout-ES5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Knockout Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The validation of user input is a common enough task that nearly every web application
    will have at least some need for. By far the most popular Knockout plugin, with
    50 percent more stars on GitHub than the next Knockout related project, Knockout
    Validation creates several extenders and binding handlers that are designed to
    simplify HTML form validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The use of the plugin starts with extenders that apply validation logic to
    observables without replacing them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Binding against validation-extended values is done with the normal `value`
    binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Knockout Validation modifies the standard value and checked bindings so that
    they display invalid value warnings. The default display behavior will place a
    span element that contains any errors after the value-bound input element. The
    error message `span` will be hidden when the value is valid and contain the error
    message text when invalid.
  prefs: []
  type: TYPE_NORMAL
- en: This automatic error insertion can be disabled if you want to manually place
    the validation message in the view. To do this, use the `validationMessage` binding,
    which has the same behavior as the inserted span.
  prefs: []
  type: TYPE_NORMAL
- en: Default validation rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Knockout Validation provides several validation extenders by default, which
    it calls **rules**. Like normal extenders, multiple validation rules can be passed
    in order to extend in a single call, or they can be chained:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The default rules cover most of the standard cases for checking values, including—but
    not limited to—numerical min and max, string length min and max, regex patterns,
    dates, and value equality.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring validation options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Knockout Validation''s behavior is very configurable. Some of the more useful
    options include:'
  prefs: []
  type: TYPE_NORMAL
- en: '`insertMessages` (default: `true`): If true, a `span` will be inserted after
    an input that is bound to a validated observable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`errorElementClass` (default: `validationElement`): This is a class that is
    applied to elements when validated observables are invalid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messagesOnModified` (default: `true`): If true, validation messages will not
    get displayed until the validated value has been modified so that they are hidden
    until a user interacts with the form.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`messageTemplate` (default: `null`): This is an ID of a script element that
    will be used as the validation message template instead of inserting the message
    into a span.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configuration options can be set globally by passing an object to `ko.validation.init`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Options can also be set contextually using the `validationOption` binding (see
    the next section) or by passing a configuration object to `ko.applyBindingsWithValidation`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Validation binding handlers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Knockout Validation adds a few binding handlers to assist in displaying validation
    errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `validationMessage` binding displays the error message for validated observables
    when they are invalid. When the value is valid, the element is hidden:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'The `validationElement` binding is useful for applying attributes and classes
    to elements. It sets the title attribute to the validation message, which is useful
    for showing tooltips, and it sets `errorElementClass` (`validationElement` by
    default) as the element''s class attribute when the `decorateElement` configuration
    option is true:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The `validationOptions` binding is similar to a control flow binding in that
    it applies the specified configuration options to all descendant DOM nodes. It
    can take the same object format that the configuration options can take:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Creating custom rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Custom rules can be created both globally so that they can be reused by multiple
    extenders or inline for use in a single extender. Adding global validation rules
    is done by adding a rule object to the `ko.validation.rules` object. A rule has
    two components, which are the **validator function** and the **default message**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'The validator function receives two arguments: the value of the observable
    and the value passed to the validation extender. The validation extender can take
    any valid JavaScript value, including objects and functions.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once a validation rule has been added, its extender is created with the following
    call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'It can then be used to extend observables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Inline validation rules work by passing the same validation rule object to
    the validation extender:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When using inline validation rules, the second parameter to the `validator`
    function is defined with the `params` property of the validation rule.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Knockout Validation is a large library with many features and options that have
    not been discussed in this section. The complete documentation for the Knockout
    Validation library can be found on its GitHub repository at [https://github.com/Knockout-Contrib/Knockout-Validation](https://github.com/Knockout-Contrib/Knockout-Validation).
  prefs: []
  type: TYPE_NORMAL
- en: Knockout Mapping
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The Knockout Mapping plugin is the answer to projects that want to bind against
    their server''s AJAX responses without manually writing the JavaScript classes
    in order to convert them into observables. The mapping plugin will convert JavaScript
    objects or JSON strings into objects with observable properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'For JSON, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The mapping plugin handles arrays by converting them into `observableArrays`.
    It also creates a copy of objects, allowing a complete object graph from the server
    to be converted into an observable object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Updates against viewmodels created with the mapping plugin can be performed
    by passing the viewmodel as the second parameter to `fromJS` or `fromJSON`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: You can see a simple example of the mapping plugin in action in the `cp8-mapping`
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the viewmodel
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `fromJS` and `fromJSON` methods can also be used to update an entire viewmodel
    in order to handle future server update responses by passing the viewmodel as
    the third parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Unmapping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Normally, when sending data back to the server, you would use `ko.toJS` or `ko.toJSON`
    to unwrap the viewmodel into an object with normal JavaScript properties instead
    of observables ones. Because the mapping plugin adds several properties to your
    viewmodel that are intended for internal use, `ko.toJS` will produce a cluttered
    copy. Instead, you can use `ko.mapping.toJS` and `ko.mapping.toJSON` to get an
    unwrapped viewmodel without the added mapping properties.
  prefs: []
  type: TYPE_NORMAL
- en: Mapping options
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To control how objects are created or updated by the mapping plugin, options
    can be passed in when a viewmodel is first created. The mapping plugin will use
    the options to build the viewmodel, and then store the options so that they can
    be used for all future updates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Using keys for array updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The default behavior for updating arrays is to replace any elements that are
    not a perfect match with the new values. When working with arrays of objects,
    it is usually expected that the elements will have their values updated in place.
    To tell the mapping plugin how to determine that elements in the values to be
    updated are the same as the old values, a key can be defined:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using create for the object construction
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'You can provide a callback for individual properties to control their creation.
    A common use case is to provide a constructor for the object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Controlling updates
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Similar to creation, an update callback can be provided. The return value will
    be used as the property''s value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Choosing which properties get mapped
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Mapping options can specify an array of property names that control various
    aspects of mapping:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ignore`: Mapping will not include these in the generated viewmodel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`copy`: Mapping will copy the values of these properties directly instead of
    converting them into observable properties.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`observe`: If present, only the properties in this array will be converted
    into observable properties on the viewmodel. This is the inverse of the previous
    option.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`include`: Normally when using `ko.mapping.toJS`, only properties that were
    originally in the mapping will be in the output. Any properties in the `include`
    array will also be copied into the output even if they weren''t in the original
    viewmodel.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'All of these arrays will be combined with the default values in the `ko.mapping.defaultOptions`
    object. The defaults are all empty by default, but they can be modified:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Challenges
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Knockout Mapping plugin is very useful in cases where server responses drive
    the work being done by the application. When the application needs to work with
    models, the mapping plugin will not be able to create the viewmodel before the
    models have been sent by the server. This happens commonly when filling out forms
    to create new models for the first time. The properties of a viewmodel are also
    only half the story; business logic will still need to be written for most viewmodels.
    It can be challenging to write functions or computed properties against properties
    that are populated by the mapping plugin, as they are not in the class that will
    be served as a reference. In very complex cases, the mapping logic for some objects
    might exceed the same logic for an object defined with normal JavaScript. While
    this can save time in medium-to-large applications with many server responses,
    it might not always be the best fit for a project.
  prefs: []
  type: TYPE_NORMAL
- en: Despite its popularity, it is no longer being maintained on GitHub. However,
    as of version 3.2, it still works with Knockout.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The documentation for the mapping plugin is on the official Knockout site at
    [http://knockoutjs.com/documentation/plugins-mapping.html](http://knockoutjs.com/documentation/plugins-mapping.html).
  prefs: []
  type: TYPE_NORMAL
- en: Knockout Kendo
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Kendo UI ([http://www.telerik.com/kendo-ui](http://www.telerik.com/kendo-ui))
    is a popular HTML5 widgets library of Telerik that offers a large selection of
    professional-looking controls. Knockout Kendo is a library of bindings, which
    allows Knockout viewmodels to use Kendo controls. Knockout Kendo has over 30 bindings,
    each with a variety of options, which is far too many to cover here. While Knockout
    Kendo is free, Kendo UI itself is not free and requires you to purchase a license
    in order to use it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Most of the bindings are simple wrappers around the Kendo widgets, offering
    an API with a few surprises. For example, here is the **autocomplete** binding,
    which takes an array of options and an observable that binds the selection:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '`DateTimePicker`, which creates two independent selection controls for the
    date and time, binds against a single observable `Date` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If you have used Kendo previously, you will be familiar with the available controls,
    and Knockout Kendo even has bindings for the non-free Professional UI widgets.
    You can see a few examples of Kendo controls in the `cp8-kendo` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can find the complete documentation for Knockout Kendo on its GitHub site
    at [http://rniemeyer.github.io/knockout-kendo/](http://rniemeyer.github.io/knockout-kendo/).
  prefs: []
  type: TYPE_NORMAL
- en: KoGrid
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: KoGrid is a plugin that creates a binding that renders tabular data. As its
    GitHub page notes, it is "a direct knockout port of ng-grid which was originally
    inspired by KoGrid, which was inspired by SlickGrid." Its history might have been
    affected by the grandfather paradox.
  prefs: []
  type: TYPE_NORMAL
- en: 'In its most basic operation mode, KoGrid can bind against an array of objects,
    turning their properties into columns and their values into cells:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: You can see this example in the `cp8-kogrid` branch. Except for needing to manually
    specify, through style of CSS, the dimensions of the grid itself, everything else
    is automatic. You get row sorting by clicking on the columns, the ability to toggle
    columns visibility, a scrollbar for overflow, item counts, and the columns can
    be reordered by dragging them. The biggest downside is that the data isn't rendered
    using a real table element, it's rendered using just a bunch of `div` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, this is just the basic mode of operation. KoGrid comes with most
    of the features you would expect from a fully baked grid widget:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Column definitions**: This specifies which row properties are displayed as
    columns.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Grouping**: This allows the user to select a column to pivot the table on,
    grouping all of the rows by matching values of the selected column.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Selected rows**: With this, an observable array can be bound against the
    selected rows for the table. When the `multiSelect` option is false, this can
    be used to create a master/detail view with the selected row.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Templates**: This provides row and cell templates for the grid.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Themes**: This specifies themes on a per-grid basis through binding options.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server-side paging**: This provides callbacks that allow the grid to get
    data asynchronously from an external source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you want a binding that outputs real table elements, and you don't need all
    of the bells and whistles offered by KoGrid, check out the knockout-table plugin
    at [https://github.com/mbest/knockout-table](https://github.com/mbest/knockout-table).
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of any of these features, templates are probably the most important. While
    their example page puts the templates in line in the viewmodel code, this is not
    a recommended practice unless you are loading the string from an external source
    (such as AJAX or the RequireJS text loader). KoGrid also supports using a script
    element as a template by referencing its ID, such as Knockout''s template system.
    However, the simplest approach is to use a URL string to refer to an HTML partial
    file as the template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example shows you several grid options as well as the column definition
    that specifies which columns to show. Note that the last column does not have
    a property but has a template that will show you a delete button instead.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to define these options in the viewmodel and pass only a single
    object to the KoGrid binding; however, this causes the viewmodel to be tightly
    coupled to its use by a KoGrid, which is a violation of the MVVM pattern. Defining
    the grid options in the view keeps the viewmodel agnostic with regards to how
    it is displayed.
  prefs: []
  type: TYPE_NORMAL
- en: 'The delete button template will be rendered by KoGrid inside the binding context
    of the cell:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The complete documentation for cell and row templates will not be covered here,
    but the preceding template demonstrates several important components.
  prefs: []
  type: TYPE_NORMAL
- en: To control its width and position properly, cells need to include the `kgCellText`
    class as well as a 0-indexed class for the column it represents. As the cell will
    be used inside a column loop, it has access to the special binding context property
    `$index()` in order to get this value.
  prefs: []
  type: TYPE_NORMAL
- en: The default value for a click binding in Knockout is the current binding context.
    Inside the cell template, this will be the cell object and not the item from the
    data array. The bound item can be accessed using `$parent.entity`. To get access
    to the viewmodel, the grid is bound against `$parent.$userViewModel`. The `$parent`
    in both these cases is the binding context for the row; when creating row templates,
    `$data.entity` and `$userViewModel` can be used to access the same properties.
  prefs: []
  type: TYPE_NORMAL
- en: You can see an example of this custom template in the `cp8-kogrid-template`
    branch.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete documentation for KoGrid can be found on its GitHub Wiki page at
    [https://github.com/Knockout-Contrib/KoGrid/wiki](https://github.com/Knockout-Contrib/KoGrid/wiki).
  prefs: []
  type: TYPE_NORMAL
- en: Knockout Bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Twitter Bootstrap has several beautiful jQuery-dependent widgets that can be
    used from JavaScript or in some cases, with their `data-*` attributes. If you
    are using Knockout, though, some work needs to be done in order to get it to work
    with observables and to initialize it from binding handlers. Knockout Bootstrap
    is a popular plugin that addresses this. Unfortunately, at the time of writing
    this, it hasn't been updated to work with Bootstrap 3 and therefore, some of its
    features do not work. When working with Knockout 3 and Bootstrap 3, the **ToolTip**,
    **Popover**, and **Alerts** bindings work correctly, but the **Progress Bar**
    and **Typeahead** bindings do not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Like Knockout Kendo, if you have used the Bootstrap widgets, the bindings in
    Knockout Bootstrap should be immediately familiar. The bindings are named after
    their widgets and take an object with the same properties the jQuery plugin initializers
    take. When sensible, the properties can be bound against:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: These can all be seen in the `cp8-knockout-bootstrap` branch. One thing to note
    is that the alert binding does not remove alerts from the bound array when they
    are closed on the UI, though it will show or hide array elements as they are added
    or removed.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The complete documentation for Knockout Bootstrap is available at [http://billpull.com/knockout-bootstrap](http://billpull.com/knockout-bootstrap).
  prefs: []
  type: TYPE_NORMAL
- en: Knockout Switch-Case
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Despite being a plugin that targets a single, specific use case, Knockout Switch-Case''s
    popularity on GitHub is evidence that a switch/case control flow binding is a
    very useful tool. Instead of writing out a series of `if`/`ifnot` bindings, a
    single case-switch binding can be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example can be seen in the `cp8-case-switch` branch.
  prefs: []
  type: TYPE_NORMAL
- en: 'The switch binding can also act on truthy values. This can be done by looking
    for the first matching value in a series:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Or, it can be done by serving as a shorthand for a pair of `if/ifnot` bindings:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The switch-case binding can also be used as a container-less binding in any
    combination of the preceding cases.
  prefs: []
  type: TYPE_NORMAL
- en: As you might have noticed, there are also special `$default` and `$else` options
    that can be used if no matching value is found.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The source code for Knockout Switch-Case is available on GitHub at [https://github.com/mbest/knockout-switch-case](https://github.com/mbest/knockout-switch-case).
  prefs: []
  type: TYPE_NORMAL
- en: Knockout Projections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using a computed observable to filter or project an observable array is an incredibly
    common operation; I don't think I've ever seen a Knockout project that didn't
    do this at least once. Knockout Projections is a plugin that adds a map and filter
    function to observable arrays, which creates a computed observable that only recomputes
    it's callback on dependent elements that have changed instead of re-evaluating
    every single dependent element.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Steven Sanderson introduced this plugin via his blog at [http://blog.stevensanderson.com/2013/12/03](http://blog.stevensanderson.com/2013/12/03).
  prefs: []
  type: TYPE_NORMAL
- en: To better understand the problem this plugin solves, we are going to look at
    the example Sanderson uses on his blog to illustrate the differences between a
    normal computed observable array and an array made with Knockout Projections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: This `selectedProducts` computed is defined using the standard ES5 Array's `filter`
    function, calling `products()` returns the underlying JavaScript array. Every
    time it runs, it will loop over all of the products and return an array of every
    element with `isSelected() === true`. The problem here is that computed observables
    always rerun when any of their dependencies change; the computed can only perform
    re-evaluation by running its callback, and has to recheck every single product
    every time it runs. This does not scale very well; it runs in O(N) time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using Knockout Projections, you will create this same computed using the
    `filter` function on the observable array itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This creates a read-only observable array that creates individual dependencies
    on each product''s `isSelected` observable. When a product is changed, the callback
    is run against only that product, and the `selectedProducts` array is updated
    with the change. Performance now has a fixed cost: no matter how large the array
    gets, the callback will only be run once per dependency change. The declaring
    code is also shorter and easier to read!'
  prefs: []
  type: TYPE_NORMAL
- en: 'Knockout Projections also creates a map function on observables, which runs
    a callback that produces an array transformation instead of a filter. For example,
    you can create an observable array of product names that only received updates
    when individual names were changed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'As the read-only arrays created by filter and map are also observable arrays,
    these methods can be chained together:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The performance gain from using Knockout Projections is minor in small arrays
    but significant in larger ones. If you are working with even medium-sized data
    sets, using Knockout Projections is a no-brainer.
  prefs: []
  type: TYPE_NORMAL
- en: Knockout-ES5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Knockout-ES5 is a plugin for Knockout that uses JavaScript getters and setters
    to hide observables behind object properties, allowing your application code to
    use standard syntax to work with them. Basically, it gets rid of the observable
    parentheses:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code becomes this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: If you remember the Durandal observable plugin, it's very similar; they even
    came out around the same time. The biggest difference between the two is that
    Durandal's observable plugin performs deep object conversion, and Knockout ES5
    performs shallow conversion.
  prefs: []
  type: TYPE_NORMAL
- en: 'To convert a viewmodel''s properties to observables, call `ko.track`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'To optionally specify which properties are to be converted in order to pass
    an array of names, take a look at the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'Observables that already exist on the model, such as those created with `ko.observable`
    or `ko.computed`, are also converted into ES5 properties by `ko.track`. Optionally,
    you can define computed observables using `ko.defineProperty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The third parameter follows the same rules as the first parameter sent to `ko.computed`;
    a function will be used to create a read-only computed, or an object can be used
    to supply a read/write function.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once observables have been created, you can access them with `ko.getObservable`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: This is useful while applying extenders or adding subscriptions. Extenders can
    also be applied by creating observables with `ko.observable` before calling `ko.track`.
  prefs: []
  type: TYPE_NORMAL
- en: An example of all of these techniques can be seen in the `cp8-es5` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Browser support
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As Knockout-ES5 uses JavaScript getters and setters, it will not work in browsers
    that do not support this feature. This is not a feature that can be shimmed or
    polyfilled with scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Knockout gets a lot of flak for the syntax that results from the decision to
    make observable object functions. Going by the popularity of questions on Stack
    Overflow, it is certainly one of the most confusing aspects to newcomers. The
    decision to do this was made so that support for older browsers such as Internet
    Explorer 6, which doesn't support JavaScript getters and setters, was possible.
    Now that Internet Explorer 6 is finally starting to lose its death grip on the
    browser market share, this supportability issue is becoming less and less important
    to web developers. Unfortunately, Internet Explorer didn't add support for ES5
    getters and setters until IE 9, which is still a high bar for most projects.
  prefs: []
  type: TYPE_NORMAL
- en: Realistically, as using Knockout ES5 has such a drastic impact on application
    syntax, switching to it on a that is project already underway is rarely feasible.
    Knockout ES5 should only be considered for new projects that do not have an old
    browser support requirement.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Narrowing down the plugins and libraries to include in this chapter was difficult.
    Knockout's Wiki page on GitHub contains a long list of plugins ([https://github.com/knockout/knockout/wiki/Plugins](https://github.com/knockout/knockout/wiki/Plugins))—far
    too many to discuss here. If you are working with Knockout, you are encouraged
    to check out the community offerings, as it could end up saving you a lot of work.
    Not all of these plugins will be useful to everyone or every project, but hopefully,
    they give you an idea of what can be done with Knockout and motivate you to share
    some of your own work with the community.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be taking a deep dive into Knockout's internals
    to see how it works.
  prefs: []
  type: TYPE_NORMAL
