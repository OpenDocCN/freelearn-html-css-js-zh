- en: Chapter 6. Advanced Durandal
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we covered most of the basic uses of the Durandal framework.
    By now, you should feel comfortable starting an application with it. In this chapter,
    we will continue to look at Durandal by covering some more advanced framework
    features as well as looking at some useful patterns that will help us solve common
    challenges encountered in the SPA development.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing and subscribing with events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application login scenarios
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Nested routers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom modal dialogs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Binding to plain JavaScript objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publishing and subscribing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A very common problem new developers face when they start using Knockout is
    how to communicate between viewmodels without establishing a single hierarchy
    with a master viewmodel or any other form of direct reference between viewmodel
    objects. These kind of hard dependencies are generally considered bad practice,
    but the need to send messages between different viewmodels is unavoidable.
  prefs: []
  type: TYPE_NORMAL
- en: 'The publish-subscribe (pub/sub) pattern is a popular solution to this problem.
    Durandal offers you a simple pub/sub implementation via the `Events` module. There
    are two ways in which you can use the events system: with the events included
    on the `durandal/app` object by default or by adding events to your own objects.'
  prefs: []
  type: TYPE_NORMAL
- en: The events module
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The events system includes the `events` module and the `subscription` class.
    The `events` module, required by `durandal/events`, provides you with the `includeIn`
    method to add events to an object. When `Events.includeIn(obj)` is called, the
    following functions are added to `obj`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`on`: This is used to subscribe to events on the object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`off`: This is used to unsubscribe to events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`trigger`: This is used to raise events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`proxy`: This returns a function that can be called to raise events'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Subscribing to events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `on` method can be used in two different ways. To provide a callback and
    an optional context (a `this` value for the callback), pass them in as parameters.
    From `on`, `obj` will be returned so that chained subscriptions can be added:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'To get a subscription object, provide only the event name to `on`. What is
    returned from `on` will be a subscription object, which provides a `then` and
    an `off` method. The `then` method can be used to attach a callback:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `then` method also returns the subscription that allows you to store the
    subscription reference.
  prefs: []
  type: TYPE_NORMAL
- en: You can subscribe to multiple events simultaneously using a space-delimited
    list of names for the event name parameter. You can also subscribe to all events
    on the object using the `all` event name.
  prefs: []
  type: TYPE_NORMAL
- en: Unsubscribing from events
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Removing a callback is done in a manner that is similar to adding callbacks,
    and it depends on whether you added the callback with `on` or by using `then`
    on a subscription.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you subscribed with `on`, you can unsubscribe by calling `off` with the
    same event name and callback. To remove all callbacks for that event name (or
    names), do not provide a callback to the second parameter. To remove all callbacks
    with a specific context, provide a context to the third parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'If you used a subscription object, just call `off` on the subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Raising events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Triggering events on an object is similar to subscribing to them. You can use
    a single event name, multiple space-delimited event names, or trigger all events
    using the special `all` event name.
  prefs: []
  type: TYPE_NORMAL
- en: 'When events are triggered, they can pass along parameters to the callbacks
    of subscribing events. Though triggered events can use any number of parameters,
    it is much easier to work with callbacks when they always use a single parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Proxying events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'An event proxy is a method that will raise a preselected event (or a list of
    events), passing along its arguments as the event parameters. The following two
    methods are equivalent:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The benefit of proxies is that they are reusable, and they can be stored or
    passed around. This is useful in order to share the proxy with other systems or
    just have a single event-raising function in several places. This practice of
    creating a function to represent another function with a fixed parameter is known
    as **currying**.
  prefs: []
  type: TYPE_NORMAL
- en: The event name of a proxy can be any string that `trigger` can use, including
    `all`.
  prefs: []
  type: TYPE_NORMAL
- en: Application events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the `app` object is a singleton that has events included out of the box,
    its events are useful for application-wide messaging. Communication between independent
    top-level components, such as page viewmodels, is a good candidate for app-wide
    messaging.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we wanted to reduce load on the server by raising an event when
    a new contact was added so that the list page could get the new contact without
    going to the server to refresh the whole list. To stop loading the list during
    it''s `activate` method, it will be converted into a singleton that reuses the
    same loading promise:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As the promise that is returned to `activate` is only run once, the list will
    not be reloaded when the page is navigated multiple times.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list page''s viewmodel now needs to create an event subscription in order
    to receive new contacts. Durandal''s convention for event names is to specify
    the source(s) and event type, separated by colons. This convention is recommended
    but not required; Durandal does not treat colons as delimiters for event names.
    For example, these are two events raised by the router during the navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'To subscribe to an event for a new contact, the list page can use the following
    subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'However, because the only action being taken is to send the `newContact` parameter
    to `contacts.push`, it would be shorter to write it as a callback with a context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: These two methods are equivalent. It should be noted that the third parameter
    that defines the context is necessary; otherwise, the `push` function will be
    called and will fail without being in the context of the contacts array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The new/edit page can now publish this event using the `contact:added` event
    after it creates a contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'This will send you the contact returned from the `createContact` promise as
    the data for the triggered event. However, as this is another case of sending
    a parameter to another single function, it can be written using a proxy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: You can see an example of this in the `cp6-pubsub` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Module-scoped events
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to application-wide pub/sub, Durandal provides a simple method
    to add the events methods to any object, allowing events to be scoped. Calling
    `Events.includeIn(obj)` will create the same event handling methods that the `app`
    object has by default: `on`, `off`, `trigger`, and `proxy`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The data service is a good candidate for events related to contacts being added
    (or modified), as only the modules that already have a reference to it will be
    interested in these events. Moving the `contact:added` event out of the new/edit
    page into the data service also ensures that the event will still go off if another
    module tries to add a contact:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This will add the event methods to the `dataService` object and raise the `contact:added`
    event in the return promise for the `createContact` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The change to the list page viewmodel is just referencing the `dataService`
    object instead of `app` for the event subscription:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: That's all that needs to be done. The `dataService` object is now acting as
    an event scope for contacts. You can see this example in the `cp6-event` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Handling logins
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Handling logins can be tricky for a variety of reasons, and there are hundreds
    of different techniques out there. Web application login generally falls in one
    of two categories: either your site is free to browse without being logged in
    (anytime login), or it uses and requires the user to log in first (gated login).
    The challenges presented by each category are different, and so are the best solutions.'
  prefs: []
  type: TYPE_NORMAL
- en: Gated login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Until fairly recently, almost all gated login sites used some redirection pattern
    to present a login page to users, which was usually an unpleasant experience.
    Beyond the issue of page load time, getting back to the originally requested URL
    generally meant query string parameters that contained the original URL. If the
    original URL had query strings itself, they were either lost or appended to the
    URL query value.
  prefs: []
  type: TYPE_NORMAL
- en: 'SPAs can sidestep the redirection problem by just showing a login page at the
    current URL; no redirection means the whole process is faster, there is no hassle
    with the query string, and the user isn''t jarred by the URL changing. They have
    a different challenge, though: what do you do with the shell? You can place the
    login form alongside the shell and switch between them with bindings, but this
    clutters the shell with login markup. You can use a modal dialog to show the login
    form so that the shell is untouched, but then the shell is either blank or shows
    information that should be login-gated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Durandal''s `setRoot` method really simplifies this problem. If the user needs
    to log in, setting the login form as the root means the shell is never even loaded.
    After the login finishes, the shell can then be set as the root; the shell''s
    markup is left untouched, and the user never sees anything they shouldn''t:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, our application startup in `main.js` will use `setRoot` to go to either
    the login or the shell, depending on whether the user is already logged in (say,
    from a cookie):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This relies on the `dataService` object, performing a synchronous check to
    see if `isLoggedIn` is `true`, but it can easily support an asynchronous one that''s
    just hooking into the `app.start` promise:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the login process is complete, the login viewmodel can just call `setRoot`
    for the shell. That's it! In fact, the only other properties in the login viewmodel
    are the ones for `username`, `password`, and a failed sign-in flag. After the
    login completes, the shell will start up just like it did previously, activate
    the router, and compose the correct page. There is no need to worry about managing
    an empty state while the login happens, as the shell is never loaded until `setRoot`
    is called on it.
  prefs: []
  type: TYPE_NORMAL
- en: You can see an example of this in the `cp6-login` branch. The login module contains
    a standard viewmodel and view. To log in, use any login details where the username
    and password are the same. Obviously, in a real application, you would want to
    create a server request.
  prefs: []
  type: TYPE_NORMAL
- en: 'One thing that is important to note is the logout function. It''s in the shell
    in the sample, but in a real application, it should be refactored into an external
    service—probably the same one that holds the methods used to get and set the login
    cookie in order to centralize the login behaviors. In SPAs, because navigation
    isn''t occurring, it can be a challenge to clean up all of the data a logged-in
    user has in the application state, especially when you have singletons. Trying
    to create a cleanup method that removes all of this data is prone to errors; it''s
    easy to miss out on important bits of data, and it requires constant maintenance
    as the application grows. Instead, it''s much safer to just reload the browser.
    Navigation, even if it''s a refresh, completely resets the JavaScript state, guaranteeing
    that nothing from the previously logged-in user is left in the memory. The `location.reload`
    method is a simple way to do this, but it might not be the best approach if the
    user is on a page with a sensitive URL. A safer approach would be to set the location
    to the domain root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Anytime login
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sites that allow users to browse and optionally log in have different challenges
    compared to gated login sites. Some sites that allow optional login still have
    a separate login page and still use redirection parameters to get the user back
    to their original location, but this experience is even more unpleasant for the
    user, as it seems unnecessary. Of course, it might be required if you allow browsing
    over HTTP and require a redirect for HTTPS to perform the login, but this is all
    the more reason to always require HTTPS! If you take the redirection route to
    get to an HTTPS page, then even the preceding method will not work for you, as
    the preceding method doesn't use browser navigation to change the page.
  prefs: []
  type: TYPE_NORMAL
- en: If you always require HTTPS for normal browsing, then you can allow the user
    to log in without interfering with the current page. You can use the same technique
    that gated login uses, but without the need to hide post-login information, there
    are less intrusive methods.
  prefs: []
  type: TYPE_NORMAL
- en: A common method, and one of the least intrusive, is to include an inline login
    form in the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: '![Anytime login](img/00015.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Once logged in, the navigation bar would appear the same as the previous navigation
    bar with the login name and the logout button. This small section of the navigation
    bar can be backed by a login viewmodel that is composed into the shell, which
    keeps the login implementation details separate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The login viewmodel doesn't need to change much for this, but the logout functionality
    can be moved into it as it no longer is controlled by the shell. You can see an
    example of this in the `cp6-login-nav` branch. Try logging in and notice how the
    navigation bar changes.
  prefs: []
  type: TYPE_NORMAL
- en: Responding to the user's login changes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The inline login form works, but it is likely that your application will need
    to respond to the newly logged-in user in some way, for example, letting only
    logged in users create, edit, or delete contacts. There are two ways to handle
    this: either use some combination of events and Knockout observables to update
    the page, or reload the page when the user logs in.'
  prefs: []
  type: TYPE_NORMAL
- en: It might be simpler to take the page reload route, but it really depends on
    your application. If you use anytime login and allow users to see most pages without
    being logged in, you might not be maintaining two separate versions of each page.
    Instead, you might have `if/visible` bindings hiding the logged-in-only content.
    If that is the case, then updating these observables won't be too much effort.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are maintaining two separate versions of each page because they
    are different enough for logged-in users, the page reload method is a better bet.
    As the reload route doesn't take much explaining, let's look at the first case.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the simple case of hiding the edit controls, Knockout observables are perfectly
    sufficient. The login-checking function in the data service is a good place to
    put observables that multiple viewmodels will depend on, as it is already a shared
    component. In a larger application, you might want to separate the data service
    into multiple services in order to serve specific roles such as login and contact
    CRUD:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `loginName` determines whether or not `isLoggedIn` is `true`. The `loginName`
    parameter is set initially if storage has a saved token, and it is updated when
    the user logs in or out. There are three places that need to use one of these
    fields: the list page, the list items, and the shell. The list page will use it
    to expose whether or not a user can edit contacts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This property is used by the list of items in order to hide or show the buttons:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'For additional safety, the methods backing these buttons should also check
    the `canEdit` property. The `delete` button is not shown, but it uses the same
    check as what is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Likewise, to ensure that the user cannot get to the edit page by manually entering
    the URL, it should use a `canActivate` check to block navigation for anonymous
    users:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, the shell will want to remove the route from the navigation bar when
    the user is not logged in. One way to do this is to create a computed observable
    array on the shell that filters out routes when the user isn''t logged in:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This model will remove any route with an `auth: true` property when the user
    is not logged in, which makes it easy to add pages that require login in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: This example can be seen in the `cp6-login-event` branch. To make it easy to
    see the logout transition, this branch does not reload the page when the user
    logs out; instead, it just clears storage and updates the observables on the data
    service.
  prefs: []
  type: TYPE_NORMAL
- en: Guarded routes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous section, we used a `canActivate` check on a page viewmodel to
    ensure that users could only get to the page when they were logged in. This works,
    but if multiple pages need to be gated, or we need to use logic that the page
    might not have, it is possible to add this logic to the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `guardRoute` method is an optional method that the router will use to screen
    every attempted navigation. It receives the module being activated and the route
    instruction as parameters. If `true`, or a promise for true, is returned from
    `guardRoute`, then navigation continues normally. If a string or a promise for
    a string is returned, it will be used as a redirection route. If `false` or a
    promise for false is returned, then navigation is cancelled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This router guard can replace the `canActivate` method on the edit page, as
    it will cancel navigation when the route has `auth:true` and the user is not logged
    in. However, canceling navigation can sometimes appear to users as the application
    not responding, such as when the back button is pressed. It can be improved by
    redirecting the current page to the error page instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This example can be seen in the `cp6-guard-route` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 5](part0041_split_000.html#page "Chapter 5. Durandal – the Knockout
    Framework"), *Durandal – the Knockout Framework*, we covered the basic and common
    uses of Durandal's composition system. This section will cover further composition
    techniques such as caching, transitions, and composition mode.
  prefs: []
  type: TYPE_NORMAL
- en: View caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By default, the view rendered by the composition binding is discarded when
    the composed module is changed. This results in the DOM contents of the composition
    binding always being only the current module''s view. The `cacheView` option on
    the composed binding will change this behavior so that Durandal can keep any view
    composed. If a module is reactivated using the same object that is already bound
    to a view, it will not be recreated. Both the `compose` and `router` bindings
    have this option:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: You can see an example of this in the `cp6-cache` branch. If you open the console,
    you can see that the attaching and binding events are no longer being raised when
    revisiting the list or edit pages. You can also see, with a debugger breakpoint,
    that the viewmodels are only being constructed the first time.
  prefs: []
  type: TYPE_NORMAL
- en: 'When working with cached views, extra caution is required. As the module is
    a singleton and is only constructed once, the `activate` method is responsible
    for setting up data or clearing old data out. For example, previously, the edit
    page only set its `contact` property to a new instance during the construction.
    The `activate` method needs to reset the contact if the page is being loaded in
    a new entry mode (without an ID):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: If this isn't done, users will not see an empty form if they tried to create
    a contact after creating or editing a previous one.
  prefs: []
  type: TYPE_NORMAL
- en: Even if the `cacheViews` property is set to `true`, Durandal will not cache
    a DOM view if the model instance has changed. In the `cp6-cache2` branch, the
    constructor is returned from the list page, and you can see that a new instance
    is constructed and attached to the DOM despite `cacheViews` being set.
  prefs: []
  type: TYPE_NORMAL
- en: Transitions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Durandal''s `router` and `compose` bindings have a hook that allows the composed
    view to transition with an animation. To use it, provide a value to the `transition`
    property on the binding:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'The `entrance` transition is provided by default; it fades the current view
    out and fades in the next view with a small slide effect. You can see it in the
    `cp6-entrance` branch. Note that for this animation to work, the composition needs
    to occur in an element with the CSS `position: relative` property, as the animation
    uses absolute positioning.'
  prefs: []
  type: TYPE_NORMAL
- en: The `durandal/composition` module also has a `defaultTransitionName` property
    that will use the supplied transition for all compositions that do not specify
    their own transitions.
  prefs: []
  type: TYPE_NORMAL
- en: To create your own transition, you need a module that returns a function that
    Durandal can call in order to run the transition. The transition function will
    receive the composition settings and needs to return a promise for its completion.
    There are a lot of values on the settings object but the two that are most useful
    are `activeView`, which is the view being transition out, and `child`, which is
    the view being transitioned to.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of a custom transition that uses the jQuery UI''s slide
    effects. It assumes that jQueryUI has already been set up in RequireJS:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The module returns the animation function, which itself returns a promise for
    the animation. The animation function pulls out the current and next view and
    then sets up callbacks in order to end the view and slide in the new view with
    jQuery. The `if` block at the end ensures that the current view is only acted
    upon when it exists. If it doesn't, then no animation is created (as there is
    nothing to slide out), and the view is just shown.
  prefs: []
  type: TYPE_NORMAL
- en: By default, Durandal looks for transitions by appending `'transitions/'` to
    their name in order to get a RequireJS path. This is why the standard Durandal
    RequireJS configuration has a transitions path defined. You can map the path in
    RequireJS to another folder if you want to keep transitions somewhere else—such
    as your `app` folder—or you can override the composition module's `convertTransitionToModuleId`
    function to provide your own lookup logic.
  prefs: []
  type: TYPE_NORMAL
- en: This example can be seen in the `cp6-transition` branch. This branch uses a
    RequireJS path for a `transitions` folder in the `app` directory, which contains
    the preceding slide animation.
  prefs: []
  type: TYPE_NORMAL
- en: The templated mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the previous chapter, we covered widgets, which offer us the ability to
    override sections of the composed element with `data-part` attributes. This feature
    is also available in viewmodel composition using the binding `mode: ''templated''`
    option.'
  prefs: []
  type: TYPE_NORMAL
- en: The example widget that was used was a bit contrived, as the list of contacts
    isn't really a reusable widget. A more common technique with lists, especially
    with complex items, is to create a module for the list item and compose it with
    a `foreach` binding.
  prefs: []
  type: TYPE_NORMAL
- en: Separating complex list items from the page they are shown in keeps properties
    and methods specific to the list item that is not on the page. This is the same
    modularization logic that drives the separation of viewmodels and modules. It
    lets the page viewmodel focus more on the actions the page takes as a whole and
    lets the item focus on itself. The contact list items aren't complex enough to
    warrant this, but I'm sure you can imagine such a case.
  prefs: []
  type: TYPE_NORMAL
- en: 'Replacing the contact list widget with a `compose/foreach` binding is simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'This allows the item itself to be moved into its own file, which is `listItem.html`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the same template that was used previously, minus the delete button.
    The viewmodel for the list item is simple, containing just a `contact` object
    and an `edit` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The last thing to do is construct the list item on the list page instead of
    just using the bare contact model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'You can see this example in the `cp6-list-item` branch. This is just the setup,
    though; what we are really after is overriding the list item view with `data-part`
    attributes. Data-part overriding works the same way with compositions as it works
    with widgets:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: Here, the entire `btn-container` element is being overridden so that a delete
    button can be added. Remember, the scope of `data-part` attributes is the view
    they will be placed into, which is `listItem` in this case. The `edit` function
    is already in this scope, but the `deleteContact` function is in the parent of
    `listItem`, which can be accessed using the `$root` property of the templated
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: This example can be seen in the `cp6-template-compose` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Child routers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common scenario is the need to support routes within routes; this is
    sometimes called **nested** or **child** routes. For example, you might have multiple
    pages under the parent `/about` route that are represented by the `/about/author`
    and `/about/publisher` URLs, which are displayed as different subsections of the
    main `/about` page.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, the parent route has to capture child routes. It can do this with
    a splat route or with the `hasChildRoutes` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: Either way is fine, but note that the `about*children` splat route requires
    at least one character after the asterisk (`*`); the `about*` route will not capture
    the children properly. Personally, I think the `hasChildRoutes` property has a
    clearer intention.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the viewmodel that exposes child routes creates a child router:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: The `createChildRouter` function returns the child router of the root router.
    You can only have one root router, but it can have any number of children, and
    children routers can have children routers as well.
  prefs: []
  type: TYPE_NORMAL
- en: The `makeRelative` function takes an optional object. The `moduleId` option
    instructs all the modules of children routes to be prefixed with the supplied
    module, essentially making the routes relative to a folder. This is not required,
    but it keeps the routes shorter. The `fromParent` option causes children routes
    to inherit their parent's URL from the `route` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the module exposes `childRouter` as the router so that its view can
    bind to it using the same syntax that was used by the shell. This is the view
    for the `about` parent page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: This example can be seen in the `cp6-child-router` branch. The about page and
    its child routes are in the `app/about` folder, and the route has been added to
    the navigation bar.
  prefs: []
  type: TYPE_NORMAL
- en: Dynamic child routes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating child routes for a parent route with a parameter, such as `/contacts/23/bio`,
    additional configuration is required in order to allow the child routes to be
    relative to the `/contacts/:id` dynamic parent. To see an example of this, we
    are going to add a biography and location section to our contact pages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The contact edit route needs to indicate that it has child routes. The same
    options are available, but there is a caveat for splat routes—you must specify
    a `hash` manually:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: The children routers will not be able to create a proper URL from a splat route
    if the hash is not specified manually. This does not need to be done if you're
    using the `hasChildRoutes` flag.
  prefs: []
  type: TYPE_NORMAL
- en: 'The child router definition is almost identical, except for the `dynamicHash`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: The `dynamicHash` property controls how the URLs for child routes are created,
    as they need to include the `route` parameter. That's all it takes, though! After
    this, the routes can be used on the parameterized URL.
  prefs: []
  type: TYPE_NORMAL
- en: You can see an example of this in the `cp6-dynamic-child-routes` branch. The
    edit page's child routes have been placed for organization in the `contacts/edit`
    folder. Also, the biography and location pages just contain dummy text.
  prefs: []
  type: TYPE_NORMAL
- en: Custom modal dialogs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Durandal, a dialog context is the viewmodel that controls a modal dialog.
    It has a method used to add the modal dialog host, which is the DOM node inside
    which the modal content will be placed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Durandal offers two modal dialogs out of the box: message boxes and the default
    context. The message box that Durandal offers adds some simple DOM elements to
    the default context and is very useful in order to show short messages to the
    user. The default dialog context can host any composable module, including message
    boxes. If you want to use your own dialog box, such as the one included in Twitter
    Bootstrap, it is possible to add it as a dialog context.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A dialog context is an object that can create a dialog in the DOM to which
    the composition can add content. A custom context uses the following APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`addHost(dialog)`: This function is responsible for creating the dialog itself,
    by adding it to the DOM. It must assign the `dialog.host` property on the parameter
    to this DOM node, which will be used by composition as the parent for the composing
    module.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`removeHost(dialog)`: This function removes the DOM for the dialog and performs
    any cleanup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`compositionComplete(child, parent, context)`: This is a composition hook that
    the context can use to perform any setup. To get the `dialog` object (the parameter
    from the other two functions), call `dialog.getDialog(context.model)`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Custom dialog contexts are useful when you have different needs for modal windows.
    The Twitter Bootstrap dialog, for example, uses the same responsive CSS system
    that the rest of the Bootstrap framework uses, making it perfect for dialogs that
    need to be usable on desktops and phones. You might also want some of your dialogs
    to be displayed in a circular pop up in order to differentiate them from other
    modals your application is using.
  prefs: []
  type: TYPE_NORMAL
- en: 'Working with custom dialogs is done using the `dialog` module, which is injected
    using `''plugins/dialog''`. You can add a custom dialog context with the `dialog.addContext`
    function, which takes a context that matches the preceding API. The first parameter
    is the name of the new context, and the second is the context object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This setup needs to be done before the dialog can be used, so it is good to
    do it with any app setup. In the upcoming example, this will be in the `common/extensions`
    module.
  prefs: []
  type: TYPE_NORMAL
- en: 'The actual setup logic for each of the context methods depends on the dialog
    you are adding. This is what the Bootstrap modal setup will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: 'Unlike the Durandal modal, where the content container and the dialog element
    are the same, the Bootstrap modal expects the content container to be inside the
    dialog element. The content''s DOM element is placed in the `dialogInstance.host`
    property, which Durandal will use to compose the module. The outer modal element
    is stored in the `modalHost` property, which will only be used by functions on
    our custom Bootstrap context:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'This is where the actual Bootstrap `$.modal()` code is run from, as the sizing
    and placement of the modal will need to have a fully composed module that already
    exists. It uses the `modalHost` property and not the `host` property, as Bootstrap
    is expecting the modal container. Additionally, the handler is set up to support
    the standard Durandal autofocus and autoclose classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The `removeHost` function takes the steps that are required to hide the modal
    and the backdrop.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we use this new modal by specifying the context parameter on `dialog.show`
    in the edit contact viewmodel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: If you look in the `cp6-bootstrap-dialog` branch, this context will be added.
    The modal dialog from [Chapter 5](part0041_split_000.html#page "Chapter 5. Durandal
    – the Knockout Framework"), *Durandal – the Knockout Framework*, that opens when
    the **Add Contact** button on the list page is pressed has been restored. You
    can see that this new dialog has the Bootstrap sliding entrance animation, and
    the content is responsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is another method that can be used to show custom dialogs. The `addContext`
    method automatically creates a helper method using the context name. For the Bootstrap
    context, the method is `dialog.showBootrap`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: You can see this example in the `cp6-bootstrap-dialog2` branch.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing the default context
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Having multiple dialog contexts is certainly useful, but if you are adding
    a custom dialog context, chances are you want it to be the default dialog context.
    Having a Bootstrap modal dialog is great, but the standard message boxes are still
    using the nonresponse Durandal context. To change this, just replace the `dialog.show`
    method with one that specifies your context when one isn''t explicitly provided:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: 'This will cause all regular calls to the dialog module to use this context
    without affecting the ability of the code to manually control which dialog context
    is used for special scenarios:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: In the `cp6-bootstrap-dailog3` branch, you can see that the delete confirmation
    message box as well as the add contact modal uses the Bootstrap dialog context.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you still need access to the default context, consider adding a conventional
    helper to the dialog object, such as `dialog.showDefault` or `dialog.showOld`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Using activators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The activation life cycle is automatically used by the router, but sometimes,
    you want to use it without tying the work to the URL, which turns out to be quite
    easy. An activator is just a computed observable whose write function enforces
    the life cycle. An activator can be created by calling `activator.create()` using
    the `durandal/activator` module.
  prefs: []
  type: TYPE_NORMAL
- en: For this example, we are going to add an inline *quick edit* to the list page
    that will allow contacts to be edited without navigating to another page. It will
    leverage the existing edit page viewmodel with some minor changes, as it already
    has a `canDeactivate` method that prompts the user with a confirmation modal when
    unsaved changes are present. The list page activator will hook into the same logic
    automatically.
  prefs: []
  type: TYPE_NORMAL
- en: This example is in the `cp6-activator` branch. You might want to play with it
    a bit before we go into how it works. Just use the quick edit button on the list
    page, and the contact will be loaded into an edit form just below the search box.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list page needs an activator and a function to set the activator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: 'The `quickEdit` function, which will be bound to a button on the list item,
    sets the `editContact` activator to a new instance of the edit page viewmodel.
    It provides the contact-to-edit to the new viewmodel and a callback to clear the
    `editContact` object. The HTML just needs a button to call it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'To use this, the edit page viewmodel will need to call the close callback—the
    second constructor parameter—when saving or canceling in a manner that is similar
    to how it handled closing the dialog:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Actually, this is all we need in order to take advantage of the deactivation
    guard, which is already on the edit viewmodel. There is some additional logic
    that handles saving changes, but it isn't strictly related to the activator use.
    If you try to use quick edit, make some changes, hit **Cancel**, and you will
    be prompted. If you hit **No**, the item will not be deactivated. You will also
    be prompted if you try to use a different quick edit while unsaved changes are
    present. All of this guard logic is handled for you by virtue of `editContact`
    being an activator observable.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to being writeable with the normal observable pattern by calling
    `editContact(newValue)`, activators have an `activateItem` method. The first parameter
    to `activateItem` is `newValue`, and the second option is `activationData`, which
    allows you to send a property bag to the `activate` method of the new value being
    set. This will be used as `editContact.activateItem(newValue, data)`.
  prefs: []
  type: TYPE_NORMAL
- en: This example, more than most examples in this book, is extremely contrived for
    the sake of brevity. Overloading the edit page viewmodel so that it is internally
    aware of being used in three different contexts is not a good design, and is not
    recommended for real-world use.
  prefs: []
  type: TYPE_NORMAL
- en: Binding to plain JavaScript objects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last part of Durandal that we are going to cover is the observable plugin,
    which allows data binding to use normal viewmodel properties as observable objects
    by converting them under the hood.
  prefs: []
  type: TYPE_NORMAL
- en: The observable plugin uses JavaScript getters and setters created with `defineProperty`,
    which is part of the ECMAScript 5 specification. Only modern browsers support
    this feature, so if your application needs to work in Internet Explorer 8, the
    observable plugin will not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the observable plugin removes one of the most common complaints from
    Knockout''s syntax: the parentheses. All of the property access is executed using
    plain syntax, whether reading or assigning values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: Everything is converted into observables by the observable plugin during data
    binding. Knockout observables can still be created with `ko.observable`, but it
    should not be necessary.
  prefs: []
  type: TYPE_NORMAL
- en: This does have an impact on all of your code, though, as using the parentheses
    to access properties will no longer work; they are not functions anymore! Using
    the observable plugin means a total conversion of your application code.
  prefs: []
  type: TYPE_NORMAL
- en: Observable plugin setup
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the observable plugin, like any plugin, requires it to be installed before
    the `app.start` call:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: If you need to use the plugin manually, it is required into a module with `plugins/observable`.
  prefs: []
  type: TYPE_NORMAL
- en: Subscribing and extending
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you are no longer creating observables manually, you will have to use
    the observable plugin to get access to the underlying observable to set up subscriptions
    or add extenders. This can be done by calling the observable module as a function
    with `observable(object, ''property'')`. The observable module is injected with
    `''plugins/observable''`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: This can be done at any time, even if the property hasn't yet been converted
    into an observable, as calling the observable module will convert the property
    immediately.
  prefs: []
  type: TYPE_NORMAL
- en: Computed observables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Computed observables are created using `observable.defineProperty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `defineProperty` method also returns the underlying computed observables
    so that it can be extended or subscribed to.
  prefs: []
  type: TYPE_NORMAL
- en: 'There is a caveat with computed observables, though. If anything tries to access
    the computed value before its dependencies have been converted into observables,
    then the computed value will not be able to register these dependencies; its value
    will never update:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: 'To stop this from happening, the dependencies `firstName`, `lastName`, and
    `nickname` need to be made observables manually. This can be done by calling `convertObject`
    on the observable module:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: This ensures that the first time `displayName` is accessed, it reads observable
    properties and not normal properties.
  prefs: []
  type: TYPE_NORMAL
- en: Because this *bug* can be difficult to track down when it happens, it can be
    a good practice to always call `convertObjec`t in viewmodel constructors. It does
    not incur any performance penalty, as it's the same method the observable plugin
    uses when it gets to data binding. If you need finer-grained control over conversion,
    properties can be converted one at a time using `observable.convertProperty(object,
    'propertyName')`.
  prefs: []
  type: TYPE_NORMAL
- en: Promises
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to treating normal JavaScript properties as observables, the observables
    plugin also allows promises to be bound against by converting the property into
    an observable and setting a callback to update it when the promise is resolved:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: After being converted into an observable, the contacts array can still be bound
    against normally. In fact, making this change requires no HTML changes in the
    sample code.
  prefs: []
  type: TYPE_NORMAL
- en: Sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can see an example of all of these binding methods in the `cp6-observable`
    branch. All of the code has been converted to using plain JavaScript properties
    with the observable plugin.
  prefs: []
  type: TYPE_NORMAL
- en: The parentheses have been removed from all of the application code, including
    the mock data service. It should be a bit easier to read now.
  prefs: []
  type: TYPE_NORMAL
- en: On the list viewmodel, the preceding contacts' promise example is used, which
    replaces the `activate` method. The `displayContacts` computed value is created
    with the observable plugin and still has the `rateLimit` extender applied.
  prefs: []
  type: TYPE_NORMAL
- en: The `Contact` model uses the `convertObject` method to manually convert to observables,
    as the dirty flag on `state` will try to read the `displayName` computed value.
  prefs: []
  type: TYPE_NORMAL
- en: The only changes on the edit page are the removal of parentheses.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Durandal aims to compliment Knockout's MVVM philosophy by providing a view-viewmodel-centric
    framework that focuses on composition. If you love Knockout (and you should; you're
    reading this book, after all!), you should hopefully see Durandal as a natural
    extension. The tools Durandal provides go a long way in simplifying the development
    of SPAs.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be leaving Durandal and deep diving into Knockout's
    inner workings.
  prefs: []
  type: TYPE_NORMAL
