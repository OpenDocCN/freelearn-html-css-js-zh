- en: Chapter 6. Advanced Durandal
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 高级Durandal
- en: In the previous chapter, we covered most of the basic uses of the Durandal framework.
    By now, you should feel comfortable starting an application with it. In this chapter,
    we will continue to look at Durandal by covering some more advanced framework
    features as well as looking at some useful patterns that will help us solve common
    challenges encountered in the SPA development.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 Durandal 框架的大部分基本用法。到现在，你应该已经能够舒适地使用它来启动应用程序。在本章中，我们将继续探讨 Durandal，通过介绍一些更高级的框架特性以及查看一些有用的模式，这些模式将帮助我们解决在
    SPA 开发中遇到的常见挑战。
- en: Publishing and subscribing with events
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用事件进行发布和订阅
- en: Application login scenarios
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序登录场景
- en: Advanced composition
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高级组合
- en: Nested routers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 嵌套路由
- en: Custom modal dialogs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自定义模态对话框
- en: Binding to plain JavaScript objects
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绑定到纯JavaScript对象
- en: Publishing and subscribing
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 发布和订阅
- en: A very common problem new developers face when they start using Knockout is
    how to communicate between viewmodels without establishing a single hierarchy
    with a master viewmodel or any other form of direct reference between viewmodel
    objects. These kind of hard dependencies are generally considered bad practice,
    but the need to send messages between different viewmodels is unavoidable.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 新开发者开始使用 Knockout 时面临的一个非常常见的问题是，如何在没有与主视图模型或视图模型对象之间的单一层次结构或任何其他形式的直接引用的情况下在视图模型之间进行通信。这类硬依赖通常被认为是不良做法，但需要在不同的视图模型之间发送消息的需求是不可避免的。
- en: 'The publish-subscribe (pub/sub) pattern is a popular solution to this problem.
    Durandal offers you a simple pub/sub implementation via the `Events` module. There
    are two ways in which you can use the events system: with the events included
    on the `durandal/app` object by default or by adding events to your own objects.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 发布-订阅（pub/sub）模式是解决此问题的流行解决方案。Durandal 通过 `Events` 模块为你提供了一个简单的 pub/sub 实现。你可以通过两种方式使用事件系统：通过默认包含在
    `durandal/app` 对象上的事件，或者通过将事件添加到自己的对象上。
- en: The events module
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件模块
- en: 'The events system includes the `events` module and the `subscription` class.
    The `events` module, required by `durandal/events`, provides you with the `includeIn`
    method to add events to an object. When `Events.includeIn(obj)` is called, the
    following functions are added to `obj`:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 事件系统包括 `events` 模块和 `subscription` 类。`events` 模块，由 `durandal/events` 需要，为你提供了
    `includeIn` 方法来向对象添加事件。当调用 `Events.includeIn(obj)` 时，以下函数将被添加到 `obj` 中：
- en: '`on`: This is used to subscribe to events on the object'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`on`: 这用于在对象上订阅事件'
- en: '`off`: This is used to unsubscribe to events'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`off`: 这用于取消订阅事件'
- en: '`trigger`: This is used to raise events'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`trigger`: 这用于引发事件'
- en: '`proxy`: This returns a function that can be called to raise events'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`proxy`: 这将返回一个可以调用来引发事件的函数'
- en: Subscribing to events
  id: totrans-17
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅事件
- en: 'The `on` method can be used in two different ways. To provide a callback and
    an optional context (a `this` value for the callback), pass them in as parameters.
    From `on`, `obj` will be returned so that chained subscriptions can be added:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`on` 方法可以用两种不同的方式使用。要提供一个回调和一个可选的上下文（回调的 `this` 值），将它们作为参数传递。从 `on`，`obj` 将被返回，以便可以添加链式订阅：'
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'To get a subscription object, provide only the event name to `on`. What is
    returned from `on` will be a subscription object, which provides a `then` and
    an `off` method. The `then` method can be used to attach a callback:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取订阅对象，只需将事件名称提供给 `on`。`on` 返回的内容将是一个订阅对象，它提供了一个 `then` 和一个 `off` 方法。`then`
    方法可以用来附加一个回调：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `then` method also returns the subscription that allows you to store the
    subscription reference.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`then` 方法也返回订阅，允许你存储订阅引用。'
- en: You can subscribe to multiple events simultaneously using a space-delimited
    list of names for the event name parameter. You can also subscribe to all events
    on the object using the `all` event name.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以使用以空格分隔的事件名称参数的名称列表同时订阅多个事件。你也可以使用 `all` 事件名称来订阅对象上的所有事件。
- en: Unsubscribing from events
  id: totrans-24
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 从事件中取消订阅
- en: Removing a callback is done in a manner that is similar to adding callbacks,
    and it depends on whether you added the callback with `on` or by using `then`
    on a subscription.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 移除回调的方式与添加回调的方式类似，这取决于你是否使用 `on` 添加了回调，或者是在订阅上使用 `then`。
- en: 'If you subscribed with `on`, you can unsubscribe by calling `off` with the
    same event name and callback. To remove all callbacks for that event name (or
    names), do not provide a callback to the second parameter. To remove all callbacks
    with a specific context, provide a context to the third parameter:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用`on`进行了订阅，你可以通过调用带有相同事件名称和回调的`off`来取消订阅。要移除该事件名称（或名称）的所有回调，不要向第二个参数提供回调。要移除具有特定上下文的所有回调，请向第三个参数提供上下文：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'If you used a subscription object, just call `off` on the subscription:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用了订阅对象，只需在订阅上调用`off`：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Raising events
  id: totrans-30
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 触发事件
- en: Triggering events on an object is similar to subscribing to them. You can use
    a single event name, multiple space-delimited event names, or trigger all events
    using the special `all` event name.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在对象上触发事件类似于订阅它们。您可以使用单个事件名称、多个用空格分隔的事件名称，或者使用特殊的`all`事件名称来触发所有事件。
- en: 'When events are triggered, they can pass along parameters to the callbacks
    of subscribing events. Though triggered events can use any number of parameters,
    it is much easier to work with callbacks when they always use a single parameter:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件被触发时，它们可以向订阅事件的回调传递参数。尽管触发的事件可以使用任何数量的参数，但当它们始终使用单个参数时，与回调一起工作会更容易：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Proxying events
  id: totrans-34
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代理事件
- en: 'An event proxy is a method that will raise a preselected event (or a list of
    events), passing along its arguments as the event parameters. The following two
    methods are equivalent:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 事件代理是一种方法，它将引发预选事件（或事件列表），并将其参数作为事件参数传递。以下两个方法是等价的：
- en: '[PRE5]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The benefit of proxies is that they are reusable, and they can be stored or
    passed around. This is useful in order to share the proxy with other systems or
    just have a single event-raising function in several places. This practice of
    creating a function to represent another function with a fixed parameter is known
    as **currying**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的优点是它们是可重用的，并且可以被存储或传递。这样做可以与其他系统共享代理，或者只是在几个地方有一个单独的事件引发函数。将一个函数表示为具有固定参数的另一个函数的这种做法被称为**柯里化**。
- en: The event name of a proxy can be any string that `trigger` can use, including
    `all`.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 代理的事件名称可以是`trigger`可以使用的任何字符串，包括`all`。
- en: Application events
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用程序事件
- en: As the `app` object is a singleton that has events included out of the box,
    its events are useful for application-wide messaging. Communication between independent
    top-level components, such as page viewmodels, is a good candidate for app-wide
    messaging.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`app`对象是一个单例，它自带事件，因此这些事件对于应用范围内的消息传递非常有用。独立顶级组件之间的通信，例如页面视图模型，是应用范围内消息传递的良好候选者。
- en: 'Let''s say we wanted to reduce load on the server by raising an event when
    a new contact was added so that the list page could get the new contact without
    going to the server to refresh the whole list. To stop loading the list during
    it''s `activate` method, it will be converted into a singleton that reuses the
    same loading promise:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们希望在添加新联系人时引发一个事件，以减少服务器的负载，这样列表页就可以获取新联系人而无需去服务器刷新整个列表。为了在`activate`方法中停止加载列表，它将被转换为一个单例，该单例重用相同的加载承诺：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: As the promise that is returned to `activate` is only run once, the list will
    not be reloaded when the page is navigated multiple times.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 由于返回给`activate`的承诺只运行一次，因此当页面多次导航时，列表不会重新加载。
- en: 'The list page''s viewmodel now needs to create an event subscription in order
    to receive new contacts. Durandal''s convention for event names is to specify
    the source(s) and event type, separated by colons. This convention is recommended
    but not required; Durandal does not treat colons as delimiters for event names.
    For example, these are two events raised by the router during the navigation:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 列表页的视图模型现在需要创建一个事件订阅来接收新的联系人。Durandal为事件名称的约定是指定源和事件类型，由冒号分隔。此约定是推荐的，但不是必需的；Durandal不会将冒号视为事件名称的分隔符。例如，以下是在导航期间路由器引发的两个事件：
- en: '[PRE7]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'To subscribe to an event for a new contact, the list page can use the following
    subscription:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 要订阅新联系人的事件，列表页可以使用以下订阅：
- en: '[PRE8]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'However, because the only action being taken is to send the `newContact` parameter
    to `contacts.push`, it would be shorter to write it as a callback with a context:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，由于唯一采取的操作是将`newContact`参数发送到`contacts.push`，因此将其作为带有上下文的回调来写会更简洁：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: These two methods are equivalent. It should be noted that the third parameter
    that defines the context is necessary; otherwise, the `push` function will be
    called and will fail without being in the context of the contacts array.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种方法等价。需要注意的是，定义上下文的第三个参数是必要的；否则，`push` 函数将被调用，并且在没有处于联系人数组上下文的情况下失败。
- en: 'The new/edit page can now publish this event using the `contact:added` event
    after it creates a contact:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 新/编辑页面现在可以在创建联系人后使用 `contact:added` 事件发布此事件：
- en: '[PRE10]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This will send you the contact returned from the `createContact` promise as
    the data for the triggered event. However, as this is another case of sending
    a parameter to another single function, it can be written using a proxy:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这将发送 `createContact` 承诺返回的联系人作为触发事件的参数。然而，由于这是将参数发送到另一个单函数的另一个案例，它可以使用代理来编写：
- en: '[PRE11]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: You can see an example of this in the `cp6-pubsub` branch.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `cp6-pubsub` 分支中看到一个示例。
- en: Module-scoped events
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模块作用域的事件
- en: 'In addition to application-wide pub/sub, Durandal provides a simple method
    to add the events methods to any object, allowing events to be scoped. Calling
    `Events.includeIn(obj)` will create the same event handling methods that the `app`
    object has by default: `on`, `off`, `trigger`, and `proxy`.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 除了应用范围内的 pub/sub，Durandal 还提供了一种简单的方法将事件方法添加到任何对象中，允许事件具有作用域。调用 `Events.includeIn(obj)`
    将创建与 `app` 对象默认具有相同的事件处理方法：`on`、`off`、`trigger` 和 `proxy`。
- en: 'The data service is a good candidate for events related to contacts being added
    (or modified), as only the modules that already have a reference to it will be
    interested in these events. Moving the `contact:added` event out of the new/edit
    page into the data service also ensures that the event will still go off if another
    module tries to add a contact:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 数据服务是处理与联系人添加（或修改）相关事件的理想选择，因为只有已经具有对其引用的模块才会对这些事件感兴趣。将 `contact:added` 事件从新/编辑页面移至数据服务也确保了如果另一个模块尝试添加联系人，事件仍然会触发：
- en: '[PRE12]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This will add the event methods to the `dataService` object and raise the `contact:added`
    event in the return promise for the `createContact` method.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 这将为 `dataService` 对象添加事件方法，并在 `createContact` 方法的返回承诺中引发 `contact:added` 事件。
- en: 'The change to the list page viewmodel is just referencing the `dataService`
    object instead of `app` for the event subscription:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 列表页面视图模型的变化只是引用 `dataService` 对象而不是 `app` 进行事件订阅：
- en: '[PRE13]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: That's all that needs to be done. The `dataService` object is now acting as
    an event scope for contacts. You can see this example in the `cp6-event` branch.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 需要做的就这些。现在 `dataService` 对象正在充当联系人事件的作用域。你可以在 `cp6-event` 分支中看到这个示例。
- en: Handling logins
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理登录
- en: 'Handling logins can be tricky for a variety of reasons, and there are hundreds
    of different techniques out there. Web application login generally falls in one
    of two categories: either your site is free to browse without being logged in
    (anytime login), or it uses and requires the user to log in first (gated login).
    The challenges presented by each category are different, and so are the best solutions.'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 由于各种原因，处理登录可能很棘手，而且有数百种不同的技术。Web 应用程序登录通常分为两类：要么你的网站可以自由浏览而不需要登录（随时登录），要么它使用并要求用户首先登录（需要登录）。每个类别所面临的挑战不同，因此最佳解决方案也不同。
- en: Gated login
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 需要登录
- en: Until fairly recently, almost all gated login sites used some redirection pattern
    to present a login page to users, which was usually an unpleasant experience.
    Beyond the issue of page load time, getting back to the originally requested URL
    generally meant query string parameters that contained the original URL. If the
    original URL had query strings itself, they were either lost or appended to the
    URL query value.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 直到最近，几乎所有需要登录的网站都使用某种重定向模式向用户展示登录页面，这通常是一种不愉快的体验。除了页面加载时间的问题之外，返回原始请求的 URL 通常意味着包含原始
    URL 的查询字符串参数。如果原始 URL 本身就有查询字符串，它们要么丢失，要么附加到 URL 查询值上。
- en: 'SPAs can sidestep the redirection problem by just showing a login page at the
    current URL; no redirection means the whole process is faster, there is no hassle
    with the query string, and the user isn''t jarred by the URL changing. They have
    a different challenge, though: what do you do with the shell? You can place the
    login form alongside the shell and switch between them with bindings, but this
    clutters the shell with login markup. You can use a modal dialog to show the login
    form so that the shell is untouched, but then the shell is either blank or shows
    information that should be login-gated.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 单页应用（SPAs）可以通过在当前URL上显示登录页面来绕过重定向问题；没有重定向意味着整个过程更快，没有查询字符串的麻烦，用户也不会因为URL变化而感到不适。然而，他们面临一个不同的挑战：如何处理外壳？你可以将登录表单放在外壳旁边，并通过绑定在它们之间切换，但这会使外壳充满登录标记。你可以使用模态对话框来显示登录表单，这样外壳就不会受到影响，但外壳要么是空的，要么显示应该通过登录才能访问的信息。
- en: 'Durandal''s `setRoot` method really simplifies this problem. If the user needs
    to log in, setting the login form as the root means the shell is never even loaded.
    After the login finishes, the shell can then be set as the root; the shell''s
    markup is left untouched, and the user never sees anything they shouldn''t:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal的`setRoot`方法真正简化了这个问题。如果用户需要登录，将登录表单设置为根意味着外壳甚至不会被加载。登录完成后，外壳可以设置为根；外壳的标记保持不变，用户永远不会看到他们不应该看到的内容：
- en: 'First, our application startup in `main.js` will use `setRoot` to go to either
    the login or the shell, depending on whether the user is already logged in (say,
    from a cookie):'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们的应用程序在`main.js`中的启动将使用`setRoot`跳转到登录或外壳，这取决于用户是否已经登录（比如，来自cookie）：
- en: '[PRE14]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This relies on the `dataService` object, performing a synchronous check to
    see if `isLoggedIn` is `true`, but it can easily support an asynchronous one that''s
    just hooking into the `app.start` promise:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这依赖于`dataService`对象，执行同步检查以查看`isLoggedIn`是否为`true`，但它可以轻松支持一个异步的，只需将其钩入`app.start`承诺：
- en: '[PRE15]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Once the login process is complete, the login viewmodel can just call `setRoot`
    for the shell. That's it! In fact, the only other properties in the login viewmodel
    are the ones for `username`, `password`, and a failed sign-in flag. After the
    login completes, the shell will start up just like it did previously, activate
    the router, and compose the correct page. There is no need to worry about managing
    an empty state while the login happens, as the shell is never loaded until `setRoot`
    is called on it.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦登录过程完成，登录视图模型只需调用`setRoot`来设置外壳。就是这样！实际上，登录视图模型中唯一的其他属性是`username`、`password`和失败的登录标志。登录完成后，外壳将像之前一样启动，激活路由器，并组合正确的页面。在登录发生时，无需担心管理空状态，因为外壳直到`setRoot`被调用之前都不会被加载。
- en: You can see an example of this in the `cp6-login` branch. The login module contains
    a standard viewmodel and view. To log in, use any login details where the username
    and password are the same. Obviously, in a real application, you would want to
    create a server request.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cp6-login`分支中看到这个示例。登录模块包含一个标准的视图模型和视图。要登录，可以使用任何登录详情，其中用户名和密码相同。显然，在实际应用中，你希望创建一个服务器请求。
- en: 'One thing that is important to note is the logout function. It''s in the shell
    in the sample, but in a real application, it should be refactored into an external
    service—probably the same one that holds the methods used to get and set the login
    cookie in order to centralize the login behaviors. In SPAs, because navigation
    isn''t occurring, it can be a challenge to clean up all of the data a logged-in
    user has in the application state, especially when you have singletons. Trying
    to create a cleanup method that removes all of this data is prone to errors; it''s
    easy to miss out on important bits of data, and it requires constant maintenance
    as the application grows. Instead, it''s much safer to just reload the browser.
    Navigation, even if it''s a refresh, completely resets the JavaScript state, guaranteeing
    that nothing from the previously logged-in user is left in the memory. The `location.reload`
    method is a simple way to do this, but it might not be the best approach if the
    user is on a page with a sensitive URL. A safer approach would be to set the location
    to the domain root:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的一个重要问题是注销功能。在示例中，它位于外壳中，但在实际应用中，它应该重构为外部服务——可能是同一个服务，该服务包含用于获取和设置登录cookie的方法，以便集中管理登录行为。在单页应用（SPAs）中，由于没有发生导航，清理登录用户在应用状态中的所有数据可能是一个挑战，尤其是当你有单例时。尝试创建一个删除所有这些数据的方法容易出错；很容易遗漏重要数据，并且随着应用的扩展，需要不断维护。相反，简单地重新加载浏览器会更安全。导航，即使是刷新，也会完全重置JavaScript状态，确保之前登录用户的所有内容都不会留在内存中。`location.reload`方法是一个简单的方法来实现这一点，但如果用户在包含敏感URL的页面上，这可能不是最佳方法。一个更安全的方法是将位置设置为域名根：
- en: '[PRE16]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Anytime login
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 任何时间登录
- en: Sites that allow users to browse and optionally log in have different challenges
    compared to gated login sites. Some sites that allow optional login still have
    a separate login page and still use redirection parameters to get the user back
    to their original location, but this experience is even more unpleasant for the
    user, as it seems unnecessary. Of course, it might be required if you allow browsing
    over HTTP and require a redirect for HTTPS to perform the login, but this is all
    the more reason to always require HTTPS! If you take the redirection route to
    get to an HTTPS page, then even the preceding method will not work for you, as
    the preceding method doesn't use browser navigation to change the page.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 允许用户浏览和可选登录的网站与门控登录网站相比面临不同的挑战。一些允许可选登录的网站仍然有单独的登录页面，并仍然使用重定向参数将用户送回原始位置，但这对用户来说体验更加不愉快，因为它似乎是不必要的。当然，如果你允许通过HTTP浏览并需要重定向到HTTPS以执行登录，这可能就是必要的，但这更是始终要求使用HTTPS的理由！如果你选择重定向路径到达HTTPS页面，那么前面的方法对你来说也将不起作用，因为前面的方法没有使用浏览器导航来更改页面。
- en: If you always require HTTPS for normal browsing, then you can allow the user
    to log in without interfering with the current page. You can use the same technique
    that gated login uses, but without the need to hide post-login information, there
    are less intrusive methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你总是需要在正常浏览时使用HTTPS，那么你可以允许用户登录而不干扰当前页面。你可以使用与门控登录相同的技巧，但不需要隐藏登录后的信息，有更不侵入性的方法。
- en: A common method, and one of the least intrusive, is to include an inline login
    form in the navigation bar.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 一种常见的方法，也是最不侵入性的方法之一，是在导航栏中包含一个内联登录表单。
- en: '![Anytime login](img/00015.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![任何时间登录](img/00015.jpeg)'
- en: 'Once logged in, the navigation bar would appear the same as the previous navigation
    bar with the login name and the logout button. This small section of the navigation
    bar can be backed by a login viewmodel that is composed into the shell, which
    keeps the login implementation details separate:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 登录后，导航栏将与之前的导航栏相同，显示登录名和注销按钮。这个导航栏的小部分可以由一个登录视图模型支持，该模型被组合到外壳中，从而将登录实现细节分离：
- en: '[PRE17]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The login viewmodel doesn't need to change much for this, but the logout functionality
    can be moved into it as it no longer is controlled by the shell. You can see an
    example of this in the `cp6-login-nav` branch. Try logging in and notice how the
    navigation bar changes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此功能，登录视图模型不需要做太多改变，但注销功能可以移动到其中，因为它不再由外壳控制。你可以在`cp6-login-nav`分支中看到一个例子。尝试登录并注意导航栏如何变化。
- en: Responding to the user's login changes
  id: totrans-86
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 响应用户的登录变化
- en: 'The inline login form works, but it is likely that your application will need
    to respond to the newly logged-in user in some way, for example, letting only
    logged in users create, edit, or delete contacts. There are two ways to handle
    this: either use some combination of events and Knockout observables to update
    the page, or reload the page when the user logs in.'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 内联登录表单是有效的，但你的应用程序可能需要以某种方式响应当前登录的用户，例如，只允许登录用户创建、编辑或删除联系人。有两种处理方式：要么使用一些事件和Knockout可观察对象的组合来更新页面，要么在用户登录时重新加载页面。
- en: It might be simpler to take the page reload route, but it really depends on
    your application. If you use anytime login and allow users to see most pages without
    being logged in, you might not be maintaining two separate versions of each page.
    Instead, you might have `if/visible` bindings hiding the logged-in-only content.
    If that is the case, then updating these observables won't be too much effort.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 可能采取页面重新加载的路线会更简单，但这实际上取决于你的应用程序。如果你使用任意登录并允许用户在不登录的情况下查看大多数页面，你可能不需要维护每个页面的两个独立版本。相反，你可能使用`if/visible`绑定来隐藏仅限登录用户的内容。如果是这种情况，那么更新这些可观察对象不会太费力。
- en: However, if you are maintaining two separate versions of each page because they
    are different enough for logged-in users, the page reload method is a better bet.
    As the reload route doesn't take much explaining, let's look at the first case.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你因为登录用户和未登录用户之间的差异足够大，而维护每个页面的两个独立版本，那么页面重新加载的方法可能更好。由于重新加载路由不需要太多解释，让我们看看第一个案例。
- en: 'For the simple case of hiding the edit controls, Knockout observables are perfectly
    sufficient. The login-checking function in the data service is a good place to
    put observables that multiple viewmodels will depend on, as it is already a shared
    component. In a larger application, you might want to separate the data service
    into multiple services in order to serve specific roles such as login and contact
    CRUD:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 对于隐藏编辑控件这种简单情况，Knockout可观察对象就足够了。数据服务中的登录检查函数是一个很好的地方来放置多个视图模型将依赖的可观察对象，因为它已经是一个共享组件。在更大的应用程序中，你可能想要将数据服务分成多个服务，以服务于特定的角色，如登录和联系人CRUD：
- en: '[PRE18]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Here, `loginName` determines whether or not `isLoggedIn` is `true`. The `loginName`
    parameter is set initially if storage has a saved token, and it is updated when
    the user logs in or out. There are three places that need to use one of these
    fields: the list page, the list items, and the shell. The list page will use it
    to expose whether or not a user can edit contacts:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`loginName`决定`isLoggedIn`是否为`true`。如果存储中有保存的令牌，则初始设置`loginName`参数，并在用户登录或注销时更新。需要使用这些字段中的任何一个的地方有三个：列表页面、列表项和外壳。列表页面将使用它来显示用户是否可以编辑联系人：
- en: '[PRE19]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This property is used by the list of items in order to hide or show the buttons:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这个属性被项目列表用来隐藏或显示按钮：
- en: '[PRE20]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'For additional safety, the methods backing these buttons should also check
    the `canEdit` property. The `delete` button is not shown, but it uses the same
    check as what is shown in the following code:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 为了额外的安全性，这些按钮背后的方法也应该检查`canEdit`属性。`delete`按钮没有显示，但它使用与以下代码中显示的相同的检查：
- en: '[PRE21]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Likewise, to ensure that the user cannot get to the edit page by manually entering
    the URL, it should use a `canActivate` check to block navigation for anonymous
    users:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，为了确保用户不能通过手动输入URL来访问编辑页面，它应该使用`canActivate`检查来阻止匿名用户的导航：
- en: '[PRE22]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, the shell will want to remove the route from the navigation bar when
    the user is not logged in. One way to do this is to create a computed observable
    array on the shell that filters out routes when the user isn''t logged in:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，外壳希望在用户未登录时从导航栏中删除路由。一种方法是在外壳上创建一个计算的可观察数组，在用户未登录时过滤掉路由：
- en: '[PRE23]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This model will remove any route with an `auth: true` property when the user
    is not logged in, which makes it easy to add pages that require login in the future.'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '这个模型将在用户未登录时删除任何具有`auth: true`属性的路线，这使得将来添加需要登录的页面变得容易。'
- en: This example can be seen in the `cp6-login-event` branch. To make it easy to
    see the logout transition, this branch does not reload the page when the user
    logs out; instead, it just clears storage and updates the observables on the data
    service.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在`cp6-login-event`分支中看到。为了便于看到注销过渡，这个分支在用户注销时不会重新加载页面；相反，它只是清除存储并更新数据服务上的可观察对象。
- en: Guarded routes
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护路由
- en: In the previous section, we used a `canActivate` check on a page viewmodel to
    ensure that users could only get to the page when they were logged in. This works,
    but if multiple pages need to be gated, or we need to use logic that the page
    might not have, it is possible to add this logic to the router.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们使用页面视图模型上的`canActivate`检查来确保用户只有在登录时才能访问页面。这很有效，但如果需要为多个页面设置门控，或者需要使用页面可能没有的逻辑，则可以将此逻辑添加到路由器中。
- en: 'The `guardRoute` method is an optional method that the router will use to screen
    every attempted navigation. It receives the module being activated and the route
    instruction as parameters. If `true`, or a promise for true, is returned from
    `guardRoute`, then navigation continues normally. If a string or a promise for
    a string is returned, it will be used as a redirection route. If `false` or a
    promise for false is returned, then navigation is cancelled:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`guardRoute`方法是一个可选方法，路由器将使用它来筛选每个尝试的导航。它接收正在激活的模块和路由指令作为参数。如果从`guardRoute`返回`true`或对`true`的承诺，则导航将正常继续。如果返回一个字符串或对字符串的承诺，它将被用作重定向路由。如果返回`false`或对`false`的承诺，则导航将被取消：'
- en: '[PRE24]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'This router guard can replace the `canActivate` method on the edit page, as
    it will cancel navigation when the route has `auth:true` and the user is not logged
    in. However, canceling navigation can sometimes appear to users as the application
    not responding, such as when the back button is pressed. It can be improved by
    redirecting the current page to the error page instead:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 此路由守卫可以替换编辑页面的`canActivate`方法，因为它将在路由有`auth:true`且用户未登录时取消导航。然而，取消导航有时可能看起来像是应用程序没有响应，例如当按下后退按钮时。可以通过将当前页面重定向到错误页面来改进：
- en: '[PRE25]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: This example can be seen in the `cp6-guard-route` branch.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在`cp6-guard-route`分支中看到。
- en: Advanced composition
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 高级组成
- en: In [Chapter 5](part0041_split_000.html#page "Chapter 5. Durandal – the Knockout
    Framework"), *Durandal – the Knockout Framework*, we covered the basic and common
    uses of Durandal's composition system. This section will cover further composition
    techniques such as caching, transitions, and composition mode.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](part0041_split_000.html#page "第5章. Durandal – Knockout 框架")中，我们介绍了Durandal的组成系统的基本和常用用法。本节将介绍进一步的组成技术，如缓存、转换和组成模式。
- en: View caching
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视图缓存
- en: 'By default, the view rendered by the composition binding is discarded when
    the composed module is changed. This results in the DOM contents of the composition
    binding always being only the current module''s view. The `cacheView` option on
    the composed binding will change this behavior so that Durandal can keep any view
    composed. If a module is reactivated using the same object that is already bound
    to a view, it will not be recreated. Both the `compose` and `router` bindings
    have this option:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，当组成模块更改时，由组成绑定渲染的视图将被丢弃。这导致组成绑定的DOM内容始终只是当前模块的视图。组成绑定上的`cacheView`选项将改变此行为，使Durandal可以保留任何组成的视图。如果使用已绑定到视图的相同对象重新激活模块，则不会重新创建。`compose`和`router`绑定都具有此选项：
- en: '[PRE26]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You can see an example of this in the `cp6-cache` branch. If you open the console,
    you can see that the attaching and binding events are no longer being raised when
    revisiting the list or edit pages. You can also see, with a debugger breakpoint,
    that the viewmodels are only being constructed the first time.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cp6-cache`分支中看到这个示例。如果你打开控制台，你可以看到在重新访问列表或编辑页面时，不再触发附加和绑定事件。你还可以通过调试器断点看到，视图模型只会在第一次构建。
- en: 'When working with cached views, extra caution is required. As the module is
    a singleton and is only constructed once, the `activate` method is responsible
    for setting up data or clearing old data out. For example, previously, the edit
    page only set its `contact` property to a new instance during the construction.
    The `activate` method needs to reset the contact if the page is being loaded in
    a new entry mode (without an ID):'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 当与缓存视图一起工作时，需要格外小心。由于模块是单例且仅构建一次，因此`activate`方法负责设置数据或清除旧数据。例如，以前，编辑页面仅在构建期间将其`contact`属性设置为新的实例。如果页面是在新条目模式下（没有ID）加载的，则需要重置联系人：
- en: '[PRE27]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: If this isn't done, users will not see an empty form if they tried to create
    a contact after creating or editing a previous one.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不这样做，用户在创建或编辑了之前的联系人后尝试创建新的联系人时，将不会看到空表单。
- en: Even if the `cacheViews` property is set to `true`, Durandal will not cache
    a DOM view if the model instance has changed. In the `cp6-cache2` branch, the
    constructor is returned from the list page, and you can see that a new instance
    is constructed and attached to the DOM despite `cacheViews` being set.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 即使将 `cacheViews` 属性设置为 `true`，如果模型实例已更改，Durandal 也不会缓存 DOM 视图。在 `cp6-cache2`
    分支中，构造函数从列表页面返回，你可以看到即使 `cacheViews` 已设置，仍然会构建一个新的实例并将其附加到 DOM 上。
- en: Transitions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 过渡
- en: 'Durandal''s `router` and `compose` bindings have a hook that allows the composed
    view to transition with an animation. To use it, provide a value to the `transition`
    property on the binding:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 的 `router` 和 `compose` 绑定有一个钩子，允许组合视图使用动画进行过渡。要使用它，请在绑定上的 `transition`
    属性提供值：
- en: '[PRE28]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The `entrance` transition is provided by default; it fades the current view
    out and fades in the next view with a small slide effect. You can see it in the
    `cp6-entrance` branch. Note that for this animation to work, the composition needs
    to occur in an element with the CSS `position: relative` property, as the animation
    uses absolute positioning.'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '默认提供 `entrance` 过渡；它通过轻微的滑动效果淡出当前视图并淡入下一个视图。你可以在 `cp6-entrance` 分支中看到它。请注意，为了使此动画正常工作，组合需要在具有
    CSS `position: relative` 属性的元素中发生，因为动画使用绝对定位。'
- en: The `durandal/composition` module also has a `defaultTransitionName` property
    that will use the supplied transition for all compositions that do not specify
    their own transitions.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`durandal/composition` 模块还有一个 `defaultTransitionName` 属性，它将为所有未指定自己过渡的所有组合使用提供的过渡。'
- en: To create your own transition, you need a module that returns a function that
    Durandal can call in order to run the transition. The transition function will
    receive the composition settings and needs to return a promise for its completion.
    There are a lot of values on the settings object but the two that are most useful
    are `activeView`, which is the view being transition out, and `child`, which is
    the view being transitioned to.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建自己的过渡，你需要一个模块，该模块返回一个 Durandal 可以调用来运行过渡的函数。过渡函数将接收组合设置并需要返回一个表示其完成的承诺。设置对象中有许多值，但最有用的两个是
    `activeView`，它是正在过渡出的视图，以及 `child`，它是正在过渡到的视图。
- en: 'Here is an example of a custom transition that uses the jQuery UI''s slide
    effects. It assumes that jQueryUI has already been set up in RequireJS:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用 jQuery UI 的滑动效果的定制过渡示例。它假设 jQueryUI 已经在 RequireJS 中设置好：
- en: '[PRE29]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The module returns the animation function, which itself returns a promise for
    the animation. The animation function pulls out the current and next view and
    then sets up callbacks in order to end the view and slide in the new view with
    jQuery. The `if` block at the end ensures that the current view is only acted
    upon when it exists. If it doesn't, then no animation is created (as there is
    nothing to slide out), and the view is just shown.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 该模块返回动画函数，该函数本身返回一个表示动画的承诺。动画函数提取当前视图和下一个视图，然后设置回调以使用 jQuery 结束视图并滑动新视图。最后的
    `if` 块确保只有当当前视图存在时才对其执行操作。如果不存在，则不会创建动画（因为没有东西可以滑动出去），视图将直接显示。
- en: By default, Durandal looks for transitions by appending `'transitions/'` to
    their name in order to get a RequireJS path. This is why the standard Durandal
    RequireJS configuration has a transitions path defined. You can map the path in
    RequireJS to another folder if you want to keep transitions somewhere else—such
    as your `app` folder—or you can override the composition module's `convertTransitionToModuleId`
    function to provide your own lookup logic.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，Durandal 通过在名称后附加 `'transitions/'` 来查找过渡，以获取 RequireJS 路径。这就是为什么标准的 Durandal
    RequireJS 配置中定义了过渡路径。如果你想将过渡保存在其他位置（如 `app` 文件夹），则可以在 RequireJS 中将路径映射到另一个文件夹，或者你可以覆盖组合模块的
    `convertTransitionToModuleId` 函数以提供自己的查找逻辑。
- en: This example can be seen in the `cp6-transition` branch. This branch uses a
    RequireJS path for a `transitions` folder in the `app` directory, which contains
    the preceding slide animation.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例可以在 `cp6-transition` 分支中看到。此分支使用 `app` 目录中 `transitions` 文件夹的 RequireJS 路径，该文件夹包含前面的滑动动画。
- en: The templated mode
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 模板模式
- en: 'In the previous chapter, we covered widgets, which offer us the ability to
    override sections of the composed element with `data-part` attributes. This feature
    is also available in viewmodel composition using the binding `mode: ''templated''`
    option.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '在上一章中，我们介绍了小部件，它通过使用 `data-part` 属性覆盖组合元素的部分来提供功能。此功能也适用于使用 `mode: ''templated''`
    选项的 viewmodel 组合。'
- en: The example widget that was used was a bit contrived, as the list of contacts
    isn't really a reusable widget. A more common technique with lists, especially
    with complex items, is to create a module for the list item and compose it with
    a `foreach` binding.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用的示例小部件有些牵强，因为联系人列表并不是一个可重用的部件。对于列表，尤其是复杂项，更常见的技巧是为列表项创建一个模块，并通过`foreach`绑定来组合它。
- en: Separating complex list items from the page they are shown in keeps properties
    and methods specific to the list item that is not on the page. This is the same
    modularization logic that drives the separation of viewmodels and modules. It
    lets the page viewmodel focus more on the actions the page takes as a whole and
    lets the item focus on itself. The contact list items aren't complex enough to
    warrant this, but I'm sure you can imagine such a case.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 将复杂列表项与其显示的页面分开，可以保持列表项特有的属性和方法。这是驱动视图模型和模块分离的相同模块化逻辑。它让页面视图模型更多地关注页面整体采取的动作，并让项目专注于自身。联系人列表项并不复杂到需要这样做，但你可以想象出这样的案例。
- en: 'Replacing the contact list widget with a `compose/foreach` binding is simple:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 将联系人列表小部件替换为`compose/foreach`绑定很简单：
- en: '[PRE30]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'This allows the item itself to be moved into its own file, which is `listItem.html`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许将项目本身移动到自己的文件中，即`listItem.html`：
- en: '[PRE31]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'This is the same template that was used previously, minus the delete button.
    The viewmodel for the list item is simple, containing just a `contact` object
    and an `edit` function:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这是之前使用的相同模板，只是没有删除按钮。列表项的视图模型很简单，只包含一个`contact`对象和一个`edit`函数：
- en: '[PRE32]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'The last thing to do is construct the list item on the list page instead of
    just using the bare contact model:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要做的事情是在列表页面上构建列表项，而不仅仅是使用裸露的联系人模型：
- en: '[PRE33]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'You can see this example in the `cp6-list-item` branch. This is just the setup,
    though; what we are really after is overriding the list item view with `data-part`
    attributes. Data-part overriding works the same way with compositions as it works
    with widgets:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cp6-list-item`分支中看到这个示例。这只是一个设置，但真正追求的是通过`data-part`属性覆盖列表项视图。数据部分覆盖在组合中与在部件中工作方式相同：
- en: '[PRE34]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Here, the entire `btn-container` element is being overridden so that a delete
    button can be added. Remember, the scope of `data-part` attributes is the view
    they will be placed into, which is `listItem` in this case. The `edit` function
    is already in this scope, but the `deleteContact` function is in the parent of
    `listItem`, which can be accessed using the `$root` property of the templated
    elements.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，整个`btn-container`元素被覆盖，以便添加删除按钮。记住，`data-part`属性的作用域是它们将被放置的视图，在这种情况下是`listItem`。`edit`函数已经在这个作用域中，但`deleteContact`函数在`listItem`的父级中，可以使用模板元素的`$root`属性来访问。
- en: This example can be seen in the `cp6-template-compose` branch.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例可以在`cp6-template-compose`分支中看到。
- en: Child routers
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 子路由
- en: Another common scenario is the need to support routes within routes; this is
    sometimes called **nested** or **child** routes. For example, you might have multiple
    pages under the parent `/about` route that are represented by the `/about/author`
    and `/about/publisher` URLs, which are displayed as different subsections of the
    main `/about` page.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见场景是需要支持路由内的路由；这有时被称为**嵌套**或**子**路由。例如，你可能有多个页面位于父`/about`路由下，这些页面由`/about/author`和`/about/publisher`
    URL表示，它们被显示为主`/about`页面的不同子部分。
- en: 'To do this, the parent route has to capture child routes. It can do this with
    a splat route or with the `hasChildRoutes` property:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，父路由必须捕获子路由。它可以使用通配符路由或`hasChildRoutes`属性来完成：
- en: '[PRE35]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Either way is fine, but note that the `about*children` splat route requires
    at least one character after the asterisk (`*`); the `about*` route will not capture
    the children properly. Personally, I think the `hasChildRoutes` property has a
    clearer intention.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 两种方式都行，但请注意，`about*children`通配符路由需要在星号（`*`）之后至少有一个字符；`about*`路由无法正确捕获子路由。我个人认为`hasChildRoutes`属性有更明确的目的。
- en: 'Next, the viewmodel that exposes child routes creates a child router:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建子路由的视图模型创建一个子路由：
- en: '[PRE36]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The `createChildRouter` function returns the child router of the root router.
    You can only have one root router, but it can have any number of children, and
    children routers can have children routers as well.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: '`createChildRouter`函数返回根路由的子路由。你只能有一个根路由，但它可以有任意数量的子路由，子路由也可以有子路由。'
- en: The `makeRelative` function takes an optional object. The `moduleId` option
    instructs all the modules of children routes to be prefixed with the supplied
    module, essentially making the routes relative to a folder. This is not required,
    but it keeps the routes shorter. The `fromParent` option causes children routes
    to inherit their parent's URL from the `route` property.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`makeRelative` 函数接受一个可选对象。`moduleId` 选项指示所有子路由的模块都以前缀提供的模块开头，本质上使路由相对于一个文件夹。这不是必需的，但它可以使路由更短。`fromParent`
    选项使子路由从 `route` 属性继承其父级的URL。'
- en: 'Finally, the module exposes `childRouter` as the router so that its view can
    bind to it using the same syntax that was used by the shell. This is the view
    for the `about` parent page:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该模块将 `childRouter` 作为路由暴露，以便其视图可以使用与shell相同的语法绑定到它。这是 `about` 父页面的视图：
- en: '[PRE37]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: This example can be seen in the `cp6-child-router` branch. The about page and
    its child routes are in the `app/about` folder, and the route has been added to
    the navigation bar.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这个例子可以在 `cp6-child-router` 分支中看到。关于页面及其子路由位于 `app/about` 文件夹中，并且路由已经被添加到导航栏中。
- en: Dynamic child routes
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动态子路由
- en: When creating child routes for a parent route with a parameter, such as `/contacts/23/bio`,
    additional configuration is required in order to allow the child routes to be
    relative to the `/contacts/:id` dynamic parent. To see an example of this, we
    are going to add a biography and location section to our contact pages.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 当为具有参数的父路由创建子路由，例如 `/contacts/23/bio`，需要额外的配置才能允许子路由相对于 `/contacts/:id` 动态父路由。为了看到这个例子，我们将向我们的联系人页面添加一个传记和位置部分。
- en: 'The contact edit route needs to indicate that it has child routes. The same
    options are available, but there is a caveat for splat routes—you must specify
    a `hash` manually:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 联系人编辑路由需要表明它有子路由。相同的选项可用，但对于splat路由有一个注意事项——你必须手动指定 `hash`：
- en: '[PRE38]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The children routers will not be able to create a proper URL from a splat route
    if the hash is not specified manually. This does not need to be done if you're
    using the `hasChildRoutes` flag.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有手动指定hash，子路由将无法从splat路由创建正确的URL。如果你使用 `hasChildRoutes` 标志，则不需要这样做。
- en: 'The child router definition is almost identical, except for the `dynamicHash`
    property:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 子路由定义几乎相同，除了 `dynamicHash` 属性：
- en: '[PRE39]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The `dynamicHash` property controls how the URLs for child routes are created,
    as they need to include the `route` parameter. That's all it takes, though! After
    this, the routes can be used on the parameterized URL.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`dynamicHash` 属性控制子路由URL的创建方式，因为它们需要包含 `route` 参数。但这就足够了！之后，这些路由就可以在参数化URL上使用了。'
- en: You can see an example of this in the `cp6-dynamic-child-routes` branch. The
    edit page's child routes have been placed for organization in the `contacts/edit`
    folder. Also, the biography and location pages just contain dummy text.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 `cp6-dynamic-child-routes` 分支中看到这个例子。编辑页面的子路由已经被放置在 `contacts/edit` 文件夹中以进行组织。此外，传记和位置页面仅包含占位文本。
- en: Custom modal dialogs
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 自定义模态对话框
- en: In Durandal, a dialog context is the viewmodel that controls a modal dialog.
    It has a method used to add the modal dialog host, which is the DOM node inside
    which the modal content will be placed.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在Durandal中，对话上下文是控制模态对话框的viewmodel。它有一个用于添加模态对话框宿主的方法，即模态内容将被放置在内的DOM节点。
- en: 'Durandal offers two modal dialogs out of the box: message boxes and the default
    context. The message box that Durandal offers adds some simple DOM elements to
    the default context and is very useful in order to show short messages to the
    user. The default dialog context can host any composable module, including message
    boxes. If you want to use your own dialog box, such as the one included in Twitter
    Bootstrap, it is possible to add it as a dialog context.'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal提供了两个模态对话框：消息框和默认上下文。Durandal提供的消息框向默认上下文添加了一些简单的DOM元素，这对于向用户显示简短消息非常有用。默认对话框上下文可以托管任何可组合模块，包括消息框。如果你想使用自己的对话框，例如Twitter
    Bootstrap中包含的对话框，可以将其添加为对话框上下文。
- en: 'A dialog context is an object that can create a dialog in the DOM to which
    the composition can add content. A custom context uses the following APIs:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 对话上下文是一个对象，可以在DOM中创建一个对话，其中内容可以添加。自定义上下文使用以下API：
- en: '`addHost(dialog)`: This function is responsible for creating the dialog itself,
    by adding it to the DOM. It must assign the `dialog.host` property on the parameter
    to this DOM node, which will be used by composition as the parent for the composing
    module.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`addHost(dialog)`: 此函数负责创建对话框本身，通过将其添加到 DOM 中。它必须将参数中的 `dialog.host` 属性分配给此
    DOM 节点，该节点将被用作组合的父节点，用于组成模块。'
- en: '`removeHost(dialog)`: This function removes the DOM for the dialog and performs
    any cleanup.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`removeHost(dialog)`: 此函数移除对话框的 DOM 并执行任何清理操作。'
- en: '`compositionComplete(child, parent, context)`: This is a composition hook that
    the context can use to perform any setup. To get the `dialog` object (the parameter
    from the other two functions), call `dialog.getDialog(context.model)`.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`compositionComplete(child, parent, context)`: 这是一个组合钩子，上下文可以使用它来执行任何设置。要获取
    `dialog` 对象（来自其他两个函数的参数），请调用 `dialog.getDialog(context.model)`。'
- en: Custom dialog contexts are useful when you have different needs for modal windows.
    The Twitter Bootstrap dialog, for example, uses the same responsive CSS system
    that the rest of the Bootstrap framework uses, making it perfect for dialogs that
    need to be usable on desktops and phones. You might also want some of your dialogs
    to be displayed in a circular pop up in order to differentiate them from other
    modals your application is using.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 当您对模态窗口有不同的需求时，自定义对话框上下文非常有用。例如，Twitter Bootstrap 对话框使用与 Bootstrap 框架其余部分相同的响应式
    CSS 系统，使其非常适合需要在桌面和手机上使用的对话框。您可能还希望将一些对话框显示为圆形弹出窗口，以便与其他应用程序使用的模态框区分开来。
- en: 'Working with custom dialogs is done using the `dialog` module, which is injected
    using `''plugins/dialog''`. You can add a custom dialog context with the `dialog.addContext`
    function, which takes a context that matches the preceding API. The first parameter
    is the name of the new context, and the second is the context object:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 使用自定义对话框是通过 `dialog` 模块完成的，该模块使用 `'plugins/dialog'` 注入。您可以使用 `dialog.addContext`
    函数添加自定义对话框上下文，该函数接受与先前 API 匹配的上下文。第一个参数是新上下文名称，第二个是上下文对象：
- en: '[PRE40]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This setup needs to be done before the dialog can be used, so it is good to
    do it with any app setup. In the upcoming example, this will be in the `common/extensions`
    module.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在可以使用对话框之前，需要完成此设置，因此在任何应用程序设置中都进行此操作是很好的。在即将到来的示例中，这将在 `common/extensions`
    模块中完成。
- en: 'The actual setup logic for each of the context methods depends on the dialog
    you are adding. This is what the Bootstrap modal setup will look like:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 每个上下文方法的实际设置逻辑取决于您添加的对话框。这就是 Bootstrap 模态框设置的样貌：
- en: '[PRE41]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Unlike the Durandal modal, where the content container and the dialog element
    are the same, the Bootstrap modal expects the content container to be inside the
    dialog element. The content''s DOM element is placed in the `dialogInstance.host`
    property, which Durandal will use to compose the module. The outer modal element
    is stored in the `modalHost` property, which will only be used by functions on
    our custom Bootstrap context:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Durandal 模态框不同，其中内容容器和对话框元素相同，Bootstrap 模态框期望内容容器位于对话框元素内部。内容的 DOM 元素放置在 `dialogInstance.host`
    属性中，Durandal 将使用它来组成模块。外部的模态框元素存储在 `modalHost` 属性中，它将仅由我们自定义的 Bootstrap 上下文中的函数使用：
- en: '[PRE42]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'This is where the actual Bootstrap `$.modal()` code is run from, as the sizing
    and placement of the modal will need to have a fully composed module that already
    exists. It uses the `modalHost` property and not the `host` property, as Bootstrap
    is expecting the modal container. Additionally, the handler is set up to support
    the standard Durandal autofocus and autoclose classes:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 这是从实际运行 Bootstrap `$.modal()` 代码的地方，因为模态框的大小和位置需要已经存在的一个完全组成的模块。它使用 `modalHost`
    属性而不是 `host` 属性，因为 Bootstrap 期望模态容器。此外，处理程序被设置为支持标准的 Durandal 自动聚焦和自动关闭类：
- en: '[PRE43]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: The `removeHost` function takes the steps that are required to hide the modal
    and the backdrop.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`removeHost` 函数负责执行隐藏模态框和背景所需的步骤。'
- en: 'Finally, we use this new modal by specifying the context parameter on `dialog.show`
    in the edit contact viewmodel:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在编辑联系人视图模型中通过指定 `dialog.show` 的上下文参数来使用这个新的模态框：
- en: '[PRE44]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: If you look in the `cp6-bootstrap-dialog` branch, this context will be added.
    The modal dialog from [Chapter 5](part0041_split_000.html#page "Chapter 5. Durandal
    – the Knockout Framework"), *Durandal – the Knockout Framework*, that opens when
    the **Add Contact** button on the list page is pressed has been restored. You
    can see that this new dialog has the Bootstrap sliding entrance animation, and
    the content is responsive.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看`cp6-bootstrap-dialog`分支，这个上下文将被添加。当按下列表页上的**添加联系人**按钮时，会打开的来自[第5章](part0041_split_000.html#page
    "第5章. Durandal – Knockout 框架")，*Durandal – Knockout 框架*的模态对话框已被恢复。你可以看到这个新的对话框具有Bootstrap滑动进入动画，内容是响应式的。
- en: 'There is another method that can be used to show custom dialogs. The `addContext`
    method automatically creates a helper method using the context name. For the Bootstrap
    context, the method is `dialog.showBootrap`:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个可以用来显示自定义对话框的方法。`addContext`方法会自动使用上下文名称创建一个辅助方法。对于Bootstrap上下文，该方法为`dialog.showBootrap`：
- en: '[PRE45]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: You can see this example in the `cp6-bootstrap-dialog2` branch.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`cp6-bootstrap-dialog2`分支中看到这个示例。
- en: Replacing the default context
  id: totrans-193
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换默认上下文
- en: 'Having multiple dialog contexts is certainly useful, but if you are adding
    a custom dialog context, chances are you want it to be the default dialog context.
    Having a Bootstrap modal dialog is great, but the standard message boxes are still
    using the nonresponse Durandal context. To change this, just replace the `dialog.show`
    method with one that specifies your context when one isn''t explicitly provided:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有多个对话框上下文当然很有用，但如果你正在添加自定义对话框上下文，那么很可能你希望它成为默认的对话框上下文。拥有一个Bootstrap模态对话框很棒，但标准消息框仍然使用非响应的Durandal上下文。要更改这一点，只需将`dialog.show`方法替换为在未明确提供上下文时指定你的上下文的方法：
- en: '[PRE46]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'This will cause all regular calls to the dialog module to use this context
    without affecting the ability of the code to manually control which dialog context
    is used for special scenarios:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 这将导致所有常规调用对话框模块都使用此上下文，而不会影响代码手动控制用于特殊场景的对话框上下文的能力：
- en: '[PRE47]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the `cp6-bootstrap-dailog3` branch, you can see that the delete confirmation
    message box as well as the add contact modal uses the Bootstrap dialog context.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在`cp6-bootstrap-dailog3`分支中，你可以看到删除确认消息框以及添加联系人的模态对话框都使用了Bootstrap对话框上下文。
- en: 'If you still need access to the default context, consider adding a conventional
    helper to the dialog object, such as `dialog.showDefault` or `dialog.showOld`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你仍然需要访问默认上下文，考虑向对话框对象添加一个常规辅助函数，例如`dialog.showDefault`或`dialog.showOld`：
- en: '[PRE48]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Using activators
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用激活器
- en: The activation life cycle is automatically used by the router, but sometimes,
    you want to use it without tying the work to the URL, which turns out to be quite
    easy. An activator is just a computed observable whose write function enforces
    the life cycle. An activator can be created by calling `activator.create()` using
    the `durandal/activator` module.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 路由器会自动使用激活生命周期，但有时你希望在不需要将工作绑定到URL的情况下使用它，这实际上相当简单。激活器只是一个计算可观察的，其写入函数强制执行生命周期。可以通过调用`durandal/activator`模块中的`activator.create()`来创建激活器。
- en: For this example, we are going to add an inline *quick edit* to the list page
    that will allow contacts to be edited without navigating to another page. It will
    leverage the existing edit page viewmodel with some minor changes, as it already
    has a `canDeactivate` method that prompts the user with a confirmation modal when
    unsaved changes are present. The list page activator will hook into the same logic
    automatically.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，我们将在列表页添加一个内联*快速编辑*，允许在不导航到另一个页面的情况下编辑联系人。它将利用现有的编辑页面视图模型进行一些小的修改，因为它已经有一个`canDeactivate`方法，当存在未保存的更改时，会通过确认模态对话框提示用户。列表页的激活器将自动挂钩到相同的逻辑。
- en: This example is in the `cp6-activator` branch. You might want to play with it
    a bit before we go into how it works. Just use the quick edit button on the list
    page, and the contact will be loaded into an edit form just below the search box.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例在`cp6-activator`分支中。在我们深入探讨其工作原理之前，你可能想先玩一玩。只需使用列表页上的快速编辑按钮，联系人就会被加载到搜索框下方的编辑表单中。
- en: 'The list page needs an activator and a function to set the activator:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 列表页需要一个激活器和设置激活器的函数：
- en: '[PRE49]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'The `quickEdit` function, which will be bound to a button on the list item,
    sets the `editContact` activator to a new instance of the edit page viewmodel.
    It provides the contact-to-edit to the new viewmodel and a callback to clear the
    `editContact` object. The HTML just needs a button to call it:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`quickEdit` 函数，它将被绑定到列表项上的按钮，将 `editContact` 激活器设置为编辑页面视图模型的新实例。它为新的视图模型提供要编辑的联系人，并提供一个回调来清除
    `editContact` 对象。HTML 只需要一个按钮来调用它：'
- en: '[PRE50]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'To use this, the edit page viewmodel will need to call the close callback—the
    second constructor parameter—when saving or canceling in a manner that is similar
    to how it handled closing the dialog:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此功能，编辑页面视图模型在保存或取消时需要调用关闭回调——即第二个构造函数参数——其方式与处理关闭对话框的方式相似：
- en: '[PRE51]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Actually, this is all we need in order to take advantage of the deactivation
    guard, which is already on the edit viewmodel. There is some additional logic
    that handles saving changes, but it isn't strictly related to the activator use.
    If you try to use quick edit, make some changes, hit **Cancel**, and you will
    be prompted. If you hit **No**, the item will not be deactivated. You will also
    be prompted if you try to use a different quick edit while unsaved changes are
    present. All of this guard logic is handled for you by virtue of `editContact`
    being an activator observable.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这就是我们利用取消激活保护器所需的一切，该保护器已经在编辑视图模型上。还有一些额外的逻辑来处理保存更改，但这与激活器的使用没有直接关系。如果你尝试使用快速编辑，进行一些更改，点击
    **取消**，将会提示你。如果你点击 **否**，项目将不会被取消激活。如果你在存在未保存更改的情况下尝试使用不同的快速编辑，也会被提示。所有这些保护逻辑都由
    `editContact` 作为激活器可观察对象为你处理。
- en: In addition to being writeable with the normal observable pattern by calling
    `editContact(newValue)`, activators have an `activateItem` method. The first parameter
    to `activateItem` is `newValue`, and the second option is `activationData`, which
    allows you to send a property bag to the `activate` method of the new value being
    set. This will be used as `editContact.activateItem(newValue, data)`.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 除了可以通过调用 `editContact(newValue)` 使用正常可观察模式进行写入外，激活器还有一个 `activateItem` 方法。`activateItem`
    的第一个参数是 `newValue`，第二个参数是 `activationData`，它允许你向新设置的 `activate` 方法发送属性包。这将被用作
    `editContact.activateItem(newValue, data)`。
- en: This example, more than most examples in this book, is extremely contrived for
    the sake of brevity. Overloading the edit page viewmodel so that it is internally
    aware of being used in three different contexts is not a good design, and is not
    recommended for real-world use.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 与本书中的大多数示例相比，这个示例为了简洁而非常牵强。过度加载编辑页面视图模型，使其内部意识到它被用于三个不同的上下文，这不是一个好的设计，也不建议在实际应用中使用。
- en: Binding to plain JavaScript objects
  id: totrans-214
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将绑定到普通 JavaScript 对象
- en: The last part of Durandal that we are going to cover is the observable plugin,
    which allows data binding to use normal viewmodel properties as observable objects
    by converting them under the hood.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要介绍的 Durandal 的最后一部分是可观察插件，它允许数据绑定通过在底层转换它们来使用正常的视图模型属性作为可观察对象。
- en: The observable plugin uses JavaScript getters and setters created with `defineProperty`,
    which is part of the ECMAScript 5 specification. Only modern browsers support
    this feature, so if your application needs to work in Internet Explorer 8, the
    observable plugin will not work.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 可观察插件使用 `defineProperty` 创建的 JavaScript 获取器和设置器，这是 ECMAScript 5 规范的一部分。只有现代浏览器支持这个功能，所以如果你的应用程序需要在
    Internet Explorer 8 中工作，可观察插件将无法使用。
- en: 'Using the observable plugin removes one of the most common complaints from
    Knockout''s syntax: the parentheses. All of the property access is executed using
    plain syntax, whether reading or assigning values:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可观察插件消除了 Knockout 语法中最常见的抱怨之一：括号。所有属性访问都使用纯语法执行，无论是读取还是赋值：
- en: '[PRE52]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: Everything is converted into observables by the observable plugin during data
    binding. Knockout observables can still be created with `ko.observable`, but it
    should not be necessary.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据绑定过程中，一切都被可观察插件转换成了可观察对象。尽管可以使用 `ko.observable` 创建 Knockout 可观察对象，但通常是不必要的。
- en: This does have an impact on all of your code, though, as using the parentheses
    to access properties will no longer work; they are not functions anymore! Using
    the observable plugin means a total conversion of your application code.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这确实会影响你所有的代码，因为使用括号来访问属性将不再有效；它们不再是函数了！使用可观察插件意味着你的应用程序代码将进行彻底的转换。
- en: Observable plugin setup
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可观察插件设置
- en: 'Using the observable plugin, like any plugin, requires it to be installed before
    the `app.start` call:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 使用可观察插件，就像任何插件一样，需要在调用`app.start`之前安装它：
- en: '[PRE53]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: If you need to use the plugin manually, it is required into a module with `plugins/observable`.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您需要手动使用插件，它需要通过`plugins/observable`模块导入。
- en: Subscribing and extending
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 订阅和扩展
- en: 'When you are no longer creating observables manually, you will have to use
    the observable plugin to get access to the underlying observable to set up subscriptions
    or add extenders. This can be done by calling the observable module as a function
    with `observable(object, ''property'')`. The observable module is injected with
    `''plugins/observable''`:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 当您不再手动创建可观察对象时，您将必须使用可观察插件来访问底层可观察对象以设置订阅或添加扩展器。这可以通过将可观察模块作为具有`observable(object,
    'property')`的函数调用来完成。可观察模块通过`'plugins/observable'`注入：
- en: '[PRE54]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: This can be done at any time, even if the property hasn't yet been converted
    into an observable, as calling the observable module will convert the property
    immediately.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以在任何时候进行，即使属性尚未转换为可观察对象，因为调用可观察模块会立即将属性转换为可观察对象。
- en: Computed observables
  id: totrans-229
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 计算可观察对象
- en: 'Computed observables are created using `observable.defineProperty`:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 计算可观察对象使用`observable.defineProperty`创建：
- en: '[PRE55]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `defineProperty` method also returns the underlying computed observables
    so that it can be extended or subscribed to.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '`defineProperty`方法还返回底层的计算可观察对象，以便可以扩展或订阅它。'
- en: 'There is a caveat with computed observables, though. If anything tries to access
    the computed value before its dependencies have been converted into observables,
    then the computed value will not be able to register these dependencies; its value
    will never update:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，计算可观察对象有一个注意事项。如果任何东西在依赖项转换为可观察对象之前尝试访问计算值，那么计算值将无法注册这些依赖项；其值将永远不会更新：
- en: '[PRE56]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'To stop this from happening, the dependencies `firstName`, `lastName`, and
    `nickname` need to be made observables manually. This can be done by calling `convertObject`
    on the observable module:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这种情况发生，需要手动将依赖项`firstName`、`lastName`和`nickname`转换为可观察对象。这可以通过在可观察模块上调用`convertObject`来完成：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This ensures that the first time `displayName` is accessed, it reads observable
    properties and not normal properties.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这确保了第一次访问`displayName`时，它读取的是可观察属性而不是常规属性。
- en: Because this *bug* can be difficult to track down when it happens, it can be
    a good practice to always call `convertObjec`t in viewmodel constructors. It does
    not incur any performance penalty, as it's the same method the observable plugin
    uses when it gets to data binding. If you need finer-grained control over conversion,
    properties can be converted one at a time using `observable.convertProperty(object,
    'propertyName')`.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这种*错误*在发生时可能难以追踪，因此始终在viewmodel构造函数中调用`convertObject`是一个好的实践。它不会引起任何性能损失，因为它与可观察插件在数据绑定时使用的是同一个方法。如果您需要更细粒度的控制转换，可以使用`observable.convertProperty(object,
    'propertyName')`逐个转换属性。
- en: Promises
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 承诺
- en: 'In addition to treating normal JavaScript properties as observables, the observables
    plugin also allows promises to be bound against by converting the property into
    an observable and setting a callback to update it when the promise is resolved:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 除了将常规JavaScript属性视为可观察对象外，可观察插件还允许通过将属性转换为可观察对象并设置一个回调来更新它在解决承诺时绑定的承诺：
- en: '[PRE58]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: After being converted into an observable, the contacts array can still be bound
    against normally. In fact, making this change requires no HTML changes in the
    sample code.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在转换为可观察对象后，联系人数组仍然可以正常绑定。实际上，在示例代码中，进行此更改不需要任何HTML更改。
- en: Sample
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 样本
- en: You can see an example of all of these binding methods in the `cp6-observable`
    branch. All of the code has been converted to using plain JavaScript properties
    with the observable plugin.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在`cp6-observable`分支中看到所有这些绑定方法的示例。所有代码都已转换为使用带有可观察插件的纯JavaScript属性。
- en: The parentheses have been removed from all of the application code, including
    the mock data service. It should be a bit easier to read now.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 所有应用程序代码中的括号都已删除，包括模拟数据服务。现在应该更容易阅读。
- en: On the list viewmodel, the preceding contacts' promise example is used, which
    replaces the `activate` method. The `displayContacts` computed value is created
    with the observable plugin and still has the `rateLimit` extender applied.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在列表viewmodel上，使用前面的联系人承诺示例，它替换了`activate`方法。`displayContacts`计算值使用可观察插件创建，并且仍然应用了`rateLimit`扩展器。
- en: The `Contact` model uses the `convertObject` method to manually convert to observables,
    as the dirty flag on `state` will try to read the `displayName` computed value.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: '`Contact` 模型使用 `convertObject` 方法手动转换为可观察对象，因为 `state` 上的脏标志将尝试读取 `displayName`
    计算值。'
- en: The only changes on the edit page are the removal of parentheses.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑页面上的唯一更改是移除了括号。
- en: Summary
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Durandal aims to compliment Knockout's MVVM philosophy by providing a view-viewmodel-centric
    framework that focuses on composition. If you love Knockout (and you should; you're
    reading this book, after all!), you should hopefully see Durandal as a natural
    extension. The tools Durandal provides go a long way in simplifying the development
    of SPAs.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: Durandal 致力于通过提供一个以视图-视图模型为中心的框架来补充 Knockout 的 MVVM 哲学，该框架专注于组合。如果你喜欢 Knockout（你应该喜欢；毕竟，你在读这本书！），你可能会希望将
    Durandal 视为一个自然的扩展。Durandal 提供的工具在简化单页应用（SPAs）的开发方面大有裨益。
- en: In the next chapter, we will be leaving Durandal and deep diving into Knockout's
    inner workings.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将离开 Durandal 并深入探索 Knockout 的内部机制。
