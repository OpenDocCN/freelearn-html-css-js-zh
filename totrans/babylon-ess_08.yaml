- en: Chapter 8. Add Rendering Effects Using Built-in Post-processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Remember [Chapter 4](ch04.html "Chapter 4. Using Materials to Customize 3D
    Objects Appearance"), *Using Materials to Customize 3D Objects Appearance*, about
    materials? Behind the materials are GPU programs called **shaders**. Shaders are
    a combination of two linked programs: the vertex shader and the pixel shader.
    The vertex shader works on vertices (transforms their 3D positions to 2D positions
    on the screen), while the pixel shader works on pixels (determines the final color
    of each pixel). Here, you can see the post-processes to be only a pixel shader
    since the vertex shader is the same for all.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the post-processes tend to create effects only in the view space.
    In other words, the post-processes are never applied to objects such as meshes,
    they are applied only to the camera itself. In this chapter, we will cover the
    following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using post-processes with Babylon.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using post-process rendering pipelines with Babylon.js
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discussing the built-in post-processes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using post-processes with Babylon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fortunately, you'll not have to create post-processes yourself, even if you
    can do it with Babylon.js. There are post-processes already available in Babylon.js
    and in most cases, available by writing only a line of code!
  prefs: []
  type: TYPE_NORMAL
- en: Starting with your first post-process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the post-processes available in Babylon.js, you can create blur, bloom,
    HDR, SSAO, volumetric light post-processes, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start with the following scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with your first post-process](img/image_08_001-1024x551.png)'
  prefs: []
  type: TYPE_IMG
- en: 'For the first example, let''s create a vertical blur post-process using the
    built-in post-processes. The blur post-process is available by creating a new
    instance of the `BABYLON.BlurPostProcess` class, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The result is as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with your first post-process](img/image_08_002.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The majority of post-processes available in Babylon.js will have the same parameters
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Name**: This is the name of the post-process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Ratio**: This is the ratio of the post-process in the `[0, 1]` interval.
    The ratio is used to calculate the post-process in a lower resolution in order
    to save performances. In other words, with a ratio of `0.5`, the post-process
    will be applied to the canvas resolution divided by 2.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Camera**: The post-processes are applied on the cameras. Then, you just have
    to provide the camera reference and the post-process''s constructors attaches
    itself to the camera.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For another example, let''s create a `black and white` post-process that will
    make the scene entirely black and white, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following screenshot displays the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Starting with your first post-process](img/image_08_003.png)'
  prefs: []
  type: TYPE_IMG
- en: Chaining post-processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With Babylon.js, you can chain post-processes. This means that for a post-process,
    the previous post-process will be used as a reference. For example, two blur post-processes
    can be used to blur the scene horizontally and vertically; the first post-process
    blurs the scene horizontally and the second uses the horizontal blur post-process
    to blur the scene vertically.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the first post-process that is the horizontal blur post-process:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '![Chaining post-processes](img/image_08_004-1024x548.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s create the vertical blur post-process after the horizontal blur
    post-process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '![Chaining post-processes](img/image_08_005-1024x549.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Finally, why not add the `black and white` post-process, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The final result is displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Chaining post-processes](img/image_08_006-1024x549.png)'
  prefs: []
  type: TYPE_IMG
- en: Removing and retrieving post-processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To remove a post-process from the camera, you can simply call the `.dispose`
    function on a post-process. The dispose function removes the internal resources
    and detaches the post-process from the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following with the previous chained post-processes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Conversely, you can detach and attach a post-process from/to a camera without
    removing the internal resources. Simply, call the `.attachPostProcess` or `.detachPostProcess` functions
    on a camera. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'To retrieve the available post-processes, you can access the `._postProcesses`
    property of a camera. Consider the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Using post-process rendering pipelines with Babylon.js
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you are able to create post-processes and attach them to a camera. The
    problem is that if you manage multiple cameras in your project, then you'll have
    to dispose or detach post-processes in order to reattach them to a new camera.
    To facilitate the task, you can use the rendering pipelines. In other words, you
    can see a rendering pipeline as a list of post-processes, which you can attach
    to multiple cameras.
  prefs: []
  type: TYPE_NORMAL
- en: Create a rendering pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The steps consist on creating a pipeline reference, adding the pipeline to the
    scene, and attaching the pipeline to the cameras.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a rendering pipeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the pipeline has been created, add it to the post-process render pipeline
    manager of the scene (referenced by the engine that you passed as an argument
    to the rendering pipeline''s constructor), as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the pipeline is added to the post-process render pipeline manager, you
    are able to add the effects. The process consists of adding a new `BABYLON.PostProcessRenderEffect` object
    to the pipeline by calling the `.addEffect` method to the pipeline, as shown in
    the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, the method to construct the post-processes must be changed.
    Now, the post-processes will not take any camera as an argument since they are
    not applied to a specific camera. This is the reason why we must provide all the
    arguments, such as the filter type (bilinear as default, then can be null) and
    the engine. This method is the same for all the post-processes, you can easily
    add post-process render effects to the pipeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, let''s attach the pipeline to a camera or a list of cameras. The post-process
    will now be applied to the cameras, as shown in the following snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also detach the pipeline from a camera or a list of cameras, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The result looks exactly the same; however, now it''s easier to share the post-processes
    among your multiple cameras, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Create a rendering pipeline](img/image_08_007-1024x549.png)'
  prefs: []
  type: TYPE_IMG
- en: Enabling and disabling effects in pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Another particularity of the post-process render pipelines is the possibility
    of disabling and enabling effects, a useful feature that allows you to highly
    debug the rendering part of your project.
  prefs: []
  type: TYPE_NORMAL
- en: Consider that, in your project, you can switch between two cameras (`scene.activeCamera
    = theNewCamera`). The first camera is blurred and the second is blurred and `black
    and white`. The goal is that the two cameras can share the same post-process render
    pipeline reference, except that the first camera must have the `black and white`
    post-process disabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable an effect in a render pipeline, you can call the  `.disableEffectInPipeline`
    method on the post-process render pipeline manager of your scene. The only parameters
    needed are the pipeline''s name, the effect''s name, and the camera that will
    no longer have the post-process enabled. If we take the previous example, let''s
    deactivate the `black and white` post-process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: In other words, this method allows you to deactivate a render effect only for
    the camera passed as an argument.
  prefs: []
  type: TYPE_NORMAL
- en: 'Conversely, at any time, you can enable a render effect that is previously
    disabled by calling the  `.enableEffectInPipeline` method on the post-process
    render pipeline manager of your scene. Let''s enable the `black and white` render
    effect, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The built-in post-processes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start with the most interesting part of this chapter; the use of the
    built-in post-processes in Babylon.js. There are several post-processes that can
    beautify your scenes only though the use of the following elements:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Volumetric light scattering**: This shows how to easily scatter the light
    rays of a given light source, such as a sun or a moon.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**SSAO rendering pipeline**: Screen-Space Ambient Occlusion. In other words,
    this rendering pipeline tends to approximate the ambient occlusion of a scene
    for more realism, only using a post-process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**HDR rendering pipeline**: High Dynamic Range rendering. This rendering pipeline
    is directly related to the lighting in the scene and tends to simulate the way
    retinas work in the real world.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Volumetric Light Scattering post-process
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's start this fun part with the **Volumetric Light Scattering** (**VLS**)
    post-process. The VLS post-process tends to simulate the scattering of light rays
    from a light source according to the obstacles between the light and the camera.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take the following original scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Volumetric Light Scattering post-process](img/image_08_008.png)'
  prefs: []
  type: TYPE_IMG
- en: The VLS post-process takes a mesh that will represent the light color as an
    argument. In fact, the light source isn't really a light (`BABYLON.Light`), but
    a mesh with a material configured to simulate the light's color by a diffuse texture
    or color.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s consider, for example, a white sun represented by a billboard. With
    the VLS post-process, the result looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Volumetric Light Scattering post-process](img/image_08_009-1024x549.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The scene, without the post-process, looks similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Volumetric Light Scattering post-process](img/image_08_010.png)'
  prefs: []
  type: TYPE_IMG
- en: The rounded white mesh is, in fact, a plane with a diffuse texture that contains
    alpha. The diffuse texture can be found in the example files and is named `sun.png`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create the VLS post-process, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'In the VLS constructor, if the mesh parameter is null, the post-process creates
    a default mesh that is a plane rendered as a billboard. At any time, if you want,
    you can access the method as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'For example, the mansion scene of Babylon.js used the VLS post-process to scatter
    the moon''s light rays. The result was the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Volumetric Light Scattering post-process](img/image_08_011-1024x507.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The method is pretty simple, they just got the moon''s mesh reference and created
    the VLS post-process by passing the moon''s mesh reference as parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: The number of samples is typically in the `[30, 100]` interval and defines the
    quality of the post-process's result. In the mansion scene of Babylon.js, the
    number of samples was set to `65` in order to save the performance due to the
    pretty large and really nice scene that was already rendered by the engine.
  prefs: []
  type: TYPE_NORMAL
- en: 'To save more performance, the ratio of the post-process can be more customized.
    In fact, the VLS post-process uses an internal pass that renders the scene in
    a texture (Render Target Texture) to create the scattering of light rays. You
    can easily configure the internal pass in order to render in a lower resolution.
    Simply pass an object as an argument for the ratio, as shown in the following
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: You can also customize the parameters related to the VLS post-process itself.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exposure controls the overall intensity of the effect (default `0.3`),
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '![Volumetric Light Scattering post-process](img/image_08_012-1024x548.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The decay dissipates each sample''s contribution (default `0.96815`), as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '![Volumetric Light Scattering post-process](img/image_08_013-1024x548.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The weight controls the overall intensity of each sample (default `0.58767`),
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '![Volumetric Light Scattering post-process](img/image_08_014-1024x545.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The density controls the density of each sample (default `0.926`), as shown
    in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '![Volumetric Light Scattering post-process](img/image_08_015-1024x549.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To give you an order, the mansion scene of Babylon.js was configured as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: SSAO rendering pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SSAO effect is a rendering pipeline as it counts the following five post-processes:'
  prefs: []
  type: TYPE_NORMAL
- en: Pass post-process (saves the scene in a texture)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSAO post-process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontal blur post-process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertical blur post-process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine post-process
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SSAO is famous as it computes the ambient occlusion only using the screen
    space (post-process) in contrast with the more classical methods that require
    the 3D artists to calculate the ambient occlusion in their textures. Finally,
    the SSAO is a good way to save textures and the weight of your projects (no more
    textures required).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the SSAO effect in this scene, the scene without SSAO, the scene
    with SSAO, and finally the scene with only SSAO enabled:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SSAO rendering pipeline](img/image_08_016-1024x455.png)![SSAO rendering pipeline](img/image_08_017-1024x487.png)![SSAO
    rendering pipeline](img/image_08_018-1024x489.png)'
  prefs: []
  type: TYPE_IMG
- en: The result is particularly discreet; however, it can highly add realism to your
    scenes. The ambient occlusion is the way to represent the capacity of the light
    rays to access the objects at its different points, or specifically with SSAO,
    the light rays that cannot access the objects at its different points.
  prefs: []
  type: TYPE_NORMAL
- en: 'At a various point of view, the effect can be easily perceived, as shown in
    the following images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SSAO rendering pipeline](img/image_08_019-1024x454.png)![SSAO rendering pipeline](img/image_08_020-1024x453.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The SSAO is a render pipeline and can be easily created, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'That''s all. Fortunately, the SSAO, the horizontal, and the vertical blur post-processes
    can be done at a lower resolution than the screen size. As for the VLS post-process,
    you can pass an object for the ratio parameter, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'In each scene''s function, you may have to configure the SSAO to render perfectly.
    There are several parameters that you can customize, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The total strength: This controls the overall intensity of the effect (default
    `1.0`). The `.totalStrength` property is rarely or slightly modified as it can
    create some artifacts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The radius: This represents the radius around the analyzed pixel by the SSAO
    (default `0.0002`). To calculate the A**mbient** Occlusion (**AO**) of the current
    pixel, the SSAO effect computes 16 samples around the current pixel in the specified `.radius`
    property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The area: The `.area` (default `0.0075`) property is used to interpolate the
    SSAO samples based on the occlusion difference of each pixel. In other words,
    the area is used to smooth the ambient occlusion of each sample of each pixel.
    Take a look at the following example of a smooth function base on a line (from
    Wikipedia):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![SSAO rendering pipeline](img/image_08_021-1024x768.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the example files, you can press the **2** key to disable SSAO, **1** to
    enable SSAO, and **3** to only draw the SSAO pass. The results (in order) are shown
    in the following images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![SSAO rendering pipeline](img/image_08_022-1024x500.png)![SSAO rendering pipeline](img/image_08_023-1024x502.png)![SSAO
    rendering pipeline](img/image_08_024-1024x505.png)'
  prefs: []
  type: TYPE_IMG
- en: HDR rendering pipeline
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **High Dynamic Range** (**HDR**) was a buzzword for a long time. This concept,
    particularly interesting, tends to simulate how the retinas operate in the real
    world. It includes the adaptation of luminosity (glaring) and the luminosity artifacts
    on the highlighted surfaces of an object.
  prefs: []
  type: TYPE_NORMAL
- en: To understand the effect of glare, imagine that you are in a totally dark room.
    Suddenly, someone turns the light on; the necessary time for your eye to adapt
    to the luminosity (bloomed and blurred) represents the glare effect.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compare the same scene with and without the HDR render pipeline enabled
    (HDR will adapt the luminosity and create artifacts on the highlighted zones),
    as shown in the following images:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HDR rendering pipeline](img/image_08_025-1024x456.png)![HDR rendering pipeline](img/image_08_026-1024x453.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To create an HDR render pipeline, the process is the same as the SSAO render
    pipeline, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The HDR rendering pipeline can be highly customized as you can customize the
    minimum luminosity required to create the artifacts, create the blur effect that
    creates the artifacts, the speed of retina adaptation of luminosity, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The exposure (`hdr.exposure`) controls the overall luminosity of the scene
    (default 1.0), as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '![HDR rendering pipeline](img/image_08_027-1024x460.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The bright threshold (`hdr.brightThreshold`) controls the minimum luminance
    required to create the artifacts (default `0.8`), as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '![HDR rendering pipeline](img/image_08_028-1024x454.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The minimum luminance (`hdr.minimumLuminance`) represents the retina adaptation
    in the darker zones (default `1.0`). The smaller the value (`>= 0.0`), the more
    highlighted the scene is, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '![HDR rendering pipeline](img/image_08_029-1024x455.png)'
  prefs: []
  type: TYPE_IMG
- en: The luminance decrease rate (`hdr.luminanceDecreaseRate`) and luminance increase
    rate (`hdr.luminanceIncreaserate`) represent the speed of retina adaptation to
    the luminosity (default `0.5` for both). The higher the value, the quicker the
    adaptation. In most cases, the value is between `0.5` and `1.0`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Gaussian blur multiplier (`hdr.gaussMultiplier`) intensifies the blur width
    (default `4`). It works the `.blurWidth` property of `BABYLON.BlurPostProcess`,
    as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '![HDR rendering pipeline](img/image_08_030-1024x458.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Gaussian coefficient (`hdr.gaussCoeff`) controls the overall Gaussian blur
    effect (default `0.3`). In fact, the output of the Gaussian blur is *output *
    gaussCoeff*, as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '![HDR rendering pipeline](img/image_08_031-1024x455.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Gaussian standard deviaition (`hdr.gaussStandDev`) controls the overall
    blur intensity of the effect (default 0.8), as shown in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '![HDR rendering pipeline](img/image_08_032-1024x456.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The `.gausCoeff` and `.gaussStandDev` properties are linked together. They
    must be equilibrated relative to each other. To give you an order, the following
    scene is configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'It looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![HDR rendering pipeline](img/image_08_033-1024x456.png)'
  prefs: []
  type: TYPE_IMG
- en: In most cases, in a highlighted scene, following the Gaussian Blur equations
    with the implementation of HDR in Babylon.js, the Gaussian Standard Deviation
    equals *10.0 * Gaussian Coefficient*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to beautify your scenes using only post-processes.
    The Mansion demo on the Babylon.js home page showed a great usage of the Volumetric
    Light Scattering post-process. Unfortunately, none of the post-processes are available
    on phones due to hardware limitations. Even if the post-process is not supported
    on mobiles, your projects will still run without the post-process being rendered.
    The power of Babylon.js resides in the fact that it works on all devices. Even
    if a feature is not supported on a device, the feature will simply be disabled.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, let's end this with animations. The Babylon.js framework
    allows creating and managing animations. These animations will allow you to animate
    characters, objects, and more with the help of the framework and 3D artists!
  prefs: []
  type: TYPE_NORMAL
