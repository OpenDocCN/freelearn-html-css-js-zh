- en: Chapter 8. Add Rendering Effects Using Built-in Post-processes
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章. 使用内置后处理添加渲染效果
- en: 'Remember [Chapter 4](ch04.html "Chapter 4. Using Materials to Customize 3D
    Objects Appearance"), *Using Materials to Customize 3D Objects Appearance*, about
    materials? Behind the materials are GPU programs called **shaders**. Shaders are
    a combination of two linked programs: the vertex shader and the pixel shader.
    The vertex shader works on vertices (transforms their 3D positions to 2D positions
    on the screen), while the pixel shader works on pixels (determines the final color
    of each pixel). Here, you can see the post-processes to be only a pixel shader
    since the vertex shader is the same for all.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 记得[第4章](ch04.html "第4章. 使用材质自定义3D对象外观")，关于材质的内容吗？在材质背后是称为**着色器**的GPU程序。着色器是两个链接程序的组合：顶点着色器和像素着色器。顶点着色器在顶点上工作（将它们的3D位置转换为屏幕上的2D位置），而像素着色器在像素上工作（确定每个像素的最终颜色）。在这里，你可以看到后处理只是一个像素着色器，因为顶点着色器对所有后处理都是相同的。
- en: 'Finally, the post-processes tend to create effects only in the view space.
    In other words, the post-processes are never applied to objects such as meshes,
    they are applied only to the camera itself. In this chapter, we will cover the
    following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，后处理倾向于只在视图空间中创建效果。换句话说，后处理永远不会应用于如网格等对象，它们只应用于相机本身。在本章中，我们将涵盖以下主题：
- en: Using post-processes with Babylon.js
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Babylon.js 的后处理
- en: Using post-process rendering pipelines with Babylon.js
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Babylon.js 的后处理渲染管线
- en: Discussing the built-in post-processes
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 讨论内置的后处理
- en: Using post-processes with Babylon.js
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Babylon.js 的后处理
- en: Fortunately, you'll not have to create post-processes yourself, even if you
    can do it with Babylon.js. There are post-processes already available in Babylon.js
    and in most cases, available by writing only a line of code!
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，你不必自己创建后处理，即使你可以使用 Babylon.js 来做。Babylon.js 中已经有一些后处理可用，并且在大多数情况下，只需写一行代码即可使用！
- en: Starting with your first post-process
  id: totrans-8
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从你的第一个后处理开始
- en: With the post-processes available in Babylon.js, you can create blur, bloom,
    HDR, SSAO, volumetric light post-processes, and so on.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Babylon.js 中，你可以使用后处理创建模糊、辉光、HDR、SSAO、体积光后处理等。
- en: 'Let''s start with the following scene:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从以下场景开始：
- en: '![Starting with your first post-process](img/image_08_001-1024x551.png)'
  id: totrans-11
  prefs: []
  type: TYPE_IMG
  zh: '![从你的第一个后处理开始](img/image_08_001-1024x551.png)'
- en: 'For the first example, let''s create a vertical blur post-process using the
    built-in post-processes. The blur post-process is available by creating a new
    instance of the `BABYLON.BlurPostProcess` class, as follows:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个例子，让我们使用内置后处理创建一个垂直模糊后处理。模糊后处理可以通过创建`BABYLON.BlurPostProcess`类的新实例来获取，如下所示：
- en: '[PRE0]'
  id: totrans-13
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The result is as shown in the following screenshot:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下所示：
- en: '![Starting with your first post-process](img/image_08_002.png)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![从你的第一个后处理开始](img/image_08_002.png)'
- en: 'The majority of post-processes available in Babylon.js will have the same parameters
    as shown in the following:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: Babylon.js 中大多数可用的后处理将具有以下相同的参数：
- en: '**Name**: This is the name of the post-process.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**名称**: 这是后处理的名称。'
- en: '**Ratio**: This is the ratio of the post-process in the `[0, 1]` interval.
    The ratio is used to calculate the post-process in a lower resolution in order
    to save performances. In other words, with a ratio of `0.5`, the post-process
    will be applied to the canvas resolution divided by 2.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**比例**: 这是后处理在`[0, 1]`区间内的比例。比例用于在较低分辨率下计算后处理以节省性能。换句话说，如果比例为`0.5`，后处理将应用于画布分辨率除以2。'
- en: '**Camera**: The post-processes are applied on the cameras. Then, you just have
    to provide the camera reference and the post-process''s constructors attaches
    itself to the camera.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相机**: 后处理应用于相机。然后，你只需提供相机引用，后处理的构造函数就会自动附加到相机上。'
- en: 'For another example, let''s create a `black and white` post-process that will
    make the scene entirely black and white, as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 以另一个例子为例，让我们创建一个`黑白`后处理，它将场景完全转换为黑白，如下所示：
- en: '[PRE1]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The following screenshot displays the result:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了结果：
- en: '![Starting with your first post-process](img/image_08_003.png)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![从你的第一个后处理开始](img/image_08_003.png)'
- en: Chaining post-processes
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 后处理链
- en: With Babylon.js, you can chain post-processes. This means that for a post-process,
    the previous post-process will be used as a reference. For example, two blur post-processes
    can be used to blur the scene horizontally and vertically; the first post-process
    blurs the scene horizontally and the second uses the horizontal blur post-process
    to blur the scene vertically.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Babylon.js，您可以链式后处理。这意味着对于某个后处理，前一个后处理将作为参考。例如，两个模糊后处理可以用来水平垂直模糊场景；第一个后处理水平模糊场景，第二个使用水平模糊后处理垂直模糊场景。
- en: 'Let''s create the first post-process that is the horizontal blur post-process:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建第一个后处理，即水平模糊后处理：
- en: '[PRE2]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![Chaining post-processes](img/image_08_004-1024x548.png)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![链式后处理](img/image_08_004-1024x548.png)'
- en: 'Now, let''s create the vertical blur post-process after the horizontal blur
    post-process, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在水平模糊后处理之后创建垂直模糊后处理，如下所示：
- en: '[PRE3]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '![Chaining post-processes](img/image_08_005-1024x549.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![链式后处理](img/image_08_005-1024x549.png)'
- en: 'Finally, why not add the `black and white` post-process, as shown in the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为什么不添加“黑白”后处理，如下所示：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The final result is displayed in the following screenshot:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 最终结果显示在下述截图：
- en: '![Chaining post-processes](img/image_08_006-1024x549.png)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![链式后处理](img/image_08_006-1024x549.png)'
- en: Removing and retrieving post-processes
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 移除和检索后处理
- en: To remove a post-process from the camera, you can simply call the `.dispose`
    function on a post-process. The dispose function removes the internal resources
    and detaches the post-process from the camera.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 要从相机中移除后处理，您可以直接在某个后处理上调用`.dispose`函数。该函数会移除内部资源并将后处理从相机中分离。
- en: 'For example, consider the following with the previous chained post-processes:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下链式后处理：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Conversely, you can detach and attach a post-process from/to a camera without
    removing the internal resources. Simply, call the `.attachPostProcess` or `.detachPostProcess` functions
    on a camera. Consider the following example:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以从/到相机中分离和附加后处理而不删除内部资源。只需在相机上调用`.attachPostProcess`或`.detachPostProcess`函数即可。考虑以下示例：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'To retrieve the available post-processes, you can access the `._postProcesses`
    property of a camera. Consider the following example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 要检索可用的后处理，您可以访问相机的`._postProcesses`属性。考虑以下示例：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Using post-process rendering pipelines with Babylon.js
  id: totrans-44
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Babylon.js的后处理渲染管线
- en: Now, you are able to create post-processes and attach them to a camera. The
    problem is that if you manage multiple cameras in your project, then you'll have
    to dispose or detach post-processes in order to reattach them to a new camera.
    To facilitate the task, you can use the rendering pipelines. In other words, you
    can see a rendering pipeline as a list of post-processes, which you can attach
    to multiple cameras.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您能够创建后处理并将它们附加到相机上。问题是如果您在项目中管理多个相机，那么您将不得不销毁或分离后处理以便重新附加到新的相机上。为了简化任务，您可以使用渲染管线。换句话说，您可以将渲染管线视为后处理列表，您可以将它们附加到多个相机上。
- en: Create a rendering pipeline
  id: totrans-46
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建渲染管线
- en: The steps consist on creating a pipeline reference, adding the pipeline to the
    scene, and attaching the pipeline to the cameras.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这些步骤包括创建管线引用，将管线添加到场景中，并将管线附加到相机上。
- en: 'Create a rendering pipeline, as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个渲染管线，如下所示：
- en: '[PRE8]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Once the pipeline has been created, add it to the post-process render pipeline
    manager of the scene (referenced by the engine that you passed as an argument
    to the rendering pipeline''s constructor), as follows:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦管线被创建，将其添加到场景的后处理渲染管线管理器中（由创建渲染管线构造函数时传入的引擎引用），如下所示：
- en: '[PRE9]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Once the pipeline is added to the post-process render pipeline manager, you
    are able to add the effects. The process consists of adding a new `BABYLON.PostProcessRenderEffect` object
    to the pipeline by calling the `.addEffect` method to the pipeline, as shown in
    the following snippet:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦管线被添加到后处理渲染管线管理器中，您就可以添加效果。这个过程包括通过调用管线的`.addEffect`方法向管线中添加一个新的`BABYLON.PostProcessRenderEffect`对象，如下所示：
- en: '[PRE10]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'As you can see, the method to construct the post-processes must be changed.
    Now, the post-processes will not take any camera as an argument since they are
    not applied to a specific camera. This is the reason why we must provide all the
    arguments, such as the filter type (bilinear as default, then can be null) and
    the engine. This method is the same for all the post-processes, you can easily
    add post-process render effects to the pipeline, as follows:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，构建后处理的方法必须更改。现在，后处理将不会接受任何相机作为参数，因为它们不是应用于特定相机。这就是为什么我们必须提供所有参数的原因，例如过滤器类型（默认为双线性，然后可以是null）和引擎。这种方法适用于所有后处理，您可以轻松地将后处理渲染效果添加到管道中，如下所示：
- en: '[PRE11]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Finally, let''s attach the pipeline to a camera or a list of cameras. The post-process
    will now be applied to the cameras, as shown in the following snippet:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们将管道连接到相机或相机列表。现在，后处理将应用于相机，如下面的代码片段所示：
- en: '[PRE12]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'You can also detach the pipeline from a camera or a list of cameras, as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以按照以下方式从相机或相机列表中分离管道：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The result looks exactly the same; however, now it''s easier to share the post-processes
    among your multiple cameras, as shown in the following screenshot:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 结果看起来完全一样；然而，现在更容易在多个相机之间共享后处理，如下面的屏幕截图所示：
- en: '![Create a rendering pipeline](img/image_08_007-1024x549.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![创建渲染管道](img/image_08_007-1024x549.png)'
- en: Enabling and disabling effects in pipeline
  id: totrans-62
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在管道中启用和禁用效果
- en: Another particularity of the post-process render pipelines is the possibility
    of disabling and enabling effects, a useful feature that allows you to highly
    debug the rendering part of your project.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 后处理渲染管道的另一个特点是禁用和启用效果的可能性，这是一个有用的功能，允许您高度调试项目的渲染部分。
- en: Consider that, in your project, you can switch between two cameras (`scene.activeCamera
    = theNewCamera`). The first camera is blurred and the second is blurred and `black
    and white`. The goal is that the two cameras can share the same post-process render
    pipeline reference, except that the first camera must have the `black and white`
    post-process disabled.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设，在您的项目中，您可以在两个相机之间切换（`scene.activeCamera = theNewCamera`）。第一个相机是模糊的，第二个是模糊的并且是`黑白`。目标是两个相机可以共享相同的后处理渲染管道引用，除了第一个相机必须禁用`黑白`后处理。
- en: 'To disable an effect in a render pipeline, you can call the  `.disableEffectInPipeline`
    method on the post-process render pipeline manager of your scene. The only parameters
    needed are the pipeline''s name, the effect''s name, and the camera that will
    no longer have the post-process enabled. If we take the previous example, let''s
    deactivate the `black and white` post-process, as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要在渲染管道中禁用效果，您可以在场景的后处理渲染管道管理器上调用`.disableEffectInPipeline`方法。所需的唯一参数是管道的名称、效果的名称以及将不再启用后处理的相机。如果我们以之前的例子为例，让我们禁用`黑白`后处理，如下所示：
- en: '[PRE14]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: In other words, this method allows you to deactivate a render effect only for
    the camera passed as an argument.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，这种方法允许您仅对作为参数传递的相机禁用渲染效果。
- en: 'Conversely, at any time, you can enable a render effect that is previously
    disabled by calling the  `.enableEffectInPipeline` method on the post-process
    render pipeline manager of your scene. Let''s enable the `black and white` render
    effect, as shown in the following:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，您可以在任何时候通过在场景的后处理渲染管道管理器上调用`.enableEffectInPipeline`方法来启用之前已禁用的渲染效果。让我们启用`黑白`渲染效果，如下所示：
- en: '[PRE15]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The built-in post-processes
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 内置的后处理
- en: 'Let''s start with the most interesting part of this chapter; the use of the
    built-in post-processes in Babylon.js. There are several post-processes that can
    beautify your scenes only though the use of the following elements:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从本章最有趣的部分开始；在Babylon.js中使用内置的后处理。有几个后处理可以通过以下元素美化您的场景：
- en: '**Volumetric light scattering**: This shows how to easily scatter the light
    rays of a given light source, such as a sun or a moon.'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**体积光散射**：这展示了如何轻松散射给定光源（如太阳或月亮）的光线。'
- en: '**SSAO rendering pipeline**: Screen-Space Ambient Occlusion. In other words,
    this rendering pipeline tends to approximate the ambient occlusion of a scene
    for more realism, only using a post-process.'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SSAO渲染管道**：屏幕空间环境遮挡。换句话说，这个渲染管道倾向于通过仅使用后处理来近似场景的环境遮挡，以获得更逼真的效果。'
- en: '**HDR rendering pipeline**: High Dynamic Range rendering. This rendering pipeline
    is directly related to the lighting in the scene and tends to simulate the way
    retinas work in the real world.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HDR渲染管线**：高动态范围渲染。此渲染管线与场景中的光照直接相关，并倾向于模拟视网膜在现实世界中的工作方式。'
- en: Volumetric Light Scattering post-process
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 体积光散射后处理
- en: Let's start this fun part with the **Volumetric Light Scattering** (**VLS**)
    post-process. The VLS post-process tends to simulate the scattering of light rays
    from a light source according to the obstacles between the light and the camera.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从有趣的**体积光散射**（**VLS**）后处理开始。VLS后处理倾向于模拟光源根据光与相机之间的障碍物散射光线的现象。
- en: 'Let''s take the following original scene:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们考虑以下原始场景：
- en: '![Volumetric Light Scattering post-process](img/image_08_008.png)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![体积光散射后处理](img/image_08_008.png)'
- en: The VLS post-process takes a mesh that will represent the light color as an
    argument. In fact, the light source isn't really a light (`BABYLON.Light`), but
    a mesh with a material configured to simulate the light's color by a diffuse texture
    or color.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: VLS后处理接受一个代表光色的网格作为参数。实际上，光源并不是真正的光源（`BABYLON.Light`），而是一个配置了材质的网格，通过漫反射纹理或颜色来模拟光的颜色。
- en: 'Let''s consider, for example, a white sun represented by a billboard. With
    the VLS post-process, the result looks similar to the following screenshot:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑一个由广告牌表示的白色太阳。使用VLS后处理，结果看起来类似于以下截图：
- en: '![Volumetric Light Scattering post-process](img/image_08_009-1024x549.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![体积光散射后处理](img/image_08_009-1024x549.png)'
- en: 'The scene, without the post-process, looks similar to the following screenshot:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 没有后处理的场景看起来类似于以下截图：
- en: '![Volumetric Light Scattering post-process](img/image_08_010.png)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![体积光散射后处理](img/image_08_010.png)'
- en: The rounded white mesh is, in fact, a plane with a diffuse texture that contains
    alpha. The diffuse texture can be found in the example files and is named `sun.png`.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，那个圆形的白色网格是一个包含alpha的漫反射纹理的平面。漫反射纹理可以在示例文件中找到，命名为`sun.png`。
- en: 'Let''s create the VLS post-process, as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建VLS后处理，如下所示：
- en: '[PRE16]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the VLS constructor, if the mesh parameter is null, the post-process creates
    a default mesh that is a plane rendered as a billboard. At any time, if you want,
    you can access the method as shown in the following:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在VLS构造函数中，如果网格参数为null，后处理将创建一个默认网格，该网格是一个渲染为广告牌的平面。在任何时候，如果你想，你可以像以下所示访问该方法：
- en: '[PRE17]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'For example, the mansion scene of Babylon.js used the VLS post-process to scatter
    the moon''s light rays. The result was the following image:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，Babylon.js的豪宅场景使用了VLS后处理来散射月光的射线。结果如下所示图像：
- en: '![Volumetric Light Scattering post-process](img/image_08_011-1024x507.png)'
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![体积光散射后处理](img/image_08_011-1024x507.png)'
- en: 'The method is pretty simple, they just got the moon''s mesh reference and created
    the VLS post-process by passing the moon''s mesh reference as parameter, as follows:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法相当简单，他们只是获取了月球网格参考，并通过将月球网格参考作为参数创建VLS后处理，如下所示：
- en: '[PRE18]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The number of samples is typically in the `[30, 100]` interval and defines the
    quality of the post-process's result. In the mansion scene of Babylon.js, the
    number of samples was set to `65` in order to save the performance due to the
    pretty large and really nice scene that was already rendered by the engine.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 样本数通常在`[30, 100]`区间内，并定义了后处理结果的品质。在Babylon.js的豪宅场景中，样本数设置为`65`以节省性能，因为该场景已经由引擎渲染得相当大且非常漂亮。
- en: 'To save more performance, the ratio of the post-process can be more customized.
    In fact, the VLS post-process uses an internal pass that renders the scene in
    a texture (Render Target Texture) to create the scattering of light rays. You
    can easily configure the internal pass in order to render in a lower resolution.
    Simply pass an object as an argument for the ratio, as shown in the following
    snippet:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了节省更多性能，后处理的比率可以更加定制化。实际上，VLS后处理使用一个内部遍历，在纹理（渲染目标纹理）中渲染场景以创建光线的散射。你可以轻松配置内部遍历以在较低分辨率下渲染。只需将一个对象作为参数传递给比率，如下面的代码片段所示：
- en: '[PRE19]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can also customize the parameters related to the VLS post-process itself.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你还可以自定义与VLS后处理本身相关的参数。
- en: 'The exposure controls the overall intensity of the effect (default `0.3`),
    as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 曝光控制效果的整体强度（默认`0.3`），如下所示：
- en: '[PRE20]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '![Volumetric Light Scattering post-process](img/image_08_012-1024x548.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![体积光散射后处理](img/image_08_012-1024x548.png)'
- en: 'The decay dissipates each sample''s contribution (default `0.96815`), as shown
    in the following code:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '![Volumetric Light Scattering post-process](img/image_08_013-1024x548.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: 'The weight controls the overall intensity of each sample (default `0.58767`),
    as shown in the following code:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '![Volumetric Light Scattering post-process](img/image_08_014-1024x545.png)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
- en: 'The density controls the density of each sample (default `0.926`), as shown
    in the following code:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '![Volumetric Light Scattering post-process](img/image_08_015-1024x549.png)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
- en: 'To give you an order, the mansion scene of Babylon.js was configured as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: SSAO rendering pipeline
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The SSAO effect is a rendering pipeline as it counts the following five post-processes:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Pass post-process (saves the scene in a texture)
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SSAO post-process
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Horizontal blur post-process
  id: totrans-115
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Vertical blur post-process
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Combine post-process
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The SSAO is famous as it computes the ambient occlusion only using the screen
    space (post-process) in contrast with the more classical methods that require
    the 3D artists to calculate the ambient occlusion in their textures. Finally,
    the SSAO is a good way to save textures and the weight of your projects (no more
    textures required).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see the SSAO effect in this scene, the scene without SSAO, the scene
    with SSAO, and finally the scene with only SSAO enabled:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![SSAO rendering pipeline](img/image_08_016-1024x455.png)![SSAO rendering pipeline](img/image_08_017-1024x487.png)![SSAO
    rendering pipeline](img/image_08_018-1024x489.png)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: The result is particularly discreet; however, it can highly add realism to your
    scenes. The ambient occlusion is the way to represent the capacity of the light
    rays to access the objects at its different points, or specifically with SSAO,
    the light rays that cannot access the objects at its different points.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'At a various point of view, the effect can be easily perceived, as shown in
    the following images:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '![SSAO rendering pipeline](img/image_08_019-1024x454.png)![SSAO rendering pipeline](img/image_08_020-1024x453.png)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
- en: 'The SSAO is a render pipeline and can be easily created, as follows:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'That''s all. Fortunately, the SSAO, the horizontal, and the vertical blur post-processes
    can be done at a lower resolution than the screen size. As for the VLS post-process,
    you can pass an object for the ratio parameter, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In each scene''s function, you may have to configure the SSAO to render perfectly.
    There are several parameters that you can customize, as follows:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: 'The total strength: This controls the overall intensity of the effect (default
    `1.0`). The `.totalStrength` property is rarely or slightly modified as it can
    create some artifacts.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The radius: This represents the radius around the analyzed pixel by the SSAO
    (default `0.0002`). To calculate the A**mbient** Occlusion (**AO**) of the current
    pixel, the SSAO effect computes 16 samples around the current pixel in the specified `.radius`
    property.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The area: The `.area` (default `0.0075`) property is used to interpolate the
    SSAO samples based on the occlusion difference of each pixel. In other words,
    the area is used to smooth the ambient occlusion of each sample of each pixel.
    Take a look at the following example of a smooth function base on a line (from
    Wikipedia):'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 区域：`.area`（默认`0.0075`）属性用于根据每个像素的遮挡差异插值SSAO样本。换句话说，区域用于平滑每个像素每个样本的环境遮挡。以下是一个基于线的平滑函数示例（来自维基百科）：
- en: '![SSAO rendering pipeline](img/image_08_021-1024x768.png)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![SSAO渲染管线](img/image_08_021-1024x768.png)'
- en: 'In the example files, you can press the **2** key to disable SSAO, **1** to
    enable SSAO, and **3** to only draw the SSAO pass. The results (in order) are shown
    in the following images:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在示例文件中，你可以按**2**键禁用SSAO，按**1**键启用SSAO，按**3**键仅绘制SSAO通道。结果（按顺序）如下所示：
- en: '![SSAO rendering pipeline](img/image_08_022-1024x500.png)![SSAO rendering pipeline](img/image_08_023-1024x502.png)![SSAO
    rendering pipeline](img/image_08_024-1024x505.png)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![SSAO渲染管线](img/image_08_022-1024x500.png)![SSAO渲染管线](img/image_08_023-1024x502.png)![SSAO渲染管线](img/image_08_024-1024x505.png)'
- en: HDR rendering pipeline
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HDR渲染管线
- en: The **High Dynamic Range** (**HDR**) was a buzzword for a long time. This concept,
    particularly interesting, tends to simulate how the retinas operate in the real
    world. It includes the adaptation of luminosity (glaring) and the luminosity artifacts
    on the highlighted surfaces of an object.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '**高动态范围**（**HDR**）很长时间都是一个热门词汇。这个概念特别有趣，它倾向于模拟视网膜在现实世界中的工作方式。它包括亮度的适应（刺眼）和物体高亮表面的亮度伪影。'
- en: To understand the effect of glare, imagine that you are in a totally dark room.
    Suddenly, someone turns the light on; the necessary time for your eye to adapt
    to the luminosity (bloomed and blurred) represents the glare effect.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解眩光的效果，想象你在一个完全黑暗的房间里。突然，有人打开了灯；你的眼睛适应亮度（泛光和模糊）所需的时间代表眩光效果。
- en: 'Let''s compare the same scene with and without the HDR render pipeline enabled
    (HDR will adapt the luminosity and create artifacts on the highlighted zones),
    as shown in the following images:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们比较启用和未启用HDR渲染管线（HDR会调整亮度并在高亮区域创建伪影）的同一场景，如下所示：
- en: '![HDR rendering pipeline](img/image_08_025-1024x456.png)![HDR rendering pipeline](img/image_08_026-1024x453.png)'
  id: totrans-139
  prefs: []
  type: TYPE_IMG
  zh: '![HDR渲染管线](img/image_08_025-1024x456.png)![HDR渲染管线](img/image_08_026-1024x453.png)'
- en: 'To create an HDR render pipeline, the process is the same as the SSAO render
    pipeline, as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建HDR渲染管线，过程与SSAO渲染管线相同，如下所示：
- en: '[PRE27]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The HDR rendering pipeline can be highly customized as you can customize the
    minimum luminosity required to create the artifacts, create the blur effect that
    creates the artifacts, the speed of retina adaptation of luminosity, and so on.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: HDR渲染管线可以高度定制，因为你可以根据需要定制创建伪影所需的最小亮度、创建伪影的模糊效果、亮度适应速度等。
- en: 'The exposure (`hdr.exposure`) controls the overall luminosity of the scene
    (default 1.0), as shown in the following:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 曝光（`hdr.exposure`）控制场景的整体亮度（默认1.0），如下所示：
- en: '[PRE28]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '![HDR rendering pipeline](img/image_08_027-1024x460.png)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![HDR渲染管线](img/image_08_027-1024x460.png)'
- en: 'The bright threshold (`hdr.brightThreshold`) controls the minimum luminance
    required to create the artifacts (default `0.8`), as shown in the following:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 明亮阈值（`hdr.brightThreshold`）控制创建伪影所需的最小亮度（默认`0.8`），如下所示：
- en: '[PRE29]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '![HDR rendering pipeline](img/image_08_028-1024x454.png)'
  id: totrans-148
  prefs: []
  type: TYPE_IMG
  zh: '![HDR渲染管线](img/image_08_028-1024x454.png)'
- en: 'The minimum luminance (`hdr.minimumLuminance`) represents the retina adaptation
    in the darker zones (default `1.0`). The smaller the value (`>= 0.0`), the more
    highlighted the scene is, as shown in the following:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 最小亮度（`hdr.minimumLuminance`）代表较暗区域的视网膜适应（默认`1.0`）。值越小（`>= 0.0`），场景越突出，如下所示：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '![HDR rendering pipeline](img/image_08_029-1024x455.png)'
  id: totrans-151
  prefs: []
  type: TYPE_IMG
  zh: '![HDR渲染管线](img/image_08_029-1024x455.png)'
- en: The luminance decrease rate (`hdr.luminanceDecreaseRate`) and luminance increase
    rate (`hdr.luminanceIncreaserate`) represent the speed of retina adaptation to
    the luminosity (default `0.5` for both). The higher the value, the quicker the
    adaptation. In most cases, the value is between `0.5` and `1.0`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 亮度降低率（`hdr.luminanceDecreaseRate`）和亮度增加率（`hdr.luminanceIncreaserate`）代表视网膜对亮度的适应速度（默认两者均为`0.5`）。值越高，适应越快。在大多数情况下，该值介于`0.5`和`1.0`之间。
- en: 'The Gaussian blur multiplier (`hdr.gaussMultiplier`) intensifies the blur width
    (default `4`). It works the `.blurWidth` property of `BABYLON.BlurPostProcess`,
    as shown in the following:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯模糊乘数(`hdr.gaussMultiplier`)增强了模糊宽度（默认`4`）。它作用于`BABYLON.BlurPostProcess`的`.blurWidth`属性，如下所示：
- en: '[PRE31]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '![HDR rendering pipeline](img/image_08_030-1024x458.png)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![HDR渲染管线](img/image_08_030-1024x458.png)'
- en: 'The Gaussian coefficient (`hdr.gaussCoeff`) controls the overall Gaussian blur
    effect (default `0.3`). In fact, the output of the Gaussian blur is *output *
    gaussCoeff*, as shown in the following:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯系数(`hdr.gaussCoeff`)控制整体高斯模糊效果（默认`0.3`）。实际上，高斯模糊的输出是*output * gaussCoeff*，如下所示：
- en: '[PRE32]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '![HDR rendering pipeline](img/image_08_031-1024x455.png)'
  id: totrans-158
  prefs: []
  type: TYPE_IMG
  zh: '![HDR渲染管线](img/image_08_031-1024x455.png)'
- en: 'The Gaussian standard deviaition (`hdr.gaussStandDev`) controls the overall
    blur intensity of the effect (default 0.8), as shown in the following:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 高斯标准差(`hdr.gaussStandDev`)控制效果的整体模糊强度（默认0.8），如下所示：
- en: '[PRE33]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '![HDR rendering pipeline](img/image_08_032-1024x456.png)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![HDR渲染管线](img/image_08_032-1024x456.png)'
- en: 'The `.gausCoeff` and `.gaussStandDev` properties are linked together. They
    must be equilibrated relative to each other. To give you an order, the following
    scene is configured:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`.gausCoeff`和`.gaussStandDev`属性是相互关联的。它们必须相互平衡。为了给你一个顺序，以下场景是这样配置的：'
- en: '[PRE34]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'It looks like the following:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 它看起来如下：
- en: '![HDR rendering pipeline](img/image_08_033-1024x456.png)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![HDR渲染管线](img/image_08_033-1024x456.png)'
- en: In most cases, in a highlighted scene, following the Gaussian Blur equations
    with the implementation of HDR in Babylon.js, the Gaussian Standard Deviation
    equals *10.0 * Gaussian Coefficient*.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，在Babylon.js中实现HDR的突出场景中，遵循高斯模糊方程，高斯标准差等于*10.0 * 高斯系数*。
- en: Summary
  id: totrans-167
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to beautify your scenes using only post-processes.
    The Mansion demo on the Babylon.js home page showed a great usage of the Volumetric
    Light Scattering post-process. Unfortunately, none of the post-processes are available
    on phones due to hardware limitations. Even if the post-process is not supported
    on mobiles, your projects will still run without the post-process being rendered.
    The power of Babylon.js resides in the fact that it works on all devices. Even
    if a feature is not supported on a device, the feature will simply be disabled.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何仅使用后处理来美化你的场景。Babylon.js主页上的Mansion演示展示了Volumetric Light Scattering后处理的一个很好的应用。不幸的是，由于硬件限制，手机上没有可用的后处理。即使后处理在移动设备上不受支持，你的项目仍然可以在没有后处理渲染的情况下运行。Babylon.js的力量在于它可以在所有设备上工作。即使某个功能在设备上不受支持，该功能也会简单地被禁用。
- en: In the next chapter, let's end this with animations. The Babylon.js framework
    allows creating and managing animations. These animations will allow you to animate
    characters, objects, and more with the help of the framework and 3D artists!
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，让我们以动画结束。Babylon.js框架允许创建和管理动画。这些动画将允许你借助框架和3D艺术家来动画化角色、对象等！
