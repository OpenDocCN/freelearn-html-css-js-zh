<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-572"><a id="_idTextAnchor634"/>Appendix</h1>
		</div>
		<div><h2>About</h2>
			<p>This section is included to assist the students to perform the activities present in the book. It includes detailed steps that are to be performed by the students to complete and achieve the objectives of the book.</p>
		</div>
		<div><h1 id="_idParaDest-573"><a id="_idTextAnchor635"/>Chapter 1: Getting to Know JavaScript</h1>
			<h2 id="_idParaDest-574"><a id="_idTextAnchor636"/>Activity 1.01: Creating an Alert Box Popup in the Web Browser</h2>
			<h3 id="_idParaDest-575"><a id="_idTextAnchor637"/>Solution</h3>
			<ol>
				<li>Press <em class="italic">F12</em> to open the developer tools that are integrated within it. If this doesn't work, a right-click may expose a prompt so that you can do this as well:<div><img alt="Figure 1.18: Choosing Inspect in Google Chrome&#13;&#10;" src="img/C14377_01_18.jpg"/></div><p class="figure-caption">Figure 1.18: Choosing Inspect in Google Chrome</p></li>
				<li>The developer tools may default to the console. If not, there is likely to be a <code>Console</code> tab you can click on to activate it. The console allows you to write JavaScript code directly within the web browser itself:<div><img alt="Figure 1.19: The Developer Tools Console tab in Google Chrome&#13;&#10;" src="img/C14377_01_19.jpg"/></div><p class="figure-caption">Figure 1.19: The Developer Tools Console tab in Google Chrome</p></li>
				<li>Within the console, write the following command:<pre>var greeting = 'Hello from JavaScript!';
alert(greeting);</pre></li>
				<li>Hit <em class="italic">Return</em>/<em class="italic">Enter</em> to execute the code. The code will execute within the browser environment.<p>You should see an alert appear in the browser viewport displaying your message, as shown here:</p></li>
			</ol>
			<div><div><img alt="Figure 1.20: An alert appears with our message&#13;&#10;" src="img/C14377_01_20.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 1.20: An alert appears with our message</p>
			<p>What does that code do? It declares a variable, using the <code>var</code> keyword, with the <code>greeting</code> identifier on the first line. As part of this same line of code, we then use the <code>=</code> assignment operator to assign a <code>'Hello from JavaScript!'</code> text string value to our variable.</p>
			<p>On the second line, we use the <code>alert()</code> function and pass in our <code>greeting</code>  identifier as an argument. The result is that the web browser displays an alert overlay with the text value applied to the identifier we passed in. </p>
			<h1 id="_idParaDest-576"><a id="_idTextAnchor638"/>Chapter 2: Working with JavaScript</h1>
			<h2 id="_idParaDest-577">Activity 2.01: Add<a id="_idTextAnchor639"/>ing and Modifying an Item to/in the To-Do List</h2>
			<h3 id="_idParaDest-578"><a id="_idTextAnchor640"/>Solution</h3>
			<ol>
				<li value="1">Cr<a id="_idTextAnchor641"/>eate the HTML file yourself and paste in the HTML code to get started:<div><img alt="Figure 2.28: The initial to-do list's appearance&#13;&#10;" src="img/C14377_02_28.jpg"/></div><p class="figure-caption">Figure 2.28: The initial to-do list's appearance</p></li>
				<li>The first thing we need to do is assign an ID to our list in order to identify it via code. To do this, add an <code>id</code> attribute to the <code>ol</code> element and give it a value of <code>todo-list</code>. With that complete, we can then address this element directly with JavaScript:<pre>&lt;ol id="todo-list"&gt;</pre></li>
				<li>Using a bit of JavaScript code, we can now create a new variable named <code>parentContainer</code>. This will refer to the ordered list container element that holds all of our list items. We'll use the ID we assigned in the previous step to address this element directly via the use of the <code>getElementById()</code> method:<pre>var parentContainer = document.getElementById('todo-list');</pre></li>
				<li>Create a new HTML <code>&lt;li&gt;</code> list item element via JavaScript. Right now, the element only exists in memory since we have to add it to a visual container. It also has no text content associated with it:<pre>var newItem = document.createElement('li');</pre></li>
				<li>Now, let's populate the list item with a data value. Set the <code>innerText</code> of our <code>newItem</code> node to a string. The value of that string can be whatever you like, but it should fit within the concept of a to-do list:<pre>newItem.innerText = "Research Wines";</pre></li>
				<li>Now that the new HTML element has been created and populated with text, we can add it to the visual document by appending it to a chosen parent container that already exists:<pre>parentContainer.appendChild(newItem);</pre></li>
				<li>We t<a id="_idTextAnchor642"/>hen need to add an extra line of JavaScript below all the others that currently exist within our <code>&lt;script&gt;</code> tag to modify the element's appearance. We will reference the last child element within our ordered list and change the <code>style</code> attribute to add a CSS color rule. You can set the actual color of the text to whatever you like—I'm going to use <code>crimson</code>:<pre>parentContainer.lastChild.style.color = "crimson";</pre></li>
				<li>Now,<a id="_idTextAnchor643"/> to verify the execution order through code, add the following line of JavaScript directly underneath the initial declaration of <code>parentContainer</code>: <pre>console.log('Beginning List Count: ' + parentContainer.children.length);</pre></li>
				<li>Then, add the following line right before the closing <code>&lt;script&gt;</code> tag:<pre>console.log('End List Count: ' + parentContainer.children.length);</pre></li>
				<li>With that completed, refresh your browser view and a seventh item should appear on your list. Do keep an eye on the developer tools console to verify the execution order of our code! Not only will the new item be added to the existing ordered list, but it will also display with crimson text instead of the usual white:<div><img alt="Figure 2.29: A list item has been added to our to-do list and styled in crimson&#13;&#10;" src="img/C14377_02_29.jpg"/></div></li>
			</ol>
			<p class="figure-caption">Figure 2.29: A list item has been added to our to-do list and styled in crimson</p>
			<p>The complete code will be as follows:</p>
			<pre>activity-complete.html
30    &lt;ol i<a id="_idTextAnchor644"/>d="todo-list"&gt;
31        &lt;li&gt;Wash Laundry&lt;/li&gt;
32        &lt;li&gt;Clean Silver&lt;/li&gt;
33        &lt;li&gt;Write Letters&lt;/li&gt;
34        &lt;li&gt;Purchase Groceries&lt;/li&gt;
35        &lt;li&gt;Retrieve Mail&lt;/li&gt;
36        &lt;li&gt;Prepare Dinner&lt;/li&gt;
37    &lt;/ol&gt;
38    &lt;script&gt;
39        var parentContainer = document.getElementById('todo-list');
The full code is available at: <a href="https://packt.live/2q8CGY1">https://packt.live/2q8CGY1</a></pre>
			<p>This is just a simple example of how JavaScript can have a direct influence over other aspects of the environment it is run with.</p>
			<h1 id="_idParaDest-579"><a id="_idTextAnchor645"/>Chapter 3: Programming Fundamentals</h1>
			<h2 id="_idParaDest-580"><a id="_idTextAnchor646"/>Activity 3.01: The To-Do List Shuffle Program</h2>
			<h3 id="_idParaDest-581"><a id="_idTextAnchor647"/>Solution</h3>
			<ol>
				<li value="1">All the coding is done in the <code>activity.js</code> file. Add the code after the comment shown in each step. Create the array of <code>todo</code> items:<pre>// Declare and initialize the todo list array
let todoList = [
 "Wash Laundry",
 "Clean Silver",
 "Write Letters",
 "Purchase Groceries",
 "Retrieve Mail",
 "Prepare Dinner"
];</pre></li>
				<li>Examine the <code>ol</code> element in the HTML document file called <code>activity.html</code> and notice that it has an <code>id</code> attribute with the value of <code>todo-list</code>:<pre> &lt;ol id="todo-list"&gt;
 &lt;/ol&gt;</pre></li>
				<li>You can create an object variable, referencing the <code>ol</code> element using the <code>document.getElementById</code> method:<pre>// The todo list element
let todoEle = document.getElementById('todo-list');</pre></li>
				<li>Next, write a function that accepts a list element object and an array of values. The function removes the <code>li</code> elements from the list element and then loops through the array, creating new <code>li</code> elements for each value in the array:<pre>// Function to replace an HTML DOM list li elements with array items.
function replaceListElements(listEle, listItems){
 listEle.innerHTML = "";
 for (let i= 0; i&lt;= listItems.length - 1; i++){
  let liEle = document.createElement("li");
  liEle.appendChild(document.createTextNode(listItems[i]));
  listEle.appendChild(liEle);
 }
}</pre><p>The first line uses the <code>innerHTML</code> property to remove all the contents of the list element object. The <code>for</code> loop iterates through the array. The first line in the <code>for</code> loop creates an <code>li</code> element object named <code>liEle</code>. The next line uses the <code>liEle</code> object's <code>addChild</code> method to append a text node to the <code>liEle</code> object. The <code>document.createTextNode</code> method provides the item in the array as a proper node object. The last line appends the <code>liEle</code> object to the <code>listEle</code> object.</p></li>
				<li>The final step is to call the function:<pre>// Update the todo list view with initial list of items
replaceListElements(todoEle, todoList);</pre><p>This function will execute when the <code>activity.js</code> file is loaded.</p></li>
				<li>Save the <code>activity.js</code> file and reload the <code>activity.html</code> file in the web browser. It should appear as follows:<div><img alt="Figure 3.24: activity.js and activity.html file output&#13;&#10;" src="img/C14377_03_24.jpg"/></div><p class="figure-caption">Figure 3.24: <code>activity.js</code> and <code>activity.html</code> file output</p></li>
				<li>Examine the <code>button</code> element in the HTML document file called <code>activity.html</code> and notice that it has an <code>id</code> attribute with the value of <code>shuffle-button</code>:<pre> &lt;button id="shuffle-button"&gt;Shuffle&lt;/button&gt;</pre><p>You can create an object variable referencing the <code>button</code> element by using the <code>document.getElementById</code> method:</p><pre>// The shuffle button element.
let shuffleButtonEle = document.getElementById('shuffle-button');</pre></li>
				<li>Next, you need to listen for click events and call a function that will handle the event. The <code>shuffleButtonEle</code> object's <code>addEventListener</code> method can do that for you. The first argument is the name of the event, and the second argument is the name of the function:<pre>// Add event listener function for the shuffle button element.
shuffleButtonEle.addEventListener('click', shuffleButtonClicked);</pre></li>
				<li>Now, we need to write the <code>shuffleButtonClicked</code> function:<pre>// Function to handle click events for the Shuffle button
function shuffleButtonClicked(e){
 replaceListElements(todoEle, getNewShuffledArray(todoList));
}</pre><p>The only line of code is used to call the <code>replaceListElements</code> function. The first argument is the <code>todoEle</code> object for the <code>ol</code> element. The second argument is the <code>getNewShuffledArray</code> function, which is using the <code>todoList</code> array as an argument. The <code>getNewShuffledArray</code> function returns an array that's been shuffled.</p></li>
				<li>Save the <code>activity.js</code> file and reload the <code>activity.html</code> file in the web browser. Then, click the Shuffle button to see the list change.</li>
				<li>Take a moment to examine the comments in the <code>getNewShuffledArray</code> function to see how it works. It shuffles the array elements, and appears as follows:<pre> function getNewShuffledArray(sourceArray){</pre></li>
				<li>Now, make a copy of <code>sourceArray</code> and set the index to make a swap, starting with the last:<pre> var newArray = [].concat(sourceArray);
 let swapIndex = newArray.length;</pre></li>
				<li>Create an index to make a swap with <code>swapIndex</code> and swap the value of <code>swapIndex</code>:<pre> let swapWithIndex;
 let swapIndexValue;</pre></li>
				<li>Create a <code>while</code> loop called <code>swapIndex</code> that's not equal to <code>0</code> and pick an index to swap with the current index from <code>0</code> to the current <code>swapIndex</code>:<pre> while (0 !== swapIndex) {
  swapWithIndex = Math.floor(Math.random() * swapIndex);</pre></li>
				<li>Now, reduce <code>swapIndex</code> by <code>1</code> and make a copy of the <code>swapIndex</code> value. Then, replace the <code>swapIndex</code> value with the <code>swapWithIndex</code> value, and replace the <code>swapWithIndex</code> value with the <code>temporaryValue</code> value:<pre>  swapIndex -= 1;
  swapIndexValue = newArray[swapIndex];
  newArray[swapIndex] = newArray[swapWithIndex];
  newArray[swapWithIndex] = swapIndexValue;
 }
 return newArray;</pre></li>
			</ol>
			<p>The shuffled To-Do list will look similar to something as follows:</p>
			<div><div><img alt="Figure 3.25: Shuffled list 1" src="img/C14377_03_25.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.25: Shuffled list 1</p>
			<p>Another example of a shuffled To-Do list is as follows:</p>
			<div><div><img alt="Figure 3.26: Shuffled list 2" src="img/C14377_03_26.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 3.26: Shuffled list 2</p>
			<h1 id="_idParaDest-582"><a id="_idTextAnchor648"/>Chapter 4: JavaScript Libraries and Frameworks</h1>
			<h2 id="_idParaDest-583"><a id="_idTextAnchor649"/>Activity 4.01: Adding an Animation to the Todo List Application</h2>
			<h3 id="_idParaDest-584"><a id="_idTextAnchor650"/>Solution:</h3>
			<ol>
				<li value="1">Go to <a href="http://cdnjs.com">cdnjs.com</a> and get the jQuery CDN URL.</li>
				<li>Load the library into the head tag of your existing Todo-List-HTML using a script tag. This will allow you to use jQuery within your code:<pre>&lt;head&gt;
    // ... links and meta tags from the previous activity
&lt;script src="img/jquery.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;</pre><p>Inside <code>activity.js</code>, you need to change the <code>todoEle</code> variable. Change it to a jQuery element:</p><pre>// The todo list element
// let todoEle = document.getElementById('todo-list'); // old
let todoEle = $('#todo-list'); // new</pre><p>Inside the <code>replaceListElements</code> function, you can now use functions on the <code>todoEle</code> element that jQuery provides you with.</p></li>
				<li>Hide and clear what's inside the element using the necessary jQuery functions:<pre>function replaceListElements(listEle, listItems){
 // listEle.innerHTML = „"; // old
 listEle.hide();
 listEle.empty();
 for (let i= 0; i&lt;= listItems.length - 1; i++){
  let liEle = document.createElement("li");
  liEle.appendChild(document.createTextNode(listItems[i]));
  listEle.appendChild(liEle);
 }
}</pre></li>
				<li>Inside the for loop, create the <code>liEle</code> list item element, set the text contest, and append it to the <code>listEle</code> list element:<pre>function replaceListElements(listEle, listItems){
 listEle.hide();
 listEle.empty();
 for (let i= 0; i&lt;= listItems.length - 1; i++){
  // let liEle = document.createElement("li");
  // liEle.appendChild(document.createTextNode(listItems[i]));
  // listEle.appendChild(liEle);
  let liEle = $(document.createElement("li"));
  liEle.append(document.createTextNode(listItems[i]));
  liEle.appendTo(listEle);
 }
}</pre></li>
				<li>Finally, slowly fade in the new sorted todo list, that is, <code>listEle</code>:<pre>function replaceListElements(listEle, listItems){
 listEle.hide();
 listEle.empty();
 for (let i= 0; i&lt;= listItems.length - 1; i++){
  let liEle = $(document.createElement("li"));
  liEle.append(document.createTextNode(listItems[i]));
  liEle.appendTo(listEle)
 }
 listEle.fadeIn('slow');
}</pre></li>
				<li>Now, open the HTML in your browser and click the Shuffle button. The todo list should fade out, shuffle, and fade in again:<div><img alt="Figure 4.17: Output Image&#13;&#10;" src="img/C14377_04_17.jpg"/></div><pre>&lt;head&gt;
    // ... previous links and meta tags
&lt;script src="img/velocity.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;</pre></li>
				<li>Inside the <code>replaceListElements</code> function, you can now use Velocity to hide (by setting opacity to 0) the list element, <code>listEle</code>, and then empty the elements inside of it:<pre>function replaceListElements(listEle, listItems){
 Velocity(listEle, { opacity: 0 }, { duration: 0 })
 listEle.innerHTML = "";
 for (let i= 0; i&lt;= listItems.length - 1; i++){
  let liEle = document.createElement("li");
  liEle.appendChild(document.createTextNode(listItems[i]));
  listEle.appendChild(liEle)
 }
}</pre></li>
				<li> To fade the list element back in, animate <code>listEle</code> using Velocity and set the opacity to <code>1</code>. Set the code after the for loop:<pre>function replaceListElements(listEle, listItems){
 Velocity(listEle, { opacity: 0 }, { duration: 0 })
 listEle.innerHTML = "";
 for (let i= 0; i&lt;= listItems.length - 1; i++){
  let liEle = document.createElement("li");
  liEle.appendChild(document.createTextNode(listItems[i]));
  listEle.appendChild(liEle)
 }
 Velocity(listEle, { opacity: 1 }, { duration: 500 })
}</pre></li>
				<li>Now, open the HTML in your browser and click the <em class="italic">Shuffle</em> button. The <code>todo</code> list should fade out, shuffle, and fade in again.</li>
				<li>Finally, using the Anime method, go to <a href="http://cdnjs.com">cdnjs.com</a> and get the <code>Anime.js</code> CDN URL. It will appear the same as the previous output.</li>
				<li>Load the library into the head tag of your existing Todo-List-HTML using a script tag. This will allow you to use <code>Anime.js</code> within your code:<pre>&lt;head&gt;
    // ... previous links and meta tags
&lt;script src="img/anime.min.js"&gt;&lt;/script&gt;
&lt;/head&gt;</pre></li>
				<li> Inside the <code>replaceListElements</code> function, you can now use <code>Anime.js</code> to move (by using translateX = -1000) the list element, <code>listEle</code>, out of view and then empty the elements inside of it:<pre>function replaceListElements(listEle, listItems){
 anime({
  targets: listEle,
  translateX: -1000
 });
 listEle.innerHTML = "";
 for (let i= 0; i&lt;= listItems.length - 1; i++){
  let liEle = document.createElement("li");
  liEle.appendChild(document.createTextNode(listItems[i]));
  listEle.appendChild(liEle)
 }
}</pre></li>
				<li>To show the newly shuffled todo list, use <code>Anime.js</code> to animate the <code>listEle</code> list element back into view (by using translateX = 0). Do so inside a timeout to ensure that the shuffling has been done already:<pre>activity.anime.js
21 function replaceListElements(listEle, listItems){
22  anime({
23   // ANIME SOLUTION
24   targets: listEle,
25   translateX: -1000
26  });
27  listEle.innerHTML = "";
28 
29 
30  for (let i= 0; i&lt;= listItems.length - 1; i++){
31   let liEle = document.createElement("li");
32   liEle.appendChild(document.createTextNode(listItems[i]));
33   listEle.appendChild(liEle)
34  }
The full code is available at: <a href="https://packt.live/2Kd08dx">https://packt.live/2Kd08dx</a></pre></li>
				<li>Now, open the HTML in your browser and click the <em class="italic">Shuffle</em> button. The <code>todo</code> list should fade out, shuffle, and fade in again. It will appear the same as the previous output.</li>
			</ol>
			<h1 id="_idParaDest-585"><a id="_idTextAnchor651"/>Chapter 5: Beyond the Fundamentals</h1>
			<h2 id="_idParaDest-586"><a id="_idTextAnchor652"/>Activity 5.01: Simple Number Comparison</h2>
			<h3 id="_idParaDest-587"><a id="_idTextAnchor653"/>Solution</h3>
			<ol>
				<li value="1">Create the function signature:<pre>function average_grade() {</pre></li>
				<li>Copy the function arguments to a variable. This should be a new Array instance:<pre>    var args = Array.prototype.slice.call(arguments);</pre></li>
				<li>Sum all the values of the arguments and store them in a variable:<pre>    var sum = 0;    for (let i=0; i&lt;args.length; i++) {
        sum += Number(args[i]);
    }</pre><p>Remember to convert the grade values into a Number instance so that they can be correctly added together.</p></li>
				<li>Get the average of the sum and store it in a variable:<pre>    var average = sum / args.length;</pre></li>
				<li>Using the average, calculate the student's grade and return it. This can simply be a list of conditionals:<pre>    if (average &lt; 35) {
      return "F";
    }
    if (average &gt;= 35 &amp;&amp; average &lt; 45) {
      return "D";
    }
    if (average &gt;= 45 &amp;&amp; average &lt; 60) {
      return "C";
    }
    if (average &gt;= 60 &amp;&amp; average &lt; 75) {
      return "B";
    }
    return "A";
}</pre></li>
			</ol>
			<p>The output will be visible as follows:</p>
			<div><div><img alt="Figure 5.26: Activity 5.01 output&#13;&#10;" src="img/C14377_05_26.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 5.26: Activity 5.01 output</p>
			<p class="callout-heading">Note </p>
			<p class="callout">The final condition will always be true if the others have failed, so the condition itself can be skipped. Each condition will not be evaluated if the previous condition has been returned from the function.</p>
			<h2 id="_idParaDest-588"><a id="_idTextAnchor654"/>Activity 5.02:  Creating a TODO Model</h2>
			<h3 id="_idParaDest-589"><a id="_idTextAnchor655"/>Solution</h3>
			<ol>
				<li value="1">The first step is to declare the state. It must be declared outside of any function so that it exists between function calls:<pre>let todos = [];</pre></li>
				<li>Next, create the helper function that will be used to find a TODO by <code>id</code> from the <code>state</code> array. To do this, simply look through the array and return the index once it's been found. If it isn't found and the end of the array is reached, then return <code>-1</code> to denote that no TODO with the specific <code>id</code> exists:<pre>function modelFindIndex(state, id) {
  for (let i=0; i&lt;state.length; i++) {
    if (state[i].id == id) {
      return i;
    }
  }
  return -1;
}</pre></li>
				<li>Now, create the function as described in the description of this activity:<pre>function modelStateChange(state, action, data) {</pre></li>
				<li>The function will need to act differently, depending on the value of <code>action</code>. When modifying the data successfully, it should return the new state. First, handle adding a new TODO to the state for the <code>CREATE</code> action:<pre>  if (action == "CREATE") {
    console.log("created:", data);
    return state.concat(data);
  }</pre><p>Remember that the data needs to be written to the console with <code>console.log</code>.</p></li>
				<li>Next, handle the <code>REMOVE</code> functionality. This will utilize the <code>modelFindIndex</code> function to locate the <code>TODO</code> to remove:<pre>  if (action == "REMOVE") {
   let data = modelFindIndex(todos, ev.detail);
    if (i &gt; -1) {
      state = state.splice(i, 1);
      console.log("removed", data);
      return state
    }
  }</pre></li>
				<li>Finally, handle the <code>MODIFY</code> functionality. This step is a little more complex as the original data needs to be changed without changing the object reference:<pre>  if (action == "MODIFY") {
    let data = modelFindIndex(todos, ev.detail);
    if (i &gt; -1) {
      state = state.splice(i, 1);
      console.log("removed", data);
      return state
    }
  }
}</pre></li>
			</ol>
			<h1 id="_idParaDest-590"><a id="_idTextAnchor656"/>Chapter 6: Understanding Core Concepts</h1>
			<h2 id="_idParaDest-591"><a id="_idTextAnchor657"/>Activity 6.01: Making Changes to the Model</h2>
			<h3 id="_idParaDest-592"><a id="_idTextAnchor658"/>Solution:</h3>
			<ol>
				<li value="1">The page the form is in has an area to display messages. The form itself contains the title <code>textfield</code> and a description for the <code>textarea</code> field.<p>The page loads in the model code from the previous chapter, but also a new script, which will be created shortly. The <code>body</code> tag has an in-page event handler assigned to its <code>onload</code> event, which will be included in the <code>create_todos.js</code> file.</p><p>In order to use the model's module with events, you will need to extend it by providing an event handler for each action type. Add the following code to the bottom of the <code>model.js</code> file:</p><pre>function modelInit() {
  document.addEventListener("CREATE", modelCreateHandler);
}
function modelCreateHandler(ev) {
  todos = modelStateChange(todos, "CREATE", ev.detail);
  document.dispatchEvent(new Event("CHANGED", {detail: {type: "added", value: ev.detail}}));
}</pre></li>
				<li>In the <code>create_todos.js</code> file, add the <code>loadHandler</code> function:<pre>function loadHandler() {
  model_init();
  let form = document.getElementById("todo_form");
  form.addEventListener("submit", createHandler);
  document.addEventListener("CHANGED", changedHandler);
}</pre><p>This function will initialize the model and set up any necessary event handlers. As you can see, it assigns the <code>CHANGED</code> event to the <code>changedHandler</code> function. Let's create that next.</p></li>
				<li><code>changedHandler</code> is a simple affair. It simply waits for the <code>CHANGED</code> event to be raised and then updates the notifications area when it does:<pre>function changedHandler() {
  let msg = document.getElementById("notifications");
  msg.innerHTML = "The TOD<a id="_idTextAnchor659"/>O model has been updated";
  setTimeout(() =&gt; {
    msg.innerHTML = "";
  }, 3000);
}</pre><p><code>changedHandler</code> clears the notifications area after three seconds to keep things clean.</p></li>
				<li>Finally, you need to add the <code>createHandler</code> function, which handles the form's submission:<pre>create_todos.js
16 function createHandler(ev) {
17   ev.preventDefault();
18   let title = document.getElementById("title").value,
19       description = document.getElementById("description").value,
20       msg = document.getElementById("notifications");
21   let errors = [];
22   if (title.trim() == "") {
23     errors = errors.concat(["Title is not valid"]);
24   }
25   if (description.trim() == "") {
26     errors = errors.concat(["Description is not valid"]);
27   }
28   if (errors.length &gt; 0) {
29     msg.innerHTML = errors.join("/n");
30     setTimeout(() =&gt; {
The full code is available at: <a href="https://packt.live/2Xbd34R">https://packt.live/2Xbd34R</a></pre><p>The majority of this code simply ensures that values are supplied to the form before submission and will alert the user if this is not the case.</p></li>
				<li>Now, give the application a spin. If all goes well, notifications should momentarily show when submitting the form, with different messages depending on whether the fields were populated. As an example, open the browser console and simply enter the following:<pre>todos;</pre><p>You should see the submitted <code>TODO</code> objects presented there, like so:</p></li>
			</ol>
			<div><div><img alt="Figure 6.28: TODO submission form&#13;&#10;" src="img/C14377_06_27.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.28: TODO submission form</p>
			<p>Working with events provides a powerful means to keep your applications simple. What's more, it also empowers abstraction, allowing scripts to send data without them needing to know which other areas of your application are interested in those events. This promotes clean design and easier maintenance of your code.</p>
			<h1 id="_idParaDest-593"><a id="_idTextAnchor660"/>Chapter 7: Popping the Hood</h1>
			<h2 id="_idParaDest-594"><a id="_idTextAnchor661"/>Activity 7.01: Finding out the Number of Stack Frames</h2>
			<h3 id="_idParaDest-595"><a id="_idTextAnchor662"/>Solution</h3>
			<ul>
				<li>The function that establishes the call stack's limit is as follows:<p>var frameCount = 0;</p><pre>function stackOverflow() {
  frameCount++;
  stackOverflow();
}</pre><p>The solution starts out with the <code>frameCount</code> variable being initialized with the value <code>0</code>. The <code>stackOverflow()</code> function is declared, which will add 1 to the <code>frameCount</code> variable and then call itself, thus causing a stack overflow.</p></li>
				<li>Now, <code>setTimout()</code> function is initiated, which will log the value of <code>frameCount</code> to the console after a minimum of 500 milliseconds. Now, call the <code>stackOverflow()</code> function.<pre>setTimeout(() =&gt; console.log(frameCount), 500);
stackOverflow();</pre><p>This takes the <code>console.log</code> function out of the main execution thread, allowing it to be called after the stack overflow error is thrown:</p><div><img alt="Figure 7.22: Showing the solution and number of stack frames being pushed before a stack overflow is triggered&#13;&#10;" src="img/C14377_07_22.jpg"/></div></li>
			</ul>
			<p class="figure-caption">Figure 7.22: Showing the solution and number of stack frames being pushed before a stack overflow is triggered</p>
			<h1 id="_idParaDest-596"><a id="_idTextAnchor663"/>Chapter 8: Browser APIs </h1>
			<h2 id="_idParaDest-597"><a id="_idTextAnchor664"/>Activity 8.01: Creating a Simple Fractal</h2>
			<h3 id="_idParaDest-598"><a id="_idTextAnchor665"/>Solution</h3>
			<ol>
				<li value="1">We initialize the canvas and context as we did previously, but this time we add a point variable that we initialize with the coordinates of the center of the canvas:<pre>let canvas = document.getElementById('canvas');
const width = window.innerWidth;
const height = window.innerHeight;
canvas.width = width;
canvas.height = height;
let context = canvas.getContext('2d');
// Set the starting point to the center of the canvas
let point = [width / 2, height / 2];</pre></li>
				<li>Then, we begin a new path and move the point to the coordinates that were assigned to the point variable:<pre>context.beginPath();
context.moveTo(point[0], point[1]);</pre></li>
				<li>We declare <code>i</code>, which we will use as a multiplier to tell the function how long a line should be. We also declare two constants to hold the values for a margin between the fractal that we're drawing and the edge of the canvas, as well as a multiplier, which is used to increase the line length that is drawn. Then, we start a while loop, which will keep going while the point remains inside the canvas' bounds (plus the margin on each side):<pre>let i = 1;
const OFFSET = 10;
const MARGIN = 5;
while (
  point[0] &gt; MARGIN &amp;&amp;
  point[0] &lt; width - MARGIN &amp;&amp;
  point[1] &gt; MARGIN &amp;&amp;
  point[1] &lt; height - MARGIN
) {</pre></li>
				<li>Inside the while loop, the values inside the point array are increased or decreased, depending on which direction the line is being drawn and depending on the value of <code>i</code>:<pre>point[1] = point[1] - OFFSET * i;</pre></li>
				<li>Then, the lineTo function is called with the values in the point variable. Every other time a line is drawn, <code>i</code> is incremented. This means that the line's length doubles after each second drawing of a line. You could also increase <code>i</code> each time a line is drawn, and the result would be greater spacing between the lines:<pre>context.lineTo(point[0], point[1]);
  point[0] = point[0] + OFFSET * i;
  i++;
  context.lineTo(point[0], point[1]);
  point[1] = point[1] + OFFSET * i;
  context.lineTo(point[0], point[1]);
  point[0] = point[0] - OFFSET * i;
  i++;
  context.lineTo(point[0], point[1]);
}</pre></li>
				<li>Finally, when the while loop's termination condition is met (when the point reaches within 5 pixels of one of the edges of the canvas), the stroke() method of the context is called to add a stroke to the lines we've described:<pre>context.stroke();</pre><p>There are many more methods available in the Canvas API, and many possibilities for their use. You can draw complicated patterns, pictures, and graphs, and animate anything you draw. You should explore the Canvas API in more depth to find out what it can do. </p></li>
			</ol>
			<h2 id="_idParaDest-599"><a id="_idTextAnchor666"/>Activity 8.02: Playing Sound and Controlling Frequency Using Two Oscillators</h2>
			<h3 id="_idParaDest-600"><a id="_idTextAnchor667"/>Solution</h3>
			<ol>
				<li value="1">Initialize an audio context and a volume node:<pre>let context = new AudioContext();
let volume = context.createGain();</pre></li>
				<li>Create a gain node and connect it to the context's destination:<pre>volume.connect(context.destination);</pre></li>
				<li>Initialize two oscillators (one for each coordinate of the cursor):<pre>let osciA = context.createOscillator();
let osciB = context.createOscillator();</pre></li>
				<li>Set the oscillator types (feel free to use any types you like), connect them to the volume node, and call their start() methods:<pre>osciA.type = 'sawtooth';
osciB.type = 'square';
osciA.connect(volume);
osciB.connect(volume);
osciA.start();
osciB.start();</pre></li>
				<li>Create an event listener that listens for the <code>mousemove</code> event on the <code>document</code> and set the oscillators' frequencies based on the cursor's position:<pre>document.addEventListener('mousemove', event =&gt; {
  osciA.frequency.value = event.clientY;
  osciB.frequency.value = event.clientX;
});</pre></li>
			</ol>
			<p>The callback function that's passed to the event listener assigns the cursor's x and y values to the two oscillator nodes' frequency values every time the 'mousemove' event is fired. This is a simple solution: it inherently limits the upper-frequency values for each oscillator depending on the width and height of the browser window. This is fine as a demonstration, but a better implementation would assign the same arbitrary upper-frequency value at the right-most and bottom-most parts of the document, no matter its dimensions.</p>
			<h2 id="_idParaDest-601"><a id="_idTextAnchor668"/>Activity 8.03: Audio Visualization </h2>
			<h3 id="_idParaDest-602"><a id="_idTextAnchor669"/>Solution</h3>
			<ol>
				<li value="1">Create a simple HTML file with a link to a JavaScript file called scripts.js (or anything you want to call it), with a &lt;canvas&gt; element in the body and with an ID of canvas in the DevTools console:<pre>&lt;!-- index.html --&gt;
&lt;!DOCTYPE html&gt;
&lt;html&gt;
  &lt;head&gt;
    &lt;script src='scripts.js'&gt;&lt;/script&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;canvas id='canvas'&gt;&lt;/canvas&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre></li>
				<li>In the scripts.js file, we will add an event listener on the document listening for a click event. As we saw in the <em class="italic">Audio API</em> section of this chapter, in many modern browsers, audio is disabled until the user has interacted with the page, so waiting for the click event is an easy way to make sure we don't get any errors in this regard:<pre>// scripts.js
document.addEventListener('click', () =&gt; {</pre></li>
				<li>We then get hold of the canvas element, create a canvas context, set the canvas' width and height, and get its center x/y coordinates. We also instantiate a variable that will hold the Y value of the mouse's position:<pre>  // initialise canvas and related variables
  let canvas = document.getElementById('canvas');
  let canvasContext = canvas.getContext('2d');
  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;
  let centerX = width / 2;
  let centerY = height / 2;
  let mouseY; // this will be set in the 'mousemove' event handler</pre></li>
				<li>Then, we will create an audio context, a gain node, an oscillator node, and an analyzer node. We connect the oscillator to the volume node and the analyzer node, and then connect the volume node to the audio context's destination:<pre>  // initialise Audio context, nodes and related variables
  let audioContect = new AudioContext();
  let volume = audioContect.createGain();
  let osciA = audioContect.createOscillator();
  let analyser = audioContect.createAnalyser();
  let waveform = new Float32Array(analyser.frequencyBinCount);
  osciA.type = 'sine';
  osciA.connect(volume);
  osciA.connect(analyser);
  volume.connect(audioContect.destination);
  volume.gain.value = 1;
  osciA.start();</pre></li>
				<li>Next, we listen for mousemove events, and in the callback function for the event, we assign the cursor's X position to the oscillator's frequency value and the cursor's Y position to the mouseY variable. This means that the cursor's X position will control the frequency of the oscillation. We'll see what the mouseY variable is used for shortly:<pre>  // set oscillator frequency from mouse's x-position
  document.addEventListener('mousemove', event =&gt; {
    osciA.frequency.value = event.clientX;
    mouseY = event.clientY;
  });</pre></li>
				<li>Now, we come to the meat of the application. We call the draw() function. This function tells the browser that we want to draw a frame of an animation, and by proving the draw() function as the callback, it repeats this function once for each time the page is rendered:<pre>// start drawing
  draw();</pre></li>
				<li>Next, we get the waveform data from the analyzer, which is copied to the waveform array. Then, we clear the canvas from any previous stroke() methods and begin a new path:<pre>  // the draw function
  function draw() {
    let drawing = window.requestAnimationFrame(draw); // Repeat the drawing function on every animation frame
    analyser.getFloatTimeDomainData(waveform);
    canvasContext.clearRect(0,0,canvas.width,canvas.height); // empty the canvas, so we don't get arcs drawn on top of each other
    canvasContext.beginPath();</pre></li>
				<li>Now, we come to looping through the waveform array. For each item in the array (which represents points of the waveform), we will plot a small section of a circle. The circle will be divided into as many sections as there are items in the array. Each section has a radius of half the width of the canvas, minus the mouse's Y position, plus the current chunk of the waveform's amplitude (multiplied by an arbitrary number, that is, 15). The result of this could be a negative number if the mouse is more than halfway across the screen, so we wrap the whole thing in Math.abs(), which returns the absolute value (no negatives!) of a number:<pre>    // plot a section of the circle for each part of the waveform
    for(let i = 0; i&lt;waveform.length; i++) {
      let radius = Math.abs(((width / 2) - mouseY) + (waveform[i] * 15));</pre></li>
				<li>Next, we need to set the start angle and end angle of the arc in radians. A whole circle is 2*π radians, but we're dividing the circle into as many arcs as there are items in the waveform array. Therefore, we can calculate the starting angle as ((2 / waveform.length) * i) *π, where waveforms.length is how many items there are and i is the current chunk of the waveform/our circle we're on. We just add 1 to i for the end angle as each chunk's end angle is the same as the next one's starting angle:<pre>      let startAngle = ((2 / waveform.length) * i) * Math.PI;</pre><p>      let endAngle = ((2 / waveform.length) * i) * Math.PI;</p></li>
				<li>After all that is done, and we call the arc() method of the canvas context, we can call the stroke() method to add a stroke to all the arcs we just plotted:<pre>      canvasContext.arc(centerX, centerY, radius, startAngle, endAngle);
    }</pre></li>
				<li>Put that all together, run it, and click on the page: we should get a very nice oscillating circle, whose diameter increases with the cursor's y-position, and the oscillation of which matches the sound of the sine wave coming from the speakers. This, incidentally, can be controlled with the cursor's x-position. Big fun:<pre>    canvasContext.stroke();
  };
})</pre></li>
			</ol>
			<h1 id="_idParaDest-603"><a id="_idTextAnchor670"/>Chapter 9: Working with Node.js</h1>
			<h2 id="_idParaDest-604"><a id="_idTextAnchor671"/>Activity 9.01: Create a Web Application to Upload, Store, and Save Image Details</h2>
			<h3 id="_idParaDest-605"><a id="_idTextAnchor672"/>Solution</h3>
			<ol>
				<li value="1">Let's first go through the directory structure and define the folders to upload the images:<div><img alt="Figure 9.22: Directory structure for this activity&#13;&#10;" src="img/C14377_09_22.jpg"/></div><p class="figure-caption">Figure 9.22: Directory structure for this activity</p><p>As you can see, in this project you will try to upload images in the <code>public/images</code> directory. This directory must be present at the root of the project and the current user should have read and write access to this directory. By defa<a id="_idTextAnchor673"/>ult, you will get both the permissions to this directory.</p><p class="callout-heading">Note </p><p class="callout">The source code will only contain two files (<code>app.js</code> and <code>package.json</code>). All the other files shown in the <code>images</code> directory in the preceding figure will not be present there. Once you start uploading files, you will see all the uploaded images there.</p><p>Before proceeding further, be sure to create a <code>public/images</code> directory in the root of this project that relates to <code>app.js</code> and <code>package.json</code>. The currently logged-in user of your machine must have the permissions to add files in this directory.</p></li>
				<li>The first step is to import all the dependencies:<pre>const express   = require('express');
const multer            = require('multer');
const MySQL             = require('MySQL');
const morgan    = require('morgan')
const app               = express();
const port              = 3000;</pre></li>
				<li>Then let's configure <code>morgan</code> to log each of our request details in the console. You can use <code>morgan</code> as a middleware:<pre>// Middleware for logging requests
app.use(morgan(':method :status :url - :response-time ms'));</pre></li>
				<li>Now let's configure the database. In this project, you will use a <code>MySQL</code> database:<pre>/*
* Database
*/
// Creating MySQL Connection
let connection = MySQL.createConnection({
   host         : 'localhost',
   user         : 'root',
   password     : '12345678',
   database     : 'packt_JavaScript'
});
       
// Connection to db
connection.connect();</pre><p>Make sure you pass the credentials of the user you created earlier while going through the <em class="italic">Setting Up Databases</em> section.</p></li>
				<li>When your application has established a database connection, it's time to install <code>multer</code> by executing the following command through the terminal in the root of the project:<pre>npm i multer --save</pre></li>
				<li>Now, let's configure <code>multer</code> by adding the code from the <code>app.js</code> file:<pre>/*
* File Upload Settings
*/
let storage = multer.diskStorage({
        destination: (req, file, cb) =&gt; {
                  cb(null, 'public/images')
        },
        filename: (req, file, cb) =&gt; {
                let ext = file.originalname.split('.').pop();
                  cb(null, 'img_' + Date.now() + '.' + ext);
        }
});
let upload = multer({storage: storage});    </pre><p>This code will set the destination where all files will be uploaded, which is <code>public/images</code>, and you are also changing the <code>filename</code> after upload to avoid issues with duplicate filenames.</p></li>
				<li>Now let's configure some routes in your application:<pre>app.js
39 /*
40 * Routing
41 */
42 // Landing route
43 app.get('/', (req, res) =&gt; res.send('Hello World!'))
44 
45 // Upload image route
46 app.post('/upload/image', upload.single('image'), function (req, re s) {
47        // Column name: values
48        let payload = {
49                filename: req.file.filename,
50                type: req.file.mimetype,
51                original_name: req.file.originalname,
52                path: req.file.path,
53                size: req.file.size
54 }
The full code is available at: <a href="https://packt.live/2NIE6RR">https://packt.live/2NIE6RR</a></pre></li>
				<li>The last step is to start the server:<pre>// Start listening to requests
app.listen(port, () =&gt; console.log(`App listening on port http://localhost:${port}!`))</pre></li>
				<li>That's it. The server is now up and running. The final thing is to send a request to upload the image on the server. For this, we will use Postman (the Chrome extension) as our client:</li>
			</ol>
			<div><div><img alt="Figure 9.23: API response in Postman&#13;&#10;" src="img/C14377_09_23.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 9.23: API response in Postman</p>
			<h1 id="_idParaDest-606"><a id="_idTextAnchor674"/>Chapter 10: Accessing External Resources</h1>
			<h2 id="_idParaDest-607"><a id="_idTextAnchor675"/>Activity 10.01: Implement REST Service Calls Using Various Techniques</h2>
			<h3 id="_idParaDest-608"><a id="_idTextAnchor676"/>Solution:</h3>
			<ol>
				<li value="1">Use <code>$.ajax()</code> with <code>method: 'post'</code> and <code>dataType: 'json'</code>:<pre>solution_using_jquery_ajax.html
    $.ajax({
        method: 'post',
        dataType: 'json',
        url: 'https://reqres.in/api/users',</pre></li>
				<li>Enclose your data fields in an object, <code>{}</code>:<pre>        data: {
            "name": "Beyonce Knowles",
            "occupation": "artist"
        },</pre></li>
				<li>Create a <code>success</code> function to output the expected values:<pre>        success: function (data) {
            console.log("Returned id " + data.id + 
                        ", createdAt " + data.createdAt);
            console.log(data);
            }
        });</pre><p>The boilerplate HTML is omitted and left as an exercise for you. The preceding code would result in something like the following in the JavaScript Console in Google Chrome. (All the solutions presented have similar output):</p><div><img alt="Figure 10.17: JavaScript Console output&#13;&#10;" src="img/C14377_10_17.jpg"/></div><p class="figure-caption">Figure 10.17: JavaScript Console output</p></li>
				<li>Now, let's get the same output using the <code>$.post()</code> method and using the file <code>solution_using_jquery_post.html</code>:<pre>$.post('https://reqres.in/api/users',</pre></li>
				<li>Enclose your data fields in an object, <code>{}</code>:<pre>{
            "name": "Beyonce Knowles",
            "occupation": "artist"
        },</pre></li>
				<li>Create a <code>success</code> function to output the expected values:<pre>function (data) {
            console.log("Returned id " + data.id + 
                        ", createdAt " + data.createdAt);
            console.log(data);
        },</pre></li>
				<li>As the last parameter to <code>$.post()</code>, use the <code>'json'</code> value to indicate the expected JSON return type:<pre>'json'
    );</pre><p>The output will be the same as is shown in <em class="italic">Figure 10.17</em>.</p></li>
				<li>Finally, create a new <code>XMLHttpRequest</code> object:<pre>const url = "https://reqres.in/api/users";
var xhttp = new XMLHttpRequest();</pre></li>
				<li>Call <code>open('POST')</code>:<pre>xhttp.open('POST', url);</pre></li>
				<li>Set the <code>Content-type</code> and <code>Accept</code> request headers to the appropriate values:<pre>xhttp.setRequestHeader("Content-type", "application/json");
xhttp.setRequestHeader('Accept', 'application/json');</pre></li>
				<li>Create a function for <code>onreadystatechange</code> that checks for a status code of <code>201 (Created)</code> and parses the JSON data with <code>JSON.parse()</code>:<pre>xhttp.onreadystatechange = function() {
    if (this.readyState == 4 &amp;&amp; this.status == 201) {
        const data = JSON.parse(this.response);
        console.log("Returned id " + data.id + 
                    ", createdAt " + data.createdAt);
        console.log(data);
    }
}</pre></li>
				<li>Call <code>JSON.stringify()</code> on the input data to convert it to JSON format:<pre>var data = JSON.stringify({
    "name": "Beyonce Knowles",
    "occupation": "artist"
});</pre></li>
				<li>Send the JSON data when calling <code>send()</code>:<pre>xhttp.send(data);</pre><p>The output will be the same as is shown in <em class="italic">Figure 10.17</em>.</p></li>
			</ol>
			<h1 id="_idParaDest-609"><a id="_idTextAnchor677"/>Chapter 11: Creating Clean and Maintainable Code</h1>
			<h2 id="_idParaDest-610"><a id="_idTextAnchor678"/>Activity 11.01: Expanding Phone Number Matching Patterns to Accept Multiple Formats</h2>
			<h3 id="_idParaDest-611"><a id="_idTextAnchor679"/>Solution:</h3>
			<ol>
				<li value="1">Observe that only the characters at the beginning of each pattern differ, but the last characters, <code>XXX-XXXX</code>, are the same in both patterns.</li>
				<li>For the differing characters, for our regex to match either format correctly, you can specify the regex snippets that correspond to each format as alternate expressions of an alternation. Recall that alternations take the form of (<code>expression1|expression2)</code>:<pre>    <strong class="bold">(</strong>[2-9]\d{2}-<strong class="bold">|</strong>\([2-9]\d{2}\) )
where Regex for XXX-\Regex for (XXX)</pre></li>
				<li>Combine it with the rest of the original regex to get the complete regex:<pre>    ^([2-9]\d{2}-|\([2-9]\d{2}\) )\d{3}-\d{4}$</pre></li>
				<li><a id="_idTextAnchor680"/>Remember that the original regex, <code>\d{3}-\d{4}</code>, matches <code>XXX-XXXX,</code> which is the same for both patterns. We only needed the alternation for the beginning parts of each pattern that differed. The <code>^</code> and <code>$</code> characters also enforce that there are no other characters before or after the acceptable ones.<p>Now, when you replace this correct regex into our tool, only the first two test strings match ( as expected)</p></li>
			</ol>
			<div><div><img alt="Figure 11.23: After using the correct regex, only the first two test strings match (as expected)&#13;&#10;" src="img/C14377_11_23.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 11.23: After using the correct regex, only the first two test strings match (as expected)</p>
			<p>In <em class="italic">Exercise 11.01, The Effect of the g Flag</em>, and this activity, we created regex expressions to accept US number formats. We will now modify the regex to accept non-US number formats.</p>
			<h2 id="_idParaDest-612"><a id="_idTextAnchor681"/>Activity 11.02: Expanding Phone Number Matching Patterns to Accept a Particular Format</h2>
			<h3 id="_idParaDest-613"><a id="_idTextAnchor682"/>Solution:</h3>
			<ol>
				<li value="1">Construct the regex for the <code>+XXX</code> pattern (where between 1-3 digits are acceptable):<pre>    (\+\d{1,3} )?</pre><p>We need two things here:</p><p>The first <code>+</code> needs to be escaped due to it being a special character.</p><p>Notice the parenthesis with <code>?</code> after it. This specifies that whole expression within the parenthesis can occur 0 or 1 times. In other words, the characters in the expression are optional. The <code>\d{1,3}</code> expression is a range quantifier requiring between 1 and 3 digits.</p></li>
				<li>By prepending this to the regex from the previous activity, the whole regex is now as follows:<pre>    ^(\+\d{1,3} )?([2-9]\d{2}-|\([2-9]\d{2}\) )\d{3}-\d{4}$</pre><p class="callout-heading">Note</p><p class="callout">See the previous activity for a full description of the latter parts of the regex.</p></li>
				<li>To kick it up one more notch, here are some of the changes we can make to the regex that allows us to use space or dot characters as digit separators rather than only dashes:<pre>    ^(\+\d{1,3} )?([2-9]\d{2}|\([2-9]\d{2}\))<code>[-. ]</code> set allows a dash, dot, or space character to be used as the separator.</p><p>This modification now allows all the formats shown in the following screenshot to match:</p><p class="callout-heading">Note</p><p class="callout">One flaw with this regex is that it allows you to mix and match what characters are used as separators. For example, you can use a dash and dot, like so: 234-567.8910. It is possible to make the regex stronger, but the result will end up being very long and convoluted.</p></li>
			</ol>
			<h2 id="_idParaDest-614"><a id="_idTextAnchor683"/>Activity 11.03: Refactoring to Clean Code</h2>
			<h3 id="_idParaDest-615"><a id="_idTextAnchor684"/>Solution:<strong class="bold"> </strong></h3>
			<p class="callout-heading">Note</p>
			<p class="callout">There are many ways the code could be refactored. The following solution represents one way, along with explanatory comments.</p>
			<ol>
				<li value="1">Use the <code>activity_solution.html</code> file. The HTML code remains the same as the original code. Only the contents of the <code>&lt;script&gt;</code> section are replaced.</li>
				<li>We start refactoring the code by creating a function called <code>processForm()</code>:<pre>document.getElementById("calc_button").addEventListener("click ", processForm);
function processForm() {
    resetErrorsAndResults();
    const formFields = getFormFields();
    const validationError = formFields.validate();
    if (validationError) {
        displayError(validationError);
        return;
    }
    const result = doCalculation(formFields);
    displayResult(result);
}</pre><p>The original code had one very long method that did all the form field processing, validations, and calculations. The new code creates new methods for different concerns. These methods are short and mostly focused on just one task.</p><p>The code reads like a narrative story with paragraphs and sentences in mostly plain English. It is easy to see the logic and flow just by reading it, and there's not much clutter: reset the errors and results, get the form fields, validate the fields and show errors (if any), do the calculation, and display the results. The gory details of each of these are contained within other methods.</p></li>
				<li>We will also create a function called <code>resetErrorsAndResults()</code>. By the name and implementation, it is easy to tell what the purpose of this function is, and the function is limited to just that specific purpose:<pre>function resetErrorsAndResults() {
    document.getElementById("error").innerHTML = "";
    document.getElementById("result").innerHTML = "";
}</pre></li>
				<li>For the next refactoring, we have decided to create a class that holds form field values and performs validations:<pre>activity_solution.html
63 class FormFields {
64     constructor(numHours, payRate, workerType) {
65         this.numHours = numHours;
66         this.payRate = payRate;
67         this.workerType = workerType;
68     }
69
70     validate() {
71         let validationError = this.validateNumHours();
72         if (validationError) {
73             return validationError;
74         }
The full code is available at: <a href="https://packt.live/372KXxp">https://packt.live/372KXxp</a></pre><p>Validation methods are simple and only return a string with an error message if the regex test fails. Displaying error messages is a separate concern (unlike the original code, which combined the concerns). It contains a constructor where the form field values are passed in rather than us having to get the values directly from the form, thus allowing the class and validations to be tested independently of the form itself.</p></li>
				<li>Next, we create a function called <code>getFormFields()</code>. This function is limited to getting the values from the form and creating an instance of the <code>FormFields</code> class:<pre>function getFormFields() {
    const numHours = document.getElementById("numHours").value;
    const payRate = document.getElementById("payRate").value;
    const workerType =
        document.querySelector('input[name="workerType"]:checked').value;
    return new FormFields(numHours, payRate, workerType);
}</pre><p>These methods have no side effects as they facilitate testing. This is because the return values are always predicable for a given set of input parameters.</p></li>
				<li>The <code>displayError()</code> and <code>displayResult()</code> functions are straightforward and do just one thing:<pre>function displayError(error) {
    document.getElementById("error").innerHTML = error;
}
function displayResult(result) {
    document.getElementById("result").innerHTML =
        `Total pay check: ${result.toFixed(2)}`;
}</pre><p>The <code>switch</code> statement in the original code was just screaming out "refactor me" to separate functions for each case! We will refactor this so that it uses an associative array called <code>calculateFunctions</code>. The key of each entry in the array is <code>workerType</code> and the user that's selected from the radio buttons, along with a reference to the function that contains the corresponding calculation logic for the value. These are minimal comments since the method, object, and variable names are self-documenting.</p></li>
				<li>Also, the <code>calculateStandardWorkerPay()</code>, <code>calculateNoOvertimeWorkerPay()</code>, and <code>calculateDoubleOvertimeWorkerPay()</code> functions take the same two parameters and have the same return value definition, so they could be called abstractly in <code>doCalculation()</code>:</li>
			</ol>
			<pre>activity_solution.html
108 const calculateFunctions = {
109     "standard": calculateStandardWorkerPay,
110     "no_overtime": calculateNoOvertimeWorkerPay,
111     "double_overtime": calculateDoubleOvertimeWorkerPay
112 };
113 
114 function doCalculation(formFields) {
115     // determine function to use for calculation based on worker type
116     const calculateFunction = calculateFunctions[formFields.workerType];
117     return calculateFunction(formFields.numHours, formFields.payRate);
118 }
119 
120 function calculateStandardWorkerPay(numHours, payRate) {
121     if (numHours &lt; 40) {
122         return numHours * payRate;
123     }
The full code is available at: <a href="https://packt.live/373ThN5">https://packt.live/373ThN5</a></pre>
			<p>In a real application, you may consider using one of the many available validation frameworks rather than rolling your own. For calculation purposes, this implementation chose to use functions in an associative array. One alternative to consider is creating a class hierarchy where subclasses implement or override a calculation method in a base class.</p>
			<h1 id="_idParaDest-616"><a id="_idTextAnchor685"/>Chapter 12: Using Next-Generation JavaScript</h1>
			<h2 id="_idParaDest-617"><a id="_idTextAnchor686"/>Activity 12.01: Creating a Project to Recognize and Compile TypeScript Files</h2>
			<h3 id="_idParaDest-618"><a id="_idTextAnchor687"/>Solution:</h3>
			<ol>
				<li value="1">The first step is to create a new project directory, then <code>cd</code> into it, and initialize it for npm:<pre>mkdir my_app
cd my_app
npm init</pre></li>
				<li>Next, install Parcel as a global library:<pre>npm install -g parcel</pre></li>
				<li>Now, you will need to install TypeScript, which you can also save as a global library:<pre>npm install -g typescript</pre></li>
				<li>To generate the configuration for TypeScript, you simply need to call the TypeScript CLI tool, <code>tsc</code>, and pass it the <code>--init</code> flag:<pre>tsc --init</pre><p>If all went well, you should be presented with a message such as the following:</p><pre>message TS6071: Successfully created a tsconfig.json file.</pre><p>You should also find a new <code>tsconfig.json</code> file in the root of your project folder.</p></li>
				<li>Next, create a directory called <code>src</code> and place an <code>index.ts</code> file within it. Add the following code as the file's content:<pre>const message:string = "Hello, World!";
console.log(message);</pre></li>
				<li>With everything in place, update the <code>package.json</code> file to include the following script:<pre>"build": "parcel build src/index.ts"</pre></li>
				<li>Finally, run the script by invoking the <code>npm</code> executable:<pre>npm run build</pre><p>You should see a successful <code>Built</code> message output onscreen, as well as the expected <code>dist</code> folder containing transpiled <code>js</code> files in the project root.</p></li>
			</ol>
			<h1 id="_idParaDest-619"><a id="_idTextAnchor688"/>Chapter 13: JavaScript Programming Paradigms</h1>
			<h2 id="_idParaDest-620"><a id="_idTextAnchor689"/>Activity 13.01: Creating a Calculator App</h2>
			<h3 id="_idParaDest-621"><a id="_idTextAnchor690"/>Solution</h3>
			<ol>
				<li value="1">Create an empty file and call it <code>procedural.js</code>.</li>
				<li>Initialize an array that will maintain the history of function calls:<pre>lethistoryList = [];</pre></li>
				<li>Now, create simple addition, subtraction, multiplication, division, and power functions:<pre>procedural.js
3 function add(m, n){
4 historyList.push(['ADD', m, n]);
5 return m+n;
6 }
7 
8 function subtract(m, n){
9 historyList.push(['SUB', m, n]);
10 return m-n;
11 }
12 
13 function multiply(m, n){
14 historyList.push(['MUL', m, n]);
15 return m*n;
16 }
The full code is available at: <a href="https://packt.live/2Xf6kHk">https://packt.live/2Xf6kHk</a></pre></li>
				<li>Create a <code>history</code> function, which will maintain the history of function calls:<pre>function history(){
 historyList.map((command, index)=&gt;{
  console.log(index+1+'.', command.join(' '));
 })
}Call all the functions one by one with some random numbers as parameters:
console.log('ADD 2 3 :', add(2, 3));
console.log('SUB 2 3 :', subtract(2, 3));
console.log('MUL 2 3 :', multiply(2, 3));
console.log('DIV 2 3 :', divide(2, 3));
console.log('POW 2 3 :', pow(2, 3));</pre></li>
				<li>Now, print the <code>history</code>:<pre>console.log('----------------HISTORY---------------');
history();</pre><p>The output of this code will be as follows:</p><div><img alt="Figure 13.15: Output with the procedural approach&#13;&#10;" src="img/C14377_14_151.jpg"/></div><p class="figure-caption">Figure 13.15: Output with the procedural approach</p></li>
				<li>Now, create a class and call it <code>calculator</code>:<pre>class Calculator {}</pre></li>
				<li>Then, initialize a <code>historyList</code> array, which will maintain the history of all function calls:<pre> constructor() {
  this.historyList = []
 }</pre></li>
				<li>Now, create simple <code>add</code>, <code>subtract</code>, <code>multiply</code>, <code>divide</code>, and <code>pow</code> methods:<pre>oop.js
6  add(m, n) {
7   this.historyList.push(['ADD', m, n]);
8   return m+n;
9  }
10 
11  subtract(m, n) {
12   this.historyList.push(['SUB', m, n]);
13   return m-n;
14  }
15 
16  multiply(m, n) {
17   this.historyList.push(['MUL', m, n]);
18   return m*n;
19  }
The full code is available at: <a href="https://packt.live/2O70oMi">https://packt.live/2O70oMi</a></pre></li>
				<li>Add one more method, which will show the history of the operations:<pre> history() {
  this.historyList.map((command, index)=&gt;{
   console.log(index+1+'.', command.join(' '));
  })
 }</pre></li>
				<li>Lastly, create an instance of this class and call its method with simple numbers to perform mathematical operations:<pre>let calc = new Calculator();
console.log('ADD 2 3 :', calc.add(2, 3));
console.log('SUB 2 3 :', calc.subtract(2, 3));
console.log('MUL 2 3 :', calc.multiply(2, 3));
console.log('DIV 2 3 :', calc.divide(2, 3));
console.log('POW 2 3 :', calc.pow(2, 3));</pre></li>
				<li>To check its history, call the <code>history</code> method of the <code>calculator</code> class:<pre>calc.history();</pre><p>The output of this code will be as follows:</p></li>
			</ol>
			<div><div><img alt="Figure 13.16: Output with the object-oriented approach&#13;&#10;" src="img/C14377_14_161.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 13.16: Output with the object-oriented approach</p>
			<h1 id="_idParaDest-622"><a id="_idTextAnchor691"/>Chapter 14: Understanding Functional Programming</h1>
			<h2 id="_idParaDest-623"><a id="_idTextAnchor692"/>Activity 14.01: Blackjack Card Functions</h2>
			<h3 id="_idParaDest-624"><a id="_idTextAnchor693"/>Solution:</h3>
			<ol>
				<li value="1">In the <code>blackjack/start.html</code> file, find the opening script tag and add some functions for defining the elements of a deck and creating an ordered deck:<pre>solution.html
88 const suits =
89     () =&gt; [
90        { suit: "hearts", symbol: '&amp;#9829;' },    // symbol: '♥'
91        { suit: 'diamonds', symbol: '&amp;#9830;' },  // symbol: '♦'
92        { suit: 'spades', symbol: '&amp;#9824;' },    // symbol: '♠'
93        { suit: 'clubs', symbol: '&amp;#9827;' }      // symbol: '♣'
94     ];
95 const rankNames =
96     () =&gt; ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K'];
97 
98 const ranks =
99     rankNames =&gt; rankNames.map(
100         (rank, index) =&gt; ({ rank, value: Math.min(10, index + 1) 101 }));
The full code is available at: <a href="https://packt.live/2QgJ0Y2">https://packt.live/2QgJ0Y2</a></pre></li>
				<li>Below this code, define how to create a deck by adding the core functional programming methods:<pre>const compose =
    (...fns) =&gt; input =&gt; fns.reduceRight((prev, fn) =&gt; fn(prev), input);
const pipe = (...fns) =&gt; input =&gt; fns.reduce((prev, fn) =&gt; fn(prev), input);
const map = fx =&gt; arr =&gt; arr.map(fx);</pre></li>
				<li>Next, add the functions for shuffling a deck, as we did in <em class="italic">Exercise 14.09: Using the pipe Method to Create a Card Shuffling Function</em>:<pre>solution.html
117 const addRandom =
118     randomizer =&gt; deck =&gt; deck.map(card =&gt; ({
119         random: randomizer(),
120         card
121     }));
122 
123 const sortByRandom =
124     deck =&gt; [...deck].sort((a, b) =&gt; a.random - b.random);
125 
126 const shuffle =
127     (deck, randomizer) =&gt; {
128         const doShuffle = pipe(
129             addRandom(randomizer),
130             sortByRandom,
131             map(card =&gt; card.card)
132         );
The full code is available at: <a href="https://packt.live/2QlDGCZ">https://packt.live/2QlDGCZ</a></pre></li>
				<li>Now, we will add functions for drawing a card, getting the sum of a player's cards, checking whether a hand is over 21 points, and checking whether the game is over:<pre>const draw =
    (deck, n = 1) =&gt; [deck.slice(0, n), deck.slice(n)];
const sumCards =
    cards =&gt; cards.reduce((total, card) =&gt; total + card.value, 0);
const isBust =
    total =&gt; total &gt; 21;
const isGameOver =
    (bust, stay) =&gt; bust || stay;</pre></li>
				<li>Next, we need to add a way to update the visual display and the cards shown to the user. One way this can be done is as follows:<pre>const updateCardDisplay =
    ({ updateHTML }, hand) =&gt; {
        const cardHtml = hand.map((card, index) =&gt; 
            `&lt;div class="card ${card.suit}"
                style="top: -${index * 120}px; 
                       left: ${index * 100}px;"&gt;
                &lt;div class="top rank"&gt;${card.rank}&lt;/div&gt;
                &lt;div class="bigsuit"&gt;${card.symbol}&lt;/div&gt;
                &lt;div class="bottom rank"&gt;${card.rank}&lt;/div&gt;
             &lt;/div&gt;`);
        updateHTML("cards", cardHtml.join(""));
    };</pre></li>
				<li>The next part of the visual display is the status display, which tells the user the sum of their hand and whether the game is over. The implementation that will be used in this solution consists of the two functions shown in the following code:<pre>const showOrHide =
    (updateStyle, element, hide) =&gt;
        updateStyle(element, "display", hide ? "none" : "");
const updateStatusDisplay =
    ({ updateStyle, updateHTML }, hand, stay) =&gt; {
        const total = sumCards(hand);
        updateHTML("totalSpan", total);
        const bust = isBust(total);
        const gameover = isGameOver(bust, stay);
        showOrHide(updateStyle, "playBtn", !gameover);
        showOrHide(updateStyle, "hitBtn", gameover);
        showOrHide(updateStyle, "stayBtn", gameover);
        let statusMsg = gameover ?
            "Game over.  Press New Game button to start again." :
            "Select Hit or Stay";
        statusMsg = bust ? "You went bust!!! " + statusMsg : statusMsg;
        updateHTML("statusMsg", statusMsg);
    };</pre></li>
				<li>Now, we're going to add functions for each action a user can take, such as <code>play</code>, <code>stay</code>, and <code>hit</code>. We will call these handlers:<pre>const playHandler = (randomizer, { getState, setState }) =&gt; () =&gt; {
     const orderedDeck = createOrderedDeck(suits(), ranks(rankNames()));
     let gameDeck = shuffle(orderedDeck, randomizer);
     [hand, gameDeck] = draw(gameDeck, 2);
     setState(hand, gameDeck);
 };
 
const hitHandler = ({ getState, setState }) =&gt; () =&gt; {
     [hand, gameDeck] = getState();
     [card, gameDeck] = draw(gameDeck, 1);
     setState(hand.concat(card), gameDeck);
 };
 
const stayHandler = ({ getState, setState }) =&gt; () =&gt; {
     [hand, gameDeck] = getState();
setState(hand, gameDeck, true);
};</pre></li>
				<li>You may have noticed that, in the solution steps, there are some variables that haven't been defined. We've saved these for a section at the end that includes all non-purely functional code:<pre>Solution.html
206 // impure functions
207 
208 const byId =
209     elementId =&gt; document.getElementById(elementId);
210 
211 const updateHTML =
212     (elementId, html) =&gt; byId(elementId).innerHTML = html;
213 
214 const updateStyle =
215     (elementId, style, value) =&gt; byId(elementId).style[style] = value;
216 
217 const randomizer =
218     Math.random;
The full code is available at: <a href="https://packt.live/2FnuFCH">https://packt.live/2FnuFCH</a></pre></li>
				<li>We now have almost a completely working game. All we need to do is set the state and call that to tell the game to start:<pre>const createState = (dom) =&gt; {
    let _state;
    const getState = () =&gt; [..._state];
    const setState =
        (hand, gameDeck, stay = false) =&gt; {
            _state = [hand, gameDeck];
            updateCardDisplay(dom, hand);
            updateStatusDisplay(dom, hand, stay);
        };
    return { getState, setState };
}
startGame(createState(dom));</pre></li>
			</ol>
			<p>With these steps done, you should now be able to open the HTML file in a browser and have a running version of the game, as shown in the following screenshot:</p>
			<div><div><img alt="Figure 14.17: Screenshot of the Blackjack game&#13;&#10;" src="img/C14377_15_17.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.17: Screenshot of the Blackjack game</p>
			<p>If you're unsure about whether you followed the solution steps correctly, feel free to take a look at the <code>blackjack/solution.html</code> file and compare it with your own implementation. </p>
			<h1 id="_idParaDest-625"><a id="_idTextAnchor694"/>Chapter 15: Asynchronous Tasks</h1>
			<h2 id="_idParaDest-626"><a id="_idTextAnchor695"/>Activity 15.01: Refactoring Promise Code to await/async Syntax</h2>
			<h3 id="_idParaDest-627"><a id="_idTextAnchor696"/>Solution</h3>
			<p>Here's one implementation of equivalent code that uses <code>async/await</code>:</p>
			<ol>
				<li value="1">Define the promise variables as follows:<pre>(async () =&gt; {  
    let p1 = use1(); 
    let p2 = use2(); 
    let p3 = use3(); </pre></li>
				<li>It would not have been correct to place the <code>await</code> keyword in the initial block when calling each function like this:<pre>    let p1 = await use1();
    let p2 = await use2();
    let p3 = await use3();</pre><p>This is because each of the use cases has a different timeout defined. If you used <code>await</code> when calling <code>use1()</code>, it would have caused a delay of 3 seconds until it completed before <code>use2()</code> was even initiated, which is not what you want. Rather, our desire is for all three use cases to trigger one right after the other with no delay, so they execute concurrently.</p></li>
				<li>You then have the three <code>await</code> keywords:<pre>    await p1;
    await p2;
    await p3;</pre></li>
				<li>It made sense to refactor each case into its own asynchronous functions: <code>use1()</code>, <code>use2()</code>, and <code>use3()</code>. The <code>async</code> keyword indicates that these functions are asynchronous ones (you could have used inline <code>async</code> functions, but this would have made for rather confusing and awkward syntax):</li>
			</ol>
			<pre>activity1_solution.js
31     console.log("All done!");
32 })();
33 
34 async function use1() {
35     let response = await addDelay(3000, fetch(nextEventUrl));
36     let nextEvents = await response.json();
37     console.log("Use case 1: " + nextEvents.events[0].strEvent);
38 }
39 
40 async function use2() {
41     let response = await fetch(nextEventUrl);
42     await addDelay(1000);
43     let nextEvents = await response.json();
44     console.log("Use case 2: " + nextEvents.events[1].strEvent);
The full code is available at: <a href="https://packt.live/32JulHw">https://packt.live/32JulHw</a></pre>
			<p>In this activity, the order in which you wait for promises does not matter. Even though <code>await use1</code> will end up waiting 3 seconds, by the time <code>await use2</code> and <code>await use3</code> are called, both of those promises would have already been completed a second or two before, so they would just move on right away.</p>
			<h2 id="_idParaDest-628"><a id="_idTextAnchor697"/>Activity 15.02: Further Simplifying Promise Code to Remove Function Parameters</h2>
			<h3 id="_idParaDest-629"><a id="_idTextAnchor698"/>Solution</h3>
			<p>Here's one possible implementation. The two functions are very similar and have been refactored using two different styles for demonstration purposes. However, it is perfectly acceptable to solve the challenge using one or the other technique for both of the functions:</p>
			<ol>
				<li value="1">In technique #1, refactor <code>getTeamsInLeague</code> so that it now only takes one parameter, <code>(leagueName)</code>, rather than two parameters that are actually needed to determine the full result <code>(leagueData, leagueName)</code>. The other parameter is deferred until later:<pre>function getTeamsInLeague(leagueName) {</pre></li>
				<li>In technique #1, instead of returning the promise from <code>myFetch</code> directly, you return another curried function that takes <code>leagueData</code> as its parameter (the parameter you deferred in the last step). It is only a partially applied function at this point:<pre>return leagueData =&gt; {
    const leagueId = findLeagueId(leagueData, leagueName);
        return myFetch(ALL_TEAMS_URL, {id: leagueId});
    }
}</pre></li>
				<li>Technique #2 is really the same idea, but uses a function variable and multiple levels of arrow functions rather than a regular function:<pre>// technique #2 – use a function variable and multiple arrow functions
const getPlayersOnTeam = teamName =&gt; teamData =&gt; {
    const teamId = findTeamId(teamData, teamName);
    return myFetch(ALL_PLAYERS_URL, {id: teamId});
}</pre></li>
				<li>Finally, when <code>getTeamsInLeague(LEAGUE_NAME)</code> is invoked in the <code>then()</code> clause, the function returned above would be fully applied, with the resolved value from the previous promise passed in as the implied <code>leagueData</code> parameter:<pre>myFetch(ALL_LEAGUES_URL)
  .then(getTeamsInLeague(LEAGUE_NAME))
  .then(getPlayersOnTeam(TEAM_NAME))
  .then(getPlayerHonors)
  .catch(console.log)</pre></li>
				<li>To perhaps make this plainer, let's consider this as if it were written with <code>async/await</code> syntax. Refer to the following code. On the second line, the process when calling <code>getTeamsInLeague(LEAGUE_NAME)</code> is incomplete at that point and returns another function to complete it. Only when calling this partially applied function on the third line would you finally have the desired result:<pre>const allLeagueData = await myFetch(ALL_LEAGUES_URL);
const partiallyAppliedFunction = getTeamsInLeague(LEAGUE_NAME);
const league = await partiallyAppliedFunction(allLeagueData);</pre></li>
			</ol>
		</div>
	</body></html>