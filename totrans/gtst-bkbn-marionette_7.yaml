- en: Chapter 7. Changing and Growing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous chapter, we explored various functions that could be combined
    to produce a system that is fully integrated, but loosely coupled. In this chapter,
    we will cover some external pieces of Marionette that are very valuable, and as
    we progress, you will discover how to change some default features of the framework
    and combine `Marionette.js` with external libraries to make your application perform
    better. Here is a list of the topics that we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Using **Asynchronous Module Definitions** (**AMD**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the `Require.js` library
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Configuring `Require.js`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the text plugin to load the templates
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AMD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using the AMD, API will help us to load scripts on demand, specify the module
    dependencies, and reduce the script definition order problem. In [Chapter 5](ch05.html
    "Chapter 5. Divide and Conquer – Modularizing Everything"), *Divide and Conquer
    – Modularizing Everything*, we discussed why building large applications can easily
    get out of hand. There are multiple aspects to consider, but managing the script
    modules is a common scenario. We need to make sure that all the scripts are loaded
    in the right order, combine them, and reduce the number of requests to the servers.
    This seems to be simple but as the application grows, it is really complex to
    keep track.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the scenario, we will use a part of the script section from the
    `Index.html` file before we implement an AMD solution as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This list contains files for just a small proof of the concept and we have already
    started to accumulate a lot of scripts. As we add more modules, services, models,
    views, and so on, it will start to get less comprehensive and really hard to maintain.
    For example, at some point, we may lose track of the files that are not being
    used anymore. In the preceding code, all the scripts are downloaded when the page
    is loaded, even if the current view is not using them. Our code is modular, but
    still it is not easy to write encapsulated code that can be loaded on the fly,
    injected as dependency, and shared with other modules. Let's review how we can
    fix this.
  prefs: []
  type: TYPE_NORMAL
- en: Using the Require.js library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: James Burke introduced the `Require.js` library and it has a great community.
    The author is an expert in script loading and a contributor to the AMD specification.
    This book assumes that you know the basics of AMD and so before jumping to the
    implementation of our application, it will provide you with some basics of the
    configuration and boilerplate required while using `Require.js`. To get the latest
    build of `Require.js`, please go to the project website, [http://requirejs.org/docs/download.html](http://requirejs.org/docs/download.html).
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Require.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To get started with `Require.js`, we will create a file named `main.js`. Of
    course, you can give this file a more appropriate name that follows your naming
    conventions and business domain. We will write the following code inside the `main.js`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s replace all the script references from our `Index.html` file for the
    next script reference as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In this script reference, we pass the name of the file (in our example, the
    `main.js` file) that has all the required configuration to the `data-main` attribute.
    Please note that it's just the name of the file (`main`) and not its extension
    (`.js`) that is passed, because `Require.js` assumes that it will be working only
    with JavaScript files; therefore, the extension is not needed. The source (`src`)
    should point to the path where the `Require.js` file is located.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to complete a small test to see if we are on the right path.
    Open the browser and in the console, you should see the log message when you load
    the `Index.html` file.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's review each section of the content of the `main.js` file to get a
    better understanding of what's going on.
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding code snippet, we put all the libraries that we will use under
    the `paths` section of the `require.config` function. On the left-hand side, we
    assigned the alias of the library and on the right-hand side, we indicated the
    path of the file—the path that will be relative to the `baseUrl` value assigned,
    in this case, the `src` folder.
  prefs: []
  type: TYPE_NORMAL
- en: The second property of this function is called **shim**. The primary use of
    `shim` is for libraries that do not support AMD, but you still need to manage
    their dependencies. A perfect example for this is `Underscore.js`. In this case,
    `Underscore.js` is exported as `_` and it does not depend on another library to
    be loaded. We have a different scenario with `Backbone.js` that requires Underscore
    to work correctly. We have to specify `Underscore.js` as a dependency because
    it is possible that `Backbone.js` would try to do something with it before it
    is loaded.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `require` function is placed at the end of the file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will be the starting point of our application. It is a function
    definition that gets the exported values as parameters. At this point, we are
    just logging a message, but now let's do something more useful.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our application module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that the core dependencies are configured using `Require.js`, and once
    those are loaded and ready, we can define our Marionette application and set up
    the region initializers, commands, and request/response handlers. This is because
    we need the inside of a single file that we will name `app.js` with the idea of
    keeping all the login details related to the Marionette application object inside
    of this file. In the following code, our application is defined and ready to work
    as an AMD module. The following is the content of our `app.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The book's application that we just defined will be used in the `main.js` file
    when we start the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we add a new file we need to know where it is located and also its alias
    name. We specify this by going to the `paths` section of the `main.js` file definition.
    After this change your `paths` section should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we are ready to use this file to start our Marionette application in the
    `require` function of the `main.js` file as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Note how we injected the book's dependency to start the Marionette application
    and used the `start()` method of the Marionette application object to fire the
    initializers.
  prefs: []
  type: TYPE_NORMAL
- en: Writing the subapplications using Require.js
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The module that we defined is our root app that takes care of starting up the
    subapplications. The next example shows how we can define the subapplications
    using `Require.js`. As you can see, we can easily adapt our preceding code to
    use the `require` function by sending our script definitions to a configuration
    file and injecting the necessary object into our module definition. The following
    code is from the `CartApp` subapplication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Modularizing all your components
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the following example, we will show how to write a module for a view to be
    loaded with `Require.js`, but the same concept applies for all the objects/components.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we define a view called `CategoryView.js` and gave it
    the alias name of `categoryView` in the `main.js` file so that other files can
    use it.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example defined a well-scoped object. When a module does not have
    any dependencies and it is just a collection, we pass an object literal to `define()`.
    In our scenario, our module has dependencies, so the first argument should be
    an array of dependency names—in this case, `app` is the alias of our application—and
    the second argument should be a definition function.
  prefs: []
  type: TYPE_NORMAL
- en: Adding the text plugin
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: So far, we have defined the template property of our views using the ID of the
    template. This template is inside a script tag and has always been present in
    the DOM. But putting all the templates in the HTML file of a SPA won't scale and
    will give us the same maintenance problem that we had with all the script references
    in the `Index.html` file. A solution to this problem is to use the text plugin.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can download the text plugin from the `Require.js` page. The following
    is the link for the download:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://requirejs.org/docs/download.html#text](http://requirejs.org/docs/download.html#text).'
  prefs: []
  type: TYPE_NORMAL
- en: As with any other script file, we need to give it an alias in the `main.js`
    file and its path in order to start using it.
  prefs: []
  type: TYPE_NORMAL
- en: The responsibility of the text plugin is to get the template from the server
    and pass it to our view so that we don't need it in the HTML file.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code, we passed the relative path to the template using the
    `!text/path` syntax and the function that creates the view receives the exported
    name of the template as a parameter; in this case, `CategoryTemplate`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: This approach is more maintainable when building a large-scale application,
    but perhaps you want to keep the initial templates in your HTML file for performance
    benefits and the rest of your templates inside the right file structure.
  prefs: []
  type: TYPE_NORMAL
- en: Structuring your files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are many different options to define the layout of your files and probably
    this will be defined depending on the size and type of your project. At the end
    of the day, the goal should be to create a folder structure that is easy to understand,
    implement, and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: In the following example, we categorize the source into common folders, such
    as models and collections, and specific folders for the application pieces (views
    and controllers).
  prefs: []
  type: TYPE_NORMAL
- en: The static dependencies such as CSS, images, and JavaScript libraries required
    by our code should go under a different directory. It could prevent unintentional
    modifications to the library code and give us a better understanding of the real
    business domain.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following image shows the base structure where we will fit our files:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structuring your files](img/425OS_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Having said that, let''s dive into some of the details of our application.
    The following image shows how you might layout your application structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Structuring your files](img/425OS_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding image, we showed the structure of our book store application.
    This structure makes sense in this particular case. But the good thing is that
    we created small meaningful files that can interact with each other in an easier
    and elegant way, instead of having big files with the logic of different components
    contained.
  prefs: []
  type: TYPE_NORMAL
- en: Using handlebars as a template engine in Marionette
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the selling points of Backbone is that it plays well with the other libraries
    and this also holds true for Marionette . If we want to use a different template
    engine, we can do it with ease.
  prefs: []
  type: TYPE_NORMAL
- en: For this specific example, we will use handlebars, which we can be downloaded
    from [http://handlebarsjs.com/](http://handlebarsjs.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once we have downloaded the `Handlebars.js` file, we can add it to our `Index.html`
    file by using the following line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Or, we can do so by specifying an alias and path for it in the `main.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The syntax difference from the underscore templates is that a handlebars expression
    is `{{`, followed by some content, and then by `}}` instead of `<%= expression
    %>` of the `require` function. So, a template in handlebars looks like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'In order to use this template in a Marionette view, we must call the following
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding line will grab the template from the DOM and compile it into
    a function that will later be used by Marionette to render the view . The following
    will be the full code for `ItemView`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To see this working please go to the JSFiddle example at [http://jsfiddle.net/rayweb_on/gXemX/](http://jsfiddle.net/rayweb_on/gXemX/).
  prefs: []
  type: TYPE_NORMAL
- en: And that's it! There is no global change needed to start using a different template
    engine. We can also use both the engines if we want because the definition of
    the template is at the view level.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned that in order to manage the increasing complexity
    of our application, we must break it down into separate files. This increasing
    number of files leads to another problem that `Require.js` solves in an elegant
    way. The `Backbone.js` development clearly benefits from the use of `Marionette.js`,
    along with other libraries, such as `Require.js` and `Handlebars.js`, among others.
    This will definitely make our development environment more solid and at the same
    time, flexible to changes.
  prefs: []
  type: TYPE_NORMAL
