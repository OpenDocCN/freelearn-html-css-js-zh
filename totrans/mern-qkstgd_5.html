<html><head></head><body><div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Managing State with Redux</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Defining actions and action creators</li>
<li>Defining reducer functions</li>
<li>Creating a Redux store</li>
<li>Binding action creators to the dispatch method</li>
<li>Splitting and combining reducers</li>
<li>Writing Redux store enhancers</li>
<li>Time traveling with Redux</li>
<li>Understanding Redux middleware</li>
<li>Dealing with asynchronous data flow</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p><span>You will be required to have an IDE, Visual Studio Code, Node.js and MongoDB. You will also need to install Git, in order use the Git repository of this book.</span></p>
<p>The code files of this chapter can be found on GitHub:<br/>
<a href="https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05">https://github.com/PacktPublishing/MERN-Quick-Start-Guide/tree/master/Chapter05</a></p>
<p>Check out the following video to see the code in action:<br/>
<a href="https://goo.gl/mU9AjR">https://goo.gl/mU9AjR</a></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p>Redux is a predictable state container for JavaScript applications. It allows developers to manage the state of their applications with ease. With Redux, the state is immutable. Thus, it is possible to go back and forth to the next or previous state of your application. Redux is bound to three core principles:</p>
<ul>
<li><strong>Single source of truth</strong>: All the state of your application must be stored in a single object tree within one single store</li>
<li><strong>State is read-only</strong>: You must not mutate the state tree. Only by dispatching an action can the state tree change</li>
<li><strong>Changes are made with pure functions</strong>: These are called reducers, which are functions that accept the previous state and an action and compute a new state. Reducers must never mutate the previous state but rather always return a new one</li>
</ul>
<p>Reducers work in a very similar way to how the <kbd>Array.prototype.reduce</kbd> function does. The <kbd>reduce</kbd> method executes a function for every item in an array against an accumulator to reduce it to a single value. For example:</p>
<pre>const a = 5 
const b = 10 
const c = [a, b].reduce((accumulator, value) =&gt; { 
    return accumulator + value 
}, 0) </pre>
<p>The resulting value in variable <kbd>c</kbd> while reducing <kbd>a</kbd> and <kbd>b</kbd> against the <kbd>accumulator</kbd>, is <kbd>15</kbd> and the initial value is <kbd>0</kbd>. The reducer function here is:</p>
<pre>(accumulator, value) =&gt; { 
    return accumulator + value 
} </pre>
<p>Redux reducers are written in a similar way and they are the most important concept of Redux. For example:</p>
<pre>const reducer = (prevState, action) =&gt; newState </pre>
<p>In this chapter, we will focus on learning how to manage simple and complex state trees with Redux. You will learn as well how to deal with asynchronous data flows.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining actions and action creators</h1>
                </header>
            
            <article>
                
<p>Reducers accept an <kbd>action</kbd> object that describes the action that is going to be performed and decides how to transform the state based on this <kbd>action</kbd> object.</p>
<p>Actions are just plain objects and they have only one required property that needs to be present, the action-type. For instance:</p>
<pre>const action = { 
    type: 'INCREMENT_COUNTER', 
} </pre>
<p>We can also provide additional properties as well. For instance:</p>
<pre>const action = { 
    type: 'INCREMENT_COUNTER', 
    incrementBy: 2, 
} </pre>
<p>Actions creators are just functions that return actions, for instance:</p>
<pre>const increment = (incrementBy) =&gt; ({ 
    type: 'INCREMENT_COUNTER', 
    incrementBy, 
}) </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will see how these simple Redux concepts can be applied with <kbd>Array.prototype.reduce</kbd> to decide how data should be accumulated or reduced.</p>
<p>We won't need the Redux library yet for this purpose.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Build a small JavaScript application that will increase or decreased a counter based on the action provided.</p>
<ol>
<li>Create a new file named <kbd>counter.js</kbd></li>
<li>Define action-types as constants:</li>
</ol>
<pre>      const INCREMENT_COUNTER = 'INCREMENT_COUNTER' 
      const DECREMENT_COUNTER = 'DECREMENT_COUNTER' </pre>
<ol start="3">
<li>Define two action creators for generating two kinds of actions to <kbd>increment</kbd> and <kbd>decrement</kbd> the counter:</li>
</ol>
<pre>      const increment = (by) =&gt; ({ 
          type: INCREMENT_COUNTER, 
          by, 
      }) 
      const decrement = (by) =&gt; ({ 
          type: DECREMENT_COUNTER, 
          by, 
      }) </pre>
<ol start="4">
<li>Initialize the initial accumulator to <kbd>0</kbd>, then reduce it by passing several actions. The reducer function will decide which kind of action to perform based on the action type:</li>
</ol>
<pre>      const reduced = [ 
          increment(10), 
          decrement(5), 
          increment(3), 
      ].reduce((accumulator, action) =&gt; { 
          switch (action.type) { 
              case INCREMENT_COUNTER: 
            return accumulator + action.by 
              case DECREMENT_COUNTER: 
                  return accumulator - action.by 
              default: 
                  return accumulator 
          } 
      }, 0) </pre>
<ol start="5">
<li>Log the resulting value:</li>
</ol>
<pre>      console.log(reduced) </pre>
<ol start="6">
<li>Save the file</li>
<li>Open a terminal and run:</li>
</ol>
<pre>       <strong>node counter.js</strong>
  </pre>
<ol start="7">
<li>Outputs: <kbd>8</kbd></li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<ol>
<li>The first action type that the reducer encounters is <kbd>increment(10)</kbd> which will increment the accumulator by <kbd>10</kbd>. Because the initial value of the accumulator is <kbd>0</kbd>, the next current value will be <kbd>10</kbd></li>
<li>The second action type tells the reducer function to decrement the accumulator by <kbd>5</kbd>. Thus, the accumulator's value will be <kbd>5</kbd>.</li>
<li>The last action type tells the reducer function to increment the accumulator by <kbd>3</kbd>. As a result, the accumulator's value will be <kbd>8</kbd>.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Defining reducer functions</h1>
                </header>
            
            <article>
                
<p>Redux reducers are pure functions. That means, they have no side-effects. Given the same arguments, the reducer must always generate the same shape of state. Take for example the following reducer function:</p>
<pre>const reducer = (prevState, action) =&gt; { 
    if (action.type === 'INC') { 
        return { counter: prevState.counter + 1 } 
    } 
    return prevState 
} </pre>
<p>If we execute this function providing the same arguments, the result will always be the same:</p>
<pre>const a = reducer( 
   { counter: 0 }, 
   { type: 'INC' }, 
) // Value is { counter: 1 }  
const b = reducer( 
   { counter: 0 }, 
   { type: 'INC' }, 
) // Value is { counter: 1 } </pre>
<div class="packt_infobox">However, take into account that even though the returned values have the same shape, these are two different objects. For instance, comparing the above:<br/>
<kbd>console.log(a === b)</kbd>Â returns false.</div>
<p>Impure reducer functions prevent your application state from being predictable and make difficult to reproduce the same state. For instance:</p>
<pre>const impureReducer = (prevState = {}, action) =&gt; { 
    if (action.type === 'SET_TIME') { 
        return { time: new Date().toString() } 
    } 
    return prevState 
} </pre>
<p>If we execute this function:</p>
<pre>const a = impureReducer({}, { type: 'SET_TIME' }) 
setTimeout(() =&gt; { 
    const b = impureReducer({}, { type: 'SET_TIME' }) 
    console.log( 
        a, // Output may be: {time: "22:10:15 GMT+0000"} 
        b, // Output may be: {time: "22:10:17 GMT+0000"} 
    ) 
}, 2000) </pre>
<p>As you can see, after executing the function for a second time after 2 seconds, we get a different result. To make it pure, you can consider re-writing the previously impure reducer as:</p>
<pre>const timeReducer = (prevState = {}, action) =&gt; { 
    if (action.type === 'SET_TIME') { 
        return { time: action.time } 
    } 
    return prevState 
} </pre>
<p>Then, you can safely pass a time property inside your action to set the time:</p>
<pre>const currentTime = new Date().toTimeString() 
const a = timeReducer( 
   { time: null }, 
   { type: 'SET_TIME', time: currentTime }, 
) 
const b = timeReducer( 
   { time: null }, 
   { type: 'SET_TIME', time: currentTime }, 
) 
console.log(a.time === b.time) // true </pre>
<p>This approach makes your state predictable and the state is easy to reproduce. For instance, you could re-create a scenario of how your application will act if you pass the <kbd>time</kbd> property for any time in morning or afternoon.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>Now that you understand the concept of how reducers work, in this recipe, you will build a small application that will act differently according to the state change.</p>
<p>For this purpose, you won't need to install or use the Redux library yet.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Build an application that will remind you what kind of meal you should get according to your local time. Manage all the state of our application in a single object tree. Also provide a way to simulate what the application will display if it's <kbd>00:00a.m</kbd> or <kbd>12:00p.m</kbd>:</p>
<ol>
<li>Create a new file named <kbd>meal-time.html</kbd>.</li>
<li>Add the following code:</li>
</ol>
<pre>      &lt;!DOCTYPE html&gt; 
      &lt;html lang="en"&gt; 
      &lt;head&gt; 
          &lt;meta charset="UTF-8"&gt; 
          &lt;title&gt;Breakfast Time&lt;/title&gt; 
          &lt;script <br/>         src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;  <br/>        &lt;/script&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
          &lt;h1&gt;What you need to do:&lt;/h1&gt; 
          &lt;p&gt; 
              &lt;b&gt;Current time:&lt;/b&gt; 
              &lt;span id="display-time"&gt;&lt;/span&gt; 
          &lt;/p&gt; 
                &lt;p id="display-meal"&gt;&lt;/p&gt; 
                &lt;button id="emulate-night"&gt; 
              Let's pretend is 00:00:00 
          &lt;/button&gt; 
          &lt;button id="emulate-noon"&gt; 
              Let's pretend is 12:00:00 
          &lt;/button&gt; 
          &lt;script type="text/babel"&gt; 
              // Add JavaScript code here 
          &lt;/script&gt; 
      &lt;/body&gt; 
      &lt;/html&gt; </pre>
<ol start="3">
<li>Inside the script tag add the code defined in the next steps, starting on step 4.</li>
<li>Define a variable <kbd>state</kbd> that will contain all the state tree and later the next state:</li>
</ol>
<pre>      let state = { 
          kindOfMeal: null, 
          time: null, 
      } </pre>
<ol start="5">
<li>Create a reference to the HTML elements that we will use to display data or add event listeners:</li>
</ol>
<pre>      const meal = document.getElementById('display-meal') 
      const time = document.getElementById('display-time') 
      const btnNight = document.getElementById('emulate-night') 
      const btnNoon = document.getElementById('emulate-noon') </pre>
<ol start="6">
<li>Define two action types:</li>
</ol>
<pre>      const SET_MEAL = 'SET_MEAL' 
      const SET_TIME = 'SET_TIME' </pre>
<ol start="7">
<li>Define an action creator for setting the kind of meal the user should have:</li>
</ol>
<pre>      const setMeal = (kindOfMeal) =&gt; ({ 
          type: SET_MEAL, 
          kindOfMeal, 
      }) </pre>
<ol start="8">
<li>Define an action creator for setting the time:</li>
</ol>
<pre>      const setTime = (time) =&gt; ({ 
          type: SET_TIME, 
          time, 
      }) </pre>
<ol start="9">
<li>Define a reducer function that will compute a new state when an action is dispatched:</li>
</ol>
<pre>      const reducer = (prevState = state, action) =&gt; { 
          switch (action.type) { 
              case SET_MEAL: 
                  return Object.assign({}, prevState, { 
                      kindOfMeal: action.kindOfMeal, 
                  }) 
              case SET_TIME: 
                  return Object.assign({}, prevState, { 
                      time: action.time, 
                  }) 
              default: 
                  return prevState 
          } 
      } </pre>
<ol start="10">
<li>Add a function that we will call when the state changes, so we can update our view:</li>
</ol>
<pre>      const onStateChange = (nextState) =&gt; { 
          const comparison = [ 
              { time: '23:00:00', info: 'Too late for dinner!' }, 
              { time: '18:00:00', info: 'Dinner time!' }, 
              { time: '16:00:00', info: 'Snacks time!' }, 
              { time: '12:00:00', info: 'Lunch time!' }, 
              { time: '10:00:00', info: 'Branch time!' }, 
              { time: '05:00:00', info: 'Breakfast time!' }, 
              { time: '00:00:00', info: 'Too early for breakfast!' }, 
          ] 
          time.textContent = nextState.time 
          meal.textContent = comparison.find((condition) =&gt; ( 
              nextState.time &gt;= condition.time 
          )).info 
      } </pre>
<ol start="11">
<li>Define a dispatch function that will generate a new state tree by passing the current state and an action to the reducer. Then, it will call the <kbd>onChangeState</kbd> function to notify your application that the state has changed:</li>
</ol>
<pre>      const dispatch = (action) =&gt; { 
          state = reducer(state, action) 
          onStateChange(state) 
      } </pre>
<ol start="12">
<li>Add an event listener for the button that will emulate that the time is <kbd>00:00a.m</kbd>:</li>
</ol>
<pre>      btnNight.addEventListener('click', () =&gt; { 
          const time = new Date('1/1/1 00:00:00') 
          dispatch(setTime(time.toTimeString())) 
      }) </pre>
<ol start="13">
<li>Add an event listener for the button that will emulate that the time is <kbd>12:00p.m</kbd>:</li>
</ol>
<pre>      btnNoon.addEventListener('click', () =&gt; { 
          const time = new Date('1/1/1 12:00:00') 
          dispatch(setTime(time.toTimeString())) 
      }) </pre>
<ol start="14">
<li>Once the script is running, dispatch an action with the current time for the view to update:</li>
</ol>
<pre>      dispatch(setTime(new Date().toTimeString())) </pre>
<ol start="15">
<li>Save the file.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's test it...</h1>
                </header>
            
            <article>
                
<p>To see your previous work in action:</p>
<ol>
<li>Open the <kbd>meal-time.html</kbd> file in your web browser. You can do so by double-clicking on the file, or right-clicking on the file and choosing <span class="packt_screen">Open with...</span>.</li>
<li>You should be able to see your current local time and a message stating what kind of meal you should have. For instance, if your local time is <kbd>20:42:35 GMT+0800 (CST)</kbd>, you should see <kbd>Dinner time!</kbd></li>
<li>Click on the button <kbd>"Let's pretend is 00:00:00"</kbd>Â to see what your application would display if the time was <kbd>00:00a.m</kbd>.</li>
<li>The same way, click on the button <kbd>"Let's pretend is 12:00:00"</kbd> to see what your application would display if the time was <kbd>12:00p.m</kbd>.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>We can summarize our application like the following to understand how it works:</p>
<ol>
<li>Action types <kbd>SET_MEAL</kbd> and <kbd>SET_TIME</kbd> were defined.</li>
<li>Two action creators were defined:
<ol>
<li><kbd>setMeal</kbd> <span>which generates an action with the</span> <kbd>SET_MEAL</kbd> <span>action type and a</span> <kbd>kindOfMeal</kbd> <span>property with the provided argument</span></li>
<li><kbd>setTime</kbd> <span>which generates an action with the</span> <kbd>SET_TIME</kbd> <span>action type and a</span> <kbd>time</kbd> <span>property with the provided argument</span></li>
</ol>
</li>
</ol>
<ol start="3">
<li>A reducer function was defined:
<ol>
<li>For the action type <kbd>SET_MEAL</kbd><span>, computes a new state with a new</span> <kbd>kindOfMeal</kbd> <span>property</span></li>
<li>For the action type <kbd>SET_TIME</kbd><span>, computes a new state with a new</span> <kbd>time</kbd> <span>property</span></li>
</ol>
</li>
</ol>
<ol start="4">
<li>We defined a function that will get called when the state tree changes. Inside the function, we updated the view according to the new state.</li>
<li>A <kbd>dispatch</kbd> function was defined that calls the reducer function providing the previous state and an action object to generate a new state.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Creating a Redux store</h1>
                </header>
            
            <article>
                
<p>In the previous recipes, we have seen how to define reducers and actions. We have also seen how to create a dispatch function to dispatch actions for the reducers to update the state. The store is an object that provides a small API to put all of that together.</p>
<p>The redux module exposes the <kbd>createStore</kbd> method which we can use to create a store. It has the following signature:</p>
<pre>createStore(reducer, preloadedState, enhancer) </pre>
<p>The two last arguments are optional. For example, creating a store with a single reducer could look like this:</p>
<pre>const TYPE = { 
    INC_COUNTER: 'INC_COUNTER', 
    DEC_COUNTER: 'DEC_COUNTER', 
} 
const initialState = { 
    counter: 0, 
} 
const reducer = (state = initialState, action) =&gt; { 
    switch (action.type) { 
        case TYPE.INC_COUNTER:  
            return { counter: state.counter + 1 } 
        case TYPE.DEC_COUNTER:  
            return { counter: state.counter - 1 } 
        default:  
            return state 
    } 
} 
const store = createStore(reducer) </pre>
<p>Calling <kbd>createStore</kbd> will expose four methods:</p>
<ul>
<li><kbd>store.dispatch(action)</kbd>: Where action is an object that contains at least one property named <kbd>type</kbd> that specifies the action type</li>
<li><kbd>store.getState()</kbd>: Returns the whole state tree</li>
<li><kbd>store.subscribe(listener)</kbd>: Where listener is a callback function that will get triggered whenever the state tree changes. Several listeners can be subscribed</li>
<li><kbd>store.replaceReducer(reducer)</kbd>: Replaces the current Reducer function with a new one</li>
</ul>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will re-build the application that you built in the previous recipe. However, this time you will use Redux. Before you start, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3", 
        "redux": "4.0.0" 
    } 
} </pre>
<p>Then, install the dependencies by opening a terminal and running:</p>
<pre><strong>npm install</strong>
  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>First, build a small ExpressJS server application whose sole purpose will be to serve an HTML file and the Redux module:</p>
<ol>
<li>Create a new file named <kbd>meal-time-server.js</kbd></li>
<li>Include the ExpressJS and <kbd>path</kbd> module and initialize a new ExpressJS Application:</li>
</ol>
<pre>      const express = require('express') 
      const path = require('path') 
      const app = express() </pre>
<ol start="3">
<li>Serve the Redux library on <kbd>/lib</kbd> path. Make sure that the path points to the <kbd>node_modules</kbd> folder:</li>
</ol>
<pre>      app.use('/lib', express.static( 
          path.join(__dirname, 'node_modules', 'redux', 'dist') 
      )) </pre>
<ol start="4">
<li>Serve the client application on the root path <kbd>/</kbd>:</li>
</ol>
<pre>      app.get('/', (req, res) =&gt; { 
          res.sendFile(path.join( 
              __dirname, 
              'meal-time-client.html', 
          )) 
      }) </pre>
<ol start="5">
<li>Listen for new connections on port <kbd>1337</kbd>:</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="6">
<li>Save the file</li>
</ol>
<p>Now, build the client application using Redux following the next steps:</p>
<ol>
<li>Create a new file named <kbd>meal-time-client.html</kbd>.</li>
<li>Add the following code:</li>
</ol>
<pre>      &lt;!DOCTYPE html&gt; 
      &lt;html lang="en"&gt; 
      &lt;head&gt; 
          &lt;meta charset="UTF-8"&gt; 
          &lt;title&gt;Meal Time with Redux&lt;/title&gt; 
          &lt;script <br/>          src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;<br/>         &lt;/script&gt; 
          &lt;script src="/lib/redux.js"&gt;&lt;/script&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
          &lt;h1&gt;What you need to do:&lt;/h1&gt; 
          &lt;p&gt; 
              &lt;b&gt;Current time:&lt;/b&gt; 
              &lt;span id="display-time"&gt;&lt;/span&gt; 
          &lt;/p&gt; 
          &lt;p id="display-meal"&gt;&lt;/p&gt; 
          &lt;button id="emulate-night"&gt; 
              Let's pretend is 00:00:00 
          &lt;/button&gt; 
          &lt;button id="emulate-noon"&gt; 
              Let's pretend is 12:00:00 
          &lt;/button&gt; 
          &lt;script type="text/babel"&gt; 
              // Add JavaScript code here 
          &lt;/script&gt; 
      &lt;/body&gt; 
      &lt;/html&gt; </pre>
<ol start="3">
<li>Inside the script tag, add the code for the next steps, starting from step 4.</li>
<li>Extract the <kbd>createStore</kbd> method from the Redux library:</li>
</ol>
<pre>      const { createStore } = Redux </pre>
<ol start="5">
<li>Define the initial state of your application:</li>
</ol>
<pre>      const initialState = { 
          kindOfMeal: null, 
          time: null, 
      } </pre>
<ol start="6">
<li>Keep a reference of the HTML DOM elements that will be used to display the state or interact with the application:</li>
</ol>
<pre>      const meal = document.getElementById('display-meal') 
      const time = document.getElementById('display-time') 
      const btnNight = document.getElementById('emulate-night') 
      const btnNoon = document.getElementById('emulate-noon') </pre>
<ol start="7">
<li>Define two action types:</li>
</ol>
<pre>      const SET_MEAL = 'SET_MEAL' 
      const SET_TIME = 'SET_TIME' </pre>
<ol start="8">
<li>Define two action creators:</li>
</ol>
<pre>      const setMeal = (kindOfMeal) =&gt; ({ 
          type: SET_MEAL, 
          kindOfMeal, 
      }) 
      const setTime = (time) =&gt; ({ 
          type: SET_TIME, 
          time, 
      }) </pre>
<ol start="9">
<li>Define the reducer that will transform the state when <kbd>SET_TIME</kbd> and/or <kbd>SET_TIME</kbd> action types are dispatched:</li>
</ol>
<pre>      const reducer = (prevState = initialState, action) =&gt; { 
          switch (action.type) { 
              case SET_MEAL: 
                  return {...prevState, 
                      kindOfMeal: action.kindOfMeal, 
                  } 
              case SET_TIME: 
                  return {...prevState, 
                      time: action.time, 
                  } 
              default: 
                  return prevState 
          } 
      } </pre>
<ol start="10">
<li>Create a new Redux Store:</li>
</ol>
<pre>      const store = createStore(reducer) </pre>
<ol start="11">
<li>Subscribe a callback function to the changes of the store. Whenever the store changes this callback will be triggered and it will update the view according to the changes in the store:</li>
</ol>
<pre>      store.subscribe(() =&gt; { 
          const nextState = store.getState() 
          const comparison = [ 
              { time: '23:00:00', info: 'Too late for dinner!' }, 
              { time: '18:00:00', info: 'Dinner time!' }, 
              { time: '16:00:00', info: 'Snacks time!' }, 
              { time: '12:00:00', info: 'Lunch time!' }, 
              { time: '10:00:00', info: 'Brunch time!' }, 
              { time: '05:00:00', info: 'Breakfast time!' }, 
              { time: '00:00:00', info: 'Too early for breakfast!' }, 
          ] 
          time.textContent = nextState.time 
          meal.textContent = comparison.find((condition) =&gt; ( 
              nextState.time &gt;= condition.time 
          )).info 
      }) </pre>
<ol start="12">
<li>Add an event listener for the <kbd>click</kbd> event for our button that will dispatch the <kbd>SET_TIME</kbd> action type to set the time to <kbd>00:00:00</kbd>:</li>
</ol>
<pre>      btnNight.addEventListener('click', () =&gt; { 
          const time = new Date('1/1/1 00:00:00') 
          store.dispatch(setTime(time.toTimeString())) 
      }) </pre>
<ol start="13">
<li>Add an event listener for the <kbd>click</kbd> event for our button that will dispatch the <kbd>SET_TIME</kbd> action type to set the time to <kbd>12:00:00</kbd>:</li>
</ol>
<pre>      btnNoon.addEventListener('click', () =&gt; { 
          const time = new Date('1/1/1 12:00:00') 
          store.dispatch(setTime(time.toTimeString())) 
      }) </pre>
<ol start="14">
<li>When the application is first started, dispatch an action to set the time to the current local time:</li>
</ol>
<pre>      store.dispatch(setTime(new Date().toTimeString())) </pre>
<ol start="15">
<li>Save the file</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's test it...</h1>
                </header>
            
            <article>
                
<p>To see the previous work in action:</p>
<ol>
<li>Open a new terminal and run:</li>
</ol>
<pre><strong>      node meal-time-server.js</strong></pre>
<ol start="2">
<li>In your web browser, visit:</li>
</ol>
<pre>    
       http://localhost:1337/</pre>
<ol start="3">
<li>You should be able to see your current local time and a message stating what kind of meal you should have. For instance, if your local time is <kbd>20:42:35 GMT+0800 (CST)</kbd>, you should see <kbd>Dinner time!</kbd></li>
<li>Click on the button <kbd>"Let's pretend is 00:00:00"</kbd>Â to see what your application would display if the time was <kbd>00:00a.m</kbd>.</li>
<li>The same way, click on the <kbd>"Let's pretend is 12:00:00"</kbd> button to see what your application would display if the time was <kbd>12:00p.m</kbd>.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p>You can use the ES6 spread operator instead of <kbd>Object.assign</kbd> to merge your previous state with the next one, for instance, we re-wrote the reducer function of the previous recipe:</p>
<pre>const reducer = (prevState = initialState, action) =&gt; { 
    switch (action.type) { 
        case SET_MEAL: 
            return Object.assign({}, prevState, { 
                kindOfMeal: action.kindOfMeal, 
            }) 
        case SET_TIME: 
            return Object.assign({}, prevState, { 
                time: action.time, 
            }) 
        default: 
            return prevState 
    } 
} </pre>
<p>We rewrote it as the following:</p>
<pre>const reducer = (prevState = initialState, action) =&gt; { 
    switch (action.type) { 
        case SET_MEAL: 
            return {...prevState, 
                kindOfMeal: action.kindOfMeal, 
            } 
        case SET_TIME: 
            return {...prevState, 
                time: action.time, 
            } 
        default: 
            return prevState 
    } 
} </pre>
<p>This could make the code more readable.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Binding action creators to the dispatch method</h1>
                </header>
            
            <article>
                
<p>Actions creators are just functions that generate action objects which can later be used to dispatch actions using the <kbd>dispatch</kbd> method. Take for example the following code:</p>
<pre>const TYPES = { 
    ADD_ITEM: 'ADD_ITEM', 
    REMOVE_ITEM: 'REMOVE_ITEM', 
} 
const actions = { 
    addItem: (name, description) =&gt; ({ 
        type: TYPES.ADD_ITEM, 
        payload: { name, description }, 
    }), 
    removeItem: (id) =&gt; ({ 
        type: TYPES.REMOVE_ITEM, 
        payload: { id }, 
    }) 
} 
module.exports = actions </pre>
<p>Later, somewhere in your application, you can dispatch these actions using the <kbd>dispatch</kbd> method:</p>
<pre>dispatch(actions.addItem('Little Box', 'Cats')) 
dispatch(actions.removeItem(123)) </pre>
<p>However, as you can see, calling the <kbd>dispatch</kbd> method every time seems like a repeated and unnecessary step. You could simply wrap the action creators around the <kbd>dispatch</kbd> function itself like this:</p>
<pre>const actions = { 
    addItem: (name, description) =&gt; dispatch({ 
        type: TYPES.ADD_ITEM, 
        payload: { name, description }, 
    }), 
    removeItem: (id) =&gt; dispatch({ 
        type: TYPES.REMOVE_ITEM, 
        payload: { id }, 
    }) 
} 
module.exports = actions </pre>
<p>Even though this seems like a good solution, there is a problem. It means, you would need to create the store first, then define your action creators binding them to the <kbd>dispatch</kbd> method. In addition, it would be difficult to maintain the action creators in a separate file since they depend on the <kbd>dispatch</kbd> method to be present. There is a solution provided by the Redux module, a helper method called <kbd>bindActionCreators</kbd> which accepts two arguments. The first argument is an object with keys, which represent the name of an action creator, and values, which represent a function that returns an action. The second argument is expected to be the <kbd>dispatch</kbd> function:</p>
<pre>bindActionCreators(actionCreators, dispatchMethod) </pre>
<p>This helper method will map all the action creators to the dispatch method. For instance, we could re-write the previous example as the following:</p>
<pre>const store = createStore(reducer) 
const originalActions = require('./actions') 
const actions = bindActionCreators( 
    originalActions, 
    store.dispatch, 
) </pre>
<p>Then, later somewhere in your application, you can call these methods without wrapping them around the <kbd>dispatch</kbd> method:</p>
<pre>actions.addItem('Little Box', 'Cats') 
actions.removeItem(123) </pre>
<p>As you can see, our bound action creators look more like regular functions now. In fact, by destructuring the <kbd>actions</kbd> object, you can use only the methods you need. For instance:</p>
<pre>const { 
    addItem, 
    removeItem, 
} = bindActionCreators( 
    originalActions,  
    store.dispatch, 
) </pre>
<p>Then, you can call them like this:</p>
<pre>addItem('Little Box', 'Cats') 
removeItem(123) </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will build a simple To-do application and you will use the concepts that you just have learned about binding action creators. First, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3", 
        "redux": "4.0.0" 
    } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>To build your To-do application, for the purpose of this recipe, define only one action creator and use <kbd>bindActionCreators</kbd> to bind it to the <kbd>dispatch</kbd> method.</p>
<p>First, build a small ExpressJS application that will serve the HTML file containing the To-do client application which we will build after:</p>
<ol>
<li>Create a new file named <kbd>bind-server.js</kbd></li>
<li>Add the following code:</li>
</ol>
<pre>      const express = require('express') 
      const path = require('path') 
      const app = express() 
      app.use('/lib', express.static( 
          path.join(__dirname, 'node_modules', 'redux', 'dist') 
      )) 
      app.get('/', (req, res) =&gt; { 
          res.sendFile(path.join( 
              __dirname, 
              'bind-index.html', 
          )) 
      }) 
      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="3">
<li>Save the file</li>
</ol>
<p>Next, build the To-do application in an HTML file:</p>
<ol>
<li>Create a new file named <kbd>bind-index.html</kbd>.</li>
<li>Add the following code:</li>
</ol>
<pre>      &lt;!DOCTYPE html&gt; 
      &lt;html lang="en"&gt; 
      &lt;head&gt; 
          &lt;meta charset="UTF-8"&gt; 
          &lt;title&gt;Binding action creators&lt;/title&gt; 
          &lt;script <br/>           src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;<br/>          &lt;/script&gt; 
          &lt;script src="/lib/redux.js"&gt;&lt;/script&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
          &lt;h1&gt;List:&lt;/h1&gt; 
          &lt;form id="item-form"&gt; 
              &lt;input id="item-input" name="item" /&gt; 
          &lt;/form&gt; 
          &lt;ul id="list"&gt;&lt;/ul&gt; 
          &lt;script type="text/babel"&gt; 
              // Add code here 
          &lt;/script&gt; 
      &lt;/body&gt; 
      &lt;/html&gt; </pre>
<ol start="3">
<li>Inside the script tag, add the code in the following steps, starting from step 4.</li>
<li>Keep a reference to the HTML DOM element that will be used in the application:</li>
</ol>
<pre>      const form = document.querySelector('#item-form') 
      const input = document.querySelector('#item-input') 
      const list = document.querySelector('#list') </pre>
<ol start="5">
<li>Define the initial state of your application:</li>
</ol>
<pre>      const initialState = { 
          items: [], 
      } </pre>
<ol start="6">
<li>Define an action type:</li>
</ol>
<pre>      const TYPE = { 
          ADD_ITEM: 'ADD_ITEM', 
      } </pre>
<ol start="7">
<li>Define an action creator:</li>
</ol>
<pre>      const actions = { 
          addItem: (text) =&gt; ({ 
              type: TYPE.ADD_ITEM, 
              text, 
          }) 
      } </pre>
<ol start="8">
<li>Define a reducer function that will add a new item to the list whenever the <kbd>ADD_ITEM</kbd> action type is dispatched. The state will keep only 5 items:</li>
</ol>
<pre>      const reducer = (state = initialState, action) =&gt; { 
          switch (action.type) { 
              case TYPE.ADD_ITEM: return { 
                  items: [...state.items, action.text].splice(-5) 
              } 
              default: return state 
          } 
      } </pre>
<ol start="9">
<li>Create a store and bind the <kbd>dispatch</kbd> function to the action creator:</li>
</ol>
<pre>      const { createStore, bindActionCreators } = Redux 
      const store = createStore(reducer) 
      const { addItem } = bindActionCreators( 
          actions,  
          store.dispatch, 
      ) </pre>
<ol start="10">
<li>Subscribe to the store and whenever the state changes add a new item to the list. If an item was already defined, we will re-use it instead of creating a new one:</li>
</ol>
<pre>      store.subscribe(() =&gt; { 
          const { items } = store.getState() 
          items.forEach((itemText, index) =&gt; { 
              const li = ( 
                  list.children.item(index) || 
                  document.createElement('li') 
              ) 
              li.textContent = itemText 
              list.insertBefore(li, list.children.item(0)) 
          }) 
      }) </pre>
<ol start="11">
<li>Add an event listener to the form for the <kbd>submit</kbd> event. This way, we can get the input value and dispatch an action:</li>
</ol>
<pre>      form.addEventListener('submit', (event) =&gt; { 
          event.preventDefault() 
          addItem(input.value) 
      }) </pre>
<ol start="12">
<li>Save the file.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's test it...</h1>
                </header>
            
            <article>
                
<p>To see the previous work in action:</p>
<ol>
<li>Open a new Terminal and run:</li>
</ol>
<pre><strong>      node bind-server.js</strong></pre>
<ol start="2">
<li>In your browser, visit:</li>
</ol>
<pre>     http://localhost:1337/</pre>
<ol start="3">
<li>Type something in the input box and press <span class="KeyPACKT">Enter</span>. A new item should appear in the list.</li>
<li>Try to add more than five items to the list. The last one displayed will be removed and only five items are kept on the view.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Splitting and combining reducers</h1>
                </header>
            
            <article>
                
<p>As your application grows, you probably wouldn't want to write all the logic for how the state of your application needs to be transformed in a simple reducer function. What you would probably want is to write smaller reducers that specialize in managing independent parts of the state.</p>
<p>Take for example the following reducer function:</p>
<pre>const initialState = { 
    todoList: [], 
    chatMsg: [], 
} 
const reducer = (state = initialState, action) =&gt; { 
    switch (action.type) { 
        case 'ADD_TODO': return { 
            ...state, 
            todoList: [ 
                ...state.todoList, 
                { 
                    title: action.title, 
                    completed: action.completed, 
                }, 
            ], 
        } 
        case 'ADD_CHAT_MSG': return { 
            ...state, 
            chatMsg: [ 
                ...state.chatMsg, 
                { 
                    from: action.id, 
                    message: action.message, 
                }, 
            ], 
        } 
        default: 
            return state 
    } 
} </pre>
<p>You have two properties that manage the state of two different parts of an application. One manages the state of a Todo, list while the other manages the Chat messages. You could split this reducer into two reducer functions, where each manages one slice of the state, for instance:</p>
<pre>const initialState = { 
    todoList: [], 
    chatMsg: [], 
} 
const todoListReducer = (state = initialState.todoList, action) =&gt; { 
    switch (action.type) { 
        case 'ADD_TODO': return state.concat([ 
            { 
                title: action.title, 
                completed: action.completed, 
            }, 
        ]) 
        default: return state 
    } 
} 
const chatMsgReducer = (state = initialState.chatMsg, action) =&gt; { 
    switch (action.type) { 
        case 'ADD_CHAT_MSG': return state.concat([ 
            { 
                from: action.id, 
                message: action.message, 
            }, 
        ]) 
        default: return state 
    } 
} </pre>
<p>However, because <kbd>createStore</kbd> method accepts only one reducer as the first argument, you would need to combine them into a single reducer:</p>
<pre>const reducer = (state = initialState, action) =&gt; { 
    return { 
        todoList: todoListReducer(state.todoList, action), 
        chatMsg: chatMsgReducer(state.chatMsg, action), 
    } 
} </pre>
<p>In this way, we are able to split our reducers into smaller reducers that specialize in managing only one slice of the state, and later combine them together into a single reducer function.</p>
<p>Redux provides a helper method named <kbd>combineReducers</kbd> that allows you to combine reducers in a similar way to what we just did but without having to repeat a lot of code; for instance, we could rewrite the previous way of combining reducers like this:</p>
<pre>const reducer = combineReducers({ 
    todoList: todoListReducer, 
    chatMsg: chatMsgReducer, 
}) </pre>
<p>The <kbd>combineReducers</kbd> method is a <em>higher-order reducer</em> function. It accepts an object mapping specifies keys to a certain slice of the state managed by a specific <kbd>reducer</kbd> function and returns a new reducer function. If you run the following code, for instance:</p>
<pre>console.log(JSON.stringify( 
    reducer(initialState, { type: null }), 
    null, 2, 
)) </pre>
<p>You will see that the generated shape of the state looks like this:</p>
<pre>{ 
    "todoList": [], 
    "chatMsg": [], 
} </pre>
<p>We can try as well if our combined reducers are working and managing only the part of the state assigned to them. For instance:</p>
<pre>console.log(JSON.stringify( 
    reducer( 
        initialState, 
        { 
            type: 'ADD_TODO', 
            title: 'This is an example', 
            completed: false, 
        }, 
    ), 
    null, 2, 
)) </pre>
<p>The output should display the generated state as the following:</p>
<pre>{ 
    "todoList": [ 
        { 
            "title": "This is an example", 
            "completed": false, 
        }, 
    ], 
    "chatMsg": [], 
} </pre>
<p>This shows that each reducer is managing only the slice of the state assigned to them.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will recreate the To-do application as in the pervious recipe. However, you will add other functionalities such as remove and toggle a To-do item. You will define other state of your application that will be managed by separate reducer functions. First, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3", 
        "redux": "4.0.0" 
    } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>First, build a small ExpressJS server application that will serve the client application and the Redux library installed in <kbd>node_modules</kbd>:</p>
<ol>
<li>Create a new file named <kbd>todo-time.js</kbd></li>
<li>Add the following code:</li>
</ol>
<pre>      const express = require('express') 
      const path = require('path') 
      const app = express() 
      app.use('/lib', express.static( 
          path.join(__dirname, 'node_modules', 'redux', 'dist') 
      )) 
      app.get('/', (req, res) =&gt; { 
          res.sendFile(path.join( 
              __dirname, 
              'todo-time.html', 
          )) 
      }) 
      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="3">
<li>Save the file</li>
</ol>
<p>Next, build the To-do client application. Also include a separate reducer to manage state for the current local time and a random lucky number generator:</p>
<ol>
<li>Create a new file named <kbd>todo-time.html</kbd></li>
<li>Add the following HTML code:</li>
</ol>
<pre>      &lt;!DOCTYPE html&gt; 
      &lt;html lang="en"&gt; 
      &lt;head&gt; 
         &lt;meta charset="UTF-8"&gt; 
          &lt;title&gt;Lucky Todo&lt;/title&gt; 
          &lt;script <br/>           src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;<br/>          &lt;/script&gt; 
          &lt;script src="/lib/redux.js"&gt;&lt;/script&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
          &lt;h1&gt;List:&lt;/h1&gt; 
          &lt;form id="item-form"&gt; 
              &lt;input id="item-input" name="item" /&gt; 
          &lt;/form&gt; 
          &lt;ul id="list"&gt;&lt;/ul&gt; 
          &lt;script type="text/babel"&gt; 
              // Add code here 
          &lt;/script&gt; 
      &lt;/body&gt; 
      &lt;/html&gt; </pre>
<ol start="3">
<li>Inside the script tag add the JavaScript code following the next steps, starting from step 4</li>
<li>Keep a reference of the HTML elements that we will use to display data or interact with the application:</li>
</ol>
<pre>      const timeElem = document.querySelector('#current-time') 
      const formElem = document.querySelector('#todo-form') 
      const listElem = document.querySelector('#todo-list') 
      const inputElem = document.querySelector('#todo-input') 
      const luckyElem = document.querySelector('#lucky-number') </pre>
<ol start="5">
<li>Get the <kbd>createStore</kbd> method and helper methods from the Redux library:</li>
</ol>
<pre>      const { 
          createStore, 
          combineReducers, 
          bindActionCreators, 
      } = Redux </pre>
<ol start="6">
<li>Set action types:</li>
</ol>
<pre>      const TYPE = { 
          SET_TIME: 'SET_TIME', 
          SET_LUCKY_NUMBER: 'SET_LUCKY_NUMBER', 
          ADD_TODO: 'ADD_TODO', 
          REMOVE_TODO: 'REMOVE_TODO', 
          TOGGLE_COMPLETED_TODO: 'TOGGLE_COMPLETED_TODO', 
      } </pre>
<ol start="7">
<li>Define action creators:</li>
</ol>
<pre>      const actions = { 
          setTime: (time) =&gt; ({ 
              type: TYPE.SET_TIME, 
              time, 
          }), 
          setLuckyNumber: (number) =&gt; ({ 
              type: TYPE.SET_LUCKY_NUMBER, 
              number, 
          }), 
          addTodo: (id, title) =&gt; ({ 
              type: TYPE.ADD_TODO, 
              title, 
              id, 
          }), 
          removeTodo: (id) =&gt; ({ 
              type: TYPE.REMOVE_TODO, 
              id, 
          }), 
          toggleTodo: (id) =&gt; ({ 
              type: TYPE.TOGGLE_COMPLETED_TODO, 
              id, 
          }), 
      } </pre>
<ol start="8">
<li>Define a reducer function to manage the slice of state that keeps the time:</li>
</ol>
<pre>      const currentTime = (state = null, action) =&gt; { 
          switch (action.type) { 
              case TYPE.SET_TIME: return action.time 
              default: return state 
          } 
      } </pre>
<ol start="9">
<li>Define a reducer function to manage the slice of state that keeps a lucky number that will be generated every time the user loads your application:</li>
</ol>
<pre>      const luckyNumber = (state = null, action) =&gt; { 
          switch (action.type) { 
              case TYPE.SET_LUCKY_NUMBER: return action.number 
              default: return state 
          } 
      } </pre>
<ol start="10">
<li>Define a reducer function to manage the slice of state that keeps an array of To-do items:</li>
</ol>
<pre>      const todoList = (state = [], action) =&gt; { 
          switch (action.type) { 
              case TYPE.ADD_TODO: return state.concat([ 
                  { 
                      id: String(action.id), 
                      title: action.title, 
                      completed: false, 
                  } 
              ]) 
              case TYPE.REMOVE_TODO: return state.filter( 
                  todo =&gt; todo.id !== action.id 
              ) 
              case TYPE.TOGGLE_COMPLETED_TODO: return state.map( 
                  todo =&gt; ( 
                      todo.id === action.id 
                          ? { 
                              ...todo, 
                              completed: !todo.completed, 
                          } 
                          : todo 
                  ) 
              ) 
              default: return state 
          } 
      } </pre>
<ol start="11">
<li>Combine all reducers into a single one:</li>
</ol>
<pre>      const reducer = combineReducers({ 
          currentTime, 
          luckyNumber, 
          todoList, 
      }) </pre>
<ol start="12">
<li>Create a store:</li>
</ol>
<pre>      const store = createStore(reducer) </pre>
<ol start="13">
<li>Bind all actions creators to the <kbd>dispatch</kbd> method of the store:</li>
</ol>
<pre>      const { 
          setTime, 
          setLuckyNumber, 
          addTodo, 
          removeTodo, 
          toggleTodo, 
      } = bindActionCreators(actions, store.dispatch) </pre>
<ol start="14">
<li>Subscribe a listener to the store that will update the HTML element, that will hold the time, whenever the state changes:</li>
</ol>
<pre>      store.subscribe(() =&gt; { 
          const { currentTime } = store.getState() 
          timeElem.textContent = currentTime 
      }) </pre>
<ol start="15">
<li>Subscribe a listener to the store that will update the HTML element, that will display a lucky number, whenever the state changes:</li>
</ol>
<pre>      store.subscribe(() =&gt; { 
          const { luckyNumber } = store.getState() 
          luckyElem.textContent = `Your lucky number is: ${luckyNumber}` 
      }) </pre>
<ol start="16">
<li>Subscribe a listener to the store that will update the HTML element that will display the list of To-do items, whenever the state changes. Set the attribute <kbd>draggable</kbd> for the <kbd>li</kbd> HTML elements to allow the user to drag and drop the items on the view:</li>
</ol>
<pre>      store.subscribe(() =&gt; { 
          const { todoList } = store.getState() 
          listElem.innerHTML = '' 
          todoList.forEach(todo =&gt; { 
              const li = document.createElement('li') 
              li.textContent = todo.title 
              li.dataset.id = todo.id 
              li.setAttribute('draggable', true) 
              if (todo.completed) { 
                  li.style = 'text-decoration: line-through' 
              } 
              listElem.appendChild(li) 
          }) 
      }) </pre>
<ol start="17">
<li>Add an event listener for the <kbd>click</kbd> event on the list HTML element that will toggle a To-do item's <kbd>completed</kbd> property whenever the item is clicked:</li>
</ol>
<pre>      listElem.addEventListener('click', (event) =&gt; { 
    <strong>      </strong>toggleTodo(event.target.dataset.id) 
      }) </pre>
<ol start="18">
<li>Add an event listener for the <kbd>drag</kbd> event on the list HTML element that will remove a To-do Item when this one is dragged outside of the list:</li>
</ol>
<pre>      listElem.addEventListener('drag', (event) =&gt; { 
          removeTodo(event.target.dataset.id) 
      }) </pre>
<ol start="19">
<li>Add an event listener for the <kbd>submit</kbd> event on the form that contains an input HTML element that will dispatch a new action to add a new To-do item:</li>
</ol>
<pre>      let id = 0 
      formElem.addEventListener('submit', (event) =&gt; { 
          event.preventDefault() 
          addTodo(++id, inputElem.value) 
          inputElem.value = '' 
      }) </pre>
<ol start="20">
<li>When the page loads for the first time, dispatch an action to set a lucky number and define a function that will get triggered every second to update the current time in the state of the application:</li>
</ol>
<pre>      setLuckyNumber(Math.ceil(Math.random() * 1024)) 
      setInterval(() =&gt; { 
          setTime(new Date().toTimeString()) 
      }, 1000) </pre>
<ol start="21">
<li>Save the file</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's test it...</h1>
                </header>
            
            <article>
                
<p>To see the previous work in action:</p>
<ol>
<li>Open a new Terminal and run:</li>
</ol>
<pre><strong>      node todo-time.js</strong></pre>
<ol start="2">
<li>In your browser, visit:</li>
</ol>
<pre>      http://localhost:1337/</pre>
<ol start="3">
<li>Introduce something in the input box and press <span class="KeyPACKT">enter</span>. A new item should appear in the list.</li>
<li>Click on one of the items that you have added to mark it as completed.</li>
<li>Click once again on one of the items marked as completed to mark it as not completed.</li>
<li>Click and drag one of the items outside of the list to remove it from the To-do list.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<ol>
<li>Three reducer functions were defined to independently manage each slice of the state that has the following shape:</li>
</ol>
<pre>      { 
          currentTime: String, 
          luckyNumber: Number, 
          todoList: Array.of({ 
              id: Number, 
              title: String, 
              completed: Boolean, 
          }), 
      } </pre>
<ol start="2">
<li>We used the <kbd>combineReducers</kbd> helper method from the Redux library to combine those three reducers into a single one</li>
<li>Then, a store was created providing the combined reducer function</li>
<li>For convenience, we subscribed three listener functions that get triggered whenever the state changes to update the HTML elements used to display the data from the state</li>
<li>We also defined three event listeners: one to detect when a user submits a form that contains an input HTML element to add a new To-do item, another to detect when the user clicks on a To-do item displayed on the screen to toggle its state from not completed to completed or vice versa, and finally one event listener to detect when the user drags an element from the list to dispatch an action to remove it from the list of To-do items</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Writing Redux store enhancers</h1>
                </header>
            
            <article>
                
<p>A Redux store enhancer is a higher-order function that takes a store creator function and returns a new enhanced store creator function. The <kbd>createStore</kbd> method is a store creator which has the following signature:</p>
<pre>createStore = (reducer, preloadedState, enhancer) =&gt; Store </pre>
<p>While a store enhancer function has the following signature:</p>
<pre>enhancer = (...optionalArguments) =&gt; ( 
createStore =&gt; (reducer, preloadedState, enhancer) =&gt; Store 
) </pre>
<p>It may look a bit difficult to understand now, but you don't really have to worry if you don't get it at first because you will probably never need to write a store enhancer. The purpose of this recipe was simply to help you to understand their purpose in a very simple way.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will create a store enhancer to expand the functionality of Redux by allowing the definition of reducer functions in a <kbd>Map</kbd> JavaScript native object. First, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "redux": "4.0.0" 
    } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>      npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Remember that <kbd>createStore</kbd> accepts a single reducer function as the first argument. We write a store enhancer to allow the <kbd>createStore</kbd> method to accept a <kbd>Map</kbd> object containing key-value pairs, where key is the property or slice of state that will be managed, and value is a <kbd>reducer</kbd> function. Then, define two reducer functions using a <kbd>Map</kbd> object to handle two slices of the state, one for a counter and the other for setting the current time:</p>
<ol>
<li>Create a new file named <kbd>map-store.js</kbd>.</li>
<li>Include the Redux library:</li>
</ol>
<pre>      const { 
          createStore, 
          combineReducers, 
          bindActionCreators, 
      } = require('redux') </pre>
<ol start="3">
<li>Define a store enhancer function that will allow the <kbd>createStore</kbd> method to accept a <kbd>Map</kbd> object as an argument. It will go through each key-value pair of the <kbd>Map</kbd> and add it to an object which will then be used to combine the reducers using the <kbd>combineReducers</kbd> method:</li>
</ol>
<pre>      const acceptMap = () =&gt; createStore =&gt; ( 
          (reducerMap, ...rest) =&gt; { 
              const reducerList = {} 
              for (const [key, val] of reducerMap) { 
                  reducerList[key] = val 
              } 
              return createStore( 
                  combineReducers(reducerList), 
                  ...rest, 
              ) 
          } 
      ) </pre>
<ol start="4">
<li>Define actions types:</li>
</ol>
<pre>      const TYPE = { 
          INC_COUNTER: 'INC_COUNTER', 
          DEC_COUNTER: 'DEC_COUNTER', 
          SET_TIME: 'SET_TIME', 
      } </pre>
<ol start="5">
<li>Define actions creators:</li>
</ol>
<pre>      const actions = { 
          incrementCounter: (incBy) =&gt; ({ 
              type: TYPE.INC_COUNTER, 
              incBy, 
          }), 
          decrementCounter: (decBy) =&gt; ({ 
              type: TYPE.DEC_COUNTER, 
              decBy, 
          }), 
          setTime: (time) =&gt; ({ 
              type: TYPE.SET_TIME, 
              time, 
          }), 
      } </pre>
<ol start="6">
<li>Define a <kbd>map</kbd> constant that will contain an instance of <kbd>Map</kbd>:</li>
</ol>
<pre>      const map = new Map() </pre>
<ol start="7">
<li>Add a new reducer function to the <kbd>map</kbd> object with a key <kbd>counter</kbd>:</li>
</ol>
<pre>      map.set('counter', (state = 0, action) =&gt; { 
          switch (action.type) { 
              case TYPE.INC_COUNTER: return state + action.incBy 
              case TYPE.DEC_COUNTER: return state - action.decBy 
              default: return state 
          } 
      }) </pre>
<ol start="8">
<li>Add another reducer function to the <kbd>map</kbd> object with a key <kbd>time</kbd>:</li>
</ol>
<pre>      map.set('time', (state = null, action) =&gt; { 
          switch (action.type) { 
              case TYPE.SET_TIME: return action.time 
              default: return state 
          } 
      }) </pre>
<ol start="9">
<li>Create a new store providing the <kbd>map</kbd> as the first argument and the <strong>store enhancer</strong> as the second argument to extend the functionality of the <kbd>createStore</kbd> method:</li>
</ol>
<pre>      const store = createStore(map, acceptMap()) </pre>
<ol start="10">
<li>Bind the previously defined actions creators to the <kbd>dispatch</kbd> method of the store:</li>
</ol>
<pre>      const { 
          incrementCounter, 
          decrementCounter, 
          setTime, 
      } = bindActionCreators(actions, store.dispatch) </pre>
<ol start="11">
<li>To test the code in NodeJS, use the <kbd>setInterval</kbd> global method to repeatedly call a function every second. It will first dispatch an action to set the current time, then, based on the criteria, it will decide if to increment or decrement the counter. After, pretty print in the terminal the current value of the store:</li>
</ol>
<pre>      setInterval(function() { 
          setTime(new Date().toTimeString()) 
          if (this.shouldIncrement) { 
              incrementCounter((Math.random() * 5) + 1 | 0) 
          } else { 
              decrementCounter((Math.random() * 5) + 1 | 0) 
          } 
          console.dir( 
              store.getState(), 
              { colors: true, compact: false }, 
          ) 
          this.shouldIncrement = !this.shouldIncrement 
      }.bind({ shouldIncrement: false }), 1000) </pre>
<ol start="12">
<li>Save the file.</li>
<li>Open a new Terminal and run:</li>
</ol>
<pre><strong>      node map-store.js</strong></pre>
<ol start="14">
<li>The current state would be displayed every second having this shape:</li>
</ol>
<pre>      { 
          "counter": Number, 
          "time": String, 
      } </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>The enhancer composes the store creator into a new one. For instance, the following line:</p>
<pre>const store = createStore(map, acceptMap()) </pre>
<p>Could be written as:</p>
<pre>const store = acceptMap()(createStore)(map) </pre>
<p>Which actually, in a way, wraps the original <kbd>createStore</kbd> method into another <kbd>createStore</kbd> method.</p>
<p>Composition can be explained as a set of functions that are called accepting the result argument of the previous function. For instance:</p>
<pre>const c = (...args) =&gt; f(g(h(...args))) </pre>
<p>This composes functions <kbd>f</kbd>, <kbd>g</kbd>, and <kbd>h</kbd> from right to left into a single function <kbd>c</kbd>. That means, we could write the previous line of code also like this:</p>
<pre>const _createStore = acceptMap()(createStore) 
const store = _createStore(map) </pre>
<p>Here <kbd>_createStore</kbd> is the result of composing <kbd>createStore</kbd> and your store enhancer function.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Time traveling with Redux</h1>
                </header>
            
            <article>
                
<p>Even though, you may probably never need to write store enhancers, there is one special that you may find very useful for debugging your Redux powered applications to time travel through the state of your application. You can enable time traveling on your application by simple installing <strong>Redux DevTools Extension</strong> (for Chrome and Firefox): <a href="https://github.com/zalmoxisus/redux-devtools-extension"><span class="URLPACKT">https://github.com/zalmoxisus/redux-devtools-extension</span></a>.<a href="https://github.com/zalmoxisus/redux-devtools-extension"/></p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, we will see an example of how to take advanced of this feature and analyze how the state of your application has changed over the time that was running on the browser. First, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3", 
        "redux": "4.0.0" 
    } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>npm install</strong> </pre>
<p>Make sure to have installed the Redux DevTools Extension in your web browser.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Build a counter application that will randomly increment or decrement the initial specified counter 10 times when the application is run on the browser. However, because it happens fast, the user won't be able to notice that the state has actually changed 10 times since the application started. We will use the Redux DevTools Extension to navigate and analyze how the state has changed over time.</p>
<p>First, build a small ExpressJS server application that will serve the client application and the Redux library installed in <kbd>node_modules</kbd>:</p>
<ol>
<li>Create a new file named <kbd>time-travel.js</kbd></li>
<li>Add the following code:</li>
</ol>
<pre>      const express = require('express') 
      const path = require('path') 
      const app = express() 
      app.use('/lib', express.static( 
          path.join(__dirname, 'node_modules', 'redux', 'dist') 
      )) 
      app.get('/', (req, res) =&gt; { 
          res.sendFile(path.join( 
              __dirname, 
              'time-travel.html', 
          )) 
      }) 
      app.listen( 
          1337, 
          () =&gt; console.log('Web Server running on port 1337'), 
      ) </pre>
<ol start="3">
<li>Save the file</li>
</ol>
<p>Next, build your counter, Redux powered application, with time travel capabilities:</p>
<ol>
<li>Create a new file named <kbd>time-travel.html</kbd></li>
<li>Add the following HTML code:</li>
</ol>
<pre>      &lt;!DOCTYPE html&gt; 
      &lt;html lang="en"&gt; 
      &lt;head&gt; 
          &lt;meta charset="UTF-8"&gt; 
          &lt;title&gt;Time travel&lt;/title&gt; 
          &lt;script <br/>           src="https://unpkg.com/@babel/standalone/babel.min.js"&gt;<br/>          &lt;/script&gt; 
          &lt;script src="/lib/redux.js"&gt;&lt;/script&gt; 
      &lt;/head&gt; 
      &lt;body&gt; 
          &lt;h1&gt;Counter: &lt;span id="counter"&gt;&lt;/span&gt;&lt;/h1&gt; 
          &lt;script type="text/babel"&gt; 
              // Add JavaScript Code here 
          &lt;/script&gt; 
      &lt;/body&gt; 
      &lt;/html&gt; </pre>
<ol start="3">
<li>Inside the script tag add the JavaScript code that follows the next steps, starting from step 4</li>
<li>Keep a reference to the <kbd>span</kbd> HTML element that will display the current value of the counter whenever the state changes:</li>
</ol>
<pre>      const counterElem = document.querySelector('#counter') </pre>
<ol start="5">
<li>Get the <kbd>createStore</kbd> method and <kbd>bindActionCreators</kbd> method from the Redux library:</li>
</ol>
<pre>      const { 
          createStore, 
          bindActionCreators, 
      } = Redux </pre>
<ol start="6">
<li>Define two action types:</li>
</ol>
<pre>      const TYPE = { 
          INC_COUNTER: 'INC_COUNTER', 
          DEC_COUNTER: 'DEC_COUNTER', 
      } </pre>
<ol start="7">
<li>Define two action creators:</li>
</ol>
<pre>      const actions = { 
          incCounter: (by) =&gt; ({ type: TYPE.INC_COUNTER, by }), 
          decCounter: (by) =&gt; ({ type: TYPE.DEC_COUNTER, by }), 
      } </pre>
<ol start="8">
<li>Define a reducer function that will transform the state according to the given action type:</li>
</ol>
<pre>      const reducer = (state = { value: 5 }, action) =&gt; { 
          switch (action.type) { 
              case TYPE.INC_COUNTER: 
                  return { value: state.value + action.by } 
              case TYPE.DEC_COUNTER: 
                  return { value: state.value - action.by } 
              default: 
                  return state 
          } 
      } </pre>
<ol start="9">
<li>Create a new store providing a store enhancer function that will be available on the <kbd>window</kbd> object when the Redux DevTools extension is installed:</li>
</ol>
<pre>      const store = createStore( 
          reducer, 
          ( 
              window.__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; 
              window.__REDUX_DEVTOOLS_EXTENSION__() 
          ), 
      ) </pre>
<ol start="10">
<li>Bind the action creators to the <kbd>dispatch</kbd> method of the store:</li>
</ol>
<pre>      const { 
          incCounter, 
          decCounter, 
      } = bindActionCreators(actions, store.dispatch) </pre>
<ol start="11">
<li>Subscribe a listener function to the store that will update the <kbd>span</kbd> HTML element whenever the state changes:</li>
</ol>
<pre>      store.subscribe(() =&gt; { 
          const state = store.getState() 
          counterElem.textContent = state.value 
      }) </pre>
<ol start="12">
<li>Let's create a <kbd>for</kbd> loop that will update increment or decrement the counter randomly 10 times when the application is run:</li>
</ol>
<pre>      for (let i = 0; i &lt; 10; i++) { 
          const incORdec = (Math.random() * 10) &gt; 5 
          if (incORdec) incCounter(2) 
          else decCounter(1) 
      } </pre>
<ol start="13">
<li>Save the file</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's test it...</h1>
                </header>
            
            <article>
                
<p>To see the previous work in action:</p>
<ol>
<li>Open a new Terminal and run:</li>
</ol>
<pre><strong>      node todo-time.js</strong></pre>
<ol start="2">
<li>In your Browser, visit:</li>
</ol>
<pre>      http://localhost:1337/</pre>
<ol start="3">
<li>Open <span class="packt_screen">Developer Tools</span> of your Browser and look for the <span class="packt_screen">Redux</span> tab. You should see a tab like this:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/d6635f01-f201-44b1-91ba-76ee735152da.png" style="width:27.08em;height:19.00em;" width="762" height="534"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Redux DevTools â Tab Window</span></div>
<ol start="4">
<li>The slider allows you to move from the last state to the very first state of your application. Try moving the slider to a different position:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="Images/64146aed-2c98-42af-bfef-96fa08b2d098.png" style="width:28.08em;height:17.67em;" width="764" height="480"/></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span>Redux DevTools â Moving Slider</span></div>
<ol start="5">
<li>While moving the slider, you would be able to see in your browser the counters initial value and how it changed those ten times in the for loop</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more</h1>
                </header>
            
            <article>
                
<p><strong>Redux DevTools</strong> has some features that you will probably find amazing and helpful for debugging and managing the state of your application. In fact, if you followed the previous recipes, I suggest you go back to the projects we wrote and enable this enhancer and try to experiment with Redux DevTools.</p>
<p>One of many features of Redux DevTools is the <span class="packt_screen">Log monitor</span>, which displays in chronological order which action was dispatched and the resulting value of transforming the state:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="Images/c1d3b8a0-3d7d-4f30-80a0-1c660b506e43.png" style="width:29.83em;height:18.75em;" width="764" height="480"/></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign">Redux DevTools â Log Monitor</div>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Understanding Redux middleware</h1>
                </header>
            
            <article>
                
<p>Probably the easiest and best way of extending the Redux functionality is by using middleware.</p>
<p>There is a store enhancer function that comes in the Redux library named <kbd>applyMiddleware</kbd> and allows you define one or multiple middleware functions. The way middleware works in Redux is simple, it allows you to wrap the <kbd>dispatch</kbd> method of the store to extend its functionality. The same way as store enhancer functions, middleware is composable and has the following signature:</p>
<pre>middleware = API =&gt; next =&gt; action =&gt; next(action) </pre>
<p>Here, <kbd>API</kbd> is an object containing the <kbd>dispatch</kbd> and <kbd>getState</kbd> methods from the store, destructuring the <kbd>API</kbd>, the signature looks like this:</p>
<pre>middleware = ({ 
    getState, 
    dispatch, 
}) =&gt; next =&gt; action =&gt; next(action)  </pre>
<p>Let's analyze how it works:</p>
<ol>
<li>The <kbd>applyMiddleware</kbd> function receives one or more middleware functions as arguments. For example:</li>
</ol>
<pre>      applyMiddleware(middleware1, middleware2) </pre>
<ol start="2">
<li>Each middleware function is kept internally as an <kbd>Array</kbd>. Then, internally using the <kbd>Array.prototype.map</kbd> method, the array maps each middleware function by calling itself providing the middleware <kbd>API</kbd> object which contains the <kbd>dispatch</kbd> and <kbd>getState</kbd> methods of the store. Similar to this:</li>
</ol>
<pre>      middlewares.map((middleware) =&gt; middleware(API)) </pre>
<ol start="3">
<li>Then, by composing all the middleware functions, it computes a new value for the <kbd>dispatch</kbd> method providing the <kbd>next</kbd> argument. In the very first middleware that is executed, the <kbd>next</kbd> argument refers to the original <kbd>dispatch</kbd> method before any middleware was applied. For instance, if applying three middleware functions, the new computed dispatch method's signature would be:</li>
</ol>
<pre>      dispatch = (action) =&gt; ( 
          (action) =&gt; ( 
              (action) =&gt; store.dispatch(action) 
          )(action) 
      )(action) </pre>
<ol start="4">
<li>Which means that a middleware function can interrupt the chain and prevent a certain action from being dispatched if the <kbd>next(action)</kbd> method is not called</li>
<li>The dispatch method from the middleware <kbd>API</kbd> object, allows you to call the dispatch method of the store with the previously applied middleware. That means, if you are not careful while using this method, you may create an infinite loop</li>
</ol>
<p>Understanding how it works internally may not be so simple at first, but I assure you that you will get it soon.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will write a middleware function that will warn the user when dispatching an action type that has not been defined. First, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "redux": "4.0.0" 
    } 
} </pre>
<p>Then, install the dependencies by opening a Terminal and running:</p>
<pre><strong>npm install</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Redux doesn't warn you or display errors when an action type, that was never defined within your reducers, is used. Build a NodeJS application that will use Redux to manage its state. Focus on writing a middleware function that will check that the dispatched actions types are defined or else throw an error:</p>
<ol>
<li>Create a new file named <kbd>type-check-redux.js</kbd>.</li>
<li>Include the Redux library:</li>
</ol>
<pre>      const { 
          createStore, 
          applyMiddleware, 
      } = require('redux') </pre>
<ol start="3">
<li>Define an object containing the allowed action types:</li>
</ol>
<pre>      const TYPE = { 
          INCREMENT: 'INCREMENT', 
          DECREMENT: 'DECREMENT', 
          SET_TIME: 'SET_TIME', 
      } </pre>
<ol start="4">
<li>Create a dummy reducer function that returns its original state whichever action type is called. We don't need it for the purpose of this recipe:</li>
</ol>
<pre>      const reducer = ( 
          state = null, 
          action, 
      ) =&gt; state </pre>
<ol start="5">
<li>Define a middleware function that will intercept every action that is being dispatched and check whether the action type exists in the <kbd>TYPE</kbd> object. If the action exists allow the action to be dispatched, or otherwise, throw an error and inform the user that an invalid action type was dispatched. Additionally, let's provide the user, as part of the error message, information about which valid types are allowed:</li>
</ol>
<pre>      const typeCheckMiddleware = api =&gt; next =&gt; action =&gt; { 
          if (Reflect.has(TYPE, action.type)) { 
              next(action) 
          } else { 
              const err = new Error( 
                  `Type "${action.type}" is not a valid` + 
                  `action type. ` + 
                  `did you mean to use one of the following` + 
                  `valid types? ` + 
                  `"${Reflect.ownKeys(TYPE).join('"|"')}"n`, 
              ) 
              throw err 
          } 
      } </pre>
<ol start="6">
<li>Create a store and apply the defined middleware function:</li>
</ol>
<pre>      const store = createStore( 
          reducer, 
          applyMiddleware(typeCheckMiddleware), 
      ) </pre>
<ol start="7">
<li>Dispatch two action types. The first action type is valid, and it exists in the <kbd>TYPE</kbd> object. However, the second one is an action type that was never defined:</li>
</ol>
<pre>      store.dispatch({ type: 'INCREMENT' }) 
      store.dispatch({ type: 'MISTAKE' }) </pre>
<ol start="8">
<li>Save the file.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's test it...</h1>
                </header>
            
            <article>
                
<p>First, open a new Terminal and run:</p>
<pre>    <strong>node type-check-redux.js </strong></pre>
<p>The Terminal output should display an error similar to this:</p>
<pre>/type-check-redux.js:25 
                throw err 
                ^ 
Error: Type "MISTAKE" is not a valid action type. did you mean to use one of the following valid types? "INCREMENT"|"DECREMENT"|"SET_TIME" 
    at Object.action [as dispatch] (/type-check-redux.js:18:15) 
    at Object.&lt;anonymous&gt; (/type-check-redux.js:33:7) </pre>
<p>In this example, the stack trace tells us that the error happened on line <kbd>18</kbd>, which points to our middleware function. However, the next one points to line <kbd>33</kbd>, <kbd>store.dispatch({ type: 'MISTAKE' })</kbd>, which is a good thing because it can help you track exactly where certain actions are dispatched that were never defined.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>It's pretty simple, the middleware function checks the action type, of the action being dispatched, to see if it exists as a property of the <kbd>TYPE</kbd> object constant. If it exists, then the middleware passes control to the next middleware in the chain. However, in our case, there is no next middleware, so the control is passed to the original dispatch method of the store that will apply the reducer and transform the state. On the other side, if the action type was not defined, the middleware function interrupts the middleware chain by not calling the <kbd>next</kbd> function and by throwing an error.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Dealing with asynchronous data flow</h1>
                </header>
            
            <article>
                
<p>By default, Redux doesn't handle asynchronous data flow. There are several libraries out there that can help you with these tasks. However, for the purpose of this chapter, we will build our own implementation using middleware functions to give the <kbd>dispatch</kbd> method the ability to dispatch and handle asynchronous data flow.</p>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Getting ready</h1>
                </header>
            
            <article>
                
<p>In this recipe, you will build an ExpressJS application with a very small API to test your application when making HTTP requests and dealing with asynchronous data flow and errors. First, create a new <kbd>package.json</kbd> file with the following content:</p>
<pre>{ 
    "dependencies": { 
        "express": "4.16.3", 
        "node-fetch": "2.1.2", 
        "redux": "4.0.0" 
    } 
} </pre>
<p>Then install the dependencies by opening a Terminal and running:</p>
<pre><strong>npm install</strong>  </pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<p>Build a simple RESTful API server that will have two endpoints or answer to paths <kbd>/time</kbd> and <kbd>/date</kbd> when a GET request is made. However, on <kbd>/date</kbd> path, we will pretend that there is an internal error and make the request fail in order to see how to handle errors in asynchronous requests as well:</p>
<ol>
<li>Create a new file named <kbd>api-server.js</kbd></li>
<li>Include the ExpressJS library and initialize a new ExpressJS application:</li>
</ol>
<pre>      const express = require('express') 
      const app = express() </pre>
<ol start="3">
<li>For <kbd>/time</kbd> path, simulates a delay of <kbd>2s</kbd> before sending a response:</li>
</ol>
<pre>      app.get('/time', (req, res) =&gt; { 
          setTimeout(() =&gt; { 
              res.send(new Date().toTimeString()) 
          }, 2000) 
      }) </pre>
<ol start="4">
<li>For <kbd>/date</kbd> path, simulates a delay of <kbd>2s</kbd> before sending a failed response:</li>
</ol>
<pre>      app.get('/date', (req, res) =&gt; { 
          setTimeout(() =&gt; { 
              res.destroy(new Error('Internal Server Error')) 
          }, 2000) 
      }) </pre>
<ol start="5">
<li>Listen on port <kbd>1337</kbd> for new connections</li>
</ol>
<pre>      app.listen( 
          1337, 
          () =&gt; console.log('API server running on port 1337'), 
      ) </pre>
<ol start="6">
<li>Save the file</li>
</ol>
<p>As for the client, build a NodeJS application using Redux that will dispatch synchronous and asynchronous actions. Write a middleware function to allow the dispatch method to handle asynchronous actions:</p>
<ol>
<li>Create a new file named <kbd>async-redux.js</kbd></li>
<li>Include the <kbd>node-fetch</kbd> and Redux libraries:</li>
</ol>
<pre>      const fetch = require('node-fetch') 
      const { 
          createStore, 
          applyMiddleware, 
          combineReducers, 
          bindActionCreators, 
      } = require('redux') </pre>
<ol start="3">
<li>Define three kinds of status. Each status represents the state of an asynchronous operation:</li>
</ol>
<pre>      const STATUS = { 
          PENDING: 'PENDING', 
          RESOLVED: 'RESOLVED', 
          REJECTED: 'REJECTED', 
      } </pre>
<ol start="4">
<li>Define two action types:</li>
</ol>
<pre>      const TYPE = { 
          FETCH_TIME: 'FETCH_TIME', 
          FETCH_DATE: 'FETCH_DATE', 
      } </pre>
<ol start="5">
<li>Define action creators. Notice that the value property is an asynchronous function in the first two action creators. Your, later defined, middleware function will be responsible for making Redux understand these actions:</li>
</ol>
<pre>      const actions = { 
          fetchTime: () =&gt; ({ 
              type: TYPE.FETCH_TIME, 
              value: async () =&gt; { 
                  const time = await fetch( 
                      'http://localhost:1337/time' 
                  ).then((res) =&gt; res.text()) 
                  return time 
              } 
          }), 
          fetchDate: () =&gt; ({ 
              type: TYPE.FETCH_DATE, 
              value: async () =&gt; { 
                  const date = await fetch( 
                      'http://localhost:1337/date' 
                  ).then((res) =&gt; res.text()) 
                  return date 
              } 
          }), 
          setTime: (time) =&gt; ({ 
              type: TYPE.FETCH_TIME, 
              value: time, 
          }) 
      } </pre>
<ol start="6">
<li>Define a common function for setting values from an action object that will be used in your reducer:</li>
</ol>
<pre>      const setValue = (prevState, action) =&gt; ({ 
          ...prevState, 
          value: action.value || null, 
          error: action.error || null, 
          status: action.status || STATUS.RESOLVED, 
      }) </pre>
<ol start="7">
<li>Define the initial state of your application:</li>
</ol>
<pre>      const iniState = { 
          time: { 
              value: null, 
              error: null, 
              status: STATUS.RESOLVED, 
          }, 
          date: { 
              value: null, 
              error: null, 
              status: STATUS.RESOLVED, 
          } 
      } </pre>
<ol start="8">
<li>Define a reducer function. Notice that it is only one reducer that handles two slices of the state, the <kbd>time</kbd> and the <kbd>date</kbd>:</li>
</ol>
<pre>      const timeReducer = (state = iniState, action) =&gt; { 
          switch (action.type) { 
              case TYPE.FETCH_TIME: return { 
                  ...state, 
                  time: setValue(state.time, action) 
              } 
              case TYPE.FETCH_DATE: return { 
                  ...state, 
                  date: setValue(state.date, action) 
              } 
              default: return state 
          } 
      } </pre>
<ol start="9">
<li>Define a middleware function that will check whether a dispatched action type has a function as the <kbd>value</kbd> property. If that is so, assume that the <kbd>value</kbd> property is an async function. First, we dispatch an action to set the status as <kbd>PENDING</kbd>. Then, when the async function is resolved, we dispatch another action to set the status as <kbd>RESOLVED</kbd> or in case of an error as <kbd>REJECTED</kbd>:</li>
</ol>
<pre>      const allowAsync = ({ dispatch }) =&gt; next =&gt; action =&gt; { 
          if (typeof action.value === 'function') { 
              dispatch({ 
                  type: action.type, 
                  status: STATUS.PENDING, 
              }) 
              const promise = Promise 
                  .resolve(action.value()) 
                  .then((value) =&gt; dispatch({ 
                      type: action.type, 
                      status: STATUS.RESOLVED, 
                      value, 
                  })) 
                        .catch((error) =&gt; dispatch({ 
                      type: action.type, 
                      status: STATUS.REJECTED, 
                      error: error.message, 
                  })) 
              return promise 
          } 
          return next(action) 
      } </pre>
<ol start="10">
<li>Create a new store and apply your defined middleware function to extend the functionality of the <kbd>dispatch</kbd> method:</li>
</ol>
<pre>      const store = createStore( 
          timeReducer, 
          applyMiddleware( 
              allowAsync, 
          ), 
      ) </pre>
<ol start="11">
<li>Bind action creators to the <kbd>dispatch</kbd> method of the store:</li>
</ol>
<pre>      const { 
          setTime, 
          fetchTime, 
          fetchDate, 
      } = bindActionCreators(actions, store.dispatch) </pre>
<ol start="12">
<li>Subscribe a function listener to the store and display in terminal the state tree, as a JSON string, every time there is a change in the state:</li>
</ol>
<pre>      store.subscribe(() =&gt; { 
          console.log('x1b[1;34m%sx1b[0m', 'State has changed') 
          console.dir( 
              store.getState(), 
              { colors: true, compact: false }, 
          ) 
      }) </pre>
<ol start="13">
<li>Dispatch a synchronous action to set the time:</li>
</ol>
<pre>      setTime(new Date().toTimeString()) </pre>
<ol start="14">
<li>Dispatch an asynchronous action to fetch and set the time:</li>
</ol>
<pre>      fetchTime() </pre>
<ol start="15">
<li>Dispatch another asynchronous action to fetch and try to set the date. Remember that this operation is supposed to fail and it's intentional:</li>
</ol>
<pre>      fetchDate() </pre>
<ol start="16">
<li>Save the file.</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Let's test it...</h1>
                </header>
            
            <article>
                
<p>To see your previous work in action:</p>
<ol>
<li>Open a new terminal and run:</li>
</ol>
<pre><strong>      node api-server.js</strong></pre>
<ol start="2">
<li>Without closing the previously running NodeJS process, open another Terminal and run:</li>
</ol>
<pre><strong>      node async-redux.js</strong></pre>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<ol>
<li>Every time there is a change in the state, the subscribed listener function will pretty print in the terminal the current state tree</li>
<li>The first dispatched action is synchronous. It will cause the time slice of the state tree to be updated like this, for example:</li>
</ol>
<pre>      time: { 
          value: "01:02:03 GMT+0000", 
          error: null, 
          status: "RESOLVED" 
      } </pre>
<ol start="3">
<li>The second action being dispatched is asynchronous. Internally, two actions are dispatched to reflect the state of the asynchronous operation, one when the async function is still in execution, and another when the async function was fulfilled:</li>
</ol>
<pre>      time: { 
          value: null, 
          error: null, 
          status: "PENDING" 
      } 
      // Later, once the operation is fulfilled: 
      time: { 
          value: "01:02:03 GMT+0000", 
          error: null, 
          status: "RESOLVED" 
      } </pre>
<ol start="4">
<li>The third action being dispatched is also asynchronous. Internally, it also causes two actions to be dispatched to reflect the state of the async operation:</li>
</ol>
<pre>      date: { 
          value: null, 
          error: null, 
          status: "PENDING" 
      } 
      // Later, once the operation is fulfilled: 
      date: { 
          value: null, 
          error: "request to http://localhost:1337/date failed, reason:   <br/>             socket hang up", 
          status: "REJECTED" 
      } </pre>
<ol start="5">
<li>Take into account that because the operations are asynchronous, the output displayed in the terminal may not always be in the same order</li>
<li>Notice that the first async operation is fulfilled and the status marked as <kbd>RESOLVED</kbd> while the second async operation is fulfilled and its status marked as <kbd>REJECTED</kbd></li>
<li>The statuses <kbd>PENDING</kbd>, <kbd>RESOLVED</kbd>, and <kbd>REJECTED</kbd> reflect the three statuses that a JavaScript Promise can be, and they are not obligatory names, simply easy to remember</li>
</ol>


            </article>

            
        </section>
    </div>



  
<div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>If you don't want to write your own middleware functions or store enhancers to deal with asynchronous operations, you can opt to use one of the many libraries for Redux that exist out there. Two of the most use or popular ones are these:</p>
<ul>
<li>Redux Thunkâ<a href="https://github.com/gaearon/redux-thunk"><span class="URLPACKT">https://github.com/gaearon/redux-thunk</span></a></li>
<li>Redux Sagaâ<a href="https://github.com/redux-saga/redux-saga"><span class="URLPACKT">https://github.com/redux-saga/redux-saga</span></a></li>
</ul>


            </article>

            
        </section>
    </div>



  </body></html>