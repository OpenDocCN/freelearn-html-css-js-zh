<html><head></head><body><div class="chapter" title="Chapter&#xA0;9.&#xA0;Creating Your Own Blockbuster Game &#x2013; A Complete Match 3 Game"><div class="titlepage"><div><div><h1 class="title"><a id="ch09"/>Chapter 9. Creating Your Own Blockbuster Game – A Complete Match 3 Game</h1></div></div></div><p>This is the last chapter of this book, and I really hope you have enjoyed reading it as much as I enjoyed writing it. When I drafted the initial outline for this book, I planned to dedicate the last chapter to a Match 3 game such as Candy Crush Saga or Farm Heroes Saga.</p><p>I then realized that there are tons of tutorials about these games available around the Web. Hence, I decided to show y'all something new, the engine of the <a id="id329" class="indexterm"/>Dungeon Raid game (available at <a class="ulink" href="https://itunes.apple.com/us/app/dungeon-raid/id403090531">https://itunes.apple.com/us/app/dungeon-raid/id403090531</a>), which I adapted to create<a id="id330" class="indexterm"/> Globez (available at <a class="ulink" href="http://www.mindjolt.com/globez.html">http://www.mindjolt.com/globez.html</a>), a game that has been played millions of times.</p><div class="mediaobject"><img src="graphics/0075OS_09_1.jpg" alt="Creating Your Own Blockbuster Game – A Complete Match 3 Game"/></div><p>During the making of this game, you will not only use most of the concepts described in this book in the creation of a real game engine, but you will also learn the bare bones of the Cocos2d-JS drawing API.</p><p>Follow the steps carefully; this is a complete game engine, and there's a lot to do.</p><div class="section" title="Setting up the game"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec60"/>Setting up the game</h1></div></div></div><p>Since it's a basic game<a id="id331" class="indexterm"/> with no physics, we don't need to include external libraries; so, <code class="literal">project.json</code> returns to its original content:</p><div class="informalexample"><pre class="programlisting">{
  "debugMode" : 0,
  "showFPS" : false,
  "frameRate" : 60,
  "id" : "gameCanvas",
  "renderMode" : 0,
  "engineDir":"cocos2d-html5/",

  "modules" : ["cocos2d"],

  "jsList" : [
  "src/loadassets.js",
  "src/gamescript.js"
  ]
}</pre></div><p>Also, the content of <code class="literal">main.js</code> is basically the same as always:</p><div class="informalexample"><pre class="programlisting">cc.game.onStart = function(){
  var screenSize = cc.view.getFrameSize();
  <span class="strong"><strong>cc.view.setDesignResolutionSize(300, 300, cc.ResolutionPolicy.SHOW_ALL);</strong></span>
  cc.LoaderScene.preload(gameResources, function () {
    cc.director.runScene(new gameScene());
  }, this);
};
cc.game.run();</pre></div><p>Just have a look at the resolution: 300x300 is the main game area. For now, we'll only focus on the main game area, and believe me, you'll have enough to do!</p><p>
<code class="literal">loadassets.js</code> is loading a sprite sheet created with <a id="id332" class="indexterm"/>
<span class="strong"><strong>TexturePacker</strong></span>:</p><div class="informalexample"><pre class="programlisting">var gameResources = [
"assets/globes.png",
"assets/globes.plist",
];</pre></div><p>
<code class="literal">globes.png</code> is just one single file with all colored globes:</p><div class="mediaobject"><img src="graphics/0075OS_09_2.jpg" alt="Setting up the game"/></div><p>And <code class="literal">globes.plist</code> defines<a id="id333" class="indexterm"/> various images this way, with each color name assigned the <code class="literal">key</code> node. For example:</p><div class="informalexample"><pre class="programlisting">&lt;key&gt;purple&lt;/key&gt;
&lt;dict&gt;
  &lt;key&gt;frame&lt;/key&gt;
  &lt;string&gt;{{2,2},{46,46}}&lt;/string&gt;
  &lt;key&gt;offset&lt;/key&gt;
  &lt;string&gt;{0,0}&lt;/string&gt;
  &lt;key&gt;rotated&lt;/key&gt;
  &lt;false/&gt;
  &lt;key&gt;sourceColorRect&lt;/key&gt;
  &lt;string&gt;{{2,2},{46,46}}&lt;/string&gt;
  &lt;key&gt;sourceSize&lt;/key&gt;
  &lt;string&gt;{50,50}&lt;/string&gt;
&lt;/dict&gt;</pre></div><p>Now that we are done with the settings, we can start coding the game itself.</p><div class="section" title="Creating the board"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec16"/>Creating the board</h2></div></div></div><p>The first thing<a id="id334" class="indexterm"/> we'll do is create the board in <code class="literal">gamescript.js</code> on which we'll be playing the game. Trying to<a id="id335" class="indexterm"/> make the engine as customizable as we can, we'll start with some global variables. Changing most of them will result in a quick gameplay change. It is shown as follows:</p><div class="informalexample"><pre class="programlisting">var fieldSize = 6;
var tileTypes = ["red", "green", "blue", "grey", "yellow"];
var tileSize = 50;
var tileArray = [];
var globezLayer;</pre></div><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">fieldSize</code>: This variable is the width and height of the field size, in tiles. This means we will play on a 6 x 6 tile field.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tileTypes</code>: This is an array with the keys of the sprites defined in the <code class="literal">globes.plist</code> file. I used only five different kinds of globez because I like the game to offer the opportunity to make big combos. You can choose how many colors you want; just keep in mind the more the colors in the game, the harder the gameplay.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tileSize</code>: This variable is the size of a tile, in pixels.</li><li class="listitem" style="list-style-type: disc"><code class="literal">tileArray</code>: This is the <a id="id336" class="indexterm"/>array that will contain all globez objects.</li><li class="listitem" style="list-style-type: disc"><code class="literal">globezLayer</code>: This variable will be the layer where globez tiles will be placed.</li></ul></div><p>The <code class="literal">gameScene</code> definition does not change:</p><div class="informalexample"><pre class="programlisting">var gameScene = cc.Scene.extend({
  onEnter:function () {
    this._super();
    gameLayer = new game();
    gameLayer.init();
    this.addChild(gameLayer);
  }
});</pre></div><p>Let's have a look at the <a id="id337" class="indexterm"/>game definition, the core of the script:</p><div class="informalexample"><pre class="programlisting">var game = cc.Layer.extend({
  init:function () {
    this._super();
    cc.spriteFrameCache.addSpriteFrames("assets/globes.plist", "assets/globes.png");
    var backgroundLayer = cc.LayerGradient.create(cc.color(0x00,0x22,0x22,255), cc.color(0x22,0x00,0x44,255));
    this.addChild(backgroundLayer);
    globezLayer = cc.Layer.create();
    // new cc.layer() can also be used
    this.addChild(globezLayer)
    this.createLevel();
  },
  createLevel: function(){
    // do something
  }
});</pre></div><p>There's nothing<a id="id338" class="indexterm"/> new here; we load the sprite sheet, create and place a background layer, create and place the layer<a id="id339" class="indexterm"/> that will contain all globez, and call the <a id="id340" class="indexterm"/>
<code class="literal">createLevel </code>function.</p><p>Let's add globe creation to <code class="literal">createLevel</code>:</p><div class="informalexample"><pre class="programlisting">createLevel: function(){
  for(var i = 0; i &lt; fieldSize; i ++){
    tileArray[i] = [];
    for(var j = 0;j &lt; fieldSize; j ++){
      this.addTile(i, j);
    }
  }
},
addTile:function(row,col){
  // do something
}</pre></div><p>Here we are just building a two-dimensional array called <code class="literal">tileArray</code> according to the <code class="literal">fieldSize</code> number of entries. Given the <span class="emphasis"><em>i</em></span> and <span class="emphasis"><em>j</em></span> values, the <code class="literal">addTile</code> function causes the final creation of the tile, which accepts the row and the column of such a tile in the game field.</p><p>Let's look at <code class="literal">addTile</code> to know how to set up a game field:</p><div class="informalexample"><pre class="programlisting">addTile:function(row,col){
  var randomTile = Math.floor(Math.random()*tileTypes.length);
  var spriteFrame = cc.spriteFrameCache.getSpriteFrame(tileTypes[randomTile]);
  var sprite = cc.Sprite.createWithSpriteFrame(spriteFrame);
  // new cc.Sprite(spriteFrame) can also be used
  sprite.val = randomTile;
  sprite.picked = false;
  globezLayer.addChild(sprite,0);
  sprite.setPosition(col*tileSize+tileSize/2,row*tileSize+tileSize/2);
  tileArray[row][col] = sprite;
}</pre></div><p>At this point of time, you can test the project and see what happens:</p><div class="mediaobject"><img src="graphics/0075OS_09_3.jpg" alt="Creating the board"/></div><p>Did you notice? Every time you run the game, you get a different, random game field.</p><p>Having a look at the <code class="literal">addTile</code> function will let you understand what happened:</p><div class="informalexample"><pre class="programlisting">var randomTile = Math.floor(Math.random()*tileTypes.length);</pre></div><p>First, a random number between zero and the number of allowed tile types minus one is generated. In this case, it is from zero to five.</p><div class="informalexample"><pre class="programlisting">var spriteFrame = cc.spriteFrameCache.getSpriteFrame(tileTypes[randomTile]);</pre></div><p>From the sprite sheet, we<a id="id341" class="indexterm"/> will pick the sprite with the same key as <code class="literal">tileTypes[randomTile]</code>:</p><div class="informalexample"><pre class="programlisting">var sprite = cc.Sprite.createWithSpriteFrame(spriteFrame);</pre></div><p>Finally, the sprite is<a id="id342" class="indexterm"/> created starting from its assigned frame:</p><div class="informalexample"><pre class="programlisting">sprite.val = randomTile;
sprite.picked = false;</pre></div><p>I added two custom attributes to our sprite:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">val</code>: This variable represents the value of the tile as defined by the <code class="literal">randomTile</code> variable</li><li class="listitem" style="list-style-type: disc"><code class="literal">picked</code>: This is a Boolean variable that says whether the tile has currently been picked by the players</li></ul></div><p>Then, the sprite is added to the <code class="literal">globezLayer</code> layer:</p><div class="informalexample"><pre class="programlisting">globezLayer.addChild(sprite,0);</pre></div><p>Now, we have to<a id="id343" class="indexterm"/> make something with all these globez.</p></div><div class="section" title="Selecting and deselecting the first globe"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec17"/>Selecting and deselecting the first globe</h2></div></div></div><p>What's the first thing we<a id="id344" class="indexterm"/> need to do when we want the player to<a id="id345" class="indexterm"/> interact with the game? Yes, add a<a id="id346" class="indexterm"/> listener. We will add it to the<a id="id347" class="indexterm"/> game's <code class="literal">init</code> function:</p><div class="informalexample"><pre class="programlisting">init:function () {
  this._super();
  cc.spriteFrameCache.addSpriteFrames("assets/globes.plist", "assets/globes.png");
  var backgroundLayer = cc.LayerGradient.create(cc.color(0x00,0x22,0x22,255), cc.color(0x22,0x00,0x44,255));
  this.addChild(backgroundLayer);
  globezLayer = cc.Layer.create();
  this.addChild(globezLayer)
  this.createLevel();
  <span class="strong"><strong>cc.eventManager.addListener(touchListener, this);</strong></span>
}</pre></div><p>These are all concepts you have already met; I am just putting them together in order to create a game. So, you should know by now that we are going to declare <code class="literal">touchListener</code>; but first, let me add two more global variables to keep track of all the tiles I am going to select and the color I select:</p><div class="informalexample"><pre class="programlisting">var fieldSize = 6;
var tileTypes = ["red","green","blue","grey","yellow"];
var tileSize = 50;
var tileArray = [];
var globezLayer;
<span class="strong"><strong>var startColor = null;</strong></span>
<span class="strong"><strong>var visitedTiles = [];</strong></span>
</pre></div><p>
<code class="literal">visitedTiles</code> is the array that will store the tiles once they have been picked up by the player, while <code class="literal">startColor</code> is the color of the first tile selected. We start with <code class="literal">null</code> as no color has been selected.</p><p>Now, let's move to the <code class="literal">touchListener</code> creation:</p><div class="informalexample"><pre class="programlisting">var touchListener = cc.EventListener.create({
  event: cc.EventListener.MOUSE,
  onMouseDown: function (event) {
    var pickedRow = Math.floor(event._y / tileSize);
    var pickedCol = Math.floor(event._x / tileSize);
    tileArray[pickedRow][pickedCol].setOpacity(128);
    tileArray[pickedRow][pickedCol].picked = true;
    startColor = tileArray[pickedRow][pickedCol].val;
    visitedTiles.push({
      row: pickedRow,
      col: pickedCol
    });
  },
  onMouseUp: function(event){
    startColor=null;
    for(i = 0; i &lt; visitedTiles.length; i ++){
      tileArray[visitedTiles[i].row][visitedTiles[i].col].setOpacity(255);
      tileArray[visitedTiles[i].row][visitedTiles[i].col].picked=false;
    }
  }
});</pre></div><p>It seems a lot of<a id="id348" class="indexterm"/>  code but don't worry; it's really easy. Check the following line of code:</p><div class="informalexample"><pre class="programlisting">event: cc.EventListener.MOUSE</pre></div><p>This time, we will play with the mouse but, obviously, you can use touch if you want. Let's say you should be<a id="id349" class="indexterm"/> able to use both ways to control the game. Using the mouse, we have to deal with two events, <code class="literal">onMouseDown</code> and <code class="literal">onMouseUp</code>:</p><div class="informalexample"><pre class="programlisting">onMouseDown: function (event) {
  var pickedRow = Math.floor(event._y / tileSize);
  var pickedCol = Math.floor(event._x / tileSize);
  tileArray[pickedRow][pickedCol].setOpacity(128);
  tileArray[pickedRow][pickedCol].picked = true;
  startColor = tileArray[pickedRow][pickedCol].val;
  visitedTiles.push({
    row: pickedRow,
    col: pickedCol
  });
}</pre></div><p>When the mouse is pressed, the <code class="literal">pickedRow</code> and <code class="literal">pickedCol</code> variables take the index of the row and column picked by the mouse according to click coordinates and <code class="literal">tileSize</code>. Once I know the row and column of the globe I picked, I can make it semitransparent by setting its opacity to 128—remember that opacity ranges from 0 to 255 in Cocos2d-JS with the <code class="literal">setOpacity</code> method. Also, I set the globe <code class="literal">picked</code> value to <code class="literal">true</code> because I actually picked it up, and since it's the first globe I am picking, I also need to set <code class="literal">startColor</code> to the globe color. From now on, we will only have to pick globez with the same color.</p><p>Last but not least, we<a id="id350" class="indexterm"/> need to update the <code class="literal">visitedTiles</code> array with the newly picked globe—in this case, it's added as an object.</p><p>At the moment, <code class="literal">onMouseUp</code> is quite<a id="id351" class="indexterm"/> simple, although it will become the most complicated function in the whole game. It is as follows:</p><div class="informalexample"><pre class="programlisting">onMouseUp: function(event){
  startColor=null;
  for(i = 0; i &lt; visitedTiles.length; i ++){
    tileArray[visitedTiles[i].row][visitedTiles[i].col].setOpacity(255);
    tileArray[visitedTiles[i].row][visitedTiles[i].col].picked=false;
  }
  visitedTiles = [];
}</pre></div><p>There isn't much to say; once the player releases the mouse, the <code class="literal">startColor</code> method needs to be reset to <code class="literal">null</code> and each globe in the <code class="literal">visitedTiles</code> array must be set to fully opaque, with the <code class="literal">picked</code> attribute set to <code class="literal">false</code>. With an empty <code class="literal">visitedTiles</code> array, we are ready to wait for the next player choice.</p><p>Test the game and try to pick and release a globe:</p><div class="mediaobject"><img src="graphics/0075OS_09_4.jpg" alt="Selecting and deselecting the first globe"/></div><p>As you can see, when <a id="id352" class="indexterm"/>you pick a globe, it turns semitransparent. When<a id="id353" class="indexterm"/> you release it, it returns fully opaque.</p><p>Let's make our first chain.</p></div><div class="section" title="Making globez chains"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec18"/>Making globez chains</h2></div></div></div><p>The gameplay is simple: you have to <a id="id354" class="indexterm"/>connect as many globez you can, horizontally, vertically, or diagonally. And you can also backtrack.</p><p>Let's see how to <a id="id355" class="indexterm"/>connect globez. First, though, let me introduce you to a variable that will be very important in all your draw-to-match games: <code class="literal">tolerance</code>. Check the following code snippet:</p><div class="informalexample"><pre class="programlisting">var fieldSize = 6;
var tileTypes = ["red","green","blue","grey","yellow"];
var tileSize = 50;
var tileArray = [];
var globezLayer;
var visitedTiles = [];
var startColor = null;
<span class="strong"><strong>var tolerance = 400;</strong></span>
</pre></div><p>Have a look at the following screenshot:</p><div class="mediaobject"><img src="graphics/0075OS_09_5.jpg" alt="Making globez chains"/></div><p>Let's say the player wants to connect the three green globez, from bottom to top. When you draw with your finger on a small surface, say, your mobile phone, maybe in a train, you aren't this<a id="id356" class="indexterm"/> precise. So, on the left side, we can see what will happen if we detect player movement in a tile-based environment. The not-that-precise drawing would touch five different globez, resulting in an illegal move, which is frustrating. On the right side, using a tolerance, we only detect a player movement when next to the center of the tile. See the difference? The player only touches three globez, performing a legal move as required.</p><p>I called the square of the distance from the center—the radius of the inner white circles—<code class="literal">tolerance</code>, and in this case, I set it to <span class="emphasis"><em>20 pixels * 20 pixels = 400</em></span>.</p><p>We can say we have a legal move when:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are inside a tolerance area</li><li class="listitem" style="list-style-type: disc">The current globe hasn't already been picked—the <code class="literal">picked</code> attribute is <code class="literal">false</code></li><li class="listitem" style="list-style-type: disc">The current globe is adjacent to the last picked globe</li><li class="listitem" style="list-style-type: disc">The current globe has the same color as the first picked globe</li></ul></div><p>Translated into Cocos2d-JS, this means the <code class="literal">onMouseMove</code> function will contain:</p><div class="informalexample"><pre class="programlisting">onMouseMove: function(event){
  if(startColor!=null){
    var currentRow = Math.floor(event._y / tileSize);
    var currentCol = Math.floor(event._x / tileSize);
    var centerX = currentCol * tileSize + tileSize / 2;
    var centerY = currentRow * tileSize + tileSize / 2;
    var distX = event._x - centerX;
    var distY = event._y - centerY;
    if(distX * distX + distY * distY &lt; tolerance){
      if(!tileArray[currentRow][currentCol].picked){
        if(Math.abs(currentRow - visitedTiles[visitedTiles.length - 1].row) &lt;= 1 &amp;&amp; Math.abs(currentCol -visitedTiles[visitedTiles.length -1].col) &lt;= 1){
          if(tileArray[currentRow][currentCol].val==startColor){
            tileArray[currentRow][currentCol].setOpacity(128);
            tileArray[currentRow][currentCol].picked=true;
            visitedTiles.push({
              row:currentRow,
              col:currentCol
            });
          }
        }
      }
    }
  }
}</pre></div><p>It seems a lot of code but it's just the representation of the four conditions mentioned earlier. I would like to<a id="id357" class="indexterm"/> point out the following line to you:</p><div class="informalexample"><pre class="programlisting">if(distX * distX + distY * distY &lt; tolerance){ … }</pre></div><p>Here, I am applying the <a id="id358" class="indexterm"/>
<span class="strong"><strong>Pythagorean Theorem</strong></span> without using square roots, to save CPU time.</p><p>Test the script, and see what happens:</p><div class="mediaobject"><img src="graphics/0075OS_09_6.jpg" alt="Making globez chains"/></div><p>You are now able to select globez even if your drawing is a bit imprecise. Now, what if you change your mind and want to backtrack to try another route?</p></div><div class="section" title="Backtracking"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec19"/>Backtracking</h2></div></div></div><p>You can backtrack your <a id="id359" class="indexterm"/>selection when you move your mouse back to the second last globe. In this case, the last globe is removed from the <code class="literal">visitedTiles</code> array and both the <code class="literal">picked</code> <a id="id360" class="indexterm"/>attribute and the opacity are turned back to their default values: <code class="literal">true</code> and <code class="literal">255</code>, respectively.</p><p>To check for backtrack, you must check whether:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">We are inside a tolerance area</li><li class="listitem" style="list-style-type: disc">The current globe has already been picked—the <code class="literal">picked</code> attribute is <code class="literal">true</code></li><li class="listitem" style="list-style-type: disc">The current globe is the second last entry in the <code class="literal">visitedTiles</code> array</li></ul></div><p>This is just a minor change in the <code class="literal">onMouseMove</code> code:</p><div class="informalexample"><pre class="programlisting">onMouseMove: function(event){
  if(startColor!=null){
    // same as before
    if(distX * distX + distY * distY &lt; tolerance){
      if(!tileArray[currentRow][currentCol].picked){
        // same as before
      }
      <span class="strong"><strong>else{</strong></span>
        <span class="strong"><strong>if(visitedTiles.length&gt;=2 &amp;&amp; currentRow == visitedTiles[visitedTiles.length - 2].row &amp;&amp; currentCol == visitedTiles[visitedTiles.length - 2].col){</strong></span>
          <span class="strong"><strong>tileArray[visitedTiles[visitedTiles.length - 1].row][visitedTiles[visitedTiles.length - 1].col].setOpacity(255);</strong></span>
          <span class="strong"><strong>tileArray[visitedTiles[visitedTiles.length - 1].row][visitedTiles[visitedTiles.length - 1].col].picked=false;</strong></span>
          <span class="strong"><strong>visitedTiles.pop();</strong></span>
        <span class="strong"><strong>}</strong></span>
      }
    }
  }
}</pre></div><p>Test your game now, and try to backtrack. See the following screenshot:</p><div class="mediaobject"><img src="graphics/0075OS_09_7.jpg" alt="Backtracking"/></div><p>Do you see this? Now, you<a id="id361" class="indexterm"/> can change your mind and take another route.</p><p>Take a short break because it's not over yet, although we managed to completely handle player movements.</p></div><div class="section" title="Removing globez"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec20"/>Removing globez</h2></div></div></div><p>An ancient proverb says, <span class="emphasis"><em>it's not a match game if you can't remove items</em></span>. And, it's right! Once you select the globez, you must be able to remove them once you release the mouse.</p><p>Removing globez is very<a id="id362" class="indexterm"/> easy: once you know the <code class="literal">visitedTiles</code> array has at least three items, just remove<a id="id363" class="indexterm"/> those items from the stage and from the <code class="literal">tileArray</code> array.</p><p>Change <code class="literal">onMouseUp</code> this way:</p><div class="informalexample"><pre class="programlisting">onMouseUp: function(event){
  startColor=null;
  for(i = 0; i &lt; visitedTiles.length; i ++){
    <span class="strong"><strong>if(visitedTiles.length&lt;3){</strong></span>
      tileArray[visitedTiles[i].row][visitedTiles[i].col].setOpacity(255);
      tileArray[visitedTiles[i].row][visitedTiles[i].col].picked=false;
    }
    <span class="strong"><strong>else{</strong></span>
      <span class="strong"><strong>globezLayer.removeChild</strong></span>        <span class="strong"><strong>(tileArray[visitedTiles[i].row][visitedTiles[i].col]);</strong></span>
      <span class="strong"><strong>tileArray[visitedTiles[i].row][visitedTiles[i].col]=null;</strong></span>
    <span class="strong"><strong>}</strong></span>
  }
  visitedTiles = [];
}</pre></div><p>Setting removed globez with <code class="literal">null</code> in the <code class="literal">tileArray</code> array after having physically removed them from the stage with <code class="literal">removeChild</code> will be useful when we want to replenish the board.</p><p>Now, try the game:</p><div class="mediaobject"><img src="graphics/0075OS_09_8.jpg" alt="Removing globez"/></div><p>Did you see? We removed the globez. Now, the game is complete. Wait. No. Once you remove the globez, some globez have to fall down and more globez have to appear from the top of the screen to refill the stage. We will make them fall down gently using a tween.</p></div><div class="section" title="Making the globez fall down"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec21"/>Making the globez fall down</h2></div></div></div><p>Once you remove<a id="id364" class="indexterm"/> the globez, you will need to check whether there are globez with empty spaces below them, and make them fall down accordingly.</p><p>Remember, unlike<a id="id365" class="indexterm"/> most other languages, Cocos2d-JS sets the origin (0,0) coordinate at the bottom left of the stage, so the lowest row is row zero.</p><p>We need to heavily edit <code class="literal">onMouseUp</code>:</p><div class="informalexample"><pre class="programlisting">onMouseUp: function(event){
  startColor=null;
  for(i = 0; i &lt; visitedTiles.length; i ++){
    if(visitedTiles.length&lt;3){
      tileArray[visitedTiles[i].row][visitedTiles[i].col].setOpacity(255);
      tileArray[visitedTiles[i].row][visitedTiles[i].col].picked=false;
    }
    else{
      globezLayer.removeChild(tileArray[visitedTiles[i].row][visitedTiles[i].col]);
      tileArray[visitedTiles[i].row][visitedTiles[i].col]=null;
    }
  }
  <span class="strong"><strong>if(visitedTiles.length&gt;=3){</strong></span>
    <span class="strong"><strong>for(i = 1; i &lt; fieldSize; i ++){</strong></span>
      <span class="strong"><strong>for(j = 0; j &lt; fieldSize; j ++){</strong></span>
        <span class="strong"><strong>if(tileArray[i][j] != null){</strong></span>
          <span class="strong"><strong>var holesBelow = 0;</strong></span>
          <span class="strong"><strong>for(var k = i - 1; k &gt;= 0; k --){</strong></span>
            <span class="strong"><strong>if(tileArray[k][j] == null){</strong></span>
              <span class="strong"><strong>holesBelow++;</strong></span>
            <span class="strong"><strong>}</strong></span>
          <span class="strong"><strong>}</strong></span>
          <span class="strong"><strong>if(holesBelow&gt;0){</strong></span>
            <span class="strong"><strong>var moveAction = cc.MoveTo.create(0.5, new cc.Point(tileArray[i][j].x,tileArray[i][j].y-holesBelow*tileSize));</strong></span>
            <span class="strong"><strong>// cc,moveTo() can also be used</strong></span>
            <span class="strong"><strong>tileArray[i][j].runAction(moveAction);</strong></span>
            <span class="strong"><strong>tileArray[i - holesBelow][j] = tileArray[i][j];</strong></span>
            <span class="strong"><strong>tileArray[i][j] = null;</strong></span>
          <span class="strong"><strong>}</strong></span>
        <span class="strong"><strong>}</strong></span>
      <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>}</strong></span>
  <span class="strong"><strong>}</strong></span>
  visitedTiles = [];
}</pre></div><p>Run the script <a id="id366" class="indexterm"/>and see what happens:</p><div class="mediaobject"><img src="graphics/0075OS_09_9.jpg" alt="Making the globez fall down"/></div><p>Once green globez have been removed, the upper globez fall down.</p><p>Let's analyze the code a little:</p><div class="informalexample"><pre class="programlisting">if(visitedTiles.length&gt;=3){   </pre></div><p>Everything depends on whether we selected more than three globez. Otherwise, no globez will be removed, and there will be no need to check for empty spaces:</p><div class="informalexample"><pre class="programlisting">for(i = 1; i &lt; fieldSize; i ++){</pre></div><p>We start looping through all rows starting from <code class="literal">1</code>—the next-to-bottomt row—to row <code class="literal">fieldsize</code>-1, which<a id="id367" class="indexterm"/> is the topmost row.</p><div class="informalexample"><pre class="programlisting">for(j = 0; j &lt; fieldSize; j ++){</pre></div><p>We do the same thing for the columns but, this time, we scan them.</p><div class="informalexample"><pre class="programlisting">if(tileArray[i][j] != null){</pre></div><p>If in the given position we have a globe, it's time to count how many empty spaces we have below it.</p><div class="informalexample"><pre class="programlisting">var holesBelow = 0;</pre></div><p>The <code class="literal">holesBelow</code> variable will keep track of the empty spaces below a globe.</p><div class="informalexample"><pre class="programlisting">for(var k = i - 1; k &gt;= 0; k --){</pre></div><p>Starting from the current row and going down to the first, we have to count the empty spaces.</p><div class="informalexample"><pre class="programlisting">if(tileArray[k][j] == null){</pre></div><p>We find an empty space when its <code class="literal">tileArray</code> value is null.</p><div class="informalexample"><pre class="programlisting">holesBelow++;</pre></div><p>And, in this case, we increment the <code class="literal">holesBelow</code> variable:</p><div class="informalexample"><pre class="programlisting">if(holesBelow&gt;0){</pre></div><p>Once the loop has finished, we check whether there were holes below:</p><div class="informalexample"><pre class="programlisting">var moveAction = cc.MoveTo.create(0.5, new cc.Point(tileArray[i][j].x,tileArray[i][j].y-holesBelow*tileSize));
tileArray[i][j].runAction(moveAction);</pre></div><p>Then, move the globe accordingly.</p><div class="informalexample"><pre class="programlisting">tileArray[i - holesBelow][j] = tileArray[i][j];
tileArray[i][j] = null;</pre></div><p>Finally, we can update <code class="literal">tileArray</code> to register the new position of the globe.</p><p>Now that we <a id="id368" class="indexterm"/>managed to make the globez fall down, there is just one more thing to do—create new globes to fill the stage again.</p></div><div class="section" title="Creating new globez"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec22"/>Creating new globez</h2></div></div></div><p>Creating new globez shares the same<a id="id369" class="indexterm"/> concept as making the globez fall. For each column, we count the number of empty places; this number is the number of globez <a id="id370" class="indexterm"/>we have to create.</p><p>In order to create a smooth appearance, each globe will be created outside the top of the stage and an animation tween will place it in its right place.</p><p>This is the last time we need to modify <code class="literal">onMouseUp</code>, promise!</p><div class="informalexample"><pre class="programlisting">onMouseUp: function(event){
  // same as before
  if(visitedTiles.length&gt;=3){
    // same as before
    <span class="strong"><strong>for(i = 0; i &lt; fieldSize; i ++){</strong></span>
      <span class="strong"><strong>for(j = fieldSize-1; j&gt;=0; j --){</strong></span>
        <span class="strong"><strong>if(tileArray[j][i] != null){</strong></span>
          <span class="strong"><strong>break;</strong></span>
        <span class="strong"><strong>}</strong></span>
      <span class="strong"><strong>}</strong></span>
      <span class="strong"><strong>var missingGlobes = fieldSize-1-j;</strong></span>
      <span class="strong"><strong>if(missingGlobes&gt;0){</strong></span>
        <span class="strong"><strong>for(j=0;j&lt;missingGlobes;j++){</strong></span>
          <span class="strong"><strong>this.fallTile(fieldSize-j-1,i,missingGlobes-j)</strong></span>
        <span class="strong"><strong>}</strong></span>
      <span class="strong"><strong>}</strong></span>
    <span class="strong"><strong>}</strong></span>
  }
  visitedTiles = [];
}</pre></div><p>This is the part needed to scan for empty spaces and call the <code class="literal">fallTile</code> method to create a new tile with the destination row, destination column, and falling height. We use the falling height to <a id="id371" class="indexterm"/>create a smooth tween to the globe's final position.</p><p>Here's the definition for <code class="literal">fallTile</code>:</p><div class="informalexample"><pre class="programlisting">fallTile:function(row,col,height){
  var randomTile = Math.floor(Math.random()*tileTypes.length);
  var spriteFrame = cc.spriteFrameCache.getSpriteFrame(tileTypes[randomTile]);
  var sprite = cc.Sprite.createWithSpriteFrame(spriteFrame);
  sprite.val = randomTile;
  sprite.picked = false;
  globezLayer.addChild(sprite,0);
  sprite.setPosition(col*tileSize+tileSize/2,(fieldSize+height)*tileSize);
  var moveAction = cc.MoveTo.create(0.5, new cc.Point(col*tileSize+tileSize/2,row*tileSize+tileSize/2));
  sprite.runAction(moveAction);
  tileArray[row][col] = sprite;
}</pre></div><p>It's really similar to the <code class="literal">addTile</code> method created several pages ago—it was a long journey, wasn't it? And finally Globez is made:</p><div class="mediaobject"><img src="graphics/0075OS_09_10.jpg" alt="Creating new globez"/></div><p>Once you remove some globez, new ones will fall down from the top.</p></div><div class="section" title="Bonus – using the drawing API for a visual feedback"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec23"/>Bonus – using the drawing API for a visual feedback</h2></div></div></div><p>As promised, we will use<a id="id372" class="indexterm"/> the drawing API to provide a visual feedback of the path we are drawing with the mouse.</p><p>First, let's create a new global variable to<a id="id373" class="indexterm"/> store the layer where we will draw the player movement. It's called <code class="literal">arrowsLayer</code>:</p><div class="informalexample"><pre class="programlisting">var fieldSize = 6;
var tileTypes = ["red","green","blue","grey","yellow"];
var tileSize = 50;
var tileArray = [];
var globezLayer;
<span class="strong"><strong>var arrowsLayer;</strong></span>
var visitedTiles = [];
var startColor = null;
var tolerance = 400;</pre></div><p>We will create and add <code class="literal">arrowLayer</code> after <code class="literal">globezLayer</code> in the <code class="literal">init</code> function:</p><div class="informalexample"><pre class="programlisting">init:function () {
  this._super();
  cc.spriteFrameCache.addSpriteFrames("assets/globes.plist", "assets/globes.png");
  var backgroundLayer = cc.LayerGradient.create(cc.color(0x00,0x22,0x22,255), cc.color(0x22,0x00,0x44,255));
  this.addChild(backgroundLayer);
  globezLayer = cc.Layer.create();
  this.addChild(globezLayer)
  <span class="strong"><strong>arrowsLayer = cc.DrawNode.create();</strong></span>
  <span class="strong"><strong>// new cc.DrawNode() can also be used</strong></span>
  <span class="strong"><strong>this.addChild(arrowsLayer);</strong></span>
  this.createLevel();
  cc.eventManager.addListener(touchListener, this);
}</pre></div><p>The entity we can draw in is <code class="literal">DrawNode</code>.</p><p>No matter what<a id="id374" class="indexterm"/> happens, when we release the mouse, we will clear the draw area using the <code class="literal">clear</code> method:</p><div class="informalexample"><pre class="programlisting">onMouseUp: function(event){
  <span class="strong"><strong>arrowsLayer.clear();</strong></span>
  // same as before
}</pre></div><p>Now, we know how to clear a draw node and we have to see how to draw lines in it. Add a new method call when the player performs a legal move, no matter whether you're selecting a new globe or backtracking:</p><div class="informalexample"><pre class="programlisting">onMouseMove: function(event){
  if(startColor!=null){
    // same as before
    if(distX * distX + distY * distY &lt; tolerance){
      // same as before
      <span class="strong"><strong>this.drawPath();</strong></span>
    }
  }
}</pre></div><p>And now the only thing to do is the creation of <code class="literal">touchListener</code> listener's <code class="literal">drawPath</code> method:</p><div class="informalexample"><pre class="programlisting">drawPath:function(){
  arrowsLayer.clear();
  if(visitedTiles.length&gt;0){
    for(var i=1;i&lt;visitedTiles.length;i++){
      arrowsLayer.drawSegment(new cc.Point(visitedTiles[i-1].col*tileSize+tileSize/2,visitedTiles[i-1].row*tileSize+tileSize/2),new cc.Point(visitedTiles[i].col*tileSize+tileSize/2,visitedTiles[i].row*tileSize+tileSize/2), 4,cc.color(255, 255, 255, 255));
    }
  }
}</pre></div><p>As you can see, I loop through the <code class="literal">visitedTiles</code> array and use the <code class="literal">drawSegment</code> method to draw a segment from the first <code class="literal">cc.Point</code> argument to the second.</p><p>Finally, your game is <a id="id375" class="indexterm"/>completed. For real!!</p><div class="mediaobject"><img src="graphics/0075OS_09_11.jpg" alt="Bonus – using the drawing API for a visual feedback"/></div><p>Look how you can draw lines with the mouse, connecting the various globez you selected.</p></div></div></div>
<div class="section" title="Where to go now"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec61"/>Where to go now</h1></div></div></div><p>Normally, each chapter ends with a summary heading; anyway, this time I don't think you need a summary. I mean, you made several games, from a Concentration to Sokoban, from an endless runner to Globez.</p><p>First, I want to thank you for reading the entire book, and I hope you enjoyed reading it as much as I enjoyed writing it.</p><p>Although you created several games, this is just the beginning of a long journey into cross-platform game development.</p><p>First, you should complete the game by adding sounds, a scoring system, and some other features I am sure you know how to add, now that you are reading these final pages.</p><p>Then, I just want to point you to three sites you may find useful if you want to dive into cross-platform HTML5 development.</p><div class="section" title="Protect your code"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec24"/>Protect your code</h2></div></div></div><p>As your games were written in JavaScript, anyone can look at your code simply by directly looking at the HTML <a id="id376" class="indexterm"/>of your pages. There are several tools to obfuscate your code to make it unreadable—or at least to make life really hard for code lurkers. I selected two of them:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Javascript Obfuscator</strong></span> (<a class="ulink" href="http://javascriptobfuscator.com/">http://javascriptobfuscator.com/</a>): This is an online free<a id="id377" class="indexterm"/> tool to obfuscate your code; just copy-and-paste your code or upload small files and it does the hard work for you.</li><li class="listitem"><span class="strong"><strong>JScrambler</strong></span> (<a class="ulink" href="https://jscrambler.com">https://jscrambler.com</a>): This is the one I currently use and recommend. This <a id="id378" class="indexterm"/>allows you a lot of obfuscation levels, mobile gaming optimizations, site-locking, expiration dates, and many more. Just drag-and-drop your project and download the protected version.</li></ol></div></div><div class="section" title="Port your game on mobile devices as a native app"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec25"/>Port your game on mobile devices as a native app</h2></div></div></div><p>Once your game<a id="id379" class="indexterm"/> is running on each browser, you may be tempted to convert it into a native mobile app to try to conquer new markets. There are three awesome tools that allow you to create mobile apps starting from HTML, CSS, and JavaScript:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Cocos2D proprietary JSB API (<a class="ulink" href="http://www.cocos2d-x.org/wiki/Basic_usage_of_JSB_API">http://www.cocos2d-x.org/wiki/Basic_usage_of_JSB_API</a>): This is the<a id="id380" class="indexterm"/> official API to bind C++ to JavaScript. Starting<a id="id381" class="indexterm"/> from a Cocos2d-iphone or Cocos2d-x project, you can have all graphics, rendering, and physics code running natively with the game logic running JavaScript.</li><li class="listitem"><span class="strong"><strong>PhoneGap</strong></span> (<a class="ulink" href="http://phonegap.com/">http://phonegap.com/</a>): This application works both from your computer using native SDKs and from the cloud. PhoneGap compiles your HTML5 <a id="id382" class="indexterm"/>games, creating native apps ready to be published in markets such as Apple App Store. I used it to create the iOS version<a id="id383" class="indexterm"/> of BWBan (<a class="ulink" href="https://itunes.apple.com/us/app/bwban/id783208885?mt=8">https://itunes.apple.com/us/app/bwban/id783208885?mt=8</a>), starting from an HTML5 game.</li><li class="listitem"><span class="strong"><strong>CocoonJS</strong></span> (<a class="ulink" href="https://www.ludei.com/cocoonjs/">https://www.ludei.com/cocoonjs/</a>): This platform provides you with a platform<a id="id384" class="indexterm"/> to test, accelerate, deploy, and monetize your HTML5 apps and games on all mobile<a id="id385" class="indexterm"/> devices with many interesting features to help you deliver great web products faster.</li></ol></div></div><div class="section" title="Publishing your game"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec26"/>Publishing your game</h2></div></div></div><p>Making games is fun, but having people playing your games is even more fun. Here are the two top gaming<a id="id386" class="indexterm"/> portals where you should upload your games to receive plays, ratings, comments, and feedback:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>Newgrounds</strong></span> (<a class="ulink" href="http://www.newgrounds.com/">http://www.newgrounds.com/</a>): This web gaming portal has a collection of the best indie audios, web movies, and <a id="id387" class="indexterm"/>games made by <a id="id388" class="indexterm"/>developers all around the world.</li><li class="listitem"><span class="strong"><strong>Kongregate</strong></span> (<a class="ulink" href="http://www.kongregate.com/">http://www.kongregate.com/</a>): This is<a id="id389" class="indexterm"/> my favorite web <a id="id390" class="indexterm"/>gaming portal; it also offers an interesting revenue share.</li></ol></div></div><div class="section" title="Licensing your game"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec27"/>Licensing your game</h2></div></div></div><p>Game publishers are<a id="id391" class="indexterm"/> always looking for quality games and are willing to pay you to license them to use and customize your game. Unfortunately, it's not that easy to get in touch with them and get enough attention. Luckily, there's a service that does the hard job for you, showing your game to hundreds of potential buyers:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>FGL</strong></span> (<a class="ulink" href="https://www.fgl.com/">https://www.fgl.com/</a>): This is the industry's leading distribution and monetization <a id="id392" class="indexterm"/>services for HTML5, Android, iOS, Unity, and Flash. I got several sponsorships, thanks to FGL. I highly recommend working with them.</li></ol></div></div><div class="section" title="Staying up-to-date"><div class="titlepage"><div><div><h2 class="title"><a id="ch09lvl2sec28"/>Staying up-to-date</h2></div></div></div><p>The HTML5 gaming<a id="id393" class="indexterm"/> market is a new market changing almost daily. You will need to stay up-to-date to know news and trends. There's one forum I highly recommend:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem"><span class="strong"><strong>HTML5GameDevs</strong></span> (<a class="ulink" href="http://www.html5gamedevs.com/">http://www.html5gamedevs.com/</a>): This is the top HTML5 Game <a id="id394" class="indexterm"/>Dev forum with articles, game releases, frameworks, demos, videos, tutorials, blog posts, and more.</li></ol></div><p>And obviously, my blog, <a class="ulink" href="http://www.emanueleferonato.com/">http://www.emanueleferonato.com/</a>, is updated with almost daily news and tutorials.</p><p>Finally, you can refer to the official <a id="id395" class="indexterm"/>Cocos2d-JS site, <a class="ulink" href="http://www.cocos2d-x.org/wiki/Cocos2d-JS">http://www.cocos2d-x.org/wiki/Cocos2d-JS</a>, where you can find all new releases and under-development features.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch09lvl1sec62"/>Summary</h1></div></div></div><p>In this last chapter, you created a complete prototype of a Match-3 game using most of the features you learned during the reading of this book. Now, you should be able to create your own games starting from scratch, porting your ideas from pencil and paper to modern web browsers and mobile devices.</p></div></body></html>