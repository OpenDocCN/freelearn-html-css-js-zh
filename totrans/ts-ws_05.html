<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-93">4. <a id="_idTextAnchor107"/>Classes and Objects</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn how to define classes and instantiate them to create objects. You will also learn how to define the data types that can be passed to a class using interfaces. By the end of this chapter, you will be able to build a basic class that includes data attributes, a constructor, methods, and an interface. You will be able to <a id="_idTextAnchor108"/>create classes that take in multiple objects as arguments to build dynamic behavior and confidently use TypeScript to generate HTML code.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor109"/>Introduction</h1>
			<p><strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) has been around since the 1960s and many popular programming languages utilize it, including <strong class="bold">Java</strong>, <strong class="bold">Ruby</strong>, and <strong class="bold">Python</strong>. Prior to OOP, developers typically followed the procedural programming style. Languages that utilize procedural programming processes run from the top of the code file to the bottom. Eventually, developers started wanting to wrap entire processes and data so that they could be called from different parts of a program at different times. And that's how OOP was born.</p>
			<p>From a high-level perspective, OOP allows programs to wrap data and behavior together to create complete systems. So, instead of programs running code from top to bottom, as with procedural programs, OOP programs allow you to create code blueprints and establish rules for how a program will run, and then you can call those blueprints from other parts of an application.</p>
			<p>Don't worry if that doesn't make sense quite yet – we're going to walk through exactly how to work with OOP in TypeScript in this chapter. And we're going to start by learning about the fundamental building blocks of OOP – <strong class="bold">classes</strong> and <strong class="bold">objects</strong>.</p>
			<p>In the previous chapters, we've covered a wide assortment of topics, including various ways to declare variables, how to work with advanced types, aliases, union types, and assertions, and how to check for types. You've already added quite a bit of knowledge to your TypeScript skill set.</p>
			<p>In this chapter, we're going to build a scoreboard application in TypeScript and will be learning about classes and objects along the way. Do not worry if you have no previous knowledge or familiarity with OOP, or how it applies to TypeScript. If you have some experience with classes and objects, then you can skip ahead to some of the more advanced material later in the chapter – though you may still benefit from a refresher on these key concepts.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor110"/>What Are Classes and Objects?</h1>
			<p>Before we build out our class, let's take a step back and understand how classes work. You can think of a class as a blueprint. It establishes a structure for what we want to build and has some behavior inside it. Now, the class by itself does nothing. It is simply a blueprint. In order to work with it, we have to perform a process called <strong class="bold">instantiation</strong>.</p>
			<p>Instantiation is the process of taking a class and creating an actual object of the class that we can use. Let's walk through an example to understand instantiation further. Imagine that you're building a house and, like a good builder, you have a blueprint of what you want to build. That blueprint is like our class. The blueprint for a home is simply a set of rules, attributes, and behavior for a home. A blueprint for a house defines elements such as square footage, the number of rooms, the number of bathrooms, and where the plumbing goes. Technically, a blueprint is simply a set of rules that are printed out or stored on a computer; it's not the house itself, or the program itself, in this case. In order to create the house, someone needs to take the blueprint and then actually build the house, and it's the same in programming.</p>
			<p>A class by itself does nothing besides establishing the rules for the program. In order to work with the class, we need to create an instance or object of that class. So, returning to the building analogy, you can think of instantiation as taking the blueprint for the house and building it.</p>
			<p>Let's look at the following code snippet to understand how classes and objects appear in TypeScript:</p>
			<pre>class Person {
    name:string;
    constructor(name) {
        this.name = name;
    }
    read() {
        console.log(this.name+ "likes to read.");
    }
}
const obj = new Person("Mike");
obj.read();</pre>
			<p>Let's walk through each of the elements in the preceding code so that you can have a mental model of the key terminology associated with classes and objects in TypeScript, and then we'll go through an in-depth exercise where you will see how to work with each element:</p>
			<ul>
				<li><code>class Person {}</code> creates or defines a class.</li>
				<li><code>name: string;</code> creates the class attributes.</li>
				<li><code>constructor()</code> allows you to perform setup work for when an object is created.</li>
				<li><code>read()</code> is a method that allows you to implement custom behavior in a class.</li>
				<li><code>const obj = new Person("Mike");</code> creates an object from a class and stores it in a variable so that it can be used.</li>
				<li><code>obj.read();</code> calls a method on an object. In this example, it would console log out the value <code>Mike likes to read</code>.</li>
			</ul>
			<p>In the next section, we will solve an exercise wherein we'll be building our first TypeScript class.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor111"/>Exercise 4.01: Building Your First Class</h2>
			<p>In this exercise, we'll build a class named <code>Team</code> and add a behavior or method named <code>generateLineup</code> inside it. We'll also create an object of this class and access its method. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/UJXSY">https://packt.link/UJXSY</a>.</p>
			<ol>
				<li>Open the Visual Studio Code editor.</li>
				<li>Create a new directory and then a new file called <code>scoreboard.ts</code>. You will be running the TypeScript compiler on it to have it generate a JavaScript file as well. Add the following command in the TypeScript compiler to generate a JavaScript file:<pre>tsc scoreboard.ts</pre><p>Once this command is executed, a <code>scoreboard.js</code> file is generated, as you can see in the following screenshot:</p><div><img src="img/B14508_04_01.jpg" alt="Figure 4.1: TypeScript scoreboard and generated JavaScript files&#13;&#10;"/></div><p class="figure-caption">Figure 4.1: TypeScript scoreboard and generated JavaScript files</p></li>
				<li>Now, create a class called <code>Team</code>, and then utilize the instantiation process to create an object of that class. Write the following code inside the <code>scoreboard.ts</code> file to create a class:<pre>class Team {
}</pre><p>Right now, this is simply an empty class that doesn't do anything. Let's fix that by adding some behavior to the class. We can add behavior by defining functions. For our <code>Team</code> class, we're going to generate a lineup, so we define a function called <code>generateLineup</code>, and it doesn't take in any arguments.</p><p class="callout-heading">Note</p><p class="callout">From a syntax perspective, notice that we're using the <code>class</code> keyword. The term<code> class </code>is a reserved word in TypeScript and JavaScript, and it tells the compiler that we're about to define a class. In this case, we're calling the <code>Team</code> class. </p></li>
				<li>Write the following code to define a <code>generateLineup()</code> function inside the class:<pre>class Team {
    generateLineup() {
        return "Lineup will go here…";
    }
}</pre><p>As you can see, functions in classes, which are also referred to as methods, look similar in syntax to standard functions in JavaScript. Now, our <code>generateLineup</code> method simply returns a string. Later in the chapter, we'll see how we can implement dynamic behavior in this method.</p><p>Once we've created a class and defined its behavior, we can create an object. In order to create an object of the <code>Team</code> class, we call the <code>new</code> keyword in front of the <code>Team</code> class name and assign that to a variable. In this case, we'll store the instantiated object in a variable called <code>astros</code>.</p></li>
				<li>Add the following code to create an object of the <code>Team</code> class:<pre>const astros = new Team();</pre><p>Notice that in the preceding code, we're also adding parentheses after the <code>Team</code> class name, mimicking how we call functions in TypeScript. </p><p>With all of this in place, we can now use the <code>astros</code> variable to call the <code>generateLineup</code> method on it. </p></li>
				<li>Add the following code to call the <code>generateLineup</code> method:<pre>console.log(astros.generateLineup());</pre></li>
				<li>In the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc scoreboard.ts
node scoreboard.js</pre><p>Once we run the preceding commands, the following output is displayed in the terminal: <code>Lineup will go here…</code></p></li>
			</ol>
			<p>Hence, we've created our first class, and then from there, we've taken that class, that blueprint, and then used instantiation to create an object. From that point, we're able to call the method inside the class. Now that we've created a class and used its object to access its methods, in the next section, we'll explore the concept of the <strong class="bold">constructor</strong>.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor112"/>Extending Class Behavior with a Constructor</h2>
			<p>In the previous section, we established the syntax for classes in TypeScript. Before we get started with the next phase of the previous program, let's take a step back and discuss an element that we're going to use, called the constructor. The concept of constructors can be confusing if you've never used them before. </p>
			<p>Returning to our blueprint/house analogy, if a class is like a home's blueprint and an object is the home that is created, the constructor is the process of going to the hardware shop and purchasing the materials needed to build the home. A constructor is run automatically anytime that you create an object. Typically, constructors are used to do the following:</p>
			<ul>
				<li>Set data for attributes, which we're about to explore.</li>
				<li>Run any setup processes. Examples of this include calling outside APIs to get data and communicating with a database.<p class="callout-heading">Note</p><p class="callout">More on constructors will be covered in <em class="italic">Chapter 8</em>, <em class="italic">Dependency Injection in TypeScript</em>.</p></li>
			</ul>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor113"/>The this Keyword</h2>
			<p>The concept of <code>this</code> keyword refers to the instance of the class that is currently being executed. It has access to the data and behavior of the created object. Let's say we have the following code within a class:</p>
			<pre>constructor(name){
    this.name = name;
}</pre>
			<p>In the preceding code, if <code>this.name</code> is referring to the instance of the class and the attribute of <code>name</code>, what does the <code>name</code> parameter in the constructor represent? In order to use data in our class, we need to have a mechanism for passing data into the object, and that's what the constructor parameters are doing. So, why do we need to assign <code>this.name</code> to <code>name</code>? It does seem redundant; however, it is helpful for understanding how variable scope works in TypeScript classes. We need to assign the values passed into the object to <code>this.attributeName</code> so that the other methods in the class can have access to the values. If we simply passed the value into the constructor and didn't perform the <code>this.name</code> assignment, the other methods in the class wouldn't have access to the <code>name</code> value. Now, let's extend the behavior of the program in the next exercise, where we will explore the attributes of the class.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor114"/>Exercise 4.02: Defining and Accessing the Attributes of a Class</h2>
			<p>In this exercise, we'll add attributes to the <code>Team</code> class, which we created in the previous exercise. We'll be using constructors to define and access the attributes of the objects. Perform the following steps to implement this exercise.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this exercise, we'll continue the work we performed earlier in the chapter with our <code>Team</code> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/Diuyl">https://packt.link/Diuyl</a>.</p>
			<p>We begin by listing the names of the attributes at the top of the <code>Team</code> class and then we set the value with a <code>constructor</code> function by passing in a <code>name</code> parameter. From there, we set the value of <code>this.name</code> to the value that gets passed into the <code>constructor</code> function: </p>
			<ol>
				<li value="1">Write the following code to create a <code>constructor</code> function:<pre>class Team {
    name: string;
    constructor(name) {
      this.name = name;
    }
    generateLineup() {
      return "Lineup will go here …";
    }
}</pre><p>When we create the <code>astros</code> object, the <code>this</code> keyword represents the object that was created. </p></li>
				<li>Create another object to see how the <code>this</code> keyword works with multiple objects. Add the following code to the <code>scoreboard.ts</code> file to create objects of the <code>Team</code> class:<pre>const astros = new Team();
console.log(astros.generatLineup());
const bluJays = new Team();
console.log(blueJays.generateLineup());</pre><p>In the preceding code, we've created another <code>Team</code> class object called <code>blueJays</code>. From there, we called the <code>generateLineup</code> method on the object. When we say <code>this.name</code>, what we're referring to is the instance of the class. This means that when we say <code>this.name</code> for the first object, we're referring to the <code>astros</code> object. And then, for the new object we've created, <code>this.name</code> is referencing the <code>blueJays</code> object.</p><p>Our <code>generateLineup</code> method has access to the value of <code>name</code> because we assigned it in the constructor. </p></li>
				<li>Pass values to the constructors of both the objects by writing the following code:<pre>const astros = new Team("Astros");
console.log(astros.generateLineup());
const blueJays = new Team("Blue Jays");
console.log(blueJays.generateLineup());</pre><p class="callout-heading">Note</p><p class="callout">If you ever get asked the difference between parameters and arguments in TypeScript, parameters are what you place inside the function's declarations in your class. Arguments are what you pass to an object or a function.</p><p>In order to pass arguments to a class, you can pass them in the same way that you do with functions, as you can see above. Additionally, when we perform an assignment such as <code>this.name = name</code>, this means that when an object is created, it can call the data value as well. </p></li>
				<li>Write the following code to call the relevant data values:<pre>const astros = new Team("Astros");
//console.log(astros.generateLineup());
console.log(astros.name);
const blueJays = new Team("Blue Jays");
//console.log(blueJays.generateLineup());
console.log(blueJays.name);</pre></li>
				<li>In the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc scoreboard.ts
node scoreboard.js</pre><p>Once we run the preceding commands, the following output is displayed in the terminal: </p><pre>Astros
Blue Jays</pre></li>
			</ol>
			<p>As you can see in the code in the previous step, when we call <code>astros.name</code>, this outputs the name value that was passed into the instantiated object. When we pass the name value <code>Blue Jays</code> into the new object, the new value is printed in the terminal. </p>
			<p>We are now able to understand the basic workings of classes and objects. We've also learned how to pass data into an object via a constructor. Now it's time to extend that knowledge and see how we can integrate types directly into our classes.</p>
			<p>Even though the current implementation works, we're not taking advantage of the key benefits that TypeScript offers. In fact, the current implementation is very close to how you would build a class in vanilla JavaScript. By using types in classes, we can define exactly how to work with the code, which will help to make our code more manageable and scalable.</p>
			<p>A real-world example of this would be a React application that utilizes TypeScript versus vanilla JavaScript. One of the most common errors that developers run into is passing the wrong type of data to a class or method, resulting in an error for the user. Imagine accidentally passing a string to a class that requires an array. When the user tries to access the page that is associated with that class, they won't see any data, as the wrong data was passed to the method.</p>
			<p>When you utilize TypeScript and types in a React class, the text editor won't allow the program to even compile as it will explain to you exactly what type of data is required by each class and process. In the next section, we'll solve an exercise wherein we'll integrate different types into our class.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor115"/>Exercise 4.03: Integrating Types into Classes</h2>
			<p>In this exercise, we'll add another attribute named <code>players</code> inside our <code>Team</code> class. This parameter takes arrays of strings. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We'll continue the work we performed in the previous exercise with our <code>Team</code> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/tbav7">https://packt.link/tbav7</a>.</p>
			<ol>
				<li value="1">Open the <code>scoreboard.ts</code> file.</li>
				<li>Inside the <code>Team</code> class, declare another attribute named <code>players</code>, which takes arrays of strings. Write the following code to declare the <code>string</code> array:<pre>players: string[]; </pre></li>
				<li>Update the <code>constructor</code> function by adding the <code>name</code> and <code>players</code> parameters. Set the values of the <code>name</code> and <code>players</code> parameters to <code>this.name</code> and <code>this.players</code>, respectively. Write the following code to update our <code>constructor</code> function:<pre>constructor(name, players){
    this.name = name;
    this.players = players;
}</pre></li>
				<li>Update the <code>generateLineup()</code> method so that it joins the player names that will get passed into the object. This method will return a plain string. Here is the updated code of the <code>generateLineup()</code> method:<pre>generateLineup(){
    return this.players.join(", ");
}</pre></li>
				<li>Create two arrays of players, namely, <code>astrosPlayers</code> and <code>blueJaysPlayers</code>. Assign four player names to each array and pass those arrays as second arguments to the <code>Team</code> class objects. Write the following code to accomplish this:<pre>const astrosPlayers = ["Altuve", "Bregman", "Correa", "Springer"];
const astros = new Team("Astros", astrosPlayers);
console.log(astros.generateLineup());
console.log(astros.name);
const blueJaysPlayers = ["Vlad", "Smoak", "Tellez", "Sogard"];
const blueJays = new Team("Blue Jays", blueJaysPlayers);
console.log(blueJays.generateLineup());
console.log(blueJays.name);</pre></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc scoreboard.ts
node scoreboard.js</pre><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><pre>Altuve, Bregman, Correa, Springer
Astros
Vlad, Smoak, Tellez, Sogard
Blue Jays</pre></li>
			</ol>
			<p>We've now integrated types into our <code>Team</code> class. If you're able to view the names that you passed to the class in the console, this means that you're working with the class and their types properly. In the next section, we'll learn why <strong class="bold">interfaces</strong> are needed and how they are useful.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor116"/>TypeScript Interfaces</h1>
			<p>We'll go through a deep dive into TypeScript interfaces in the next chapter. But for now, just know that an interface allows you to describe the data passed to a class when you're creating an object. In the previous exercise code, if we hover over the <code>Team</code> class on Visual Studio Code, we get the following message:</p>
			<div><div><img src="img/B14508_04_02.jpg" alt="Figure 4.2: Vague IntelliSense guidance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2: Vague IntelliSense guidance</p>
			<p>As you can see in the preceding screenshot, the Visual Studio Code editor's IntelliSense is saying that the <code>players</code> parameter uses the <code>any</code> data type. It's not giving us any usage hints here, and this starts to speak to the reason why we need interfaces, because right now, the <code>players</code> array could be anything. It could be a string, it could be an object, and so on. This is essentially breaking one of the main benefits of using TypeScript in the first place. Ideally, our programs should be declarative to the point that we know exactly what type of data should be passed to our functions and classes. We're going to leverage interfaces in order to do that. The way you define an interface is by starting with the <code>interface</code> keyword followed by the name of the interface. The common convention in the TypeScript community is to start with a capital <code>I</code>, followed by whatever class you're building the interface for. </p>
			<p>Once we have created the interface and update the constructor, we'll establish a way of defining our arguments and our types. This will break any of the previously created objects with the old argument syntax since the previous arguments no longer match up with our new interface. In the next section, we'll complete an exercise wherein we'll build an interface.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor117"/>Exercise 4.04: Building an Interface</h2>
			<p>In this exercise, we'll build an interface and set the types of data that need to be passed to our functions and classes. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We'll continue the work we performed in the previous exercise with our <code>Team</code> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/FWUA6">https://packt.link/FWUA6</a>.</p>
			<ol>
				<li value="1">Open the <code>scoreboard.ts</code> file.</li>
				<li>Create an interface named <code>ITeam</code> and list out the attributes and data types with the same key/value syntax that you would use with an object. Write the following code to create an interface:<pre>interface ITeam{
    name: string;
    players: string[];
}</pre></li>
				<li>Inside our <code>Team</code> class, alter the parameter list in the <code>constructor</code> function so that the data is passed in as a single object that is of the <code>ITeam</code> type. Write the following code to accomplish this:<pre>constructor(args: ITeam){
    this.name = args.name;
    this.players = args.players;
}</pre><p>Notice in the preceding code that, instead of listing out each of the parameters separately, we're declaring the exact structure that is needed for a <code>Team</code> object to be created. From that point, we're calling the <code>name</code> and <code>players</code> values from the <code>args</code> parameter since our parameter list has now been refactored to use a single argument.</p></li>
				<li>Create an object of the <code>Team</code> class by writing the following code:<pre>const astros = new Team();</pre><p>Now notice what happens when we hover over the parentheses. It says that it expected one argument but got zero. Look at the following screenshot to view the message:</p><div><img src="img/B14508_04_03.jpg" alt="Figure 4.3: IntelliSense listing out the arguments needed by the class&#13;&#10;"/></div><p class="figure-caption">Figure 4.3: IntelliSense listing out the arguments needed by the class</p></li>
				<li>Let's update how we create the objects. Start typing in the <code>name</code> attribute. Write the following code to create the object:<pre>const astros = new Team({
    name
})</pre><p>After adding in the <code>name</code> argument, we'll see the following error:</p><div><img src="img/B14508_04_04.jpg" alt="Figure 4.4: IntelliSense describing the data types needed to create the object&#13;&#10;"/></div><p class="figure-caption">Figure 4.4: IntelliSense describing the data types needed to create the object</p><p>If you hover over the <code>name</code> attribute, you can see that TypeScript is helping us understand the other arguments we need to pass in, because the <code>players</code> property is missing. So, this is already giving us so much more information on how our class needs to work.</p></li>
				<li>Now, pass the values for both the attributes, <code>name</code> and <code>players</code>, and update the values for both the objects, <code>astros</code> and <code>blueJays</code>. Write the following code to accomplish this:<pre>const astrosPlayers = ["Altuve", "Bregman", "Correa", "Springer"];
const astros = new Team({
    name: "Astros",
    players: astrosPlayers
});
console.log(astros.generateLineup());
console.log(astros.name);
const blueJaysPlayers = ["Vlad", "Smoak", "Tellez", "Sogard"];
const blueJays = new Team({
    name: "Blue Jays",
    players: blueJaysPlayers
});
console.log(blueJays.generateLineup());
console.log(blueJays.name);</pre></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc scoreboard.ts
node scoreboard.js</pre><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><pre>Altuve, Bregman, Correa, Springer
Astros
Vlad, Smoak, Tellez, Sogard
Blue Jays</pre></li>
			</ol>
			<p>We've now built an interface and set the types of data that need to be passed to our functions and classes. Although we got the same output as we got in the previous exercise, we are now aware of what type of data needs to be passed to our functions and classes.</p>
			<p>Another great benefit of using interfaces and object-based arguments with classes is that the arguments do not have to be in a specific order. You can pass in the keys in any order that you want, and the class can still parse them properly. If you use standard parameter names, you'll always need to know the order to pass arguments to the class and function.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor118"/>Generating HTML Code in Methods</h1>
			<p>Now that we have learned how to build an interface and have the ability to pass data, along with having some help from IntelliSense in knowing the types of data that we're passing in, we can actually generate some HTML. It's fun to see the code we write generate its own code. Part of the reason why we chose to include this example is that this is very close to the same type of process that you will be using when building React JS or Angular applications. At their very core, the goal of a standard React app is to leverage JavaScript/TypeScript code to render HTML code that can be rendered to the user.</p>
			<p>In the next section, we'll complete an exercise wherein we generate HTML code and view it in the browser.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor119"/>Exercise 4.05: Generating and Viewing HTML Code</h2>
			<p>In this exercise, we will generate some HTML by cleaning up some of the code. We'll get rid of the <code>name</code> attribute and the interface. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We'll continue the work we performed in the previous exercise with our <code>Team</code> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/Bz5LV">https://packt.link/Bz5LV</a>.</p>
			<ol>
				<li value="1">Open the <code>scoreboard.ts</code> file.</li>
				<li>Inside the <code>Team</code> class, declare the <code>players</code> array and create a <code>constructor</code> function. Write the following code to implement this:<pre>players: string[];
constructor(players){
    this.players = players;
}</pre></li>
				<li>Update the <code>generateLineup()</code> function by writing the following code:<pre>generateLineup(): string{
    <a id="_idTextAnchor120"/>const playersWithOrderNumber = 
      this.players.map((player, idx) =&gt; {
        return `&lt;div&gt;${idx + 1} - ${player}&lt;/div&gt;`;
    });
    return playersWithOrderNumber.join("");
}</pre><p>The <code>map</code> function is a helpful iterator tool that loops over the player array. You can pass it as a function that performs some type of operation. In the preceding code, the line <code>`&lt;div&gt;${idx + 1} – ${player}&lt;/div&gt;`</code> states that in every iteration, each player's data is wrapped inside the HTML code. Also, each element that is returned is stored in a new array, <code>playersWithOrderNumber</code>.</p><p class="callout-heading">Note</p><p class="callout">Notice the return type that we've declared for the <code>generateLineup</code> method. This means that we're telling the TypeScript compiler that the method will always return a string value. The reason why this is so important is that if any other part of the application calls this method and tries to perform a task that does not work with the string data type, they'll get a clear error and recommendation on how to fix it.</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc scoreboard.ts
node scoreboard.js</pre><p>Once we have run the preceding commands, the following output is displayed in the terminal:</p><div><img src="img/B14508_04_05.jpg" alt="Figure 4.5: Output showing the lineup of players for both teams&#13;&#10;"/></div><p class="figure-caption">Figure 4.5: Output showing the lineup of players for both teams</p><p>In the preceding output, you'll see that we're getting HTML returned that prints out the lineup of players for both teams. </p><p>But let's not stop here. Let's see what this looks like in the browser. </p></li>
				<li>Save the generated code in an HTML file named <code>index.html</code> and view it in the browser. The following output will be displayed in the browser:<div><img src="img/B14508_04_06.jpg" alt="Figure 4.6: Viewing the generated HTML code in the browser&#13;&#10;"/></div><p> </p></li>
			</ol>
			<p class="figure-caption">Figure 4.6: Viewing the generated HTML code in the browser</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may get a different image depending on your default browser; however, the text displayed will be the same as listed in the preceding screenshot.</p>
			<p>You can see that we have a full lineup of players for both teams. However, we have not yet formatted the text on the page, and so it is difficult to ascertain the teams to which the players belong unless you have access to the code. We will be enhancing this page with more information and formatting as we progress in this chapter.</p>
			<p>Note that we can pass the objects themselves to another class that will put them together for us and generate a full scoreboard. In the next section, we'll learn how to work with multiple classes and objects.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor121"/>Working with Multiple Classes and Objects</h2>
			<p>In this section, we're going to learn how to create a class that combines other classes to give us more advanced behavior. The reason why this is an important concept to understand is that you will need to implement this type of behavior in many different types of applications. For example, if you are building a contact form in a React application, you might need to have classes for an API, form elements, form validations, and other form features all working together. In the next section, we will look at an exercise where we'll combine classes.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor122"/>Exercise 4.06: Combining Classes</h2>
			<p>In this exercise, we will be creating a <code>scoreboard</code> class that will allow us to pass in objects and work with their data and behavior. This will allow us to take instantiated objects that were created from other classes such as our <code>Team</code> class. Then, we're going to add in some other behavior that will generate a full scoreboard that shows off both the lineups along with the data. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We'll continue the work we performed in the previous exercise with our <code>Team</code> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/UY5NP">https://packt.link/UY5NP</a>.</p>
			<ol>
				<li value="1">Open the <code>scoreboard.ts</code> file.</li>
				<li>Create a <code>Scoreboard</code> class and list three attributes, namely, <code>homeTeam</code>, <code>awayTeam</code>, and <code>date</code>. Here, <code>homeTeam</code> and <code>awayTeam</code> will be of the <code>Team</code> type, and <code>date</code> will be of the <code>string</code> type. Write the following code to accomplish this:<pre>class Scoreboard{
    homeTeam: Team;
    awayTeam: Team;
    date: string;
}</pre><p>In the preceding code, notice how we were able to call the <code>Team</code> class. This is because when we create a class, we're able to treat that class like a type in TypeScript. So, TypeScript now knows that our <code>homeTeam</code> and <code>awayTeam</code> data attributes must be a <code>Team</code> object. The <code>date</code> attribute will represent the date of the scoreboard. If we tried to pass in <code>string</code>, <code>array</code>, or anything else for a <code>Team</code> object, the program would not compile.</p></li>
				<li>Now that we know the type of data that our scoreboard needs to have, let's create an interface for it. Write the following code to create an interface:<pre>interface IScoreboard{
    homeTeam: Team;
    awayTeam: Team;
    date: string;
}</pre><p>This is similar to what we implemented with the <code>ITeam</code> interface, but with a nice twist. Because our <code>homeTeam</code> and <code>awayTeam</code> attributes are not associated with a basic data type such as <code>string</code> or <code>number</code>, we're letting the interface know that these values are required to be objects of the <code>Team</code> class.</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc scoreboard.ts</pre><p>When the preceding command is executed, the <code>scoreboard.js</code> file is created.</p></li>
				<li>Open the <code>scoreboard.js</code> file and you'll see the following code at the beginning:<div><img src="img/B14508_04_07.jpg" alt="Figure 4.7: Generated JavaScript that shows interfaces are only used by the text editor&#13;&#10;"/></div><p class="figure-caption">Figure 4.7: Generated JavaScript that shows interfaces are only used by the text editor</p><p>In the preceding screenshot, what we're essentially doing here is almost like a mini declaration file for this class. We're defining the shape of the class. If you remember, those interfaces and those declaration files do not get compiled down into JavaScript. You can confirm this by looking at the generated JavaScript code in the preceding screenshot.</p><p>Now that we've defined the interface, we have essentially defined the shape of our <code>Scoreboard</code> class.</p></li>
				<li>Now we implement a <code>constructor</code> function, allowing the <code>Scoreboard</code> class to know what parameters to expect when creating a new object. Write the following code to accomplish this:<pre>constructor(args: IScoreboard){
    this.homeTeam = args.homeTeam;
    this.awayTeam = args.awayTeam;
    this.date = args.date;
}</pre><p>With this in place, any functions inside our <code>Scoreboard</code> class can work with these values.</p></li>
				<li>Now let's create a function called <code>scoreboardHtml()</code> inside the <code>Scoreboard</code> class. Write the following code to accomplish this:<pre>scoreboardHtml(): string{
    return `
    &lt;h1&gt;${this.date}&lt;/h1&gt;
    &lt;h2&gt;${this.homeTeam.name}&lt;/h2&gt;
    &lt;div&gt;${this.homeTeam.generateLineup()}&lt;/div&gt;
    &lt;h2&gt;${this.awayTeam.name}&lt;/h2&gt;
    &lt;div&gt;${this.awayTeam.generateLineup()}&lt;/div&gt;
    `;
}</pre><p>In the preceding code, we have an <code>&lt;h1&gt;</code> heading tag for <code>date</code> and an <code>&lt;h2&gt;</code> heading tag wrapping the team names. This is great, as even though the <code>Scoreboard</code> class has no knowledge of the <code>Team</code> class, the IDE can let us know that we have access to the name value. Lastly, we're able to call the <code>Team</code> functions. So, inside the <code>&lt;div&gt;</code> tags wrapper, we're calling the <code>generateLineup()</code> function of <code>Team</code>, which we know from earlier returns a list of HTML elements. Also, notice that this function will always return a string and that we're using backticks so that we can use string literals, which can be dynamic.</p><p class="callout-heading">Note</p><p class="callout">In TypeScript and JavaScript, string literals can be written on multiple lines, which is not allowed with quotation marks.</p></li>
				<li>Update the <code>Team</code> class with the <code>name</code> attribute and <code>constructor</code> function. Write the following code to accomplish this:<pre>name: string;
players: string[];
constructor(name, players){
    this.name = name;
    this.players = players;
}</pre></li>
				<li>To view the final scoreboard, first create two team objects followed by the <code>Scoreboard</code> class object, and then pass in dates and both of our team objects to it. Write the following code to accomplish this:<pre>const astrosPlayers = ["Altuve", "Bregman", "Correa", "Springer"];
const astros = new Team("Astros", astrosPlayers);
//console.log(astros.generateLineup());
const blueJaysPlayers = ["Vlad", "Smoak", "Tellez", "Sogard"];
const blueJays = new Team("Blue Jays", blueJaysPlayers);
//console.log(blueJays.generateLineup());
const todaysGame = new Scoreboard({
    date: "5/24/19",
    homeTeam: astros,
    awayTeam: blueJays
});
console.log(todaysGame.scoreboardHtml());</pre></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<pre>tsc scoreboard.ts
node scoreboard.js</pre><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><div><img src="img/B14508_04_08.jpg" alt="Figure 4.8: Generated HTML code&#13;&#10;"/></div><p class="figure-caption">Figure 4.8: Generated HTML code</p></li>
				<li>Add this code to an HTML file and view it in the browser. You will see that we have a full scoreboard like the one shown in the following screenshot:<div><img src="img/B14508_04_09.jpg" alt="Figure 4.9: Generated code in the browser&#13;&#10;"/></div><p> </p></li>
			</ol>
			<p class="figure-caption">Figure 4.9: Generated code in the browser</p>
			<p>Finally, we combined two classes, namely, <code>Scoreboard</code> and <code>Team</code>. In the <code>Scoreboard</code> class, we created attributes of the <code>Team</code> type and added a few behaviors that will help to generate a full scoreboard consisting of the lineups of both teams. </p>
			<p>So far, we've introduced classes and objects in TypeScript, and with this knowledge, we're ready to move on to the code activity in the next section, where we will create a user model.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor123"/>Activity 4.01: Creating a User Model Using Classes, Objects, and Interfaces</h2>
			<p>In this activity, you will build a user authentication system that mimics how a TypeScript application would pass login data to a backend API to register and sign users into our baseball scorecard application. This will entail building multiple TypeScript classes and combining classes and objects together to mimic an authentication feature. Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">Visit the GitHub repository and download the activity project containing the specs and configuration elements: <a href="https://packt.link/vJxBm">https://packt.link/vJxBm</a>.</li>
				<li>Open the Visual Studio Code editor.</li>
				<li>Create a file called <code>auth.ts</code>.</li>
				<li>Run the TypeScript compiler on the file and watch for changes.</li>
				<li>Create a <code>Login</code> class that takes in an object containing the string attributes of <code>email</code> and <code>password</code>.</li>
				<li>Build an interface called <code>ILogin</code> that defines the <code>email</code> and <code>password</code> attributes.</li>
				<li>Pass it as a parameter to the <code>constructor</code> function.</li>
				<li>Create an <code>Auth</code> class that takes in an object containing the attributes of <code>user</code> and <code>source</code>.</li>
				<li>Build an interface called <code>IAuth</code> that defines the <code>user</code> and <code>source</code> attributes and pass it as the <code>constructor</code> function parameter. Have the <code>user</code> attribute be of the <code>Login</code> type and the <code>source</code> attribute of the <code>string</code> type.</li>
				<li>Add a <code>validUser()</code> method to the <code>Auth</code> class that returns <code>true</code> if <code>email</code> is equal to <code>admin@example.com</code> and if <code>password</code> is equal to <code>secret123</code>. </li>
				<li>Ensure that you can access the <code>source</code> attribute from the instantiated <code>Auth</code> object and that it's a string.</li>
				<li>Test the user model by first checking a valid user and then an invalid user.<p>The expected output should look something like this:</p><pre>Validating user...User is authenticated: true
Validating user...User is authenticated: false</pre><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor399">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor124"/>Summary</h1>
			<p>Learning OOP development patterns for the first time can be a challenging task. In this chapter, you learned about OOP development, how to define classes in TypeScript, how to instantiate classes and create objects, how to combine data and methods in a class to encapsulate a full set of behavior, how to utilize interfaces in order to define the data that can be passed to a TypeScript class, and finally, how to pass the objects to classes of various types.</p>
			<p>You also now have a basic understanding of how an authentication system works and how to utilize TypeScript to generate HTML code.</p>
			<p>Now that you have a basic understanding of how classes and objects work in TypeScript, in the next chapter, you'll learn how to work with the concept of class inheritance and take a deeper dive into interfaces.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>