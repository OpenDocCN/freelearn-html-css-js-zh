<html><head></head><body>
		<div>
			<div id="_idContainer062" class="Content">
			</div>
		</div>
		<div id="_idContainer063" class="Content">
			<h1 id="_idParaDest-93">4. <a id="_idTextAnchor107"/>Classes and Objects</h1>
		</div>
		<div id="_idContainer073" class="Content">
			<p class="callout-heading">Overview</p>
			<p class="callout">In this chapter, you will learn how to define classes and instantiate them to create objects. You will also learn how to define the data types that can be passed to a class using interfaces. By the end of this chapter, you will be able to build a basic class that includes data attributes, a constructor, methods, and an interface. You will be able to <a id="_idTextAnchor108"/>create classes that take in multiple objects as arguments to build dynamic behavior and confidently use TypeScript to generate HTML code.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor109"/>Introduction</h1>
			<p><strong class="bold">Object-Oriented Programming</strong> (<strong class="bold">OOP</strong>) has been around since the 1960s and many popular programming languages utilize it, including <strong class="bold">Java</strong>, <strong class="bold">Ruby</strong>, and <strong class="bold">Python</strong>. Prior to OOP, developers typically followed the procedural programming style. Languages that utilize procedural programming processes run from the top of the code file to the bottom. Eventually, developers started wanting to wrap entire processes and data so that they could be called from different parts of a program at different times. And that's how OOP was born.</p>
			<p>From a high-level perspective, OOP allows programs to wrap data and behavior together to create complete systems. So, instead of programs running code from top to bottom, as with procedural programs, OOP programs allow you to create code blueprints and establish rules for how a program will run, and then you can call those blueprints from other parts of an application.</p>
			<p>Don't worry if that doesn't make sense quite yet – we're going to walk through exactly how to work with OOP in TypeScript in this chapter. And we're going to start by learning about the fundamental building blocks of OOP – <strong class="bold">classes</strong> and <strong class="bold">objects</strong>.</p>
			<p>In the previous chapters, we've covered a wide assortment of topics, including various ways to declare variables, how to work with advanced types, aliases, union types, and assertions, and how to check for types. You've already added quite a bit of knowledge to your TypeScript skill set.</p>
			<p>In this chapter, we're going to build a scoreboard application in TypeScript and will be learning about classes and objects along the way. Do not worry if you have no previous knowledge or familiarity with OOP, or how it applies to TypeScript. If you have some experience with classes and objects, then you can skip ahead to some of the more advanced material later in the chapter – though you may still benefit from a refresher on these key concepts.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor110"/>What Are Classes and Objects?</h1>
			<p>Before we build out our class, let's take a step back and understand how classes work. You can think of a class as a blueprint. It establishes a structure for what we want to build and has some behavior inside it. Now, the class by itself does nothing. It is simply a blueprint. In order to work with it, we have to perform a process called <strong class="bold">instantiation</strong>.</p>
			<p>Instantiation is the process of taking a class and creating an actual object of the class that we can use. Let's walk through an example to understand instantiation further. Imagine that you're building a house and, like a good builder, you have a blueprint of what you want to build. That blueprint is like our class. The blueprint for a home is simply a set of rules, attributes, and behavior for a home. A blueprint for a house defines elements such as square footage, the number of rooms, the number of bathrooms, and where the plumbing goes. Technically, a blueprint is simply a set of rules that are printed out or stored on a computer; it's not the house itself, or the program itself, in this case. In order to create the house, someone needs to take the blueprint and then actually build the house, and it's the same in programming.</p>
			<p>A class by itself does nothing besides establishing the rules for the program. In order to work with the class, we need to create an instance or object of that class. So, returning to the building analogy, you can think of instantiation as taking the blueprint for the house and building it.</p>
			<p>Let's look at the following code snippet to understand how classes and objects appear in TypeScript:</p>
			<p class="source-code">class Person {</p>
			<p class="source-code">    name:string;</p>
			<p class="source-code">    constructor(name) {</p>
			<p class="source-code">        this.name = name;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    read() {</p>
			<p class="source-code">        console.log(this.name+ "likes to read.");</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p class="source-code">const obj = new Person("Mike");</p>
			<p class="source-code">obj.read();</p>
			<p>Let's walk through each of the elements in the preceding code so that you can have a mental model of the key terminology associated with classes and objects in TypeScript, and then we'll go through an in-depth exercise where you will see how to work with each element:</p>
			<ul>
				<li><strong class="source-inline">class Person {}</strong> creates or defines a class.</li>
				<li><strong class="source-inline">name: string;</strong> creates the class attributes.</li>
				<li><strong class="source-inline">constructor()</strong> allows you to perform setup work for when an object is created.</li>
				<li><strong class="source-inline">read()</strong> is a method that allows you to implement custom behavior in a class.</li>
				<li><strong class="source-inline">const obj = new Person("Mike");</strong> creates an object from a class and stores it in a variable so that it can be used.</li>
				<li><strong class="source-inline">obj.read();</strong> calls a method on an object. In this example, it would console log out the value <strong class="source-inline">Mike likes to read</strong>.</li>
			</ul>
			<p>In the next section, we will solve an exercise wherein we'll be building our first TypeScript class.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor111"/>Exercise 4.01: Building Your First Class</h2>
			<p>In this exercise, we'll build a class named <strong class="source-inline">Team</strong> and add a behavior or method named <strong class="source-inline">generateLineup</strong> inside it. We'll also create an object of this class and access its method. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The code files for this exercise can be found here: <a href="https://packt.link/UJXSY">https://packt.link/UJXSY</a>.</p>
			<ol>
				<li>Open the Visual Studio Code editor.</li>
				<li>Create a new directory and then a new file called <strong class="source-inline">scoreboard.ts</strong>. You will be running the TypeScript compiler on it to have it generate a JavaScript file as well. Add the following command in the TypeScript compiler to generate a JavaScript file:<p class="source-code">tsc scoreboard.ts</p><p>Once this command is executed, a <strong class="source-inline">scoreboard.js</strong> file is generated, as you can see in the following screenshot:</p><div id="_idContainer064" class="IMG---Figure"><img src="image/B14508_04_01.jpg" alt="Figure 4.1: TypeScript scoreboard and generated JavaScript files&#13;&#10;"/></div><p class="figure-caption">Figure 4.1: TypeScript scoreboard and generated JavaScript files</p></li>
				<li>Now, create a class called <strong class="source-inline">Team</strong>, and then utilize the instantiation process to create an object of that class. Write the following code inside the <strong class="source-inline">scoreboard.ts</strong> file to create a class:<p class="source-code">class Team {</p><p class="source-code">}</p><p>Right now, this is simply an empty class that doesn't do anything. Let's fix that by adding some behavior to the class. We can add behavior by defining functions. For our <strong class="source-inline">Team</strong> class, we're going to generate a lineup, so we define a function called <strong class="source-inline">generateLineup</strong>, and it doesn't take in any arguments.</p><p class="callout-heading">Note</p><p class="callout">From a syntax perspective, notice that we're using the <strong class="source-inline">class</strong> keyword. The term<strong class="source-inline"> class </strong>is a reserved word in TypeScript and JavaScript, and it tells the compiler that we're about to define a class. In this case, we're calling the <strong class="source-inline">Team</strong> class. </p></li>
				<li>Write the following code to define a <strong class="source-inline">generateLineup()</strong> function inside the class:<p class="source-code">class Team {</p><p class="source-code">    generateLineup() {</p><p class="source-code">        return "Lineup will go here…";</p><p class="source-code">    }</p><p class="source-code">}</p><p>As you can see, functions in classes, which are also referred to as methods, look similar in syntax to standard functions in JavaScript. Now, our <strong class="source-inline">generateLineup</strong> method simply returns a string. Later in the chapter, we'll see how we can implement dynamic behavior in this method.</p><p>Once we've created a class and defined its behavior, we can create an object. In order to create an object of the <strong class="source-inline">Team</strong> class, we call the <strong class="source-inline">new</strong> keyword in front of the <strong class="source-inline">Team</strong> class name and assign that to a variable. In this case, we'll store the instantiated object in a variable called <strong class="source-inline">astros</strong>.</p></li>
				<li>Add the following code to create an object of the <strong class="source-inline">Team</strong> class:<p class="source-code">const astros = new Team();</p><p>Notice that in the preceding code, we're also adding parentheses after the <strong class="source-inline">Team</strong> class name, mimicking how we call functions in TypeScript. </p><p>With all of this in place, we can now use the <strong class="source-inline">astros</strong> variable to call the <strong class="source-inline">generateLineup</strong> method on it. </p></li>
				<li>Add the following code to call the <strong class="source-inline">generateLineup</strong> method:<p class="source-code">console.log(astros.generateLineup());</p></li>
				<li>In the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc scoreboard.ts</p><p class="source-code">node scoreboard.js</p><p>Once we run the preceding commands, the following output is displayed in the terminal: <strong class="source-inline">Lineup will go here…</strong></p></li>
			</ol>
			<p>Hence, we've created our first class, and then from there, we've taken that class, that blueprint, and then used instantiation to create an object. From that point, we're able to call the method inside the class. Now that we've created a class and used its object to access its methods, in the next section, we'll explore the concept of the <strong class="bold">constructor</strong>.</p>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor112"/>Extending Class Behavior with a Constructor</h2>
			<p>In the previous section, we established the syntax for classes in TypeScript. Before we get started with the next phase of the previous program, let's take a step back and discuss an element that we're going to use, called the constructor. The concept of constructors can be confusing if you've never used them before. </p>
			<p>Returning to our blueprint/house analogy, if a class is like a home's blueprint and an object is the home that is created, the constructor is the process of going to the hardware shop and purchasing the materials needed to build the home. A constructor is run automatically anytime that you create an object. Typically, constructors are used to do the following:</p>
			<ul>
				<li>Set data for attributes, which we're about to explore.</li>
				<li>Run any setup processes. Examples of this include calling outside APIs to get data and communicating with a database.<p class="callout-heading">Note</p><p class="callout">More on constructors will be covered in <em class="italic">Chapter 8</em>, <em class="italic">Dependency Injection in TypeScript</em>.</p></li>
			</ul>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor113"/>The this Keyword</h2>
			<p>The concept of <strong class="bold">this</strong> is one of the most confusing aspects of OOP. The <strong class="source-inline">this</strong> keyword refers to the instance of the class that is currently being executed. It has access to the data and behavior of the created object. Let's say we have the following code within a class:</p>
			<p class="source-code">constructor(name){</p>
			<p class="source-code">    this.name = name;</p>
			<p class="source-code">}</p>
			<p>In the preceding code, if <strong class="source-inline">this.name</strong> is referring to the instance of the class and the attribute of <strong class="source-inline">name</strong>, what does the <strong class="source-inline">name</strong> parameter in the constructor represent? In order to use data in our class, we need to have a mechanism for passing data into the object, and that's what the constructor parameters are doing. So, why do we need to assign <strong class="source-inline">this.name</strong> to <strong class="source-inline">name</strong>? It does seem redundant; however, it is helpful for understanding how variable scope works in TypeScript classes. We need to assign the values passed into the object to <strong class="source-inline">this.attributeName</strong> so that the other methods in the class can have access to the values. If we simply passed the value into the constructor and didn't perform the <strong class="source-inline">this.name</strong> assignment, the other methods in the class wouldn't have access to the <strong class="source-inline">name</strong> value. Now, let's extend the behavior of the program in the next exercise, where we will explore the attributes of the class.</p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor114"/>Exercise 4.02: Defining and Accessing the Attributes of a Class</h2>
			<p>In this exercise, we'll add attributes to the <strong class="source-inline">Team</strong> class, which we created in the previous exercise. We'll be using constructors to define and access the attributes of the objects. Perform the following steps to implement this exercise.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In this exercise, we'll continue the work we performed earlier in the chapter with our <strong class="source-inline">Team</strong> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/Diuyl">https://packt.link/Diuyl</a>.</p>
			<p>We begin by listing the names of the attributes at the top of the <strong class="source-inline">Team</strong> class and then we set the value with a <strong class="source-inline">constructor</strong> function by passing in a <strong class="source-inline">name</strong> parameter. From there, we set the value of <strong class="source-inline">this.name</strong> to the value that gets passed into the <strong class="source-inline">constructor</strong> function: </p>
			<ol>
				<li value="1">Write the following code to create a <strong class="source-inline">constructor</strong> function:<p class="source-code">class Team {</p><p class="source-code">    name: string;</p><p class="source-code">    constructor(name) {</p><p class="source-code">      this.name = name;</p><p class="source-code">    }</p><p class="source-code">    generateLineup() {</p><p class="source-code">      return "Lineup will go here …";</p><p class="source-code">    }</p><p class="source-code">}</p><p>When we create the <strong class="source-inline">astros</strong> object, the <strong class="source-inline">this</strong> keyword represents the object that was created. </p></li>
				<li>Create another object to see how the <strong class="source-inline">this</strong> keyword works with multiple objects. Add the following code to the <strong class="source-inline">scoreboard.ts</strong> file to create objects of the <strong class="source-inline">Team</strong> class:<p class="source-code">const astros = new Team();</p><p class="source-code">console.log(astros.generatLineup());</p><p class="source-code">const bluJays = new Team();</p><p class="source-code">console.log(blueJays.generateLineup());</p><p>In the preceding code, we've created another <strong class="source-inline">Team</strong> class object called <strong class="source-inline">blueJays</strong>. From there, we called the <strong class="source-inline">generateLineup</strong> method on the object. When we say <strong class="source-inline">this.name</strong>, what we're referring to is the instance of the class. This means that when we say <strong class="source-inline">this.name</strong> for the first object, we're referring to the <strong class="source-inline">astros</strong> object. And then, for the new object we've created, <strong class="source-inline">this.name</strong> is referencing the <strong class="source-inline">blueJays</strong> object.</p><p>Our <strong class="source-inline">generateLineup</strong> method has access to the value of <strong class="source-inline">name</strong> because we assigned it in the constructor. </p></li>
				<li>Pass values to the constructors of both the objects by writing the following code:<p class="source-code">const astros = new Team("Astros");</p><p class="source-code">console.log(astros.generateLineup());</p><p class="source-code">const blueJays = new Team("Blue Jays");</p><p class="source-code">console.log(blueJays.generateLineup());</p><p class="callout-heading">Note</p><p class="callout">If you ever get asked the difference between parameters and arguments in TypeScript, parameters are what you place inside the function's declarations in your class. Arguments are what you pass to an object or a function.</p><p>In order to pass arguments to a class, you can pass them in the same way that you do with functions, as you can see above. Additionally, when we perform an assignment such as <strong class="source-inline">this.name = name</strong>, this means that when an object is created, it can call the data value as well. </p></li>
				<li>Write the following code to call the relevant data values:<p class="source-code">const astros = new Team("Astros");</p><p class="source-code">//console.log(astros.generateLineup());</p><p class="source-code">console.log(astros.name);</p><p class="source-code">const blueJays = new Team("Blue Jays");</p><p class="source-code">//console.log(blueJays.generateLineup());</p><p class="source-code">console.log(blueJays.name);</p></li>
				<li>In the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc scoreboard.ts</p><p class="source-code">node scoreboard.js</p><p>Once we run the preceding commands, the following output is displayed in the terminal: </p><p class="source-code">Astros</p><p class="source-code">Blue Jays</p></li>
			</ol>
			<p>As you can see in the code in the previous step, when we call <strong class="source-inline">astros.name</strong>, this outputs the name value that was passed into the instantiated object. When we pass the name value <strong class="source-inline">Blue Jays</strong> into the new object, the new value is printed in the terminal. </p>
			<p>We are now able to understand the basic workings of classes and objects. We've also learned how to pass data into an object via a constructor. Now it's time to extend that knowledge and see how we can integrate types directly into our classes.</p>
			<p>Even though the current implementation works, we're not taking advantage of the key benefits that TypeScript offers. In fact, the current implementation is very close to how you would build a class in vanilla JavaScript. By using types in classes, we can define exactly how to work with the code, which will help to make our code more manageable and scalable.</p>
			<p>A real-world example of this would be a React application that utilizes TypeScript versus vanilla JavaScript. One of the most common errors that developers run into is passing the wrong type of data to a class or method, resulting in an error for the user. Imagine accidentally passing a string to a class that requires an array. When the user tries to access the page that is associated with that class, they won't see any data, as the wrong data was passed to the method.</p>
			<p>When you utilize TypeScript and types in a React class, the text editor won't allow the program to even compile as it will explain to you exactly what type of data is required by each class and process. In the next section, we'll solve an exercise wherein we'll integrate different types into our class.</p>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor115"/>Exercise 4.03: Integrating Types into Classes</h2>
			<p>In this exercise, we'll add another attribute named <strong class="source-inline">players</strong> inside our <strong class="source-inline">Team</strong> class. This parameter takes arrays of strings. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We'll continue the work we performed in the previous exercise with our <strong class="source-inline">Team</strong> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/tbav7">https://packt.link/tbav7</a>.</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">scoreboard.ts</strong> file.</li>
				<li>Inside the <strong class="source-inline">Team</strong> class, declare another attribute named <strong class="source-inline">players</strong>, which takes arrays of strings. Write the following code to declare the <strong class="source-inline">string</strong> array:<p class="source-code">players: string[]; </p></li>
				<li>Update the <strong class="source-inline">constructor</strong> function by adding the <strong class="source-inline">name</strong> and <strong class="source-inline">players</strong> parameters. Set the values of the <strong class="source-inline">name</strong> and <strong class="source-inline">players</strong> parameters to <strong class="source-inline">this.name</strong> and <strong class="source-inline">this.players</strong>, respectively. Write the following code to update our <strong class="source-inline">constructor</strong> function:<p class="source-code">constructor(name, players){</p><p class="source-code">    this.name = name;</p><p class="source-code">    this.players = players;</p><p class="source-code">}</p></li>
				<li>Update the <strong class="source-inline">generateLineup()</strong> method so that it joins the player names that will get passed into the object. This method will return a plain string. Here is the updated code of the <strong class="source-inline">generateLineup()</strong> method:<p class="source-code">generateLineup(){</p><p class="source-code">    return this.players.join(", ");</p><p class="source-code">}</p></li>
				<li>Create two arrays of players, namely, <strong class="source-inline">astrosPlayers</strong> and <strong class="source-inline">blueJaysPlayers</strong>. Assign four player names to each array and pass those arrays as second arguments to the <strong class="source-inline">Team</strong> class objects. Write the following code to accomplish this:<p class="source-code">const astrosPlayers = ["Altuve", "Bregman", "Correa", "Springer"];</p><p class="source-code">const astros = new Team("Astros", astrosPlayers);</p><p class="source-code">console.log(astros.generateLineup());</p><p class="source-code">console.log(astros.name);</p><p class="source-code">const blueJaysPlayers = ["Vlad", "Smoak", "Tellez", "Sogard"];</p><p class="source-code">const blueJays = new Team("Blue Jays", blueJaysPlayers);</p><p class="source-code">console.log(blueJays.generateLineup());</p><p class="source-code">console.log(blueJays.name);</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc scoreboard.ts</p><p class="source-code">node scoreboard.js</p><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><p class="source-code">Altuve, Bregman, Correa, Springer</p><p class="source-code">Astros</p><p class="source-code">Vlad, Smoak, Tellez, Sogard</p><p class="source-code">Blue Jays</p></li>
			</ol>
			<p>We've now integrated types into our <strong class="source-inline">Team</strong> class. If you're able to view the names that you passed to the class in the console, this means that you're working with the class and their types properly. In the next section, we'll learn why <strong class="bold">interfaces</strong> are needed and how they are useful.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor116"/>TypeScript Interfaces</h1>
			<p>We'll go through a deep dive into TypeScript interfaces in the next chapter. But for now, just know that an interface allows you to describe the data passed to a class when you're creating an object. In the previous exercise code, if we hover over the <strong class="source-inline">Team</strong> class on Visual Studio Code, we get the following message:</p>
			<div>
				<div id="_idContainer065" class="IMG---Figure">
					<img src="image/B14508_04_02.jpg" alt="Figure 4.2: Vague IntelliSense guidance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 4.2: Vague IntelliSense guidance</p>
			<p>As you can see in the preceding screenshot, the Visual Studio Code editor's IntelliSense is saying that the <strong class="source-inline">players</strong> parameter uses the <strong class="source-inline">any</strong> data type. It's not giving us any usage hints here, and this starts to speak to the reason why we need interfaces, because right now, the <strong class="source-inline">players</strong> array could be anything. It could be a string, it could be an object, and so on. This is essentially breaking one of the main benefits of using TypeScript in the first place. Ideally, our programs should be declarative to the point that we know exactly what type of data should be passed to our functions and classes. We're going to leverage interfaces in order to do that. The way you define an interface is by starting with the <strong class="source-inline">interface</strong> keyword followed by the name of the interface. The common convention in the TypeScript community is to start with a capital <strong class="source-inline">I</strong>, followed by whatever class you're building the interface for. </p>
			<p>Once we have created the interface and update the constructor, we'll establish a way of defining our arguments and our types. This will break any of the previously created objects with the old argument syntax since the previous arguments no longer match up with our new interface. In the next section, we'll complete an exercise wherein we'll build an interface.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor117"/>Exercise 4.04: Building an Interface</h2>
			<p>In this exercise, we'll build an interface and set the types of data that need to be passed to our functions and classes. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We'll continue the work we performed in the previous exercise with our <strong class="source-inline">Team</strong> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/FWUA6">https://packt.link/FWUA6</a>.</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">scoreboard.ts</strong> file.</li>
				<li>Create an interface named <strong class="source-inline">ITeam</strong> and list out the attributes and data types with the same key/value syntax that you would use with an object. Write the following code to create an interface:<p class="source-code">interface ITeam{</p><p class="source-code">    name: string;</p><p class="source-code">    players: string[];</p><p class="source-code">}</p></li>
				<li>Inside our <strong class="source-inline">Team</strong> class, alter the parameter list in the <strong class="source-inline">constructor</strong> function so that the data is passed in as a single object that is of the <strong class="source-inline">ITeam</strong> type. Write the following code to accomplish this:<p class="source-code">constructor(args: ITeam){</p><p class="source-code">    this.name = args.name;</p><p class="source-code">    this.players = args.players;</p><p class="source-code">}</p><p>Notice in the preceding code that, instead of listing out each of the parameters separately, we're declaring the exact structure that is needed for a <strong class="source-inline">Team</strong> object to be created. From that point, we're calling the <strong class="source-inline">name</strong> and <strong class="source-inline">players</strong> values from the <strong class="source-inline">args</strong> parameter since our parameter list has now been refactored to use a single argument.</p></li>
				<li>Create an object of the <strong class="source-inline">Team</strong> class by writing the following code:<p class="source-code">const astros = new Team();</p><p>Now notice what happens when we hover over the parentheses. It says that it expected one argument but got zero. Look at the following screenshot to view the message:</p><div id="_idContainer066" class="IMG---Figure"><img src="image/B14508_04_03.jpg" alt="Figure 4.3: IntelliSense listing out the arguments needed by the class&#13;&#10;"/></div><p class="figure-caption">Figure 4.3: IntelliSense listing out the arguments needed by the class</p></li>
				<li>Let's update how we create the objects. Start typing in the <strong class="source-inline">name</strong> attribute. Write the following code to create the object:<p class="source-code">const astros = new Team({</p><p class="source-code">    name</p><p class="source-code">})</p><p>After adding in the <strong class="source-inline">name</strong> argument, we'll see the following error:</p><div id="_idContainer067" class="IMG---Figure"><img src="image/B14508_04_04.jpg" alt="Figure 4.4: IntelliSense describing the data types needed to create the object&#13;&#10;"/></div><p class="figure-caption">Figure 4.4: IntelliSense describing the data types needed to create the object</p><p>If you hover over the <strong class="source-inline">name</strong> attribute, you can see that TypeScript is helping us understand the other arguments we need to pass in, because the <strong class="source-inline">players</strong> property is missing. So, this is already giving us so much more information on how our class needs to work.</p></li>
				<li>Now, pass the values for both the attributes, <strong class="source-inline">name</strong> and <strong class="source-inline">players</strong>, and update the values for both the objects, <strong class="source-inline">astros</strong> and <strong class="source-inline">blueJays</strong>. Write the following code to accomplish this:<p class="source-code">const astrosPlayers = ["Altuve", "Bregman", "Correa", "Springer"];</p><p class="source-code">const astros = new Team({</p><p class="source-code">    name: "Astros",</p><p class="source-code">    players: astrosPlayers</p><p class="source-code">});</p><p class="source-code">console.log(astros.generateLineup());</p><p class="source-code">console.log(astros.name);</p><p class="source-code">const blueJaysPlayers = ["Vlad", "Smoak", "Tellez", "Sogard"];</p><p class="source-code">const blueJays = new Team({</p><p class="source-code">    name: "Blue Jays",</p><p class="source-code">    players: blueJaysPlayers</p><p class="source-code">});</p><p class="source-code">console.log(blueJays.generateLineup());</p><p class="source-code">console.log(blueJays.name);</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc scoreboard.ts</p><p class="source-code">node scoreboard.js</p><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><p class="source-code">Altuve, Bregman, Correa, Springer</p><p class="source-code">Astros</p><p class="source-code">Vlad, Smoak, Tellez, Sogard</p><p class="source-code">Blue Jays</p></li>
			</ol>
			<p>We've now built an interface and set the types of data that need to be passed to our functions and classes. Although we got the same output as we got in the previous exercise, we are now aware of what type of data needs to be passed to our functions and classes.</p>
			<p>Another great benefit of using interfaces and object-based arguments with classes is that the arguments do not have to be in a specific order. You can pass in the keys in any order that you want, and the class can still parse them properly. If you use standard parameter names, you'll always need to know the order to pass arguments to the class and function.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor118"/>Generating HTML Code in Methods</h1>
			<p>Now that we have learned how to build an interface and have the ability to pass data, along with having some help from IntelliSense in knowing the types of data that we're passing in, we can actually generate some HTML. It's fun to see the code we write generate its own code. Part of the reason why we chose to include this example is that this is very close to the same type of process that you will be using when building React JS or Angular applications. At their very core, the goal of a standard React app is to leverage JavaScript/TypeScript code to render HTML code that can be rendered to the user.</p>
			<p>In the next section, we'll complete an exercise wherein we generate HTML code and view it in the browser.</p>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor119"/>Exercise 4.05: Generating and Viewing HTML Code</h2>
			<p>In this exercise, we will generate some HTML by cleaning up some of the code. We'll get rid of the <strong class="source-inline">name</strong> attribute and the interface. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We'll continue the work we performed in the previous exercise with our <strong class="source-inline">Team</strong> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/Bz5LV">https://packt.link/Bz5LV</a>.</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">scoreboard.ts</strong> file.</li>
				<li>Inside the <strong class="source-inline">Team</strong> class, declare the <strong class="source-inline">players</strong> array and create a <strong class="source-inline">constructor</strong> function. Write the following code to implement this:<p class="source-code">players: string[];</p><p class="source-code">constructor(players){</p><p class="source-code">    this.players = players;</p><p class="source-code">}</p></li>
				<li>Update the <strong class="source-inline">generateLineup()</strong> function by writing the following code:<p class="source-code">generateLineup(): string{</p><p class="source-code">    <a id="_idTextAnchor120"/>const playersWithOrderNumber = </p><p class="source-code">      this.players.map((player, idx) =&gt; {</p><p class="source-code">        return `&lt;div&gt;${idx + 1} - ${player}&lt;/div&gt;`;</p><p class="source-code">    });</p><p class="source-code">    return playersWithOrderNumber.join("");</p><p class="source-code">}</p><p>The <strong class="source-inline">map</strong> function is a helpful iterator tool that loops over the player array. You can pass it as a function that performs some type of operation. In the preceding code, the line <strong class="source-inline">`&lt;div&gt;${idx + 1} – ${player}&lt;/div&gt;`</strong> states that in every iteration, each player's data is wrapped inside the HTML code. Also, each element that is returned is stored in a new array, <strong class="source-inline">playersWithOrderNumber</strong>.</p><p class="callout-heading">Note</p><p class="callout">Notice the return type that we've declared for the <strong class="source-inline">generateLineup</strong> method. This means that we're telling the TypeScript compiler that the method will always return a string value. The reason why this is so important is that if any other part of the application calls this method and tries to perform a task that does not work with the string data type, they'll get a clear error and recommendation on how to fix it.</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc scoreboard.ts</p><p class="source-code">node scoreboard.js</p><p>Once we have run the preceding commands, the following output is displayed in the terminal:</p><div id="_idContainer068" class="IMG---Figure"><img src="image/B14508_04_05.jpg" alt="Figure 4.5: Output showing the lineup of players for both teams&#13;&#10;"/></div><p class="figure-caption">Figure 4.5: Output showing the lineup of players for both teams</p><p>In the preceding output, you'll see that we're getting HTML returned that prints out the lineup of players for both teams. </p><p>But let's not stop here. Let's see what this looks like in the browser. </p></li>
				<li>Save the generated code in an HTML file named <strong class="source-inline">index.html</strong> and view it in the browser. The following output will be displayed in the browser:<div id="_idContainer069" class="IMG---Figure"><img src="image/B14508_04_06.jpg" alt="Figure 4.6: Viewing the generated HTML code in the browser&#13;&#10;"/></div><p> </p></li>
			</ol>
			<p class="figure-caption">Figure 4.6: Viewing the generated HTML code in the browser</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You may get a different image depending on your default browser; however, the text displayed will be the same as listed in the preceding screenshot.</p>
			<p>You can see that we have a full lineup of players for both teams. However, we have not yet formatted the text on the page, and so it is difficult to ascertain the teams to which the players belong unless you have access to the code. We will be enhancing this page with more information and formatting as we progress in this chapter.</p>
			<p>Note that we can pass the objects themselves to another class that will put them together for us and generate a full scoreboard. In the next section, we'll learn how to work with multiple classes and objects.</p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor121"/>Working with Multiple Classes and Objects</h2>
			<p>In this section, we're going to learn how to create a class that combines other classes to give us more advanced behavior. The reason why this is an important concept to understand is that you will need to implement this type of behavior in many different types of applications. For example, if you are building a contact form in a React application, you might need to have classes for an API, form elements, form validations, and other form features all working together. In the next section, we will look at an exercise where we'll combine classes.</p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor122"/>Exercise 4.06: Combining Classes</h2>
			<p>In this exercise, we will be creating a <strong class="source-inline">scoreboard</strong> class that will allow us to pass in objects and work with their data and behavior. This will allow us to take instantiated objects that were created from other classes such as our <strong class="source-inline">Team</strong> class. Then, we're going to add in some other behavior that will generate a full scoreboard that shows off both the lineups along with the data. Perform the following steps to implement this exercise:</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We'll continue the work we performed in the previous exercise with our <strong class="source-inline">Team</strong> class, so make sure to reference it as a starting point. The code files for this exercise can be found here: <a href="https://packt.link/UY5NP">https://packt.link/UY5NP</a>.</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">scoreboard.ts</strong> file.</li>
				<li>Create a <strong class="source-inline">Scoreboard</strong> class and list three attributes, namely, <strong class="source-inline">homeTeam</strong>, <strong class="source-inline">awayTeam</strong>, and <strong class="source-inline">date</strong>. Here, <strong class="source-inline">homeTeam</strong> and <strong class="source-inline">awayTeam</strong> will be of the <strong class="source-inline">Team</strong> type, and <strong class="source-inline">date</strong> will be of the <strong class="source-inline">string</strong> type. Write the following code to accomplish this:<p class="source-code">class Scoreboard{</p><p class="source-code">    homeTeam: Team;</p><p class="source-code">    awayTeam: Team;</p><p class="source-code">    date: string;</p><p class="source-code">}</p><p>In the preceding code, notice how we were able to call the <strong class="source-inline">Team</strong> class. This is because when we create a class, we're able to treat that class like a type in TypeScript. So, TypeScript now knows that our <strong class="source-inline">homeTeam</strong> and <strong class="source-inline">awayTeam</strong> data attributes must be a <strong class="source-inline">Team</strong> object. The <strong class="source-inline">date</strong> attribute will represent the date of the scoreboard. If we tried to pass in <strong class="source-inline">string</strong>, <strong class="source-inline">array</strong>, or anything else for a <strong class="source-inline">Team</strong> object, the program would not compile.</p></li>
				<li>Now that we know the type of data that our scoreboard needs to have, let's create an interface for it. Write the following code to create an interface:<p class="source-code">interface IScoreboard{</p><p class="source-code">    homeTeam: Team;</p><p class="source-code">    awayTeam: Team;</p><p class="source-code">    date: string;</p><p class="source-code">}</p><p>This is similar to what we implemented with the <strong class="source-inline">ITeam</strong> interface, but with a nice twist. Because our <strong class="source-inline">homeTeam</strong> and <strong class="source-inline">awayTeam</strong> attributes are not associated with a basic data type such as <strong class="source-inline">string</strong> or <strong class="source-inline">number</strong>, we're letting the interface know that these values are required to be objects of the <strong class="source-inline">Team</strong> class.</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc scoreboard.ts</p><p>When the preceding command is executed, the <strong class="source-inline">scoreboard.js</strong> file is created.</p></li>
				<li>Open the <strong class="source-inline">scoreboard.js</strong> file and you'll see the following code at the beginning:<div id="_idContainer070" class="IMG---Figure"><img src="image/B14508_04_07.jpg" alt="Figure 4.7: Generated JavaScript that shows interfaces are only used by the text editor&#13;&#10;"/></div><p class="figure-caption">Figure 4.7: Generated JavaScript that shows interfaces are only used by the text editor</p><p>In the preceding screenshot, what we're essentially doing here is almost like a mini declaration file for this class. We're defining the shape of the class. If you remember, those interfaces and those declaration files do not get compiled down into JavaScript. You can confirm this by looking at the generated JavaScript code in the preceding screenshot.</p><p>Now that we've defined the interface, we have essentially defined the shape of our <strong class="source-inline">Scoreboard</strong> class.</p></li>
				<li>Now we implement a <strong class="source-inline">constructor</strong> function, allowing the <strong class="source-inline">Scoreboard</strong> class to know what parameters to expect when creating a new object. Write the following code to accomplish this:<p class="source-code">constructor(args: IScoreboard){</p><p class="source-code">    this.homeTeam = args.homeTeam;</p><p class="source-code">    this.awayTeam = args.awayTeam;</p><p class="source-code">    this.date = args.date;</p><p class="source-code">}</p><p>With this in place, any functions inside our <strong class="source-inline">Scoreboard</strong> class can work with these values.</p></li>
				<li>Now let's create a function called <strong class="source-inline">scoreboardHtml()</strong> inside the <strong class="source-inline">Scoreboard</strong> class. Write the following code to accomplish this:<p class="source-code">scoreboardHtml(): string{</p><p class="source-code">    return `</p><p class="source-code">    &lt;h1&gt;${this.date}&lt;/h1&gt;</p><p class="source-code">    &lt;h2&gt;${this.homeTeam.name}&lt;/h2&gt;</p><p class="source-code">    &lt;div&gt;${this.homeTeam.generateLineup()}&lt;/div&gt;</p><p class="source-code">    &lt;h2&gt;${this.awayTeam.name}&lt;/h2&gt;</p><p class="source-code">    &lt;div&gt;${this.awayTeam.generateLineup()}&lt;/div&gt;</p><p class="source-code">    `;</p><p class="source-code">}</p><p>In the preceding code, we have an <strong class="source-inline">&lt;h1&gt;</strong> heading tag for <strong class="source-inline">date</strong> and an <strong class="source-inline">&lt;h2&gt;</strong> heading tag wrapping the team names. This is great, as even though the <strong class="source-inline">Scoreboard</strong> class has no knowledge of the <strong class="source-inline">Team</strong> class, the IDE can let us know that we have access to the name value. Lastly, we're able to call the <strong class="source-inline">Team</strong> functions. So, inside the <strong class="source-inline">&lt;div&gt;</strong> tags wrapper, we're calling the <strong class="source-inline">generateLineup()</strong> function of <strong class="source-inline">Team</strong>, which we know from earlier returns a list of HTML elements. Also, notice that this function will always return a string and that we're using backticks so that we can use string literals, which can be dynamic.</p><p class="callout-heading">Note</p><p class="callout">In TypeScript and JavaScript, string literals can be written on multiple lines, which is not allowed with quotation marks.</p></li>
				<li>Update the <strong class="source-inline">Team</strong> class with the <strong class="source-inline">name</strong> attribute and <strong class="source-inline">constructor</strong> function. Write the following code to accomplish this:<p class="source-code">name: string;</p><p class="source-code">players: string[];</p><p class="source-code">constructor(name, players){</p><p class="source-code">    this.name = name;</p><p class="source-code">    this.players = players;</p><p class="source-code">}</p></li>
				<li>To view the final scoreboard, first create two team objects followed by the <strong class="source-inline">Scoreboard</strong> class object, and then pass in dates and both of our team objects to it. Write the following code to accomplish this:<p class="source-code">const astrosPlayers = ["Altuve", "Bregman", "Correa", "Springer"];</p><p class="source-code">const astros = new Team("Astros", astrosPlayers);</p><p class="source-code">//console.log(astros.generateLineup());</p><p class="source-code">const blueJaysPlayers = ["Vlad", "Smoak", "Tellez", "Sogard"];</p><p class="source-code">const blueJays = new Team("Blue Jays", blueJaysPlayers);</p><p class="source-code">//console.log(blueJays.generateLineup());</p><p class="source-code">const todaysGame = new Scoreboard({</p><p class="source-code">    date: "5/24/19",</p><p class="source-code">    homeTeam: astros,</p><p class="source-code">    awayTeam: blueJays</p><p class="source-code">});</p><p class="source-code">console.log(todaysGame.scoreboardHtml());</p></li>
				<li>Now, in the terminal, type the following commands to generate the JavaScript code and run it:<p class="source-code">tsc scoreboard.ts</p><p class="source-code">node scoreboard.js</p><p>Once we run the preceding commands, the following output is displayed in the terminal:</p><div id="_idContainer071" class="IMG---Figure"><img src="image/B14508_04_08.jpg" alt="Figure 4.8: Generated HTML code&#13;&#10;"/></div><p class="figure-caption">Figure 4.8: Generated HTML code</p></li>
				<li>Add this code to an HTML file and view it in the browser. You will see that we have a full scoreboard like the one shown in the following screenshot:<div id="_idContainer072" class="IMG---Figure"><img src="image/B14508_04_09.jpg" alt="Figure 4.9: Generated code in the browser&#13;&#10;"/></div><p> </p></li>
			</ol>
			<p class="figure-caption">Figure 4.9: Generated code in the browser</p>
			<p>Finally, we combined two classes, namely, <strong class="source-inline">Scoreboard</strong> and <strong class="source-inline">Team</strong>. In the <strong class="source-inline">Scoreboard</strong> class, we created attributes of the <strong class="source-inline">Team</strong> type and added a few behaviors that will help to generate a full scoreboard consisting of the lineups of both teams. </p>
			<p>So far, we've introduced classes and objects in TypeScript, and with this knowledge, we're ready to move on to the code activity in the next section, where we will create a user model.</p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor123"/>Activity 4.01: Creating a User Model Using Classes, Objects, and Interfaces</h2>
			<p>In this activity, you will build a user authentication system that mimics how a TypeScript application would pass login data to a backend API to register and sign users into our baseball scorecard application. This will entail building multiple TypeScript classes and combining classes and objects together to mimic an authentication feature. Perform the following steps to implement this activity:</p>
			<ol>
				<li value="1">Visit the GitHub repository and download the activity project containing the specs and configuration elements: <a href="https://packt.link/vJxBm">https://packt.link/vJxBm</a>.</li>
				<li>Open the Visual Studio Code editor.</li>
				<li>Create a file called <strong class="source-inline">auth.ts</strong>.</li>
				<li>Run the TypeScript compiler on the file and watch for changes.</li>
				<li>Create a <strong class="source-inline">Login</strong> class that takes in an object containing the string attributes of <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong>.</li>
				<li>Build an interface called <strong class="source-inline">ILogin</strong> that defines the <strong class="source-inline">email</strong> and <strong class="source-inline">password</strong> attributes.</li>
				<li>Pass it as a parameter to the <strong class="source-inline">constructor</strong> function.</li>
				<li>Create an <strong class="source-inline">Auth</strong> class that takes in an object containing the attributes of <strong class="source-inline">user</strong> and <strong class="source-inline">source</strong>.</li>
				<li>Build an interface called <strong class="source-inline">IAuth</strong> that defines the <strong class="source-inline">user</strong> and <strong class="source-inline">source</strong> attributes and pass it as the <strong class="source-inline">constructor</strong> function parameter. Have the <strong class="source-inline">user</strong> attribute be of the <strong class="source-inline">Login</strong> type and the <strong class="source-inline">source</strong> attribute of the <strong class="source-inline">string</strong> type.</li>
				<li>Add a <strong class="source-inline">validUser()</strong> method to the <strong class="source-inline">Auth</strong> class that returns <strong class="source-inline">true</strong> if <strong class="source-inline">email</strong> is equal to <strong class="source-inline">admin@example.com</strong> and if <strong class="source-inline">password</strong> is equal to <strong class="source-inline">secret123</strong>. </li>
				<li>Ensure that you can access the <strong class="source-inline">source</strong> attribute from the instantiated <strong class="source-inline">Auth</strong> object and that it's a string.</li>
				<li>Test the user model by first checking a valid user and then an invalid user.<p>The expected output should look something like this:</p><p class="source-code">Validating user...User is authenticated: true</p><p class="source-code">Validating user...User is authenticated: false</p><p class="callout-heading">Note</p><p class="callout">The solution to this activity can be found via <a href="B14508_Solution_ePub.xhtml#_idTextAnchor399">this link</a>.</p></li>
			</ol>
			<h1 id="_idParaDest-108"><a id="_idTextAnchor124"/>Summary</h1>
			<p>Learning OOP development patterns for the first time can be a challenging task. In this chapter, you learned about OOP development, how to define classes in TypeScript, how to instantiate classes and create objects, how to combine data and methods in a class to encapsulate a full set of behavior, how to utilize interfaces in order to define the data that can be passed to a TypeScript class, and finally, how to pass the objects to classes of various types.</p>
			<p>You also now have a basic understanding of how an authentication system works and how to utilize TypeScript to generate HTML code.</p>
			<p>Now that you have a basic understanding of how classes and objects work in TypeScript, in the next chapter, you'll learn how to work with the concept of class inheritance and take a deeper dive into interfaces.</p>
		</div>
		<div>
			<div id="_idContainer074" class="Content">
			</div>
		</div>
	</body></html>