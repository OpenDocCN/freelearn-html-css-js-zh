<html><head></head><body>
        

                            
                    <h1 class="header-title">Building Your First Amazon Lex Chatbot</h1>
                
            
            
                
<p class="mce-root">The preceding two chapters focused solely on Amazon Alexa and building Alexa Skills. The next three chapters will teach you how to build chatbots using Amazon Lex. In this chapter, we'll learn how to build and test a Lex chatbot and then we'll step things up by integrating S3.</p>
<p>Amazon Lex is very similar to Amazon Alexa but the main difference is that Lex has been designed to primarily work as a typed interaction. This means that you can use Lex to power Facebook messenger bots, add functionality to Slack, or even send text messages to your users. This doesn't stop you from using Lex for voice interactions and it can be used to build voice-based chatbots outside of the Amazon Alexa ecosystem.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Creating a Lex chatbot with slots and built-in responses</li>
<li>Creating an FAQ chatbot with Lambda fulfillment</li>
<li>Retrieving answers from S3 storage</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Technical requirements</h1>
                
            
            
                
<p>In this chapter, we will be creating a Lambda function for our skill, and we'll be creating and deploying it using the local development setup that we created in <a href="ac448944-0559-408e-a9c4-972933a03611.xhtml" target="_blank">Chapter 2</a>, <em>Getting Started with AWS and Amazon CLI</em>.</p>
<p>All of the code and data required for this chapter can be found at <a href="http://bit.ly/chatbot-ch5">http://bit.ly/chatbot-ch5</a>.<a href="http://bit.ly/chatbot-ch5"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an Amazon Lex chatbot</h1>
                
            
            
                
<p>Creating a Lex chatbot is very similar to the process of creating an Alexa skill. We need to create intents with utterances, we can have slots with slot types on those intents, and we can then build a response to the user. Although Lex and Alexa are very similar, there are some key differences that we will look at as we go through this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up the chatbot</h1>
                
            
            
                
<p>To start creating our first Lex chatbot, we need to open the AWS console and search for <em>Lex</em>. Once on the Lex page, click Get Started to get to the bot setup page. You'll be presented with the option to use one of three sample bots or to create a Custom bot. We'll be creating a custom bot, so select that option. The other three options are sample bots. These have been built to showcase the applications that you can use a Lex chatbot for:</p>
<div><img src="img/3309227c-5fd2-4617-b8c8-28313e47c43f.png"/></div>
<p>Bot-creation options</p>
<p>Having selected Custom bot, we get to name our bot and set up a few other settings. All of these settings are editable later, so we can start with some defaults.</p>
<p class="mce-root">Select a voice for your chatbot. This is the voice that will be used if you want to set up your Lex bot for voice-based chatbots. As we are going to be using Lex for text-based interactions only, we could select None. We'll be building a text-based application, but you should still choose a voice so you can test with voice.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The last two parts are to set a timeout; we can use the default of 5 minutes, and select No for the COPPA question. If you want to create a chatbot that will talk with children, ticking Yes will stop Lex from storing any of the conversations to comply with the Children's Online Privacy Protection Act. Now that we've finished the settings, we can click Create. This takes us to the Lex dashboard:</p>
<div><img src="img/5eac0fff-1d1c-4013-981d-960045e11548.png"/></div>
<p>Lex dashboard</p>
<div><p>The components and process of creating a Lex chatbot are very similar to the process of creating an Alexa skill. There are Intents, Utterances, Slots, and Slot types, and the creation of most of these is almost identical to their creation in Alexa.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an Intent</h1>
                
            
            
                
<p>The first thing we want to do is Create intent. Unlike Alexa, we have the option to Create intent, Import intent, or Search existing intents. As this is our first intent in Lex, we need to Create intent. We are prompted for a name for our new intent; we should call our first intent <kbd>sayHello</kbd>:</p>
<div><img src="img/4e54e9ca-0a2d-4439-b947-b93caaa2be7b.png"/></div>
<p>Intent screen</p>
<p>First, we need to add utterances so that the user can trigger the intent. We can add the utterances of <kbd>hi</kbd>, <kbd>hey</kbd>, and <kbd>hello</kbd>. These are not case-sensitive, and adding punctuation such as commas and full stops is unnecessary, although apostrophes are accepted.</p>
<p class="mce-root"/>
<p>One of the biggest differences between Lex and Alexa is that we can send responses without needing a Lambda. Scroll to the bottom of the page and you will see the Fulfillment and Response sections. The Fulfillment section lets you decide whether to send this intent to a Lambda. For now, we are going to keep that option on Return parameters to client.</p>
<p class="CDPAlignLeft CDPAlign">Inside the Response section is where we can tell Lex what to send back to the user. Click the Add Message button and a message block will appear. In the text area, we can type the response we want to send back to the user. Add a response phrase such as <kbd>Hi there</kbd> and press <em>Enter</em>. Unlike the utterances, the response is case-sensitive and can contain any punctuation you want:</p>
<div><img src="img/f8d718c5-066f-4482-a6c7-c8e642b553d7.png" style=""/></div>
<p>Fulfillment and response</p>
<p>We can actually add multiple response messages, and Lex will choose one of them at random. This makes multiple interactions with the chatbot feel more natural and less robotic.</p>
<p>With the utterances and the response completed, we can save the intent with the Save Intent button at the bottom of the intent. Once that has saved, we can build our bot.</p>
<p class="mce-root">Building the bot takes all of the utterances from your intents and adds them to a language model. Click the Build button in the upper-right corner of the screen and wait for the system to put the bot together. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing your chatbot</h1>
                
            
            
                
<p>When Lex has finished building, you will get a notification and a new Test bot section will open on the right of your screen. This is a basic text chat interface where you can try out your bot. Try typing <kbd>Hi</kbd> into the chat and you should get a response of Hi there or Hey:</p>
<div><img src="img/6e095239-4f81-4768-9917-c14e65785a24.png" style=""/></div>
<p>Initial test</p>
<p>If you don't, check that you have added the utterances and responses, and rebuild the chatbot.</p>
<p>You can also test your bot by speaking to it. Click the microphone symbol, say <kbd>Hello</kbd>, and then click the microphone again. You should see what you said, and get a spoken response as well as a text response. If you get an error about not having a selected voice, go to Settings | General and change the output voice.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Publishing your bot</h1>
                
            
            
                
<p>With a working chatbot, we can publish the bot. Clicking the Publish button opens a popup where we can select the alias that we want to publish to. This is useful when you want to test that a new version of the bot is fully functional without replacing the existing live version. You can create a development or test alias without overwriting the existing production bot:</p>
<div><img src="img/7716aabd-8c90-4571-bb97-41caa3587f43.png"/></div>
<p>Publishing your bot</p>
<p class="ImageCaption CDPAlignLeft CDPAlign">Once the Publish is complete, you can access this new alias from other services.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Slots</h1>
                
            
            
                
<p>As we saw with Alexa, having a set response is OK, but using slots to customize the interaction is much better. Go into the sayHello intent screen and scroll down to Slots. This is identical to the slot configuration in Alexa.</p>
<p>Give a name to the slot you want to get; in this case, we can ask them for their name so we call the slot <kbd>usersName</kbd>. We have to select a slot type and we can choose either GB_FIRST_NAME or US_FIRST_NAME. The last thing we need to do is to configure the prompt. Enter a question that will get them to enter their name, such as <kbd>What is your name?</kbd>. To add this slot, we need to click the blue plus button at the end of the line.</p>
<p>When we see the new line created, we can check that the Required checkbox is ticked so Lex knows to ask the user for this slot:</p>
<div><img src="img/95db7d96-cdc5-45b4-a262-412b376f9707.png" style="width:55.08em;height:10.25em;"/><br/>
<br/>
Slot creation</div>
<p>Now that we have a slot, we need to use the answer in our response. To add the slot into a response, we can wrap the slot name in curly braces. This means our response becomes <kbd>Hi there {usersName}</kbd>.</p>
<p>We can now save this intent again and rebuild the chatbot. Now we get a slightly longer conversation:</p>
<div><img src="img/506b7fe4-9381-4d3e-902f-bf162cf2ea24.png" style=""/></div>
<p>Test with name</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating an FAQ chatbot</h1>
                
            
            
                
<p>Now that we've learned how to make a Lex chatbot, we can start to build something that you are more likely to see in the real world. FAQ chatbots are becoming more and more popular; they are relatively simple to create and are a great way to introduce a chatbot to a website or Facebook group.</p>
<p>To start creating an FAQ chatbot, we need to find an FAQ page to base this on. Most company websites have an FAQ page now so you can find the FAQ page for a company that interests you, or follow along with me on CircleLoop (<a href="https://www.circleloop.com/">circleloop.com</a>). This site was chosen because it is where I work and it has the questions in three groups. If you are only doing this for practice, you can use any website, but if you want to publish your chatbot, ask the permission of the company. You never know, they could end up paying you for it eventually!</p>
<p>CircleLoop is also good as it has a total of 24 questions, which is a good amount – too many and it can take a very long time and Lex can mix up similar questions.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up Lex</h1>
                
            
            
                
<p>As we did in the first half of this chapter, we need to create a new Lex chatbot. On the Lex console page there will be a list of all of your Lex chatbots, and above that will be a Create button.</p>
<p>Follow the same process as before, selecting Custom bot, naming your chatbot, choosing a voice, selecting a five-minute timeout, and selecting <em>No</em> for the COPPA question. If you are making a chatbot that is designed for children under 13, you should research COPPA and alter your answer accordingly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Gathering the data</h1>
                
            
            
                
<p>All of the data files for this section are available at <a href="https://bit.ly/chatbot-ch5">https://bit.ly/chatbot-ch5</a> in the <kbd>data</kbd> folder, but if you are using your own company, you'll have to follow this process with your company's FAQs.</p>
<p>Before we start creating intents, we need to get the data that we will be using. Go to the FAQ page of your choice and open up a new file called <kbd>faq-setup.json</kbd>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>This file will contain a group of intents and answers in the following format:</p>
<pre>{<br/>     "intentName1": "This is the answer to question 1",<br/>     "intentName2": "You do this by selecting 'A' and then pressing 'START'"<br/>     ...<br/> }</pre>
<p>The intent names should be unique strings that describe what the question is asking. For example, if you are asking, "Where is the company based?", you might call the intent <kbd>companyLocation</kbd>.</p>
<p>Go through all of the questions in the <em>Setting Up &amp; Using CircleLoop</em> section of the site. Repeat the process with a new file for the <em>Users &amp; Numbers</em> and <em>Other Questions</em> sections. You should end up with three JSON files that contain all of the answers on the website. Here is a section of one of the <kbd>faq-setup.json</kbd> files:</p>
<pre>{<br/>    "howItWorks": "CircleLoop is a cloud-based business phone system, which allows ... settings.",<br/>    "technicalKnowledge": "No. We’ve made it really easy with our simple apps. As long as ... and you’re ready to go.",<br/>    ...<br/>    "sevenDayTrial": "Full user privileges, including the ability to add users ... during your trial period."<br/>}</pre>
<p class="CDPAlignLeft CDPAlign">We are now going to upload these three files into an S3 bucket so that our Lambda functions can access them. In your AWS console, navigate to S3 and click Create bucket. Give your bucket a unique name and continue through the configuration. We don't need to add any extra permissions to this bucket for this project:</p>
<div><img src="img/98b401c2-b1a4-47ad-baf2-e2529c66f9d0.png" style=""/></div>
<p>Upload files</p>
<div><p>Now that we've created the bucket, we can upload our FAQ files. Click into your newly created bucket and then click the Upload button. Again, we don't need to change any of the permissions from their defaults.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Intents</h1>
                
            
            
                
<p>Once we've created and uploaded the JSON files, we need to create the intents to match up. Go through your JSON files and create a new intent for each line. The intent names need to be exactly the same as the keys in the JSON file object. You can then use the questions from the FAQ page as the first utterance for that intent:</p>
<div><img src="img/6f5c4842-7128-4de9-aa66-0e5e47d31e73.png" style=""/></div>
<p>Intents</p>
<div><p>By the end of this process, you should have as many intents as you do rows in your JSON files. You should then go through and add more utterances to each intent. These new utterances should be other ways to phrase the same question. Expanding the list of utterances increases the chance that the user will get the correct answer.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating the Lambda Handler</h1>
                
            
            
                
<p class="mce-root">Now that we have the intents—catching the user utterances—we need to create the responses to send to the user. Because we have three files, we can create three Lambdas.</p>
<p class="mce-root"/>
<p class="mce-root">Each Lambda will deal with questions about one section.</p>
<div><p>Create three folders in your main Lambda folder, called <kbd>CL-setup</kbd>, <kbd>CL-users</kbd>, and <kbd>CL-other</kbd>. Inside each of the folders, create an <kbd>index.js</kbd> file. Open up the <kbd>index.js</kbd> file inside <kbd>CL-setup</kbd> and we can start to program the handler, starting with an empty handler:</p>
<pre>exports.handler = async event =&gt; {<br/>};</pre>
<p>First, we need to find out which intent triggered the Lambda. The structure of the data received from Lex is slightly different from the structure of the data received from Alexa:</p>
<pre>let intentName = event.currentIntent.name;</pre>
<p>Now that we have the intent name, we need to make a request to S3 to get the file that contains the answer. As we did in <a href="13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml" target="_blank">Chapter 3</a>, <em>Creating Your First Alexa Skill</em>, we first need to require in AWS and create a new instance of S3. Add this code at the very top of the file, just before <kbd>exports.handler</kbd>:</p>
<pre>const AWS = require('aws-sdk');<br/>const s3 = new AWS.S3();</pre>
<p>To make a request to S3, we need to pass in some query parameters. This is an object containing the <kbd>Bucket</kbd> that contains our object and the <kbd>Key</kbd> of the object we want.</p>
<p>Because we're using Node 8.10 and an <kbd>async</kbd> function, we need to return a promised value. This means we need to create a <kbd>new Promise</kbd> and then <kbd>resolve</kbd> and <kbd>reject</kbd> our results. Back inside our handler function, we can add this code. Unlike in <a href="13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml" target="_blank">Chapter 3</a>, <em>Creating Your First Alexa Skill</em>, we can set <kbd>Key</kbd> to a fixed value of <kbd>faq-setup.json</kbd> for this Lambda, as this Lambda is only going to be called for questions from the <em>Set Up &amp; Using CircleLoop</em> section:</p>
<pre>var params = {<br/>    Bucket: 'cl-faq',<br/>    Key: `faq-setup.json`<br/>};<br/> <br/>return new Promise((resolve, reject) =&gt; {<br/>    // do something<br/>    resolve(success);<br/>    reject(failure);<br/>})</pre>
<p>We can put our <kbd>s3.getObject()</kbd> code inside this <kbd>Promise</kbd>, resolving <kbd>handleS3Data()</kbd> and rejecting <kbd>handleS3Error()</kbd>:</p>
<pre>return new Promise((resolve, reject) =&gt; {<br/>    s3.getObject(params, function(err, data) {<br/>        if (err) { // an error occurred<br/>            reject(handleS3Error(err));<br/>        } else { // successful response<br/>            console.log(data);<br/>            resolve(handleS3Data(data, intentName));<br/>        }<br/>    });<br/>})</pre>
<p>We now need to create the two handlers for the S3 responses. These functions can be created after the handler:</p>
<pre>const handleS3Error = err =&gt; {<br/>}<br/> <br/>const handleS3Data = (data, intentName) =&gt; {<br/>}</pre>
<p>We will start by creating the data-handler. Inside here, we first need to parse the body of the data. This is because it comes down as a <em>buffer</em> that needs to be turned into JSON before we can work with it:</p>
<pre>let body = JSON.parse(data.Body);</pre>
<p>With the data in JSON format, we can now check that <kbd>intentName</kbd> is one of the keys in the object. If it isn't, we need to return the <kbd>handleS3Error</kbd> function to send the user an error message:</p>
<pre>if (!body[intentName]){<br/>    return handleS3Error(`Intent name ${intentName} was not present in faq-setup.json`);<br/>}</pre>
<p>In <kbd>handleS3Error</kbd>, we can <kbd>console.log</kbd> the error and then create an error response string. This should tell the user there was an error and ask them to try asking another question:</p>
<pre>console.log('error of: ', err);<br/>let errResponse = `Unfortunately I don't know how to answer that. Is there anything else I can help you with?`;</pre></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a response</h1>
                
            
            
                
<p>The way that you create a response in Lex is very different from how it's done in Alexa. In Lex, there is an object structure that needs to be followed:</p>
<pre>sessionAttributes: {},<br/>dialogAction: {<br/>    type: '',<br/>    fulfillmentState: '',<br/>    slots: {},<br/>    slotToElicit: '',<br/>    message: { contentType: 'PlainText', content:  ''};<br/>}</pre>
<p>Because this is a bit of code that we may use multiple times, we can create functions for each of the types. Here is a function for finishing the last stage of a conversation flow. This can be added to the bottom of the <kbd>index.js</kbd> file:</p>
<pre>const lexClose = ({ message, sessionAttributes = {}, fulfillmentState = "Fulfilled"}) =&gt; {<br/>    return {<br/>        sessionAttributes,<br/>        dialogAction: {<br/>            type: 'Close',<br/>            fulfillmentState,<br/>            message: { contentType: 'PlainText', content: message }<br/>        }<br/>    }<br/>}</pre>
<p>This function uses default values for <kbd>sessionAttributes</kbd> and <kbd>fulfillmentState</kbd> as we won't be setting either of them in most cases, but it is good to be able to if we wanted to.</p>
<p>With this new function, we can now create responses in our handler functions. Inside our <kbd>handleS3Data</kbd> function, we can return this <kbd>lexClose</kbd> function with the answer from the file as the message:</p>
<pre>return lexClose({ message: body[intentName] });</pre>
<p>We also need to make a <kbd>lexElicitIntent</kbd> function at the bottom of the file for when we tell the user to ask another question. This tells Lex that it should be expecting an intent utterance as its next message:</p>
<pre>const lexElicitIntent = ({ message, sessionAttributes = {} } ) =&gt; {<br/>    return {<br/>        sessionAttributes,<br/>        dialogAction: {<br/>            type: 'ElicitIntent',<br/>            message: { contentType: 'PlainText', content: message }<br/>        },<br/>    };<br/>}</pre>
<p>This <kbd>lexElicitIntent</kbd> can then be returned at the end of the <kbd>handleS3Error</kbd> function to tell the user to ask another question:</p>
<pre>return lexElicitIntent({ message: errResponse });</pre>
<p>This file can be copied into the other two folders. We only need to change <kbd>key</kbd> in the params object and the text in the error console log and response. With those changes made, we can deploy our three Lambdas using our build script.</p>
<p>With all three Lambdas deployed, we need to make sure their role includes permissions to access S3 buckets. Inside each of the Lambdas, scroll down to the Role section and we should be able to see the role of lambdaBasic. We should have updated this in <a href="13a7c772-9228-4bf9-8e22-0d41dfba9416.xhtml" target="_blank">Chapter 3</a>, <em>Creating Your First Alexa Skill</em>, but we should check again. Navigate into the IAM service and make sure that lambdaBasic has S3 read permissions. If it doesn't, then attach AmazonS3ReadOnlyAcess to this role.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lambda fulfillment</h1>
                
            
            
                
<p>We can use Lambdas to create the response of our intents. This gives us a lot more control than just having a text response. The great thing about Lex is that each intent can have its own Lambda handler or multiple intents can share one Lambda.</p>
<p>With the three Lambdas deployed, we can use them to fulfill the intents. We're going to have all of the intents about the setup share the <kbd>CL-setup</kbd> Lambda, all intents about users and numbers will share the <kbd>CL-users</kbd> Lambda, and all other questions will share the <kbd>CL-other</kbd> Lambda.</p>
<p>Open up your Lambda console and go into your FAQ chatbot. Open an intent and scroll down to the Fulfillment section.</p>
<p>There are two options:</p>
<ul>
<li>AWS Lambda function</li>
<li>Return parameters to client</li>
</ul>
<p>As we've created the Lambdas, we can select AWS Lambda function, which opens more menu items for us to select. The main one is the Lambda dropdown where we can select which Lambda will be triggered on the intent fulfillment:</p>
<div><img src="img/629682ea-3204-4cdf-a1a4-6ddebe158ecc.png" style=""/></div>
<p>Intent fulfillment options</p>
<p>With the Lambda selected, we need to save the intent and move on to the next intent. This needs to be done for every intent in the chatbot, making sure to send the correct intents to the correct Lambdas.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Building and testing</h1>
                
            
            
                
<p>With all of the intents pointing to a fulfillment Lambda, we can build our chatbot and then test it. Click the Build button in the upper-right corner of the screen and wait until the build process has stopped. This may take a few minutes, and the <em>Test</em> section will open when the build process ends.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>To test our chatbot, type a question and you should receive the correct answer:</p>
<div><img src="img/493b8dd5-39d9-4d96-9928-e804bb7b00db.png" style=""/></div>
<p>FAQ tests</p>
<p>If you don't get the correct answer, or don't get an error at all, then there are a few things to check:</p>
<ul>
<li>Look in the Lambda logs and check that the correct Lambda is being called. You should also be able to see a log with the error message, allowing you to pinpoint the error.</li>
<li>Check that the Lambdas have permission to access the S3 buckets.</li>
<li>Follow the Lambda debugging guide at the end of this book.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Lex responses</h1>
                
            
            
                
<p>We have just seen two of the different response types that can be returned to Lex. There are currently five different types of response that Lex can handle:</p>
<ul>
<li><kbd>elicitSlot</kbd></li>
<li><kbd><kbd>elicitIntent</kbd></kbd></li>
<li><kbd>confirmIntent</kbd></li>
<li><kbd>close</kbd></li>
<li><kbd>delegate</kbd></li>
</ul>
<p>These can all be found at <a href="http://bit.ly/chatbot-ch5">http://bit.ly/chatbot-ch5 </a>in the <kbd>All-Lex-Responses.js</kbd> file. You can then copy them into your future projects.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">elicitSlot</h1>
                
            
            
                
<p>The <kbd>elicitSlot</kbd> response type is very useful if you have been doing checks on your slot values and have found one of them to be incorrect. You can then ask the user to re-enter the value for that slot and make sure that Lex stores that in the correct slot.</p>
<p>To call <kbd>elicitSlot</kbd>, you need to pass in a message, the slots (an object containing all of the slots and current values), a <kbd>slotToElicit</kbd> value, and <kbd>intentName</kbd>:</p>
<pre>const lexElicitSlot = ({ sessionAttributes = {}, message, intentName, slotToElicit, slots }) =&gt; {<br/>     return {<br/>         sessionAttributes,<br/>         dialogAction: {<br/>             type: 'ElicitSlot',<br/>             intentName,<br/>             slots,<br/>             slotToElicit,<br/>             message: { contentType: 'PlainText', content: message }<br/>         },<br/>     };<br/> }</pre>
<p>If we rebuilt the car helper bot in Lex, we would use the <kbd>lexElicitSlot</kbd> function when we validate the slot values. If there was an incorrect slot, then we would call this function like so:</p>
<pre>return lexElicitSlot({<br/>     intentName: 'whichCar',<br/>     slotToElicit: 'size',<br/>     slots: {<br/>         size: null,<br/>         cost: 'value',<br/>         doors: 5,<br/>         gears: null<br/>     }<br/> })</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">elicitIntent</h1>
                
            
            
                
<p>We have already seen this Lex response, taking a message and session attributes. This is usually used to continue the conversation or to restart with a new intent:</p>
<pre>const lexElicitIntent = ({ message, sessionAttributes = {} } ) =&gt; {<br/>    return {<br/>        sessionAttributes,<br/>        dialogAction: {<br/>            type: 'ElicitIntent',<br/>            message: { contentType: 'PlainText', content: message }<br/>        },<br/>    };<br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">confirmIntent</h1>
                
            
            
                
<p>The <kbd>confirmIntent</kbd> response is used when you want to ask a user whether they want to do something. This could be used at the end of the FAQ bot to ask <kbd>Would you like to sign up?</kbd>, which would be a <kbd>confirmIntent</kbd> response for a <em>signUp</em> intent. You need to pass in <kbd>message</kbd>, <kbd>intentName</kbd>, and the <kbd>slots</kbd> for that intent. Any slots that you don't want to pre-fill should have a value of <kbd>null</kbd>:</p>
<pre>const lexConfirmIntent = ({ sessionAttributes = {}, intentName, slots, message }) =&gt; {<br/>    return {<br/>        sessionAttributes,<br/>        dialogAction: {<br/>            type: 'ConfirmIntent',<br/>            intentName,<br/>            slots,<br/>            message: { contentType: 'PlainText', content: message }<br/>        },<br/>    };<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">close</h1>
                
            
            
                
<p>This is the simplest and most-used Lex response. The only thing that you need to pass in is <kbd>message</kbd>:</p>
<pre>const lexClose = ({ sessionAttributes = {}, fulfillmentState = 'Fulfilled', message }) =&gt; {<br/>     return {<br/>         sessionAttributes,<br/>         dialogAction: {<br/>             type: 'Close',<br/>             fulfillmentState,<br/>             message: { contentType: 'PlainText', content: message }<br/>         },<br/>     };<br/> }</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">delegate</h1>
                
            
            
                
<p>The <kbd>delegate</kbd> response is where you want to leave Lex to decide what to send to the user. This is most likely used if you have validated an input and you want Lex to ask for the next slot or move into fulfillment. It takes just a <kbd>slots</kbd> object that contains all of the slots for the current intent:</p>
<pre>const lexDelegate = ({ sessionAttributes = {}, slots }) =&gt; { <br/>    return { <br/>        sessionAttributes, <br/>        dialogAction: { type: 'Delegate', slots, }<br/>    }; <br/>}</pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>This chapter has been an introduction to Amazon Lex. You've learned that Lex and Alexa are very similar in form and function, but there are a few differences in how they are built and how they work.</p>
<p class="mce-root">We can now create a Lex chatbot with intents, slots, and hardcoded responses. We can then increase the functionality by creating Lambdas to handle intent fulfillment. One advantage of Lex over Alexa is that we can use multiple Lambdas to handle different intents. To help us easily respond to Lex, we created a <kbd>Lex</kbd> class that maps values into the correct response format.</p>
<p class="mce-root"/>
<p>We used these skills to build an FAQ chatbot that gets data from S3 and uses that to generate a response.</p>
<p>In the next chapter we will take what we have learned in this chapter and build upon it by adding a database to our chatbot. We will use DynamoDB to store information about the chat, allowing us to make a more realistic chatbot conversation.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Questions</h1>
                
            
            
                
<ol>
<li>Can you create a Lex chatbot without using Lambdas?</li>
<li>How do you include a slot in a response from Lex?</li>
<li>How does Lex use Lambdas differently from Alexa?</li>
<li>How many response types does Lex deal with?</li>
<li>Can you name them all?</li>
<li>What is the name of the function to get data from S3?</li>
</ol>


            

            
        
    </body></html>