<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-34" lang="en-GB"><a id="_idTextAnchor033"/>3</h1>
<h1 id="_idParaDest-35" lang="en-GB"><a id="_idTextAnchor034"/>Choosing a Package Manager</h1>
<p lang="en-GB">So far, we have learned a bit about Node.js and its internal modules. We also started to write our own modules, but we have either avoided or worked around using third-party packages.</p>
<p lang="en-GB">One of the big advantages of Node.js is that using other people’s code is actually quite easy. The path to doing so leads us directly to package managers. A package manager helps us to handle the life cycle of packages containing modules that can be used in Node.js.</p>
<p lang="en-GB">In this chapter, we’ll learn how Node.js’s de facto standard package<a id="_idIndexMarker087"/> manager <strong class="bold" lang="">npm</strong> works. We will then go on to learn about other <a id="_idIndexMarker088"/>package managers, such as <strong class="bold" lang="">Yarn</strong> and <strong class="bold" lang="">pnpm</strong>. They <a id="_idIndexMarker089"/>all promise some advantages in terms of usability, performance, or reliability. We will take a deeper look at them to understand these advantages and who might benefit from using each of the different package managers. Finally, we’ll also look at alternatives.</p>
<p lang="en-GB">This chapter will help you to use third-party libraries in your code. Third-party dependencies will make you more productive and focused, and a package manager will be useful for installing and updating third-party dependencies. By the end of the chapter, you’ll know the most important package managers and which one you want to pick in the context of your project.</p>
<p lang="en-GB">We will cover the following key topics in this chapter:</p>
<ul>
<li lang="en-GB">Using npm</li>
<li lang="en-GB">Using Yarn</li>
<li lang="en-GB">Using pnpm</li>
<li lang="en-GB">More alternatives</li>
</ul>
<h1 id="_idParaDest-36" lang="en-GB"><a id="_idTextAnchor035"/>Technical Requirements</h1>
<p lang="en-GB">Some code examples for this chapter are available at  <a href="https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter03">https://github.com/PacktPublishing/Modern-Frontend-Development-with-Node.js/tree/main/Chapter03</a>.</p>
<p lang="en-GB">The CiA videos for this chapter can be accessed at <a href="http://bit.ly/3TmZr22">http://bit.ly/3TmZr22</a>.</p>
<h1 id="_idParaDest-37" lang="en-GB"><a id="_idTextAnchor036"/>Using npm</h1>
<p lang="en-GB">When<a id="_idIndexMarker090"/> you install Node.js from the official sources, you get a bit more than just Node.js. For convenience, Node.js will also add a few more programs and settings to your system. One of the most important additions is a tool called npm. Originally, npm was intended to stand for <em class="italic" lang="">Node.js Package Manager</em>, but today, it is essentially its own standalone name.</p>
<p lang="en-GB">The goal of npm is to allow developers to manage third-party dependencies. This includes installing and updating packages, as well as handling their versioning and transitive dependencies. A transitive dependency is established when dependencies that are installed also include dependencies, which therefore need to be installed, too.</p>
<p lang="en-GB">For <code>npm</code> to know what dependencies exist and what their dependencies are, the npm registry was created. It is a web service that hosts all packages on a file server.</p>
<p class="callout-heading" lang="en-GB">Changing the used npm registry</p>
<p class="callout" lang="en-GB">Today, many npm registries exist – but<a id="_idIndexMarker091"/> only the official one located at <a href="https://registry.npmjs.org/">https://registry.npmjs.org/</a> is used by default. To change the registry consistently, a special file, <code>.npmrc</code>, needs to be created. If the file is created in the home directory, then the change applies to all usages. Otherwise, this file could also be created next to a <code>package.json</code> – only being applied to the designated project. Finally, to only temporarily use another registry, the <code>--registry</code> command-line flag can be used. The format of the <code>.npmrc</code> file is outlined at <a href="https://docs.npmjs.com/cli/v8/configuring-npm/npmrc">https://docs.npmjs.com/cli/v8/configuring-npm/npmrc</a>.</p>
<p lang="en-GB">To use packages from the npm registry, we’ll need to use the <code>npm</code> command-line utility. In fact, the first thing we should do when we copy or clone the source code of a Node.js project is to run <code>npm install</code> in the directory of the project’s <code>package.json</code>:</p>
<pre class="console" lang="en-GB">
$ npm install</pre>
<p lang="en-GB">This will install all packages that are mentioned as runtime and development dependencies in the <code>package.json</code>. The packages are downloaded from the configured npm registry and then stored in the <code>node_modules</code> directory. It is good practice to avoid adding the <code>node_modules</code> directory to your source control. For instance, for Git, you should add <code>node_modules</code> to your repository’s <code>.gitignore</code> file. There are several reasons for this – for example, the installation might be platform-specific or the installation may be reproducible anyway.</p>
<p lang="en-GB">The <code>npm</code> command-line utility <a id="_idIndexMarker092"/>comes with a set of integrated commands – such as the previously shown <code>install</code> command. To see what commands are available to you, the utility can be used with the <code>--</code><code>help</code> flag:</p>
<pre class="console" lang="en-GB">
$ npm --help

Usage: npm &lt;command&gt;

where &lt;command&gt; is one of:

    access, adduser, audit, bin, bugs, c, cache, ci, cit,

    clean-install, [...], v, version, view, whoami

npm &lt;command&gt; -h  quick help on &lt;command&gt;</pre>
<p lang="en-GB">The <code>--help</code> flag also works in combination with a specific command. If you want to know which options exist for the <code>install</code> command, you can just type the following:</p>
<pre class="console" lang="en-GB">
$ npm install --help

npm install (with no args, in package dir)

[...]

npm install &lt;github username&gt;/&lt;github project&gt;

aliases: i, isntall, add

common options: [--save-prod|--save-dev|--save-optional] [--save-exact] [--no-save]</pre>
<p lang="en-GB">The principle of getting context-specific help is vital to many command-line utilities. All of the package managers that we’ll look at in this chapter feature this approach. In the end, for us as users, this has some advantages. Instead of needing to look up the online documentation, other books, or tutorials to see the syntax for a command every time, we can just get all the required information directly in the command line which is tailored to the specific version that we use.</p>
<p lang="en-GB">A <a id="_idIndexMarker093"/>command that is highly useful is <code>init</code>. While <code>install</code> is great to use for existing projects, <code>init</code> can be used to create a new project. When you run <code>npm init</code>, you’ll be guided through all the options in a kind of survey. The result is shown as follows:</p>
<pre class="console" lang="en-GB">
$ npm init

package name: (my-project)

version: (1.0.0)

description: This is my new project

git repository:

author: Florian Rappl

license: (ISC) MIT

About to write to /home/node/my-project/package.json:

{

  "name": "my-project",

  "version": "1.0.0",

  "description": "This is my new project",

  "keywords": [],

  "scripts": {

    "test": "echo \"Error: no test specified\" &amp;&amp; exit 1"

  },

  "main": "index.js",

  "author": "Florian Rappl",

  "license": "MIT"

}

Is this OK? (yes) yes</pre>
<p lang="en-GB">An <a id="_idIndexMarker094"/>alternative would be to specify the <code>-y</code> flag. This way, all the defaults will be taken – a much quicker alternative if you just want to initialize a new project.</p>
<p lang="en-GB">The initializer function of npm can even be extended. If you provide another name after <code>npm init</code>, then npm will try to look for a package using the <code>create-</code> prefix. For instance, when you run <code>npm init react-app</code>, npm will look for a package called <code>create-react-app</code> and run it. Running a package refers to looking for a <code>bin</code> field in the package’s <code>package.json</code> file and using the given reference to start a new process.</p>
<p lang="en-GB">If you want to add dependencies to your project instead, you can use <code>npm install</code>, too. For instance, adding React as a dependency is <code>npm </code><code>install react</code>.</p>
<p lang="en-GB">The dependency life cycle also requires us to know when dependencies are outdated. For this purpose, npm offers the <code>npm </code><code>outdated</code> command:</p>
<pre class="console" lang="en-GB">
$ npm outdated

Package                  Current   Wanted   Latest  Location

@types/node              16.11.9  17.0.40  17.0.40  pilet-foo

react                     17.0.2   17.0.2   18.1.0  pilet-foo

typescript                 4.5.2    4.7.3    4.7.3  pilet-foo</pre>
<p lang="en-GB">The command only shows packages that have a more recent release than the currently installed version. In some cases, that is fine – that is, when the current version matches the wanted version. In other cases, running <code>npm update</code> will actually update the installed version.</p>
<p class="callout-heading" lang="en-GB">Using different versions of npm</p>
<p class="callout" lang="en-GB">npm is already packaged together with Node.js. Therefore, each release of Node.js also selects a version of npm. For instance, Node.js 14 was bundled with npm 6. In Node.js 15, npm 7 was included. With Node.js 16 onward, you’ll get npm 8. One way to stay flexible is to use <strong class="bold" lang="">nvm</strong> instead. nvm is a<a id="_idIndexMarker095"/> small tool that allows you to select the version of Node.js to use. It can also be used to change the default version and quickly update and install new versions of Node.js and npm. More information is available at <a href="https://github.com/nvm-sh/nvm">https://github.com/nvm-sh/nvm</a>.</p>
<p lang="en-GB">npm also <a id="_idIndexMarker096"/>provides a lot of useful, convenient features – for example, to improve security. The <code>npm audit</code> command checks the currently installed packages against an online database containing security vulnerabilities. Quite often, a fix in vulnerable packages is just one call of <code>npm audit --fix</code> flag away. Furthermore, using a command such as <code>npm view</code> – for example, in <code>npm view react</code> – we can directly interact with the npm registry containing most of the publicly available packages.</p>
<p lang="en-GB">While the npm registry is a great source for packages, the <code>npm</code> command-line utility is not the only way to use it. In fact, the API of the web service is public and could be used by anyone – or any program for that matter.</p>
<p lang="en-GB">One of the first companies to use a public API of the npm registry was Facebook. They suffered from slow installation times in their large projects and wanted to improve on this by providing a better algorithm to actually resolve the dependencies of a project – especially transitive dependencies. The result was a new package manager named <strong class="bold" lang="">Yarn</strong>.</p>
<h1 id="_idParaDest-38" lang="en-GB"><a id="_idTextAnchor037"/>Using Yarn</h1>
<p lang="en-GB">The <a id="_idIndexMarker097"/>issue with the original npm package resolution algorithm was that it was created in a resilient but naïve way. This does not mean that the algorithm was simple. Rather, here, we refer to the fact that no exotic tricks or experience optimizations have been considered. Instead of trying to optimize (that is, lower) the number of packages available on the local disk, it was designed to put the packages into the same hierarchy as they were declared in. This results in a filesystem view as shown in <em class="italic" lang="">Figure 3</em><em class="italic" lang="">.1</em>:</p>
<div><div><img alt="Figure 3.1 – Example filesystem snapshot after installing packages using npm " src="img/Figure_3.1_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 – Example filesystem snapshot after installing packages using npm</p>
<p lang="en-GB">The <a id="_idIndexMarker098"/>naïve way of handling package installations is certainly a great way to ensure that everything is installed correctly, but not ideal in terms of performance. Looking at <em class="italic" lang="">Figure 3</em><em class="italic" lang="">.1</em>, there may be some optimizations possible.</p>
<p lang="en-GB">Let’s add some example package names and versions to <em class="italic" lang="">Figure 3</em><em class="italic" lang="">.1</em> to see the opportunities for optimization. In <em class="italic" lang="">Figure 3</em><em class="italic" lang="">.2</em>, the same snapshot is shown – just with example package names:</p>
<div><div><img alt="Figure 3.2 – Filesystem snapshot with example package names after npm installation " src="img/Figure_3.2_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Filesystem snapshot with example package names after npm installation</p>
<p lang="en-GB">Instead <a id="_idIndexMarker099"/>of duplicating the <code>bar</code> dependency, it could be just used once. The <code>foo</code> dependency, on the other hand, has to be duplicated due to conflicting versions. Other transitive dependencies, such as <code>abc</code> or <code>def</code>, can be brought to the top level.</p>
<p lang="en-GB">The resulting image is shown in <em class="italic" lang="">Figure 3</em><em class="italic" lang="">.3</em>. This flattens the structure where possible. This optimization was key to the first version of Yarn. Actually, it was so successful that npm improved its algorithm, too. Today, npm resolves the packages in a similar way to the sketch shown in <em class="italic" lang="">Figure 3</em><em class="italic" lang="">.3</em>:</p>
<div><div><img alt="Figure 3.3 – Filesystem snapshot with example package names after installation using Yarn " src="img/Figure_3.3_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.3 – Filesystem snapshot with example package names after installation using Yarn</p>
<p lang="en-GB">For <a id="_idIndexMarker100"/>the team at Yarn, the optimizations gained were not enough. They started to look for different ways to improve even further. However, the more they looked, the more they were convinced that something completely new was needed to make any further enhancements.</p>
<p lang="en-GB">The result was introduced with <code>node_modules</code> directory. Instead, a special file called <code>.pnp.cjs</code> is created to give information on how the dependencies can be resolved. With the <code>.pnp.cjs</code> file, every package can be resolved – just as with <code>node_modules</code> beforehand.</p>
<p lang="en-GB">The specific location of the packages depends on the project’s settings. With Yarn 2, a new concept called <em class="italic" lang="">zero-installs</em> has been introduced. This way, each dependency will be available within the project – just in a <code>.yarn/cache</code> subfolder. To actually achieve zero-installs, the <code>.yarn</code> folder should be checked into source control. Now, when the project is cloned, no installation needs to be performed. The dependencies are already part of the repository.</p>
<p lang="en-GB">While <a id="_idIndexMarker101"/>most commands are very similar, Yarn takes a different approach to adding new dependencies. Here, dependencies are added using <code>yarn add</code> – for example, <code>yarn add react</code>. The installation of packages using the <code>yarn</code> command-line utility is quite similar to the previous usage with <code>npm</code>, though:</p>
<pre class="console" lang="en-GB">
$ yarn install

<img alt="" src="img/01.png"/> YN0000: ┌ Resolution step

<img alt="" src="img/01.png"/> YN0000: └ Completed in 0s 634ms

<img alt="" src="img/01.png"/> YN0000: ┌ Fetch step

<img alt="" src="img/01.png"/> YN0013: │ js-tokens@npm:4.0.0 can't be found in the cache and will be fetched from the remote registry

<img alt="" src="img/01.png"/> YN0013: │ loose-envify@npm:1.4.0 can't be found in the cache and will be fetched from the remote registry

<img alt="" src="img/01.png"/> YN0013: │ react-dom@npm:18.1.0 can't be found in the cache and will be fetched from the remote registry

<img alt="" src="img/01.png"/> YN0013: │ react@npm:18.1.0 can't be found in the cache and will be fetched from the remote registry

<img alt="" src="img/01.png"/> YN0013: │ scheduler@npm:0.22.0 can't be found in the cache and will be fetched from the remote registry

<img alt="" src="img/01.png"/> YN0000: └ Completed

<img alt="" src="img/01.png"/> YN0000: ┌ Link step

<img alt="" src="img/01.png"/> YN0000: └ Completed

<img alt="" src="img/01.png"/> YN0000: Done in 0s 731ms</pre>
<p lang="en-GB">In <em class="italic" lang="">Figure 3</em><em class="italic" lang="">.4</em>, the new PnP mechanism is shown using the previous example. By using fully qualified names consisting of the package name and version, unique identifiers are created, allowing multiple versions of the same package to be located in a flat structure.</p>
<p lang="en-GB">The <a id="_idIndexMarker102"/>downside of the PnP mechanism is the custom resolution method, which requires some patching in Node.js. The standard resolution mechanism of Node.js uses <code>node_modules</code> to actually find modules within packages. The custom resolution method teaches Node.js to use a different directory with a different structure to find modules:</p>
<div><div><img alt="Figure 3.4 – Filesystem snapshot with example package names after installation using Yarn PnP " src="img/Figure_3.4_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.4 – Filesystem snapshot with example package names after installation using Yarn PnP</p>
<p lang="en-GB">While using a custom resolution method is not a problem for many packages, some may depend on the classic structure involving <code>node_modules</code> with packages just resolving to directories and files. In PnP, however, the structure is flat, with each package being a zip archive.</p>
<p lang="en-GB">As of today, many plugins and patches are available for packages to be compatible with PnP. Many – especially less popular – packages are still not usable with PnP. Luckily, Yarn 3 fixed many of these issues, providing a compatibility mode that works for most of these problematic packages. At the end of the day, it’s, unfortunately, mostly a matter of trial and <a id="_idIndexMarker103"/>error. Luckily, Yarn PnP is not the only solution that exists for speeding up npm even more.</p>
<p lang="en-GB">Even before Yarn 2 with PnP was released, other developers started thinking of alternative strategies to speed up installation times and preserve network bandwidth and storage capacity. The best-known attempt is a utility called pnpm.</p>
<h1 id="_idParaDest-39" lang="en-GB"><a id="_idTextAnchor038"/>Using pnpm</h1>
<p lang="en-GB">The <a id="_idIndexMarker104"/>approach of pnpm feels a bit like the original package resolution of npm. Here, each package is essentially isolated and puts its own dependencies into a local <code>node_modules</code> subfolder.</p>
<p lang="en-GB">There is, however, one crucial difference: instead of having a hard copy of each dependency, the different dependencies are made available through symbolic links. The advantage of this approach is that every dependency only needs to be resolved once per system.</p>
<p lang="en-GB">The other advantage is that for most packages everything is as it should be. There is nothing hiding behind an archive or via some custom mapping defined by a module that would run in the beginning. The whole package resolution just works. The exception to this rule is packages that use their path to find other packages or work against a root directory. Since the physical location of the packages is global, and therefore different from the project’s location, these approaches do not work with pnpm.</p>
<p lang="en-GB">Installing packages with the <code>pnpm</code> command-line utility works very similarly to <code>npm</code>:</p>
<pre class="console" lang="en-GB">
$ pnpm install

Packages: +5

+++++

Packages are hard linked from the content-addressable store to the virtual store.

  Content-addressable store is at: /home/rapplf/.local/share/pnpm/store/v3

  Virtual store is at:             node_modules/.pnpm

dependencies:

+ react 18.1.0

+ react-dom 18.1.0

Progress: resolved 5, reused 2, downloaded 3, added 5, done</pre>
<p lang="en-GB">Overall, most<a id="_idIndexMarker105"/> commands of the <code>pnpm</code> command-line utility have either the same or a very similar name to their <code>npm</code> counterpart.</p>
<p lang="en-GB">On installation, <code>pnpm</code> adds the unavailable packages to a local store. A local store is just a special directory from <code>pnpm</code> that is not bound to your project, but rather your user account. It is pnpm’s package storage that is actually the source of its miraculous performance. Afterward, <code>pnpm</code> creates all the symbolic links to wire everything together. The result looks similar to <em class="italic" lang="">Figure 3</em><em class="italic" lang="">.5</em>:</p>
<div><div><img alt="Figure 3.5 – Filesystem snapshot with example package names after installation using pnpm " src="img/Figure_3.5_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.5 – Filesystem snapshot with example package names after installation using pnpm</p>
<p lang="en-GB">Only direct dependencies are listed in the <code>node_modules</code> folder. The content of each subfolder is not available in the original <code>node_modules</code> – rather, in the global <code>.pnpm</code> cache. The same is then applied to all sub-dependencies.</p>
<p lang="en-GB">The result is a<a id="_idIndexMarker106"/> massive performance boost. Already, on a clean install, <code>pnpm</code> is faster than the competition. However, in other scenarios, the relative gap may be even larger. In <em class="italic" lang="">Figure 3</em><em class="italic" lang="">.6</em>, the performance of <code>pnpm</code> is compared against other package managers. Lower bars refer to better performance:</p>
<div><div><img alt="Figure 3.6 – Performance benchmark comparing pnpm against npm, Yarn, and Yarn with PnP (source: https://pnpm.io/benchmarks)" src="img/Figure_3.6_B18989.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.6 – Performance benchmark comparing pnpm against npm, Yarn, and Yarn with PnP (source: https://pnpm.io/benchmarks)</p>
<p lang="en-GB">Only in the <a id="_idIndexMarker107"/>case of an up-to-date installation can npm be considered the fastest option. In other cases, pnpm and sometimes Yarn PnP can be considered faster. With this in mind, the key question is whether there are other alternatives to consider. Let’s see what else we can do to simplify dependency management.</p>
<h1 id="_idParaDest-40" lang="en-GB"><a id="_idTextAnchor039"/>More alternatives</h1>
<p lang="en-GB">There is no strict requirement when using a package manager. Theoretically, it does not matter where the code comes from. You could, for instance, download the packages directly, extract them, and refer to them via their local path.</p>
<p lang="en-GB">Alternatively, a system<a id="_idIndexMarker108"/> such as <strong class="bold" lang="">Deno</strong> could be interesting. On the surface, Deno is quite similar to Node.js. However, there are a few crucial differences under the hood. The most striking one is that there is no package manager for Deno. Instead, packages are just URLs that are resolved once needed. This way, the package installation is just a download – which happens to run when needed.</p>
<p class="callout-heading" lang="en-GB">Deno in a nutshell</p>
<p class="callout" lang="en-GB">Deno was created by Ryan Dahl – the creator of Node.js. As such, Deno shares many features with Node.js but deviates in some aspects. Deno aims to be a lot more compatible with JavaScript running in the browser than Node.js. Deno also tries to be secure by default. When running a script with Deno, the provided security context has to be defined by the user. Otherwise, access to the network or the filesystem may be impossible for the code running. You can get more<a id="_idIndexMarker109"/> information at <a href="https://deno.land/">https://deno.land/</a>.</p>
<p lang="en-GB">Another option is to use a tool that actually leverages one of the existing package managers underneath but in a more efficient or user-friendly fashion. One example in this category is <strong class="bold" lang="">Turborepo</strong>.</p>
<p lang="en-GB">Turborepo works<a id="_idIndexMarker110"/> with any of the popular package managers and claims to provide improved performance for many tasks, including package installation and updates. The most efficient way, however, to utilize Turborepo is to use it for a so-called monorepo, which will be discussed in greater length in <a href="B18989_09.xhtml#_idTextAnchor088"><em class="italic" lang="">Chapter 9</em></a>, <em class="italic" lang="">Structuring Code </em><em class="italic" lang="">in Monorepos</em>.</p>
<p lang="en-GB">Besides the question of how the packages can be installed, updated, and published, the other part of package management is the package registry. In this space, you can choose from many commercial offerings to open source projects<a id="_idIndexMarker111"/> such as <strong class="bold" lang="">Verdaccio</strong>. Having your own package registry can be great for larger projects, where missing dependencies or downtimes of the public npm registry may be problematic.</p>
<p lang="en-GB">In general, there are not many alternatives to the established package managers npm, Yarn, and pnpm. While optimizing the use of package managers or using cached registries instead might be appealing, they are certainly not worth the effort for most projects. Right now, npm and Yarn seem to be most appealing in the broadest range of scenarios, whereas pnpm could be considered the desired choice for really big repositories.</p>
<h1 id="_idParaDest-41" lang="en-GB"><a id="_idTextAnchor040"/>Summary</h1>
<p lang="en-GB">In this chapter, you learned how to use a package manager to handle everything related to packages. You’ve leveraged the default <code>npm</code> command-line utility. You got in touch with the most important alternatives, Yarn and pnpm. You should know what Yarn brings to the table – after all, PnP and zero-installs are neat features. Furthermore, you checked out some alternatives and learned about custom registries and repository task runners such as Turborepo.</p>
<p lang="en-GB">At this point, you have everything to clone and run existing Node.js projects. You can install new dependencies, check for outdated dependencies, and update them. This gives you the power to integrate all of the over-a-million packages that have been published over the years in the npm registry.</p>
<p lang="en-GB">In the next chapter, we will discuss how different flavors of JavaScript, such as more modern specifications or languages that use JavaScript as a compilation target, can be used in Node.js.</p>
</div>


<div><h1 id="_idParaDest-42" lang="en-GB"><a id="_idTextAnchor041"/>Part 2: Tooling</h1>
<p lang="en-GB">In this part, you’ll strengthen your knowledge of the Node.js ecosystem by getting in touch with a variety of tools and utilities. You’ll learn how you can use different flavors of JavaScript in Node.js. Examples here include TypeScript and Flow. You’ll also see which code verification and style checkers exist and how to use them.</p>
<p lang="en-GB">The main focus of this part is to enable you to set up and maintain a new web development project from scratch. This also includes knowledge about quality assurance. As part of these topics, utilities such as Jest or Playwright are discussed.</p>
<p lang="en-GB">This part of the book comprises the following chapters:</p>
<ul>
<li lang="en-GB"><a href="B18989_04.xhtml#_idTextAnchor042"><em class="italic" lang="">Chapter 4</em></a>, <em class="italic" lang="">Using Different Flavors of JavaScript</em></li>
<li lang="en-GB"><a href="B18989_05.xhtml#_idTextAnchor049"><em class="italic" lang="">Chapter 5</em></a>, <em class="italic" lang="">Enhancing Code Quality with Linters and Formatters</em></li>
<li lang="en-GB"><a href="B18989_06.xhtml#_idTextAnchor057"><em class="italic" lang="">Chapter 6</em></a>, <em class="italic" lang="">Building Web Apps with Bundlers</em></li>
<li lang="en-GB"><a href="B18989_07.xhtml#_idTextAnchor067"><em class="italic" lang="">Chapter 7</em></a>, <em class="italic" lang="">Improving Reliability with Testing Tools</em></li>
</ul>
</div>
<div><div></div>
</div>
</body></html>