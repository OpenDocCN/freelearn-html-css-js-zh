- en: Chapter 3. Moving Sprites Around the Screen – An Endless Runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A while ago, endless runners started with a game called **Helicopter** where
    you had to drive a helicopter through an endless cave, just pressing a button
    to give it thrust.
  prefs: []
  type: TYPE_NORMAL
- en: Then, games became more complex until mobile gaming started to spread. Endless
    runners started gaining a new popularity due to their simple one tap control.
    The player is just required to touch anywhere when needed to control a helicopter.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you are going to build an endless runner that features a spaceship
    flying through a city while avoiding dangerous asteroids.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the making of this game, you will learn, among other things, how to:'
  prefs: []
  type: TYPE_NORMAL
- en: Scroll big images to give an idea on an endless background
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Schedule events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Control a frame rate
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check collision between sprites
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a simple particle system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Move sprites manually or using actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Moreover, although this is supposed to be a cross-platform game, you will also
    learn about mouse-only controls. It will be easy to change them to touch or tap
    controls as you already met them during the making of Concentration. All in all,
    it's something you can find useful should you plan a desktop-only browser game.
  prefs: []
  type: TYPE_NORMAL
- en: Loading and placing graphic resources
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You need to build the game over the blueprint created in the first chapter,
    so here is the content of the `assets` folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading and placing graphic resources](img/0075OS_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You can see the spaceship, the asteroid you have to avoid, a small circle to
    create particle effects, and the scrolling background.
  prefs: []
  type: TYPE_NORMAL
- en: You will spend some time trying to understand the background. As the game is
    480 x 320 pixels, your background should be at least *480*2=960* pixels wide,
    which is made by two 480 x 320 seamless images.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the following image, you will be able to give the player the possibility
    to fly through an endless cityscape:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Loading and placing graphic resources](img/0075OS_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'All these images need to be preloaded by the `loadassets.js` file located in
    `src`, which will become:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'You also need to make some changes to `main.js` because this time you want
    a game in the landscape mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The highlighted line shows the new resolution settings.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an endless scrolling background
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now, it''s time to add the cityscape background, which will scroll endlessly
    and seamlessly. Finally, you can start editing `gamescript.js`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: You might think that's a lot of code, but most of it is just a copy and paste
    of what you've already seen in the making of the Concentration game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s have a look at the interesting new stuff:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: These three variables will represent the background sprite, the main game layer,
    and the scrolling speed in pixels per frame. This means you want the background
    to scroll by one pixel at each frame, that is, 60 pixels per second.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it should be really clear why you are working with a fixed frame rate.
    On fast bowsers such as Chrome with a 120 fps refresh, you will able to see the
    background scrolling at the same speed as on the Firefox 60 fps browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `gameScene` code does not contain anything new, so let''s jump to game
    definition, which will introduce a new feature:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: After declaring a `ScrollingBG` class, you will extend the built-in `Sprite`
    class in the same way you did in the making of Concentration when you created
    the tiles; you can see a call to `scheduleUpdate` method.
  prefs: []
  type: TYPE_NORMAL
- en: Normally, a Cocos2d-JS game is static. It never updates. Like the previous Concentration
    game, if you leave the game alone for ages, nothing happens.
  prefs: []
  type: TYPE_NORMAL
- en: To help you add some actions, Cocos2d-JS allows you to schedule events that
    happen at a certain time.
  prefs: []
  type: TYPE_NORMAL
- en: The easiest way to schedule an event is the `scheduleUpdate` method. It's just
    like saying you want to do something each time the game is refreshed, which in
    our case is every 1/60 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'When you call `scheduleUpdate`, a custom `update` function will be called at
    each frame:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: At the moment, you are just calling a custom method of your `ScrollingBG` new
    class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The definition of `ScrollingBG` is also quite simple if you got the basics
    of class inheritance explained in the previous chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Here, once you load and add the background image to the screen, you move it
    by the `scrollSpeed` pixels to the left, giving the feeling that it is moving
    to the right. Once you moved the background image by more than 480 pixels, that
    is, half of its length or the full length of your game resolution, you move it
    back by exactly 480 pixels to give the player the illusion of an infinite scrolling.
  prefs: []
  type: TYPE_NORMAL
- en: I could place a picture of what you get at this point, but it's much better
    if you test it yourself and see a beautiful scrolling background.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note this is just one way to move assets around the screen as Cocos2d-JS offers
    a set of methods to manage sprite positions. I will cover them when adding asteroids
    on the screen, but at the moment, let''s focus on the main actor of the game:
    the spaceship!'
  prefs: []
  type: TYPE_NORMAL
- en: Adding the spaceship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The spaceship you are going to add is just another sprite, but you are going
    to give it behavior like it was ruled by gravity.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let'' s add a couple of variables:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The `ship` variable will be the spaceship itself, whereas `gameGravity` is the
    force that will attract the spaceship toward the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, inside the `init` function in `game` declaration, you add the ship in
    the same way you added the background:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Then, in the `update` function (remember this function is automatically called
    at each frame). Thanks to the `scheduleUpdate` method, an `updateY` custom method
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: 'The creation of the ship itself does not differ much from just extending the
    `Sprite` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The spaceship is assigned an image and a custom attribute called `ySpeed`, initially
    set to zero from the `ctor` constructor.
  prefs: []
  type: TYPE_NORMAL
- en: Once it's placed on the stage, the `onEnter` function places it at `60`, `160`
    (remember its *x* position will never change). Then, the `setPosition` function,
    which is called at each frame by the game's `update` function adds `gameGravity`
    value to the ship's vertical speed (`ySpeed`) and updates its *y* position by
    adding speed to the current position.
  prefs: []
  type: TYPE_NORMAL
- en: This is the cheapest but quickest way to handle gravity, forces, and thrust
    (that will be introduced in the next step), and it works well in simple games
    like an endless runner.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, run the game and see what happens:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding the spaceship](img/0075OS_03_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You should see our previously created nice scrolling background and our poor
    spaceship falling down and disappearing off the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: 'You just learned the first rule of spaceship creation: *remember the engine*.'
  prefs: []
  type: TYPE_NORMAL
- en: Controlling the spaceship
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Players will be able to give thrust to the spaceship by holding the mouse or
    finger pressed on the screen.
  prefs: []
  type: TYPE_NORMAL
- en: As you should be able to detect when the player touches the screen, I am going
    to show you a mouse-only way to control the spaceship to make you learn something
    new. You are free to replace this way to control the ship with the one you prefer.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to manage ship control in just a few lines, first by adding a
    new global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: The `gameThrust` variable represents engine power, the force that will make
    the ship fly through the air.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are controlling the game with the mouse, so that''s how you change the
    `game` declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Unlike in the previous chapter, here you added the listener on the fly without
    declaring it as a variable and then calling it. It's basically the same as before,
    it's just that now you are working with the mouse, so you must define the event
    type as `cc.EventListener.MOUSE`. The events are `onMouseDown` when the player
    presses the mouse and `onMouseUp` when the mouse is released. Now, with `onMouseDown`
    and `onMouseUp`, you just turn the ship's engine to on or off, which is actually
    a Boolean `ship` attribute called `engineOn`.
  prefs: []
  type: TYPE_NORMAL
- en: 'What are you going to do with such an attribute? You just update the ship''s
    vertical speed just like you did with the gravity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: This was really easy. First, you set `engineOn` to `false` and according to
    its value, you decide whether you have to add `gameThrust` to `ySpeed`.
  prefs: []
  type: TYPE_NORMAL
- en: Test the game and try to control the ship by pressing and releasing the mouse
    button.
  prefs: []
  type: TYPE_NORMAL
- en: '![Controlling the spaceship](img/0075OS_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Finally, the spaceship can fly through the city in peace and harmony. Unfortunately,
    game designers are a bit mad and they could decide to make some changes to spaceship
    plans by adding a belt of deadly asteroids big enough to smash a spaceship.
  prefs: []
  type: TYPE_NORMAL
- en: Adding asteroids
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As the spaceship flies from left to right (actually it does not, but that's
    how it seems), you have to add asteroids, which enter the screen from the right-hand
    side of the game.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you can just place some asteroid sprites on the right-hand side of the
    screen and make them move to the left-hand side just like you did with the background
    cityscape, but you wouldn't learn anything new if you did that, so let's see another
    way to manage sprite movement.
  prefs: []
  type: TYPE_NORMAL
- en: First things first, before you can move an asteroid, you have to create it.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this game, a new asteroid will appear every half a second, so it''s time
    to schedule another event in the `game` class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To schedule an event at a given interval, you use the `schedule` method that
    works like `scheduleUpdate`, but this time you can also define which function
    to call, `addAsteroid`, in this case, and the interval of time in seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s easy to see what `addAsteroid` does: it adds an asteroid by extending
    the `Sprite` class in the same way you saw before. You also added a `removeAsteroid`
    function because you don''t want asteroids to remain in the game forever; you
    will see how to remove them once they are not necessary anymore.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is the `Asteroid` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Run the game and you will see an asteroid belt flying towards the ship following
    a random path.
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding asteroids](img/0075OS_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There is a lot of stuff in a simple class declaration, so let's take a closer
    look at the preceding code.
  prefs: []
  type: TYPE_NORMAL
- en: The `ctor` constructor simply creates the instance and assigns it an image,
    as usual. So, the magic happened somewhere else.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `onEnter` event places the asteroid on the right-hand side of the screen
    at a random height; the next line is responsible for the whole animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Cocos2d-JS allows you to create actions, which in this case basically are tweens
    and can be seen as things to do at a given point in time.
  prefs: []
  type: TYPE_NORMAL
- en: This action should move to a given random point on the left-hand side of the
    screen in 2.5 seconds. That's it. It doesn't matter how Cocos2d-JS will perform
    this task; you just say *bring this asteroid and make it fly to that point*.
  prefs: []
  type: TYPE_NORMAL
- en: The power of these actions is awesome and you will deal with it in more examples
    in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the action is created, you make Cocos2d-JS execute it with:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The asteroid travel is done. You should also see whether there's a `scheduleUpdate`
    call because you want to remove asteroids once they exit from the left-hand side
    of the screen; so, in the `update` function (remember, every `scheduleUpdate`
    method calls an `update` function at each frame). You simply check when the asteroid
    is outside the screen and eventually remove it with the `removeAsteroid` method
    you created before.
  prefs: []
  type: TYPE_NORMAL
- en: That was really easy, wasn't it?
  prefs: []
  type: TYPE_NORMAL
- en: Too bad! The asteroids and spaceship do not collide yet, but don't worry, it
    won't take more than a couple of lines.
  prefs: []
  type: TYPE_NORMAL
- en: Asteroid versus spaceship collision
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The easiest way to see whether two sprites collide, which is also the most used
    in simple fast paced arcade games like the one you are currently building, is
    by checking whether sprite bounding boxes intersect somehow.
  prefs: []
  type: TYPE_NORMAL
- en: 'The bounding box of an image is the smallest rectangle, which entirely contains
    the image itself, and the principle of this method can be explained by the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Asteroid versus spaceship collision](img/0075OS_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'In this 4x zoomed image, you can see the three different ways the bounding
    box collision will react:'
  prefs: []
  type: TYPE_NORMAL
- en: Bounding boxes do not intersect. There is no collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bounding boxes intersect. There is a collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bounding boxes intersect, although there isn't a collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In sophisticated collision engines, to prevent case 3, once bounding boxes intersect,
    a pixel perfect collision is performed, but this is CPU-consuming and at the moment,
    you don't want such a high level of precision.
  prefs: []
  type: TYPE_NORMAL
- en: So, if you want to make case 3 occur as seldom as possible, you can draw your
    sprites with shapes as close to a rectangle as possible, or you can consider the
    intersection between two boxes a little smaller than the original bounding boxes.
  prefs: []
  type: TYPE_NORMAL
- en: Remember, players want to be forgiven, so if it's just a matter of a couple
    of pixels, it's better not to see an actual collision rather than to see a false
    positive collision.
  prefs: []
  type: TYPE_NORMAL
- en: 'Having said that, here is how Cocos2d-JS will help you to manage bounding box
    collisions working on asteroid''s `update` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `getBoundingBox` method returns a rectangle, which is the actual sprite
    bounding box, and the `rectIntersectsRect` method checks whether two rectangles
    intersect.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is easy. Collision detection occurs in two lines. Then, the asteroid is
    removed and the `restartGame` function is called.This function just resets spaceship''s
    variables, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Now, test the game and you will see the spaceship position being reset once
    it collides with an asteroid. This way, the game becomes a bit punishing when
    you die, as you will often respawn in front of an asteroid, causing an immediate
    death. Remember, players want to be forgiven.
  prefs: []
  type: TYPE_NORMAL
- en: Invulnerability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This feature has nothing to do with the new Cocos2d-JS stuff, it's just some
    polishing in game design, but remember polishing is always better than adding
    features.
  prefs: []
  type: TYPE_NORMAL
- en: People played Angry Birds series to death because it's polished, not because
    wooden blocks did break exactly like a real-world wooden block would.
  prefs: []
  type: TYPE_NORMAL
- en: So, after the player smashed the spaceship into an asteroid, let's make the
    spaceship invulnerable for a limited period of time; let the player see the ship
    cannot be destroyed by making it flash.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are going to add an `invulnerability` attribute to the spaceship in the
    ship''s `ctor` constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'When `invulnerability` is set to zero, this means the spaceship is not invulnerable
    and can be destroyed by asteroids. You have to add this case to Asteroid''s `update`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, collision is processed only if invulnerability is set to zero,
    and when you restart the game in the `restartGame` function, you assign it a high
    value, let''s say 100:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This means that now the spaceship cannot be destroyed. To give the player a
    visual feedback and decrease invulnerability, let''s add two lines to ship''s
    `updateY` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: If invulnerability is greater than zero, decrease it and make the spaceship
    flash by switching its opacity from fully opaque (255) to completely transparent
    (0).
  prefs: []
  type: TYPE_NORMAL
- en: The `setOpacity` and `getOpacity` methods handle sprite's opacity.
  prefs: []
  type: TYPE_NORMAL
- en: Test the game and after you run into an asteroid, you should have *God mode*
    enabled for about a second and a half.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing the spaceship from flying off the screen
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The last thing you need to do is prevent the spaceship from flying off the screen.
    If you press the mouse for too long, or if you don't press the mouse at all, your
    ship will fly respectively off the top or the bottom of the screen.
  prefs: []
  type: TYPE_NORMAL
- en: You need to prevent the ship from flying off the screen by punishing it with
    death.
  prefs: []
  type: TYPE_NORMAL
- en: 'Just add these two lines to the ship''s `updateY` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: No need to comment them, it's just an `if` statement that checks for the spaceship's
    vertical position.
  prefs: []
  type: TYPE_NORMAL
- en: Adding particles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Do you remember that in your `assets` folder, there's a yellow circle called
    `particle.png`? You will use it to create a nice particle effect to simulate the
    spaceship engine.
  prefs: []
  type: TYPE_NORMAL
- en: Discussing particle systems is beyond the scope of this book, so for more detailed
    information as well as complete particle generation software compatible with Cocos2d-JS,
    take a look at [https://71squared.com/particledesigner](https://71squared.com/particledesigner).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, you are just going to add the simplest particle effect ever, but you
    will see it has a visual appeal like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Adding particles](img/0075OS_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'First, create a new global variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'The emitter will be created and configured in game''s `init` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that the emitter is created with a **sun** effect, an image
    is assigned to it, and a start and end image size are given to it.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is enough to generate an ever working particle emitter, but you also need
    it to follow the spaceship only when the engines are working by updating the ship''s
    `updateY` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Here, you just move the emitter to spaceship's tail when the engine is on, and
    outside the screen when the engine is off. Cheap and dirty, but it's working.
  prefs: []
  type: TYPE_NORMAL
- en: Test the game; you should see an eye-candy effect when engines are on, just
    like in the image you saw before.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned how to create tweens, collisions, and so on. You
    also learned how to pass through particle generation and create a complete working
    game.
  prefs: []
  type: TYPE_NORMAL
- en: There is something you should do to get more familiar with Cocos2d-JS, that
    is, use what you learned until now and improve the game. You can try to switch
    the control mode from mouse-driven to touch-driven, display text with the maximum
    distance travelled without hitting an asteroid, and increase the difficulty level
    every *n* seconds without hitting asteroids by making asteroids faster or appear
    more often.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you are ready to dive into the next chapter where touch controls will become
    more interactive thanks to swipe detection.
  prefs: []
  type: TYPE_NORMAL
