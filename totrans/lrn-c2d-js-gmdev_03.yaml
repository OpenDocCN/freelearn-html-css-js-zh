- en: Chapter 3. Moving Sprites Around the Screen – An Endless Runner
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 在屏幕上移动精灵 - 无尽跑酷
- en: A while ago, endless runners started with a game called **Helicopter** where
    you had to drive a helicopter through an endless cave, just pressing a button
    to give it thrust.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，无尽跑酷从一个名为**直升机**的游戏开始，你必须驾驶直升机穿过无尽的洞穴，只需按一个按钮给它推力。
- en: Then, games became more complex until mobile gaming started to spread. Endless
    runners started gaining a new popularity due to their simple one tap control.
    The player is just required to touch anywhere when needed to control a helicopter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，游戏变得更加复杂，直到移动游戏开始传播。由于简单的单次点击控制，无尽跑酷开始获得新的流行。玩家只需在需要时触摸任何地方来控制直升机。
- en: In this chapter, you are going to build an endless runner that features a spaceship
    flying through a city while avoiding dangerous asteroids.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将构建一个无尽跑酷游戏，其中一艘太空船在城市中飞行，同时避开危险的陨石。
- en: 'In the making of this game, you will learn, among other things, how to:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在制作这个游戏的过程中，你将学习如何做其他事情，例如：
- en: Scroll big images to give an idea on an endless background
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 滚动大图像以在无尽背景上给出一个概念
- en: Schedule events
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 安排事件
- en: Control a frame rate
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制帧率
- en: Check collision between sprites
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查精灵之间的碰撞
- en: Create a simple particle system
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个简单的粒子系统
- en: Move sprites manually or using actions
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 手动移动精灵或使用动作
- en: Moreover, although this is supposed to be a cross-platform game, you will also
    learn about mouse-only controls. It will be easy to change them to touch or tap
    controls as you already met them during the making of Concentration. All in all,
    it's something you can find useful should you plan a desktop-only browser game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尽管这是一个跨平台游戏，你还将了解仅使用鼠标控制。当你已经遇到它们在制作注意力游戏时，将它们更改为触摸或点击控制将很容易。总的来说，如果你计划一个仅适用于桌面的浏览器游戏，这将是有用的东西。
- en: Loading and placing graphic resources
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加载和放置图形资源
- en: 'You need to build the game over the blueprint created in the first chapter,
    so here is the content of the `assets` folder:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在第一章中创建的蓝图上构建游戏，所以这里是`assets`文件夹的内容：
- en: '![Loading and placing graphic resources](img/0075OS_03_01.jpg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![加载和放置图形资源](img/0075OS_03_01.jpg)'
- en: You can see the spaceship, the asteroid you have to avoid, a small circle to
    create particle effects, and the scrolling background.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到太空船、你必须避免的陨石、一个小圆圈用于创建粒子效果，以及滚动背景。
- en: You will spend some time trying to understand the background. As the game is
    480 x 320 pixels, your background should be at least *480*2=960* pixels wide,
    which is made by two 480 x 320 seamless images.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 你将花一些时间尝试理解背景。由于游戏是480 x 320像素，你的背景至少应该是*480*2=960*像素宽，这是由两个480 x 320的无缝图像组成的。
- en: 'With the following image, you will be able to give the player the possibility
    to fly through an endless cityscape:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 通过以下图像，你将能够给玩家提供飞越无尽城市景观的可能性：
- en: '![Loading and placing graphic resources](img/0075OS_03_02.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_IMG
  zh: '![加载和放置图形资源](img/0075OS_03_02.jpg)'
- en: 'All these images need to be preloaded by the `loadassets.js` file located in
    `src`, which will become:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些图像都需要通过位于`src`的`loadassets.js`文件预加载，它将变成：
- en: '[PRE0]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You also need to make some changes to `main.js` because this time you want
    a game in the landscape mode:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你还需要对`main.js`做一些修改，因为这次你想要一个横幅模式的游戏：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The highlighted line shows the new resolution settings.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 突出的行显示了新的分辨率设置。
- en: Adding an endless scrolling background
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加无限滚动背景
- en: 'Now, it''s time to add the cityscape background, which will scroll endlessly
    and seamlessly. Finally, you can start editing `gamescript.js`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候添加城市景观背景了，它将无限且无缝地滚动。最后，你可以开始编辑`gamescript.js`：
- en: '[PRE2]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: You might think that's a lot of code, but most of it is just a copy and paste
    of what you've already seen in the making of the Concentration game.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会认为这有很多代码，但其中大部分只是复制和粘贴你在制作注意力游戏时已经看到的内容。
- en: 'Let''s have a look at the interesting new stuff:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看有趣的新内容：
- en: '[PRE3]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: These three variables will represent the background sprite, the main game layer,
    and the scrolling speed in pixels per frame. This means you want the background
    to scroll by one pixel at each frame, that is, 60 pixels per second.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这三个变量将代表背景精灵、主游戏层和每帧像素的滚动速度。这意味着你希望背景在每一帧滚动一个像素，即每秒60像素。
- en: Now, it should be really clear why you are working with a fixed frame rate.
    On fast bowsers such as Chrome with a 120 fps refresh, you will able to see the
    background scrolling at the same speed as on the Firefox 60 fps browser.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，应该非常清楚为什么你正在使用固定帧率。在像Chrome这样的快速浏览器上，其刷新率为120 fps，你将能够看到背景以与Firefox 60 fps浏览器相同的速度滚动。
- en: 'The `gameScene` code does not contain anything new, so let''s jump to game
    definition, which will introduce a new feature:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameScene`代码中没有包含任何新内容，所以让我们跳转到游戏定义，这将引入一个新特性：'
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: After declaring a `ScrollingBG` class, you will extend the built-in `Sprite`
    class in the same way you did in the making of Concentration when you created
    the tiles; you can see a call to `scheduleUpdate` method.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在声明了一个`ScrollingBG`类之后，你将像在制作集中注意力游戏时创建瓷砖那样扩展内置的`Sprite`类；你可以看到一个对`scheduleUpdate`方法的调用。
- en: Normally, a Cocos2d-JS game is static. It never updates. Like the previous Concentration
    game, if you leave the game alone for ages, nothing happens.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，Cocos2d-JS游戏是静态的。它永远不会更新。就像之前的集中注意力游戏一样，如果你长时间不玩游戏，什么都不会发生。
- en: To help you add some actions, Cocos2d-JS allows you to schedule events that
    happen at a certain time.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助你添加一些动作，Cocos2d-JS允许你安排在特定时间发生的事件。
- en: The easiest way to schedule an event is the `scheduleUpdate` method. It's just
    like saying you want to do something each time the game is refreshed, which in
    our case is every 1/60 seconds.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 安排事件的简单方法就是`scheduleUpdate`方法。这就像说你想在游戏刷新时做某事，在我们的例子中是每1/60秒。
- en: 'When you call `scheduleUpdate`, a custom `update` function will be called at
    each frame:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用`scheduleUpdate`时，一个自定义的`update`函数将在每一帧被调用：
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: At the moment, you are just calling a custom method of your `ScrollingBG` new
    class.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，你只是在调用你的`ScrollingBG`新类的自定义方法。
- en: 'The definition of `ScrollingBG` is also quite simple if you got the basics
    of class inheritance explained in the previous chapter:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你掌握了上一章中解释的类继承基础知识，`ScrollingBG`的定义也非常简单：
- en: '[PRE6]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Here, once you load and add the background image to the screen, you move it
    by the `scrollSpeed` pixels to the left, giving the feeling that it is moving
    to the right. Once you moved the background image by more than 480 pixels, that
    is, half of its length or the full length of your game resolution, you move it
    back by exactly 480 pixels to give the player the illusion of an infinite scrolling.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，一旦你加载并将背景图像添加到屏幕上，你通过`scrollSpeed`像素向左移动它，给人一种它在向右移动的感觉。一旦背景图像移动超过480像素，即其长度的一半或你的游戏分辨率的完整长度，你将精确地将其移动回480像素，给玩家一种无限滚动的错觉。
- en: I could place a picture of what you get at this point, but it's much better
    if you test it yourself and see a beautiful scrolling background.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我可以放一张你现在得到的图片，但最好是你亲自测试并看到美丽的滚动背景。
- en: 'Note this is just one way to move assets around the screen as Cocos2d-JS offers
    a set of methods to manage sprite positions. I will cover them when adding asteroids
    on the screen, but at the moment, let''s focus on the main actor of the game:
    the spaceship!'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这只是移动屏幕上资产的一种方法，因为Cocos2d-JS提供了一套管理精灵位置的方法。我将在添加屏幕上的小行星时介绍它们，但此时，让我们专注于游戏的主要角色：飞船！
- en: Adding the spaceship
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加飞船
- en: The spaceship you are going to add is just another sprite, but you are going
    to give it behavior like it was ruled by gravity.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 你将要添加的飞船只是一个另一个精灵，但你将给它像受重力规则支配的行为。
- en: 'First, let'' s add a couple of variables:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们添加几个变量：
- en: '[PRE7]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `ship` variable will be the spaceship itself, whereas `gameGravity` is the
    force that will attract the spaceship toward the bottom of the screen.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`ship`变量将是飞船本身，而`gameGravity`是吸引飞船向屏幕底部运动的力。'
- en: 'Then, inside the `init` function in `game` declaration, you add the ship in
    the same way you added the background:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`game`声明中的`init`函数内，你以添加背景的方式添加飞船：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Then, in the `update` function (remember this function is automatically called
    at each frame). Thanks to the `scheduleUpdate` method, an `updateY` custom method
    is called.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在`update`函数中（记住这个函数是自动在每一帧被调用的）。多亏了`scheduleUpdate`方法，一个名为`updateY`的自定义方法被调用。
- en: 'The creation of the ship itself does not differ much from just extending the
    `Sprite` class:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船本身的创建与仅仅扩展`Sprite`类没有太大区别：
- en: '[PRE9]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The spaceship is assigned an image and a custom attribute called `ySpeed`, initially
    set to zero from the `ctor` constructor.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 飞船被分配了一个图像和一个名为`ySpeed`的自定义属性，初始值由`ctor`构造函数设置为零。
- en: Once it's placed on the stage, the `onEnter` function places it at `60`, `160`
    (remember its *x* position will never change). Then, the `setPosition` function,
    which is called at each frame by the game's `update` function adds `gameGravity`
    value to the ship's vertical speed (`ySpeed`) and updates its *y* position by
    adding speed to the current position.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦它被放置在舞台上，`onEnter` 函数将其放置在 `60`，`160`（记住它的 *x* 位置永远不会改变）。然后，`setPosition`
    函数，它由游戏的 `update` 函数在每一帧调用，将 `gameGravity` 值添加到飞船的垂直速度 (`ySpeed`)，并通过向当前位置添加速度来更新其
    *y* 位置。
- en: This is the cheapest but quickest way to handle gravity, forces, and thrust
    (that will be introduced in the next step), and it works well in simple games
    like an endless runner.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这是处理重力、力和推力（将在下一步介绍）最便宜但最快的方法，并且在简单的游戏如无尽跑酷中效果良好。
- en: 'Now, run the game and see what happens:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，运行游戏并看看会发生什么：
- en: '![Adding the spaceship](img/0075OS_03_03.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![添加宇宙飞船](img/0075OS_03_03.jpg)'
- en: You should see our previously created nice scrolling background and our poor
    spaceship falling down and disappearing off the bottom of the screen.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到我们之前创建的漂亮的滚动背景和可怜的飞船正在向下坠落并消失在屏幕底部。
- en: 'You just learned the first rule of spaceship creation: *remember the engine*.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚刚学会了宇宙飞船创建的第一条规则：*记住引擎*。
- en: Controlling the spaceship
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制宇宙飞船
- en: Players will be able to give thrust to the spaceship by holding the mouse or
    finger pressed on the screen.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家可以通过在屏幕上按住鼠标或手指来给宇宙飞船提供推力。
- en: As you should be able to detect when the player touches the screen, I am going
    to show you a mouse-only way to control the spaceship to make you learn something
    new. You are free to replace this way to control the ship with the one you prefer.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你应该能够检测到玩家触摸屏幕时的情况，我将向你展示一种仅使用鼠标控制宇宙飞船的方法，让你学习一些新知识。你可以自由地用你喜欢的控制方式来替换这种控制飞船的方式。
- en: 'You are going to manage ship control in just a few lines, first by adding a
    new global variable:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 你将只用几行代码来管理飞船控制，首先通过添加一个新的全局变量：
- en: '[PRE10]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `gameThrust` variable represents engine power, the force that will make
    the ship fly through the air.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`gameThrust` 变量代表引擎功率，这是使飞船在空中飞行的力量。'
- en: 'You are controlling the game with the mouse, so that''s how you change the
    `game` declaration:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 你正在用鼠标控制游戏，所以这就是你更改 `game` 声明的方式：
- en: '[PRE11]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Unlike in the previous chapter, here you added the listener on the fly without
    declaring it as a variable and then calling it. It's basically the same as before,
    it's just that now you are working with the mouse, so you must define the event
    type as `cc.EventListener.MOUSE`. The events are `onMouseDown` when the player
    presses the mouse and `onMouseUp` when the mouse is released. Now, with `onMouseDown`
    and `onMouseUp`, you just turn the ship's engine to on or off, which is actually
    a Boolean `ship` attribute called `engineOn`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 与上一章不同，这里你是在运行时添加了监听器，而没有将其声明为变量然后调用。基本上和以前一样，只是现在你正在使用鼠标，所以你必须将事件类型定义为 `cc.EventListener.MOUSE`。事件是
    `onMouseDown` 当玩家按下鼠标时，以及 `onMouseUp` 当鼠标释放时。现在，使用 `onMouseDown` 和 `onMouseUp`，你只需将飞船的引擎打开或关闭，这实际上是一个名为
    `engineOn` 的布尔 `ship` 属性。
- en: 'What are you going to do with such an attribute? You just update the ship''s
    vertical speed just like you did with the gravity:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 你打算如何使用这样的属性？你只需像处理重力一样更新飞船的垂直速度：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This was really easy. First, you set `engineOn` to `false` and according to
    its value, you decide whether you have to add `gameThrust` to `ySpeed`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很简单。首先，将 `engineOn` 设置为 `false`，然后根据其值，你决定是否需要将 `gameThrust` 添加到 `ySpeed`。
- en: Test the game and try to control the ship by pressing and releasing the mouse
    button.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 测试游戏并尝试通过按住和释放鼠标按钮来控制飞船。
- en: '![Controlling the spaceship](img/0075OS_03_04.jpg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![控制宇宙飞船](img/0075OS_03_04.jpg)'
- en: Finally, the spaceship can fly through the city in peace and harmony. Unfortunately,
    game designers are a bit mad and they could decide to make some changes to spaceship
    plans by adding a belt of deadly asteroids big enough to smash a spaceship.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，宇宙飞船可以和平和谐地飞过城市。不幸的是，游戏设计师有点疯狂，他们可能会决定通过添加一个足够大的致命小行星带来改变宇宙飞船的计划，足以摧毁一艘宇宙飞船。
- en: Adding asteroids
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加小行星
- en: As the spaceship flies from left to right (actually it does not, but that's
    how it seems), you have to add asteroids, which enter the screen from the right-hand
    side of the game.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 当宇宙飞船从左到右飞行时（实际上它并没有，但看起来是这样），你必须添加小行星，它们从游戏的右侧进入屏幕。
- en: Now, you can just place some asteroid sprites on the right-hand side of the
    screen and make them move to the left-hand side just like you did with the background
    cityscape, but you wouldn't learn anything new if you did that, so let's see another
    way to manage sprite movement.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你只需在屏幕的右侧放置一些小行星精灵，并让它们向左侧移动，就像你之前处理背景城市景观那样，但如果你那样做，你不会学到任何新东西，所以让我们看看另一种管理精灵移动的方法。
- en: First things first, before you can move an asteroid, you have to create it.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，在你能够移动小行星之前，你必须先创建它。
- en: 'In this game, a new asteroid will appear every half a second, so it''s time
    to schedule another event in the `game` class declaration:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个游戏中，每半秒就会出现一个新的小行星，所以是时候在`game`类声明中安排另一个事件了：
- en: '[PRE13]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: To schedule an event at a given interval, you use the `schedule` method that
    works like `scheduleUpdate`, but this time you can also define which function
    to call, `addAsteroid`, in this case, and the interval of time in seconds.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 要在给定的时间间隔安排一个事件，你使用`schedule`方法，它的工作方式类似于`scheduleUpdate`，但这次你还可以定义要调用的函数，在这个例子中是`addAsteroid`，以及时间间隔（以秒为单位）。
- en: 'It''s easy to see what `addAsteroid` does: it adds an asteroid by extending
    the `Sprite` class in the same way you saw before. You also added a `removeAsteroid`
    function because you don''t want asteroids to remain in the game forever; you
    will see how to remove them once they are not necessary anymore.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 很容易看出`addAsteroid`的作用：它通过扩展`Sprite`类来添加小行星，就像你之前看到的那样。你还添加了一个`removeAsteroid`函数，因为你不希望小行星永远留在游戏中；一旦它们不再必要，你将看到如何移除它们。
- en: 'This is the `Asteroid` class:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 这是`Asteroid`类：
- en: '[PRE14]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Run the game and you will see an asteroid belt flying towards the ship following
    a random path.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 运行游戏，你会看到一个小行星带沿着随机路径飞向飞船。
- en: '![Adding asteroids](img/0075OS_03_05.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![添加小行星](img/0075OS_03_05.jpg)'
- en: There is a lot of stuff in a simple class declaration, so let's take a closer
    look at the preceding code.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 简单的类声明中有很多内容，所以让我们仔细看看前面的代码。
- en: The `ctor` constructor simply creates the instance and assigns it an image,
    as usual. So, the magic happened somewhere else.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`ctor`构造函数简单地创建实例并为其分配一个图像，就像往常一样。所以，魔法发生在其他地方。'
- en: 'The `onEnter` event places the asteroid on the right-hand side of the screen
    at a random height; the next line is responsible for the whole animation:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`onEnter`事件将小行星放置在屏幕的右侧，高度随机；下一行负责整个动画：'
- en: '[PRE15]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Cocos2d-JS allows you to create actions, which in this case basically are tweens
    and can be seen as things to do at a given point in time.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: Cocos2d-JS允许你创建动作，在这个例子中，基本上是缓动，可以看作是在特定时间点要做的事情。
- en: This action should move to a given random point on the left-hand side of the
    screen in 2.5 seconds. That's it. It doesn't matter how Cocos2d-JS will perform
    this task; you just say *bring this asteroid and make it fly to that point*.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这个动作应该在2.5秒内移动到屏幕左侧的随机点。就是这样。Cocos2d-JS将如何执行这项任务并不重要；你只需说“把这个小行星带到那里，让它飞到那个点”。
- en: The power of these actions is awesome and you will deal with it in more examples
    in this book.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这些动作的力量是惊人的，你将在本书的更多示例中处理它们。
- en: 'Once the action is created, you make Cocos2d-JS execute it with:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了动作，你就可以使用以下方式让Cocos2d-JS执行它：
- en: '[PRE16]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: The asteroid travel is done. You should also see whether there's a `scheduleUpdate`
    call because you want to remove asteroids once they exit from the left-hand side
    of the screen; so, in the `update` function (remember, every `scheduleUpdate`
    method calls an `update` function at each frame). You simply check when the asteroid
    is outside the screen and eventually remove it with the `removeAsteroid` method
    you created before.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 小行星的旅行已经完成。你也应该看到是否有`scheduleUpdate`调用，因为你想要在小行星从屏幕左侧退出时移除它们；所以，在`update`函数中（记住，每个`scheduleUpdate`方法在每个帧上都会调用一个`update`函数）。你只需检查小行星是否在屏幕外，然后使用你之前创建的`removeAsteroid`方法将其移除。
- en: That was really easy, wasn't it?
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 这真的很简单，不是吗？
- en: Too bad! The asteroids and spaceship do not collide yet, but don't worry, it
    won't take more than a couple of lines.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾！小行星和飞船还没有发生碰撞，但别担心，这不会超过几行代码。
- en: Asteroid versus spaceship collision
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 小行星与飞船碰撞
- en: The easiest way to see whether two sprites collide, which is also the most used
    in simple fast paced arcade games like the one you are currently building, is
    by checking whether sprite bounding boxes intersect somehow.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 检查两个精灵是否碰撞的最简单方法，也是你在当前构建的简单快节奏街机游戏中最常用的方法，就是检查精灵的边界框是否以某种方式相交。
- en: 'The bounding box of an image is the smallest rectangle, which entirely contains
    the image itself, and the principle of this method can be explained by the following
    image:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图像的边界框是包含图像本身的矩形，这个方法的原则可以通过以下图像解释：
- en: '![Asteroid versus spaceship collision](img/0075OS_03_06.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![小行星与飞船碰撞](img/0075OS_03_06.jpg)'
- en: 'In this 4x zoomed image, you can see the three different ways the bounding
    box collision will react:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个4倍缩放的图像中，您可以看到边界框碰撞的三个不同反应方式：
- en: Bounding boxes do not intersect. There is no collision.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边界框不相交。没有发生碰撞。
- en: Bounding boxes intersect. There is a collision.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边界框相交。发生了碰撞。
- en: Bounding boxes intersect, although there isn't a collision.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 边界框相交，尽管没有发生碰撞。
- en: In sophisticated collision engines, to prevent case 3, once bounding boxes intersect,
    a pixel perfect collision is performed, but this is CPU-consuming and at the moment,
    you don't want such a high level of precision.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 在复杂的碰撞引擎中，为了防止情况3，一旦边界框相交，就会执行像素完美的碰撞，但这很消耗CPU资源，目前您不想达到如此高的精度。
- en: So, if you want to make case 3 occur as seldom as possible, you can draw your
    sprites with shapes as close to a rectangle as possible, or you can consider the
    intersection between two boxes a little smaller than the original bounding boxes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您想尽可能少地让情况3发生，您可以将精灵绘制得尽可能接近矩形，或者您可以考虑两个比原始边界框略小的框之间的交集。
- en: Remember, players want to be forgiven, so if it's just a matter of a couple
    of pixels, it's better not to see an actual collision rather than to see a false
    positive collision.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，玩家希望得到宽恕，所以如果只是几像素的问题，最好不要看到实际的碰撞，而是一个假阳性碰撞。
- en: 'Having said that, here is how Cocos2d-JS will help you to manage bounding box
    collisions working on asteroid''s `update` function:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，以下是如何通过Cocos2d-JS帮助您管理边界框碰撞，在 asteroid 的 `update` 函数中工作：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `getBoundingBox` method returns a rectangle, which is the actual sprite
    bounding box, and the `rectIntersectsRect` method checks whether two rectangles
    intersect.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`getBoundingBox`方法返回一个矩形，这是实际的精灵边界框，而`rectIntersectsRect`方法检查两个矩形是否相交。'
- en: 'This is easy. Collision detection occurs in two lines. Then, the asteroid is
    removed and the `restartGame` function is called.This function just resets spaceship''s
    variables, as shown in the following code:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 这很简单。碰撞检测发生在两行代码中。然后，移除小行星并调用`restartGame`函数。这个函数只是重置飞船的变量，如下面的代码所示：
- en: '[PRE18]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, test the game and you will see the spaceship position being reset once
    it collides with an asteroid. This way, the game becomes a bit punishing when
    you die, as you will often respawn in front of an asteroid, causing an immediate
    death. Remember, players want to be forgiven.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，测试游戏，您将看到飞船与小行星碰撞后位置被重置。这样，当您死亡时，游戏会变得有些惩罚性，因为您通常会复活在小行星前面，导致立即死亡。记住，玩家希望得到宽恕。
- en: Invulnerability
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不可摧毁性
- en: This feature has nothing to do with the new Cocos2d-JS stuff, it's just some
    polishing in game design, but remember polishing is always better than adding
    features.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这个特性与新的Cocos2d-JS无关，这只是游戏设计中的打磨，但请记住，打磨总是比添加特性更好。
- en: People played Angry Birds series to death because it's polished, not because
    wooden blocks did break exactly like a real-world wooden block would.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 人们玩愤怒的小鸟系列游戏玩到死，因为它很精致，并不是因为木块确实像现实世界中的木块一样破碎。
- en: So, after the player smashed the spaceship into an asteroid, let's make the
    spaceship invulnerable for a limited period of time; let the player see the ship
    cannot be destroyed by making it flash.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当玩家将飞船撞向小行星后，让我们让飞船在有限的时间内不可摧毁；通过使其闪烁来让玩家看到飞船无法被摧毁。
- en: 'You are going to add an `invulnerability` attribute to the spaceship in the
    ship''s `ctor` constructor:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在飞船的`ctor`构造函数中添加一个`invulnerability`属性：
- en: '[PRE19]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'When `invulnerability` is set to zero, this means the spaceship is not invulnerable
    and can be destroyed by asteroids. You have to add this case to Asteroid''s `update`
    method:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 当`invulnerability`设置为零时，这意味着飞船不具有不可摧毁性，可以被小行星摧毁。您必须在小行星的`update`方法中添加这个情况：
- en: '[PRE20]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you can see, collision is processed only if invulnerability is set to zero,
    and when you restart the game in the `restartGame` function, you assign it a high
    value, let''s say 100:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，只有当不可摧毁性设置为零时，才会处理碰撞，当您在`restartGame`函数中重新启动游戏时，您将其赋予一个高值，比如说100：
- en: '[PRE21]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'This means that now the spaceship cannot be destroyed. To give the player a
    visual feedback and decrease invulnerability, let''s add two lines to ship''s
    `updateY` function:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着现在飞船不能被摧毁。为了给玩家提供视觉反馈并减少无敌值，让我们在飞船的 `updateY` 函数中添加两行代码：
- en: '[PRE22]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: If invulnerability is greater than zero, decrease it and make the spaceship
    flash by switching its opacity from fully opaque (255) to completely transparent
    (0).
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果无敌值大于零，就减少它，并通过将飞船的不透明度从完全不透明（255）切换到完全透明（0）来使飞船闪烁。
- en: The `setOpacity` and `getOpacity` methods handle sprite's opacity.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`setOpacity` 和 `getOpacity` 方法处理精灵的不透明度。'
- en: Test the game and after you run into an asteroid, you should have *God mode*
    enabled for about a second and a half.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 测试游戏，在你撞上小行星后，你应该大约有半秒钟的 *上帝模式*。
- en: Preventing the spaceship from flying off the screen
  id: totrans-134
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止飞船飞出屏幕
- en: The last thing you need to do is prevent the spaceship from flying off the screen.
    If you press the mouse for too long, or if you don't press the mouse at all, your
    ship will fly respectively off the top or the bottom of the screen.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 最后你需要做的是防止飞船飞出屏幕。如果你按住鼠标时间过长，或者根本不按鼠标，你的飞船将分别飞出屏幕的顶部或底部。
- en: You need to prevent the ship from flying off the screen by punishing it with
    death.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要通过惩罚来防止飞船飞出屏幕，即让飞船无法被摧毁。
- en: 'Just add these two lines to the ship''s `updateY` function:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 只需将这些两行代码添加到飞船的 `updateY` 函数中：
- en: '[PRE23]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: No need to comment them, it's just an `if` statement that checks for the spaceship's
    vertical position.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 无需注释它们，这只是一个检查飞船垂直位置的 `if` 语句。
- en: Adding particles
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加粒子
- en: Do you remember that in your `assets` folder, there's a yellow circle called
    `particle.png`? You will use it to create a nice particle effect to simulate the
    spaceship engine.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 你还记得在你的 `assets` 文件夹中有一个叫做 `particle.png` 的黄色圆圈吗？你将使用它来创建一个漂亮的粒子效果来模拟飞船引擎。
- en: Discussing particle systems is beyond the scope of this book, so for more detailed
    information as well as complete particle generation software compatible with Cocos2d-JS,
    take a look at [https://71squared.com/particledesigner](https://71squared.com/particledesigner).
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 讨论粒子系统超出了本书的范围，因此有关更详细的信息以及与 Cocos2d-JS 兼容的完整粒子生成软件，请查看 [https://71squared.com/particledesigner](https://71squared.com/particledesigner)。
- en: 'Here, you are just going to add the simplest particle effect ever, but you
    will see it has a visual appeal like the following figure:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你只是将要添加最简单的粒子效果，但你将看到它具有以下图示的视觉吸引力：
- en: '![Adding particles](img/0075OS_03_07.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![添加粒子](img/0075OS_03_07.jpg)'
- en: 'First, create a new global variable:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个新的全局变量：
- en: '[PRE24]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The emitter will be created and configured in game''s `init` function:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 发射器将在游戏的 `init` 函数中创建和配置：
- en: '[PRE25]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Here, you can see that the emitter is created with a **sun** effect, an image
    is assigned to it, and a start and end image size are given to it.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到发射器是通过一个 **太阳** 效果创建的，一个图像被分配给它，并且给出了起始和结束图像的大小。
- en: 'This is enough to generate an ever working particle emitter, but you also need
    it to follow the spaceship only when the engines are working by updating the ship''s
    `updateY` function:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这足以生成一个始终工作的粒子发射器，但你还需要在引擎工作时通过更新飞船的 `updateY` 函数来跟踪飞船：
- en: '[PRE26]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Here, you just move the emitter to spaceship's tail when the engine is on, and
    outside the screen when the engine is off. Cheap and dirty, but it's working.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，当引擎开启时，你只需将发射器移动到飞船的尾部，当引擎关闭时，将其移出屏幕。虽然简单粗暴，但确实有效。
- en: Test the game; you should see an eye-candy effect when engines are on, just
    like in the image you saw before.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 测试游戏；当引擎开启时，你应该会看到之前看到的图像中的炫酷效果。
- en: Summary
  id: totrans-154
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you learned how to create tweens, collisions, and so on. You
    also learned how to pass through particle generation and create a complete working
    game.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，你学习了如何创建补间动画、碰撞等。你还学习了如何通过粒子生成创建一个完整的游戏。
- en: There is something you should do to get more familiar with Cocos2d-JS, that
    is, use what you learned until now and improve the game. You can try to switch
    the control mode from mouse-driven to touch-driven, display text with the maximum
    distance travelled without hitting an asteroid, and increase the difficulty level
    every *n* seconds without hitting asteroids by making asteroids faster or appear
    more often.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更熟悉 Cocos2d-JS，你应该做的是，运用你到目前为止所学的内容来改进游戏。你可以尝试将控制模式从鼠标驱动切换到触摸驱动，显示没有撞击小行星时行驶的最大距离，并且每
    *n* 秒通过使小行星更快或更频繁地出现来提高难度级别。
- en: Now, you are ready to dive into the next chapter where touch controls will become
    more interactive thanks to swipe detection.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你已经准备好进入下一章了，在这一章中，由于触控检测，触控操作将变得更加互动。
