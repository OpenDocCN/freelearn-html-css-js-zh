<html><head></head><body>
		<div><div></div>
		</div>
		<div><h1 id="_idParaDest-518"><a id="_idTextAnchor575"/>14. Understanding Functional Programming</h1>
		</div>
		<div><p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to use functional programming concepts such as pure functions, immutability, composition, and currying; use higher-order functions such as filter, map, and reduce; apply techniques such as cloning objects to reduce side effects in your code; and demonstrate strategies for reducing imperative logic and <code>for</code> loops in your code.</p>
			<h1 id="_idParaDest-519"><a id="_idTextAnchor576"/>Introduction</h1>
			<p>In the previous chapter, we talked about how JavaScript is a multi-paradigm programming language. It's possible to write code with procedural, object-oriented, and functional design patterns. In this chapter, we'll look closely at the functional programming design pattern.</p>
			<p>Functional programming is a programming paradigm that has become popular in the last few years, though most JavaScript developers were unfamiliar with it before then.</p>
			<p>JavaScript is not a purely functional language like some others, such as Haskell, Scheme, and Clojure. However, JavaScript has support for functional structures and techniques if you choose to use them. It is worthwhile becoming familiar with its concepts and gaining a working knowledge of how to use them.</p>
			<p>Functional programming has a set of features. Among others, here are some of the important ones:</p>
			<ul>
				<li>Pure functions</li>
				<li>Immutability and avoiding shared state, mutable data, and side effects</li>
				<li>Declarative rather than imperative</li>
				<li>Higher-order functions</li>
				<li>Function composition and piping</li>
				<li>Currying functions</li>
				<li>Reduces the use of traditional flow control structures such as <code>for</code>, <code>while</code>, and even <code>if</code></li>
			</ul>
			<p>These concepts will be covered over the course of this chapter. If implemented correctly, functional programming can result in code that is more predictable, less error-prone, and easier to test compared to other programming methods.</p>
			<h1 id="_idParaDest-520"><a id="_idTextAnchor577"/>Pure Functions</h1>
			<p>Pure functions are one of the pillars of functional programming. A function is pure if it always returns the same result when it's given the same parameters. It also cannot depend on or modify variables or state outside of the function's scope.</p>
			<p>A simple example of an impure function is as follows:</p>
			<pre>var positionX = 10;
function moveRight(numSlots) {
    positionX += numSlots;
}
moveRight(5);</pre>
			<p>You can plainly see how the function is manipulating a value outside of its scope in the <a id="_idTextAnchor578"/><code>positionX</code> global variable. A pure function should only use the arguments that have been passed in for its logic, and should not directly modify them. Another issue is that the function doesn't actually return a value.</p>
			<p>Consider the following code. Can you see why it would not be considered a pure function?</p>
			<pre>var positionX = 10;
function moveRight(numSlots) {
    return positionX + numSlots;
}
positionX = moveRight(5);</pre>
			<p>Though the function only reads the global variable value and does not manipulate the variable directly, it is still not pure. To see why think about what happens if you call the function multiple times with the value <code>5</code> for the <code>numSlots</code> parameter:</p>
			<ul>
				<li>The first time, the result is <code>15</code> (since <code>positionX</code> is <code>10</code> and <code>10 + 5 = 15</code>)</li>
				<li>The second time, the result would be <code>20</code></li>
				<li>The third time, the result would be <code>25</code></li>
			</ul>
			<p>In other words, there is a different result for each invocation. For the function to be pure, the result would have had to resolve to the exact same value for the given parameter value, that is, <code>5</code>. Also, consider how difficult it would be to write tests for this function since the result is not predictable.</p>
			<p>The correct way of making this function pure is as follows:</p>
			<pre>var positionX = 10;
function moveRight(x, numSlots) {
    return x + numSlots;
}
positionX = moveRight(positionX, 5);</pre>
			<p>In this version, all the data that the function uses in its logic is passed in as arguments, and it does not refer to any data outside of the function's scope. It will also always have the same result for a set of given parameters:</p>
			<ul>
				<li>If <code>x=10</code> and <code>numSlots=5</code>, the result will always be <code>15</code>.</li>
				<li>If <code>x=15</code> and <code>numSlots=5</code>, the result will always be <code>20</code>.</li>
				<li>If <code>x=20</code> and <code>numSlots=5</code>, the result will always be <code>25</code>. </li>
			</ul>
			<p>The predictability of the result makes the code quality higher, makes it easier to reason about the function, and makes it easier to write tests. It also makes the code maintainable and less risky if the function ever needs to be refactored.</p>
			<h2 id="_idParaDest-521"><a id="_idTextAnchor579"/>Side Effects</h2>
			<p>An important concept in functional programming that is closely related to pure functions is reducing side effects. A side effect is when a function performs some action, either directly or indirectly, that is not strictly for the purpose of the function or its return value.</p>
			<p>Examples of side effects are actions such as showing an alert box, writing to a file, triggering a service call on the network, or making changes to the DOM. (Actually, when we manipulated the global variable in the impure function example in the previous section, we were also creating a type of side effect known as the shared state.)</p>
			<p class="callout-heading">Note </p>
			<p class="callout">It is not possible or desirable to create programs that have no side effects whatsoever. After all, what good is the program if you can't see the output in some way? However, functional programmers aim to create pure functions most of the time and isolate the functions and parts of the code that require output or side effects. Keeping such code separate helps you understand your software better for debugging, to create better tests, and to ease future maintenance and extensions.</p>
			<h2 id="_idParaDest-522"><a id="_idTextAnchor580"/>Immutability</h2>
			<p>Another concept in functional programming is to prefer immutable values and objects over mutable ones as much as possible. In short, immutable objects are those whose values cannot change once they are created, even if those objects are used. Going forward, we will perform a few exercises to demonstrate how certain objects such as strings and numbers are immutable, whereas arrays are not. We will begin with the immutability of strings in the following exercise.</p>
			<h2 id="_idParaDest-523"><a id="_idTextAnchor581"/>Exercise 14.01: Immutable Values and Objects – Strings</h2>
			<p>In this exercise, we will demonstrate how strings are immutable. Let's get started:</p>
			<ol>
				<li>In the Google Chrome browser, go to <code>Developer Tools</code> (go to the menu with the three dots at the upper-right of the screen | <code>More Tools</code> | <code>Developer Tools</code>, or just hit the <em class="italic">F12</em> key).</li>
				<li>JavaScript has several built-in immutable objects, such as strings. Create two constants, <code>string1</code> and <code>string2</code>, and assign the variable so that <code>string2</code> is a substring of <code>string1</code>:<pre>const string1 = "Hello, World!";
const string2 = string1.substring(7, 12);</pre></li>
				<li>Display both strings. Type the following into the console:<pre>console.log(`string1: ${string1}`);
console.log(`string2: ${string2}`);</pre></li>
				<li>This code results in the following output:</li>
			</ol>
			<div><div><img alt="Figure 14.1: Output of strings&#13;&#10;" src="img/C14377_14_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1: Output of strings</p>
			<p>From this, you can see that the execution of <code>substring()</code> on <code>string1</code> did not change the value of <code>string1</code> in any way, demonstrating that the string is immutable. It actually results in a new string consisting of the characters of the partial string between the given indices. This result is then set as the value of the <code>string2</code> variable.</p>
			<h2 id="_idParaDest-524"><a id="_idTextAnchor582"/>Exercise 14.02: Immutable Values and Objects – Numbers</h2>
			<p>Primitives such as numbers are also immutable. In this exercise, we will perform an operation on a number to demonstrate immutability in numbers. </p>
			<ol>
				<li value="1">Create two constants, <code>number1</code> and <code>number2</code>, and assign them numeric values such that <code>number2</code> is half of the value of <code>number1</code>:<pre>const number1 = 500;
const number2 = number1 / 2;</pre></li>
				<li>Display both number objects. Type the following into the console:<pre>console.log(`number1: ${number1}`);
console.log(`number2: ${number2}`);</pre></li>
				<li>This code results in the following output:</li>
			</ol>
			<div><div><img alt="Figure 14.2: Output of numbers&#13;&#10;" src="img/C14377_14_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2: Output of numbers</p>
			<p>We can see that performing a calculation with <code>number1</code> and setting the result to a new variable does not affect the original variable.</p>
			<h2 id="_idParaDest-525"><a id="_idTextAnchor583"/>Exercise 14.03: Mutability – Arrays</h2>
			<p>So far, we have looked at immutable objects. From this point on, we will look at examples of objects that do not have this immutability. In this exercise, we'll create an array and assign its values to another array, and then we'll modify its value to demonstrate how arrays are mutable.</p>
			<ol>
				<li value="1">Create and define <code>array1</code> so that it has three value elements, namely, <code>'one'</code>, <code>'two'</code>, and <code>'three'</code>:<pre>const array1 = ['one', 'two', 'three'];</pre></li>
				<li>Create another array, <code>array2</code>, with the value equal to <code>array1</code>:<pre>const array2 = array1;</pre></li>
				<li>Now, append another element, <code>'four'</code>, to <code>array2</code>: <pre>array2.push('four');</pre></li>
				<li>Display both outputs in the console, like so:<pre>console.log(`array1: ${array1}`);
console.log(`array2: ${array2}`);</pre></li>
			</ol>
			<p>This code results in the following output:</p>
			<div><div><img alt="Figure 14.3: Output of arrays&#13;&#10;" src="img/C14377_14_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3: Output of arrays</p>
			<p>Here, we assigned the <code>array2</code> variable to the same array as <code>array1</code>, and then appended another element to <code>array2</code> (the value <code>'four'</code>). It may surprise you that <code>array1</code> is affected and gets the element added to it as well, unlike the other examples so far. This is because when the assignment is made to <code>array2,</code> it does not create a new array. Rather, it assigns only a reference that points to the original array, that is, <code>array1</code>. Manipulating either array would affect both of the variables as they are in fact the same array.</p>
			<h2 id="_idParaDest-526"><a id="_idTextAnchor584"/>Exercise 14.04: Mutability – Objects</h2>
			<p>In this exercise, we will assign values to properties in an object to demonstrate mutability in objects.</p>
			<ol>
				<li value="1">Create an object, <code>actor1</code>, with the properties <code>name</code> and <code>show</code>. Assign the value <code>Sheldon</code> and <code>BB Theory</code> to these properties:<pre>const actor1 = {
    name: 'Sheldon',
    show: 'BB Theory'
};</pre></li>
				<li>Now, create another variable, <code>actor2</code>, and assign it to the same object as <code>actor1</code>. Then, also add a new property to <code>actor2</code> called <code>name</code><pre>const actor2 = actor1;
actor2.name = 'Leonard';</pre></li>
				<li>Type the following into the console:<pre>console.log("actor1:", actor1);
console.log("actor2:", actor2);</pre></li>
				<li>This code results in the following output:</li>
			</ol>
			<div><div><img alt="Figure 14.4: Output for objects&#13;&#10;" src="img/C14377_14_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4: Output for objects</p>
			<p>As you can see, both the objects in the <code>actor1</code> and <code>actor2</code> variables end up being exactly the same. The <code>name</code> property is not only in <code>actor2</code>, as you might expect. This is once again because <code>actor2</code> is only a reference to <code>actor1</code>, and is not its own object.</p>
			<p>Another point is worth mentioning as well. In all these examples, the variables were defined as constants using the <code>const</code> keyword. However, as we have seen in the last two examples, we were able to make changes to the object and the compiler did not complain. This shows that the <code>const</code> keyword is <em class="italic">not</em> equivalent to saying the value is immutable!</p>
			<p>All <code>const</code> means is that the compiler prevents you from being able to reassign the variable to a new object. It does not restrict you from changing the properties of the assigned object or adding array elements, though.</p>
			<p>The next section will show you some strategies regarding how to handle mutable objects effectively.</p>
			<h2 id="_idParaDest-527"><a id="_idTextAnchor585"/>Cloning Objects and Arrays</h2>
			<p>In the previous exercise, you saw how arrays and objects are mutable. What if you need to make modifications, though? How can you do this in a safe manner that avoids side effects?</p>
			<p>First, there's a simple technique for arrays. If you are just adding an element to the array, you can use <code>Array.prototype.concat</code> rather than <code>Array.prototype.push</code>. The difference is that <code>concat</code> returns a new array copy with the element added, whereas <code>push</code> modifies the original array.</p>
			<p>We can see this in the following code. Here, <code>array1</code> and <code>array2</code> are now, in fact, distinct objects:</p>
			<pre>const array1 = ['one', 'two', 'three'];
const array2 = array1.concat('four');
console.log(`array1: ${array1}`);   // output: array1: one,two,three
console.log(`array2: ${array2}`);   // output: array2: one,two,three,four</pre>
			<p>The output of the preceding code would be as follows:</p>
			<pre>array1: one,two,three
and
array2: one,two,three,four</pre>
			<p>For other array modifications or to manipulate objects, you would usually need to clone the array or object and operate on the clone. How do you make clones, you ask? Here's a neat trick: in newer JavaScript versions (since ECMAScript 2018), the spread syntax works for both arrays and objects. Using the spread syntax, you can do the following:</p>
			<pre>// Arrays
const array1 = ['one', 'two', 'three'];
const array2 = [...array1];
array2[0] = 'four';
console.log(`array1: ${array1}`);   // output: array1: one,two,three
console.log(`array2: ${array2}`);   // output: array2: four,two,three
// Objects
const actor1 = {
    name: 'Sheldon',
    show: 'BB Theory'
};
       
const actor2 = {...actor1};
actor2.name = 'Leonard';
//the output for variable actor1 will be displayed.       
console.log("actor1:", actor1);   </pre>
			<p>The output of <code>const actor1</code> will be as follows:</p>
			<pre>    // output: actor1: { name: "Sheldon", show: "BB Theory" }
//the output for variable actor2 will be displayed.
console.log("actor2:", actor2);</pre>
			<p>The output of <code>const actor2</code> will be as follows:</p>
			<pre>    // output: actor2: { name: "Leonard", show: "BB Theory" }</pre>
			<p>Notice that there are three consecutive dots in <code>[...array1]</code> and <code>{...actor1}</code>. These dots are known as spread operators. Using the spread syntax in this fashion effectively clones the array, or key-value pairs in the case of an object.</p>
			<p>There is one caveat, though. This method only makes a shallow copy, which means only the top-level elements or properties are copied. Beyond the top level, only references are created. What this means is that, for example, multi-dimensional arrays or nested objects are not copied.</p>
			<p>If a deep copy is required, one popular method is to convert the object into a JSON string and parse it right back, similar to the following code. This works for both objects and arrays:</p>
			<pre>let object2 = JSON.parse(JSON.stringify(object1));</pre>
			<p>The deep copy method also has the added benefit of working on older versions of JavaScript.</p>
			<h2 id="_idParaDest-528"><a id="_idTextAnchor586"/>Sample Data for Examples and Exercises</h2>
			<p>Before we go further, we need to introduce a scenario with sample data. In the upcoming sections, the following data will be used in the examples and exercises:</p>
			<pre>const runners = [
    {name: "Courtney", gender: "F", age: 21, timeSeconds: 1505},
    {name: "Lelisa",   gender: "M", age: 24, timeSeconds: 1370},
    {name: "Anthony",  gender: "M", age: 32, timeSeconds: 1538},
    {name: "Halina",   gender: "F", age: 33, timeSeconds: 1576},
    {name: "Nilani ",  gender: "F", age: 27, timeSeconds: 1601},
    {name: "Laferne",  gender: "F", age: 35, timeSeconds: 1572},
    {name: "Jerome",   gender: "M", age: 22, timeSeconds: 1384},
    {name: "Yipeng",   gender: "M", age: 29, timeSeconds: 1347},
    {name: "Jyothi",   gender: "F", age: 39, timeSeconds: 1462},
    {name: "Chetan",   gender: "M", age: 36, timeSeconds: 1597},
    {name: "Giuseppe", gender: "M", age: 38, timeSeconds: 1570},
    {name: "Oksana",   gender: "F", age: 23, timeSeconds: 1617}
];</pre>
			<p>This is an array of objects that represents the results of runners in a 5 km race. The name, sex, age, and time are indicated for each runner in object fields. Time is recorded in seconds, allowing for easy minutes/seconds and pace calculations.</p>
			<p>We will also define three helper functions to display the data. They will use some concepts that you may not be familiar with yet, particularly, arrow function notation and the <code>Array.prototype.map</code> method. But don't worry – these concepts will be covered in upcoming sections and they will become clear soon.</p>
			<p>The purpose of our first helper function is to format seconds into <code>MM:SS</code>:</p>
			<pre>   const minsSecs = timeSeconds =&gt;
       Math.floor(timeSeconds / 60) + ":" +
       Math.round(timeSeconds % 60).toString().padStart(2, '0');</pre>
			<p>Let's understand the code in detail:</p>
			<ul>
				<li>The <code>minsSecs</code> variable defines an arrow function with a <code>timeSeconds</code> input parameter.</li>
				<li>For the minutes portion, the <code>Math.floor()</code> method removes the decimal part of the minutes when dividing seconds by 60, resulting in just a whole number integer.</li>
				<li>For the seconds portion, the <code>Math.round()</code> method returns the number rounded to the nearest integer. (Note that we only wish to round fractional seconds. For the minute portion, it would not be correct to round.)</li>
				<li>The <code>String.prototype.padStart</code> method pads the seconds value with a leading <code>0</code> if the value is less than 10. The seconds themselves are calculated using the remainder operator, <code>%</code>, which returns any remainder value in the division.</li>
			</ul>
			<p>Our second helper function creates a string that prints the fields of the <code>runner</code> object in custom formats:</p>
			<pre>        const printRunner = runner =&gt;
            [`Name: ${runner.name}`,
             `gender: ${runner.gender}`,
             `age: ${runner.age}`,
             `time: ${minsSecs(runner.timeSeconds)}`
            ].join('\t');</pre>
			<p>Let's understand the code in detail:</p>
			<ul>
				<li>Once again, arrow function syntax is used. The function is named <code>printRunner</code> and has a <code>runner</code> input parameter.</li>
				<li>An array of formatted strings is created, one for each field in the <code>runner</code> object.</li>
				<li>Lastly, all the string elements are joined together with a tab character separator by calling <code>Array.prototype.join('\t')</code>, resulting in nice columns when printed.</li>
			</ul>
			<p>The final helper function prints all the runners:</p>
			<pre>        const printRunners = (runners, listType) =&gt;
            `List of ${listType} (total ${runners.length}):\n` +
                runners.map(printRunner).join('\n');</pre>
			<p>Let's go through the different parts of the above code in detail:</p>
			<ul>
				<li>The function is called <code>printRunners</code> and takes two parameters: an array of <code>runners</code>, and <code>listType</code>, which is a description of what type of list is being printed. It returns a string.</li>
				<li><code>Array.prototype.map</code> is used to form the runner details for printing.</li>
				<li>In short, the <code>Array.prototype.map</code> method iterates over every array element executes a callback function on them and results in a new array with the transformed values of each element. We'll explain how this works in detail later.</li>
				<li>But for now, the <code>Array.prototype.map</code> call here calls the <code>printRunner</code> function specified previously on each array element to get the formatted strings. Since the <code>printRunner</code> function only takes one parameter, in this case, it is not necessary to explicitly specify the parameter, since it is implied.</li>
				<li>The strings are then joined together with a newline character by calling <code>Array.prototype.join('\n')</code>.</li>
			</ul>
			<p>To print all the runners to the console, invoke it like this:</p>
			<pre>    console.log(printRunners(runners, "all runners"));</pre>
			<p>The output will look like this:</p>
			<div><div><img alt="Figure 14.5: Sample output of all the runners in the console&#13;&#10;" src="img/C14377_14_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.5: Sample output of all the runners in the console</p>
			<h1 id="_idParaDest-529"><a id="_idTextAnchor587"/>Higher-Order Functions</h1>
			<p>Functions in JavaScript are first-class citizens. This means they can be passed as parameter values to other functions, or even assigned to a variable. This is one of the main characteristics that make JavaScript well-suited to the functional style of programming.</p>
			<p>Higher-order functions are functions that operate on other functions. They can do this in one of three ways:</p>
			<ul>
				<li>If the function takes another function as an argument</li>
				<li>If the function returns another function as its result</li>
				<li>In both of these ways</li>
			</ul>
			<p>In the previous chapters, we've already seen several higher-order functions, perhaps without you even realizing it. Remember the callback functions that get executed in response to DOM events, or the callbacks in <em class="italic">Chapter 10, Accessing External Resources</em>, which were called once the AJAX response was ready? These are all examples of higher-order functions since these functions are parameters that are passed into other functions.</p>
			<p>The following sections will introduce three higher-order functions that are commonly used in functional programming: <code>Array.prototype.filter</code>, <code>Array.prototype.map</code>, and <code>Array.prototype.reduce</code>.</p>
			<h2 id="_idParaDest-530"><a id="_idTextAnchor588"/>The Array.prototype.filter Method</h2>
			<p>The first function we will look at is the <code>Array.prototype.filter</code> method, which is simple. Given an existing array, <code>filter()</code> creates a new array with elements that fall under the specified criteria.</p>
			<p>The syntax is as follows:</p>
			<pre>var newArray = array.filter(function(item) {
  return condition;
});</pre>
			<p>The callback function is called for each element of the array in turn. If the condition passes and the function returns <code>true</code>, the element is added to the new array. If the function returns <code>false</code>, the element is skipped and will not be added.</p>
			<p>Note that the return value is a new array. The original array is not impacted at all by this operation. In other words, it is not the case that items are filtered out and removed from the original array if they don't pass the condition. Rather, a new array is created with the elements that pass the test.</p>
			<p>The reason for creating a new array rather than modifying the existing one is due to the fundamental principles of functional programming you learned about earlier: immutability and avoiding side effects.</p>
			<p>We will look at some examples of how <code>Array.prototype.filter</code> is used in the following section.</p>
			<h2 id="_idParaDest-531"><a id="_idTextAnchor589"/>A Refresher</h2>
			<p>Before we look at these examples, though, it is prudent for us to take a step back and review basic JavaScript function syntax and arrow function notation. This will ensure that you have a good grounding for what's to come. We will do this review by showing you different ways that the filtering function can be specified for <code>Array.prototype.filter</code>.</p>
			<p>Say we wanted to filter the array of runners (presented earlier in this chapter) for only female runners. The most straightforward filtering function looks like this:</p>
			<pre>function femaleFilter(runner) {
    if (runner.gender === "F") {
        return true;
    }
    return false;
}</pre>
			<p>This filtering function would be called from another function that actually invokes <code>filter()</code> with the following code:</p>
			<pre>const getFemaleRunners = runners =&gt; runners.filter(femaleFilter);</pre>
			<p>To make the function self-contained, it takes the <code>runners</code> array as a parameter. It is not good practice to require <code>runners</code> to be a global variable.</p>
			<p>Note that we only pass in the name of the filtering function, <code>femaleFilter</code>, as the argument, and not with parentheses, like <code>femaleFilter()</code>. We do not want the function to be executed right away, which is what would happen if there were parentheses. Rather, when a function is passed by name without parentheses, you are passing the function object itself. The <code>filter</code> method is a higher-order function that takes a callback function as its input, which requires the actual function object.</p>
			<p>The results of this filtering can be displayed with the following code:</p>
			<pre>console.log(
    printRunners(getFemaleRunners(runners), "female runners"));
// output:
// → List of female runners (total 6):
// → Name: Courtney  gender: F     age: 21   time: 25:05
// → Name: Halina    gender: F     age: 33   time: 26:16
// → Name: Nilani    gender: F     age: 27   time: 26:41
// → Name: Laferne   gender: F     age: 35   time: 26:12
// → Name: Jyothi    gender: F     age: 38   time: 24:22
// → Name: Oksana    gender: F     age: 23   time: 26:57</pre>
			<p class="callout-heading">Note</p>
			<p class="callout">This code should be used to display the results of the following examples as well. The same results are expected for each example.</p>
			<p>We've done pretty well so far, but we could do better. As an alternative, the filtering function could be specified directly inline:</p>
			<pre>const getFemaleRunners = runners =&gt; runners.filter(
    function(runner) {
        if (runner.gender === "F") {
            return true;
        }
        return false;
    }
);</pre>
			<p>We can simplify this a bit more if we change the filtering test to a Boolean expression rather than explicitly returning <code>true</code> or <code>false</code> in an <code>if</code> statement:</p>
			<pre>const getFemaleRunners = runners =&gt; runners.filter(
    function(runner) {
        return runner.gender === "F";
    }
);</pre>
			<p>In newer versions of JavaScript, since ES6, this function can also be expressed more concisely using an arrow function expression:</p>
			<pre>const getFemaleRunners = runners =&gt; runners.filter(runner =&gt; {
    return runner.gender === "F";
});</pre>
			<p>Finally, note that this function has only one argument and a single <code>return</code> statement in its body. This allows us to make the code even more concise with the following one-liner, which omits the open/close brackets and the <code>return</code> keyword:</p>
			<pre>const getFemaleRunners = runners =&gt;
    runners.filter(runner =&gt; runner.gender === "F");</pre>
			<p>If desired, the filtering function can also be split into its own function and stored in a variable, since functions are first-class objects in JavaScript:</p>
			<pre>const femaleFilter = runner =&gt; runner.gender === "F";
const getFemaleRunners = runners =&gt; runners.filter(femaleFilter);</pre>
			<h2 id="_idParaDest-532"><a id="_idTextAnchor590"/>Eliminating for Loops</h2>
			<p>The <code>Array.prototype.filter</code> function is a great demonstration of powerful functional programming techniques that are used to eliminate looping code, particularly the <code>for</code> loop. To get a feel of the potential pitfalls of the traditional <code>for</code> loop, consider the equivalent imperative code to filter female runners:</p>
			<pre>var femaleRunners = [];
for (var i = 0; i &lt; runners.length; i++) {
    if (runners[i].gender == "F") {
        femaleRunners.push(runners[i]);
    }
}</pre>
			<p>Compare this to the one-liner we saw in the previous section, which does the same thing:</p>
			<pre>const femaleRunners = runners.filter(runner =&gt; runner.gender === "F");</pre>
			<p>The imperative looping code requires the use of the looping variable, <code>i</code>. This introduces mutation of the state into our code and is a potential source of bugs. Even though, in this case, it is a local state, it is best to avoid the state in all situations when possible. At some point in the future, there is a risk that a variable will change for an unknown reason, producing an issue that's difficult to debug.</p>
			<p>With the functional equivalent, it is easier to see at a glance what the code does, is easier to test, and has more opportunity for potential reuse. It has no indentation, no loops, and the code is more concise and expressive.</p>
			<p>This also demonstrates how functional code is most often declarative rather than imperative. It specifies "what to do" (declarative) rather than the steps and flow of "how to do it" (imperative). In this example, the functional code simply says, "filter the array elements passed in the <code>runners</code> parameter where gender is female". Compare this to imperative code that requires multiple variables, statements, loops, and so on, which describes "how" rather than "what."</p>
			<p>In the upcoming sections, we will look at other array methods that eliminate loops as well, such as <code>Array.prototype.map</code> and <code>Array.prototype.reduce</code>.</p>
			<h2 id="_idParaDest-533"><a id="_idTextAnchor591"/>The Array.prototype.map Method</h2>
			<p>The array <code>map()</code> method is used when you want to transform array elements. It applies a function to every element of the calling array and builds a new array consisting of the returned values. The new array will have the same length as the input array, but each element's contents will be transformed (mapped) into something else.</p>
			<p>Say you wanted to calculate the average pace per mile of each runner of the 5 km race. Our dataset provides a <code>timeSeconds</code> field, which is the total amount of time in seconds the runner needs to complete the full distance. There are also 3.1 miles in 5 kilometers. Therefore, to get the pace per mile, you would divide the number of seconds by 3.1.</p>
			<p>We can calculate the pace for all runners with the following code:</p>
			<pre>const getPaces = runners =&gt; runners.map(runner =&gt; runner.timeSeconds / 3.1);
const paces = getPaces(runners);</pre>
			<p>This code results in a new array with elements that have the <code>pace</code> value of the corresponding runner at the same index of the input array. In other words, the value of <code>paces[0]</code> corresponds to the runner in <code>runner[0]</code>, the value of <code>paces[1]</code> corresponds to the runner in <code>runner[1]</code>, and so on.</p>
			<p>The pace results can be printed to the console as follows:</p>
			<pre>paces.forEach(pace =&gt; console.log(minsSecs(pace)));
// output:
// → 8:05
// → 7:22
// → 8:16
// → 8:27
// ...</pre>
			<h2 id="_idParaDest-534"><a id="_idTextAnchor592"/>Exercise 14.05: Another Way of Using Array.prototype.map</h2>
			<p>The results from the previous section in regards to mapping to an array of single-valued elements are useful as-is for some contexts, such as if you intend to subsequently calculate the sum or average of the values. This is okay when you just require the raw numbers and context isn't important. But what if you need more values or context for each element, such as the name of the runner that achieved the pace? This exercise shows another way we can use <code>Array.prototype.map</code> to achieve different results using the original dataset; for example, to get the calculated pace of each runner.</p>
			<ol>
				<li value="1">In the Google Chrome browser, go to <code>Developer Tools</code> (go to the menu with the three dots at the upper-right of the screen | <code>More Tools</code> | <code>Developer Tools</code>, or just hit the <em class="italic">F12</em> key):<div><img alt="Figure 14.6: Developer Tools in the Google Chrome browser&#13;&#10;" src="img/C14377_14_06.jpg"/></div><p class="figure-caption">Figure 14.6: Developer Tools in the Google Chrome browser</p></li>
				<li>In the console, paste in the sample runner data (beginning with <code>const runners = [...]</code>) from the <em class="italic">Sample Data for Examples</em> section of this chapter:<pre>const runners = [
    {name: "Courtney", gender: "F", age: 21, timeSeconds: 1505},
    {name: "Lelisa",   gender: "M", age: 24, timeSeconds: 1370},
    {name: "Anthony",  gender: "M", age: 32, timeSeconds: 1538},
    {name: "Halina",   gender: "F", age: 33, timeSeconds: 1576},
    {name: "Nilani ",  gender: "F", age: 27, timeSeconds: 1601},
    {name: "Laferne",  gender: "F", age: 35, timeSeconds: 1572},
    {name: "Jerome",   gender: "M", age: 22, timeSeconds: 1384},
    {name: "Yipeng",   gender: "M", age: 29, timeSeconds: 1347},
    {name: "Jyothi",   gender: "F", age: 39, timeSeconds: 1462},
    {name: "Chetan",   gender: "M", age: 36, timeSeconds: 1597},
    {name: "Giuseppe", gender: "M", age: 38, timeSeconds: 1570},
    {name: "Oksana",   gender: "F", age: 23, timeSeconds: 1617}
];</pre></li>
				<li>In the console, paste in the code for the <code>minsSecs()</code> helper function, also from the <em class="italic">Sample Data for Examples</em> section of this chapter:<pre>const minsSecs = timeSeconds =&gt;
            Math.floor(timeSeconds / 60) + ":" + 
            Math.round(timeSeconds % 60).toString().padStart(2, '0');</pre></li>
				<li>Type the following code into the console:<pre>const getPacesWithNames = runners =&gt; runners.map(runner =&gt;
    ({name: runner.name, pace: runner.timeSeconds / 3.1}));
const pacesWithNames = getPacesWithNames(runners);</pre><p>This code shows a simple way of adding context to the array elements: rather than returning just a single value from the mapping function, an object with multiple fields can be returned instead that includes as many fields as desired. In this case, the object has the <code>name</code> and <code>pace</code> fields for each array element. </p></li>
				<li>We can see the output by using the following code:<pre>// print each value
pacesWithNames.forEach(paceObj =&gt;
    console.log(`name: ${paceObj.name}\tpace: ${minsSecs(paceObj.pace)}`));</pre><p>After running the preceding commands, your console log should look like the one shown in the following screenshot. Notice the list of names and paces at the bottom:</p><div><img alt="Figure 14.7: Output of the name and pace fields&#13;&#10;" src="img/C14377_14_07.jpg"/></div><p class="figure-caption">Figure 14.7: Output of the name and pace fields</p><p>You'll notice that we have all the same runners from the original data but without gender, age, or times in seconds. We've also added a new value called <code>pace</code>, which we created with the <code>getPacesWithNames</code> function.What if you want your array to contain elements with all the original fields and append an additional <code>pace</code> field? </p></li>
				<li>We could use the spread operator you learned about earlier. Type the following into the console:<pre>const addPacesToRunners = runners =&gt; runners.map(runner =&gt;
    ({...runner, pace: runner.timeSeconds / 3.1}));</pre></li>
				<li>The <code>...runner</code> spread syntax effectively clones all the key-value pairs in the object, adds them to the new mapped value, and displays the output. Add and run the <code>addPacesToRunners</code> function to your console. <p class="callout-heading">Note</p><p class="callout">Copies will be made of the fields. As before, we do not want to just modify the original object so that we can add the new field either, as this has the potential for side effects.</p></li>
				<li>The following code runs the function and displays the results in the console:<pre>const pacesWithAllFields = addPacesToRunners(runners);
pacesWithAllFields.forEach(paceObj =&gt; console.log(paceObj));</pre></li>
			</ol>
			<p>Once you run the <code>forEach()</code> function to iterate over the elements of the <code>pacesWithAllFields</code>, you should get a list of runners with all the original data, but in addition, there will be a new field for the average pace:</p>
			<div><div><img alt="Figure 14.8: Results of addPacesToRunners with the pace field appended&#13;&#10;" src="img/C14377_14_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.8: Results of addPacesToRunners with the pace field appended</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Do not use the spread technique if you expect your code to run in older browsers. Use alternatives such as <code>Object.assign()</code> to clone your fields. Here's how <code>addPacesToRunners</code> could be coded for older environments:</p>
			<p class="callout"><code>const addPacesToRunners = runners =&gt; runners.map(runner =&gt;</code></p>
			<p class="callout"><code>    Object.assign({}, runner, {pace: runner.timeSeconds / 3.1}));</code></p>
			<p class="callout">Alternatively, transpilers such as Babel support the spread syntax, even in older browsers.</p>
			<p>In this exercise, we looked at using the <code>Array.prototype.map</code> method and how we can use functional programming design patterns to combine functions to create complex results. We used <code>addPacesToRunners</code> in combination with <code>minsSecs</code> and <code>pacesWithNames</code> to print the pace of each runner in addition to the data from the original set. Importantly, we added the additional data value of pace without modifying the original dataset. Using the techniques in this exercise thus allows you to retain context when mapping values.</p>
			<p>In the next section, we will learn about another array method, <code>reduce</code>, which allows us to take a set of values from an array and compute them into a single value.</p>
			<h2 id="_idParaDest-535"><a id="_idTextAnchor593"/>The Array.prototype.reduce method</h2>
			<p>Similar to <code>map()</code>, the array <code>reduce()</code> method operates on every element of an array. It is used when you need to compute a single value from them.</p>
			<p>A simple example of this is if you need the sum of a collection of numbers:</p>
			<pre>const sum = [2, 4, 6, 8, 10].reduce((total, current) =&gt; total + current, 0);
console.log(sum);</pre>
			<p>The output of the preceding function will be as follows:</p>
			<pre>// output:
// → 10</pre>
			<p>Here, the <code>reduce()</code> method takes two parameters: a combining function and a start value (0, in this case). It causes the combining function to be called repeatedly with each array element in turn, as it does in a <code>for</code> loop. For each invocation, the present element is passed as the <code>current</code> value, along with the <code>total</code> value so far (sometimes referred to as the accumulator).</p>
			<p>The first time the combining function is invoked, <code>total</code> is the start value (<code>0</code>) and <code>current</code> is the first number in the array (<code>2</code>). The addition, that is, <code>total</code> <code>+</code> <code>current</code>, results in the value of <code>2</code>.</p>
			<p>The second time the combining function is invoked, <code>total</code> is the result of the previous invocation (<code>2</code>) and <code>current</code> is the second number in the array (<code>4</code>). The addition, that is, <code>total</code> <code>+</code> <code>current</code>, results in <code>6</code>.</p>
			<p>This process is repeated for the remaining elements in the array until there are no elements remaining to process. Here is a simple table that shows the values at each invocation:</p>
			<div><div><img alt="Figure 14.9: Invocation value and their result&#13;&#10;" src="img/C14377_14_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.9: Invocation value and their result</p>
			<p>Here is another visualization of this reduction process that may help you see it more clearly:</p>
			<div><div><img alt="Figure 14.10: A depiction of the reduction process&#13;&#10;" src="img/C14377_14_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.10: A depiction of the reduction process</p>
			<p>Going back to using our <code>runners</code> dataset, here's how you can use <code>reduce()</code> to compute the average pace of all runners. But first, recall the code from the previous section that used <code>map()</code> to calculate the pace for each runner and returned the results in a new array:</p>
			<pre>const getPaces = runners =&gt; runners.map(runner =&gt; runner.timeSeconds / 3.1);
const paces = getPaces(runners);</pre>
			<p>We can use these paces to calculate the average with <code>reduce()</code>:</p>
			<pre>const getAvgPace = paces =&gt; paces.reduce(
    (total, currentPace) =&gt; total + currentPace, 0) / paces.length;
console.log(minsSecs(getAvgPace(paces)));</pre>
			<p>The output of the <code>reduce()</code> function will be as follows:</p>
			<pre>// output:
// → 8:08</pre>
			<p>First, in <code>reduce()</code>, we calculate the sum of all <code>pace</code> values using a similar technique as when we summed up the array of numbers. But there's one additional step. Rather than returning the sum, we divide it by the length of the array before returning the result.</p>
			<h2 id="_idParaDest-536"><a id="_idTextAnchor594"/>Exercise 14.06: Grouping with Array.prototype.reduce</h2>
			<p>What if you wanted to calculate the average pace of all runners grouped by gender? We can do this with <code>reduce()</code>, but it is a bit more involved than the previous example. In this exercise, we'll implement one approach to grouping.</p>
			<p>Unlike when we calculated the average of straight numbers, for group averages, we'll need to do this in two steps: first, gather the sum and count of each gender, and then calculate the averages in a second step.</p>
			<p>The following outlines the approach for the summing and counting step:</p>
			<ul>
				<li>Use an empty object (<code>{}</code>) as our starting value.</li>
				<li>When cycling through the array elements, get the group <code>sum</code> and <code>count</code> stats calculated so far for the gender of the current element. (If there are no stats for gender yet, create an empty group with <code>sum</code> and <code>count</code> set to <code>0</code>.)</li>
				<li>Add the pace of the current element to the group sum.</li>
				<li>Increase the count of the group by <code>1</code>.</li>
			</ul>
			<p>Here are the steps to do this:</p>
			<ol>
				<li value="1">In the Google Chrome browser, go to Developer Tools (go to the menu with the three dots at the upper-right of the screen | <code>More Tools</code> | <code>Developer Tools</code>, or just hit the <em class="italic">F12</em> key).</li>
				<li>In the console, paste in the sample runner data (beginning with <code>const runners = [...]</code>) from the <em class="italic">Sample Data for Examples</em> section of this chapter.</li>
				<li>In the console, paste in the code for the <code>minsSecs()</code> helper function, which is also from the <em class="italic">Sample Data for Examples</em> section of this chapter.</li>
				<li>We will make use of the <code>pacesWithAllFields</code> value from the example in the <em class="italic">Array.prototype.map()</em> section, which creates a new array with a calculated <code>pace</code> field added to each element. Type the following into the console:<pre>const addPacesToRunners = runners =&gt; runners.map(runner =&gt;
    ({...runner, pace: runner.timeSeconds / 3.1}));
const pacesWithAllFields = addPacesToRunners(runners);</pre></li>
				<li>The following is the code for this first summing and counting step, which we outlined previously:<pre>const groupSumPaceByGender = runners =&gt; runners.reduce((groups, runner) =&gt; {
    const gender = runner.gender;
    groups[gender] = groups[gender] || {pace: 0, count: 0};
    groups[gender].pace += runner.pace;
    groups[gender].count += 1;
    return groups;
}, {});
const sumPacesByGender = groupSumPaceByGender(pacesWithAllFields);</pre></li>
				<li>At this point, the object that results from <code>sumPacesByGender</code> will have two keys that represent the gender values, that is, "<code>M</code>" and "<code>F</code>". The value for each is also an object, in which there are <code>pace</code> and <code>count</code> fields that contain the calculated stats for gender corresponding to the key.</li>
				<li>Displaying such objects in the JavaScript console is a bit clunky and unwieldy. A trick is in order: we'll convert the object into formatted JSON text and display that instead. Type the following code into the console:<pre>console.log(JSON.stringify(sumPacesByGender,null,4));</pre><p>This will output the JSON with a 4-space indentation:</p><pre>// output:
// → { 
// →     "F": { 
// →         "pace": 3010.645161290322, 
// →         "count": 6 
// →     },
// →     "M": { 
// →         "pace": 2840.6451612903224, 
// →         "count": 6 
// →     }
// → }</pre></li>
				<li>Now that we have the sums and counts for each group determined, we can proceed to the second step and calculate the average of each group. We can do this by using <code>Object.keys()</code> to get an array with the keys of the object (that have the values "<code>M</code>" and "<code>F</code>") and then call <code>Array.prototype.map()</code> with a function to calculate the average for each gender. Type the following into the console:<pre>const calcAvgPaceByGender = sumPacesByGender =&gt;
    Object.keys(sumPacesByGender).map(gender =&gt; {
        const group = sumPacesByGender[gender];
        return {gender: gender, avgPace: group.pace / group.count};
    }
);
const avgPaceByGender = calcAvgPaceByGender(sumPacesByGender);</pre></li>
				<li>Let's write the code to display the output:<pre>console.log("Average pace by gender:");
avgPaceByGender.forEach(entry =&gt; console.log(
    `gender: ${entry.gender}  average pace: ${minsSecs(entry.avgPace)}`));</pre></li>
				<li>The output should be displayed as follows:</li>
			</ol>
			<div><div><img alt="Figure 14.11: Grouping the result of gender pace with Array.prototype.reduce&#13;&#10;" src="img/C14377_14_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.11: Grouping the result of gender pace with Array.prototype.reduce</p>
			<p>This output allowed us to take a large number of data points and "reduce" them to a smaller amount of results in an efficient manner.</p>
			<p>In this exercise, we looked at using the <code>Array.prototype.reduce</code> method for grouping. As in the previous exercise, we combined several functions to create a more complex result, without modifying the original dataset. First, we added the <code>pace</code> value for each entry in the set using <code>addPacesToRunners</code>, then we created a group sum for each gender with <code>groupSumPaceByGender</code>, and finally, we used <code>calcAvgPaceByGender</code> to get a value for the average pace for both males and females in the race.</p>
			<p>In the next section, we'll talk about the concept of composition. We've used composition several times already in this chapter, that is, each time we combined smaller functions to create a larger process. However, we haven't looked at the concept specifically and spoken of its importance in the functional paradigm. We'll also look at the <code>pipe()</code> and <code>compose()</code> functions, which make combining functions in this way easier and more readable.</p>
			<h2 id="_idParaDest-537"><a id="_idTextAnchor595"/>Composition with compose() and pipe()</h2>
			<p>In the previous exercise, we saw that starting from the runners array, we required three different functions to calculate the average pace for each gender:</p>
			<ul>
				<li><code>addPacesToRunners</code>: This is used to calculate the pace per mile.</li>
				<li><code>groupSumPaceByGender</code>: This is used to sum the pace of each gender.</li>
				<li><code>calcAvgPaceByGender</code>: This is used to calculate the average pace for each gender.</li>
			</ul>
			<p>Each function required the result of the one before it as input in order to do its job. Basically, it did the following, though it may not have been apparent up to this point:</p>
			<pre>const result1 = addPacesToRunners(runners);
const result2 = groupSumPaceByGender(result1);
const avg = calcAvgPaceByGender(result2);</pre>
			<p>This is equivalent to the following, that is, using nested functions and removing the intermediate variables:</p>
			<pre>const avg =
    calcAvgPaceByGender(groupSumPaceByGender(addPacesToRunners(runners)));</pre>
			<p>This is the idea of composition: that multiple simple functions are combined to build a more complex function.  The result of each function is passed along to the next one.</p>
			<p>We can create high-order functions called <code>compose</code> and <code>pipe</code> to achieve function composition in a more general manner, though. Putting aside the actual implementation for a moment, let's see how the functions would be used. With <code>compose</code>, the preceding nested functions would be written as follows:</p>
			<pre>const avgWithComposition =
    compose(calcAvgPaceByGender, groupSumPaceByGender, addPacesToRunners);</pre>
			<p>This function would be used as follows:</p>
			<pre>const avgResult = avgWithComposition(runners);
avgResult.forEach(entry =&gt; console.log(
    `gender: ${entry.gender}  average pace: ${minsSecs(entry.avgPace)}`));</pre>
			<p>The output of the function would be as follows:</p>
			<pre>// output:
// → gender: F average pace: 8:22
// → gender: M average pace: 7:53</pre>
			<p>Note that, perhaps counter-intuitively, the functions in <code>compose</code> are actually called in reverse order from how they are given in the parameter list, that is, right to left. So, the <code>addPacesToRunners</code> method is first invoked with the <code>runners</code> argument (even though it is the last function in the given list), then the results are passed to <code>groupSumPaceByGender</code>, and finally, those results are passed to <code>calcAvgPaceByGender</code>.</p>
			<p>Many people find this function call order unnatural, though it is consistent with the order we called our nested functions above. The <code>pipe</code> function is similar to <code>compose</code>, but functions are composed in the opposite direction, left-to-right rather than the right-to-left. The <code>pipe</code> approach is more consistent with linear thinking: first, do A, then B, then C, and the functions to do A, B and C would be given in that order.</p>
			<p>With <code>pipe</code>, the equivalent code would be:</p>
			<pre>const avgWithPipe = 
    pipe(addPacesToRunners, groupSumPaceByGender, calcAvgPaceByGender);
const resultPipe = avgWithPipe(runners);
resultPipe.forEach(entry =&gt; console.log(
    `gender: ${entry.gender}  average pace: ${minsSecs(entry.avgPace)}`));
// output:
// → gender: F average pace: 8:22
// → gender: M average pace: 7:53</pre>
			<h2 id="_idParaDest-538"><a id="_idTextAnchor596"/>Implementation of compose() and pipe()</h2>
			<p>Now, let's look at one way we could actually implement these functions. The implementations are similar, but we'll start with <code>pipe</code> first as it is a bit easier to understand.</p>
			<p>It turns out to be a pretty straightforward implementation when using <code>Array.prototype.reduce</code>:</p>
			<pre>function pipe(...fns) {
    return input =&gt; fns.reduce((prev, fn) =&gt; fn(prev), input);
}</pre>
			<p>The <code>pipe</code> function takes one or more functions passed in as parameters, which are converted into an array of functions with the spread operator, that is, <code>...fns</code>. Then, we apply <code>reduce</code> to the function array, starting by invoking the first function, <code>fn</code>, with the <code>input</code> argument passed in as <code>prev</code>. On the next invocation, the result of the first function is passed (as <code>prev</code>) and used as the parameter when calling the next function in the array. The rest of the functions in the array are processed in a similar fashion, with the result value of the final function returned.</p>
			<p>Note that this function can be simplified a bit by using <code>full fat-arrow</code> notation:</p>
			<pre>const pipe = (...fns) =&gt; input =&gt; fns.reduce((prev, fn) =&gt; fn(prev), input);</pre>
			<p>As far as <code>compose</code> is concerned, recall that it is almost the same as <code>pipe</code> except that the order of functions is processed from right to left rather than left to right. Consequently, the implementation of <code>compose</code> is also basically the same, but rather than using <code>Array.prototype.reduce</code>, the sister function, <code>Array.prototype.reduceRight</code>, is utilized instead. The <code>reduceRight</code> function processes the array in reverse order from <code>reduce</code> and operates on the last element of the array first, then operates on the second to last element, and so on.</p>
			<p>Here's the implementation of <code>compose</code>:</p>
			<pre>const compose = (...fns) =&gt; input =&gt;
    fns.reduceRight((prev, fn) =&gt; fn(prev), input);</pre>
			<h1 id="_idParaDest-539"><a id="_idTextAnchor597"/>Currying Functions</h1>
			<p>Currying is taking a function with multiple arguments and breaking it down into one or more additional functions that take just one argument and eventually resolve to a value. The initial function call does not take all the arguments but returns a function whose input is the remaining arguments and whose output is the intended result for all the arguments.</p>
			<p>That was a mouthful, so let's look at an example. Say you have a simple <code>sum</code> function:</p>
			<pre>function sum(a, b) {
    return a + b;
}</pre>
			<p>Let's express this as a curried function in arrow notation:</p>
			<pre>const sum = a =&gt; b =&gt; a + b;</pre>
			<p>Notice that we have two levels of functions here, and each function takes one parameter. The first function takes one parameter, <code>a</code>, and returns another function, which takes the second parameter, <code>b</code>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are having trouble seeing the two function levels, here's an equivalent that may help:</p>
			<p class="callout">function sum(a) {</p>
			<p class="callout">    return function(b) {</p>
			<p class="callout">       return a + b;</p>
			<p class="callout">    };</p>
			<p class="callout">};</p>
			<p class="callout">You can also write it in arrow notation:</p>
			<pre>const sum = a =&gt; function(b) {
    return a + b;
};</pre>
			<p>To invoke this curried <code>sum</code> function with multiple arguments, you would need to use the following rather awkward syntax:</p>
			<pre>let result = sum(3)(5);    // 8</pre>
			<p>This indicates to first call <code>sum</code> with the parameter value <code>3</code>, then call the function that is returned with the parameter <code>5</code>.</p>
			<p>But most often, you wouldn't invoke curried functions this way, and here's where the real utility of currying will become apparent. Typically, the functions will be called one at a time, which allows us to create intermediate functions that "remember" the parameter that's passed to it.</p>
			<p>For example, we can create the following intermediate functions:</p>
			<pre>const incrementByOne = sum(1);
const addThree = sum(3);
let result1 = incrementByOne(3); // result1 = 4, equivalent to calling sum(1)(3)
let result2 = addThree(5);       // result2 = 8, equivalent to calling sum(3)(5)</pre>
			<p>Both the intermediate functions remember their parameter: <code>incrementByOne</code> holds onto the parameter value of <code>1</code> (as in <code>sum(1)</code>) and <code>addThree</code> remembers <code>3</code>. These functions are also referred to as <code>a</code> parameter was applied to them, but the actual result is not known until the returned function is invoked with the <code>b</code> parameter. (Note that partial application is not quite the same as a curried function, though, as partial applications can hold on to multiple parameters, whereas curried functions always take only one argument.)</p>
			<p>These are essentially new functions that could be potentially reused multiple times. They are also good candidates for <code>compose</code> or <code>pipe</code>, as these functions have only one parameter.</p>
			<h2 id="_idParaDest-540"><a id="_idTextAnchor598"/>Exercise 14.07: More Uses for Composition and Curried Functions</h2>
			<p>In this exercise, you will further explore currying and composition. Most notably, you will see how you can create curried versions of common functions such as <code>Array.prototype.map</code> and <code>Array.prototype.filter</code> to compose other functions. In functional programming, common functions often need to be restructured so that they can be used as a building block for processing data in a chain of functions.</p>
			<p>The exercise will once again use the <code>runners</code> dataset. You will create a function to scan the data and return the age of the oldest female runner. The challenge is to do this using composition with <code>compose</code> or <code>pipe</code>, thereby feeding the results of one function into the next one in the pipeline.</p>
			<p>The basic outline of what we need to do is as follows:</p>
			<ul>
				<li>Create a function to filter the data just for female runners</li>
				<li>Create a function to map that data to just get the age of each runner</li>
				<li>Create a function that uses <code>Math.max()</code> to get the highest age value</li>
				<li>Compose the functions we've created so far and call them in sequence to get the final result</li>
			</ul>
			<p>The following steps show you how we do this in detail:</p>
			<ol>
				<li value="1">Open the Chrome menu at the top-right of your browser window, then select <code>Tools</code> | <code>Developer Tools</code>.</li>
				<li>Go to the console and paste in the sample runner data (beginning with <code>const runners = [...]</code>) from the <em class="italic">Sample Data for Examples</em> section of this chapter.</li>
				<li>First, create a curried version of <code>Array.prototype.filter</code>. Type the following into the console:<pre>const filter = fx =&gt; arr =&gt; arr.filter(fx);</pre></li>
				<li>Here, <code>fx</code> is the filtering function and <code>arr</code> is the array that is to be filtered. Note the ordering of the parameters, where the filtering function will be passed in before the array. This allows us to process the data itself as the last step.</li>
				<li>Similar to <code>filter</code>, you will need to create a curried version of <code>Array.prototype.map</code>. Type the following into the console:<pre>const map = fx =&gt; arr =&gt; arr.map(fx);</pre><p>Here, <code>fx</code> is the function to be called to map each array element, and <code>arr</code> is the array itself that is to be mapped to something else.</p></li>
				<li>The next function we need to restructure is <code>Math.max()</code>, which returns the highest number of the parameters passed in. Type the following into the console:<pre>const max = arr =&gt; Math.max(...arr);</pre><p>Here, <code>arr</code> is the array of numbers on which to find the max value. By default, <code>Math.max()</code> does not take an array as a parameter. However, by making use of the spread operator, that is, <code>...arr</code>, the individual array elements will be passed in as a series of parameters to <code>Math.max()</code> rather than as an array.</p></li>
				<li>Type in the implementation of the compose function:<pre>const compose = (...fns) =&gt; input =&gt; 
    fns.reduceRight((prev, fn) =&gt; fn(prev), input);</pre></li>
				<li>You are ready for our first attempt at composing these functions together. Type the following into the console:<pre>const oldestFemaleRunner1 = compose(
    max,
    map(runner =&gt; runner.age),
    filter(runner =&gt; runner.gender === "F")
);</pre><p>Remember that, with <code>compose</code>, the order of operations is from bottom to top. First, we have a filter function that picks out the female runners with the <code>runner.gender === "F"</code> expression. Next, we have a <code>map</code> function that <em class="italic">plucks</em> the <code>age</code> property from the female runners we resolved in the previous <code>filter</code> function and creates a new array with just the age values. Finally, <code>max</code> is called to obtain the oldest age from these values.</p></li>
				<li>We now have all the functions composed, but we still haven't actually run the array data through them to obtain the result. To do so, type the following into the console:<pre>const result1 = oldestFemaleRunner1(runners);</pre><p>Now print the result:</p><pre>console.log("Result of oldestFemaleRunner1 is ", result1);</pre><p>You will get an output stating that the oldest female runner is 39: </p><pre>// → output: Result of oldestFemaleRunner1 is 39</pre></li>
				<li>This works, but there is a slight improvement that can be made for the <code>femaleFilter</code> portion. Why not make it into a reusable function? We can do this like so:<pre>const femaleFilter = filter(runner =&gt; runner.gender === "F");</pre><p>Recall that <code>filter</code> was a curried function with two layers of parameters (<code>fx</code> and <code>arr</code>). Here, we are calling <code>filter</code> with the first parameter, <code>fx</code>, which results in a partially applied function. This <code>femaleFilter</code> function can now be used in any context, not just here.</p><p>Test the function by applying <code>femaleFilter</code> to compose the following:</p><pre>const oldestFemaleRunner2 = compose(
    max,
    map(runner =&gt; runner.age),
    femaleFilter
);
const result2 = oldestFemaleRunner2(runners);
console.log("Result of oldestFemaleRunner2 is ", result2);</pre><p>You will get an output stating that the oldest female runner is 39 when using the <code>filter</code> function, which is as follows: </p><pre>// → output: Result of oldestFemaleRunner2 is 39</pre></li>
				<li>Some people find the bottom-to-top order of processing confusing and unintuitive. Luckily, we have the <code>pipe</code> function, which functions the same as <code>compose</code> but in a top-to-bottom order. First, type in the implementation of the pipe function itself:<pre>const pipe = (...fns) =&gt; input =&gt; fns.reduce((prev, fn) =&gt; fn(prev), input);</pre></li>
				<li>Here is the equivalent using <code>pipe</code>:<pre>const oldestFemaleRunner3 = pipe(
    femaleFilter,
    map(runner =&gt; runner.age),
    max
);
const result3 = oldestFemaleRunner3(runners);
console.log("Result of oldestFemaleRunner3 is ", result3);</pre></li>
				<li>You will get the same output, that is, stating that the oldest female runner is 39 when using the pipe function, as follows: <pre>// → output: Result of oldestFemaleRunner3 is 39</pre></li>
			</ol>
			<p>In this exercise, we looked at composition and currying in more detail and how these can be used in tandem to complement each other. We used the curried version of <code>filter</code> to pass a filter for the runner's gender, passed the results to a <code>map</code> function to get only the <code>age</code> value, and finally used <code>Math.max</code> to find the highest value from the array of <code>age</code> values. While the previous exercise involved some aspects of combining simple functions into a more complex process, in this exercise, we actually used <code>compose</code> to create a new function that combined the subfunctions. This allows the new function, <code>oldestFemaleRunner1</code>, to be used by others without them having to consider the underlying subfunctions.</p>
			<p>In the next section, we'll learn about recursive functions – another vital aspect of functional programming that is somewhat limited in the JavaScript programming language due to the lack of something called tail-call optimization, which is present in other functional programming languages.</p>
			<h1 id="_idParaDest-541"><a id="_idTextAnchor599"/>Function Recursion</h1>
			<p>Another technique of functional programming involves functions calling themselves recursively. This generally means you start with a big problem and break it down into multiple instances of the same problem, but in smaller chunks each time the function is called.</p>
			<p>One common example of recursion is a function to reverse the characters of a string, <code>reverse(str)</code>. Think about how you can state this problem in terms of itself. Let's say you have a string, <code>"abcd"</code>, and want to reverse it to <code>"dcba"</code>.  Recognize that <code>"dcba"</code> can be restated as follows:</p>
			<pre>reverse("bcd") + "a"</pre>
			<p>In other words, you are taking the input string and breaking it down into a smaller problem by taking off the first character and making a recursive call with the remaining characters of the string. This may be easier to see in the following code:</p>
			<pre>function reverse(str) {
    if (str.length == 1) return str;
    return reverse(str.slice(1)) + str[0];
}
reverse("abcd");   // =&gt; output: "dcba"</pre>
			<p>Let's break this down:</p>
			<ul>
				<li>The <code>if</code> condition of <code>str.length == 1</code> is the base case. When the input has exactly one character, there is nothing left to reverse, so the solution is just the character itself.</li>
				<li>Otherwise, use <code>String.slice()</code> with an index of <code>1</code> to get a new string minus the first character of the input. Use this as the input to make the recursive call to <code>reverse()</code>.</li>
				<li>Return the result of the recursive call, plus the first character of the string (<code>str[0]</code>).</li>
			</ul>
			<p>Here's the step-by-step progression of calls:</p>
			<pre>reverse("abcd")  =&gt;  reverse("bcd") + "a"
reverse("bcd")   =&gt;  reverse("cd") + "b"
reverse("cd")    =&gt;  reverse("d") + "c"
reverse("d")     =&gt;  "d"</pre>
			<p>It is important to realize that these function calls are nested on the internal execution stack. Once the base case of one character is reached, the recursion finally has an actual return value, which causes the stack to "unwind." When this happens, the innermost function returns a value, then the function before it, and so on in reverse order until execution propagates back to the first call. This results in the return values of <code>"d"</code> for the innermost function, followed by <code>"dc"</code>, <code>"dcb"</code>, and finally our expected result: <code>"dcba"</code>.</p>
			<p>Recursion could be useful as another technique for avoiding code that requires the mutation of state and looping. As a matter of fact, it is possible to code recursive implementations of almost any loop, and some purely functional programming languages have a preference for recursion. However, current JavaScript engines are not optimized for recursion, which puts a damper on this and limits its usefulness. It is too easy to write code that would result in slow performance and excessive memory consumption. (Future enhancements that would mitigate these problems have been proposed, but until then, you need to be very careful if you are considering using recursion in your programs.)</p>
			<h2 id="_idParaDest-542"><a id="_idTextAnchor600"/>Exercise 14.08: Creating a Deck of Cards Using reduce()</h2>
			<p>We've looked at the basic elements of functional programming in JavaScript and a few data processing examples with runner data. But dealing with data doesn't have to be all number crunching – it can actually be fun. Take, for instance, a deck of cards, which in a way is simply a set of data values ordered in some way. In this exercise, we're going to create a deck of cards by combining four functions: <code>suits</code>, <code>rankNames</code>, and <code>createOrderedDeck</code>.</p>
			<ol>
				<li value="1">Create a function called <code>suits</code> and another called <code>rankNames</code> to describe the suits and values of a deck of playing cards. Rather than being arrays, they are functions that return arrays:<pre>const suits =
    () =&gt; [
        { suit: "hearts", symbol: '&amp;#9829;' },    // symbol: '♥'
        { suit: 'diamonds', symbol: '&amp;#9830;' },  // symbol: '♦'
        { suit: 'spades', symbol: '&amp;#9824;' },    // symbol: '♠'
        { suit: 'clubs', symbol: '&amp;#9827;' }      // symbol: '♣'
    ];
const rankNames =
    () =&gt; ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q','K'];</pre></li>
				<li>Create a function called ranks that takes the rankNames array as input and returns each rank mapped as a key-value pair.<pre>const ranks =
    rankNames =&gt; rankNames.map(rankName =&gt; ({ rank: rankName }));</pre></li>
				<li>Create a function called <code>createOrderedDeck</code> that takes <code>suits</code> and <code>rank</code> as input and returns all the possible combinations (for example, every card in the deck):<pre>const createOrderedDeck =
    (suits, ranks) =&gt; suits.reduce(
        (deck, suit) =&gt; {
            const cards = ranks.map(rank =&gt; ({ ...rank, ...suit }));
            return deck.concat(cards);
        }, []);</pre><p>We use <code>Array.prototype.reduce</code> with an empty array <code>[]</code> as the initial value.  We then "iterate" over the <code>suits</code>, and use <code>Array.prototype.map</code> over the <code>ranks</code> to combine the suits and ranks by using the spread operator (<code>...</code>).  The  <code>Array.prototype.concat()</code> method then adds the new cards to the resulting array.  Once the "nested loop" is complete, we end up with 52 unique cards with all the combinations of suits and ranks.</p></li>
				<li>Next, we'll create an instance of a deck of cards by creating a variable from the result of <code>createOrderedDeck</code> and our <code>suits</code> and <code>ranks</code> functions:<pre>const orderedDeck = createOrderedDeck(suits(), ranks(rankNames()));</pre></li>
				<li>To demonstrate what has been done so far, open up the Google Chrome browser, go to <code>Developer</code> Tools, and then paste in the preceding steps. After you've done that, type in <code>orderedDeck</code>. You should get an array like the one shown in the following screenshot. Try clicking on some of the items to look at the contained cards:</li>
			</ol>
			<div><div><img alt="Figure 14.12: List of a deck of cards using the reduce function&#13;&#10;" src="img/C14377_14_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.12: List of a deck of cards using the reduce function</p>
			<p>In this<a id="_idTextAnchor601"/> exercise, we looked at the <code>reduce</code> function we learned about earlier in the chapter and applied it to the situation of creating a deck of cards. We'll build on this in the next exercise to create a function that shuffles a deck randomly, in a way that would make it useful for games.</p>
			<h2 id="_idParaDest-543"><a id="_idTextAnchor602"/>Exercise 14.09: Using the pipe Method to Create a Card Shuffling Function</h2>
			<p>Now that we have an ordered deck of cards, we'll look at how we can shuffle it. Of course, as with all functional code, we'll do this without modifying any existing variables.</p>
			<ol>
				<li value="1">Continuing in the same console as the previous exercise, define the <code>pipe</code> and <code>map</code> functions we discussed earlier. We won't use <code>compose</code> here, but you should get into the habit of defining these three functions for each program when writing functional code as you'll be using them a lot:<pre>const compose =
    (...fns) =&gt; input =&gt; fns.reduceRight((prev, fn) =&gt; fn(prev), input);
const pipe =
    (...fns) =&gt; input =&gt; fns.reduce((prev, fn) =&gt; fn(prev), input);
const map = fx =&gt; arr =&gt; arr.map(fx);</pre><p>The <code>addRandom</code> function adds a field called <code>random</code> to each element.  Note how the random number itself is obtained from a separate <code>randomizer</code> method.  This is to keep the <code>addRandom</code> function as pure as possible, and isolate the code that has side-effects.</p></li>
				<li>Create a <code>randomizer</code> variable, followed by an <code>addRandom</code> curry function:<pre>const randomizer =
    Math.random;
const addRandom =
    randomizer =&gt; deck =&gt; deck.map(card =&gt; ({
        random: randomizer(),
        card
    }));</pre></li>
				<li>Create a <code>sortByRandom</code> function that sorts an input deck randomly:<pre>const sortByRandom =
    deck =&gt; [...deck].sort((a, b) =&gt; a.random - b.random);</pre><p>This function sorts the cards by the added <code>random</code> field.  The <code>spread</code> operator (...) is used to clone the array before sorting it, rather than sorting the original array.</p></li>
				<li>Create a <code>shuffle</code> function that takes a deck and a randomizer value (the randomizer can be changed later if there is a need for a more random value, as would be the case in real casino games). We then use <code>pipe</code> to create a function that combines <code>addRandom</code> <em class="italic">(to specify our randomizer)</em>, <code>sortByRandom</code>, and a <code>map</code> function. Finally, we'll execute the <code>doShuffle</code> function we just created and use our deck of cards as the input:<pre>const shuffle =
    (deck, randomizer) =&gt; {
        const doShuffle = pipe(
            addRandom(randomizer),
            sortByRandom,
            map(card =&gt; card.card)
        );
        return doShuffle(deck);
    };</pre><p>The purpose of the curried <code>map</code> function is to remove the <code>random</code> field that was added earlier and just preserve the original fields related to the card itself.</p></li>
				<li>Open up the Google Chrome <code>Developer Tools</code> session from the previous exercise. If you don't have it saved, you'll need to input the code from the previous exercise. At that point, input the preceding four code snippets from this exercise. With that, execute the <code>shuffle</code> function with <code>shuffle(orderedDeck, randomizer)</code> and then explore the returned object by clicking it and observing that the cards are shuffled, as shown in the following screenshot:</li>
			</ol>
			<div><div><img alt="Figure 14.13: List of a deck of cards using the reduce function&#13;&#10;" src="img/C14377_14_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.13: List of a deck of cards using the reduce function</p>
			<p>We can see the shuffled lists of cards as using the <code>pipe and map</code> functions. We can now go ahead and use these functions to work on the Blackjack card game.</p>
			<h1 id="_idParaDest-544"><a id="_idTextAnchor603"/>Blackjack</h1>
			<p>For the remainder of this chapter, we will be using what we've learned about functional programming to write an implementation of a simple variant of the card game Blackjack.</p>
			<p>Unlike regular Blackjack, though, our game only has one player. The player can draw as many cards as they want (<code>hit</code>), as long as the total value does not exceed 21.</p>
			<p>The total is the sum of the values of the cards in the player's hand. Cards have the following values:</p>
			<ul>
				<li>Numeric cards have their face value (for example, a 6 of hearts has a value of 6)</li>
				<li>A Jack, Queen, or King has a value of 10</li>
				<li>For simplicity, the Ace is worth 1 (unlike regular Blackjack, where it has a value of either 1 or 11)</li>
			</ul>
			<p>If the total value exceeds 21, the hand has gone bust and the game is over.</p>
			<h2 id="_idParaDest-545"><a id="_idTextAnchor604"/>Mapping Card Values to Cards</h2>
			<p>The two previous exercises will be very useful in the final assignment, where you'll be implementing a Blackjack game. Feel free to use those code snippets directly. Of course, it won't be sufficient to know just the cards' names – you'll also want to know the value of each card. The <code>map</code> function we previously explored will come in very handy for this. Enhance the <code>ranks</code> currying function from <em class="italic">Exercise 8: Creating a Deck of Cards Using reduce</em> to convert <code>rankNames</code> into both <code>rank</code> and <code>value</code> fields:</p>
			<pre>const ranks =
    rankNames =&gt; rankNames.map(
        (rank, index) =&gt; ({ rank, value: Math.min(10, index + 1) }));</pre>
			<p>This function takes advantage of the index passed in as the optional second parameter in the mapping function. The rank "<code>A</code>" is at index <code>0</code>, so the value resolves as <code>1</code> (since the formula is <code>index</code> + <code>1</code>). The rank "<code>2</code>" is at index <code>1</code>, so the value would resolve to <code>2</code> (since <code>index</code> + <code>1</code> = <code>2</code>). Same applies to the rest of the numbers, the value would resolve to the same as the number. Once we get to "<code>J</code>" and above, though, the value resolves to <code>10</code> due to <code>Math.min()</code>.</p>
			<p>Now, enter <code>orderedDeck</code> and explore the object that is returned. You'll notice that all the items now have a value, and the value for the face suits (<code>J</code>, <code>Q</code>, <code>K</code>) are all 10:</p>
			<div><div><img alt="Figure 14.14: Ordered list of a deck of cards using the order function&#13;&#10;" src="img/C14377_14_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.14: Ordered list of a deck of cards using the order function</p>
			<p>With the functions we've now covered relating to cards using the basics of functional programming, that is, <code>map</code>, <code>reduce</code>, <code>compose</code>, and <code>pipe</code>, you will have a strong foundation for building your own card games.</p>
			<h2 id="_idParaDest-546"><a id="_idTextAnchor605"/>Activity 14.01: Blackjack Card Functions</h2>
			<p>The aim of this activity is to get you to create some of the functions that are needed to code a Blackjack game with what you learned about functional programming. You will not be coding the whole game, just some of the core functions related to card logic.</p>
			<p>In the GitHub project, you'll find a pre-built HTML file <code>start.html</code> with some CSS in it that you should use as a starting point.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Open the starting point HTML/CSS file called <code>blackjack/start.html.</code></li>
				<li>Add or implement the functions for creating a deck of cards using suits, rank names, and values.</li>
				<li>Write implementations for the core functional programming methods, that is, <code>pipe</code>, <code>compose</code>, and <code>map</code>.</li>
				<li>Add functions for drawing a card, getting the sum of a player's cards, checking whether a hand is over 21 points, and checking whether the game is over (the player stayed or went bust).</li>
				<li>Add a function for updating the card display and card images.</li>
				<li>Add a function for updating the status display, which tells the user the sum of their hand.</li>
				<li>Add the <code>play</code>, <code>hit</code>, and <code>stay</code> handler functions for the different actions a user can take.</li>
				<li>Finally, add any impure functions you may need, such as helpers for getting an element by ID or class.</li>
				<li>Add a function for setting the state, as well as a function to trigger the game itself.</li>
			</ol>
			<p>With these steps done, you should now be able to open the HTML file in a browser and have a running version of the game, as shown in the following screenshot:</p>
			<div><div><img alt="Figure 14.15: Screenshot of the Blackjack game&#13;&#10;" src="img/C14377_14_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.15: Screenshot of the Blackjack game</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 758.</p>
			<p>Admittedly, this implementation of Blackjack is not very playable and won't win awards for visual design. However, it is a great demonstration of functional programming. See if you can use this code as a basis to implement your own full two-player version of the game.</p>
			<h2 id="_idParaDest-547"><a id="_idTextAnchor606"/>Managing Blackjack Game State</h2>
			<p>This game only requires a small amount of state: namely, the player's hand, the game deck, and if the player has selected to stay (and not ask for another card). This state management is isolated to the following code:</p>
			<pre>const createState = (dom) =&gt; {
    let _state;
    const getState = () =&gt; [..._state];
    const setState =
        (hand, gameDeck, stay = false) =&gt; {
            _state = [hand, gameDeck];
            updateCardDisplay(dom, hand);
            updateStatusDisplay(dom, hand, stay);
        };
    return { getState, setState };
}</pre>
			<p>Notice the <code>return</code> statement at the end. Only the two methods <code>getState</code> and <code>setState</code> end up being exposed to the caller, but the <code>_state</code> variable remains safe in the closure and acts as the equivalent of a "private" field in object-oriented programming. In addition:</p>
			<ul>
				<li>To isolate the code that produces side-effects as much as possible, there is a separate parameter <code>dom</code> that has references to other functions that actually do DOM manipulation.</li>
				<li>The <code>getState</code> function returns a clone of the state fields (using the spread operator ...), not the actual values in the fields</li>
				<li>When <code>setState</code> is called, two other functions <code>updateCardDisplay</code> and <code>updateStatusDisplay</code> are called (presented soon) to update the respective portions of the display to correspond to the new state. These functions are designed to dynamically regenerate all the HTML related to the state values each time the state changes.  his way there is no additional state needed in the display logic itself. (Popular web frameworks like Angular and React update displays in much the same way, though with some optimizations for the sake of performance).</li>
			</ul>
			<p>The state is created at the start of the game:</p>
			<pre>startGame(createState(dom));</pre>
			<h2 id="_idParaDest-548"><a id="_idTextAnchor607"/>Blackjack Game Logic Flow</h2>
			<p>The <code>startGame</code> function itself registers three event handling functions to respond to the three buttons the user may click: <code>New Game</code>, <code>Hit</code> or <code>Stay</code>:</p>
			<pre>const startGame = (state) =&gt; {
    byId("playBtn").addEventListener("click", playHandler(randomizer, state));
    byId("hitBtn").addEventListener("click", hitHandler(state));
    byId("stayBtn").addEventListener("click", stayHandler(state));
}</pre>
			<p>The <code>playHandler</code> function looks like this:</p>
			<pre>const playHandler = (randomizer, { getState, setState }) =&gt; () =&gt; {
    const orderedDeck = createOrderedDeck(suits(), ranks(rankNames()));
    let gameDeck = shuffle(orderedDeck, randomizer);
    [hand, gameDeck] = draw(gameDeck, 2);
    setState(hand, gameDeck);
};</pre>
			<p>First the deck is created and shuffled to create the full game deck.  Two cards are then drawn from the game deck as the hand. The hand and remaining game deck (minus the two cards drawn) are saved by calling <code>setState</code> (which indirectly also triggers the screen to display the cards).</p>
			<p>The <code>hitHandler</code> function follows a similar pattern:</p>
			<pre>const hitHandler = ({ getState, setState }) =&gt; () =&gt; {
    [hand, gameDeck] = getState();
    [card, gameDeck] = draw(gameDeck, 1);
    setState(hand.concat(card), gameDeck);
};</pre>
			<p>The current hand and game deck is retrieved by calling <code>getState</code>. Then one card is drawn from the game deck. This card is added to the hand and saved by calling <code>setState</code> (which once again indirectly also triggers the screen to display the cards).</p>
			<p>The <code>stayHandler</code> is simpler. It doesn't make any state modifications besides calling <code>setState</code> with <code>true</code> in the last parameter, indicating the player has stayed:</p>
			<pre>const stayHandler = ({ getState, setState }) =&gt; () =&gt; {
    [hand, gameDeck] = getState();
    setState(hand, gameDeck, true);
};</pre>
			<h2 id="_idParaDest-549"><a id="_idTextAnchor608"/>Blackjack Game Display Functions</h2>
			<p>The <code>updateCardDisplay</code> function is the following:</p>
			<pre>const updateCardDisplay =
    ({ updateHTML }, hand) =&gt; {
        const cardHtml = hand.map((card, index) =&gt;
            `&lt;div class="card ${card.suit}"
                style="top: -${index * 120}px;
                       left: ${index * 100}px;"&gt;
                &lt;div class="top rank"&gt;${card.rank}&lt;/div&gt;
                &lt;div class="bigsuit"&gt;${card.symbol}&lt;/div&gt;
                &lt;div class="bottom rank"&gt;${card.rank}&lt;/div&gt;
             &lt;/div&gt;`);
        updateHTML("cards", cardHtml.join(""));
    };</pre>
			<p>The HTML for each card in the hand is determined in this function using <code>Array.prototype.map</code> and joined together at the end to make one string. The calculations for the styles <code>top</code> and <code>left</code> take advantage of the optional <code>index</code> parameter of the mapping function to allow the cards to have a staggered effect. Different CSS classes <code>top</code>, <code>rank</code>, <code>bigsuit</code> and <code>bottom</code> position and size the different parts of the card. The suit name itself is also a CSS class to apply the correct color for the suit (black or red).</p>
			<p>The other function related to display, <code>updateStatusDisplay</code>, is implemented as follows:</p>
			<pre>const updateStatusDisplay =
    ({ updateStyle, updateHTML }, hand, stay) =&gt; {
        const total = sumCards(hand);
        updateHTML("totalSpan", total);
        const bust = isBust(total);
        const gameover = isGameOver(bust, stay);
        showOrHide(updateStyle, "playBtn", !gameover);
        showOrHide(updateStyle, "hitBtn", gameover);
        showOrHide(updateStyle, "stayBtn", gameover);
        let statusMsg = gameover ?
            "Game over.  Press New Game button to start again." :
            "Select Hit or Stay";
        statusMsg = bust ? "You went bust!!! " + statusMsg : statusMsg;
        updateHTML("statusMsg", statusMsg);
    };</pre>
			<p>This function does several things:</p>
			<ul>
				<li>Calculates the total value of the cards and displays it</li>
				<li>Determines if the game is over by calling <code>isBust</code> and <code>isGameOver.</code>  (If a hand is in play, the New Game button should not be visible.  If the game is over or not active, the Hit and Stay buttons should not be visible. See Figure 14.16.)</li>
				<li>Shows or hides the different buttons depending on if the game is over or not</li>
				<li>Changes the status message depending on if the game is over or not</li>
			</ul>
			<div><div><img alt="Figure 14.16: The Hit and Stay buttons are visible when the game is active&#13;&#10;" src="img/C14377_14_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.16: The Hit and Stay buttons are visible when the game is active</p>
			<p>Effectively, this function actually drives much of the game flow, as the UI elements available to the user are set within it.</p>
			<h2 id="_idParaDest-550"><a id="_idTextAnchor609"/>Blackjack Code Listing</h2>
			<p>The previous sections covered the most important parts of the code. The full code listing for the game is linked as follows:</p>
			<p><a href="https://packt.live/370zgaq">https://packt.live/370zgaq</a></p>
			<p>For simplicity, all the code is contained within one file, including all the CSS styles and JavaScript supporting functions. In a real-world application, though, you should consider splitting up the files.</p>
			<h1 id="_idParaDest-551"><a id="_idTextAnchor610"/>Summary</h1>
			<p>In this chapter, you got a taste of functional programming. It is quite different from other programming paradigms such as imperative and object-oriented approaches, and it takes a while to get used to. But when properly applied, it is a very powerful way of structuring programs so that they're more declarative, correct, testable, and have fewer errors.</p>
			<p>Even if you don't use pure functional programming in your projects, there are many useful techniques that can be used on their own. This is especially true for the <code>map</code>, <code>reduce</code>, and <code>filter</code> array methods, which can have many applications.</p>
			<p>This chapter also only used functionality that's available in native JavaScript. But note that there are also a number of popular libraries available to assist with functional programming. These libraries facilitate practical functional programming concerns such as immutability, side-effect-free functions, composition, and automatic currying. </p>
			<p>The topics we covered in this chapter will help you bolster the skills you need to pursue a programming project in the functional style.</p>
			<p>In the next chapter, you will take a deeper look at asynchronous coding, including the history of asynchronous callbacks, generators, promises, and async/await. This will complete your journey through modern JavaScript development, priming you with all you need to create great-looking software.</p>
		</div>
		<div><div></div>
		</div>
	</body></html>