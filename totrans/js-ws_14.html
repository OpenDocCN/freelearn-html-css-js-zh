<html><head></head><body>
		<div>
			<div class="Content" id="_idContainer330">
			</div>
		</div>
		<div class="Content" id="_idContainer331">
			<h1 id="_idParaDest-518"><a id="_idTextAnchor575"/>14. Understanding Functional Programming</h1>
		</div>
		<div class="Content" id="_idContainer348">
			<p class="callout-heading">Overview</p>
			<p class="callout">By the end of this chapter, you will be able to use functional programming concepts such as pure functions, immutability, composition, and currying; use higher-order functions such as filter, map, and reduce; apply techniques such as cloning objects to reduce side effects in your code; and demonstrate strategies for reducing imperative logic and <strong class="source-inline">for</strong> loops in your code.</p>
			<h1 id="_idParaDest-519"><a id="_idTextAnchor576"/>Introduction</h1>
			<p>In the previous chapter, we talked about how JavaScript is a multi-paradigm programming language. It's possible to write code with procedural, object-oriented, and functional design patterns. In this chapter, we'll look closely at the functional programming design pattern.</p>
			<p>Functional programming is a programming paradigm that has become popular in the last few years, though most JavaScript developers were unfamiliar with it before then.</p>
			<p>JavaScript is not a purely functional language like some others, such as Haskell, Scheme, and Clojure. However, JavaScript has support for functional structures and techniques if you choose to use them. It is worthwhile becoming familiar with its concepts and gaining a working knowledge of how to use them.</p>
			<p>Functional programming has a set of features. Among others, here are some of the important ones:</p>
			<ul>
				<li>Pure functions</li>
				<li>Immutability and avoiding shared state, mutable data, and side effects</li>
				<li>Declarative rather than imperative</li>
				<li>Higher-order functions</li>
				<li>Function composition and piping</li>
				<li>Currying functions</li>
				<li>Reduces the use of traditional flow control structures such as <strong class="source-inline">for</strong>, <strong class="source-inline">while</strong>, and even <strong class="source-inline">if</strong></li>
			</ul>
			<p>These concepts will be covered over the course of this chapter. If implemented correctly, functional programming can result in code that is more predictable, less error-prone, and easier to test compared to other programming methods.</p>
			<h1 id="_idParaDest-520"><a id="_idTextAnchor577"/>Pure Functions</h1>
			<p>Pure functions are one of the pillars of functional programming. A function is pure if it always returns the same result when it's given the same parameters. It also cannot depend on or modify variables or state outside of the function's scope.</p>
			<p>A simple example of an impure function is as follows:</p>
			<p class="source-code">var positionX = 10;</p>
			<p class="source-code">function moveRight(numSlots) {</p>
			<p class="source-code">    positionX += numSlots;</p>
			<p class="source-code">}</p>
			<p class="source-code">moveRight(5);</p>
			<p>You can plainly see how the function is manipulating a value outside of its scope in the <a id="_idTextAnchor578"/><strong class="source-inline">positionX</strong> global variable. A pure function should only use the arguments that have been passed in for its logic, and should not directly modify them. Another issue is that the function doesn't actually return a value.</p>
			<p>Consider the following code. Can you see why it would not be considered a pure function?</p>
			<p class="source-code">var positionX = 10;</p>
			<p class="source-code">function moveRight(numSlots) {</p>
			<p class="source-code">    return positionX + numSlots;</p>
			<p class="source-code">}</p>
			<p class="source-code">positionX = moveRight(5);</p>
			<p>Though the function only reads the global variable value and does not manipulate the variable directly, it is still not pure. To see why think about what happens if you call the function multiple times with the value <strong class="source-inline">5</strong> for the <strong class="source-inline">numSlots</strong> parameter:</p>
			<ul>
				<li>The first time, the result is <strong class="source-inline">15</strong> (since <strong class="source-inline">positionX</strong> is <strong class="source-inline">10</strong> and <strong class="source-inline">10 + 5 = 15</strong>)</li>
				<li>The second time, the result would be <strong class="source-inline">20</strong></li>
				<li>The third time, the result would be <strong class="source-inline">25</strong></li>
			</ul>
			<p>In other words, there is a different result for each invocation. For the function to be pure, the result would have had to resolve to the exact same value for the given parameter value, that is, <strong class="source-inline">5</strong>. Also, consider how difficult it would be to write tests for this function since the result is not predictable.</p>
			<p>The correct way of making this function pure is as follows:</p>
			<p class="source-code">var positionX = 10;</p>
			<p class="source-code">function moveRight(x, numSlots) {</p>
			<p class="source-code">    return x + numSlots;</p>
			<p class="source-code">}</p>
			<p class="source-code">positionX = moveRight(positionX, 5);</p>
			<p>In this version, all the data that the function uses in its logic is passed in as arguments, and it does not refer to any data outside of the function's scope. It will also always have the same result for a set of given parameters:</p>
			<ul>
				<li>If <strong class="source-inline">x=10</strong> and <strong class="source-inline">numSlots=5</strong>, the result will always be <strong class="source-inline">15</strong>.</li>
				<li>If <strong class="source-inline">x=15</strong> and <strong class="source-inline">numSlots=5</strong>, the result will always be <strong class="source-inline">20</strong>.</li>
				<li>If <strong class="source-inline">x=20</strong> and <strong class="source-inline">numSlots=5</strong>, the result will always be <strong class="source-inline">25</strong>. </li>
			</ul>
			<p>The predictability of the result makes the code quality higher, makes it easier to reason about the function, and makes it easier to write tests. It also makes the code maintainable and less risky if the function ever needs to be refactored.</p>
			<h2 id="_idParaDest-521"><a id="_idTextAnchor579"/>Side Effects</h2>
			<p>An important concept in functional programming that is closely related to pure functions is reducing side effects. A side effect is when a function performs some action, either directly or indirectly, that is not strictly for the purpose of the function or its return value.</p>
			<p>Examples of side effects are actions such as showing an alert box, writing to a file, triggering a service call on the network, or making changes to the DOM. (Actually, when we manipulated the global variable in the impure function example in the previous section, we were also creating a type of side effect known as the shared state.)</p>
			<p class="callout-heading">Note </p>
			<p class="callout">It is not possible or desirable to create programs that have no side effects whatsoever. After all, what good is the program if you can't see the output in some way? However, functional programmers aim to create pure functions most of the time and isolate the functions and parts of the code that require output or side effects. Keeping such code separate helps you understand your software better for debugging, to create better tests, and to ease future maintenance and extensions.</p>
			<h2 id="_idParaDest-522"><a id="_idTextAnchor580"/>Immutability</h2>
			<p>Another concept in functional programming is to prefer immutable values and objects over mutable ones as much as possible. In short, immutable objects are those whose values cannot change once they are created, even if those objects are used. Going forward, we will perform a few exercises to demonstrate how certain objects such as strings and numbers are immutable, whereas arrays are not. We will begin with the immutability of strings in the following exercise.</p>
			<h2 id="_idParaDest-523"><a id="_idTextAnchor581"/>Exercise 14.01: Immutable Values and Objects – Strings</h2>
			<p>In this exercise, we will demonstrate how strings are immutable. Let's get started:</p>
			<ol>
				<li>In the Google Chrome browser, go to <strong class="source-inline">Developer Tools</strong> (go to the menu with the three dots at the upper-right of the screen | <strong class="source-inline">More Tools</strong> | <strong class="source-inline">Developer Tools</strong>, or just hit the <em class="italic">F12</em> key).</li>
				<li>JavaScript has several built-in immutable objects, such as strings. Create two constants, <strong class="source-inline">string1</strong> and <strong class="source-inline">string2</strong>, and assign the variable so that <strong class="source-inline">string2</strong> is a substring of <strong class="source-inline">string1</strong>:<p class="source-code">const string1 = "Hello, World!";</p><p class="source-code">const string2 = string1.substring(7, 12);</p></li>
				<li>Display both strings. Type the following into the console:<p class="source-code">console.log(`string1: ${string1}`);</p><p class="source-code">console.log(`string2: ${string2}`);</p></li>
				<li>This code results in the following output:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer332">
					<img alt="Figure 14.1: Output of strings&#13;&#10;" src="image/C14377_14_01.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.1: Output of strings</p>
			<p>From this, you can see that the execution of <strong class="source-inline">substring()</strong> on <strong class="source-inline">string1</strong> did not change the value of <strong class="source-inline">string1</strong> in any way, demonstrating that the string is immutable. It actually results in a new string consisting of the characters of the partial string between the given indices. This result is then set as the value of the <strong class="source-inline">string2</strong> variable.</p>
			<h2 id="_idParaDest-524"><a id="_idTextAnchor582"/>Exercise 14.02: Immutable Values and Objects – Numbers</h2>
			<p>Primitives such as numbers are also immutable. In this exercise, we will perform an operation on a number to demonstrate immutability in numbers. </p>
			<ol>
				<li value="1">Create two constants, <strong class="source-inline">number1</strong> and <strong class="source-inline">number2</strong>, and assign them numeric values such that <strong class="source-inline">number2</strong> is half of the value of <strong class="source-inline">number1</strong>:<p class="source-code">const number1 = 500;</p><p class="source-code">const number2 = number1 / 2;</p></li>
				<li>Display both number objects. Type the following into the console:<p class="source-code">console.log(`number1: ${number1}`);</p><p class="source-code">console.log(`number2: ${number2}`);</p></li>
				<li>This code results in the following output:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer333">
					<img alt="Figure 14.2: Output of numbers&#13;&#10;" src="image/C14377_14_02.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.2: Output of numbers</p>
			<p>We can see that performing a calculation with <strong class="source-inline">number1</strong> and setting the result to a new variable does not affect the original variable.</p>
			<h2 id="_idParaDest-525"><a id="_idTextAnchor583"/>Exercise 14.03: Mutability – Arrays</h2>
			<p>So far, we have looked at immutable objects. From this point on, we will look at examples of objects that do not have this immutability. In this exercise, we'll create an array and assign its values to another array, and then we'll modify its value to demonstrate how arrays are mutable.</p>
			<ol>
				<li value="1">Create and define <strong class="source-inline">array1</strong> so that it has three value elements, namely, <strong class="source-inline">'one'</strong>, <strong class="source-inline">'two'</strong>, and <strong class="source-inline">'three'</strong>:<p class="source-code">const array1 = ['one', 'two', 'three'];</p></li>
				<li>Create another array, <strong class="source-inline">array2</strong>, with the value equal to <strong class="source-inline">array1</strong>:<p class="source-code">const array2 = array1;</p></li>
				<li>Now, append another element, <strong class="source-inline">'four'</strong>, to <strong class="source-inline">array2</strong>: <p class="source-code">array2.push('four');</p></li>
				<li>Display both outputs in the console, like so:<p class="source-code">console.log(`array1: ${array1}`);</p><p class="source-code">console.log(`array2: ${array2}`);</p></li>
			</ol>
			<p>This code results in the following output:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer334">
					<img alt="Figure 14.3: Output of arrays&#13;&#10;" src="image/C14377_14_03.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.3: Output of arrays</p>
			<p>Here, we assigned the <strong class="source-inline">array2</strong> variable to the same array as <strong class="source-inline">array1</strong>, and then appended another element to <strong class="source-inline">array2</strong> (the value <strong class="source-inline">'four'</strong>). It may surprise you that <strong class="source-inline">array1</strong> is affected and gets the element added to it as well, unlike the other examples so far. This is because when the assignment is made to <strong class="source-inline">array2,</strong> it does not create a new array. Rather, it assigns only a reference that points to the original array, that is, <strong class="source-inline">array1</strong>. Manipulating either array would affect both of the variables as they are in fact the same array.</p>
			<h2 id="_idParaDest-526"><a id="_idTextAnchor584"/>Exercise 14.04: Mutability – Objects</h2>
			<p>In this exercise, we will assign values to properties in an object to demonstrate mutability in objects.</p>
			<ol>
				<li value="1">Create an object, <strong class="source-inline">actor1</strong>, with the properties <strong class="source-inline">name</strong> and <strong class="source-inline">show</strong>. Assign the value <strong class="source-inline">Sheldon</strong> and <strong class="source-inline">BB Theory</strong> to these properties:<p class="source-code">const actor1 = {</p><p class="source-code">    name: 'Sheldon',</p><p class="source-code">    show: 'BB Theory'</p><p class="source-code">};</p></li>
				<li>Now, create another variable, <strong class="source-inline">actor2</strong>, and assign it to the same object as <strong class="source-inline">actor1</strong>. Then, also add a new property to <strong class="source-inline">actor2</strong> called <strong class="source-inline">name</strong><p class="source-code">const actor2 = actor1;</p><p class="source-code">actor2.name = 'Leonard';</p></li>
				<li>Type the following into the console:<p class="source-code">console.log("actor1:", actor1);</p><p class="source-code">console.log("actor2:", actor2);</p></li>
				<li>This code results in the following output:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer335">
					<img alt="Figure 14.4: Output for objects&#13;&#10;" src="image/C14377_14_04.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.4: Output for objects</p>
			<p>As you can see, both the objects in the <strong class="source-inline">actor1</strong> and <strong class="source-inline">actor2</strong> variables end up being exactly the same. The <strong class="source-inline">name</strong> property is not only in <strong class="source-inline">actor2</strong>, as you might expect. This is once again because <strong class="source-inline">actor2</strong> is only a reference to <strong class="source-inline">actor1</strong>, and is not its own object.</p>
			<p>Another point is worth mentioning as well. In all these examples, the variables were defined as constants using the <strong class="source-inline">const</strong> keyword. However, as we have seen in the last two examples, we were able to make changes to the object and the compiler did not complain. This shows that the <strong class="source-inline">const</strong> keyword is <em class="italic">not</em> equivalent to saying the value is immutable!</p>
			<p>All <strong class="source-inline">const</strong> means is that the compiler prevents you from being able to reassign the variable to a new object. It does not restrict you from changing the properties of the assigned object or adding array elements, though.</p>
			<p>The next section will show you some strategies regarding how to handle mutable objects effectively.</p>
			<h2 id="_idParaDest-527"><a id="_idTextAnchor585"/>Cloning Objects and Arrays</h2>
			<p>In the previous exercise, you saw how arrays and objects are mutable. What if you need to make modifications, though? How can you do this in a safe manner that avoids side effects?</p>
			<p>First, there's a simple technique for arrays. If you are just adding an element to the array, you can use <strong class="source-inline">Array.prototype.concat</strong> rather than <strong class="source-inline">Array.prototype.push</strong>. The difference is that <strong class="source-inline">concat</strong> returns a new array copy with the element added, whereas <strong class="source-inline">push</strong> modifies the original array.</p>
			<p>We can see this in the following code. Here, <strong class="source-inline">array1</strong> and <strong class="source-inline">array2</strong> are now, in fact, distinct objects:</p>
			<p class="source-code">const array1 = ['one', 'two', 'three'];</p>
			<p class="source-code">const array2 = array1.concat('four');</p>
			<p class="source-code">console.log(`array1: ${array1}`);   // output: array1: one,two,three</p>
			<p class="source-code">console.log(`array2: ${array2}`);   // output: array2: one,two,three,four</p>
			<p>The output of the preceding code would be as follows:</p>
			<p class="source-code">array1: one,two,three</p>
			<p class="source-code">and</p>
			<p class="source-code">array2: one,two,three,four</p>
			<p>For other array modifications or to manipulate objects, you would usually need to clone the array or object and operate on the clone. How do you make clones, you ask? Here's a neat trick: in newer JavaScript versions (since ECMAScript 2018), the spread syntax works for both arrays and objects. Using the spread syntax, you can do the following:</p>
			<p class="source-code">// Arrays</p>
			<p class="source-code">const array1 = ['one', 'two', 'three'];</p>
			<p class="source-code">const array2 = [...array1];</p>
			<p class="source-code">array2[0] = 'four';</p>
			<p class="source-code">console.log(`array1: ${array1}`);   // output: array1: one,two,three</p>
			<p class="source-code">console.log(`array2: ${array2}`);   // output: array2: four,two,three</p>
			<p class="source-code">// Objects</p>
			<p class="source-code">const actor1 = {</p>
			<p class="source-code">    name: 'Sheldon',</p>
			<p class="source-code">    show: 'BB Theory'</p>
			<p class="source-code">};</p>
			<p class="source-code">       </p>
			<p class="source-code">const actor2 = {...actor1};</p>
			<p class="source-code">actor2.name = 'Leonard';</p>
			<p class="source-code">//the output for variable actor1 will be displayed.       </p>
			<p class="source-code">console.log("actor1:", actor1);   </p>
			<p>The output of <strong class="source-inline">const actor1</strong> will be as follows:</p>
			<p class="source-code">    // output: actor1: { name: "Sheldon", show: "BB Theory" }</p>
			<p class="source-code">//the output for variable actor2 will be displayed.</p>
			<p class="source-code">console.log("actor2:", actor2);</p>
			<p>The output of <strong class="source-inline">const actor2</strong> will be as follows:</p>
			<p class="source-code">    // output: actor2: { name: "Leonard", show: "BB Theory" }</p>
			<p>Notice that there are three consecutive dots in <strong class="source-inline">[...array1]</strong> and <strong class="source-inline">{...actor1}</strong>. These dots are known as spread operators. Using the spread syntax in this fashion effectively clones the array, or key-value pairs in the case of an object.</p>
			<p>There is one caveat, though. This method only makes a shallow copy, which means only the top-level elements or properties are copied. Beyond the top level, only references are created. What this means is that, for example, multi-dimensional arrays or nested objects are not copied.</p>
			<p>If a deep copy is required, one popular method is to convert the object into a JSON string and parse it right back, similar to the following code. This works for both objects and arrays:</p>
			<p class="source-code">let object2 = JSON.parse(JSON.stringify(object1));</p>
			<p>The deep copy method also has the added benefit of working on older versions of JavaScript.</p>
			<h2 id="_idParaDest-528"><a id="_idTextAnchor586"/>Sample Data for Examples and Exercises</h2>
			<p>Before we go further, we need to introduce a scenario with sample data. In the upcoming sections, the following data will be used in the examples and exercises:</p>
			<p class="source-code">const runners = [</p>
			<p class="source-code">    {name: "Courtney", gender: "F", age: 21, timeSeconds: 1505},</p>
			<p class="source-code">    {name: "Lelisa",   gender: "M", age: 24, timeSeconds: 1370},</p>
			<p class="source-code">    {name: "Anthony",  gender: "M", age: 32, timeSeconds: 1538},</p>
			<p class="source-code">    {name: "Halina",   gender: "F", age: 33, timeSeconds: 1576},</p>
			<p class="source-code">    {name: "Nilani ",  gender: "F", age: 27, timeSeconds: 1601},</p>
			<p class="source-code">    {name: "Laferne",  gender: "F", age: 35, timeSeconds: 1572},</p>
			<p class="source-code">    {name: "Jerome",   gender: "M", age: 22, timeSeconds: 1384},</p>
			<p class="source-code">    {name: "Yipeng",   gender: "M", age: 29, timeSeconds: 1347},</p>
			<p class="source-code">    {name: "Jyothi",   gender: "F", age: 39, timeSeconds: 1462},</p>
			<p class="source-code">    {name: "Chetan",   gender: "M", age: 36, timeSeconds: 1597},</p>
			<p class="source-code">    {name: "Giuseppe", gender: "M", age: 38, timeSeconds: 1570},</p>
			<p class="source-code">    {name: "Oksana",   gender: "F", age: 23, timeSeconds: 1617}</p>
			<p class="source-code">];</p>
			<p>This is an array of objects that represents the results of runners in a 5 km race. The name, sex, age, and time are indicated for each runner in object fields. Time is recorded in seconds, allowing for easy minutes/seconds and pace calculations.</p>
			<p>We will also define three helper functions to display the data. They will use some concepts that you may not be familiar with yet, particularly, arrow function notation and the <strong class="source-inline">Array.prototype.map</strong> method. But don't worry – these concepts will be covered in upcoming sections and they will become clear soon.</p>
			<p>The purpose of our first helper function is to format seconds into <strong class="source-inline">MM:SS</strong>:</p>
			<p class="source-code">   const minsSecs = timeSeconds =&gt;</p>
			<p class="source-code">       Math.floor(timeSeconds / 60) + ":" +</p>
			<p class="source-code">       Math.round(timeSeconds % 60).toString().padStart(2, '0');</p>
			<p>Let's understand the code in detail:</p>
			<ul>
				<li>The <strong class="source-inline">minsSecs</strong> variable defines an arrow function with a <strong class="source-inline">timeSeconds</strong> input parameter.</li>
				<li>For the minutes portion, the <strong class="source-inline">Math.floor()</strong> method removes the decimal part of the minutes when dividing seconds by 60, resulting in just a whole number integer.</li>
				<li>For the seconds portion, the <strong class="source-inline">Math.round()</strong> method returns the number rounded to the nearest integer. (Note that we only wish to round fractional seconds. For the minute portion, it would not be correct to round.)</li>
				<li>The <strong class="source-inline">String.prototype.padStart</strong> method pads the seconds value with a leading <strong class="source-inline">0</strong> if the value is less than 10. The seconds themselves are calculated using the remainder operator, <strong class="source-inline">%</strong>, which returns any remainder value in the division.</li>
			</ul>
			<p>Our second helper function creates a string that prints the fields of the <strong class="source-inline">runner</strong> object in custom formats:</p>
			<p class="source-code">        const printRunner = runner =&gt;</p>
			<p class="source-code">            [`Name: ${runner.name}`,</p>
			<p class="source-code">             `gender: ${runner.gender}`,</p>
			<p class="source-code">             `age: ${runner.age}`,</p>
			<p class="source-code">             `time: ${minsSecs(runner.timeSeconds)}`</p>
			<p class="source-code">            ].join('\t');</p>
			<p>Let's understand the code in detail:</p>
			<ul>
				<li>Once again, arrow function syntax is used. The function is named <strong class="source-inline">printRunner</strong> and has a <strong class="source-inline">runner</strong> input parameter.</li>
				<li>An array of formatted strings is created, one for each field in the <strong class="source-inline">runner</strong> object.</li>
				<li>Lastly, all the string elements are joined together with a tab character separator by calling <strong class="source-inline">Array.prototype.join('\t')</strong>, resulting in nice columns when printed.</li>
			</ul>
			<p>The final helper function prints all the runners:</p>
			<p class="source-code">        const printRunners = (runners, listType) =&gt;</p>
			<p class="source-code">            `List of ${listType} (total ${runners.length}):\n` +</p>
			<p class="source-code">                runners.map(printRunner).join('\n');</p>
			<p>Let's go through the different parts of the above code in detail:</p>
			<ul>
				<li>The function is called <strong class="source-inline">printRunners</strong> and takes two parameters: an array of <strong class="source-inline">runners</strong>, and <strong class="source-inline">listType</strong>, which is a description of what type of list is being printed. It returns a string.</li>
				<li><strong class="source-inline">Array.prototype.map</strong> is used to form the runner details for printing.</li>
				<li>In short, the <strong class="source-inline">Array.prototype.map</strong> method iterates over every array element executes a callback function on them and results in a new array with the transformed values of each element. We'll explain how this works in detail later.</li>
				<li>But for now, the <strong class="source-inline">Array.prototype.map</strong> call here calls the <strong class="source-inline">printRunner</strong> function specified previously on each array element to get the formatted strings. Since the <strong class="source-inline">printRunner</strong> function only takes one parameter, in this case, it is not necessary to explicitly specify the parameter, since it is implied.</li>
				<li>The strings are then joined together with a newline character by calling <strong class="source-inline">Array.prototype.join('\n')</strong>.</li>
			</ul>
			<p>To print all the runners to the console, invoke it like this:</p>
			<p class="source-code">    console.log(printRunners(runners, "all runners"));</p>
			<p>The output will look like this:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer336">
					<img alt="Figure 14.5: Sample output of all the runners in the console&#13;&#10;" src="image/C14377_14_05.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.5: Sample output of all the runners in the console</p>
			<h1 id="_idParaDest-529"><a id="_idTextAnchor587"/>Higher-Order Functions</h1>
			<p>Functions in JavaScript are first-class citizens. This means they can be passed as parameter values to other functions, or even assigned to a variable. This is one of the main characteristics that make JavaScript well-suited to the functional style of programming.</p>
			<p>Higher-order functions are functions that operate on other functions. They can do this in one of three ways:</p>
			<ul>
				<li>If the function takes another function as an argument</li>
				<li>If the function returns another function as its result</li>
				<li>In both of these ways</li>
			</ul>
			<p>In the previous chapters, we've already seen several higher-order functions, perhaps without you even realizing it. Remember the callback functions that get executed in response to DOM events, or the callbacks in <em class="italic">Chapter 10, Accessing External Resources</em>, which were called once the AJAX response was ready? These are all examples of higher-order functions since these functions are parameters that are passed into other functions.</p>
			<p>The following sections will introduce three higher-order functions that are commonly used in functional programming: <strong class="source-inline">Array.prototype.filter</strong>, <strong class="source-inline">Array.prototype.map</strong>, and <strong class="source-inline">Array.prototype.reduce</strong>.</p>
			<h2 id="_idParaDest-530"><a id="_idTextAnchor588"/>The Array.prototype.filter Method</h2>
			<p>The first function we will look at is the <strong class="source-inline">Array.prototype.filter</strong> method, which is simple. Given an existing array, <strong class="source-inline">filter()</strong> creates a new array with elements that fall under the specified criteria.</p>
			<p>The syntax is as follows:</p>
			<p class="source-code">var newArray = array.filter(function(item) {</p>
			<p class="source-code">  return condition;</p>
			<p class="source-code">});</p>
			<p>The callback function is called for each element of the array in turn. If the condition passes and the function returns <strong class="source-inline">true</strong>, the element is added to the new array. If the function returns <strong class="source-inline">false</strong>, the element is skipped and will not be added.</p>
			<p>Note that the return value is a new array. The original array is not impacted at all by this operation. In other words, it is not the case that items are filtered out and removed from the original array if they don't pass the condition. Rather, a new array is created with the elements that pass the test.</p>
			<p>The reason for creating a new array rather than modifying the existing one is due to the fundamental principles of functional programming you learned about earlier: immutability and avoiding side effects.</p>
			<p>We will look at some examples of how <strong class="source-inline">Array.prototype.filter</strong> is used in the following section.</p>
			<h2 id="_idParaDest-531"><a id="_idTextAnchor589"/>A Refresher</h2>
			<p>Before we look at these examples, though, it is prudent for us to take a step back and review basic JavaScript function syntax and arrow function notation. This will ensure that you have a good grounding for what's to come. We will do this review by showing you different ways that the filtering function can be specified for <strong class="source-inline">Array.prototype.filter</strong>.</p>
			<p>Say we wanted to filter the array of runners (presented earlier in this chapter) for only female runners. The most straightforward filtering function looks like this:</p>
			<p class="source-code">function femaleFilter(runner) {</p>
			<p class="source-code">    if (runner.gender === "F") {</p>
			<p class="source-code">        return true;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    return false;</p>
			<p class="source-code">}</p>
			<p>This filtering function would be called from another function that actually invokes <strong class="source-inline">filter()</strong> with the following code:</p>
			<p class="source-code">const getFemaleRunners = runners =&gt; runners.filter(femaleFilter);</p>
			<p>To make the function self-contained, it takes the <strong class="source-inline">runners</strong> array as a parameter. It is not good practice to require <strong class="source-inline">runners</strong> to be a global variable.</p>
			<p>Note that we only pass in the name of the filtering function, <strong class="source-inline">femaleFilter</strong>, as the argument, and not with parentheses, like <strong class="source-inline">femaleFilter()</strong>. We do not want the function to be executed right away, which is what would happen if there were parentheses. Rather, when a function is passed by name without parentheses, you are passing the function object itself. The <strong class="source-inline">filter</strong> method is a higher-order function that takes a callback function as its input, which requires the actual function object.</p>
			<p>The results of this filtering can be displayed with the following code:</p>
			<p class="source-code">console.log(</p>
			<p class="source-code">    printRunners(getFemaleRunners(runners), "female runners"));</p>
			<p class="source-code">// output:</p>
			<p class="source-code">// → List of female runners (total 6):</p>
			<p class="source-code">// → Name: Courtney  gender: F     age: 21   time: 25:05</p>
			<p class="source-code">// → Name: Halina    gender: F     age: 33   time: 26:16</p>
			<p class="source-code">// → Name: Nilani    gender: F     age: 27   time: 26:41</p>
			<p class="source-code">// → Name: Laferne   gender: F     age: 35   time: 26:12</p>
			<p class="source-code">// → Name: Jyothi    gender: F     age: 38   time: 24:22</p>
			<p class="source-code">// → Name: Oksana    gender: F     age: 23   time: 26:57</p>
			<p class="callout-heading">Note</p>
			<p class="callout">This code should be used to display the results of the following examples as well. The same results are expected for each example.</p>
			<p>We've done pretty well so far, but we could do better. As an alternative, the filtering function could be specified directly inline:</p>
			<p class="source-code">const getFemaleRunners = runners =&gt; runners.filter(</p>
			<p class="source-code">    function(runner) {</p>
			<p class="source-code">        if (runner.gender === "F") {</p>
			<p class="source-code">            return true;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        return false;</p>
			<p class="source-code">    }</p>
			<p class="source-code">);</p>
			<p>We can simplify this a bit more if we change the filtering test to a Boolean expression rather than explicitly returning <strong class="source-inline">true</strong> or <strong class="source-inline">false</strong> in an <strong class="source-inline">if</strong> statement:</p>
			<p class="source-code">const getFemaleRunners = runners =&gt; runners.filter(</p>
			<p class="source-code">    function(runner) {</p>
			<p class="source-code">        return runner.gender === "F";</p>
			<p class="source-code">    }</p>
			<p class="source-code">);</p>
			<p>In newer versions of JavaScript, since ES6, this function can also be expressed more concisely using an arrow function expression:</p>
			<p class="source-code">const getFemaleRunners = runners =&gt; runners.filter(runner =&gt; {</p>
			<p class="source-code">    return runner.gender === "F";</p>
			<p class="source-code">});</p>
			<p>Finally, note that this function has only one argument and a single <strong class="source-inline">return</strong> statement in its body. This allows us to make the code even more concise with the following one-liner, which omits the open/close brackets and the <strong class="source-inline">return</strong> keyword:</p>
			<p class="source-code">const getFemaleRunners = runners =&gt;</p>
			<p class="source-code">    runners.filter(runner =&gt; runner.gender === "F");</p>
			<p>If desired, the filtering function can also be split into its own function and stored in a variable, since functions are first-class objects in JavaScript:</p>
			<p class="source-code">const femaleFilter = runner =&gt; runner.gender === "F";</p>
			<p class="source-code">const getFemaleRunners = runners =&gt; runners.filter(femaleFilter);</p>
			<h2 id="_idParaDest-532"><a id="_idTextAnchor590"/>Eliminating for Loops</h2>
			<p>The <strong class="source-inline">Array.prototype.filter</strong> function is a great demonstration of powerful functional programming techniques that are used to eliminate looping code, particularly the <strong class="source-inline">for</strong> loop. To get a feel of the potential pitfalls of the traditional <strong class="source-inline">for</strong> loop, consider the equivalent imperative code to filter female runners:</p>
			<p class="source-code">var femaleRunners = [];</p>
			<p class="source-code">for (var i = 0; i &lt; runners.length; i++) {</p>
			<p class="source-code">    if (runners[i].gender == "F") {</p>
			<p class="source-code">        femaleRunners.push(runners[i]);</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>Compare this to the one-liner we saw in the previous section, which does the same thing:</p>
			<p class="source-code">const femaleRunners = runners.filter(runner =&gt; runner.gender === "F");</p>
			<p>The imperative looping code requires the use of the looping variable, <strong class="source-inline">i</strong>. This introduces mutation of the state into our code and is a potential source of bugs. Even though, in this case, it is a local state, it is best to avoid the state in all situations when possible. At some point in the future, there is a risk that a variable will change for an unknown reason, producing an issue that's difficult to debug.</p>
			<p>With the functional equivalent, it is easier to see at a glance what the code does, is easier to test, and has more opportunity for potential reuse. It has no indentation, no loops, and the code is more concise and expressive.</p>
			<p>This also demonstrates how functional code is most often declarative rather than imperative. It specifies "what to do" (declarative) rather than the steps and flow of "how to do it" (imperative). In this example, the functional code simply says, "filter the array elements passed in the <strong class="source-inline">runners</strong> parameter where gender is female". Compare this to imperative code that requires multiple variables, statements, loops, and so on, which describes "how" rather than "what."</p>
			<p>In the upcoming sections, we will look at other array methods that eliminate loops as well, such as <strong class="source-inline">Array.prototype.map</strong> and <strong class="source-inline">Array.prototype.reduce</strong>.</p>
			<h2 id="_idParaDest-533"><a id="_idTextAnchor591"/>The Array.prototype.map Method</h2>
			<p>The array <strong class="source-inline">map()</strong> method is used when you want to transform array elements. It applies a function to every element of the calling array and builds a new array consisting of the returned values. The new array will have the same length as the input array, but each element's contents will be transformed (mapped) into something else.</p>
			<p>Say you wanted to calculate the average pace per mile of each runner of the 5 km race. Our dataset provides a <strong class="source-inline">timeSeconds</strong> field, which is the total amount of time in seconds the runner needs to complete the full distance. There are also 3.1 miles in 5 kilometers. Therefore, to get the pace per mile, you would divide the number of seconds by 3.1.</p>
			<p>We can calculate the pace for all runners with the following code:</p>
			<p class="source-code">const getPaces = runners =&gt; runners.map(runner =&gt; runner.timeSeconds / 3.1);</p>
			<p class="source-code">const paces = getPaces(runners);</p>
			<p>This code results in a new array with elements that have the <strong class="source-inline">pace</strong> value of the corresponding runner at the same index of the input array. In other words, the value of <strong class="source-inline">paces[0]</strong> corresponds to the runner in <strong class="source-inline">runner[0]</strong>, the value of <strong class="source-inline">paces[1]</strong> corresponds to the runner in <strong class="source-inline">runner[1]</strong>, and so on.</p>
			<p>The pace results can be printed to the console as follows:</p>
			<p class="source-code">paces.forEach(pace =&gt; console.log(minsSecs(pace)));</p>
			<p class="source-code">// output:</p>
			<p class="source-code">// → 8:05</p>
			<p class="source-code">// → 7:22</p>
			<p class="source-code">// → 8:16</p>
			<p class="source-code">// → 8:27</p>
			<p class="source-code">// ...</p>
			<h2 id="_idParaDest-534"><a id="_idTextAnchor592"/>Exercise 14.05: Another Way of Using Array.prototype.map</h2>
			<p>The results from the previous section in regards to mapping to an array of single-valued elements are useful as-is for some contexts, such as if you intend to subsequently calculate the sum or average of the values. This is okay when you just require the raw numbers and context isn't important. But what if you need more values or context for each element, such as the name of the runner that achieved the pace? This exercise shows another way we can use <strong class="source-inline">Array.prototype.map</strong> to achieve different results using the original dataset; for example, to get the calculated pace of each runner.</p>
			<ol>
				<li value="1">In the Google Chrome browser, go to <strong class="source-inline">Developer Tools</strong> (go to the menu with the three dots at the upper-right of the screen | <strong class="source-inline">More Tools</strong> | <strong class="source-inline">Developer Tools</strong>, or just hit the <em class="italic">F12</em> key):<div class="IMG---Figure" id="_idContainer337"><img alt="Figure 14.6: Developer Tools in the Google Chrome browser&#13;&#10;" src="image/C14377_14_06.jpg"/></div><p class="figure-caption">Figure 14.6: Developer Tools in the Google Chrome browser</p></li>
				<li>In the console, paste in the sample runner data (beginning with <strong class="source-inline">const runners = [...]</strong>) from the <em class="italic">Sample Data for Examples</em> section of this chapter:<p class="source-code">const runners = [</p><p class="source-code">    {name: "Courtney", gender: "F", age: 21, timeSeconds: 1505},</p><p class="source-code">    {name: "Lelisa",   gender: "M", age: 24, timeSeconds: 1370},</p><p class="source-code">    {name: "Anthony",  gender: "M", age: 32, timeSeconds: 1538},</p><p class="source-code">    {name: "Halina",   gender: "F", age: 33, timeSeconds: 1576},</p><p class="source-code">    {name: "Nilani ",  gender: "F", age: 27, timeSeconds: 1601},</p><p class="source-code">    {name: "Laferne",  gender: "F", age: 35, timeSeconds: 1572},</p><p class="source-code">    {name: "Jerome",   gender: "M", age: 22, timeSeconds: 1384},</p><p class="source-code">    {name: "Yipeng",   gender: "M", age: 29, timeSeconds: 1347},</p><p class="source-code">    {name: "Jyothi",   gender: "F", age: 39, timeSeconds: 1462},</p><p class="source-code">    {name: "Chetan",   gender: "M", age: 36, timeSeconds: 1597},</p><p class="source-code">    {name: "Giuseppe", gender: "M", age: 38, timeSeconds: 1570},</p><p class="source-code">    {name: "Oksana",   gender: "F", age: 23, timeSeconds: 1617}</p><p class="source-code">];</p></li>
				<li>In the console, paste in the code for the <strong class="source-inline">minsSecs()</strong> helper function, also from the <em class="italic">Sample Data for Examples</em> section of this chapter:<p class="source-code">const minsSecs = timeSeconds =&gt;</p><p class="source-code">            Math.floor(timeSeconds / 60) + ":" + </p><p class="source-code">            Math.round(timeSeconds % 60).toString().padStart(2, '0');</p></li>
				<li>Type the following code into the console:<p class="source-code">const getPacesWithNames = runners =&gt; runners.map(runner =&gt;</p><p class="source-code">    ({name: runner.name, pace: runner.timeSeconds / 3.1}));</p><p class="source-code">const pacesWithNames = getPacesWithNames(runners);</p><p>This code shows a simple way of adding context to the array elements: rather than returning just a single value from the mapping function, an object with multiple fields can be returned instead that includes as many fields as desired. In this case, the object has the <strong class="source-inline">name</strong> and <strong class="source-inline">pace</strong> fields for each array element. </p></li>
				<li>We can see the output by using the following code:<p class="source-code">// print each value</p><p class="source-code">pacesWithNames.forEach(paceObj =&gt;</p><p class="source-code">    console.log(`name: ${paceObj.name}\tpace: ${minsSecs(paceObj.pace)}`));</p><p>After running the preceding commands, your console log should look like the one shown in the following screenshot. Notice the list of names and paces at the bottom:</p><div class="IMG---Figure" id="_idContainer338"><img alt="Figure 14.7: Output of the name and pace fields&#13;&#10;" src="image/C14377_14_07.jpg"/></div><p class="figure-caption">Figure 14.7: Output of the name and pace fields</p><p>You'll notice that we have all the same runners from the original data but without gender, age, or times in seconds. We've also added a new value called <strong class="source-inline">pace</strong>, which we created with the <strong class="source-inline">getPacesWithNames</strong> function.What if you want your array to contain elements with all the original fields and append an additional <strong class="source-inline">pace</strong> field? </p></li>
				<li>We could use the spread operator you learned about earlier. Type the following into the console:<p class="source-code">const addPacesToRunners = runners =&gt; runners.map(runner =&gt;</p><p class="source-code">    ({...runner, pace: runner.timeSeconds / 3.1}));</p></li>
				<li>The <strong class="source-inline">...runner</strong> spread syntax effectively clones all the key-value pairs in the object, adds them to the new mapped value, and displays the output. Add and run the <strong class="source-inline">addPacesToRunners</strong> function to your console. <p class="callout-heading">Note</p><p class="callout">Copies will be made of the fields. As before, we do not want to just modify the original object so that we can add the new field either, as this has the potential for side effects.</p></li>
				<li>The following code runs the function and displays the results in the console:<p class="source-code">const pacesWithAllFields = addPacesToRunners(runners);</p><p class="source-code">pacesWithAllFields.forEach(paceObj =&gt; console.log(paceObj));</p></li>
			</ol>
			<p>Once you run the <strong class="source-inline">forEach()</strong> function to iterate over the elements of the <strong class="source-inline">pacesWithAllFields</strong>, you should get a list of runners with all the original data, but in addition, there will be a new field for the average pace:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer339">
					<img alt="Figure 14.8: Results of addPacesToRunners with the pace field appended&#13;&#10;" src="image/C14377_14_08.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.8: Results of addPacesToRunners with the pace field appended</p>
			<p class="callout-heading">Note</p>
			<p class="callout">Do not use the spread technique if you expect your code to run in older browsers. Use alternatives such as <strong class="source-inline">Object.assign()</strong> to clone your fields. Here's how <strong class="source-inline">addPacesToRunners</strong> could be coded for older environments:</p>
			<p class="callout"><strong class="source-inline">const addPacesToRunners = runners =&gt; runners.map(runner =&gt;</strong></p>
			<p class="callout"><strong class="source-inline">    Object.assign({}, runner, {pace: runner.timeSeconds / 3.1}));</strong></p>
			<p class="callout">Alternatively, transpilers such as Babel support the spread syntax, even in older browsers.</p>
			<p>In this exercise, we looked at using the <strong class="source-inline">Array.prototype.map</strong> method and how we can use functional programming design patterns to combine functions to create complex results. We used <strong class="source-inline">addPacesToRunners</strong> in combination with <strong class="source-inline">minsSecs</strong> and <strong class="source-inline">pacesWithNames</strong> to print the pace of each runner in addition to the data from the original set. Importantly, we added the additional data value of pace without modifying the original dataset. Using the techniques in this exercise thus allows you to retain context when mapping values.</p>
			<p>In the next section, we will learn about another array method, <strong class="source-inline">reduce</strong>, which allows us to take a set of values from an array and compute them into a single value.</p>
			<h2 id="_idParaDest-535"><a id="_idTextAnchor593"/>The Array.prototype.reduce method</h2>
			<p>Similar to <strong class="source-inline">map()</strong>, the array <strong class="source-inline">reduce()</strong> method operates on every element of an array. It is used when you need to compute a single value from them.</p>
			<p>A simple example of this is if you need the sum of a collection of numbers:</p>
			<p class="source-code">const sum = [2, 4, 6, 8, 10].reduce((total, current) =&gt; total + current, 0);</p>
			<p class="source-code">console.log(sum);</p>
			<p>The output of the preceding function will be as follows:</p>
			<p class="source-code">// output:</p>
			<p class="source-code">// → 10</p>
			<p>Here, the <strong class="source-inline">reduce()</strong> method takes two parameters: a combining function and a start value (0, in this case). It causes the combining function to be called repeatedly with each array element in turn, as it does in a <strong class="source-inline">for</strong> loop. For each invocation, the present element is passed as the <strong class="source-inline">current</strong> value, along with the <strong class="source-inline">total</strong> value so far (sometimes referred to as the accumulator).</p>
			<p>The first time the combining function is invoked, <strong class="source-inline">total</strong> is the start value (<strong class="source-inline">0</strong>) and <strong class="source-inline">current</strong> is the first number in the array (<strong class="source-inline">2</strong>). The addition, that is, <strong class="source-inline">total</strong> <strong class="source-inline">+</strong> <strong class="source-inline">current</strong>, results in the value of <strong class="source-inline">2</strong>.</p>
			<p>The second time the combining function is invoked, <strong class="source-inline">total</strong> is the result of the previous invocation (<strong class="source-inline">2</strong>) and <strong class="source-inline">current</strong> is the second number in the array (<strong class="source-inline">4</strong>). The addition, that is, <strong class="source-inline">total</strong> <strong class="source-inline">+</strong> <strong class="source-inline">current</strong>, results in <strong class="source-inline">6</strong>.</p>
			<p>This process is repeated for the remaining elements in the array until there are no elements remaining to process. Here is a simple table that shows the values at each invocation:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer340">
					<img alt="Figure 14.9: Invocation value and their result&#13;&#10;" src="image/C14377_14_09.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.9: Invocation value and their result</p>
			<p>Here is another visualization of this reduction process that may help you see it more clearly:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer341">
					<img alt="Figure 14.10: A depiction of the reduction process&#13;&#10;" src="image/C14377_14_10.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.10: A depiction of the reduction process</p>
			<p>Going back to using our <strong class="source-inline">runners</strong> dataset, here's how you can use <strong class="source-inline">reduce()</strong> to compute the average pace of all runners. But first, recall the code from the previous section that used <strong class="source-inline">map()</strong> to calculate the pace for each runner and returned the results in a new array:</p>
			<p class="source-code">const getPaces = runners =&gt; runners.map(runner =&gt; runner.timeSeconds / 3.1);</p>
			<p class="source-code">const paces = getPaces(runners);</p>
			<p>We can use these paces to calculate the average with <strong class="source-inline">reduce()</strong>:</p>
			<p class="source-code">const getAvgPace = paces =&gt; paces.reduce(</p>
			<p class="source-code">    (total, currentPace) =&gt; total + currentPace, 0) / paces.length;</p>
			<p class="source-code">console.log(minsSecs(getAvgPace(paces)));</p>
			<p>The output of the <strong class="source-inline">reduce()</strong> function will be as follows:</p>
			<p class="source-code">// output:</p>
			<p class="source-code">// → 8:08</p>
			<p>First, in <strong class="source-inline">reduce()</strong>, we calculate the sum of all <strong class="source-inline">pace</strong> values using a similar technique as when we summed up the array of numbers. But there's one additional step. Rather than returning the sum, we divide it by the length of the array before returning the result.</p>
			<h2 id="_idParaDest-536"><a id="_idTextAnchor594"/>Exercise 14.06: Grouping with Array.prototype.reduce</h2>
			<p>What if you wanted to calculate the average pace of all runners grouped by gender? We can do this with <strong class="source-inline">reduce()</strong>, but it is a bit more involved than the previous example. In this exercise, we'll implement one approach to grouping.</p>
			<p>Unlike when we calculated the average of straight numbers, for group averages, we'll need to do this in two steps: first, gather the sum and count of each gender, and then calculate the averages in a second step.</p>
			<p>The following outlines the approach for the summing and counting step:</p>
			<ul>
				<li>Use an empty object (<strong class="source-inline">{}</strong>) as our starting value.</li>
				<li>When cycling through the array elements, get the group <strong class="source-inline">sum</strong> and <strong class="source-inline">count</strong> stats calculated so far for the gender of the current element. (If there are no stats for gender yet, create an empty group with <strong class="source-inline">sum</strong> and <strong class="source-inline">count</strong> set to <strong class="source-inline">0</strong>.)</li>
				<li>Add the pace of the current element to the group sum.</li>
				<li>Increase the count of the group by <strong class="source-inline">1</strong>.</li>
			</ul>
			<p>Here are the steps to do this:</p>
			<ol>
				<li value="1">In the Google Chrome browser, go to Developer Tools (go to the menu with the three dots at the upper-right of the screen | <strong class="source-inline">More Tools</strong> | <strong class="source-inline">Developer Tools</strong>, or just hit the <em class="italic">F12</em> key).</li>
				<li>In the console, paste in the sample runner data (beginning with <strong class="source-inline">const runners = [...]</strong>) from the <em class="italic">Sample Data for Examples</em> section of this chapter.</li>
				<li>In the console, paste in the code for the <strong class="source-inline">minsSecs()</strong> helper function, which is also from the <em class="italic">Sample Data for Examples</em> section of this chapter.</li>
				<li>We will make use of the <strong class="source-inline">pacesWithAllFields</strong> value from the example in the <em class="italic">Array.prototype.map()</em> section, which creates a new array with a calculated <strong class="source-inline">pace</strong> field added to each element. Type the following into the console:<p class="source-code">const addPacesToRunners = runners =&gt; runners.map(runner =&gt;</p><p class="source-code">    ({...runner, pace: runner.timeSeconds / 3.1}));</p><p class="source-code">const pacesWithAllFields = addPacesToRunners(runners);</p></li>
				<li>The following is the code for this first summing and counting step, which we outlined previously:<p class="source-code">const groupSumPaceByGender = runners =&gt; runners.reduce((groups, runner) =&gt; {</p><p class="source-code">    const gender = runner.gender;</p><p class="source-code">    groups[gender] = groups[gender] || {pace: 0, count: 0};</p><p class="source-code">    groups[gender].pace += runner.pace;</p><p class="source-code">    groups[gender].count += 1;</p><p class="source-code">    return groups;</p><p class="source-code">}, {});</p><p class="source-code">const sumPacesByGender = groupSumPaceByGender(pacesWithAllFields);</p></li>
				<li>At this point, the object that results from <strong class="source-inline">sumPacesByGender</strong> will have two keys that represent the gender values, that is, "<strong class="source-inline">M</strong>" and "<strong class="source-inline">F</strong>". The value for each is also an object, in which there are <strong class="source-inline">pace</strong> and <strong class="source-inline">count</strong> fields that contain the calculated stats for gender corresponding to the key.</li>
				<li>Displaying such objects in the JavaScript console is a bit clunky and unwieldy. A trick is in order: we'll convert the object into formatted JSON text and display that instead. Type the following code into the console:<p class="source-code">console.log(JSON.stringify(sumPacesByGender,null,4));</p><p>This will output the JSON with a 4-space indentation:</p><p class="source-code">// output:</p><p class="source-code">// → { </p><p class="source-code">// →     "F": { </p><p class="source-code">// →         "pace": 3010.645161290322, </p><p class="source-code">// →         "count": 6 </p><p class="source-code">// →     },</p><p class="source-code">// →     "M": { </p><p class="source-code">// →         "pace": 2840.6451612903224, </p><p class="source-code">// →         "count": 6 </p><p class="source-code">// →     }</p><p class="source-code">// → }</p></li>
				<li>Now that we have the sums and counts for each group determined, we can proceed to the second step and calculate the average of each group. We can do this by using <strong class="source-inline">Object.keys()</strong> to get an array with the keys of the object (that have the values "<strong class="source-inline">M</strong>" and "<strong class="source-inline">F</strong>") and then call <strong class="source-inline">Array.prototype.map()</strong> with a function to calculate the average for each gender. Type the following into the console:<p class="source-code">const calcAvgPaceByGender = sumPacesByGender =&gt;</p><p class="source-code">    Object.keys(sumPacesByGender).map(gender =&gt; {</p><p class="source-code">        const group = sumPacesByGender[gender];</p><p class="source-code">        return {gender: gender, avgPace: group.pace / group.count};</p><p class="source-code">    }</p><p class="source-code">);</p><p class="source-code">const avgPaceByGender = calcAvgPaceByGender(sumPacesByGender);</p></li>
				<li>Let's write the code to display the output:<p class="source-code">console.log("Average pace by gender:");</p><p class="source-code">avgPaceByGender.forEach(entry =&gt; console.log(</p><p class="source-code">    `gender: ${entry.gender}  average pace: ${minsSecs(entry.avgPace)}`));</p></li>
				<li>The output should be displayed as follows:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer342">
					<img alt="Figure 14.11: Grouping the result of gender pace with Array.prototype.reduce&#13;&#10;" src="image/C14377_14_11.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.11: Grouping the result of gender pace with Array.prototype.reduce</p>
			<p>This output allowed us to take a large number of data points and "reduce" them to a smaller amount of results in an efficient manner.</p>
			<p>In this exercise, we looked at using the <strong class="source-inline">Array.prototype.reduce</strong> method for grouping. As in the previous exercise, we combined several functions to create a more complex result, without modifying the original dataset. First, we added the <strong class="source-inline">pace</strong> value for each entry in the set using <strong class="source-inline">addPacesToRunners</strong>, then we created a group sum for each gender with <strong class="source-inline">groupSumPaceByGender</strong>, and finally, we used <strong class="source-inline">calcAvgPaceByGender</strong> to get a value for the average pace for both males and females in the race.</p>
			<p>In the next section, we'll talk about the concept of composition. We've used composition several times already in this chapter, that is, each time we combined smaller functions to create a larger process. However, we haven't looked at the concept specifically and spoken of its importance in the functional paradigm. We'll also look at the <strong class="source-inline">pipe()</strong> and <strong class="source-inline">compose()</strong> functions, which make combining functions in this way easier and more readable.</p>
			<h2 id="_idParaDest-537"><a id="_idTextAnchor595"/>Composition with compose() and pipe()</h2>
			<p>In the previous exercise, we saw that starting from the runners array, we required three different functions to calculate the average pace for each gender:</p>
			<ul>
				<li><strong class="source-inline">addPacesToRunners</strong>: This is used to calculate the pace per mile.</li>
				<li><strong class="source-inline">groupSumPaceByGender</strong>: This is used to sum the pace of each gender.</li>
				<li><strong class="source-inline">calcAvgPaceByGender</strong>: This is used to calculate the average pace for each gender.</li>
			</ul>
			<p>Each function required the result of the one before it as input in order to do its job. Basically, it did the following, though it may not have been apparent up to this point:</p>
			<p class="source-code">const result1 = addPacesToRunners(runners);</p>
			<p class="source-code">const result2 = groupSumPaceByGender(result1);</p>
			<p class="source-code">const avg = calcAvgPaceByGender(result2);</p>
			<p>This is equivalent to the following, that is, using nested functions and removing the intermediate variables:</p>
			<p class="source-code">const avg =</p>
			<p class="source-code">    calcAvgPaceByGender(groupSumPaceByGender(addPacesToRunners(runners)));</p>
			<p>This is the idea of composition: that multiple simple functions are combined to build a more complex function.  The result of each function is passed along to the next one.</p>
			<p>We can create high-order functions called <strong class="source-inline">compose</strong> and <strong class="source-inline">pipe</strong> to achieve function composition in a more general manner, though. Putting aside the actual implementation for a moment, let's see how the functions would be used. With <strong class="source-inline">compose</strong>, the preceding nested functions would be written as follows:</p>
			<p class="source-code">const avgWithComposition =</p>
			<p class="source-code">    compose(calcAvgPaceByGender, groupSumPaceByGender, addPacesToRunners);</p>
			<p>This function would be used as follows:</p>
			<p class="source-code">const avgResult = avgWithComposition(runners);</p>
			<p class="source-code">avgResult.forEach(entry =&gt; console.log(</p>
			<p class="source-code">    `gender: ${entry.gender}  average pace: ${minsSecs(entry.avgPace)}`));</p>
			<p>The output of the function would be as follows:</p>
			<p class="source-code">// output:</p>
			<p class="source-code">// → gender: F average pace: 8:22</p>
			<p class="source-code">// → gender: M average pace: 7:53</p>
			<p>Note that, perhaps counter-intuitively, the functions in <strong class="source-inline">compose</strong> are actually called in reverse order from how they are given in the parameter list, that is, right to left. So, the <strong class="source-inline">addPacesToRunners</strong> method is first invoked with the <strong class="source-inline">runners</strong> argument (even though it is the last function in the given list), then the results are passed to <strong class="source-inline">groupSumPaceByGender</strong>, and finally, those results are passed to <strong class="source-inline">calcAvgPaceByGender</strong>.</p>
			<p>Many people find this function call order unnatural, though it is consistent with the order we called our nested functions above. The <strong class="source-inline">pipe</strong> function is similar to <strong class="source-inline">compose</strong>, but functions are composed in the opposite direction, left-to-right rather than the right-to-left. The <strong class="source-inline">pipe</strong> approach is more consistent with linear thinking: first, do A, then B, then C, and the functions to do A, B and C would be given in that order.</p>
			<p>With <strong class="source-inline">pipe</strong>, the equivalent code would be:</p>
			<p class="source-code">const avgWithPipe = </p>
			<p class="source-code">    pipe(addPacesToRunners, groupSumPaceByGender, calcAvgPaceByGender);</p>
			<p class="source-code">const resultPipe = avgWithPipe(runners);</p>
			<p class="source-code">resultPipe.forEach(entry =&gt; console.log(</p>
			<p class="source-code">    `gender: ${entry.gender}  average pace: ${minsSecs(entry.avgPace)}`));</p>
			<p class="source-code">// output:</p>
			<p class="source-code">// → gender: F average pace: 8:22</p>
			<p class="source-code">// → gender: M average pace: 7:53</p>
			<h2 id="_idParaDest-538"><a id="_idTextAnchor596"/>Implementation of compose() and pipe()</h2>
			<p>Now, let's look at one way we could actually implement these functions. The implementations are similar, but we'll start with <strong class="source-inline">pipe</strong> first as it is a bit easier to understand.</p>
			<p>It turns out to be a pretty straightforward implementation when using <strong class="source-inline">Array.prototype.reduce</strong>:</p>
			<p class="source-code">function pipe(...fns) {</p>
			<p class="source-code">    return input =&gt; fns.reduce((prev, fn) =&gt; fn(prev), input);</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">pipe</strong> function takes one or more functions passed in as parameters, which are converted into an array of functions with the spread operator, that is, <strong class="source-inline">...fns</strong>. Then, we apply <strong class="source-inline">reduce</strong> to the function array, starting by invoking the first function, <strong class="source-inline">fn</strong>, with the <strong class="source-inline">input</strong> argument passed in as <strong class="source-inline">prev</strong>. On the next invocation, the result of the first function is passed (as <strong class="source-inline">prev</strong>) and used as the parameter when calling the next function in the array. The rest of the functions in the array are processed in a similar fashion, with the result value of the final function returned.</p>
			<p>Note that this function can be simplified a bit by using <strong class="source-inline">full fat-arrow</strong> notation:</p>
			<p class="source-code">const pipe = (...fns) =&gt; input =&gt; fns.reduce((prev, fn) =&gt; fn(prev), input);</p>
			<p>As far as <strong class="source-inline">compose</strong> is concerned, recall that it is almost the same as <strong class="source-inline">pipe</strong> except that the order of functions is processed from right to left rather than left to right. Consequently, the implementation of <strong class="source-inline">compose</strong> is also basically the same, but rather than using <strong class="source-inline">Array.prototype.reduce</strong>, the sister function, <strong class="source-inline">Array.prototype.reduceRight</strong>, is utilized instead. The <strong class="source-inline">reduceRight</strong> function processes the array in reverse order from <strong class="source-inline">reduce</strong> and operates on the last element of the array first, then operates on the second to last element, and so on.</p>
			<p>Here's the implementation of <strong class="source-inline">compose</strong>:</p>
			<p class="source-code">const compose = (...fns) =&gt; input =&gt;</p>
			<p class="source-code">    fns.reduceRight((prev, fn) =&gt; fn(prev), input);</p>
			<h1 id="_idParaDest-539"><a id="_idTextAnchor597"/>Currying Functions</h1>
			<p>Currying is taking a function with multiple arguments and breaking it down into one or more additional functions that take just one argument and eventually resolve to a value. The initial function call does not take all the arguments but returns a function whose input is the remaining arguments and whose output is the intended result for all the arguments.</p>
			<p>That was a mouthful, so let's look at an example. Say you have a simple <strong class="source-inline">sum</strong> function:</p>
			<p class="source-code">function sum(a, b) {</p>
			<p class="source-code">    return a + b;</p>
			<p class="source-code">}</p>
			<p>Let's express this as a curried function in arrow notation:</p>
			<p class="source-code">const sum = a =&gt; b =&gt; a + b;</p>
			<p>Notice that we have two levels of functions here, and each function takes one parameter. The first function takes one parameter, <strong class="source-inline">a</strong>, and returns another function, which takes the second parameter, <strong class="source-inline">b</strong>.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">If you are having trouble seeing the two function levels, here's an equivalent that may help:</p>
			<p class="callout">function sum(a) {</p>
			<p class="callout">    return function(b) {</p>
			<p class="callout">       return a + b;</p>
			<p class="callout">    };</p>
			<p class="callout">};</p>
			<p class="callout">You can also write it in arrow notation:</p>
			<p class="source-code">const sum = a =&gt; function(b) {</p>
			<p class="source-code">    return a + b;</p>
			<p class="source-code">};</p>
			<p>To invoke this curried <strong class="source-inline">sum</strong> function with multiple arguments, you would need to use the following rather awkward syntax:</p>
			<p class="source-code">let result = sum(3)(5);    // 8</p>
			<p>This indicates to first call <strong class="source-inline">sum</strong> with the parameter value <strong class="source-inline">3</strong>, then call the function that is returned with the parameter <strong class="source-inline">5</strong>.</p>
			<p>But most often, you wouldn't invoke curried functions this way, and here's where the real utility of currying will become apparent. Typically, the functions will be called one at a time, which allows us to create intermediate functions that "remember" the parameter that's passed to it.</p>
			<p>For example, we can create the following intermediate functions:</p>
			<p class="source-code">const incrementByOne = sum(1);</p>
			<p class="source-code">const addThree = sum(3);</p>
			<p class="source-code">let result1 = incrementByOne(3); // result1 = 4, equivalent to calling sum(1)(3)</p>
			<p class="source-code">let result2 = addThree(5);       // result2 = 8, equivalent to calling sum(3)(5)</p>
			<p>Both the intermediate functions remember their parameter: <strong class="source-inline">incrementByOne</strong> holds onto the parameter value of <strong class="source-inline">1</strong> (as in <strong class="source-inline">sum(1)</strong>) and <strong class="source-inline">addThree</strong> remembers <strong class="source-inline">3</strong>. These functions are also referred to as <strong class="bold">partially applied</strong> since the <strong class="source-inline">a</strong> parameter was applied to them, but the actual result is not known until the returned function is invoked with the <strong class="source-inline">b</strong> parameter. (Note that partial application is not quite the same as a curried function, though, as partial applications can hold on to multiple parameters, whereas curried functions always take only one argument.)</p>
			<p>These are essentially new functions that could be potentially reused multiple times. They are also good candidates for <strong class="source-inline">compose</strong> or <strong class="source-inline">pipe</strong>, as these functions have only one parameter.</p>
			<h2 id="_idParaDest-540"><a id="_idTextAnchor598"/>Exercise 14.07: More Uses for Composition and Curried Functions</h2>
			<p>In this exercise, you will further explore currying and composition. Most notably, you will see how you can create curried versions of common functions such as <strong class="source-inline">Array.prototype.map</strong> and <strong class="source-inline">Array.prototype.filter</strong> to compose other functions. In functional programming, common functions often need to be restructured so that they can be used as a building block for processing data in a chain of functions.</p>
			<p>The exercise will once again use the <strong class="source-inline">runners</strong> dataset. You will create a function to scan the data and return the age of the oldest female runner. The challenge is to do this using composition with <strong class="source-inline">compose</strong> or <strong class="source-inline">pipe</strong>, thereby feeding the results of one function into the next one in the pipeline.</p>
			<p>The basic outline of what we need to do is as follows:</p>
			<ul>
				<li>Create a function to filter the data just for female runners</li>
				<li>Create a function to map that data to just get the age of each runner</li>
				<li>Create a function that uses <strong class="source-inline">Math.max()</strong> to get the highest age value</li>
				<li>Compose the functions we've created so far and call them in sequence to get the final result</li>
			</ul>
			<p>The following steps show you how we do this in detail:</p>
			<ol>
				<li value="1">Open the Chrome menu at the top-right of your browser window, then select <strong class="source-inline">Tools</strong> | <strong class="source-inline">Developer Tools</strong>.</li>
				<li>Go to the console and paste in the sample runner data (beginning with <strong class="source-inline">const runners = [...]</strong>) from the <em class="italic">Sample Data for Examples</em> section of this chapter.</li>
				<li>First, create a curried version of <strong class="source-inline">Array.prototype.filter</strong>. Type the following into the console:<p class="source-code">const filter = fx =&gt; arr =&gt; arr.filter(fx);</p></li>
				<li>Here, <strong class="source-inline">fx</strong> is the filtering function and <strong class="source-inline">arr</strong> is the array that is to be filtered. Note the ordering of the parameters, where the filtering function will be passed in before the array. This allows us to process the data itself as the last step.</li>
				<li>Similar to <strong class="source-inline">filter</strong>, you will need to create a curried version of <strong class="source-inline">Array.prototype.map</strong>. Type the following into the console:<p class="source-code">const map = fx =&gt; arr =&gt; arr.map(fx);</p><p>Here, <strong class="source-inline">fx</strong> is the function to be called to map each array element, and <strong class="source-inline">arr</strong> is the array itself that is to be mapped to something else.</p></li>
				<li>The next function we need to restructure is <strong class="source-inline">Math.max()</strong>, which returns the highest number of the parameters passed in. Type the following into the console:<p class="source-code">const max = arr =&gt; Math.max(...arr);</p><p>Here, <strong class="source-inline">arr</strong> is the array of numbers on which to find the max value. By default, <strong class="source-inline">Math.max()</strong> does not take an array as a parameter. However, by making use of the spread operator, that is, <strong class="source-inline">...arr</strong>, the individual array elements will be passed in as a series of parameters to <strong class="source-inline">Math.max()</strong> rather than as an array.</p></li>
				<li>Type in the implementation of the compose function:<p class="source-code">const compose = (...fns) =&gt; input =&gt; </p><p class="source-code">    fns.reduceRight((prev, fn) =&gt; fn(prev), input);</p></li>
				<li>You are ready for our first attempt at composing these functions together. Type the following into the console:<p class="source-code">const oldestFemaleRunner1 = compose(</p><p class="source-code">    max,</p><p class="source-code">    map(runner =&gt; runner.age),</p><p class="source-code">    filter(runner =&gt; runner.gender === "F")</p><p class="source-code">);</p><p>Remember that, with <strong class="source-inline">compose</strong>, the order of operations is from bottom to top. First, we have a filter function that picks out the female runners with the <strong class="source-inline">runner.gender === "F"</strong> expression. Next, we have a <strong class="source-inline">map</strong> function that <em class="italic">plucks</em> the <strong class="source-inline">age</strong> property from the female runners we resolved in the previous <strong class="source-inline">filter</strong> function and creates a new array with just the age values. Finally, <strong class="source-inline">max</strong> is called to obtain the oldest age from these values.</p></li>
				<li>We now have all the functions composed, but we still haven't actually run the array data through them to obtain the result. To do so, type the following into the console:<p class="source-code">const result1 = oldestFemaleRunner1(runners);</p><p>Now print the result:</p><p class="source-code">console.log("Result of oldestFemaleRunner1 is ", result1);</p><p>You will get an output stating that the oldest female runner is 39: </p><p class="source-code">// → output: Result of oldestFemaleRunner1 is 39</p></li>
				<li>This works, but there is a slight improvement that can be made for the <strong class="source-inline">femaleFilter</strong> portion. Why not make it into a reusable function? We can do this like so:<p class="source-code">const femaleFilter = filter(runner =&gt; runner.gender === "F");</p><p>Recall that <strong class="source-inline">filter</strong> was a curried function with two layers of parameters (<strong class="source-inline">fx</strong> and <strong class="source-inline">arr</strong>). Here, we are calling <strong class="source-inline">filter</strong> with the first parameter, <strong class="source-inline">fx</strong>, which results in a partially applied function. This <strong class="source-inline">femaleFilter</strong> function can now be used in any context, not just here.</p><p>Test the function by applying <strong class="source-inline">femaleFilter</strong> to compose the following:</p><p class="source-code">const oldestFemaleRunner2 = compose(</p><p class="source-code">    max,</p><p class="source-code">    map(runner =&gt; runner.age),</p><p class="source-code">    femaleFilter</p><p class="source-code">);</p><p class="source-code">const result2 = oldestFemaleRunner2(runners);</p><p class="source-code">console.log("Result of oldestFemaleRunner2 is ", result2);</p><p>You will get an output stating that the oldest female runner is 39 when using the <strong class="source-inline">filter</strong> function, which is as follows: </p><p class="source-code">// → output: Result of oldestFemaleRunner2 is 39</p></li>
				<li>Some people find the bottom-to-top order of processing confusing and unintuitive. Luckily, we have the <strong class="source-inline">pipe</strong> function, which functions the same as <strong class="source-inline">compose</strong> but in a top-to-bottom order. First, type in the implementation of the pipe function itself:<p class="source-code">const pipe = (...fns) =&gt; input =&gt; fns.reduce((prev, fn) =&gt; fn(prev), input);</p></li>
				<li>Here is the equivalent using <strong class="source-inline">pipe</strong>:<p class="source-code">const oldestFemaleRunner3 = pipe(</p><p class="source-code">    femaleFilter,</p><p class="source-code">    map(runner =&gt; runner.age),</p><p class="source-code">    max</p><p class="source-code">);</p><p class="source-code">const result3 = oldestFemaleRunner3(runners);</p><p class="source-code">console.log("Result of oldestFemaleRunner3 is ", result3);</p></li>
				<li>You will get the same output, that is, stating that the oldest female runner is 39 when using the pipe function, as follows: <p class="source-code">// → output: Result of oldestFemaleRunner3 is 39</p></li>
			</ol>
			<p>In this exercise, we looked at composition and currying in more detail and how these can be used in tandem to complement each other. We used the curried version of <strong class="source-inline">filter</strong> to pass a filter for the runner's gender, passed the results to a <strong class="source-inline">map</strong> function to get only the <strong class="source-inline">age</strong> value, and finally used <strong class="source-inline">Math.max</strong> to find the highest value from the array of <strong class="source-inline">age</strong> values. While the previous exercise involved some aspects of combining simple functions into a more complex process, in this exercise, we actually used <strong class="source-inline">compose</strong> to create a new function that combined the subfunctions. This allows the new function, <strong class="source-inline">oldestFemaleRunner1</strong>, to be used by others without them having to consider the underlying subfunctions.</p>
			<p>In the next section, we'll learn about recursive functions – another vital aspect of functional programming that is somewhat limited in the JavaScript programming language due to the lack of something called tail-call optimization, which is present in other functional programming languages.</p>
			<h1 id="_idParaDest-541"><a id="_idTextAnchor599"/>Function Recursion</h1>
			<p>Another technique of functional programming involves functions calling themselves recursively. This generally means you start with a big problem and break it down into multiple instances of the same problem, but in smaller chunks each time the function is called.</p>
			<p>One common example of recursion is a function to reverse the characters of a string, <strong class="source-inline">reverse(str)</strong>. Think about how you can state this problem in terms of itself. Let's say you have a string, <strong class="source-inline">"abcd"</strong>, and want to reverse it to <strong class="source-inline">"dcba"</strong>.  Recognize that <strong class="source-inline">"dcba"</strong> can be restated as follows:</p>
			<p class="source-code">reverse("bcd") + "a"</p>
			<p>In other words, you are taking the input string and breaking it down into a smaller problem by taking off the first character and making a recursive call with the remaining characters of the string. This may be easier to see in the following code:</p>
			<p class="source-code">function reverse(str) {</p>
			<p class="source-code">    if (str.length == 1) return str;</p>
			<p class="source-code">    return reverse(str.slice(1)) + str[0];</p>
			<p class="source-code">}</p>
			<p class="source-code">reverse("abcd");   // =&gt; output: "dcba"</p>
			<p>Let's break this down:</p>
			<ul>
				<li>The <strong class="source-inline">if</strong> condition of <strong class="source-inline">str.length == 1</strong> is the base case. When the input has exactly one character, there is nothing left to reverse, so the solution is just the character itself.</li>
				<li>Otherwise, use <strong class="source-inline">String.slice()</strong> with an index of <strong class="source-inline">1</strong> to get a new string minus the first character of the input. Use this as the input to make the recursive call to <strong class="source-inline">reverse()</strong>.</li>
				<li>Return the result of the recursive call, plus the first character of the string (<strong class="source-inline">str[0]</strong>).</li>
			</ul>
			<p>Here's the step-by-step progression of calls:</p>
			<p class="source-code">reverse("abcd")  =&gt;  reverse("bcd") + "a"</p>
			<p class="source-code">reverse("bcd")   =&gt;  reverse("cd") + "b"</p>
			<p class="source-code">reverse("cd")    =&gt;  reverse("d") + "c"</p>
			<p class="source-code">reverse("d")     =&gt;  "d"</p>
			<p>It is important to realize that these function calls are nested on the internal execution stack. Once the base case of one character is reached, the recursion finally has an actual return value, which causes the stack to "unwind." When this happens, the innermost function returns a value, then the function before it, and so on in reverse order until execution propagates back to the first call. This results in the return values of <strong class="source-inline">"d"</strong> for the innermost function, followed by <strong class="source-inline">"dc"</strong>, <strong class="source-inline">"dcb"</strong>, and finally our expected result: <strong class="source-inline">"dcba"</strong>.</p>
			<p>Recursion could be useful as another technique for avoiding code that requires the mutation of state and looping. As a matter of fact, it is possible to code recursive implementations of almost any loop, and some purely functional programming languages have a preference for recursion. However, current JavaScript engines are not optimized for recursion, which puts a damper on this and limits its usefulness. It is too easy to write code that would result in slow performance and excessive memory consumption. (Future enhancements that would mitigate these problems have been proposed, but until then, you need to be very careful if you are considering using recursion in your programs.)</p>
			<h2 id="_idParaDest-542"><a id="_idTextAnchor600"/>Exercise 14.08: Creating a Deck of Cards Using reduce()</h2>
			<p>We've looked at the basic elements of functional programming in JavaScript and a few data processing examples with runner data. But dealing with data doesn't have to be all number crunching – it can actually be fun. Take, for instance, a deck of cards, which in a way is simply a set of data values ordered in some way. In this exercise, we're going to create a deck of cards by combining four functions: <strong class="source-inline">suits</strong>, <strong class="source-inline">rankNames</strong>, and <strong class="source-inline">createOrderedDeck</strong>.</p>
			<ol>
				<li value="1">Create a function called <strong class="source-inline">suits</strong> and another called <strong class="source-inline">rankNames</strong> to describe the suits and values of a deck of playing cards. Rather than being arrays, they are functions that return arrays:<p class="source-code">const suits =</p><p class="source-code">    () =&gt; [</p><p class="source-code">        { suit: "hearts", symbol: '&amp;#9829;' },    // symbol: '♥'</p><p class="source-code">        { suit: 'diamonds', symbol: '&amp;#9830;' },  // symbol: '♦'</p><p class="source-code">        { suit: 'spades', symbol: '&amp;#9824;' },    // symbol: '♠'</p><p class="source-code">        { suit: 'clubs', symbol: '&amp;#9827;' }      // symbol: '♣'</p><p class="source-code">    ];</p><p class="source-code">const rankNames =</p><p class="source-code">    () =&gt; ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q','K'];</p></li>
				<li>Create a function called ranks that takes the rankNames array as input and returns each rank mapped as a key-value pair.<p class="source-code">const ranks =</p><p class="source-code">    rankNames =&gt; rankNames.map(rankName =&gt; ({ rank: rankName }));</p></li>
				<li>Create a function called <strong class="source-inline">createOrderedDeck</strong> that takes <strong class="source-inline">suits</strong> and <strong class="source-inline">rank</strong> as input and returns all the possible combinations (for example, every card in the deck):<p class="source-code">const createOrderedDeck =</p><p class="source-code">    (suits, ranks) =&gt; suits.reduce(</p><p class="source-code">        (deck, suit) =&gt; {</p><p class="source-code">            const cards = ranks.map(rank =&gt; ({ ...rank, ...suit }));</p><p class="source-code">            return deck.concat(cards);</p><p class="source-code">        }, []);</p><p>We use <strong class="source-inline">Array.prototype.reduce</strong> with an empty array <strong class="source-inline">[]</strong> as the initial value.  We then "iterate" over the <strong class="source-inline">suits</strong>, and use <strong class="source-inline">Array.prototype.map</strong> over the <strong class="source-inline">ranks</strong> to combine the suits and ranks by using the spread operator (<strong class="source-inline">...</strong>).  The  <strong class="source-inline">Array.prototype.concat()</strong> method then adds the new cards to the resulting array.  Once the "nested loop" is complete, we end up with 52 unique cards with all the combinations of suits and ranks.</p></li>
				<li>Next, we'll create an instance of a deck of cards by creating a variable from the result of <strong class="source-inline">createOrderedDeck</strong> and our <strong class="source-inline">suits</strong> and <strong class="source-inline">ranks</strong> functions:<p class="source-code">const orderedDeck = createOrderedDeck(suits(), ranks(rankNames()));</p></li>
				<li>To demonstrate what has been done so far, open up the Google Chrome browser, go to <strong class="source-inline">Developer</strong> Tools, and then paste in the preceding steps. After you've done that, type in <strong class="source-inline">orderedDeck</strong>. You should get an array like the one shown in the following screenshot. Try clicking on some of the items to look at the contained cards:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer343">
					<img alt="Figure 14.12: List of a deck of cards using the reduce function&#13;&#10;" src="image/C14377_14_12.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.12: List of a deck of cards using the reduce function</p>
			<p>In this<a id="_idTextAnchor601"/> exercise, we looked at the <strong class="source-inline">reduce</strong> function we learned about earlier in the chapter and applied it to the situation of creating a deck of cards. We'll build on this in the next exercise to create a function that shuffles a deck randomly, in a way that would make it useful for games.</p>
			<h2 id="_idParaDest-543"><a id="_idTextAnchor602"/>Exercise 14.09: Using the pipe Method to Create a Card Shuffling Function</h2>
			<p>Now that we have an ordered deck of cards, we'll look at how we can shuffle it. Of course, as with all functional code, we'll do this without modifying any existing variables.</p>
			<ol>
				<li value="1">Continuing in the same console as the previous exercise, define the <strong class="source-inline">pipe</strong> and <strong class="source-inline">map</strong> functions we discussed earlier. We won't use <strong class="source-inline">compose</strong> here, but you should get into the habit of defining these three functions for each program when writing functional code as you'll be using them a lot:<p class="source-code">const compose =</p><p class="source-code">    (...fns) =&gt; input =&gt; fns.reduceRight((prev, fn) =&gt; fn(prev), input);</p><p class="source-code">const pipe =</p><p class="source-code">    (...fns) =&gt; input =&gt; fns.reduce((prev, fn) =&gt; fn(prev), input);</p><p class="source-code">const map = fx =&gt; arr =&gt; arr.map(fx);</p><p>The <strong class="source-inline">addRandom</strong> function adds a field called <strong class="source-inline">random</strong> to each element.  Note how the random number itself is obtained from a separate <strong class="source-inline">randomizer</strong> method.  This is to keep the <strong class="source-inline">addRandom</strong> function as pure as possible, and isolate the code that has side-effects.</p></li>
				<li>Create a <strong class="source-inline">randomizer</strong> variable, followed by an <strong class="source-inline">addRandom</strong> curry function:<p class="source-code">const randomizer =</p><p class="source-code">    Math.random;</p><p class="source-code">const addRandom =</p><p class="source-code">    randomizer =&gt; deck =&gt; deck.map(card =&gt; ({</p><p class="source-code">        random: randomizer(),</p><p class="source-code">        card</p><p class="source-code">    }));</p></li>
				<li>Create a <strong class="source-inline">sortByRandom</strong> function that sorts an input deck randomly:<p class="source-code">const sortByRandom =</p><p class="source-code">    deck =&gt; [...deck].sort((a, b) =&gt; a.random - b.random);</p><p>This function sorts the cards by the added <strong class="source-inline">random</strong> field.  The <strong class="source-inline">spread</strong> operator (...) is used to clone the array before sorting it, rather than sorting the original array.</p></li>
				<li>Create a <strong class="source-inline">shuffle</strong> function that takes a deck and a randomizer value (the randomizer can be changed later if there is a need for a more random value, as would be the case in real casino games). We then use <strong class="source-inline">pipe</strong> to create a function that combines <strong class="source-inline">addRandom</strong> <em class="italic">(to specify our randomizer)</em>, <strong class="source-inline">sortByRandom</strong>, and a <strong class="source-inline">map</strong> function. Finally, we'll execute the <strong class="source-inline">doShuffle</strong> function we just created and use our deck of cards as the input:<p class="source-code">const shuffle =</p><p class="source-code">    (deck, randomizer) =&gt; {</p><p class="source-code">        const doShuffle = pipe(</p><p class="source-code">            addRandom(randomizer),</p><p class="source-code">            sortByRandom,</p><p class="source-code">            map(card =&gt; card.card)</p><p class="source-code">        );</p><p class="source-code">        return doShuffle(deck);</p><p class="source-code">    };</p><p>The purpose of the curried <strong class="source-inline">map</strong> function is to remove the <strong class="source-inline">random</strong> field that was added earlier and just preserve the original fields related to the card itself.</p></li>
				<li>Open up the Google Chrome <strong class="source-inline">Developer Tools</strong> session from the previous exercise. If you don't have it saved, you'll need to input the code from the previous exercise. At that point, input the preceding four code snippets from this exercise. With that, execute the <strong class="source-inline">shuffle</strong> function with <strong class="source-inline">shuffle(orderedDeck, randomizer)</strong> and then explore the returned object by clicking it and observing that the cards are shuffled, as shown in the following screenshot:</li>
			</ol>
			<div>
				<div class="IMG---Figure" id="_idContainer344">
					<img alt="Figure 14.13: List of a deck of cards using the reduce function&#13;&#10;" src="image/C14377_14_13.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.13: List of a deck of cards using the reduce function</p>
			<p>We can see the shuffled lists of cards as using the <strong class="source-inline">pipe and map</strong> functions. We can now go ahead and use these functions to work on the Blackjack card game.</p>
			<h1 id="_idParaDest-544"><a id="_idTextAnchor603"/>Blackjack</h1>
			<p>For the remainder of this chapter, we will be using what we've learned about functional programming to write an implementation of a simple variant of the card game Blackjack.</p>
			<p>Unlike regular Blackjack, though, our game only has one player. The player can draw as many cards as they want (<strong class="source-inline">hit</strong>), as long as the total value does not exceed 21.</p>
			<p>The total is the sum of the values of the cards in the player's hand. Cards have the following values:</p>
			<ul>
				<li>Numeric cards have their face value (for example, a 6 of hearts has a value of 6)</li>
				<li>A Jack, Queen, or King has a value of 10</li>
				<li>For simplicity, the Ace is worth 1 (unlike regular Blackjack, where it has a value of either 1 or 11)</li>
			</ul>
			<p>If the total value exceeds 21, the hand has gone bust and the game is over.</p>
			<h2 id="_idParaDest-545"><a id="_idTextAnchor604"/>Mapping Card Values to Cards</h2>
			<p>The two previous exercises will be very useful in the final assignment, where you'll be implementing a Blackjack game. Feel free to use those code snippets directly. Of course, it won't be sufficient to know just the cards' names – you'll also want to know the value of each card. The <strong class="source-inline">map</strong> function we previously explored will come in very handy for this. Enhance the <strong class="source-inline">ranks</strong> currying function from <em class="italic">Exercise 8: Creating a Deck of Cards Using reduce</em> to convert <strong class="source-inline">rankNames</strong> into both <strong class="source-inline">rank</strong> and <strong class="source-inline">value</strong> fields:</p>
			<p class="source-code">const ranks =</p>
			<p class="source-code">    rankNames =&gt; rankNames.map(</p>
			<p class="source-code">        (rank, index) =&gt; ({ rank, value: Math.min(10, index + 1) }));</p>
			<p>This function takes advantage of the index passed in as the optional second parameter in the mapping function. The rank "<strong class="source-inline">A</strong>" is at index <strong class="source-inline">0</strong>, so the value resolves as <strong class="source-inline">1</strong> (since the formula is <strong class="source-inline">index</strong> + <strong class="source-inline">1</strong>). The rank "<strong class="source-inline">2</strong>" is at index <strong class="source-inline">1</strong>, so the value would resolve to <strong class="source-inline">2</strong> (since <strong class="source-inline">index</strong> + <strong class="source-inline">1</strong> = <strong class="source-inline">2</strong>). Same applies to the rest of the numbers, the value would resolve to the same as the number. Once we get to "<strong class="source-inline">J</strong>" and above, though, the value resolves to <strong class="source-inline">10</strong> due to <strong class="source-inline">Math.min()</strong>.</p>
			<p>Now, enter <strong class="source-inline">orderedDeck</strong> and explore the object that is returned. You'll notice that all the items now have a value, and the value for the face suits (<strong class="source-inline">J</strong>, <strong class="source-inline">Q</strong>, <strong class="source-inline">K</strong>) are all 10:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer345">
					<img alt="Figure 14.14: Ordered list of a deck of cards using the order function&#13;&#10;" src="image/C14377_14_14.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.14: Ordered list of a deck of cards using the order function</p>
			<p>With the functions we've now covered relating to cards using the basics of functional programming, that is, <strong class="source-inline">map</strong>, <strong class="source-inline">reduce</strong>, <strong class="source-inline">compose</strong>, and <strong class="source-inline">pipe</strong>, you will have a strong foundation for building your own card games.</p>
			<h2 id="_idParaDest-546"><a id="_idTextAnchor605"/>Activity 14.01: Blackjack Card Functions</h2>
			<p>The aim of this activity is to get you to create some of the functions that are needed to code a Blackjack game with what you learned about functional programming. You will not be coding the whole game, just some of the core functions related to card logic.</p>
			<p>In the GitHub project, you'll find a pre-built HTML file <strong class="source-inline">start.html</strong> with some CSS in it that you should use as a starting point.</p>
			<p>The high-level steps for the activity are as follows:</p>
			<ol>
				<li value="1">Open the starting point HTML/CSS file called <strong class="source-inline">blackjack/start.html.</strong></li>
				<li>Add or implement the functions for creating a deck of cards using suits, rank names, and values.</li>
				<li>Write implementations for the core functional programming methods, that is, <strong class="source-inline">pipe</strong>, <strong class="source-inline">compose</strong>, and <strong class="source-inline">map</strong>.</li>
				<li>Add functions for drawing a card, getting the sum of a player's cards, checking whether a hand is over 21 points, and checking whether the game is over (the player stayed or went bust).</li>
				<li>Add a function for updating the card display and card images.</li>
				<li>Add a function for updating the status display, which tells the user the sum of their hand.</li>
				<li>Add the <strong class="source-inline">play</strong>, <strong class="source-inline">hit</strong>, and <strong class="source-inline">stay</strong> handler functions for the different actions a user can take.</li>
				<li>Finally, add any impure functions you may need, such as helpers for getting an element by ID or class.</li>
				<li>Add a function for setting the state, as well as a function to trigger the game itself.</li>
			</ol>
			<p>With these steps done, you should now be able to open the HTML file in a browser and have a running version of the game, as shown in the following screenshot:</p>
			<div>
				<div class="IMG---Figure" id="_idContainer346">
					<img alt="Figure 14.15: Screenshot of the Blackjack game&#13;&#10;" src="image/C14377_14_15.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.15: Screenshot of the Blackjack game</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The solution to this activity can be found on page 758.</p>
			<p>Admittedly, this implementation of Blackjack is not very playable and won't win awards for visual design. However, it is a great demonstration of functional programming. See if you can use this code as a basis to implement your own full two-player version of the game.</p>
			<h2 id="_idParaDest-547"><a id="_idTextAnchor606"/>Managing Blackjack Game State</h2>
			<p>This game only requires a small amount of state: namely, the player's hand, the game deck, and if the player has selected to stay (and not ask for another card). This state management is isolated to the following code:</p>
			<p class="source-code">const createState = (dom) =&gt; {</p>
			<p class="source-code">    let _state;</p>
			<p class="source-code">    const getState = () =&gt; [..._state];</p>
			<p class="source-code">    const setState =</p>
			<p class="source-code">        (hand, gameDeck, stay = false) =&gt; {</p>
			<p class="source-code">            _state = [hand, gameDeck];</p>
			<p class="source-code">            updateCardDisplay(dom, hand);</p>
			<p class="source-code">            updateStatusDisplay(dom, hand, stay);</p>
			<p class="source-code">        };</p>
			<p class="source-code">    return { getState, setState };</p>
			<p class="source-code">}</p>
			<p>Notice the <strong class="source-inline">return</strong> statement at the end. Only the two methods <strong class="source-inline">getState</strong> and <strong class="source-inline">setState</strong> end up being exposed to the caller, but the <strong class="source-inline">_state</strong> variable remains safe in the closure and acts as the equivalent of a "private" field in object-oriented programming. In addition:</p>
			<ul>
				<li>To isolate the code that produces side-effects as much as possible, there is a separate parameter <strong class="source-inline">dom</strong> that has references to other functions that actually do DOM manipulation.</li>
				<li>The <strong class="source-inline">getState</strong> function returns a clone of the state fields (using the spread operator ...), not the actual values in the fields</li>
				<li>When <strong class="source-inline">setState</strong> is called, two other functions <strong class="source-inline">updateCardDisplay</strong> and <strong class="source-inline">updateStatusDisplay</strong> are called (presented soon) to update the respective portions of the display to correspond to the new state. These functions are designed to dynamically regenerate all the HTML related to the state values each time the state changes.  his way there is no additional state needed in the display logic itself. (Popular web frameworks like Angular and React update displays in much the same way, though with some optimizations for the sake of performance).</li>
			</ul>
			<p>The state is created at the start of the game:</p>
			<p class="source-code">startGame(createState(dom));</p>
			<h2 id="_idParaDest-548"><a id="_idTextAnchor607"/>Blackjack Game Logic Flow</h2>
			<p>The <strong class="source-inline">startGame</strong> function itself registers three event handling functions to respond to the three buttons the user may click: <strong class="source-inline">New Game</strong>, <strong class="source-inline">Hit</strong> or <strong class="source-inline">Stay</strong>:</p>
			<p class="source-code">const startGame = (state) =&gt; {</p>
			<p class="source-code">    byId("playBtn").addEventListener("click", playHandler(randomizer, state));</p>
			<p class="source-code">    byId("hitBtn").addEventListener("click", hitHandler(state));</p>
			<p class="source-code">    byId("stayBtn").addEventListener("click", stayHandler(state));</p>
			<p class="source-code">}</p>
			<p>The <strong class="source-inline">playHandler</strong> function looks like this:</p>
			<p class="source-code">const playHandler = (randomizer, { getState, setState }) =&gt; () =&gt; {</p>
			<p class="source-code">    const orderedDeck = createOrderedDeck(suits(), ranks(rankNames()));</p>
			<p class="source-code">    let gameDeck = shuffle(orderedDeck, randomizer);</p>
			<p class="source-code">    [hand, gameDeck] = draw(gameDeck, 2);</p>
			<p class="source-code">    setState(hand, gameDeck);</p>
			<p class="source-code">};</p>
			<p>First the deck is created and shuffled to create the full game deck.  Two cards are then drawn from the game deck as the hand. The hand and remaining game deck (minus the two cards drawn) are saved by calling <strong class="source-inline">setState</strong> (which indirectly also triggers the screen to display the cards).</p>
			<p>The <strong class="source-inline">hitHandler</strong> function follows a similar pattern:</p>
			<p class="source-code">const hitHandler = ({ getState, setState }) =&gt; () =&gt; {</p>
			<p class="source-code">    [hand, gameDeck] = getState();</p>
			<p class="source-code">    [card, gameDeck] = draw(gameDeck, 1);</p>
			<p class="source-code">    setState(hand.concat(card), gameDeck);</p>
			<p class="source-code">};</p>
			<p>The current hand and game deck is retrieved by calling <strong class="source-inline">getState</strong>. Then one card is drawn from the game deck. This card is added to the hand and saved by calling <strong class="source-inline">setState</strong> (which once again indirectly also triggers the screen to display the cards).</p>
			<p>The <strong class="source-inline">stayHandler</strong> is simpler. It doesn't make any state modifications besides calling <strong class="source-inline">setState</strong> with <strong class="source-inline">true</strong> in the last parameter, indicating the player has stayed:</p>
			<p class="source-code">const stayHandler = ({ getState, setState }) =&gt; () =&gt; {</p>
			<p class="source-code">    [hand, gameDeck] = getState();</p>
			<p class="source-code">    setState(hand, gameDeck, true);</p>
			<p class="source-code">};</p>
			<h2 id="_idParaDest-549"><a id="_idTextAnchor608"/>Blackjack Game Display Functions</h2>
			<p>The <strong class="source-inline">updateCardDisplay</strong> function is the following:</p>
			<p class="source-code">const updateCardDisplay =</p>
			<p class="source-code">    ({ updateHTML }, hand) =&gt; {</p>
			<p class="source-code">        const cardHtml = hand.map((card, index) =&gt;</p>
			<p class="source-code">            `&lt;div class="card ${card.suit}"</p>
			<p class="source-code">                style="top: -${index * 120}px;</p>
			<p class="source-code">                       left: ${index * 100}px;"&gt;</p>
			<p class="source-code">                &lt;div class="top rank"&gt;${card.rank}&lt;/div&gt;</p>
			<p class="source-code">                &lt;div class="bigsuit"&gt;${card.symbol}&lt;/div&gt;</p>
			<p class="source-code">                &lt;div class="bottom rank"&gt;${card.rank}&lt;/div&gt;</p>
			<p class="source-code">             &lt;/div&gt;`);</p>
			<p class="source-code">        updateHTML("cards", cardHtml.join(""));</p>
			<p class="source-code">    };</p>
			<p>The HTML for each card in the hand is determined in this function using <strong class="source-inline">Array.prototype.map</strong> and joined together at the end to make one string. The calculations for the styles <strong class="source-inline">top</strong> and <strong class="source-inline">left</strong> take advantage of the optional <strong class="source-inline">index</strong> parameter of the mapping function to allow the cards to have a staggered effect. Different CSS classes <strong class="source-inline">top</strong>, <strong class="source-inline">rank</strong>, <strong class="source-inline">bigsuit</strong> and <strong class="source-inline">bottom</strong> position and size the different parts of the card. The suit name itself is also a CSS class to apply the correct color for the suit (black or red).</p>
			<p>The other function related to display, <strong class="source-inline">updateStatusDisplay</strong>, is implemented as follows:</p>
			<p class="source-code">const updateStatusDisplay =</p>
			<p class="source-code">    ({ updateStyle, updateHTML }, hand, stay) =&gt; {</p>
			<p class="source-code">        const total = sumCards(hand);</p>
			<p class="source-code">        updateHTML("totalSpan", total);</p>
			<p class="source-code">        const bust = isBust(total);</p>
			<p class="source-code">        const gameover = isGameOver(bust, stay);</p>
			<p class="source-code">        showOrHide(updateStyle, "playBtn", !gameover);</p>
			<p class="source-code">        showOrHide(updateStyle, "hitBtn", gameover);</p>
			<p class="source-code">        showOrHide(updateStyle, "stayBtn", gameover);</p>
			<p class="source-code">        let statusMsg = gameover ?</p>
			<p class="source-code">            "Game over.  Press New Game button to start again." :</p>
			<p class="source-code">            "Select Hit or Stay";</p>
			<p class="source-code">        statusMsg = bust ? "You went bust!!! " + statusMsg : statusMsg;</p>
			<p class="source-code">        updateHTML("statusMsg", statusMsg);</p>
			<p class="source-code">    };</p>
			<p>This function does several things:</p>
			<ul>
				<li>Calculates the total value of the cards and displays it</li>
				<li>Determines if the game is over by calling <strong class="source-inline">isBust</strong> and <strong class="source-inline">isGameOver.</strong>  (If a hand is in play, the New Game button should not be visible.  If the game is over or not active, the Hit and Stay buttons should not be visible. See Figure 14.16.)</li>
				<li>Shows or hides the different buttons depending on if the game is over or not</li>
				<li>Changes the status message depending on if the game is over or not</li>
			</ul>
			<div>
				<div class="IMG---Figure" id="_idContainer347">
					<img alt="Figure 14.16: The Hit and Stay buttons are visible when the game is active&#13;&#10;" src="image/C14377_14_16.jpg"/>
				</div>
			</div>
			<p class="figure-caption">Figure 14.16: The Hit and Stay buttons are visible when the game is active</p>
			<p>Effectively, this function actually drives much of the game flow, as the UI elements available to the user are set within it.</p>
			<h2 id="_idParaDest-550"><a id="_idTextAnchor609"/>Blackjack Code Listing</h2>
			<p>The previous sections covered the most important parts of the code. The full code listing for the game is linked as follows:</p>
			<p><a href="https://packt.live/370zgaq">https://packt.live/370zgaq</a></p>
			<p>For simplicity, all the code is contained within one file, including all the CSS styles and JavaScript supporting functions. In a real-world application, though, you should consider splitting up the files.</p>
			<h1 id="_idParaDest-551"><a id="_idTextAnchor610"/>Summary</h1>
			<p>In this chapter, you got a taste of functional programming. It is quite different from other programming paradigms such as imperative and object-oriented approaches, and it takes a while to get used to. But when properly applied, it is a very powerful way of structuring programs so that they're more declarative, correct, testable, and have fewer errors.</p>
			<p>Even if you don't use pure functional programming in your projects, there are many useful techniques that can be used on their own. This is especially true for the <strong class="source-inline">map</strong>, <strong class="source-inline">reduce</strong>, and <strong class="source-inline">filter</strong> array methods, which can have many applications.</p>
			<p>This chapter also only used functionality that's available in native JavaScript. But note that there are also a number of popular libraries available to assist with functional programming. These libraries facilitate practical functional programming concerns such as immutability, side-effect-free functions, composition, and automatic currying. </p>
			<p>The topics we covered in this chapter will help you bolster the skills you need to pursue a programming project in the functional style.</p>
			<p>In the next chapter, you will take a deeper look at asynchronous coding, including the history of asynchronous callbacks, generators, promises, and async/await. This will complete your journey through modern JavaScript development, priming you with all you need to create great-looking software.</p>
		</div>
		<div>
			<div class="Content" id="_idContainer349">
			</div>
		</div>
	</body></html>