- en: Chapter 5. Inheritance, Overriding, and Nesting in Less
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far in our journey with Less, we've seen how you can begin to reduce the
    code you need to write; it's time to take it up a level and begin to look at some
    more advanced concepts within Less.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me begin by asking you a question: what is the one thing that irritates
    you about writing styles where the same selector has to be repeated many times,
    such as when designing a menu system using an unordered list element? Hopefully,
    the answer is duplicated styles. In this chapter, we will take a look at how you
    can group styles to avoid the need to duplicate selectors in your code. We will
    also cover how you can inherit styles that can have a dramatic effect on reducing
    duplication; I''ll also provide some hints and tips on using these techniques
    and others to help reduce code bloat.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Enough chat, let''s take a look at what we will cover throughout this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Nesting styles within Less
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting styles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Namespacing in Less
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scope of styles in Less
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Hints and tips on avoiding code bloat
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing style sheets into Less
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Curious? What are you waiting for? Let's get started...
  prefs: []
  type: TYPE_NORMAL
- en: Nesting styles in Less
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you spend any time writing styles, I am sure you will frequently have written
    some that are duplicates of existing ones elsewhere in the same style sheet; this
    is particularly true if you are creating styles for elements of a site, such as
    a menu system using `<ul>` or `<li>`.
  prefs: []
  type: TYPE_NORMAL
- en: It can add a lot of extra code bloat from duplicated styles. Thankfully, there
    is a way we can reduce this, by using Less' ability to nest styles. Let's take
    a look at how this principle works, by creating the online equivalent of a business
    card.
  prefs: []
  type: TYPE_NORMAL
- en: For this exercise, we will need a few things. As a start, we'll need an image
    on our card; in this instance, we'll use an avatar, as this business card will
    be displayed on websites. There are thousands of icons available for this purpose;
    I will assume you have picked a suitable one and saved it as `avatar.png`. I've
    used the Office Client Male Light Icon, available at [http://www.iconarchive.com/show/vista-people-icons-by-icons-land/Office-Client-Male-Light-icon.html](http://www.iconarchive.com/show/vista-people-icons-by-icons-land/Office-Client-Male-Light-icon.html).
  prefs: []
  type: TYPE_NORMAL
- en: Next comes the telephone, e-mail, and figurehead icons; these are from the Modern
    Pictograms font family found at [http://www.fontsquirrel.com/fonts/modern-pictograms](http://www.fontsquirrel.com/fonts/modern-pictograms).
    You will need to convert it into a format that can be embedded into a webpage;
    this can be done using a free service at [http://www.convertfonts.com](http://www.convertfonts.com).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, before we can start work on creating our card, we need some social
    media icons. I've chosen to use the hand-drawn ones by Chris Spooner, which can
    be downloaded from [http://blog.spoongraphics.co.uk/freebies/hand-drawn-sketchy-icons-of-your-favorite-social-sites](http://blog.spoongraphics.co.uk/freebies/hand-drawn-sketchy-icons-of-your-favorite-social-sites);
    alter the code accordingly if you decide to use other icons instead.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a business card
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start by opening a copy of `nesting.html` from the code bundle that accompanies
    this book. This contains the markup we need to create our basic vCard.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add some styling to make it look presentable. There are a few
    styles involved, so grab a copy of the code download file that accompanies this
    book and extract a copy of `nesting.less` from within the archive.
  prefs: []
  type: TYPE_NORMAL
- en: 'Save the file as `nesting.html`. If you preview the results in a browser, you''ll
    see something similar to the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating a business card](img/00052.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Examining the process in detail
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we take a look through `nesting.less`, you will notice a number of styles
    using a similar format. These examples are all variations on a theme of nesting,
    where instead of adding individual child selectors (and thus duplicating code),
    we can group together similar child selectors and implement one parent selector.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our first example uses the standard `a` selector, to which we''ve grouped together
    the style rules for `:focus`, `:hover`, and `:active`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This produces the following code when compiled:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In this example, we've used `a` only to illustrate how the process works—in
    reality, this is an example of where you wouldn't gain any benefit from such a
    short selector name; the benefit is only seen when longer names are used.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our second example is a little more advanced—here, we''ve included some standard
    CSS styles and mixed in style rules for two additional child selectors that go
    several levels deeper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The key to nesting is careful examination of any classes or selectors, where
    there is duplication; let''s take a look at the CSS styles that will be displayed
    in a browser, for the `.social` code block we''ve just covered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: To work out whether a style can be converted to use nesting, we can take a look
    at similar selectors; nesting will only work where the selectors use common IDs.
    In this example, `.social` is the common selector, hence it's used in our Less
    example.
  prefs: []
  type: TYPE_NORMAL
- en: A key point to note—at first glance, it would appear that `.social ul` could
    have been used instead. This would work, but only for two additional child selectors
    (`.social ul li` and `.social ul li a`). The parent `.social` class cannot be
    included if we go in at this level, as we can only work top-down and not bottom-up
    when considering which styles to nest.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a general rule of thumb that the selector or class used as our grouping
    ID, should not be more than two levels deep; any more is considered bad practice
    and should really be revisited!
  prefs: []
  type: TYPE_NORMAL
- en: Let's change focus and take a look at another functionality of Less, which is
    inheriting and overriding styles, using the `extend` option.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting and overriding styles with extend
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we've used mixins to help reduce the need to write extra code,
    as we can call these blocks of code from our Less statements easily, to produce
    the desired effect.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately this is still not without its own drawback. Let's say we create
    two rules, that both call the same mixin, and produce identical results (save
    for the rule name), then Less will interpret these as two separate blocks of code,
    even though they both perform the same styling on two different objects. What
    if we could merge these two rules together so that there is only one block of
    code, but which can be called by either rule?
  prefs: []
  type: TYPE_NORMAL
- en: Well, we can, with the use of the `extend` function in Less. This is a really
    powerful function, introduced for this purpose. Let's take a look at the concept
    to see how it works.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have a mixin, such as this simple one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'If we compile it using something like Crunch!, then it will display this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'This works perfectly well, but shows the aforementioned duplicated styles.
    To remove this duplication, we can use the `extend` keyword and rework the code
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'You can immediately see the difference in the output. Instead of splitting
    each rule onto two lines as it did before, we''ve been able to merge the rule
    into one block, but it can be called by either class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth reading the documentation on the main Less site on the subject of
    `extend`—there are some interesting features that you will need to be aware of,
    when using the function in your code. You can view the documentation at [http://lesscss.org/features/#extend-feature](http://lesscss.org/features/#extend-feature).
  prefs: []
  type: TYPE_NORMAL
- en: The rule of thumb for choosing whether to use `extend` or a mixin is to choose
    the technique that requires the least final output (or that works best for you).
  prefs: []
  type: TYPE_NORMAL
- en: Using extend to create information alerts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To see how `extend` works in practice, let's take a look at a little exercise
    to create some imaginary dialog boxes that contain messages to alert the user
    about the outcome of an operation.
  prefs: []
  type: TYPE_NORMAL
- en: Before we can get to work on our example, we first need to download some icons
    that are suitable for use in dialog boxes. I've chosen to use the free icons created
    by Andy Gongea; it will be assumed that you are using these icons, for the purpose
    of the exercise. Visit [http://www.graphicrating.com/2012/06/14/koloria-free-icons-set/](http://www.graphicrating.com/2012/06/14/koloria-free-icons-set/)
    to download the icons. You will need to extract the `info.png`, `error.png`, `warning.png`,
    `help.png`, and `valid.png` images and drop them into an `img` folder at the root
    of your project folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start writing the code! Open a copy of `project.html`, which we created
    in [Chapter 3](part0031_split_000.html#page "Chapter 3. Getting Started with Less"),
    *Getting Started with Less*, and then modify the `<head>` section as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, remove the existing markup in the `<body>` tag and replace it with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `extend.html`. On its own, it won''t win any awards for style
    if we were to preview it now, so let''s fix that by adding some! In a new file,
    add the following styles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file as `extend.less` in the `css` subfolder; if you have configured
    Sublime Text to compile Less files on save, then it will also produce the compiled
    CSS equivalent file. We can use this to compare the results shown in the file,
    with those displayed in the browser, when using a DOM Inspector such as Firebug.
    If we preview the file in a browser, we should see something like the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Using extend to create information alerts](img/00053.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Although this is a relatively simple example, it is worth taking a moment to
    study the code to see how the `extend` function operates.
  prefs: []
  type: TYPE_NORMAL
- en: If you use a mixin, you often find that you have to include a base class (`.stuff`
    in our earlier example) as your mixin, which contains the styles that you need
    to inherit within your calling classes (in this instance, `.foo` and `.bar`).
  prefs: []
  type: TYPE_NORMAL
- en: This will work perfectly well, but will duplicate the code as we have already
    seen; instead, we used the `extend` function to apply the existing `.box` class
    to each of the classes we used for the dialogs, namely `.info`, `.success`, `.warning`,
    `.error`, and `.validation`.
  prefs: []
  type: TYPE_NORMAL
- en: As `extend` is a Less pseudo-class, all trace of the `extend` function will
    be removed, leaving the resulting compiled styles. The real benefit of using this
    function can be seen when using Firebug; instead of seeing a lot of duplicated
    styles, we will see styles neatly merged together where they perform the same
    function, with the remaining styles left to operate on the remaining elements
    where appropriate.
  prefs: []
  type: TYPE_NORMAL
- en: Extending using the all keyword
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Once you have begun using the `extend` keyword in your Less code, you might
    find that you want to extend styles that are nested.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, extend can only match a selector based on what is given in the
    `extend` request; it is not always able to match child selectors below a parent,
    unless a child selector is specified. Let's take a look at an example to see what
    this means.
  prefs: []
  type: TYPE_NORMAL
- en: 'Imagine you have this simple bit of nested Less:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Using `extend` will produce this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The `h3` style will not be extended and will instead be compiled as a separate
    style:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'To get around this, we can use the `all` keyword as shown in the following
    line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `all` keyword will extend everything to produce the desired effect:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The key to it is to think of it as performing a nondestructive search and replace
    operation on the original selector, to produce a new one. Let's take a look at
    it in practice, by modifying the previous `extend` demo to use the `all` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening a copy of `extend.html`, which we created from the previous
    exercise, then encompass each of the dialog text messages in the `<h3>` tags,
    as highlighted:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `extendall.html`. In a copy of `extend.less`, we need to move
    the rule for `font-size` from body to `<h3>`, so we can then include it as a nested
    rule later in our code. Amend the style rule for body, and then immediately below
    this, add a new rule for `<h3>`, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the validation code block, add the three lines (as highlighted); this will
    style the `<h3>` tags we added earlier to our HTML code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now take advantage of the `all` keyword; immediately below the `.validation`
    style block, add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'Save the file as `extendall.less`. If we preview the results in a browser,
    we will see the added dialog box appear below the last dialog box, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Extending using the all keyword](img/00054.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now that we have seen this in action, let's take a moment to examine how it
    works.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `all` attribute with `extend` is very easy, as we have seen, but it
    does mean that the styles that need to be replicated should be as close to the
    desired result as possible, to make the use of `extend` worthwhile.
  prefs: []
  type: TYPE_NORMAL
- en: This doesn't mean to say that you can't add additional, or indeed override,
    existing styles as we have done here, but we've kept them to a minimum. Here,
    we've used `extend all` to replicate the `.validation` class and rename it as
    `.rebase`; this includes the additional styling for the `<h3>` tag, which would
    otherwise not have been included if the `all` tag had not been used. We've then
    simply overridden three of the styles to change the image used, `background-color`
    and text `color`, to make it a little more unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve only scratched the surface with what you can do using `extend`—before
    we change focus and move to looking at namespacing, let''s take a moment to look
    at some of the other highlights of using the `extend` keyword:'
  prefs: []
  type: TYPE_NORMAL
- en: Extend can be used with pseudo-class selectors such as `:hover` or `:active`;
    multiple extends can be used, along with spaces. However, if only one extend is
    used, then this must be the last part of the statement.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can use `&:extend` within a ruleset; this is a shortcut to adding `extend`
    to every single selector within the ruleset.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extend can be used with nested selectors; as long as the calling extend can
    be matched against a valid Less rule, it will be extended to use the new class
    or selector ID.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By default, extend will look for an exact match, for example, `*.class` and
    `.class`, which are equivalent, won't be considered as exact matches by Less,
    when using extend.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you want to match using type identifiers such as `[title="identifier"]`,
    then it doesn't matter whether quotes are used or not; these are effectively ignored.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `extend` keyword is a very useful tool within the Less article, but can
    cause issues if not used correctly. It is well worth reading the main documentation
    on the Less site at [http://lesscss.org/features/#extend-feature](http://lesscss.org/features/#extend-feature),
    to get your head around some of the quirks of using the function.
  prefs: []
  type: TYPE_NORMAL
- en: Namespacing in Less
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'There is one thing I am sure you will find asking yourself as time goes by
    and your CSS style sheets get larger: *can I group similar styles to make things
    easier to find?*'
  prefs: []
  type: TYPE_NORMAL
- en: Sure, you can always cut and paste similar styles together, but this is a manual
    process, right? What happens if two weeks down the line, you need to add a new
    style, which is similar to the one buried 1500-odd lines down? Surely there has
    to be a better way to do this—there is. Welcome to namespacing in Less!
  prefs: []
  type: TYPE_NORMAL
- en: Namespacing in Less takes your need to group similar styles and flips it on
    its head; it groups all of the constituent building blocks of your styles together,
    then allows you to pick and choose which styles to use when adding styling for
    a new element on your site. We can, of course, create multiple namespaces if we
    need to—our only real guide for this is that each namespace should contain styles
    that share common elements; a great example is buttons, as you will see from our
    upcoming exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s begin creating these buttons by opening a copy of `project.html` and
    then modifying the `<head>` tag as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, remove the existing markup in the `<body>` tag and replace it with the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `namespace.html` in the root of our project folder. We need to
    apply some styling, so go ahead and add the following Less styles to a new file;
    we''ll break it down into sections and go through it bit by bit, as there are
    a few important concepts to consider:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'We saw examples similar to this back in [Chapter 4](part0041_split_000.html#page
    "Chapter 4. Working with Variables, Mixins, and Functions"), *Working with Variables,
    Mixins, and Functions*; hopefully, you will recognize this as a parametric mixin.
    In this instance, we''re using it to build up a gradient for each of our buttons;
    we''re feeding it two values that represent the colors used in the gradient fading
    process, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Note that namespaces such as `#button()` used here can be made from classes
    or selector IDs; for more details on the recognized behavior, see [https://github.com/less/less.js/issues/1205](https://github.com/less/less.js/issues/1205).
  prefs: []
  type: TYPE_NORMAL
- en: 'Next comes the most important part of our Less styling: the opening statement
    for a namespaced style. It shows the name under which we will group our styles.
    We''ve used `()`, as we don''t want Less to output the mixin as well as the compiled
    CSS, when compiling our code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'These three blocks of code will call the `.background(...)` mixin to set the
    appropriate gradient, depending on which state is currently set for a specific
    button:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: This is where the real magic happens. Here, we've set the styles to be used
    for three buttons, namely red, purple, and blue. Within each button style, we've
    chosen to call elements from the `#button` namespace; if several similar namespaces
    had been created, we could easily pick and choose our styles from each, as we
    are not limited to just using one namespace. The key thing to note is that when
    calling a namespace style, you must use the format given in our example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Okay, enough of the theory. If we preview the results in a browser, we should
    expect to see something akin to this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Namespacing in Less](img/00055.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: A nice, easy example, huh? Hopefully, it will help show you how you can pick
    and choose your styles from groupings of styles, particularly when a project uses
    a lot of similar elements and styles that could benefit from being namespaced.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy loading of variables in Less
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we''ve covered a number of techniques to create and control how styles
    are applied. There is one key theme that runs throughout all of this though and
    of which you need to be aware: scope.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Yes, there''s that ugly word, scope! No matter how much we try to avoid it,
    we must always allow for it when using Less; if not, it can come back to bite
    us at the most unexpected moments. Let me explain what I mean: as we will see
    in the upcoming exercise, we can always reuse our mixins or variables throughout
    our Less code.'
  prefs: []
  type: TYPE_NORMAL
- en: The downside is that Less must have a means of knowing which instance is the
    most latest; therefore, it always takes the last instance of any variable or mixin
    that is included in our code. If you're not careful, it can lead to some odd effects.
    Let's take a look at what this means in practice, with a quick exercise.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening a copy of `project.html` that we created back in [Chapter
    3](part0031_split_000.html#page "Chapter 3. Getting Started with Less"), *Getting
    Started with Less*, and then, alter the `<head>` tag as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, remove the existing markup and replace it with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Save this as `scope.html`. Finally, even though this is only a simple example,
    we still need to add some styling; go ahead and add the following to a new file,
    saving it as `scope1.less`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Before we preview the results in a browser, ask yourself this one question:
    what colors would you expect to see in each box?'
  prefs: []
  type: TYPE_NORMAL
- en: 'No, I''ve not gone insane; stay with me on this one! If you were expecting
    to see red in boxes **1** and **2** and orange in box **3**, then I''m sorry to
    disappoint you:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy loading of variables in Less](img/00056.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Hold on—all three of them are in orange! This is true; this has to do with the
    concept of scoping within Less.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''ve spent any time programming, then you will likely be aware of how
    a variable''s value will be used in a statement if it has just been set before
    the statement. Less uses variables in a similar fashion, but with one important
    difference: it uses the *last known instance* of that variable assignment, to
    determine which value to display.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Variables in Less are merged into code—this is the equivalent of lazy loading,
    as the last defined instance of a variable is the one that is used, overwriting
    any previous instance of that variable.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look through the code, we can clearly see the last instance of `@boxcolor`
    being set a color value, just before `box3`. As the color set was orange, this
    is the value that will be used throughout our code. We can clearly see this from
    a screenshot excerpt of the compiled styles within Crunch!, where `#ffa500` is
    orange:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy loading of variables in Less](img/00057.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: It is worth noting the scope that is set when using variables, as we have done
    here. It is all too easy to be tripped up through the use of an (incorrectly)
    assigned variable, which produces unexpected results!
  prefs: []
  type: TYPE_NORMAL
- en: 'The only safe way to ensure that the right values are used is to assign separate
    variables. We can see the results of this if we modify the Less styles from our
    previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Resave the Less file as `scope2.less`; don''t forget to change the markup in
    `scope.html`! If we preview the results in the browser, we can clearly see the
    difference it has made, where separate variables have been used:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy loading of variables in Less](img/00058.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Throughout this demo, we've used `box1`, `box2`, and `box3` as selector IDs—it
    is worth nothing that these are not semantic names; for this reason, they should
    not be used in a production environment. As we are working in a demo environment
    only to illustrate a concept, then use of these names is less of an issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen the results of using separate variables, we can also see
    the difference by looking at the compiled CSS in this screenshot extract from
    Crunch!:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Lazy loading of variables in Less](img/00059.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Notice the difference? Hopefully, you will see how it is crucial to take care
    while using variables, as the scope of their use can produce some odd effects
    if not used carefully! Let's move on, as we need to take a look at some functionality
    we've already used, but haven't explored in any great depth, namely importing
    style sheets into Less.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Going overboard with variables**'
  prefs: []
  type: TYPE_NORMAL
- en: It is all too easy to add lots of variables to cater to values such as colors
    used in your site. This is not always a sensible thing to do; you should consider
    setting up a core number of variables, then using functions to work out the values
    that should be used.
  prefs: []
  type: TYPE_NORMAL
- en: Importing style sheets into Less
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Phew! We're almost there. We've certainly covered a lot in this chapter! Before
    we finish the chapter with some tips on avoiding code bloat, we should take a
    moment to consider one useful function that we've used, but not explored in any
    detail—this is the use of importing to manage our Less style sheets.
  prefs: []
  type: TYPE_NORMAL
- en: Importing in Less is a simple but useful trick to learn, particularly when managing
    large style sheets. We can begin to build up a library of code and then import
    it straight into any future project.
  prefs: []
  type: TYPE_NORMAL
- en: It makes it much easier to manage smaller files, as we can build a master file
    that imports each of the subfiles into one master; Less will only compile these
    styles that are directly referenced from our main code. So for example, if your
    code library file is more than 2,500 lines long, but a mixin of only 10 lines
    is all that is used, then Less will only include those 10 lines in the final compiled
    results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the import option is really easy; all you need to do is add in the following
    statement somewhere within your Less code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here `XXXXXXX` is one of any of the following options:'
  prefs: []
  type: TYPE_NORMAL
- en: '| Option: | Allows us to: |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `reference` | This uses a Less file but do not output it, unless referenced
    from within the code. |'
  prefs: []
  type: TYPE_TB
- en: '| `inline` | This includes the source file in the output but does not process
    it and is useful if you need to import files that are not Less compatible, but
    still need to be included in the compiled CSS file. |'
  prefs: []
  type: TYPE_TB
- en: '| `less` | This treats the file as a Less file, no matter what the file extension.
    This is ideal if you have a need for all Less files to have the `.css` extension,
    but where they should be treated as Less files, not plain CSS. |'
  prefs: []
  type: TYPE_TB
- en: '| `css` | This treats the file as a CSS file, no matter what the file extension
    is. |'
  prefs: []
  type: TYPE_TB
- en: '| `once` | This only includes the file once (this is the default behavior);
    any subsequent import requests for this file will be ignored. |'
  prefs: []
  type: TYPE_TB
- en: '| `multiple` | This includes the same Less file multiple times. This is the
    opposite of the default behavior of Less. |'
  prefs: []
  type: TYPE_TB
- en: You can learn more about the various options from the main Less site, at [http://lesscss.org/features/#import-options](http://lesscss.org/features/#import-options).
  prefs: []
  type: TYPE_NORMAL
- en: Okay, let's wrap up this chapter by taking a look at some important hints and
    tips on avoiding code bloat. Some of what you will see comes from the functionality
    that we've explored throughout this chapter, but it's useful to take a moment
    to summarize some of the key points we've covered in the book to date.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding code bloat
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When designing websites, one of the key aims that should be dear to every designer
    is to ensure that they avoid code bloat wherever they can so that their finished
    article works well and is engaging to their audience.
  prefs: []
  type: TYPE_NORMAL
- en: 'To help with this, there are a number of tips we can use to help reduce code
    bloat. We''ve already used some throughout the book so far, but now seems like
    an opportune moment to revisit and consolidate them into a useful list you can
    use for future projects:'
  prefs: []
  type: TYPE_NORMAL
- en: Aim to create a cleaner structure with the use of nesting—this means you can
    avoid having to reenter duplicate selectors (such as using `<ul>` within a list
    or menu) and can keep the code organized as related items are grouped together.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create variables for faster maintenance—these work very much like variables
    in other programming languages, such as C#. We can set one instance of a variable
    at the start, then reference this throughout our code; Less will automatically
    update each instance for you. Take care how many you create though, as each requires
    valuable resources; it is better practice to create a core bunch and use operators
    to dynamically work out new values. This has the benefit of allowing these new
    values to continue to work, even if original variables are subsequently changed.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use mixins to create whole classes that we can reference throughout our code.
    On larger sites, this can have a dramatic effect in reducing the amount of code
    that needs to be written. If you are already using mixins, then check through
    your code to see if they can't be made parametric; this increases their flexibility
    and will allow you to remove redundant mixins, as they can be served by tweaking
    other mixins.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Take an iterative approach to develop your CSS, particularly when using mixins.
    If you use mixins that are similar to mixins being brought in by external Less
    libraries, then try to design out the differences, so you can remove your own...
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Use namespaces to pick and choose mixins. This will help you group together
    common styling rules that apply to similar elements, such as buttons; you can
    then pick and choose which elements to use. Try to keep the number of selector
    elements used in each namespace to a minimum too; there is no hard and fast rule,
    but a good rule of thumb is something like the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If your code uses more than one selector elements in each namespace it is likely
    that your code isn't as efficient as it should be...!
  prefs: []
  type: TYPE_NORMAL
- en: If you are using namespacing, then take care of your CSS specificity, otherwise
    clashing results can be a symptom of nesting too deeply, or overuse of the `!important`
    attribute. If you find this happening, then you might need to break your namespacing
    into smaller groups, which uses fewer levels of nesting.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consider using class inheritance instead of selector inheritance. If you are
    creating a mixin, which you later reference in your selector classes, you might
    find that you can simply use class inheritance in your HTML instead. So, as an
    example, instead of using this in your Less file:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We can eliminate the repeated use of `.gradientBlack`, by defining it once
    in our style sheet, then referencing it directly in the code:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Use extend instead of mixins to reduce code bloat; `extend` is clever enough
    to merge together styles that use the same rules, as we saw earlier in the chapter,
    instead of simply reproducing code blocks for each similar style.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you have to stay with using mixins, then use parentheses to hide the mixin
    code so that only the calling code is compiled and not the additional mixin as
    well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you have a number of mixins that require vendor prefixing, you can use this
    mixin to handle them by simply passing the property that needs to be prefixed,
    along with the appropriate value, as shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note that this isn't necessary for all properties that still require vendor
    prefixes; if a CSS3 property only needs one or two vendor prefixes, you might
    find it easier to create a simple mixin to handle this separately.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is worth noting that some vendor prefixes use a completely different format
    to the example we've used—the mixin here won't work for all property values, such
    as gradients and will therefore need a separate mixin.
  prefs: []
  type: TYPE_NORMAL
- en: Hopefully, there are some useful tips in there that you can use in your projects.
    The key to all of this is using the right combination of functions, such as extends
    instead of mixins (or a mix of both), that helps keep your code to a minimum and
    free of bloat.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout this chapter, we've covered a few concepts that will help further
    reduce the amount of code you need to write—let's take a moment to recap, before
    moving onto some more practical areas of using Less in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: We began with a look at how you can group or nest styles within Less; we saw
    how this can help arrange styles visually, to make it easier to manage, but also
    remove the need to duplicate styles, when referencing child selectors such as
    those used in building menu systems.
  prefs: []
  type: TYPE_NORMAL
- en: We then moved on and looked at the extend function to inherit or override existing
    styles, and covered how it works in a similar fashion to mixins, while at the
    same time, merging together identical styles, to remove the need to have separate
    code blocks for identical styles. We also took a look at the use of the `all`
    keyword to help with inheriting of all of the styles, particularly those otherwise
    not accessible using extend on its own.
  prefs: []
  type: TYPE_NORMAL
- en: We then covered how you group styles and reference one or more elements using
    namespacing; this allows us to visually group together common elements, while
    at the same time, picking and choosing which styles to use. Once chosen, we then
    saw how Less will compile these into valid CSS.
  prefs: []
  type: TYPE_NORMAL
- en: Last but by no means least, we took a quick look at setting the right scope
    in Less, to ensure our variables have the right values. We saw from the example
    how easy it is to get the scope wrong and the importance of using the right scope
    in our code. We then finished with a look at importing Less files into CSS and
    some hints and tips on removing code bloat, based on some of the key areas of
    Less we have seen so far in the book.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll move on from the theory and take a look at some of
    the practical aspects of moving a CSS-based site over to using Less.
  prefs: []
  type: TYPE_NORMAL
