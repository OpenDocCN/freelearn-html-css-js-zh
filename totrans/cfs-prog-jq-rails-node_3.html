<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. CoffeeScript and jQuery</h1></div></div></div><p><strong>jQuery</strong>
<a id="id148" class="indexterm"/> is a cross-browser compatible library designed to simplify the life of an HTML application developer. It was first released by John Resig in 2006 and has since become the most popular JavaScript library in the world, and is used in millions of websites.</p><p>Why did it become so popular? Well, jQuery has a couple of nice features like easy DOM manipulation and querying, event handling, and animation, as well as AJAX support. All these combined together makes programming against the DOM and programming in JavaScript much better.</p><p>The library has also been highly optimized in terms of cross-browser compatibility and speed and thus using jQuery's DOM traversal and manipulation functions not only save you from writing tedious code, but it's also usually much faster than the code that you could write yourself.</p><p>As it turns out, jQuery and CoffeeScript go very well together, and when combined, provides a powerful toolset to write web applications in a succinct and expressive manner.</p><p>In this chapter, we'll do the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Explore some of the high level features of jQuery and talk about what it gives you</li><li class="listitem" style="list-style-type: disc">Learn how to use CoffeeScript and jQuery in the browser</li><li class="listitem" style="list-style-type: disc">Build a simple to-do list app using jQuery and CoffeeScript</li></ul></div><p>Let's start by discussing the jQuery library in more detail, and discover what makes it so useful.</p><div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Finding and changing elements</h1></div></div></div><p>In web <a id="id149" class="indexterm"/>browsers, the DOM, or Document Object Model, is the representation<a id="id150" class="indexterm"/> of the elements in an HTML document used to interact with programmatically.</p><p>In JavaScript, you'll find yourself doing a lot of DOM traversal to find elements that you're interested in and then manipulate them.</p><p>To accomplish this using just the standard JavaScript libraries, you'll usually need to use a combination of the <code class="literal">document.getElementsByName</code>, <code class="literal">document.getElementById</code>, and <code class="literal">document.getElementsById</code> methods. As soon as your HTML structure starts getting complex, this usually means that you would have to combine these methods in an awkward and cumbersome iteration code.</p><p>Code written in this fashion usually makes a lot of assumptions about the structure of your HTML, which means that it will usually break if the HTML changes.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>The $ function</h2></div></div></div><p>With <a id="id151" class="indexterm"/>jQuery, a lot of this imperative style code becomes much simpler with the <code class="literal">$</code> function—jQuery's factory method (a method that creates instances of jQuery classes) and the entry point into most of the library.</p><p>This function usually takes a CSS selector string as an argument, which can be used to select one or multiple elements according to their element name, ID, class attribute, or other attribute values. This method will return a jQuery object that contains one or more elements that matches the selector.</p><p>Here, we'll select all the <code class="literal">input</code> tags in a document with a class of <code class="literal">address</code>, using the <code class="literal">$</code> function:</p><div><pre class="programlisting">$('input .address')</pre></div><p>You can then manipulate or interrogate these elements using a multitude of functions, often called <strong>commands</strong>. The following are just a few of the common jQuery commands and what they are used for:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">addClass</code>: This adds a CSS class to an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">removeClass</code>: This removes a CSS class from an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">attr</code>: This gets a attribute from an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">hasClass</code>: This checks for the existence of a CSS class on an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">html</code>: This gets or sets the HTML text of an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">val</code>: This gets or sets the element value</li><li class="listitem" style="list-style-type: disc"><code class="literal">show</code>: This displays an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">hide</code>: This hides an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">parent</code>: This gets the parent of an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">appendTo</code>: This appends a child element</li><li class="listitem" style="list-style-type: disc"><code class="literal">fadeIn</code>: This fades in an element</li><li class="listitem" style="list-style-type: disc"><code class="literal">fadeout</code>: This fades out an element</li></ul></div><p>Most of the commands return a jQuery object that can be used to chain other commands onto them. By chaining commands, you can use the output of one command as the input of the next. This powerful technique lets you write very short and succinct transformations on parts of the HTML document.</p><p>Let's say that we want to highlight and enable all the <code class="literal">address</code> inputs in an HTML form; jQuery allows us to do something similar to this:</p><div><pre class="programlisting">$('input .address').addClass('highlighted').removeAttr('disabled')</pre></div><p>Here, we once again select all the <code class="literal">input</code> tags with an <code class="literal">address</code> class. We add the <code class="literal">highlighted</code> class to each using the <code class="literal">addClass</code> command, and then remove the <code class="literal">disabled</code> attribute by chaining a call to the <code class="literal">removeAttr</code> command.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Utility functions</h1></div></div></div><p>jQuery also<a id="id152" class="indexterm"/> comes with a host of utility functions that generally improves your day-to-day JavaScript programming experience. These are all in the form of methods on the global jQuery object like this: <code class="literal">$.methodName</code>. For instance, one of the most widely used utilities is the <code class="literal">each</code> method, that can be used to iterate over arrays or objects, and would be called as follows (in CoffeeScript):</p><div><pre class="programlisting">$.each [1, 2, 3, 4], (index, value) -&gt; alert(index + ' is ' + value)</pre></div><p> jQuery's utility methods range from array and collection helper methods, time and string manipulation, as well as a host of other useful JavaScript and browser related functions. A lot of these functions stem from the everyday needs of a lot of JavaScript programmers.</p><p>Often, you'll find a function that applies to a common problem or pattern you face yourself when writing JavaScript or CoffeeScript. You can find a detailed list of the functions at <a class="ulink" href="http://api.jquery.com/category/utilities/">http://api.jquery.com/category/utilities/</a>.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec33"/>Ajax methods</h1></div></div></div><p>jQuery <a id="id153" class="indexterm"/>provides the <code class="literal">$.ajax</code> method to perform Ajax requests that work across browsers. Traditionally, this has been a pain to do, since browsers all implemented different interfaces for handling Ajax. jQuery takes care of all of that and provides a simpler, callback-based way of constructing and executing Ajax requests. This means that you can declaratively specify how the Ajax call should be made and then provide functions that jQuery will call back when the request succeeds or fails.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec34"/>Using jQuery</h1></div></div></div><p>Using<a id="id154" class="indexterm"/> jQuery in the browser is very simple; you just need to include the jQuery library in your HTML file. You can either download the latest version of jQuery from their site (<a class="ulink" href="http://docs.jquery.com/Downloading_jQuery">http://docs.jquery.com/Downloading_jQuery</a>) and reference that, or you can directly link to a <strong>Content Delivery Network</strong> (<strong>CDN</strong>)<a id="id155" class="indexterm"/> version of the library.</p><p>Following is an example of how you might do it. This snippet comes from the excellent HTML5 Boilerplate project (<a class="ulink" href="http://html5boilerplate.com/">http://html5boilerplate.com/</a>). Here we include the latest minified jQuery from a Google CDN, but we will also include a local version if including from the CDN fails.</p><div><pre class="programlisting">&lt;script src="img/jquery.min.js"&gt;&lt;/script&gt;
    &lt;script&gt;window.jQuery || document.write('&lt;script src="img/jquery-1.7.2.min.js"&gt;&lt;\/script&gt;')
&lt;/script&gt;</pre></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec35"/>Using CoffeeScript and jQuery in the browser</h1></div></div></div><p>Before we <a id="id156" class="indexterm"/>can <a id="id157" class="indexterm"/>start playing with jQuery and CoffeeScript, let's talk about how you go about writing CoffeeScript code that runs in the browser.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Compiling CoffeeScript</h2></div></div></div><p>The most <a id="id158" class="indexterm"/>common way of compiling CoffeeScript for a web application is to run the <code class="literal">coffee</code> command to watch one or more CoffeeScript files for changes and then to compile them to JavaScript. The output will then be included in your web application.</p><p>As an example, we'll organize our project folder structure to look something like the following folder structure:</p><div><img src="img/9588_03_01.jpg" alt="Compiling CoffeeScript"/></div><p>'</p><p>The <strong>src</strong> folder is <a id="id159" class="indexterm"/>where your CoffeeScript files would go. We could then start a CoffeeScript compiler to watch that folder and compile the JavaScript to our <strong>public/js</strong> folder.</p><p>This is what the CoffeeScript command would look like:</p><div><pre class="programlisting">coffee -co public/js -w src/</pre></div><p>Keep this command running in the background in its own terminal window and it will recompile your CoffeeScript files when you save them.</p><div><div><h3 class="title"><a id="tip05"/>Tip</h3><p><strong>CoffeeScript tags</strong></p><p>Another way of running CoffeeScript in the browser is to include CoffeeScript inline in the document enclosed in the <code class="literal">&lt;script type="text/coffeescript"&gt;</code> tag and then to include the minified CoffeeScript compiler script (<code class="literal">coffee-script.js</code>) in your document. This will compile, and then run all the inline CoffeeScript in the page.</p><p>This isn't meant for serious use, since you will pay a serious performance penalty for the compiling step each time the page is loaded. However, it can be quite useful from time to time to just quickly play around with some CoffeeScript in the browser without setting up a complete compiler chain.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>jQuery and CoffeeScript</h2></div></div></div><p>Let's put something in <a id="id160" class="indexterm"/>our CoffeeScript file to see if we can successfully hook it up with jQuery. In the <code class="literal">src</code> folder, create a file named <code class="literal">app.coffee</code> and include the following code:</p><div><pre class="programlisting">$ -&gt; alert "It works!"</pre></div><p>This sets up the jQuery's <code class="literal">$(document).ready()</code> function<a id="id161" class="indexterm"/> that will be called when the application is initialized. Here we are using the shorthand syntax for it, by just passing an anonymous function to the <code class="literal">$</code> function.</p><p>You should now have an <code class="literal">app.js</code> file in the <code class="literal">public/js</code> folder with content similar to this:</p><div><pre class="programlisting">// Generated by CoffeeScript 1.3.3
(function() {
    alert('It works!');
}).call(this);</pre></div><p>Lastly, we need to include<a id="id162" class="indexterm"/> this file as well as the jQuery in our application's HTML file. In the <code class="literal">public/index.html</code> file, add the following code:</p><div><pre class="programlisting">&lt;!doctype html&gt;
&lt;html lang="en"&gt;
&lt;head&gt;
  &lt;meta charset="utf-8"&gt;
  &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt;
  &lt;title&gt;jQuery and CoffeeScript Todo&lt;/title&gt;
  &lt;link rel="stylesheet" href="css/styles.css"&gt;
&lt;/head&gt;
&lt;body&gt;
  &lt;script src="img/jquery.min.js"&gt;&lt;/script&gt;
  &lt;script src="img/app.js"&gt;&lt;/script&gt;
&lt;/body&gt;
&lt;/html&gt;</pre></div><p>The preceding code creates our HTML skeleton, and includes jQuery (using the Google CDN) as well as our application code.</p><div><div><h3 class="title"><a id="tip06"/>Tip</h3><p><strong>Downloading the example code</strong></p><p>You can download the example code files for all Packt books you have purchased from your account at <a class="ulink" href="http://www.PacktPub.com">http://www.PacktPub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.PacktPub.com/">http://www.PacktPub.com/</a> support and register to have the files e-mailed directly to you.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec38"/>Testing it all</h2></div></div></div><p>We should <a id="id163" class="indexterm"/>now be able to run our application by opening our <code class="literal">index.html</code> file in a browser. If all went well, we should see our alert pop-up window, as shown in the following screenshot:</p><div><img src="img/9588_03_02.jpg" alt="Testing it all"/></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec39"/>Running a local web server</h2></div></div></div><p>While we <a id="id164" class="indexterm"/>can easily test our web application from the disk for now, we might want to host it on a local web server soon, especially if we wanted to start doing Ajax. Since we already have Node.js installed, it should be really easy to run a web server, for which we only need to serve static content for now. Luckily, there is an npm package that will do just that for us; it is named <strong>http-server</strong>
<a id="id165" class="indexterm"/>
<strong> </strong>and can be found at <a class="ulink" href="https://github.com/nodeapps/http-server">https://github.com/nodeapps/http-server</a>.</p><p>To install it, just run the following command:</p><div><pre class="programlisting">npm install http-server -g</pre></div><p>And then, we execute it by navigating to our application folder and entering this:</p><div><pre class="programlisting">http-server</pre></div><p>This will host all the files in the public folder on port <strong>8080</strong>. We should now be able to navigate to our hosted site by using the URL <code class="literal">http://localhost:8080/</code>.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec36"/>Our application</h1></div></div></div><p>In the rest of this chapter, we will be building a jQuery application using CoffeeScript. The application is a to-do list app, which can be used to keep track of your daily tasks and how you completed them.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec40"/>TodoMVC</h2></div></div></div><p>I have <a id="id166" class="indexterm"/>modeled a lot of the application on some of the TodoMVC project's <a id="id167" class="indexterm"/>source code, which is in the public domain. This project is a showcase of different JavaScript MVC frameworks all used to build the same application, and can be very useful when evaluating frameworks. If you wanted to check it out, it can be found at <a class="ulink" href="http://addyosmani.github.com/todomvc/">http://addyosmani.github.com/todomvc/</a>.</p><div><div><h3 class="title"><a id="note06"/>Note</h3><p><strong>MVC</strong>
<a id="id168" class="indexterm"/>, or Model–view–controller, is a widely used application architecture pattern that aims to simplify code and reduce coupling by splitting application concerns into three domain object types. We'll talk about MVC a bit more later on in the book.</p></div></div><p>We will mostly base our application on the TodoMVC project to get the awesome-looking stylesheets that come with it as well as a well-designed HTML5 structure. However, most of the client-side JavaScript will be rewritten in CoffeeScript and it will be simplified and modified quite a lot for illustration purposes.</p><p>So without further ado, let's get to it!</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec41"/>Our initial HTML</h2></div></div></div><p>First, we'll <a id="id169" class="indexterm"/>add some HTML that will allow us to enter to-do items and view a list of existing items. In <code class="literal">index.html</code>, add the following code to the <code class="literal">body</code> tag, right before the included <code class="literal">script</code> tags:</p><div><pre class="programlisting">&lt;section id="todoapp"&gt;
    &lt;header id="header"&gt;
      &lt;h1&gt;todos&lt;/h1&gt;
      &lt;input id="new-todo" placeholder="What needs to be done?" autofocus&gt;
    &lt;/header&gt;
    &lt;section id="main"&gt;
      &lt;ul id="todo-list"&gt;&lt;/ul&gt;
    &lt;/section&gt;
    &lt;footer id="footer"&gt;
      &lt;button id="clear-completed"&gt;Clear completed&lt;/button&gt;
    &lt;/footer&gt;
  &lt;/section&gt; </pre></div><p>Let's briefly walk through the structure of the preceding markup. First, we have a section with the <code class="literal">todoapp</code> ID, that will serve as the main part of the app. It consists of a <code class="literal">header</code> tag, which will house our input for creating new items, a <code class="literal">main</code> section, which will list all our to-do items, and a <code class="literal">footer</code> section that will have the <strong>Clear completed</strong> button. Before we open this page in the browser, let's remove the previous alert line from our <code class="literal">app.coffee</code> file.</p><p>When you navigate to this page, it won't look like much. That is because our HTML hasn't been styled at all. Download the <code class="literal">styles.css</code> file for this chapter and copy it to the <code class="literal">public/css</code> folder. It should now look much better.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec42"/>Initializing our app</h2></div></div></div><p>Most jQuery apps,<a id="id170" class="indexterm"/> including ours, follow a similar pattern. We create a <code class="literal">$(document).ready</code> handler which in turn performs page initialization, usually including hooking up event handlers for user actions. Let's do this in our <code class="literal">app.coffee</code> file.</p><div><pre class="programlisting">class TodoApp
  constructor: -&gt;
    @bindEvents()

  bindEvents: -&gt;
    alert 'binding events'

  
$ -&gt;
  app = new TodoApp()</pre></div><p>Here, in the previous code snippet, we create a class called <code class="literal">TodoApp</code>
<a id="id171" class="indexterm"/> that will represent our application. It has a constructor that calls the <code class="literal">bindEvents</code> method<a id="id172" class="indexterm"/>, which for now just displays an alert message.</p><p>We set up jQuery's <code class="literal">$(document).ready</code> event handler<a id="id173" class="indexterm"/> to create an instance of our <code class="literal">TodoApp</code>. When you reload the page, you should see the <strong>binding events</strong> alert pop-up window.</p><div><div><h3 class="title"><a id="tip07"/>Tip</h3><p><strong>Not seeing the expected output?</strong></p><p>Remember to keep an eye on the output of the coffee compiler running in the background. If you have made any syntax errors, then the compiler will spit out an error message. Once you have fixed it, the compiler should recompile your new JavaScript file. Remember that CoffeeScript is whitespace sensitive. If you come across any errors that you don't understand, check your indentation carefully.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec43"/>Adding a to-do item</h2></div></div></div><p>Now we can<a id="id174" class="indexterm"/> add the event handling to actually add a to-do item to the list. In our <code class="literal">bindEvents</code> function, we'll select the <code class="literal">new-todo</code> input <a id="id175" class="indexterm"/>and handle its <code class="literal">keyup</code> event<a id="id176" class="indexterm"/>. We bind that to call the <code class="literal">create</code> method<a id="id177" class="indexterm"/> on our class, which we'll also go and define; this is shown in the following code snippet:</p><div><pre class="programlisting">  bindEvents: -&gt;
    $('#new-todo').on('keyup', @create)
 
  create: (e) -&gt;
    $input = $(this)
    val = ($.trim $input.val())
    return unless e.which == 13 and val
    alert val
    # We create the todo item</pre></div><p>The <code class="literal">$('#new-todo')</code> function uses the jQuery CSS selector syntax to get the input with the <code class="literal">new-todo</code> ID, the <code class="literal">on</code> method binds the <code class="literal">create</code> method to its <code class="literal">'keyup'</code> event, which fires whenever a key is pressed while the input has focus.</p><p>In the <code class="literal">create</code> function, we can get a reference to the input by using the <code class="literal">$(this)</code> function, which will always return the element that generated the event. We assign this to the <code class="literal">$input</code> variable. Using variable names that are prefixed with <code class="literal">$</code> is a common convention when assigning jQuery variables. We can then get the value of the input using the <code class="literal">val()</code> function<a id="id178" class="indexterm"/> and assign it a local <code class="literal">val</code> variable.</p><p>We can see if the <em>Enter</em> key was pressed by checking if the <code class="literal">which</code> property of the <code class="literal">keyup</code> event is equal to <code class="literal">13</code>. If so, and if the <code class="literal">val</code> variable is not <code class="literal">null</code>, we can go ahead and create the to-do item. For now, we'll just output its value using an alert message.</p><p>Once we create the item, where shall we put it? In lots of traditional web apps, this data will typically be stored on the server using an Ajax request. We would like to keep this app simple for now and just keep these items around on the client side for now. The HTML5 specification defines a mechanism for us called <strong>localStorage</strong>, to do just that.</p><div><div><div><div><h3 class="title"><a id="ch03lvl3sec03"/>Using localStorage</h3></div></div></div><p><code class="literal">localStorage</code> is<a id="id179" class="indexterm"/> part of the new HTML5 specification and allows you to store and retrieve objects in a local database that lives in the browser. The interface is quite simple; in supported <a id="id180" class="indexterm"/>browsers a global variable named <code class="literal">localStorage</code> will be present. This variable has the following three important methods:</p><div><pre class="programlisting">localStorage.setItem(key, value)
localStorage.getItem(key)
localStorage.removeItem(key)</pre></div><p>Both the <code class="literal">key</code> and <code class="literal">value</code> parameters are strings. Strings stored in the <code class="literal">localStorage</code> variable hang around even <a id="id181" class="indexterm"/>when the page is refreshed. You can store up to 5 MB in the <code class="literal">localStorage</code> variable in most browsers.</p><p>Because we want to store the to-do items as a complex object rather than a string, we use the commonly used technique of converting to and from a JSON object when setting and getting items from <code class="literal">localStorage</code>. To do so, we'll add two methods to the prototype of the <code class="literal">Storage</code> class, which will then be available on the global <code class="literal">localStorage</code> object. Add the following code snippet to the top of our <code class="literal">app.coffee</code> file:</p><div><pre class="programlisting">Storage::setObj = (key, obj) -&gt;
  @setItem key, JSON.stringify(obj)

Storage::getObj = (key) -&gt;
  JSON.parse @getItem(key)</pre></div><p>Here, we use the <code class="literal">::</code> operator to add the <code class="literal">setObj</code> and <code class="literal">getObj</code> methods to the <code class="literal">Storage</code> class. These functions wrap the <code class="literal">localStorage</code> object's <code class="literal">getItem</code> and <code class="literal">setItem</code> methods by converting the object to and from JSON.</p><p>We are now finally ready to create our to-do item and store it in <code class="literal">localStorage</code>.</p><p>Here is the rest of our <code class="literal">create</code> method:</p><div><pre class="programlisting">  create: (e)-&gt;
    $input = $(this)
    val = ($.trim $input.val())
    return unless e.which == 13 and val
    
<strong>    randomId = (Math.floor Math.random()*999999)</strong>

<strong>    localStorage.setObj randomId,{</strong>
<strong>      id: randomId</strong>
<strong>      title: val</strong>
<strong>      completed: false</strong>
<strong>    }</strong>
<strong>    $input.val ''</strong>
</pre></div><p>In order for us to uniquely identify tasks, we'll use the simplest thing we can, and just generate a big random number to use as an ID. This is not the most sophisticated way of identifying documents and you should probably not use this in a production setting. However, it's quite simple to implement, and serves our purposes well for now.</p><p>After generating the ID, we can now put the to-do item in our local database using our <code class="literal">setObj</code> method. We pass in a title that we got from the <code class="literal">input</code> tag value, and default the item to not completed.</p><p>Lastly, we clear the value of <code class="literal">$input</code> to give the user visual input that <code class="literal">create</code> was successful.</p><p>We should now be able <a id="id182" class="indexterm"/>to test our little app and see if the to-do items do get stored into <code class="literal">localStorage</code>. The Google Chrome Developer Tools will allow you to inspect <code class="literal">localStorage</code> in the <strong>Resources</strong> tab. After adding a couple of tasks, you should be able to see them here, as shown in the following screenshot:</p><div><img src="img/9588_03_03.jpg" alt="Using localStorage"/></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec44"/>Displaying the to-do items</h2></div></div></div><p>Now <a id="id183" class="indexterm"/>that we<a id="id184" class="indexterm"/> can store a list of to-do items, it would be nice if we could see them on screen. To do so, we will add a <code class="literal">displayItems</code> method<a id="id185" class="indexterm"/>. This will iterate through the local list of to-do items and display them.</p><p>Add the following code to our <code class="literal">TodoApp</code>, after the <code class="literal">create</code> method:</p><div><pre class="programlisting">displayItems: -&gt;
    alert 'displaying items'</pre></div><p>Now we should be able <a id="id186" class="indexterm"/>to call this method from the <code class="literal">create</code> method, as highlighted in the following code:</p><div><pre class="programlisting">  create: (e) -&gt;
    $input = $(this)
    val = ($.trim $input.val())
    return unless e.which == 13 and val
    
    randomId = (Math.floor Math.random()*999999)

    localStorage.setObj randomId,{
      id: randomId
      title: val
      completed: false
    }
    $input.val ''
<strong>    @displayItems()</strong>
</pre></div><p>Let's run this code to see what happens. When we do, we get the following error:</p><p><strong>Uncaught TypeError: Object #&lt;HTMLInputElement&gt; has no method 'displayItems'</strong></p><p>So what's <a id="id187" class="indexterm"/>happening here? It seems that the call to <code class="literal">@displayItems()</code>
<a id="id188" class="indexterm"/> is trying to call the method on an instance of <code class="literal">HTMLInputElement</code> instead of <code class="literal">TodoApp</code>.</p><p>This happens because jQuery will set the value of <code class="literal">this</code> to reference the element that raised the event. When we bind a class method as an event handler, jQuery will in essence "highjack" <code class="literal">this</code> to not point to the class itself. It is an important caveat that you should know of when working with jQuery and classes in CoffeeScript.</p><p>To fix it, we can use the CoffeeScript fat arrow when we set up the <code class="literal">keyup</code> event handler, which will ensure that the value of <code class="literal">this</code> remains intact. Let's modify our <code class="literal">bindEvents</code> method<a id="id189" class="indexterm"/> to look similar to the following code:</p><div><pre class="programlisting">  bindEvents: -&gt;
<strong>    $('#new-todo').on('keyup',(e) =&gt; @create(e))</strong>
</pre></div><p>There is just one more thing though; in our <code class="literal">createItem</code> method<a id="id190" class="indexterm"/>, we used <code class="literal">$(this)</code> to get the value of the <code class="literal">input</code> element that raised the event. Since switching to the fat arrow, this will now be pointing to our <code class="literal">TodoApp</code> instance. Luckily, the event argument that gets passed in has a target property that also points to our input. Change the first line of the <code class="literal">create</code> method similar to the following code snippet:</p><div><pre class="programlisting">  create: (e) -&gt;
<strong>    $input = $(e.target)</strong>
    val = ($.trim $input.val())</pre></div><p>Now when we create an item, we should see the "displaying items" alert, meaning the <code class="literal">displayItems</code> method has been hooked up correctly.</p><p>We can do one better. <a id="id191" class="indexterm"/>Since the <code class="literal">$input</code> tag will need to be looked up every time the <code class="literal">create</code> method is fired, we can just store it in a class variable so that it can be re-used.</p><p>The best place for this <a id="id192" class="indexterm"/>would be right when the app starts up. Let's create a <code class="literal">cacheElements</code> method<a id="id193" class="indexterm"/> that does just that, and gets called in the constructor—this is highlighted in the following code:</p><div><pre class="programlisting">class TodoApp
    
  constructor: -&gt;
<strong>    @cacheElements()</strong>
    @bindEvents()

<strong>  cacheElements: -&gt;</strong>
<strong>    @$input = $('#new-todo')</strong>

  bindEvents: -&gt;
<strong>    @$input.on('keyup',(e) =&gt; @create(e))</strong>
 
  create: (e) -&gt;
<strong>    val = ($.trim @$input.val())</strong>
    return unless e.which == 13 and val
    
    randomId = (Math.floor Math.random()*999999)

    localStorage.setObj randomId,{
      id: randomId
      title: val
        completed: false
    }
<strong>    @$input.val ''</strong>
 @displayItems()</pre></div><p>The <code class="literal">cacheElements</code> call assigns a class variable called <code class="literal">@$input</code>
<a id="id194" class="indexterm"/>, which is then used throughout our class. This <code class="literal">@$</code> syntax might look strange at first, but it does convey a lot of information in a few keystrokes.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec45"/>Showing the to-do items</h2></div></div></div><p>We should now be <a id="id195" class="indexterm"/>able to show the items. In the <code class="literal">displayItems</code> method, we'll iterate through all the <code class="literal">localStorage</code> keys and use them to get each corresponding to-do item. For each item we'll add a <code class="literal">li</code> child element to the <code class="literal">ul</code> element <a id="id196" class="indexterm"/>with the <code class="literal">todo-list</code> ID. Before we start working with the <code class="literal">$('#todo-list')</code> element, let's cache its value like we did with <code class="literal">@$input</code>:</p><div><pre class="programlisting">  cacheElements: -&gt;
    @$input = $('#new-todo')
<strong>    @$todoList = $('#todo-list')</strong>
  displayItems: -&gt;
<strong>    @clearItems()</strong>
<strong>    @addItem(localStorage.getObj(id)) for id in Object.keys(localStorage)</strong>

<strong>  clearItems: -&gt;</strong>
<strong>    @$todoList.empty()</strong>

<strong>  addItem: (item) -&gt;</strong>
<strong>    html = """</strong>
<strong>      &lt;li #{if item.completed then 'class="completed"' else ''} data-id="#{item.id}"&gt;</strong>
<strong>        &lt;div class="view"&gt;</strong>
<strong>          &lt;input class="toggle" type="checkbox" #{if item.completed then 'checked' else ''}&gt;</strong>
<strong>          &lt;label&gt;#{item.title}&lt;/label&gt;</strong>
<strong>          &lt;button class="destroy"&gt;&lt;/button&gt;</strong>
<strong>        &lt;/div&gt;</strong>
<strong>     &lt;/li&gt; </strong>
<strong>    """</strong>
<strong>    @$todoList.append(html)</strong>
</pre></div><p>Here, we have modified the <code class="literal">displayItems</code> method a bit. First, we remove any existing child list items from <code class="literal">$@todoList</code>, then we loop through each key in <code class="literal">localStorage</code>, get the object with that key, and send that item to the <code class="literal">addItem</code> method<a id="id197" class="indexterm"/>.</p><p>The <code class="literal">addItem</code> method builds an HTML string representation of a to-do item and then uses jQuery's <code class="literal">append</code> function to append a child element to <code class="literal">$@todoList</code>
<a id="id198" class="indexterm"/>. Together with a label for the title, <a id="id199" class="indexterm"/>we also create a checkbox to set the task as completed and a button to remove the task.</p><p>Notice the <code class="literal">data-id</code> attribute<a id="id200" class="indexterm"/> on the <code class="literal">li</code> element. This is an HTML5 data attribute, which lets you add arbitrary data attributes to any element. We will use this to link each <code class="literal">li</code> to its to-do item in the <code class="literal">localStorage</code> object.</p><div><div><h3 class="title"><a id="note07"/>Note</h3><p>Although CoffeeScript can make building HTML strings like these a bit easier, it can quickly become cumbersome to define markup within your client-side code. We have done so here mostly for illustration purposes; it's probably better to use a JavaScript templating library, such as Handlebars (<a class="ulink" href="http://handlebarsjs.com/">http://handlebarsjs.com/</a>).</p><p>These types of libraries allow you define templates within your markup and then compile them with a specific context, which then gives you a nicely formatted HTML that you can then append to the elements.</p></div></div><p>One last thing, now that we can display items after one is created, let's add the <code class="literal">displayItems</code> call to the constructor, so that we can display existing to-do items; this call is highlighted in the following code:</p><div><pre class="programlisting">  constructor: -&gt;
    @cacheElements()
    @bindEvents()
<strong>    @displayItems()</strong>
</pre></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec46"/>Removing and completing items </h2></div></div></div><p>Let's hook up the <a id="id201" class="indexterm"/>remove task button. We add an event handler for it follows:</p><div><pre class="programlisting">  bindEvents: -&gt;
    @$input.on('keyup',(e) =&gt; @create(e))
<strong>    @$todoList.on('click', '.destroy', (e) =&gt; @destroy(e.target)) </strong>
</pre></div><p>Here, we handle click events on any child element on <code class="literal">@$todoList</code> with a <code class="literal">.destroy</code> class.</p><p>We once again <a id="id202" class="indexterm"/>create the handler with the fat arrow, calling a <code class="literal">@destroy</code> method and passing in the target, which should be the <strong>destroy</strong> button that was clicked.</p><p>We now need to create the <code class="literal">@destroy</code> method using the following code snippet:</p><div><pre class="programlisting">  destroy: (elem) -&gt;
    id = $(elem).closest('li').data('id')
    localStorage.removeItem(id)
    @displayItems()</pre></div><p>The <code class="literal">closest</code> function<a id="id203" class="indexterm"/> will find the <code class="literal">li</code> element that is defined nearest to the button itself. We use jQuery's <code class="literal">data</code> function to retrieve its <code class="literal">data-id</code> attribute, which we can then use to remove the to-do item from <code class="literal">localStorage</code>. One more call is made to <code class="literal">@displayItems</code>
<a id="id204" class="indexterm"/> to refresh the view.</p><p>Completing <a id="id205" class="indexterm"/>an <a id="id206" class="indexterm"/>item will follow a very similar pattern; that is, we add an event handler, which is highlighted in the following code:</p><div><pre class="programlisting">  bindEvents: -&gt;
    @$input.on('keyup',(e) =&gt; @create(e))
    @$todoList.on('click', '.destroy', (e) =&gt; @destroy(e.target))
<strong>    @$todoList.on('change', '.toggle', (e) =&gt; @toggle(e.target))</strong>
</pre></div><p>This time we handle the <code class="literal">'change'</code> event, which will fire whenever a completed checkbox is checked or unchecked. This in turn will call the <code class="literal">@toggle</code> method, which is coded as follows:</p><div><pre class="programlisting">  toggle: (elem) -&gt;
    id = $(elem).closest('li').data('id')
    item = localStorage.getObj(id)
    item.completed = !item.completed
    localStorage.setObj(id, item)</pre></div><p>This method also <a id="id207" class="indexterm"/>uses the <code class="literal">closest</code> function to get the ID of the to-do item. It loads up the object from <code class="literal">localStorage</code>, toggles the value of <code class="literal">completed</code>, and then saves it back to <code class="literal">localStorage</code> using the <code class="literal">setObj</code> method.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec47"/>Now, it's your turn!</h2></div></div></div><p>As a final exercise for you, I will ask you to make the <strong>Clear completed</strong> button work.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec37"/>Summary</h1></div></div></div><p>In this chapter, we learned what jQuery is, and what its strengths and benefits are. We also learned how to combine the powerful features of jQuery with CoffeeScript to write complex web applications with much less effort and complexity. jQuery is a very large library and we have just scratched the surface of what it has to offer. I urge you to spend some more time learning the library itself, and to do so using CoffeeScript.</p><p>Next up, we'll start by having a look at how you would start interacting with sever-side code using CoffeeScript and Rails.</p></div></body></html>