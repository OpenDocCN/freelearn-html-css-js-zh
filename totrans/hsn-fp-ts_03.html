<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Mastering Asynchronous Programming</h1>
                </header>
            
            <article>
                
<p><span>In the previous chapter, we learned how to work with functions. In this chapter, we will explore how we can use functions, together with some native APIs, to write asynchronous TypeScript code. We will </span>focus on TypeScript's asynchronous programming capabilities, including the following concepts:</p>
<ul>
<li>Callbacks and higher-order functions</li>
<li>Arrow functions</li>
<li>Callback hell</li>
<li>Promises</li>
<li>Generators</li>
<li>Asynchronous functions (<kbd>async</kbd> and <kbd>await</kbd>)</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Callbacks and higher-order functions</h1>
                </header>
            
            <article>
                
<p>In TypeScript, functions can be passed as arguments to another function. Functions can also be returned by another function. A function passed to another as an argument is known as a <strong>callback</strong>. A function that accepts functions as parameters (callbacks) or returns functions is known as a <strong>higher-order function</strong>.</p>
<p>Callback are usually anonymous functions. They can be declared before they are passed to the higher-order function, as demonstrated by the following example:</p>
<pre>var myCallback = function() { // callback<br/>  console.log("foo");<br/>}<br/><br/>function bar(cb: () =&gt; void) { // higher order function<br/>  console.log("bar");<br/>  cb();<br/>}<br/><br/>bar(myCallback); // prints "bar" then prints "foo"</pre>
<p>Callbacks can also be declared inline, at the same point in which they are passed to a higher-order function, as demonstrated by the following example:</p>
<pre>bar(() =&gt; {<br/>  console.log("foo");<br/>}); // prints "bar" then prints "foo"</pre>
<p>The preceding code snippet declares an anonymous function and passes it to a function named <kbd>bar</kbd>. The <span>anonymous function has been declared using an alternative syntax known as an arrow function. We will learn more about arrow functions in the next section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Arrow functions</h1>
                </header>
            
            <article>
                
<p>In TypeScript, we can declare a function using a function expression or an arrow function. An arrow function expression has a shorter syntax than a function expression and lexically binds the value of the <kbd>this</kbd> operator.</p>
<p>The <kbd>this</kbd> operator behaves a little differently in TypeScript and JavaScript compared to other popular programming languages. When we define a class in TypeScript, we can use the <kbd>this</kbd> operator to refer to the class. Let's look at an example:</p>
<pre>class Person {<br/>    private _name: string;<br/>    constructor(name: string) {<br/>        this._name = name;<br/>    }<br/>    public greet() {<br/>        console.log('Hi! My name is ${this._name}');<br/>    }<br/>}<br/><br/>let person = new Person("Remo");<br/>person.greet(); // "Hi! My name is Remo"</pre>
<p>We have defined a class named <kbd>Person</kbd> that contains a property of the <kbd>string</kbd> <span>type </span>called <kbd>name</kbd>. The class has a constructor and a method named <kbd>greet</kbd>. We have created an instance named <kbd>person</kbd> and invoked the <kbd>greet</kbd> method, which internally uses the <kbd>this</kbd> operator to access the <kbd>_name</kbd> <span>property. </span>Inside the <kbd>greet</kbd> method, the <kbd>this</kbd> operator points to the object that encloses the <kbd>greet</kbd> method (the class instance).</p>
<p>We must be careful when using the <kbd>this</kbd> operator because, in some scenarios, it can point to the wrong value. Let's add an extra method to the previous example:</p>
<pre>class Person {<br/>    private _name: string;<br/>    constructor(name: string) {<br/>        this._name = name;<br/>    }<br/><br/>    public greet() {<br/>        alert('Hi! My name is ${this._name}');<br/>    }<br/><br/>    public greetDelay(time: number) {<br/>        setTimeout(function() {<br/>            alert('Hi! My name is ${this._name}'); // Error<br/>        }, time);<br/>    }<br/><br/>}<br/><br/>let person = new Person("Remo");<br/>person.greetDelay(1000); // Error</pre>
<p>In the <kbd>greetDelay</kbd> method, we perform an almost identical operation to the one performed by the <kbd>greet</kbd> method. This time, the function takes a parameter named <kbd>time</kbd>, which is used to delay the <kbd>greet</kbd> message.</p>
<p>To delay a message, we use the <kbd>setTimeout</kbd> function and a callback. As soon as we define an anonymous function (the callback), the <kbd>this</kbd> keyword changes its value and starts pointing to the anonymous function, which explains why the TypeScript compiler will throw an error.</p>
<p>As mentioned, an arrow function expression lexically binds the value of the <kbd>this</kbd> operator. This means that it allows us to add a function without altering the value of this operator. Let's replace the function expression from the previous example with an arrow function:</p>
<pre>class Person {<br/><br/>    private _name: string;<br/><br/>    constructor(name: string) {<br/>        this._name = name;<br/>    }<br/><br/>    public greet() {<br/>        alert('Hi! My name is ${this._name}');<br/>    }<br/><br/>    public greetDelay(time: number) {<br/>        setTimeout(() =&gt; {<br/>            alert('Hi! My name is ${this._name}'); // OK<br/>        }, time);<br/>    }<br/><br/>}<br/><br/>let person = new Person("Remo");<br/>person.greet(); // "Hi! My name is Remo"<br/>person.greetDelay(1000); // "Hi! My name is Remo"</pre>
<p>By using an arrow function, we can ensure that the <kbd>this</kbd> operator still points to the <kbd>Person</kbd> instance and not to the <kbd>setTimeout</kbd> callback. If we execute the <kbd>greetDelay</kbd> function, the name property will be displayed as expected.</p>
<p>The following piece of code is generated by the TypeScript compiler. When compiling an arrow function, the TypeScript compiler will generate an alias for the <kbd>this</kbd> operator named <kbd>_this</kbd>. The alias is used to ensure that the <kbd>this</kbd> operator points to the correct object:</p>
<pre>Person.prototype.greetDelay = function (time) {<br/>  var _this = this;<br/>  setTimeout(function () {<br/>    alert("Hi! My name is " + _this._name);<br/>  }, time);<br/>};</pre>
<div class="packt_infobox">
<p>We will look in depth at the <kbd>this</kbd> operator in <a href="0ea0b1ad-d206-4b3a-9520-b08365a988d7.xhtml" target="_blank">Chapter 4</a>, <em>The Runtime – The Event Loop and</em> the this O<em>perator</em>.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Callback hell</h1>
                </header>
            
            <article>
                
<p>We have learned that callbacks and higher-order functions are two powerful and flexible JavaScript and TypeScript features. However, the use of callbacks can lead to a maintainability issue known as callback hell.</p>
<p>We are now going to write an example to showcase callback hell. We are going to write three functions with the same behavior.</p>
<p>The first function is named <kbd>doSomethingAsync</kbd>. The function takes an array of numbers as one of its arguments and adds a new number to it. The function uses <kbd>setTimeout</kbd> to simulate some I/O operation, such as reading from a database, and <kbd>Math.ramdom</kbd> to simulate a potential exception, such as a request timeout:</p>
<pre>function doSomethingAsync(<br/>    arr: number[],<br/>    success: (arr: number[]) =&gt; void,<br/>    error: (e: Error) =&gt; void<br/>) {<br/>    setTimeout(() =&gt; {<br/>        try {<br/>            let n = Math.ceil(Math.random() * 100 + 1);<br/>            if (n &lt; 25) {<br/>                throw new Error("n is &lt; 25");<br/>            }<br/>            success([...arr, n]);<br/>        } catch (e) {<br/>            error(e);<br/>        }<br/>    }, 1000);<br/>}</pre>
<p>The second function is named<span> </span><kbd>doSomethingElseAsync</kbd><span>, and the third and final function is named <kbd>doSomethingMoreAsync</kbd>. We are going to skip the implementation of these two functions in the following code snippet because both functions have the exact same implementation that we used in the <kbd>doSomethingAsync</kbd> function:</span></p>
<pre>function doSomethingElseAsync(<br/>    arr: number[],<br/>    success: (arr: number[]) =&gt; void,<br/>    error: (e: Error) =&gt; void<br/>) {<br/>    // ... Same implementation here...<br/>}<br/><br/>function doSomethingMoreAsync(<br/>    arr: number[],<br/>    success: (arr: number[]) =&gt; void,<br/>    error: (e: Error) =&gt; void<br/>) {<br/>    // Same imlementation here...<br/>}</pre>
<p>The preceding functions simulate an asynchronous operation by using the <kbd>setTimeout</kbd> function. Each function takes a <kbd>success</kbd> callback, which is invoked if the operation is successful, and an <kbd>error</kbd> callback, which is invoked if something goes wrong.</p>
<p>In real-world applications, asynchronous operations usually involve some interaction with hardware (for example, the filesystem, network…). These interactions are known as <strong>input</strong>/<strong>output</strong> (<strong>I</strong>/<strong>O</strong>) operations. I/O operations can fail for many different reasons; for example, we get an error when we try to interact with the filesystem to save a new file and there is not enough space available in the hard disk.</p>
<p>The preceding functions generate a random number and throw an error if the number is lower than <kbd>25</kbd>; we do this to simulate potential I/O errors. They then add the random number to an array that is <span>passed</span> as an argument to each of the functions. If no errors take place, the result of the final function (<kbd>doSomethingMoreAsync</kbd>) should be an array with three random numbers.</p>
<p>Now that the three functions have been declared, we can try to invoke them in order. We are going to use callbacks to ensure that <kbd>doSomethingMoreAsync</kbd> is invoked after <kbd>doSomethingElseAsync</kbd>, and that <kbd>doSomethingElseAsync</kbd> is invoked after <kbd>doSomethingAsync</kbd>:</p>
<pre>doSomethingAsync([], (arr1) =&gt; {<br/>    doSomethingElseAsync(arr1, (arr2) =&gt; {<br/>        doSomethingMoreAsync(arr2, (arr3) =&gt; {<br/>            console.log(<br/>                '<br/>                doSomethingAsync: ${arr3[0]}<br/>                doSomethingElseAsync: ${arr3[1]}<br/>                doSomethingMoreAsync: ${arr3[2]}<br/>                '<br/>            );<br/>        }, (e) =&gt; console.log(e));<br/>    }, (e) =&gt; console.log(e));<br/>}, (e) =&gt; console.log(e));</pre>
<p>The preceding example used a few nesting callbacks. These kinds of nested callbacks are known as callback hell because they can lead to some maintainability issues, as follows:</p>
<ul>
<li>They make the code harder to follow and understand</li>
<li>They make the code harder to maintain (refactor, reuse, and so on)</li>
<li>They make exception handling more difficult</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Promises</h1>
                </header>
            
            <article>
                
<p>After seeing how the use of callbacks can lead to some maintainability problems, we are now going to learn about promises and how they can be used to write better asynchronous code. The core idea behind promises is that a promise represents the result of an asynchronous operation. A promise must be in one of the following three states:</p>
<ul>
<li><strong>Pending</strong>: The initial state of a promise.</li>
<li><strong>Fulfilled</strong>: Also known as resolved, this the state of a promise representing a successful operation. The terms <em>fulfilled</em> and <em>resolved</em> are both commonly used to refer to this state.</li>
<li><strong>Rejected</strong>: The state of a promise representing a failed operation.</li>
</ul>
<p>Once a promise is fulfilled or rejected, its state can never change again. Let's look at the basic syntax of a promise:</p>
<pre>function foo() {<br/>    return new Promise&lt;string&gt;((fulfill, reject) =&gt; {<br/>        try {<br/>            // do something<br/>            fulfill("SomeValue");<br/>        } catch (e) {<br/>            reject(e);<br/>        }<br/>    });<br/>}<br/><br/>foo().then((value) =&gt; {<br/>    console.log(value);<br/>}).catch((e) =&gt; {<br/>    console.log(e);<br/>});</pre>
<div class="packt_infobox">
<p>Please note that a <kbd>try…catch</kbd> statement is used here to showcase how we can explicitly fulfill or reject a promise. The <kbd>try…catch</kbd> statement is not needed for a <kbd>Promise</kbd> function because, when an error is thrown within a promise, the promise will automatically be rejected.</p>
</div>
<p>The preceding code snippet declares a function named <kbd>foo</kbd> that returns a promise. The promise contains a method named <kbd>then</kbd>, which accepts a callback function as an argument. The callback function is invoked when the promise is fulfilled. Promises also provide a method named <kbd>catch</kbd>, which is invoked when a promise is rejected.</p>
<div class="packt_infobox">
<p>Promises will not be recognized by the TypeScript compiler if we are targeting ES5 because the <kbd>Promise</kbd> API is part of ES6. We can solve this by enabling the <kbd>es2015.promise</kbd> type using the <kbd>lib</kbd> option in the <kbd>tsconfig.json</kbd> file. Note that enabling this option will disable some types that are included by default and thereby break some examples. You will be able to resolve the problems by including the <kbd>dom</kbd> and <kbd>es5</kbd> types as well by using the lib option in the <kbd>tsconfig.json</kbd> file:</p>
<pre>"lib": [<br/>     "es2015.promise",<br/>     "dom",<br/>     "es5",<br/>     "es2015.generator", // new<br/>     "es2015.iterable" // new<br/> ]</pre></div>
<p>We are now going to rewrite the <kbd>doSomethingAsync</kbd>, <kbd>doSomethingElseAsync</kbd>, and <kbd>doSomethingMoreAsync</kbd> <span>functions,</span> which we wrote in the <em>Callback hell</em> section, but this time, we are going to use promises instead of callbacks:</p>
<pre>function doSomethingAsync(arr: number[]) {<br/>    return new Promise&lt;number[]&gt;((resolve, reject) =&gt; {<br/>        setTimeout(() =&gt; {<br/>            try {<br/>                let n = Math.ceil(Math.random() * 100 + 1);<br/>                if (n &lt; 25) {<br/>                    throw new Error("n is &lt; 25");<br/>                }<br/>                resolve([...arr, n]);<br/>            } catch (e) {<br/>                reject(e);<br/>            }<br/>        }, 1000);<br/>    });<br/>}</pre>
<p>Once again, we are going to skip the implementation details of the <kbd>doSomethingElseAsync</kbd> and <kbd>doSomethingMoreAsync</kbd> functions because they should be identical to the implementation of the <kbd>doSomethingAsync</kbd> function:</p>
<pre>function doSomethingElseAsync(arr: number[]) {<br/>    // Same implementation here...<br/>}<br/><br/>function doSomethingMoreAsync(arr: number[]) {<br/>    // Same implementation here...<br/>}</pre>
<p>We can chain the promises returned by each of the preceding functions using the <kbd>Promise</kbd> API:</p>
<pre>doSomethingAsync([]).then((arr1) =&gt; {<br/>    doSomethingElseAsync(arr1).then((arr2) =&gt; {<br/>        doSomethingMoreAsync(arr2).then((arr3) =&gt; {<br/>            console.log(<br/>                '<br/>                doSomethingAsync: ${arr3[0]}<br/>                doSomethingElseAsync: ${arr3[1]}<br/>                doSomethingMoreAsync: ${arr3[2]}<br/>                '<br/>            );<br/>        });<br/>    });<br/>}).catch((e) =&gt; console.log(e));</pre>
<p>The preceding code snippet is a little better than the one used in the callback example, because we only needed to declare one instead of three exception handlers. This is possible because errors are propagated through the chain of promises. However, we can improve the code even more because the <kbd>Promise</kbd> API allows us to chain promises in a much less verbose manner:</p>
<pre>doSomethingAsync([])<br/>    .then(doSomethingElseAsync)<br/>    .then(doSomethingMoreAsync)<br/>    .then((arr3) =&gt; {<br/>        console.log(<br/>            '<br/>            doSomethingAsync: ${arr3[0]}<br/>            doSomethingElseAsync: ${arr3[1]}<br/>            doSomethingMoreAsync: ${arr3[2]}<br/>            '<br/>        );<br/>    }).catch((e) =&gt; console.log(e));</pre>
<p>The preceding code is much easier to read and follow than the one used during the callback examples, but this is not the only reason to favor promises over callbacks. Using promises also gives us better control over the execution flow of operations. Let's look at a couple of examples.</p>
<p>The <kbd>Promise</kbd> API includes a method named <kbd>all</kbd>, which allows us to execute a series of promises in parallel and get all the results of each of the promises at once:</p>
<pre>Promise.all([<br/>    new Promise&lt;number&gt;((resolve) =&gt; {<br/>        setTimeout(() =&gt; resolve(1), 1000);<br/>    }),<br/>    new Promise&lt;number&gt;((resolve) =&gt; {<br/>        setTimeout(() =&gt; resolve(2), 1000);<br/>    }),<br/>    new Promise&lt;number&gt;((resolve) =&gt; {<br/>        setTimeout(() =&gt; resolve(3), 1000);<br/>    })<br/>]).then((values) =&gt; {<br/>    console.log(values); // [ 1 ,2, 3]<br/>});</pre>
<p>The <kbd>Promise</kbd> API also includes a method named <kbd>race</kbd>, which allows us to execute a series of promises in parallel and obtain the result of the first promise resolved:</p>
<pre>Promise.race([<br/>    new Promise&lt;number&gt;((resolve) =&gt; {<br/>        setTimeout(() =&gt; resolve(1), 3000);<br/>    }),<br/>    new Promise&lt;number&gt;((resolve) =&gt; {<br/>        setTimeout(() =&gt; resolve(2), 2000);<br/>    }),<br/>    new Promise&lt;number&gt;((resolve) =&gt; {<br/>        setTimeout(() =&gt; resolve(3), 1000);<br/>    })<br/>]).then((fastest) =&gt; {<br/>    console.log(fastest); // 3<br/>});</pre>
<p>We can use many different types of asynchronous flow control when working with promises:</p>
<ul>
<li><strong>Concurrent</strong>: The tasks are executed in parallel (as in the <kbd>Promise.all</kbd> example)</li>
<li><strong>Race</strong>: The tasks are executed in parallel, and only the result of the fastest promise is returned</li>
<li><strong>Series</strong>: A group of tasks is executed in sequence, but the preceding tasks do not pass arguments to the next task</li>
<li><strong>Waterfall</strong>: A group of tasks is executed in sequence, and each task passes arguments to the next task (as in the example)</li>
<li><strong>Composite</strong>: This is any combination of the previous concurrent, series, and waterfall approaches</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Covariant checking in callback parameters</h1>
                </header>
            
            <article>
                
<p>TypeScript 2.4 changed the way the type system behaves internally to improve error detection in nested callbacks and promises:</p>
<ul>
<li>TypeScript's checking of callback parameters is now covariant in relation to immediate signature checks. Previously, it was bivariant and occasionally allowed incorrect types through.</li>
<li>Basically, this means that callback parameters and classes that contain callbacks are checked more carefully, so Typescript will require stricter types in this release. This is particularly true of promises and observables due to the way in which their APIs are specified.</li>
</ul>
<p>In TypeScript versions before 2.4, the following example was considered valid, and no errors were thrown:</p>
<pre>declare function someFunc(<br/>    callback: (<br/>    nestedCallback: (error: number, result: any) =&gt; void<br/>    ) =&gt; void<br/>): void;<br/><br/>someFunc(<br/>    (<br/>        nestedCallback: (e: number) =&gt; void // Error<br/>    ) =&gt; {<br/>        nestedCallback(1);<br/>    }<br/>);</pre>
<p>In TypeScript versions following the 2.4 release, we will need to add the complete signature of <kbd>nestedCallback</kbd> to resolve this error:</p>
<pre>someFunc(<br/>    (<br/>        nestedCallback: (e: number, result: any) =&gt; void // OK<br/>    ) =&gt; {<br/>        nestedCallback(1, 1);<br/>    }<br/>);</pre>
<p>Thanks to the internal change in the TypeScript type system, the following error is also detected:</p>
<pre>let p: Promise&lt;number&gt; = new Promise((res, rej) =&gt; {<br/>    res("error"); // Error<br/>});</pre>
<p>Before TypeScript 2.4, the preceding promise would have been inferred as <kbd>Promise&lt;{}&gt;</kbd> because we forgot to add the generic argument, <kbd>&lt;number&gt;</kbd>, when we created an instance of the <kbd>Promise</kbd> class. The string error would then have been considered a valid instance of <kbd>{}</kbd>.</p>
<div class="packt_tip">The preceding is a clear example of why it is recommended you upgrade TypeScript regularly. Each new version of TypeScript introduces new features able to detect new errors for us.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Generators</h1>
                </header>
            
            <article>
                
<p>If we invoke a function in TypeScript, we can assume that, once the function starts running, it will always run to completion before any other code can run. However, one type of function known as a <strong>generator</strong> can may be paused in the middle of execution—once or many times—and resumed later, allowing other code to run during these paused periods.</p>
<p>A generator represents a sequence of values. The interface of a generator object is just an <strong>iterator</strong>. An iterator implements the following interface:</p>
<pre>interface Iterator&lt;T&gt; {<br/>  next(value?: any): IteratorResult&lt;T&gt;;<br/>  return?(value?: any): IteratorResult&lt;T&gt;;<br/>  throw?(e?: any): IteratorResult&lt;T&gt;;<br/>}</pre>
<p>The <kbd>next</kbd> function can be invoked until it runs out of values. We can define a generator by using the <kbd>function</kbd> keyword, followed by an asterisk, (<kbd>*</kbd>). The <kbd>yield</kbd> keyword is used to stop the execution of the function and return a value. Let's look at an example:</p>
<pre>function *foo() {<br/>    yield 1;<br/>    yield 2;<br/>    yield 3;<br/>    yield 4;<br/>    return 5;<br/>}<br/><br/>let bar = foo();<br/>bar.next(); // Object {value: 1, done: false}<br/>bar.next(); // Object {value: 2, done: false}<br/>bar.next(); // Object {value: 3, done: false}<br/>bar.next(); // Object {value: 4, done: false}<br/>bar.next(); // Object {value: 5, done: true}<br/>bar.next(); // Object { done: true }</pre>
<div class="packt_infobox">
<p>Note that some additional types are required by generators if you are targeting ES5. You will need to add <kbd>es2015.generator</kbd> and <kbd>es2015.iterable</kbd>, and enable <span><kbd>downlevelIteration</kbd></span><span> to your</span> <kbd>tsconfig.json</kbd> <span>file:</span></p>
<pre>"lib": [<br/>     "es2015.promise",<br/>     "dom",<br/>     "es5",<br/>     "es2015.generator", // new<br/>     "es2015.iterable" // new<br/> ]</pre></div>
<p>As we can see, the preceding iterator has five steps. The first time we call the <kbd>next</kbd> method, the function will be executed until it reaches the first <kbd>yield</kbd> statement, and then it will return the value <kbd>1</kbd> and stop the execution of the function until we invoke the generator's <kbd>next</kbd> method again. As we can see, we are now able to stop the function's execution at a given point. This allows us to write infinite loops without causing a stack overflow exception, as demonstrated in the following example:</p>
<pre>function* foo() {<br/>    let i = 1;<br/>    while (true) { // Infinite loop!<br/>        yield i++;<br/>    }<br/>}<br/><br/>let bar = foo();<br/>bar.next(); // Object {value: 1, done: false}<br/>bar.next(); // Object {value: 2, done: false}<br/>bar.next(); // Object {value: 3, done: false}<br/>bar.next(); // Object {value: 4, done: false}<br/>bar.next(); // Object {value: 5, done: false}<br/>bar.next(); // Object {value: 6, done: false}<br/>bar.next(); // Object {value: 7, done: false}</pre>
<p>The generator's API opens up possibilities with reference to synchronicity, as we can call the generator's <kbd>next</kbd> method after an asynchronous event has occurred.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous functions – async and await</h1>
                </header>
            
            <article>
                
<p>Asynchronous functions are a TypeScript feature that arrived with the TypeScript 1.6 release. Developers can use the <kbd>await</kbd> keyword to wait for an asynchronous operation to be completed without blocking the normal execution of the program.</p>
<p>Using asynchronous functions helps to increase the readability of a piece of code when compared with the use of promises or callbacks but, technically, we can achieve the same features using both promises and asynchronous functions.</p>
<p>Let's take a look at a basic <kbd>async</kbd>/<kbd>await</kbd> example:</p>
<pre>let p = Promise.resolve(3);<br/><br/>async function fn(): Promise&lt;number&gt; {<br/>    var i = await p; // 3<br/>    return 1 + i; // 4<br/>}<br/><br/>fn().then((r) =&gt; console.log(r)); // 4</pre>
<p>The preceding code snippet declares a promise named <kbd>p</kbd>. This promise represents a future result. As we can see, the <kbd>fn</kbd> function is preceded by the <kbd>async</kbd> keyword, which is used to indicate to the compiler that it is an asynchronous function.</p>
<p>Inside the function, the <kbd>await</kbd> keyword is used to suspend execution until the promise <kbd>p</kbd> is fulfilled or rejected. As we can see, the syntax is less verbose and cleaner than it would have been had we used the <kbd>Promise</kbd> API or callbacks.</p>
<p>An asynchronous function, such as <kbd>fn</kbd>, returns a promise at runtime. This should explain why we need to use the <kbd>then</kbd> method at the end of the code snippet.</p>
<p>The following code snippet showcases how we can declare an asynchronous function named <kbd>invokeTaskAsync</kbd>. The asynchronous function uses the <kbd>await</kbd> keyword to wait for the result of the <kbd>doSomethingAsync</kbd>, <kbd>doSomethingElseAsync</kbd>, and <kbd>doSomethingMoreAsync</kbd> functions that we declared during the promises example:</p>
<pre>async function invokeTaskAsync() {<br/>    let arr1 = await doSomethingAsync([]);<br/>    let arr2 = await doSomethingElseAsync(arr1);<br/>    return await doSomethingMoreAsync(arr2);<br/>}</pre>
<p>The <kbd>invokeTaskAsync</kbd> function is asynchronous. Therefore, it will return a promise at runtime. This means that we can use the <kbd>Promise</kbd> API to await a result or catch potential errors respectively:</p>
<pre>invokeTaskAsync().then((result) =&gt; {<br/>    console.log(<br/>        '<br/>        doSomethingAsync: ${result[0]}<br/>        doSomethingElseAsync: ${result[1]}<br/>        doSomethingMoreAsync: ${result[2]}<br/>        '<br/>    );<br/>}).catch((e) =&gt; {<br/>    console.log(e);<br/>});</pre>
<p>We can also define asynchronous IIFE as a convenient way to use the <kbd>async</kbd> and <kbd>await</kbd> keywords:</p>
<pre>(async () =&gt; {<br/>    try {<br/>        let arr1 = await doSomethingAsync([]);<br/>        let arr2 = await doSomethingElseAsync(arr1);<br/>        let arr3 = await doSomethingMoreAsync(arr2);<br/>        console.log(<br/>            '<br/>            doSomethingAsync: ${arr3[0]}<br/>            doSomethingElseAsync: ${arr3[1]}<br/>            doSomethingMoreAsync: ${arr3[2]}<br/>            '<br/>        );<br/>    } catch (e) {<br/>        console.log(e);<br/>    }<br/>})();</pre>
<p>Using an <kbd>async</kbd> IIFE is very useful because it is very common to not be able to use the <kbd>await</kbd> keyword outside a function, for example, in the entry point of an application. We can use the <kbd>async</kbd> IIFE to overcome this limitation:</p>
<pre>(async () =&gt; {<br/>    await someAsyncFunction();<br/>})();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous generators</h1>
                </header>
            
            <article>
                
<p>We have already learned about the interface implemented by all iterators:</p>
<pre>interface Iterator&lt;T&gt; {<br/>  next(value?: any): IteratorResult&lt;T&gt;;<br/>  return?(value?: any): IteratorResult&lt;T&gt;;<br/>  throw?(e?: any): IteratorResult&lt;T&gt;;<br/>}</pre>
<p>However, we haven't learned yet about the interface implemented by all asynchronous iterators:</p>
<pre>interface AsyncIterator&lt;T&gt; {<br/>  next(value?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;;<br/>  return?(value?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;;<br/>  throw?(e?: any): Promise&lt;IteratorResult&lt;T&gt;&gt;;<br/>}</pre>
<p>An asynchronous iterator returns a promise every time we invoke the <kbd>next</kbd> method. The following code snippet demonstrates how asynchronous iterators can be very useful when used in conjunction with asynchronous functions:</p>
<pre>let counter = 0;<br/><br/>function doSomethingAsync() {<br/>    return new Promise&lt;number&gt;((r) =&gt; {<br/>        setTimeout(() =&gt; {<br/>            counter += 1;<br/>            r(counter);<br/>        }, 1000);<br/>    });<br/>}<br/><br/>async function* g1() {<br/>    yield await doSomethingAsync();<br/>    yield await doSomethingAsync();<br/>    yield await doSomethingAsync();<br/>}<br/><br/>let i: AsyncIterableIterator&lt;number&gt; = g1();<br/>i.next().then((n) =&gt; console.log(n)); // 1<br/>i.next().then((n) =&gt; console.log(n)); // 2<br/>i.next().then((n) =&gt; console.log(n)); // 3</pre>
<div class="packt_infobox">
<p>Some additional types are required by asynchronous iterators if we are targeting ES5. You will need to add <kbd>esnext.asynciterable</kbd> <span>and enable </span><span><kbd>downlevelIteration</kbd></span><span> in</span> your <kbd>tsconfig.json</kbd> file. We are also going to need to enable an additional setting in our <kbd>tsconfig.json</kbd> to provide full support for iterables in <kbd>for-of</kbd>, spread, and destructuring when targeting ES5 or ES3:</p>
<pre>"lib": [<br/>     "es2015.promise",<br/>     "dom",<br/>     "es5",<br/>     "es2015.generator",<br/>     "es2015.iterable",<br/>     "esnext.asynciterable" // new<br/> ]</pre></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Asynchronous iteration (for await…of)</h1>
                </header>
            
            <article>
                
<p>We can use the new <kbd>await…of</kbd> expression to iterate and await each of the promises returned by an asynchronous iterator:</p>
<pre>function* g1() {<br/>    yield 2;<br/>    yield 3;<br/>    yield 4;<br/>}<br/><br/>async function func() {<br/>    for await (const x of g1()) {<br/>        console.log(x);<br/>    }<br/>}<br/><br/>(async () =&gt; {<br/>    await func();<br/>})();</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Delegating to another generator (yield*)</h1>
                </header>
            
            <article>
                
<p>We can use the <kbd>yield*</kbd> expression to delegate from one generator to another. The following code snippet defines two generator functions, named <kbd>g1</kbd> and <kbd>g2</kbd>. The <kbd>g2</kbd> generator uses the <kbd>yield*</kbd> expression to delegate the iteration to the iterator created by <kbd>g1</kbd>:</p>
<pre>function* g1() {<br/>    yield 2;<br/>    yield 3;<br/>    yield 4;<br/>}<br/><br/>function* g2() {<br/>    yield 1;<br/>    yield* g1();<br/>    yield 5;<br/>}<br/><br/>var iterator1 = g2();<br/><br/>console.log(iterator1.next()); // {value: 1, done: false}<br/>console.log(iterator1.next()); // {value: 2, done: false}<br/>console.log(iterator1.next()); // {value: 3, done: false}<br/>console.log(iterator1.next()); // {value: 4, done: false}<br/>console.log(iterator1.next()); // {value: 5, done: false}<br/>console.log(iterator1.next()); // {value: undefined, done: true}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>yield*</kbd> expression can also be used to delegate the iteration to some <em>iterables</em>, such as arrays:</p>
<pre>function* g2() {<br/>    yield 1;<br/>    yield* [2, 3, 4];<br/>    yield 5;<br/>}<br/><br/>var iterator = g2();<br/><br/>console.log(iterator.next()); // {value: 1, done: false}<br/>console.log(iterator.next()); // {value: 2, done: false}<br/>console.log(iterator.next()); // {value: 3, done: false}<br/>console.log(iterator.next()); // {value: 4, done: false}<br/>console.log(iterator.next()); // {value: 5, done: false}<br/>console.log(iterator.next()); // {value: undefined, done: true}</pre>
<div class="packt_infobox">Please note that the preceding example requires a number of particular settings in the <kbd>tsconfig.json</kbd> file. Please refer to the preceding notes in this chapter to learn more about the required settings.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we have focused on the use of callbacks, promises, and generators to take advantage of the asynchronous programming capabilities of TypeScript. In the next chapter, we will look at the runtime to understand how the event loop and the <kbd>this</kbd> operator work. These concepts will help us to understand some of the implementations of functional programming techniques that we will explore later in this book.</p>


            </article>

            
        </section>
    </body></html>