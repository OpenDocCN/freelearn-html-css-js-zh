<html><head></head><body>
<div id="page" style="height:0pt"/><div class="book" title="Chapter&#xA0;9.&#xA0;Automate Your Testing with Node.js"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09" class="calibre1"/>Chapter 9. Automate Your Testing with Node.js</h1></div></div></div><p class="calibre7">In the previous chapter, we learned how to work with Grunt and Gulp to automate our development process. These two Node.js modules have a huge collection of plugins, which we can use in almost every case. In this chapter, we will talk about testing, its importance, and how to integrate it in our workflow. The following is a list of topics that we will cover:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Popular testing methodologies</li><li class="listitem">The Jasmine framework</li><li class="listitem">The Mocha framework</li><li class="listitem">Testing with PhantomJS and DalekJS</li></ul></div></div>

<div class="book" title="Chapter&#xA0;9.&#xA0;Automate Your Testing with Node.js">
<div class="book" title="Understanding the importance of writing tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_1"><a id="ch09lvl1sec60" class="calibre1"/>Understanding the importance of writing tests</h1></div></div></div><p class="calibre7">When developing software, the <a id="id426" class="calibre1"/>code we write can be put in the browser, run as a desktop program, or started as a Node.js script. In all these cases, we expect specific results. Every line of code has some significance, and we need to know whether the final product will do the job. Normally, we debug our applications, that is, we write part of the program and run it. By monitoring the output or its behavior, we assess whether everything is okay or whether there is a problem. However, this approach is time-consuming, especially if the project is big. Iterations through every single feature of the application costs a lot of time and money. Automated testing helps in such cases. From an architectural viewpoint, testing is very important. That's because when the system is complex and we have numerous relationships between the modules, it is difficult to add new features or introduce major changes. </p><p class="calibre7">We can't really guarantee that everything will work as it worked before the modifications. So, instead of relying on manual testing, it is much better to create scripts that can do this for us. Writing tests has several major benefits, as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">This proves that our <a id="id427" class="calibre1"/>software is stable and works as expected.</li><li class="listitem">This saves a lot of time because we don't have to repeatedly perform manual testing.</li><li class="listitem">A badly written code with a lot of dependencies cannot be tested easily. Writing tests in most of these cases leads to better code.</li><li class="listitem">If we have a solid test suite, we can extend the system without worrying about damaging something.</li><li class="listitem">If the tests cover all the application's features, then they can be used as the application's documentation.</li></ul></div></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Choosing a testing methodology"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec61" class="calibre1"/>Choosing a testing methodology</h1></div></div></div><p class="calibre7">There are few popular<a id="id428" class="calibre1"/> ways of writing tests. Let's see which are they and the differences between them.</p></div>

<div class="book" title="Choosing a testing methodology">
<div class="book" title="Test-driven development"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec59" class="calibre1"/>Test-driven development</h2></div></div></div><p class="calibre7">
<span class="strong"><strong class="calibre8">Test-driven development</strong></span> (<span class="strong"><strong class="calibre8">TDD</strong></span>)<a id="id429" class="calibre1"/> is a process that relies on the repetition of <a id="id430" class="calibre1"/>short development cycles. In other words, we write our test while writing the implementation. The shorter the cycles, the better. The following diagram shows the TDD flow:</p><div class="mediaobject"><img src="../images/00038.jpeg" alt="Test-driven development" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Before we write the actual code that does the job for us, we need to prepare a test. Of course, after the first run, the test will fail because nothing has been implemented. So, we need to ensure that the test passes all the cycles. Once this happens, we may spend some time refactoring what has been done so far and continue with the next method, class, or feature. Note that everything spins around the test, which is a really good thing because this is where we define what our code should do. With this as a basis, we avoid delivering unnecessary code. We can also be sure that the implementation meets the requirements.</p></div></div>

<div class="book" title="Choosing a testing methodology">
<div class="book" title="Behavior-driven development"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec60" class="calibre1"/>Behavior-driven development</h2></div></div></div><p class="calibre7">
<span class="strong"><strong class="calibre8">Behavior-driven development</strong></span> (<span class="strong"><strong class="calibre8">BDD</strong></span>)<a id="id431" class="calibre1"/> is similar to TDD. In <a id="id432" class="calibre1"/>fact, if the project is a small one, we can't really spot the differences. The idea of this approach is to focus more on the specification and the application's processes, rather than the actual code. For example, if we test a module that posts messages on Twitter with TDD, we will probably ask the following questions:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Is the message empty?</li><li class="listitem">Is the message length less than 140 symbols?</li><li class="listitem">Is the Ajax request made properly?</li><li class="listitem">Does the returned JSON contain certain fields?</li></ul></div><p class="calibre7">However with BDD, we ask only the following question:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Is the message sent to Twitter?</li></ul></div><p class="calibre7">Both processes are interrelated and, as we said, sometimes there is no difference at all. What we should remember is that BDD focuses on what the code is doing and TDD on how the code is doing it.</p></div></div>
<div class="book" title="Classifying tests"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec62" class="calibre1"/>Classifying tests</h1></div></div></div><p class="calibre7">There are several types of tests <a id="id433" class="calibre1"/>that you may write, which evaluate our system by giving an input and expecting a specific output. However, they also perform this evaluation on different parts. It is good to know their names, which are listed as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Unit testing</strong></span>: Unit testing <a id="id434" class="calibre1"/>performs checks on a single part of the <a id="id435" class="calibre1"/>application; it focuses on one unit. Often, we face difficulties in writing such tests because we can't split our code into units; this is usually a bad sign. If there is no clearly defined module, we can't proceed with such tests. Distributing the logic to different units not only helps in testing but also contributes to the overall stability of the program. Let's illustrate the problem with the following diagram:<div class="mediaobject"><img src="../images/00039.jpeg" alt="Classifying tests" class="calibre10"/></div><p class="calibre15"> </p><p class="calibre16">Let's assume we have an e-commerce site that sells products to our users. In the preceding diagram, processes such as log in, ordering, and logout are handled by one class, defined in the <code class="email">App.js</code> file. Yes, it works. We<a id="id436" class="calibre1"/> may achieve the goal and successfully <a id="id437" class="calibre1"/>close the circle, but this is absolutely not unit testable because there are no units. It is much better if we split the responsibilities into different classes, as shown in the following diagram:</p><div class="mediaobject"><img src="../images/00040.jpeg" alt="Classifying tests" class="calibre10"/></div><p class="calibre15"> </p><p class="calibre16">We continue to use <code class="email">App.js</code> and it still controls everything. However, the different parts of the whole flow are divided between three classes: <code class="email">Router</code>, <code class="email">Users</code>, and <code class="email">Payments</code>. Now, we are able to write unit tests.</p></li><li class="listitem"><span class="strong"><strong class="calibre8">Integration testing</strong></span>: Integration tests<a id="id438" class="calibre1"/> output a result for several<a id="id439" class="calibre1"/> units or components. If we look at the preceding example, the integration test will simulate the whole process of ordering a product, that is, logging in, buying, and logging out. Normally, integration tests use several modules of the system and ensure that the modules work properly together.</li><li class="listitem"><span class="strong"><strong class="calibre8">Functional testing</strong></span>: The <a id="id440" class="calibre1"/>functional tests are closely related to <a id="id441" class="calibre1"/>integration tests and focus on a specific functionality in the system. It may involve several modules or components.</li><li class="listitem"><span class="strong"><strong class="calibre8">System testing</strong></span>: The <a id="id442" class="calibre1"/>system tests test our program in different <a id="id443" class="calibre1"/>environments. In the context of Node.js, this could be when running our scripts on different operating systems and monitoring the output. Sometimes there are differences and if we want to globally distribute our work, we need to ensure that our program is compatible with the most popular systems.</li><li class="listitem"><span class="strong"><strong class="calibre8">Stress or performance testing</strong></span>: These <a id="id444" class="calibre1"/>tests evaluate our application<a id="id445" class="calibre1"/> beyond the defined specifications and show<a id="id446" class="calibre1"/> how our code reacts to heavy traffic or <a id="id447" class="calibre1"/>complex queries. They are really helpful when making a decision about the program's architecture or choosing a framework.</li></ul></div><p class="calibre7">There are some other types of testing, but the previously mentioned testing methods are the most popular. There is no strict policy on what tests to write. Of course, there are good practices, but what we should focus on is writing a testable code. There is nothing better than an application fully covered with tests.</p><p class="calibre7">As testing is a really important part of the development process, there are frameworks specifically oriented toward writing tests. In general, when we use a framework, we need the following two tools:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><span class="strong"><strong class="calibre8">Test runner</strong></span>: This is <a id="id448" class="calibre1"/>the part of the framework that runs our tests and displays messages whether they pass or fail.</li><li class="listitem"><span class="strong"><strong class="calibre8">Assertions</strong></span>: These methods <a id="id449" class="calibre1"/>are used for the actual checks, that is, if we need to see whether an variable is <code class="email">true</code>, then we can write <code class="email">expect(active).toBe(true)</code> instead of just <code class="email">if(active === true)</code>. It's better for the reader and also prevents some strange situations; for example, if we want to see whether a variable is defined or not, the <code class="email">if</code> statement in the following code returns <code class="email">true</code> because the <code class="email">status</code> variable has a value and this value is <code class="email">null</code>. In fact, we are asking whether the <code class="email">status</code> variable initialized, and if we leave the test in this manner, we will get wrong results. That's why we need an assertion library that has proper methods for testing. The following code is the example that shows that the <code class="email">status</code> variable is actually defined and its type is <code class="email">object</code>:<div class="informalexample"><pre class="programlisting">var status = null;
if(typeof status != "undefined") {
    console.log("status is defined");
} else {
    console.log("status is not defined");
}</pre></div></li></ul></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Using Jasmine"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec63" class="calibre1"/>Using Jasmine</h1></div></div></div><p class="calibre7">Jasmine<a id="id450" class="calibre1"/> is a framework to test the JavaScript code. It is available as a Node.js module and also as a library, which we can use in the browser. It comes with its own assertion methods.</p></div>

<div class="book" title="Using Jasmine">
<div class="book" title="Installing Jasmine"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec61" class="calibre1"/>Installing Jasmine</h2></div></div></div><p class="calibre7">We are going to<a id="id451" class="calibre1"/> use the <a id="id452" class="calibre1"/>Node.js version of the framework. It's a module, so it can be installed via the Node.js package manager, <code class="email">npm</code>, as shown in the following code line:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm install jasmine-node -g</strong></span>
</pre></div><p class="calibre7">The preceding command will set up Jasmine globally, so we can run <code class="email">jasmine-node</code> in every directory of our choice. The tests could be organized into different files placed in one folder or in subfolders. The only requirement is to end the filenames with <code class="email">spec.js</code>, for example, <code class="email">testing-payments.spec.js</code> or <code class="email">testing-authorization.spec.js</code>.</p></div></div>

<div class="book" title="Using Jasmine">
<div class="book" title="Defining the module for testing"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec62" class="calibre1"/>Defining the module for testing</h2></div></div></div><p class="calibre7">Before we write the <a id="id453" class="calibre1"/>actual test, let's define the application we want to build. Let's say we need a Node.js module that reads a file and finds specific words inside it. The following is the basic file structure that we are starting from:</p><div class="mediaobject"><img src="../images/00041.jpeg" alt="Defining the module for testing" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The code that tests the application will be placed in <code class="email">tests/test.spec.js</code>, the implementation of the logic will be in <code class="email">app.js</code>, and the file that we will read from will be <code class="email">file.txt</code>. Let's open the<code class="email"> file.txt</code> file and add the following text inside:</p><div class="informalexample"><pre class="programlisting">The quick brown fox jumps over the lazy dog.</pre></div><p class="calibre7">That's a phrase used to test typewriter's keys. It contains all the letters from the English alphabet and is perfect for our small project.</p></div></div>

<div class="book" title="Using Jasmine">
<div class="book" title="Following the test-driven development concept"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec63" class="calibre1"/>Following the test-driven development concept</h2></div></div></div><p class="calibre7">The task is<a id="id454" class="calibre1"/> simple and we can probably solve it in around 20 lines of code. For sure, we can wrap all the code in one function and perform everything there. The downside is that if something goes wrong, we can't detect where the problem occurs. That's why we will split the logic into two parts and test them separately in the following ways: </p><div class="book"><ul class="itemizedlist"><li class="listitem">Reading the file's content</li><li class="listitem">Searching for a certain word inside the file's content</li></ul></div><p class="calibre7">As we explained in the beginning of this chapter, we will write the test first, we will see it fail, and then will write the code for <code class="email">app.js</code>.</p></div></div>

<div class="book" title="Using Jasmine">
<div class="book" title="Testing the file-reading process"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_4"><a id="ch09lvl2sec64" class="calibre1"/>Testing the file-reading process</h2></div></div></div><p class="calibre7">Writing tests, just<a id="id455" class="calibre1"/> like any other task, can be challenging. Sometimes, we can't determine what to test and what to exclude. There is a certain unsaid rule that advices users to avoid working on features that are tested by other developers—in our example, we need not test whether the file is read successfully. If we do that, it will look like we are testing the filesystem API of Node.js, which is not necessary.</p><p class="calibre7">Every test written with Jasmine starts with the <code class="email">describe</code> clause. Add the following code to <code class="email">tests/test.spec.js</code>:</p><div class="informalexample"><pre class="programlisting">describe("Testing the reading of the file's content.", function() {
  // ...
});</pre></div><p class="calibre7">The <code class="email">describe</code> method<a id="id456" class="calibre1"/> accepts a description and a function. In the body of this function, we will add our assertions. Keep in mind that the text that we add needs to be informative because it will be displayed if the test fails. Similar to the <code class="email">describe</code> block, we have to add the <code class="email">it</code> blocks. These blocks contain the actual commands for testing, as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">describe("Testing the reading of the file's content.", function() {
  it("should create an instance of app.js", function(done) {
    var app = require("../app.js");
    expect(app).toBeDefined();
    done();
  });
});</pre></div><p class="calibre7">We are adding meaningful information that tells what exactly we are going to test. The second argument of <code class="email">it</code> is again a function. The difference is that it accepts an argument, which is another function. We need to call it once we are done with the checks. Many scripts in JavaScript are asynchronous, and the <code class="email">done</code> callback helps us in handling such operations.</p><p class="calibre7">The preceding code block includes the <code class="email">app.js</code> module and verifies the result. The <code class="email">expect</code> method accepts a subject of the assertion, and the following chained methods perform the actual check.</p><p class="calibre7">We have a test ready, so we can execute it. Run <code class="email">jasmine-node ./tests</code> and you will see the following result:</p><div class="mediaobject"><img src="../images/00042.jpeg" alt="Testing the file-reading process" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The test case passes. The <code class="email">app.js</code> file is empty, but <a id="id457" class="calibre1"/>even then Node.js doesn't fail. The value of the <code class="email">app</code> variable is actually an empty object. Let's continue and try to imagine the methods that we will need. In the following code we are adding one more block testing a <code class="email">read</code> API method of the module:</p><div class="informalexample"><pre class="programlisting">describe("Testing the reading of the file's content.", function() {
  it("should create an instance of app.js", function(done) {
    var app = require("../app.js");
    expect(app).toBeDefined();
    done();
  });
  it("should read the file", function(done) {
    var app = require("../app.js");
    var content = app.read("./file.txt");
    expect(content).toBe("The quick brown fox jumps over the lazy dog.");
    done();
  });
});</pre></div><p class="calibre7">The first <code class="email">it</code> runs well but the second one raises an error. That's because there is nothing in <code class="email">app.js</code>. We don't have a <code class="email">read</code> method there. The error is shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00043.jpeg" alt="Testing the file-reading process" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Note that we can clearly see what went wrong. If someone, for some reason, deletes or renames the used method, this test will fail. Even if the function exists, we expect to see a specific result that validates the job of the module.</p><p class="calibre7">Now, we have to start writing the actual code of the application. We should make the test passing. Place the following code in <code class="email">app.js</code>:</p><div class="informalexample"><pre class="programlisting">module.exports = {
  read: function(filePath) {

  }
}</pre></div><p class="calibre7">If we run the test, it will<a id="id458" class="calibre1"/> fail but for another reason, and that's because there is no logic inside the <code class="email">read</code> method. The following screenshot is the result in the console:</p><div class="mediaobject"><img src="../images/00044.jpeg" alt="Testing the file-reading process" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">This time the <code class="email">read</code> method is defined, but it doesn't return anything and <code class="email">expect(content).toBe("The quick brown fox jumps over the lazy dog.")</code> fails. Let's read <code class="email">file.txt</code> with the Node.js file API and return its content:</p><div class="informalexample"><pre class="programlisting">var fs = require('fs');
module.exports = {
  read: function(filePath) {
    return fs.readFileSync(filePath).toString();
  }
}</pre></div><p class="calibre7">Now, the color of the test is in green, which indicates that the module has the method we used and that method returns what we expect, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00045.jpeg" alt="Testing the file-reading process" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Using Jasmine">
<div class="book" title="Finding strings in the file content"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_5"><a id="ch09lvl2sec65" class="calibre1"/>Finding strings in the file content</h2></div></div></div><p class="calibre7">By using the same<a id="id459" class="calibre1"/> methodology, we will implement the second part of our<a id="id460" class="calibre1"/> application: finding words inside the file. The following is the new <code class="email">describe</code> block, which we will start with the following code:</p><div class="informalexample"><pre class="programlisting">describe("Testing if the file contains certain words", function() {
  it("should contains 'brown'", function(done) {
    var app = require("../app.js");
    var found = app.check("brown", "The quick brown fox jumps over the lazy dog.");
    expect(found).toBe(true);
    done();
  });
});</pre></div><p class="calibre7">We require a <code class="email">check</code> method that accepts two arguments. The first one is the word we want to find, and the second one is the string that will contain it. Note that we are not using the <code class="email">read</code> method. The idea is to test the function separately and guarantee that it works properly. This is a very important step because it makes our <code class="email">check</code> method universal. It is not bound to the idea of matching the text inside a file; however, it does match the text inside a string. If we don't use the test-driven workflow, we may end up with one function that does both the operations: reading the file and scanning its content. However, in our case, we can use the same module with the text fetched from a database or via an HTTP request. And, if we find that our module doesn't find a particular word, we will know that the problem lies in the <code class="email">check</code> function because it is tested as separate unit.</p><p class="calibre7">The following is the code of the new method:</p><div class="informalexample"><pre class="programlisting">var fs = require('fs');
module.exports = {
  read: function(filePath) {
    return fs.readFileSync(filePath).toString();
  },
  check: function(word, content) {
    return content.indexOf(word) &gt;= 0 ? true : false;
  }
}</pre></div><p class="calibre7">The test is now passed with three assertions as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00046.jpeg" alt="Finding strings in the file content" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Using Jasmine">
<div class="book" title="Writing an integration test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_6"><a id="ch09lvl2sec66" class="calibre1"/>Writing an integration test</h2></div></div></div><p class="calibre7">The tests we have <a id="id461" class="calibre1"/>written so <a id="id462" class="calibre1"/>far were unit tests, that is, they tested the two units of our application. Now, let's add an integration test. Again, we need a failing test that uses the module. So, we are starting with the following code:</p><div class="informalexample"><pre class="programlisting">describe("Testing the whole module", function() {
  it("read the file and search for 'lazy'", function(done) {
    var app = require("../app.js");
    app.read("./file.txt")
    expect(app.check("lazy")).toBe(true);
    done();
  });
});</pre></div><p class="calibre7">Note that we are not keeping the content of the file in a temporary variable, and we are not passing it to the <code class="email">check</code> method. In fact, we are not interested in the actual content of the file. We are interested only if it contains a specific string. So, our module should handle this and keep the text in it. The preceding test fails and the following message is displayed:</p><div class="mediaobject"><img src="../images/00047.jpeg" alt="Writing an integration test" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The following are the changes needed to make <code class="email">app.js</code> work as we want it to:</p><div class="informalexample"><pre class="programlisting">var fs = require('fs');
module.exports = {
  fileContent: '',
  read: function(filePath) {
    var content = fs.readFileSync(filePath).toString();
    this.fileContent = content;
    return content;
  },
  check: function(word, content) {
    content = content || this.fileContent;
    return content.indexOf(word) &gt;= 0 ? true : false;
  }
}</pre></div><p class="calibre7">We will <a id="id463" class="calibre1"/>simply store the text in a local variable named <code class="email">fileContent</code>. Note that <a id="id464" class="calibre1"/>we are making changes carefully and keeping the return logic of the <code class="email">read</code> method. This is needed because there is a test that requires this functionality. This shows one more benefit of TDD. We ensure that the code, before including our modifications, works in its original form. In complex systems or applications, this is extremely important, and without tests, this will be really difficult to achieve. The final result is again a screenshot with a green message:</p><div class="mediaobject"><img src="../images/00048.jpeg" alt="Writing an integration test" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Testing with Mocha"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec64" class="calibre1"/>Testing with Mocha</h1></div></div></div><p class="calibre7">Mocha<a id="id465" class="calibre1"/> is a little more advanced testing framework than Jasmine. It is more configurable, supports TDD or BDD testing, and even has several types of reporters. It is also quite popular and portable for client-side usage in the browser, which makes it a good candidate for our testing.</p></div>

<div class="book" title="Testing with Mocha">
<div class="book" title="Installation"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec67" class="calibre1"/>Installation</h2></div></div></div><p class="calibre7">Similar to Jasmine, we need the Node.js's package manager to install Mocha. By running the following command, the framework will be set up globally:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm install -g mocha</strong></span>
</pre></div><p class="calibre7">Once the installation <a id="id466" class="calibre1"/>finishes, we can run <code class="email">mocha ./tests</code>. By default, the tool searches for <a id="id467" class="calibre1"/>JavaScript files and tries to run them. Here, let's use the same example used with Jasmine and pass it through Mocha. It actually uses the same syntax of the <code class="email">describe</code> and <code class="email">it</code> blocks. However, it doesn't come with its own assertion library. In fact, there is a built-in Node.js module for such purposes named <code class="email">assert</code>. There are also libraries developed by other developers, for example, <code class="email">should.js</code>, <code class="email">chai</code>, or <code class="email">expect.js</code>. </p><p class="calibre7">They differ in certain aspects but do the same job: checking actual and expected values and raising an error if they don't match. After that, the framework catches the error and displays the results.</p></div></div>

<div class="book" title="Testing with Mocha">
<div class="book" title="Translating our example using Mocha"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec68" class="calibre1"/>Translating our example using Mocha</h2></div></div></div><p class="calibre7">If we run the <a id="id468" class="calibre1"/>same tests with <code class="email">mocha ./tests</code>, we will get the following result:</p><div class="mediaobject"><img src="../images/00049.jpeg" alt="Translating our example using Mocha" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The tests fail because there is no assertion library, that is, the <code class="email">expect</code> function is not available. Let's use the default <code class="email">assert</code> module of Node.js as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">var assert = require("assert");
describe("Testing the reading of the file's content.", function() {
  it("should create an instance of app.js", function(done) {
    var app = require("../app.js");
    if(typeof app == "undefined") {
      assert.fail('undefined', 'object');
    }
    done();
  });
  it("should read the file", function(done) {
    var app = require("../app.js");
    var content = app.read("./file.txt");
    assert.equal(content, "The quick brown fox jumps over the lazy dog.");
    done();
  });
});</pre></div><p class="calibre7">Everything is the same but the <code class="email">expect</code> module calls are replaced with <code class="email">assert.equal</code>. We used <code class="email">assert.fail</code> to notify the framework that there is something wrong. The following are the other <code class="email">describe</code> blocks:</p><div class="informalexample"><pre class="programlisting">describe("Testing if the file contains certain words", function() {
  it("should contains 'brown'", function(done) {
    var app = require("../app.js");
    var found = app.check("brown", "The quick brown fox jumps over the lazy dog.");
    assert.equal(found, true);
    done();
  });
});
describe("Testing the whole module", function() {
  it("read the file and search for 'lazy'", function(done) {
    var app = require("../app.js");
    app.read("./file.txt")
    assert.equal(app.check("lazy"), true);
    done();
  });
});</pre></div><p class="calibre7">With the latest <a id="id469" class="calibre1"/>changes, the tests should pass and we should see the following screenshot:</p><div class="mediaobject"><img src="../images/00050.jpeg" alt="Translating our example using Mocha" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div class="book" title="Testing with Mocha">
<div class="book" title="Selecting a reporter"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_3"><a id="ch09lvl2sec69" class="calibre1"/>Selecting a reporter</h2></div></div></div><p class="calibre7">Mocha is quite flexible <a id="id470" class="calibre1"/>when we talk about reporters. The reporter is the part of the <a id="id471" class="calibre1"/>framework that displays the results on the screen. There are a dozen of options we can choose from. To set the type of the reporter, we should use the <code class="email">-R</code> option in the command line, for example, the closest thing to Jasmine's reporter is the <code class="email">dot</code> type, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00051.jpeg" alt="Selecting a reporter" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">To see more detailed information about the passed or failed tests, we can use the <code class="email">spec</code> reporter as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00052.jpeg" alt="Selecting a reporter" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">There is also a<a id="id472" class="calibre1"/> reporter that looks like a landing plane (the <code class="email">landing</code> type) as shown in the <a id="id473" class="calibre1"/>following screenshot:</p><div class="mediaobject"><img src="../images/00053.jpeg" alt="Selecting a reporter" class="calibre10"/></div><p class="calibre11"> </p></div></div>

<div id="page" style="height:0pt"/><div class="book" title="Testing with a headless browser"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec65" class="calibre1"/>Testing with a headless browser</h1></div></div></div><p class="calibre7">So far we learned how to <a id="id474" class="calibre1"/>test our code. We can write a module, class, or library, and if it has an API, we can test it. However, if we need to test a user interface, it gets a little bit complex. Frameworks such as Jasmine and Mocha can run the code we write but can't visit a page, click a button, or send a form; at least, not alone. For such testing, we need to use a headless browser. A headless browser is a web browser without a user interface. There is a way to control it programmatically and perform actions such as accessing DOM elements, clicking on links, and filling forms. We are able to do the same things as we use a real browser. This gives us a really nice instrument to test the user interface. In the next few pages, we will see how to use a headless browser.</p></div>

<div class="book" title="Testing with a headless browser">
<div class="book" title="Writing the subject of our test"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_1"><a id="ch09lvl2sec70" class="calibre1"/>Writing the subject of our test</h2></div></div></div><p class="calibre7">In order to explore the<a id="id475" class="calibre1"/> possibilities<a id="id476" class="calibre1"/> of such testing, we need a simple site. Let's create two pages. The first one will contain an input field and a button. The second page will be visited when the button on the first one is clicked. The page's <code class="email">h1</code> tag title will change depending on the text written in the field. Create a new directory and insert the following code in the <code class="email">app.js</code> file:</p><div class="informalexample"><pre class="programlisting">var http = require('http');
var url = require('url');
var port = 3000;
var pageA = '\
  &lt;h1&gt;First page&lt;/h1&gt;\
  &lt;form&gt;\
    &lt;input type="text" name="title" /&gt;\
    &lt;input type="submit" /&gt;\
  &lt;/form&gt;\
';
var pageB = '\
  &lt;h1&gt;{title}&lt;/h1&gt;\
  &lt;a href="/"&gt;back&lt;/a&gt;\
';
http.createServer(function (req, res) {
  var urlParts = url.parse(req.url, true);
  var query = urlParts.query;
  res.writeHead(200, {'Content-Type': 'text/html'});
  if(query.title) {
    res.end(pageB.replace('{title}', query.title));
  } else {
    res.end(pageA);
  }
}).listen(port, '127.0.0.1');
console.log('Server running at http://127.0.0.1:' + port);</pre></div><p class="calibre7">We need only<a id="id477" class="calibre1"/> two of<a id="id478" class="calibre1"/> the Node.js native modules to launch our server. The <code class="email">http</code> module runs the server, and the <code class="email">url</code> module gets the <code class="email">GET</code> parameters from the URL. The markup of the pages is stored in simple variables. There is a check in the handler of the HTTP request, which serves <code class="email">pageB</code> if the form on <code class="email">pageA</code> is submitted. If we run the server with <code class="email">node app.js</code>, we will see how the pages look, as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00054.jpeg" alt="Writing the subject of our test" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Note that the text entered in the text field is set as the title of the second page. There is also a <span class="strong"><strong class="calibre8">back</strong></span> button we can use to return to the home page. We have a subject to run our tests on. We'll <a id="id479" class="calibre1"/>define<a id="id480" class="calibre1"/> the actions we need to verify as follows:</p><div class="book"><ul class="itemizedlist"><li class="listitem">Is the page properly rendered? We should check whether the tags of <code class="email">pageA</code> are actually on the page.</li><li class="listitem">We should add some string to the text field and submit the form.</li><li class="listitem">The title of the newly loaded page should match the text that we entered.</li><li class="listitem">We should be able to click on the <span class="strong"><strong class="calibre8">back</strong></span> button and return to the home page.</li></ul></div></div></div>

<div class="book" title="Testing with a headless browser">
<div class="book" title="Testing with PhantomJS"><div class="book"><div class="book"><div class="book"><h2 class="title1" id="calibre_pb_2"><a id="ch09lvl2sec71" class="calibre1"/>Testing with PhantomJS</h2></div></div></div><p class="calibre7">We know how our application is suppose to work, so let's write the tests. The headless browser we will use is <a id="id481" class="calibre1"/>
<span class="strong"><strong class="calibre8">PhantomJS</strong></span>. Visit <a class="calibre1" href="http://phantomjs.org">http://phantomjs.org</a> and <a id="id482" class="calibre1"/>download the package suitable for your operating system. Like <a id="id483" class="calibre1"/>we did for Node.js, we will write our test in a JavaScript file and run it at the command line. Let's say that our file structure looks like the following diagram:</p><div class="mediaobject"><img src="../images/00055.jpeg" alt="Testing with PhantomJS" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Keep in mind that PhantomJS is not a Node.js module. The JavaScript code we write for PhantomJS is not exactly a valid Node.js code. We can't directly use native modules such as <code class="email">assert</code>. Also, there isn't a test runner or test framework integrated. It's a browser based on <span class="strong"><strong class="calibre8">Webkit</strong></span><a id="id484" class="calibre1"/> but controlled from the command line or via the code. It comes across as binary, and once it is installed, we will be able to run the <code class="email">phantom ./tests/phantom.js</code> command in our terminal. The test code will open <code class="email">http://127.0.0.1:3000</code> and will interact with the pages there. Of course, the JavaScript community developed tools to combine testing frameworks such as Jasmine or Mocha with PhantomJS, but we are not going to use them in this chapter. We will write our own small utility—that's what the <code class="email">framework.js</code> file is for.</p><div class="book" title="Developing the micro testing framework"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec01" class="calibre1"/>Developing the micro testing framework</h3></div></div></div><p class="calibre7">The final result should be a <a id="id485" class="calibre1"/>simple function ready to use, such as <code class="email">describe</code> or <code class="email">it</code>, in <a id="id486" class="calibre1"/>Jasmine. It should also have something similar to the assertion library so we don't have to use the usual <code class="email">if-else</code> statements or report the failing test manually. In the following code, we can see the proper implementation:</p><div class="informalexample"><pre class="programlisting">var test = function(description, callback) {
  console.log(description);
  callback(function(subject) {
    return {
      toBe: function(value) {
        if(subject !== value) {
          console.log("! Expect '" + subject + "' to be '" + value + "'.")
        }
      },
      toBeDefined: function() {
        if(typeof subject === 'undefined') {
          console.log("! Expect '" + subject + "' to be defined")
          }
      }
    }
  });
}</pre></div><p class="calibre7">The function accepts description and function. The first argument is just printed out to the console, which indicates what we are going to test. Just after that, we call the passed <code class="email">callback</code> function with another function as the parameter, which plays the role of an assertion library. It accepts the subject of testing and executes two methods against it: <code class="email">toBe</code> and <code class="email">toBeDefined</code>. The following is a simple usage:</p><div class="informalexample"><pre class="programlisting">test("make a simple test", function(expect) {
  var variable = { property: 'value' };
  expect(true).toBe(true);
  expect(1).toBe(0);
  expect(variable.property).toBeDefined()
  expect(variable.missing).toBeDefined()
});</pre></div><p class="calibre7">If we run the preceding code, the result will be as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00056.jpeg" alt="Developing the micro testing framework" class="calibre10"/></div><p class="calibre11"> </p></div><div class="book" title="Understanding how PhantomJS works"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec02" class="calibre1"/>Understanding how PhantomJS works</h3></div></div></div><p class="calibre7">PhantomJS accepts instructions<a id="id487" class="calibre1"/> written in JavaScript. We can save them to a file and execute them via the command line by using the <code class="email">phantom</code> command. Let's look at the following code snippet:</p><div class="informalexample"><pre class="programlisting">var page = require('webpage').create();
var url = 'http://127.0.0.1:3000';
page.onConsoleMessage = function(msg) {
  // ...
};
page.onLoadFinished = function(status) {
  // ...
};
page.open(url);</pre></div><p class="calibre7">The <code class="email">page</code> variable is an access to the PhantomJS API. There is a method, <code class="email">open</code>, which loads a new page. We are mostly interested in two events dispatched from the headless browser. The first one, <code class="email">onConsoleMessage</code>, is fired when the loaded page uses the <code class="email">console</code> command, for example, <code class="email">console.log</code> or <code class="email">console.error</code>. The second event, <code class="email">onLoadFinished</code>, is also quite important. We have a function that is called when the page is loaded. That's the place where we should place our tests. Along with listening for events, we are going to use the following two other methods of PhantomJS:</p><div class="book"><ul class="itemizedlist"><li class="listitem"><code class="email">injectJs</code>: This method requires path to a file on our hard disk. The passed file is included on the page. We may also use <code class="email">includeJs</code> that does the same thing, but it loads the file from an external source.</li><li class="listitem"><code class="email">Evaluate</code>: This <a id="id488" class="calibre1"/>method accepts a function that is executed in the context of the currently loaded page. This is important because we need to check whether certain elements are in the DOM tree. We need to interact with them by filling in the text field and clicking on a button.</li></ul></div></div><div class="book" title="Writing the actual test"><div class="book"><div class="book"><div class="book"><h3 class="title2"><a id="ch09lvl3sec03" class="calibre1"/>Writing the actual test</h3></div></div></div><p class="calibre7">Before we start using<a id="id489" class="calibre1"/> PhantomJS, we need to run our application <a id="id490" class="calibre1"/>with <code class="email">node ./app.js</code>. By doing this, we are running a server that listens on a particular port. PhantomJS will make requests to that server. Now, let's start filling in the <code class="email">tests/phantom.js</code> file as follows:</p><div class="informalexample"><pre class="programlisting">var page = require('webpage').create();
var url = 'http://127.0.0.1:3000';
page.onConsoleMessage = function(msg) {
  console.log("\t" + msg);
};
page.onLoadFinished = function(status) {
  console.log("phantom: load finished");
  page.injectJs('./framework.js');
   phantom.exit();
};
page.open(url);</pre></div><p class="calibre7">As we have already<a id="id491" class="calibre1"/> discussed, we are able to create a <code class="email">page</code> variable and open a particular URL. In our case, we are using the address of the test application. The <code class="email">onConsoleMessage</code> listener just prints out the message to our terminal. When the page loads, we inject our micro unit testing framework. This means that we are able to call the <code class="email">test</code> function in the context of the page. If we run the script with <code class="email">phantom ./tests/phantom.js</code>, we will get the following result:</p><div class="mediaobject"><img src="../images/00057.jpeg" alt="Writing the actual test" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The preceding <a id="id492" class="calibre1"/>screenshot shows exactly what should happen. The browser goes to the page and fires <code class="email">onLoadFinished</code>. It's important to call <code class="email">phantom.exit()</code>; otherwise, PhantomJS's process will stay active.</p><p class="calibre7">The <code class="email">framework.js</code> file is injected to the page and we can write the first test, that is, to check whether the title contains <span class="strong"><strong class="calibre8">First page</strong></span>, fill in the test field, and submit the form:</p><div class="informalexample"><pre class="programlisting">page.onLoadFinished = function(status) {
  console.log("phantom: load finished");
  page.injectJs('./framework.js');
  page.evaluate(function() {
    test("should open the first page", function(expect) {
      expect(document).toBeDefined();
      expect(document.querySelector('h1').innerHTML).toBe('First page');
      document.querySelector('input[type="text"]').value = 'Phantom test';
      document.querySelector('form').submit();
    });
  });
  phantom.exit();
};</pre></div><p class="calibre7">The function that is executed by the <code class="email">evaluate</code> method is run in the context of the page, so it gets an access to the usual document object. We are able to use the <code class="email">getElementById</code>, <code class="email">querySelector</code>, or <code class="email">submit</code> methods. The script's result obtained now is as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00058.jpeg" alt="Writing the actual test" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">Now it gets interesting. Indeed, the form is submitted, but we immediately called <code class="email">phantom.exit()</code>, which<a id="id493" class="calibre1"/> terminates our script. If we remove it, the browser will stay<a id="id494" class="calibre1"/> active and the <code class="email">onLoadFinished</code> event will be fired again because a new page is successfully loaded. However, the script fails because there is no text field or a <code class="email">form</code> element on the next page. We need to evaluate another function. The following is one of the possible solutions:</p><div class="informalexample"><pre class="programlisting">var steps = [
  function() {
    test("should open the first page", function(expect) {
      expect(document).toBeDefined();
      expect(document.querySelector('h1').innerHTML).toBe('First page');
      document.querySelector('input[type="text"]').value = 'Phantom test';
      document.querySelector('form').submit();
    });
  },
  function() {
    test("should land on the second page", function(expect) {
      expect(document).toBeDefined();
      expect(document.querySelector('h1').innerHTML).toBe('Phantom test');
        var link = document.querySelector('a');
        var event = document.createEvent('MouseEvents');
        event.initMouseEvent('click', true, true, window, 1, 0, 0);
        link.dispatchEvent(event);
    });
  },
  function() {
    test("should return to the home page", function(expect) {
      expect(document.querySelector('h1').innerHTML).toBe('First page');
    });
  }
];
page.onLoadFinished = function(status) {
  console.log("phantom: load finished");
  page.injectJs('./framework.js');
  page.evaluate(steps.shift());
  if(steps.length == 0) {
    console.log("phantom: browser terminated");
    phantom.exit();
  }
};</pre></div><p class="calibre7">The <code class="email">steps</code> array is a global variable that contains a series of functions that need to be evaluated. On every <code class="email">onLoadFinished</code> event, we are fetching one of those functions until the <code class="email">steps</code> array is empty. This is where we call <code class="email">phantom.exit()</code> as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00059.jpeg" alt="Writing the actual test" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">PhantomJS opens<a id="id495" class="calibre1"/> the home page. It enters <span class="strong"><strong class="calibre8">Phantom test</strong></span> in the text field and submits the<a id="id496" class="calibre1"/> form. Then, on the next page, it checks whether the title contains the valid value, and when you click on the <span class="strong"><strong class="calibre8">back link</strong></span> button, it loads the previous page again.</p></div></div></div>
<div class="book" title="Testing with DalekJS"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec66" class="calibre1"/>Testing with DalekJS</h1></div></div></div><p class="calibre7">So far we learned how to test <a id="id497" class="calibre1"/>our JavaScript code. After that, we found out how to write user interface tests with Phantom.js. All these are really helpful, but it will be even better if we are able to run a real browser and control it. With DalekJS, this is possible. It's a really nice Node.js module that comes with a command-line interface tool and submodules for major browsers such as Google Chrome, Firefox, and Internet Explorer.</p><p class="calibre7">Let's see how everything works and install the command-line tool of DalekJS using the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">npm install -g dalek-cli</strong></span>
</pre></div><p class="calibre7">After running the preceding command, we will have the <code class="email">dalek</code> command set up in our terminal. Let's copy the files used in the PhantomJS test and replace <code class="email">framework.js</code> with a <code class="email">package.json</code> file. We will also rename <code class="email">tests/phantom.js</code> to <code class="email">tests/dalek.js</code>. So, the following is the new file structure:</p><div class="mediaobject"><img src="../images/00060.jpeg" alt="Testing with DalekJS" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">The application we <a id="id498" class="calibre1"/>will use will be the same. DalekJS supports several browsers, including Google Chrome, so we will use it. Of course, we should have it installed on our system. The following code snippet shows how the <code class="email">package.json</code> file looks:</p><div class="informalexample"><pre class="programlisting">{
  "name": "project",
  "description": "description",
  "version": "0.0.1",
  "devDependencies": {
    "dalekjs": "*",
    "dalek-browser-chrome": "*"
  }
}</pre></div><p class="calibre7">A quick <code class="email">npm install</code> command will create the <code class="email">node_modules</code> directory with both dependencies included in it. DalekJS has a detailed documentation published on <a class="calibre1" href="http://dalekjs.com">http://dalekjs.com</a>. It states that we can load pages, fill forms, and click on different DOM elements. It also comes with its own testing API, so we don't have to think about this. The test we have to write is actually pretty short. The following is the content of <code class="email">tests/dalek.js</code>:</p><div class="informalexample"><pre class="programlisting">var url = 'http://127.0.0.1:3000';
var title = 'DalekJS test';
module.exports = {
  'should interact with the application': function (test) {
    test
    .open(url)
    .assert.text('h1', 'First page', 'The title is "First page"')
    .type('input[type="text"]', title)
    .submit('form')
    .assert.text('h1', title, 'The title is "' + title + '"')
    .click('a')
    .assert.text('h1', 'First page', 'We are again on the home page')
    .done()
  }
};</pre></div><p class="calibre7">Again, we will make a request to <code class="email">http://127.0.0.1:3000</code> and expect to see certain elements on the page. We will also enter some text inside the text field (the <code class="email">type</code> method) and submit the form (the <code class="email">submit</code> method). To run the test, we need to type in the following command:</p><div class="informalexample"><pre class="programlisting">
<span class="strong"><strong class="calibre8">dalek .\tests\dalek.js -b chrome</strong></span>
</pre></div><p class="calibre7">If we skip the <code class="email">-b</code> parameter, DalekJS will use Phantom.js. That's the default browser type of the library. When <a id="id499" class="calibre1"/>the preceding command is launched at the terminal, a new instance of the Google Chrome browser is opened. It executes what we defined in the test and closes the browser. In order to get the example working, we need to run the application by executing <code class="email">node ./app.js</code>. The result is reported to the console as shown in the following screenshot:</p><div class="mediaobject"><img src="../images/00061.jpeg" alt="Testing with DalekJS" class="calibre10"/></div><p class="calibre11"> </p><p class="calibre7">We can even make screenshots of the current browser's screenshot. It's simply calling the <code class="email">screenshot</code> API method as shown in the following code snippet:</p><div class="informalexample"><pre class="programlisting">test
.open(url)
.assert.text('h1', 'First page', 'The title is "First page"')
.type('input[type="text"]', title)
.submit('form')
.assert.text('h1', title, 'The title is "' + title + '"')
.screenshot('./screen.jpg')
.click('a')
.assert.text('h1', 'First page', 'We are again on the home page')
.done()</pre></div><p class="calibre7">In the preceding code, we are making a screenshot of the second page, the one that is loaded after the form is submitted.</p></div>
<div class="book" title="Summary"><div class="book"><div class="book"><div class="book"><h1 class="title" id="calibre_pb_0"><a id="ch09lvl1sec67" class="calibre1"/>Summary</h1></div></div></div><p class="calibre7">In this chapter, we saw how important testing is. Thankfully, there are great tools available in the Node.js ecosystem. Frameworks such as Jasmine and Mocha make our life easier. Instruments such as Phantom.js save a lot of time by automating the testing and putting our code in a browser context. With DalekJS, we can even run tests directly in Firefox, Google Chrome, or Internet Explorer.</p><p class="calibre7">In the next chapter, we will see how to write flexible and modular CSS. Node.js has few great modules oriented for the frontend developers who write a lot of CSS.</p></div></body></html>